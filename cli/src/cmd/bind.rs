use crate::cmd::Cmd;

use clap::{Parser, ValueHint};
use ethers::contract::Abigen;
use eyre::{bail, eyre, WrapErr};
use foundry_config::{
    figment::{
        self,
        error::Kind::InvalidType,
        value::{Dict, Map, Value},
        Figment, Metadata, Profile, Provider,
    },
    find_project_root_path, Config,
};
use serde::Serialize;
use std::{
    io::Write,
    path::{Path, PathBuf},
};

// Loads project's figment and merges the bind cli arguments into it
impl<'a> From<&'a BindArgs> for Figment {
    fn from(args: &'a BindArgs) -> Self {
        let root = match args.root.clone() {
            Some(root) => root,
            None => find_project_root_path().unwrap(),
        };

        Config::figment_with_root(root).merge(args)
    }
}

impl<'a> From<&'a BindArgs> for Config {
    fn from(args: &'a BindArgs) -> Self {
        let figment: Figment = args.into();
        Config::from_provider(figment).sanitized()
    }
}

#[derive(Debug, Clone, Parser, Serialize)]
pub struct BindArgs {
    #[clap(
        help = "The project's root path. By default, this is the root directory of the current Git repository or the current working directory if it is not part of a Git repository",
        long,
        value_hint = ValueHint::DirPath
    )]
    #[serde(skip)]
    pub root: Option<PathBuf>,

    #[clap(
        help = "Path to where the contract artifacts are stored",
        long = "out",
        short,
        value_hint = ValueHint::DirPath
    )]
    #[serde(rename = "out", skip_serializing_if = "Option::is_none")]
    pub out_path: Option<PathBuf>,

    #[clap(
        help = "A directory at which to write the generated rust crate",
        long = "crate-root",
        value_hint = ValueHint::DirPath
    )]
    #[serde(skip)]
    pub crate_root: Option<PathBuf>,

    #[clap(
        long = "crate-name",
        help = "The name of the rust crate to generate. This should be a valid crates.io crate name. However, it is not currently validated by this command."
    )]
    #[serde(skip)]
    crate_name: Option<String>,

    #[clap(
        long = "crate-version",
        help = "The version of the rust crate to generate. This should be a standard semver version string. However, it is not currently validated by this command."
    )]
    #[serde(skip)]
    crate_version: Option<String>,
}

impl BindArgs {
    /// Get the path to the foundry artifacts directory
    fn artifacts(&self) -> PathBuf {
        let c: Config = self.into();
        c.out
    }

    /// Get the path to the root of the autogenerated crate
    pub fn crate_root(&self) -> PathBuf {
        self.crate_root.clone().unwrap_or_else(|| {
            let mut path = self.artifacts();
            path.push("bindings");
            path
        })
    }

    /// Get the name of the autogenerated crate
    pub fn crate_name(&self) -> String {
        self.crate_name.clone().unwrap_or_else(|| "foundry-contracts".to_owned())
    }

    /// Get the version of the autogenerated crate
    pub fn crate_version(&self) -> String {
        self.crate_version.clone().unwrap_or_else(|| "0.0.1".to_owned())
    }

    pub fn crate_src_dir(&self) -> PathBuf {
        let mut src_dir = self.crate_root();
        src_dir.push("src");
        src_dir
    }

    // derive the file path of generated contract binding files
    fn contract_binding_path(&self, contract: &str) -> PathBuf {
        let mut contract_file = contract.to_lowercase();
        contract_file.extend([".rs"]);

        let mut path = self.crate_src_dir();
        path.push(contract_file);
        path
    }

    // derive the file path of the generated `Cargo.toml`
    fn cargo_toml_path(&self) -> PathBuf {
        let mut path = self.crate_root();
        path.push("Cargo.toml");
        path
    }

    // derive the file path of the generated `lib.rs`
    fn lib_file_path(&self) -> PathBuf {
        let mut path = self.crate_src_dir();
        path.push("lib.rs");
        path
    }

    // Clean the contents of the binding directory
    fn clean_old_crate(&self) {
        // real lazy dir management. To ensure
        std::fs::create_dir_all(self.crate_root()).expect("could not create bindings dir");
        std::fs::remove_dir_all(self.crate_root()).expect("could not delete old bindings");
        std::fs::create_dir_all(self.crate_src_dir()).expect("could not create bindings src dir");
    }

    // Get a list of all directories that may contain built artifacts
    // Allow `*.sol`, then filter all `*.t.sol`
    fn get_directories(&self) -> eyre::Result<Vec<std::fs::DirEntry>> {
        // get a list of all artifact directories
        Ok(std::fs::read_dir(self.artifacts())
            .wrap_err_with(||
                format!(
                    "Error attempting to read artifact directories at {}.\nHint: are you in a foundry project?",
                    self.artifacts().to_str().unwrap()
                ),
            )?
            .filter_map(Result::ok)
            .filter(|e| e.file_type().unwrap().is_dir())
            .filter(|e| e.file_name().into_string().unwrap().ends_with(".sol"))
            .filter(|e| !e.file_name().into_string().unwrap().ends_with(".t.sol"))
            .collect())
    }

    // Get the path to a contract's json artifact from the directory that
    // contains it, if any exists.
    fn get_contract_artifact(&self, dir: &std::fs::DirEntry) -> Option<PathBuf> {
        let dir_name = dir.file_name().into_string().unwrap();
        let mut contract = dir_name.split(".").next().unwrap().to_owned();
        contract.extend([".json"]);
        let mut contract_json_path = dir.path();

        contract_json_path.push(contract);

        if !contract_json_path.exists() {
            return None
        }

        Some(contract_json_path)
    }

    // Generate and write each contract binding file
    fn generate_binding(&self, contract_json_path: &Path) -> eyre::Result<String> {
        let contract = contract_json_path.file_stem().unwrap().to_owned().into_string().unwrap();

        let bindings =
            Abigen::new(&contract, contract_json_path.to_str().expect("valid utf8 path"))
                .map_err(|e| eyre!(e))?
                .generate()
                .map_err(|e| eyre!(e))?;

        bindings.write_to_file(self.contract_binding_path(&contract)).map_err(|e| eyre!(e))?;
        Ok(contract)
    }

    // generate and write the contents of `Cargo.toml`
    fn generate_cargo_toml(&self) -> eyre::Result<()> {
        let mut toml_file =
            std::fs::File::create(&self.cargo_toml_path()).expect("could not create libfile");

        writeln!(toml_file, "[package]")?;
        writeln!(toml_file, r#"name = "{}""#, self.crate_name())?;
        writeln!(toml_file, r#"version = "{}""#, self.crate_version())?;
        writeln!(toml_file, r#"edition = "2021""#)?;
        writeln!(toml_file)?;
        writeln!(toml_file, "# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html")?;
        writeln!(toml_file)?;
        writeln!(toml_file, "[dependencies]")?;
        writeln!(
            toml_file,
            r#"ethers = {{ git = "https://github.com/gakonst/ethers-rs", default-features = false }}"#
        )?;

        Ok(())
    }

    // generate and write the contents of `src/lib.rs`
    fn generate_lib_rs(&self, mut contracts: Vec<String>) -> eyre::Result<()> {
        let lib_path = self.lib_file_path();

        let mut lib_file = std::fs::File::create(&lib_path).expect("could not create libfile");
        writeln!(lib_file, "#![allow(clippy::all)]")?;
        writeln!(lib_file, "//! This is autogenerated code.")?;
        writeln!(lib_file, "//! Do not manually edit these files.")?;
        writeln!(
            lib_file,
            "//! These files may be overwritten by the codegen system at any time."
        )?;
        writeln!(lib_file)?;

        // generate modfile in happy alphabetical order
        contracts.sort();
        for contract in contracts.into_iter() {
            writeln!(lib_file, "/// ethers-rs contract bindings for {}", contract)?;
            writeln!(lib_file, "pub mod {};", contract.to_lowercase())?;
        }

        Ok(())
    }

    // generate the crate
    fn generate_crate(&self) -> eyre::Result<()> {
        // TODO: consider generating the new crate in a tmp dir, then copying
        // to the correct location on success
        self.clean_old_crate();

        let directories = self.get_directories()?;
        if directories.is_empty() {
            bail!(
                "No contract artifacts found.\nHint: have you run forge build?
            "
            );
        }

        let mut contracts = vec![];
        for dir in directories.iter() {
            if let Some(c) = self.get_contract_artifact(dir) {
                let res = self.generate_binding(&c);
                match res {
                    Ok(contract_name) => contracts.push(contract_name),
                    Err(e) => {
                        self.clean_old_crate();
                        bail!(e);
                    }
                }
            }
        }

        self.generate_cargo_toml().wrap_err("Error generating Cargo.toml")?;
        self.generate_lib_rs(contracts).wrap_err("Error generating lib.rs")?;
        Ok(())
    }
}

impl Cmd for BindArgs {
    type Output = ();

    fn run(self) -> eyre::Result<Self::Output> {
        if let Err(e) = self.generate_crate() {
            println!("An error occurred. Cleaning partially-generated crate.");
            self.clean_old_crate();
            bail!(e)
        }

        println!("Bindings have been output to {}", self.crate_root().to_str().unwrap());
        Ok(())
    }
}

// Make this args a `figment::Provider` so that it can be merged into the `Config`
impl Provider for BindArgs {
    fn metadata(&self) -> Metadata {
        Metadata::named("Bind Args Provider")
    }

    fn data(&self) -> Result<Map<Profile, Dict>, figment::Error> {
        let value = Value::serialize(self)?;
        let error = InvalidType(value.to_actual(), "map".into());
        let dict = value.into_dict().ok_or(error)?;
        Ok(Map::from([(Config::selected_profile(), dict)]))
    }
}
