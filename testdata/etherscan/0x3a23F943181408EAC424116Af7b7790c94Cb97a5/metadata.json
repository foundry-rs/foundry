[{"SourceCode":{"language":"Solidity","sources":{"src/bridges/hop/interfaces/amm.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/**\n * @title HopAMM\n * @notice Interface to handle the token bridging to L2 chains.\n */\ninterface HopAMM {\n    /**\n     * @notice To send funds L2->L1 or L2->L2, call the swapAndSend on the L2 AMM Wrapper contract\n     * @param chainId chainId of the L2 contract\n     * @param recipient receiver address\n     * @param amount amount is the amount the user wants to send plus the Bonder fee\n     * @param bonderFee fees\n     * @param amountOutMin minimum amount\n     * @param deadline deadline for bridging\n     * @param destinationAmountOutMin minimum amount expected to be bridged on L2\n     * @param destinationDeadline destination time before which token is to be bridged on L2\n     */\n    function swapAndSend(\n        uint256 chainId,\n        address recipient,\n        uint256 amount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 deadline,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline\n    ) external payable;\n}\n"},"src/swap/oneinch/OneInchImpl.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport \"../SwapImplBase.sol\";\nimport {SwapFailed} from \"../../errors/SocketErrors.sol\";\nimport {ONEINCH} from \"../../static/RouteIdentifiers.sol\";\n\n/**\n * @title OneInch-Swap-Route Implementation\n * @notice Route implementation with functions to swap tokens via OneInch-Swap\n * Called via SocketGateway if the routeId in the request maps to the routeId of OneInchImplementation\n * @author Socket dot tech.\n */\ncontract OneInchImpl is SwapImplBase {\n    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens\n    using SafeTransferLib for ERC20;\n\n    bytes32 public immutable OneInchIdentifier = ONEINCH;\n\n    /// @notice address of OneInchAggregator to swap the tokens on Chain\n    address public immutable ONEINCH_AGGREGATOR;\n\n    /// @notice socketGatewayAddress to be initialised via storage variable SwapImplBase\n    /// @dev ensure _oneinchAggregator are set properly for the chainId in which the contract is being deployed\n    constructor(\n        address _oneinchAggregator,\n        address _socketGateway,\n        address _socketDeployFactory\n    ) SwapImplBase(_socketGateway, _socketDeployFactory) {\n        ONEINCH_AGGREGATOR = _oneinchAggregator;\n    }\n\n    /**\n     * @notice function to swap tokens on the chain and transfer to receiver address\n     *         via OneInch-Middleware-Aggregator\n     * @param fromToken token to be swapped\n     * @param toToken token to which fromToken has to be swapped\n     * @param amount amount of fromToken being swapped\n     * @param receiverAddress address of toToken recipient\n     * @param swapExtraData encoded value of properties in the swapData Struct\n     * @return swapped amount (in toToken Address)\n     */\n    function performAction(\n        address fromToken,\n        address toToken,\n        uint256 amount,\n        address receiverAddress,\n        bytes calldata swapExtraData\n    ) external payable override returns (uint256) {\n        uint256 returnAmount;\n\n        if (fromToken != NATIVE_TOKEN_ADDRESS) {\n            ERC20 token = ERC20(fromToken);\n            token.safeTransferFrom(msg.sender, socketGateway, amount);\n            token.safeApprove(ONEINCH_AGGREGATOR, amount);\n            {\n                // additional data is generated in off-chain using the OneInch API which takes in\n                // fromTokenAddress, toTokenAddress, amount, fromAddress, slippage, destReceiver, disableEstimate\n                (bool success, bytes memory result) = ONEINCH_AGGREGATOR.call(\n                    swapExtraData\n                );\n                token.safeApprove(ONEINCH_AGGREGATOR, 0);\n\n                if (!success) {\n                    revert SwapFailed();\n                }\n\n                returnAmount = abi.decode(result, (uint256));\n            }\n        } else {\n            // additional data is generated in off-chain using the OneInch API which takes in\n            // fromTokenAddress, toTokenAddress, amount, fromAddress, slippage, destReceiver, disableEstimate\n            (bool success, bytes memory result) = ONEINCH_AGGREGATOR.call{\n                value: amount\n            }(swapExtraData);\n            if (!success) {\n                revert SwapFailed();\n            }\n            returnAmount = abi.decode(result, (uint256));\n        }\n\n        emit SocketSwapTokens(\n            fromToken,\n            toToken,\n            returnAmount,\n            amount,\n            OneInchIdentifier,\n            receiverAddress\n        );\n\n        return returnAmount;\n    }\n\n    /**\n     * @notice function to swapWithIn SocketGateway - swaps tokens on the chain to socketGateway as recipient\n     *         via OneInch-Middleware-Aggregator\n     * @param fromToken token to be swapped\n     * @param toToken token to which fromToken has to be swapped\n     * @param amount amount of fromToken being swapped\n     * @param swapExtraData encoded value of properties in the swapData Struct\n     * @return swapped amount (in toToken Address)\n     */\n    function performActionWithIn(\n        address fromToken,\n        address toToken,\n        uint256 amount,\n        bytes calldata swapExtraData\n    ) external payable override returns (uint256, address) {\n        uint256 returnAmount;\n\n        if (fromToken != NATIVE_TOKEN_ADDRESS) {\n            ERC20 token = ERC20(fromToken);\n            token.safeTransferFrom(msg.sender, socketGateway, amount);\n            token.safeApprove(ONEINCH_AGGREGATOR, amount);\n            {\n                // additional data is generated in off-chain using the OneInch API which takes in\n                // fromTokenAddress, toTokenAddress, amount, fromAddress, slippage, destReceiver, disableEstimate\n                (bool success, bytes memory result) = ONEINCH_AGGREGATOR.call(\n                    swapExtraData\n                );\n                token.safeApprove(ONEINCH_AGGREGATOR, 0);\n\n                if (!success) {\n                    revert SwapFailed();\n                }\n\n                returnAmount = abi.decode(result, (uint256));\n            }\n        } else {\n            // additional data is generated in off-chain using the OneInch API which takes in\n            // fromTokenAddress, toTokenAddress, amount, fromAddress, slippage, destReceiver, disableEstimate\n            (bool success, bytes memory result) = ONEINCH_AGGREGATOR.call{\n                value: amount\n            }(swapExtraData);\n            if (!success) {\n                revert SwapFailed();\n            }\n            returnAmount = abi.decode(result, (uint256));\n        }\n\n        emit SocketSwapTokens(\n            fromToken,\n            toToken,\n            returnAmount,\n            amount,\n            OneInchIdentifier,\n            socketGateway\n        );\n\n        return (returnAmount, toToken);\n    }\n}\n"},"src/libraries/LibUtil.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./LibBytes.sol\";\n\n/// @title LibUtil library\n/// @notice library with helper functions to operate on bytes-data and addresses\n/// @author socket dot tech\nlibrary LibUtil {\n    /// @notice LibBytes library to handle operations on bytes\n    using LibBytes for bytes;\n\n    /// @notice function to extract revertMessage from bytes data\n    /// @dev use the revertMessage and then further revert with a custom revert and message\n    /// @param _res bytes data received from the transaction call\n    function getRevertMsg(\n        bytes memory _res\n    ) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_res.length < 68) {\n            return \"Transaction reverted silently\";\n        }\n        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes\n        return abi.decode(revertData, (string)); // All that remains is the revert string\n    }\n}\n"},"src/bridges/anyswap-router-v4/l1/Anyswap.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {BridgeImplBase} from \"../../BridgeImplBase.sol\";\nimport {ANYSWAP} from \"../../../static/RouteIdentifiers.sol\";\n\n/**\n * @title Anyswap-V4-Route L1 Implementation\n * @notice Route implementation with functions to bridge ERC20 via Anyswap-Bridge\n * Called via SocketGateway if the routeId in the request maps to the routeId of AnyswapImplementation\n * This is the L1 implementation, so this is used when transferring from l1 to supported l1s or L1.\n * Contains function to handle bridging as post-step i.e linked to a preceeding step for swap\n * RequestData is different to just bride and bridging chained with swap\n * @author Socket dot tech.\n */\n\n/// @notice Interface to interact with AnyswapV4-Router Implementation\ninterface AnyswapV4Router {\n    function anySwapOutUnderlying(\n        address token,\n        address to,\n        uint256 amount,\n        uint256 toChainID\n    ) external;\n}\n\ncontract AnyswapImplL1 is BridgeImplBase {\n    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens\n    using SafeTransferLib for ERC20;\n\n    bytes32 public immutable AnyswapIdentifier = ANYSWAP;\n\n    /// @notice Function-selector for ERC20-token bridging on Anyswap-Route\n    /// @dev This function selector is to be used while buidling transaction-data to bridge ERC20 tokens\n    bytes4 public immutable ANYSWAP_L1_ERC20_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeERC20To(uint256,uint256,bytes32,address,address,address)\"\n            )\n        );\n\n    bytes4 public immutable ANYSWAP_SWAP_BRIDGE_SELECTOR =\n        bytes4(\n            keccak256(\n                \"swapAndBridge(uint32,bytes,(uint256,address,address,bytes32))\"\n            )\n        );\n\n    /// @notice AnSwapV4Router Contract instance used to deposit ERC20 on to Anyswap-Bridge\n    /// @dev contract instance is to be initialized in the constructor using the router-address passed as constructor argument\n    AnyswapV4Router public immutable router;\n\n    /**\n     * @notice Constructor sets the router address and socketGateway address.\n     * @dev anyswap 4 router is immutable. so no setter function required.\n     */\n    constructor(\n        address _router,\n        address _socketGateway,\n        address _socketDeployFactory\n    ) BridgeImplBase(_socketGateway, _socketDeployFactory) {\n        router = AnyswapV4Router(_router);\n    }\n\n    /// @notice Struct to be used in decode step from input parameter - a specific case of bridging after swap.\n    /// @dev the data being encoded in offchain or by caller should have values set in this sequence of properties in this struct\n    struct AnyswapBridgeDataNoToken {\n        /// @notice destination ChainId\n        uint256 toChainId;\n        /// @notice address of receiver of bridged tokens\n        address receiverAddress;\n        /// @notice address of wrapperToken, WrappedVersion of the token being bridged\n        address wrapperTokenAddress;\n        /// @notice socket offchain created hash\n        bytes32 metadata;\n    }\n\n    /// @notice Struct to be used in decode step from input parameter - a specific case of bridging after swap.\n    /// @dev the data being encoded in offchain or by caller should have values set in this sequence of properties in this struct\n    struct AnyswapBridgeData {\n        /// @notice destination ChainId\n        uint256 toChainId;\n        /// @notice address of receiver of bridged tokens\n        address receiverAddress;\n        /// @notice address of wrapperToken, WrappedVersion of the token being bridged\n        address wrapperTokenAddress;\n        /// @notice address of token being bridged\n        address token;\n        /// @notice socket offchain created hash\n        bytes32 metadata;\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from swapAndBridge, this function is called when the swap has already happened at a different place.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in AnyswapBridgeData struct\n     * @param amount amount of tokens being bridged. this can be ERC20 or native\n     * @param bridgeData encoded data for AnyswapBridge\n     */\n    function bridgeAfterSwap(\n        uint256 amount,\n        bytes calldata bridgeData\n    ) external payable override {\n        AnyswapBridgeData memory anyswapBridgeData = abi.decode(\n            bridgeData,\n            (AnyswapBridgeData)\n        );\n        ERC20(anyswapBridgeData.token).safeApprove(address(router), amount);\n        router.anySwapOutUnderlying(\n            anyswapBridgeData.wrapperTokenAddress,\n            anyswapBridgeData.receiverAddress,\n            amount,\n            anyswapBridgeData.toChainId\n        );\n\n        emit SocketBridge(\n            amount,\n            anyswapBridgeData.token,\n            anyswapBridgeData.toChainId,\n            AnyswapIdentifier,\n            msg.sender,\n            anyswapBridgeData.receiverAddress,\n            anyswapBridgeData.metadata\n        );\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from bridgeAfterSwap since this function holds the logic for swapping tokens too.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in AnyswapBridgeData struct\n     * @param swapId routeId for the swapImpl\n     * @param swapData encoded data for swap\n     * @param anyswapBridgeData encoded data for AnyswapBridge\n     */\n    function swapAndBridge(\n        uint32 swapId,\n        bytes calldata swapData,\n        AnyswapBridgeDataNoToken calldata anyswapBridgeData\n    ) external payable {\n        (bool success, bytes memory result) = socketRoute\n            .getRoute(swapId)\n            .delegatecall(swapData);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        (uint256 bridgeAmount, address token) = abi.decode(\n            result,\n            (uint256, address)\n        );\n\n        ERC20(token).safeApprove(address(router), bridgeAmount);\n        router.anySwapOutUnderlying(\n            anyswapBridgeData.wrapperTokenAddress,\n            anyswapBridgeData.receiverAddress,\n            bridgeAmount,\n            anyswapBridgeData.toChainId\n        );\n\n        emit SocketBridge(\n            bridgeAmount,\n            token,\n            anyswapBridgeData.toChainId,\n            AnyswapIdentifier,\n            msg.sender,\n            anyswapBridgeData.receiverAddress,\n            anyswapBridgeData.metadata\n        );\n    }\n\n    /**\n     * @notice function to handle ERC20 bridging to receipent via Anyswap-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param amount amount being bridged\n     * @param toChainId destination ChainId\n     * @param receiverAddress address of receiver of bridged tokens\n     * @param token address of token being bridged\n     * @param wrapperTokenAddress address of wrapperToken, WrappedVersion of the token being bridged\n     */\n    function bridgeERC20To(\n        uint256 amount,\n        uint256 toChainId,\n        bytes32 metadata,\n        address receiverAddress,\n        address token,\n        address wrapperTokenAddress\n    ) external payable {\n        ERC20 tokenInstance = ERC20(token);\n        tokenInstance.safeTransferFrom(msg.sender, socketGateway, amount);\n        tokenInstance.safeApprove(address(router), amount);\n        router.anySwapOutUnderlying(\n            wrapperTokenAddress,\n            receiverAddress,\n            amount,\n            toChainId\n        );\n\n        emit SocketBridge(\n            amount,\n            token,\n            toChainId,\n            AnyswapIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n}\n"},"src/bridges/cbridge/CelerStorageWrapper.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.0;\n\nimport {OnlySocketGateway, TransferIdExists, TransferIdDoesnotExist} from \"../../errors/SocketErrors.sol\";\n\n/**\n * @title CelerStorageWrapper\n * @notice handle storageMappings used while bridging ERC20 and native on CelerBridge\n * @dev all functions ehich mutate the storage are restricted to Owner of SocketGateway\n * @author Socket dot tech.\n */\ncontract CelerStorageWrapper {\n    /// @notice Socketgateway-address to be set in the constructor of CelerStorageWrapper\n    address public immutable socketGateway;\n\n    /// @notice mapping to store the transferId generated during bridging on Celer to message-sender\n    mapping(bytes32 => address) private transferIdMapping;\n\n    /// @notice socketGatewayAddress to be initialised via storage variable BridgeImplBase\n    constructor(address _socketGateway) {\n        socketGateway = _socketGateway;\n    }\n\n    /**\n     * @notice function to store the transferId and message-sender of a bridging activity\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in CelerBridgeData struct\n     * @param transferId transferId generated during the bridging of ERC20 or native on CelerBridge\n     * @param transferIdAddress message sender who is making the bridging on CelerBridge\n     */\n    function setAddressForTransferId(\n        bytes32 transferId,\n        address transferIdAddress\n    ) external {\n        if (msg.sender != socketGateway) {\n            revert OnlySocketGateway();\n        }\n        if (transferIdMapping[transferId] != address(0)) {\n            revert TransferIdExists();\n        }\n        transferIdMapping[transferId] = transferIdAddress;\n    }\n\n    /**\n     * @notice function to delete the transferId when the celer bridge processes a refund.\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in CelerBridgeData struct\n     * @param transferId transferId generated during the bridging of ERC20 or native on CelerBridge\n     */\n    function deleteTransferId(bytes32 transferId) external {\n        if (msg.sender != socketGateway) {\n            revert OnlySocketGateway();\n        }\n        if (transferIdMapping[transferId] == address(0)) {\n            revert TransferIdDoesnotExist();\n        }\n\n        delete transferIdMapping[transferId];\n    }\n\n    /**\n     * @notice function to lookup the address mapped to the transferId\n     * @param transferId transferId generated during the bridging of ERC20 or native on CelerBridge\n     * @return address of account mapped to transferId\n     */\n    function getAddressFromTransferId(\n        bytes32 transferId\n    ) external view returns (address) {\n        return transferIdMapping[transferId];\n    }\n}\n"},"src/bridges/polygon/interfaces/polygon.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/**\n * @title RootChain Manager Interface for Polygon Bridge.\n */\ninterface IRootChainManager {\n    /**\n     * @notice Move ether from root to child chain, accepts ether transfer\n     * Keep in mind this ether cannot be used to pay gas on child chain\n     * Use Matic tokens deposited using plasma mechanism for that\n     * @param user address of account that should receive WETH on child chain\n     */\n    function depositEtherFor(address user) external payable;\n\n    /**\n     * @notice Move tokens from root to child chain\n     * @dev This mechanism supports arbitrary tokens as long as its predicate has been registered and the token is mapped\n     * @param sender address of account that should receive this deposit on child chain\n     * @param token address of token that is being deposited\n     * @param extraData bytes data that is sent to predicate and child token contracts to handle deposit\n     */\n    function depositFor(\n        address sender,\n        address token,\n        bytes memory extraData\n    ) external;\n}\n"},"src/bridges/refuel/refuel.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./interfaces/refuel.sol\";\nimport \"../BridgeImplBase.sol\";\nimport {REFUEL} from \"../../static/RouteIdentifiers.sol\";\n\n/**\n * @title Refuel-Route Implementation\n * @notice Route implementation with functions to bridge Native via Refuel-Bridge\n * Called via SocketGateway if the routeId in the request maps to the routeId of RefuelImplementation\n * @author Socket dot tech.\n */\ncontract RefuelBridgeImpl is BridgeImplBase {\n    bytes32 public immutable RefuelIdentifier = REFUEL;\n\n    /// @notice refuelBridge-Contract address used to deposit Native on Refuel-Bridge\n    address public immutable refuelBridge;\n\n    /// @notice Function-selector for Native bridging via Refuel-Bridge\n    /// @dev This function selector is to be used while buidling transaction-data to bridge Native tokens\n    bytes4 public immutable REFUEL_NATIVE_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(keccak256(\"bridgeNativeTo(uint256,address,uint256,bytes32)\"));\n\n    bytes4 public immutable REFUEL_NATIVE_SWAP_BRIDGE_SELECTOR =\n        bytes4(\n            keccak256(\"swapAndBridge(uint32,address,uint256,bytes32,bytes)\")\n        );\n\n    /// @notice socketGatewayAddress to be initialised via storage variable BridgeImplBase\n    /// @dev ensure _refuelBridge are set properly for the chainId in which the contract is being deployed\n    constructor(\n        address _refuelBridge,\n        address _socketGateway,\n        address _socketDeployFactory\n    ) BridgeImplBase(_socketGateway, _socketDeployFactory) {\n        refuelBridge = _refuelBridge;\n    }\n\n    // Function to receive Ether. msg.data must be empty\n    receive() external payable {}\n\n    /// @notice Struct to be used in decode step from input parameter - a specific case of bridging after swap.\n    /// @dev the data being encoded in offchain or by caller should have values set in this sequence of properties in this struct\n    struct RefuelBridgeData {\n        address receiverAddress;\n        uint256 toChainId;\n        bytes32 metadata;\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from swapAndBridge, this function is called when the swap has already happened at a different place.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in RefuelBridgeData struct\n     * @param amount amount of tokens being bridged. this must be only native\n     * @param bridgeData encoded data for RefuelBridge\n     */\n    function bridgeAfterSwap(\n        uint256 amount,\n        bytes calldata bridgeData\n    ) external payable override {\n        RefuelBridgeData memory refuelBridgeData = abi.decode(\n            bridgeData,\n            (RefuelBridgeData)\n        );\n        IRefuel(refuelBridge).depositNativeToken{value: amount}(\n            refuelBridgeData.toChainId,\n            refuelBridgeData.receiverAddress\n        );\n\n        emit SocketBridge(\n            amount,\n            NATIVE_TOKEN_ADDRESS,\n            refuelBridgeData.toChainId,\n            RefuelIdentifier,\n            msg.sender,\n            refuelBridgeData.receiverAddress,\n            refuelBridgeData.metadata\n        );\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from bridgeAfterSwap since this function holds the logic for swapping tokens too.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in RefuelBridgeData struct\n     * @param swapId routeId for the swapImpl\n     * @param receiverAddress receiverAddress\n     * @param toChainId toChainId\n     * @param swapData encoded data for swap\n     */\n    function swapAndBridge(\n        uint32 swapId,\n        address receiverAddress,\n        uint256 toChainId,\n        bytes32 metadata,\n        bytes calldata swapData\n    ) external payable {\n        (bool success, bytes memory result) = socketRoute\n            .getRoute(swapId)\n            .delegatecall(swapData);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        (uint256 bridgeAmount, ) = abi.decode(result, (uint256, address));\n        IRefuel(refuelBridge).depositNativeToken{value: bridgeAmount}(\n            toChainId,\n            receiverAddress\n        );\n\n        emit SocketBridge(\n            bridgeAmount,\n            NATIVE_TOKEN_ADDRESS,\n            toChainId,\n            RefuelIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n\n    /**\n     * @notice function to handle Native bridging to receipent via Refuel-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param amount amount of native being refuelled to destination chain\n     * @param receiverAddress recipient address of the refuelled native\n     * @param toChainId destinationChainId\n     */\n    function bridgeNativeTo(\n        uint256 amount,\n        address receiverAddress,\n        uint256 toChainId,\n        bytes32 metadata\n    ) external payable {\n        IRefuel(refuelBridge).depositNativeToken{value: amount}(\n            toChainId,\n            receiverAddress\n        );\n\n        emit SocketBridge(\n            amount,\n            NATIVE_TOKEN_ADDRESS,\n            toChainId,\n            RefuelIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n}\n"},"src/bridges/across/interfaces/across.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice interface with functions to interact with SpokePool contract of Across-Bridge\ninterface SpokePool {\n    /**************************************\n     *         DEPOSITOR FUNCTIONS        *\n     **************************************/\n\n    /**\n     * @notice Called by user to bridge funds from origin to destination chain. Depositor will effectively lock\n     * tokens in this contract and receive a destination token on the destination chain. The origin => destination\n     * token mapping is stored on the L1 HubPool.\n     * @notice The caller must first approve this contract to spend amount of originToken.\n     * @notice The originToken => destinationChainId must be enabled.\n     * @notice This method is payable because the caller is able to deposit native token if the originToken is\n     * wrappedNativeToken and this function will handle wrapping the native token to wrappedNativeToken.\n     * @param recipient Address to receive funds at on destination chain.\n     * @param originToken Token to lock into this contract to initiate deposit.\n     * @param amount Amount of tokens to deposit. Will be amount of tokens to receive less fees.\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\n     * @param relayerFeePct % of deposit amount taken out to incentivize a fast relayer.\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\n     * to LP pool on HubPool.\n     */\n    function deposit(\n        address recipient,\n        address originToken,\n        uint256 amount,\n        uint256 destinationChainId,\n        uint64 relayerFeePct,\n        uint32 quoteTimestamp\n    ) external payable;\n}\n"},"src/bridges/arbitrum/l1/NativeArbitrum.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {L1GatewayRouter} from \"../interfaces/arbitrum.sol\";\nimport {BridgeImplBase} from \"../../BridgeImplBase.sol\";\nimport {NATIVE_ARBITRUM} from \"../../../static/RouteIdentifiers.sol\";\n\n/**\n * @title Native Arbitrum-Route Implementation\n * @notice Route implementation with functions to bridge ERC20 via NativeArbitrum-Bridge\n * @notice Called via SocketGateway if the routeId in the request maps to the routeId of NativeArbitrum-Implementation\n * @notice This is used when transferring from ethereum chain to arbitrum via their native bridge.\n * @notice Contains function to handle bridging as post-step i.e linked to a preceeding step for swap\n * @notice RequestData is different to just bride and bridging chained with swap\n * @author Socket dot tech.\n */\ncontract NativeArbitrumImpl is BridgeImplBase {\n    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens\n    using SafeTransferLib for ERC20;\n\n    bytes32 public immutable NativeArbitrumIdentifier = NATIVE_ARBITRUM;\n\n    uint256 public constant DESTINATION_CHAIN_ID = 42161;\n\n    /// @notice Function-selector for ERC20-token bridging on NativeArbitrum\n    /// @dev This function selector is to be used while buidling transaction-data to bridge ERC20 tokens\n    bytes4\n        public immutable NATIVE_ARBITRUM_ERC20_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeERC20To(uint256,uint256,uint256,uint256,bytes32,address,address,address,bytes)\"\n            )\n        );\n\n    bytes4 public immutable NATIVE_ARBITRUM_SWAP_BRIDGE_SELECTOR =\n        bytes4(\n            keccak256(\n                \"swapAndBridge(uint32,bytes,(uint256,uint256,uint256,address,address,bytes32,bytes))\"\n            )\n        );\n\n    /// @notice router address of NativeArbitrum Bridge\n    /// @notice GatewayRouter looks up ERC20Token's gateway, and finding that it's Standard ERC20 gateway (the L1ERC20Gateway contract).\n    address public immutable router;\n\n    /// @notice socketGatewayAddress to be initialised via storage variable BridgeImplBase\n    /// @dev ensure router-address are set properly for the chainId in which the contract is being deployed\n    constructor(\n        address _router,\n        address _socketGateway,\n        address _socketDeployFactory\n    ) BridgeImplBase(_socketGateway, _socketDeployFactory) {\n        router = _router;\n    }\n\n    /// @notice Struct to be used in decode step from input parameter - a specific case of bridging after swap.\n    /// @dev the data being encoded in offchain or by caller should have values set in this sequence of properties in this struct\n    struct NativeArbitrumBridgeDataNoToken {\n        uint256 value;\n        /// @notice maxGas is a depositParameter derived from erc20Bridger of nativeArbitrum\n        uint256 maxGas;\n        /// @notice gasPriceBid is a depositParameter derived from erc20Bridger of nativeArbitrum\n        uint256 gasPriceBid;\n        /// @notice address of receiver of bridged tokens\n        address receiverAddress;\n        /// @notice address of Gateway which handles the token bridging for the token\n        /// @notice gatewayAddress is unique for each token\n        address gatewayAddress;\n        /// @notice socket offchain created hash\n        bytes32 metadata;\n        /// @notice data is a depositParameter derived from erc20Bridger of nativeArbitrum\n        bytes data;\n    }\n\n    struct NativeArbitrumBridgeData {\n        uint256 value;\n        /// @notice maxGas is a depositParameter derived from erc20Bridger of nativeArbitrum\n        uint256 maxGas;\n        /// @notice gasPriceBid is a depositParameter derived from erc20Bridger of nativeArbitrum\n        uint256 gasPriceBid;\n        /// @notice address of receiver of bridged tokens\n        address receiverAddress;\n        /// @notice address of Gateway which handles the token bridging for the token\n        /// @notice gatewayAddress is unique for each token\n        address gatewayAddress;\n        /// @notice address of token being bridged\n        address token;\n        /// @notice socket offchain created hash\n        bytes32 metadata;\n        /// @notice data is a depositParameter derived from erc20Bridger of nativeArbitrum\n        bytes data;\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from swapAndBridge, this function is called when the swap has already happened at a different place.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in NativeArbitrumBridgeData struct\n     * @param amount amount of tokens being bridged. this can be ERC20 or native\n     * @param bridgeData encoded data for NativeArbitrumBridge\n     */\n    function bridgeAfterSwap(\n        uint256 amount,\n        bytes calldata bridgeData\n    ) external payable override {\n        NativeArbitrumBridgeData memory nativeArbitrumBridgeData = abi.decode(\n            bridgeData,\n            (NativeArbitrumBridgeData)\n        );\n        ERC20(nativeArbitrumBridgeData.token).safeApprove(\n            nativeArbitrumBridgeData.gatewayAddress,\n            amount\n        );\n\n        L1GatewayRouter(router).outboundTransfer{\n            value: nativeArbitrumBridgeData.value\n        }(\n            nativeArbitrumBridgeData.token,\n            nativeArbitrumBridgeData.receiverAddress,\n            amount,\n            nativeArbitrumBridgeData.maxGas,\n            nativeArbitrumBridgeData.gasPriceBid,\n            nativeArbitrumBridgeData.data\n        );\n\n        emit SocketBridge(\n            amount,\n            nativeArbitrumBridgeData.token,\n            DESTINATION_CHAIN_ID,\n            NativeArbitrumIdentifier,\n            msg.sender,\n            nativeArbitrumBridgeData.receiverAddress,\n            nativeArbitrumBridgeData.metadata\n        );\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from bridgeAfterSwap since this function holds the logic for swapping tokens too.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in NativeArbitrumBridgeData struct\n     * @param swapId routeId for the swapImpl\n     * @param swapData encoded data for swap\n     * @param nativeArbitrumBridgeData encoded data for NativeArbitrumBridge\n     */\n    function swapAndBridge(\n        uint32 swapId,\n        bytes calldata swapData,\n        NativeArbitrumBridgeDataNoToken calldata nativeArbitrumBridgeData\n    ) external payable {\n        (bool success, bytes memory result) = socketRoute\n            .getRoute(swapId)\n            .delegatecall(swapData);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        (uint256 bridgeAmount, address token) = abi.decode(\n            result,\n            (uint256, address)\n        );\n        ERC20(token).safeApprove(\n            nativeArbitrumBridgeData.gatewayAddress,\n            bridgeAmount\n        );\n\n        L1GatewayRouter(router).outboundTransfer{\n            value: nativeArbitrumBridgeData.value\n        }(\n            token,\n            nativeArbitrumBridgeData.receiverAddress,\n            bridgeAmount,\n            nativeArbitrumBridgeData.maxGas,\n            nativeArbitrumBridgeData.gasPriceBid,\n            nativeArbitrumBridgeData.data\n        );\n\n        emit SocketBridge(\n            bridgeAmount,\n            token,\n            DESTINATION_CHAIN_ID,\n            NativeArbitrumIdentifier,\n            msg.sender,\n            nativeArbitrumBridgeData.receiverAddress,\n            nativeArbitrumBridgeData.metadata\n        );\n    }\n\n    /**\n     * @notice function to handle ERC20 bridging to receipent via NativeArbitrum-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param amount amount being bridged\n     * @param value value\n     * @param maxGas maxGas is a depositParameter derived from erc20Bridger of nativeArbitrum\n     * @param gasPriceBid gasPriceBid is a depositParameter derived from erc20Bridger of nativeArbitrum\n     * @param receiverAddress address of receiver of bridged tokens\n     * @param token address of token being bridged\n     * @param gatewayAddress address of Gateway which handles the token bridging for the token, gatewayAddress is unique for each token\n     * @param data data is a depositParameter derived from erc20Bridger of nativeArbitrum\n     */\n    function bridgeERC20To(\n        uint256 amount,\n        uint256 value,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes32 metadata,\n        address receiverAddress,\n        address token,\n        address gatewayAddress,\n        bytes memory data\n    ) external payable {\n        ERC20 tokenInstance = ERC20(token);\n        tokenInstance.safeTransferFrom(msg.sender, socketGateway, amount);\n        tokenInstance.safeApprove(gatewayAddress, amount);\n\n        L1GatewayRouter(router).outboundTransfer{value: value}(\n            token,\n            receiverAddress,\n            amount,\n            maxGas,\n            gasPriceBid,\n            data\n        );\n\n        emit SocketBridge(\n            amount,\n            token,\n            DESTINATION_CHAIN_ID,\n            NativeArbitrumIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n}\n"},"src/bridges/across/Across.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./interfaces/across.sol\";\nimport \"../BridgeImplBase.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {ACROSS} from \"../../static/RouteIdentifiers.sol\";\n\n/**\n * @title Across-Route Implementation\n * @notice Route implementation with functions to bridge ERC20 and Native via Across-Bridge\n * Called via SocketGateway if the routeId in the request maps to the routeId of AcrossImplementation\n * Contains function to handle bridging as post-step i.e linked to a preceeding step for swap\n * RequestData is different to just bride and bridging chained with swap\n * @author Socket dot tech.\n */\ncontract AcrossImpl is BridgeImplBase {\n    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens\n    using SafeTransferLib for ERC20;\n\n    bytes32 public immutable AcrossIdentifier = ACROSS;\n\n    /// @notice Function-selector for ERC20-token bridging on Across-Route\n    /// @dev This function selector is to be used while buidling transaction-data to bridge ERC20 tokens\n    bytes4 public immutable ACROSS_ERC20_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeERC20To(uint256,uint256,bytes32,address,address,uint32,uint64)\"\n            )\n        );\n\n    /// @notice Function-selector for Native bridging on Across-Route\n    /// @dev This function selector is to be used while buidling transaction-data to bridge Native tokens\n    bytes4 public immutable ACROSS_NATIVE_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeNativeTo(uint256,uint256,bytes32,address,uint32,uint64)\"\n            )\n        );\n\n    bytes4 public immutable ACROSS_SWAP_BRIDGE_SELECTOR =\n        bytes4(\n            keccak256(\n                \"swapAndBridge(uint32,bytes,(uint256,address,uint32,uint64,bytes32))\"\n            )\n        );\n\n    /// @notice spokePool Contract instance used to deposit ERC20 and Native on to Across-Bridge\n    /// @dev contract instance is to be initialized in the constructor using the spokePoolAddress passed as constructor argument\n    SpokePool public immutable spokePool;\n    address public immutable spokePoolAddress;\n\n    /// @notice address of WETH token to be initialised in constructor\n    address public immutable WETH;\n\n    /// @notice Struct to be used in decode step from input parameter - a specific case of bridging after swap.\n    /// @dev the data being encoded in offchain or by caller should have values set in this sequence of properties in this struct\n    struct AcrossBridgeDataNoToken {\n        uint256 toChainId;\n        address receiverAddress;\n        uint32 quoteTimestamp;\n        uint64 relayerFeePct;\n        bytes32 metadata;\n    }\n\n    struct AcrossBridgeData {\n        uint256 toChainId;\n        address receiverAddress;\n        address token;\n        uint32 quoteTimestamp;\n        uint64 relayerFeePct;\n        bytes32 metadata;\n    }\n\n    /// @notice socketGatewayAddress to be initialised via storage variable BridgeImplBase\n    /// @dev ensure spokepool, weth-address are set properly for the chainId in which the contract is being deployed\n    constructor(\n        address _spokePool,\n        address _wethAddress,\n        address _socketGateway,\n        address _socketDeployFactory\n    ) BridgeImplBase(_socketGateway, _socketDeployFactory) {\n        spokePool = SpokePool(_spokePool);\n        spokePoolAddress = _spokePool;\n        WETH = _wethAddress;\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from swapAndBridge, this function is called when the swap has already happened at a different place.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in AcrossBridgeData struct\n     * @param amount amount of tokens being bridged. this can be ERC20 or native\n     * @param bridgeData encoded data for AcrossBridge\n     */\n    function bridgeAfterSwap(\n        uint256 amount,\n        bytes calldata bridgeData\n    ) external payable override {\n        AcrossBridgeData memory acrossBridgeData = abi.decode(\n            bridgeData,\n            (AcrossBridgeData)\n        );\n\n        if (acrossBridgeData.token == NATIVE_TOKEN_ADDRESS) {\n            spokePool.deposit{value: amount}(\n                acrossBridgeData.receiverAddress,\n                WETH,\n                amount,\n                acrossBridgeData.toChainId,\n                acrossBridgeData.relayerFeePct,\n                acrossBridgeData.quoteTimestamp\n            );\n        } else {\n            spokePool.deposit(\n                acrossBridgeData.receiverAddress,\n                acrossBridgeData.token,\n                amount,\n                acrossBridgeData.toChainId,\n                acrossBridgeData.relayerFeePct,\n                acrossBridgeData.quoteTimestamp\n            );\n        }\n\n        emit SocketBridge(\n            amount,\n            acrossBridgeData.token,\n            acrossBridgeData.toChainId,\n            AcrossIdentifier,\n            msg.sender,\n            acrossBridgeData.receiverAddress,\n            acrossBridgeData.metadata\n        );\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from bridgeAfterSwap since this function holds the logic for swapping tokens too.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in AcrossBridgeData struct\n     * @param swapId routeId for the swapImpl\n     * @param swapData encoded data for swap\n     * @param acrossBridgeData encoded data for AcrossBridge\n     */\n    function swapAndBridge(\n        uint32 swapId,\n        bytes calldata swapData,\n        AcrossBridgeDataNoToken calldata acrossBridgeData\n    ) external payable {\n        (bool success, bytes memory result) = socketRoute\n            .getRoute(swapId)\n            .delegatecall(swapData);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        (uint256 bridgeAmount, address token) = abi.decode(\n            result,\n            (uint256, address)\n        );\n        if (token == NATIVE_TOKEN_ADDRESS) {\n            spokePool.deposit{value: bridgeAmount}(\n                acrossBridgeData.receiverAddress,\n                WETH,\n                bridgeAmount,\n                acrossBridgeData.toChainId,\n                acrossBridgeData.relayerFeePct,\n                acrossBridgeData.quoteTimestamp\n            );\n        } else {\n            spokePool.deposit(\n                acrossBridgeData.receiverAddress,\n                token,\n                bridgeAmount,\n                acrossBridgeData.toChainId,\n                acrossBridgeData.relayerFeePct,\n                acrossBridgeData.quoteTimestamp\n            );\n        }\n\n        emit SocketBridge(\n            bridgeAmount,\n            token,\n            acrossBridgeData.toChainId,\n            AcrossIdentifier,\n            msg.sender,\n            acrossBridgeData.receiverAddress,\n            acrossBridgeData.metadata\n        );\n    }\n\n    /**\n     * @notice function to handle ERC20 bridging to receipent via Across-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param amount amount being bridged\n     * @param toChainId destination ChainId\n     * @param receiverAddress address of receiver of bridged tokens\n     * @param token address of token being bridged\n     * @param quoteTimestamp timestamp for quote and this is to be used by Across-Bridge contract\n     * @param relayerFeePct feePct that will be relayed by the Bridge to the relayer\n     */\n    function bridgeERC20To(\n        uint256 amount,\n        uint256 toChainId,\n        bytes32 metadata,\n        address receiverAddress,\n        address token,\n        uint32 quoteTimestamp,\n        uint64 relayerFeePct\n    ) external payable {\n        ERC20 tokenInstance = ERC20(token);\n        tokenInstance.safeTransferFrom(msg.sender, socketGateway, amount);\n        spokePool.deposit(\n            receiverAddress,\n            address(token),\n            amount,\n            toChainId,\n            relayerFeePct,\n            quoteTimestamp\n        );\n\n        emit SocketBridge(\n            amount,\n            token,\n            toChainId,\n            AcrossIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n\n    /**\n     * @notice function to handle Native bridging to receipent via Across-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param amount amount being bridged\n     * @param toChainId destination ChainId\n     * @param receiverAddress address of receiver of bridged tokens\n     * @param quoteTimestamp timestamp for quote and this is to be used by Across-Bridge contract\n     * @param relayerFeePct feePct that will be relayed by the Bridge to the relayer\n     */\n    function bridgeNativeTo(\n        uint256 amount,\n        uint256 toChainId,\n        bytes32 metadata,\n        address receiverAddress,\n        uint32 quoteTimestamp,\n        uint64 relayerFeePct\n    ) external payable {\n        spokePool.deposit{value: amount}(\n            receiverAddress,\n            WETH,\n            amount,\n            toChainId,\n            relayerFeePct,\n            quoteTimestamp\n        );\n\n        emit SocketBridge(\n            amount,\n            NATIVE_TOKEN_ADDRESS,\n            toChainId,\n            AcrossIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n}\n"},"src/bridges/cbridge/interfaces/ICelerStorageWrapper.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.0;\n\n/**\n * @title Celer-StorageWrapper interface\n * @notice Interface to handle storageMappings used while bridging ERC20 and native on CelerBridge\n * @dev all functions ehich mutate the storage are restricted to Owner of SocketGateway\n * @author Socket dot tech.\n */\ninterface ICelerStorageWrapper {\n    /**\n     * @notice function to store the transferId and message-sender of a bridging activity\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in CelerBridgeData struct\n     * @param transferId transferId generated during the bridging of ERC20 or native on CelerBridge\n     * @param transferIdAddress message sender who is making the bridging on CelerBridge\n     */\n    function setAddressForTransferId(\n        bytes32 transferId,\n        address transferIdAddress\n    ) external;\n\n    /**\n     * @notice function to store the transferId and message-sender of a bridging activity\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in CelerBridgeData struct\n     * @param transferId transferId generated during the bridging of ERC20 or native on CelerBridge\n     */\n    function deleteTransferId(bytes32 transferId) external;\n\n    /**\n     * @notice function to lookup the address mapped to the transferId\n     * @param transferId transferId generated during the bridging of ERC20 or native on CelerBridge\n     * @return address of account mapped to transferId\n     */\n    function getAddressFromTransferId(\n        bytes32 transferId\n    ) external view returns (address);\n}\n"},"src/bridges/optimism/interfaces/optimism.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.0;\n\ninterface L1StandardBridge {\n    /**\n     * @dev Performs the logic for deposits by storing the ETH and informing the L2 ETH Gateway of\n     * the deposit.\n     * @param _to Account to give the deposit to on L2.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external payable;\n\n    /**\n     * @dev deposit an amount of ERC20 to a recipient's balance on L2.\n     * @param _l1Token Address of the L1 ERC20 we are depositing\n     * @param _l2Token Address of the L1 respective L2 ERC20\n     * @param _to L2 address to credit the withdrawal to.\n     * @param _amount Amount of the ERC20 to deposit.\n     * @param _l2Gas Gas limit required to complete the deposit on L2.\n     * @param _data Optional data to forward to L2. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l2Gas,\n        bytes calldata _data\n    ) external;\n}\n\ninterface OldL1TokenGateway {\n    /**\n     * @dev Transfer SNX to L2 First, moves the SNX into the deposit escrow\n     *\n     * @param _to Account to give the deposit to on L2\n     * @param _amount Amount of the ERC20 to deposit.\n     */\n    function depositTo(address _to, uint256 _amount) external;\n\n    /**\n     * @dev Transfer SNX to L2 First, moves the SNX into the deposit escrow\n     *\n     * @param currencyKey currencyKey for the SynthToken\n     * @param destination Account to give the deposit to on L2\n     * @param amount Amount of the ERC20 to deposit.\n     */\n    function initiateSynthTransfer(\n        bytes32 currencyKey,\n        address destination,\n        uint256 amount\n    ) external;\n}\n"},"src/bridges/arbitrum/interfaces/arbitrum.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.8.0;\n\n/**\n * @title L1gatewayRouter for native-arbitrum\n */\ninterface L1GatewayRouter {\n    /**\n     * @notice outbound function to bridge ERC20 via NativeArbitrum-Bridge\n     * @param _token address of token being bridged via GatewayRouter\n     * @param _to recipient of the token on arbitrum chain\n     * @param _amount amount of ERC20 token being bridged\n     * @param _maxGas a depositParameter for bridging the token\n     * @param _gasPriceBid  a depositParameter for bridging the token\n     * @param _data a depositParameter for bridging the token\n     * @return calldata returns the output of transactioncall made on gatewayRouter\n     */\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes calldata);\n}\n"},"src/deployFactory/DisabledSocketRoute.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {ISocketGateway} from \"../interfaces/ISocketGateway.sol\";\nimport {OnlySocketGatewayOwner} from \"../errors/SocketErrors.sol\";\n\ncontract DisabledSocketRoute {\n    using SafeTransferLib for ERC20;\n\n    /// @notice immutable variable to store the socketGateway address\n    address public immutable socketGateway;\n    error RouteDisabled();\n\n    /**\n     * @notice Construct the base for all BridgeImplementations.\n     * @param _socketGateway Socketgateway address, an immutable variable to set.\n     */\n    constructor(address _socketGateway) {\n        socketGateway = _socketGateway;\n    }\n\n    /// @notice Implementing contract needs to make use of the modifier where restricted access is to be used\n    modifier isSocketGatewayOwner() {\n        if (msg.sender != ISocketGateway(socketGateway).owner()) {\n            revert OnlySocketGatewayOwner();\n        }\n        _;\n    }\n\n    /**\n     * @notice function to rescue the ERC20 tokens in the bridge Implementation contract\n     * @notice this is a function restricted to Owner of SocketGateway only\n     * @param token address of ERC20 token being rescued\n     * @param userAddress receipient address to which ERC20 tokens will be rescued to\n     * @param amount amount of ERC20 tokens being rescued\n     */\n    function rescueFunds(\n        address token,\n        address userAddress,\n        uint256 amount\n    ) external isSocketGatewayOwner {\n        ERC20(token).safeTransfer(userAddress, amount);\n    }\n\n    /**\n     * @notice function to rescue the native-balance in the bridge Implementation contract\n     * @notice this is a function restricted to Owner of SocketGateway only\n     * @param userAddress receipient address to which native-balance will be rescued to\n     * @param amount amount of native balance tokens being rescued\n     */\n    function rescueEther(\n        address payable userAddress,\n        uint256 amount\n    ) external isSocketGatewayOwner {\n        userAddress.transfer(amount);\n    }\n\n    /**\n     * @notice Handle route function calls gracefully.\n     */\n    fallback() external payable {\n        revert RouteDisabled();\n    }\n\n    /**\n     * @notice Support receiving ether to handle refunds etc.\n     */\n    receive() external payable {}\n}\n"},"src/bridges/polygon/NativePolygon.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport \"./interfaces/polygon.sol\";\nimport {BridgeImplBase} from \"../BridgeImplBase.sol\";\nimport {NATIVE_POLYGON} from \"../../static/RouteIdentifiers.sol\";\n\n/**\n * @title NativePolygon-Route Implementation\n * @notice This is the L1 implementation, so this is used when transferring from ethereum to polygon via their native bridge.\n * @author Socket dot tech.\n */\ncontract NativePolygonImpl is BridgeImplBase {\n    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens\n    using SafeTransferLib for ERC20;\n\n    bytes32 public immutable NativePolyonIdentifier = NATIVE_POLYGON;\n\n    /// @notice destination-chain-Id for this router is always arbitrum\n    uint256 public constant DESTINATION_CHAIN_ID = 137;\n\n    /// @notice Function-selector for ERC20-token bridging on NativePolygon-Route\n    /// @dev This function selector is to be used while buidling transaction-data to bridge ERC20 tokens\n    bytes4\n        public immutable NATIVE_POLYGON_ERC20_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(keccak256(\"bridgeERC20To(uint256,bytes32,address,address)\"));\n\n    /// @notice Function-selector for Native bridging on NativePolygon-Route\n    /// @dev This function selector is to be used while buidling transaction-data to bridge Native tokens\n    bytes4\n        public immutable NATIVE_POLYGON_NATIVE_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(keccak256(\"bridgeNativeTo(uint256,bytes32,address)\"));\n\n    bytes4 public immutable NATIVE_POLYGON_SWAP_BRIDGE_SELECTOR =\n        bytes4(keccak256(\"swapAndBridge(uint32,address,bytes32,bytes)\"));\n\n    /// @notice root chain manager proxy on the ethereum chain\n    /// @dev to be initialised in the constructor\n    IRootChainManager public immutable rootChainManagerProxy;\n\n    /// @notice ERC20 Predicate proxy on the ethereum chain\n    /// @dev to be initialised in the constructor\n    address public immutable erc20PredicateProxy;\n\n    /**\n     * // @notice We set all the required addresses in the constructor while deploying the contract.\n     * // These will be constant addresses.\n     * // @dev Please use the Proxy addresses and not the implementation addresses while setting these\n     * // @param _rootChainManagerProxy address of the root chain manager proxy on the ethereum chain\n     * // @param _erc20PredicateProxy address of the ERC20 Predicate proxy on the ethereum chain.\n     * // @param _socketGateway address of the socketGateway contract that calls this contract\n     */\n    constructor(\n        address _rootChainManagerProxy,\n        address _erc20PredicateProxy,\n        address _socketGateway,\n        address _socketDeployFactory\n    ) BridgeImplBase(_socketGateway, _socketDeployFactory) {\n        rootChainManagerProxy = IRootChainManager(_rootChainManagerProxy);\n        erc20PredicateProxy = _erc20PredicateProxy;\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from swapAndBridge, this function is called when the swap has already happened at a different place.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in NativePolygon-BridgeData struct\n     * @param amount amount of tokens being bridged. this can be ERC20 or native\n     * @param bridgeData encoded data for NativePolygon-Bridge\n     */\n    function bridgeAfterSwap(\n        uint256 amount,\n        bytes calldata bridgeData\n    ) external payable override {\n        (address token, address receiverAddress, bytes32 metadata) = abi.decode(\n            bridgeData,\n            (address, address, bytes32)\n        );\n\n        if (token == NATIVE_TOKEN_ADDRESS) {\n            IRootChainManager(rootChainManagerProxy).depositEtherFor{\n                value: amount\n            }(receiverAddress);\n        } else {\n            ERC20(token).safeApprove(erc20PredicateProxy, amount);\n\n            // deposit into rootchain manager\n            IRootChainManager(rootChainManagerProxy).depositFor(\n                receiverAddress,\n                token,\n                abi.encodePacked(amount)\n            );\n        }\n\n        emit SocketBridge(\n            amount,\n            token,\n            DESTINATION_CHAIN_ID,\n            NativePolyonIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from bridgeAfterSwap since this function holds the logic for swapping tokens too.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in NativePolygon-BridgeData struct\n     * @param swapId routeId for the swapImpl\n     * @param receiverAddress address of the receiver\n     * @param swapData encoded data for swap\n     */\n    function swapAndBridge(\n        uint32 swapId,\n        address receiverAddress,\n        bytes32 metadata,\n        bytes calldata swapData\n    ) external payable {\n        (bool success, bytes memory result) = socketRoute\n            .getRoute(swapId)\n            .delegatecall(swapData);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        (uint256 bridgeAmount, address token) = abi.decode(\n            result,\n            (uint256, address)\n        );\n\n        if (token == NATIVE_TOKEN_ADDRESS) {\n            IRootChainManager(rootChainManagerProxy).depositEtherFor{\n                value: bridgeAmount\n            }(receiverAddress);\n        } else {\n            ERC20(token).safeApprove(erc20PredicateProxy, bridgeAmount);\n\n            // deposit into rootchain manager\n            IRootChainManager(rootChainManagerProxy).depositFor(\n                receiverAddress,\n                token,\n                abi.encodePacked(bridgeAmount)\n            );\n        }\n\n        emit SocketBridge(\n            bridgeAmount,\n            token,\n            DESTINATION_CHAIN_ID,\n            NativePolyonIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n\n    /**\n     * @notice function to handle ERC20 bridging to receipent via NativePolygon-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param amount amount of tokens being bridged\n     * @param receiverAddress recipient address\n     * @param token address of token being bridged\n     */\n    function bridgeERC20To(\n        uint256 amount,\n        bytes32 metadata,\n        address receiverAddress,\n        address token\n    ) external payable {\n        ERC20 tokenInstance = ERC20(token);\n\n        // set allowance for erc20 predicate\n        tokenInstance.safeTransferFrom(msg.sender, socketGateway, amount);\n        tokenInstance.safeApprove(erc20PredicateProxy, amount);\n\n        // deposit into rootchain manager\n        rootChainManagerProxy.depositFor(\n            receiverAddress,\n            token,\n            abi.encodePacked(amount)\n        );\n\n        emit SocketBridge(\n            amount,\n            token,\n            DESTINATION_CHAIN_ID,\n            NativePolyonIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n\n    /**\n     * @notice function to handle Native bridging to receipent via NativePolygon-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param amount amount of tokens being bridged\n     * @param receiverAddress recipient address\n     */\n    function bridgeNativeTo(\n        uint256 amount,\n        bytes32 metadata,\n        address receiverAddress\n    ) external payable {\n        rootChainManagerProxy.depositEtherFor{value: amount}(receiverAddress);\n\n        emit SocketBridge(\n            amount,\n            NATIVE_TOKEN_ADDRESS,\n            DESTINATION_CHAIN_ID,\n            NativePolyonIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n}\n"},"src/bridges/stargate/l1/Stargate.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport \"../interfaces/stargate.sol\";\nimport {BridgeImplBase} from \"../../BridgeImplBase.sol\";\nimport {STARGATE} from \"../../../static/RouteIdentifiers.sol\";\n\n/**\n * @title Stargate-L1-Route Implementation\n * @notice Route implementation with functions to bridge ERC20 and Native via Stargate-L1-Bridge\n * Called via SocketGateway if the routeId in the request maps to the routeId of Stargate-L1-Implementation\n * Contains function to handle bridging as post-step i.e linked to a preceeding step for swap\n * RequestData is different to just bride and bridging chained with swap\n * @author Socket dot tech.\n */\ncontract StargateImplL1 is BridgeImplBase {\n    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens\n    using SafeTransferLib for ERC20;\n\n    bytes32 public immutable StargateIdentifier = STARGATE;\n\n    /// @notice Function-selector for ERC20-token bridging on Stargate-L1-Route\n    /// @dev This function selector is to be used while buidling transaction-data to bridge ERC20 tokens\n    bytes4\n        public immutable STARGATE_L1_ERC20_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeERC20To(address,address,address,uint256,uint256,(uint256,uint256,uint256,uint256,bytes32,bytes,uint16))\"\n            )\n        );\n\n    /// @notice Function-selector for Native bridging on Stargate-L1-Route\n    /// @dev This function selector is to be used while buidling transaction-data to bridge Native tokens\n    bytes4\n        public immutable STARGATE_L1_NATIVE_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeNativeTo(address,address,uint16,uint256,uint256,uint256,bytes32)\"\n            )\n        );\n\n    bytes4 public immutable STARGATE_L1_SWAP_BRIDGE_SELECTOR =\n        bytes4(\n            keccak256(\n                \"swapAndBridge(uint32,bytes,(address,address,uint16,uint256,uint256,uint256,uint256,uint256,uint256,bytes32,bytes))\"\n            )\n        );\n\n    /// @notice Stargate Router to bridge ERC20 tokens\n    IBridgeStargate public immutable router;\n\n    /// @notice Stargate Router to bridge native tokens\n    IBridgeStargate public immutable routerETH;\n\n    /// @notice socketGatewayAddress to be initialised via storage variable BridgeImplBase\n    /// @dev ensure router, routerEth are set properly for the chainId in which the contract is being deployed\n    constructor(\n        address _router,\n        address _routerEth,\n        address _socketGateway,\n        address _socketDeployFactory\n    ) BridgeImplBase(_socketGateway, _socketDeployFactory) {\n        router = IBridgeStargate(_router);\n        routerETH = IBridgeStargate(_routerEth);\n    }\n\n    struct StargateBridgeExtraData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        uint256 destinationGasLimit;\n        uint256 minReceivedAmt;\n        bytes32 metadata;\n        bytes destinationPayload;\n        uint16 stargateDstChainId; // stargate defines chain id in its way\n    }\n\n    /// @notice Struct to be used in decode step from input parameter - a specific case of bridging after swap.\n    /// @dev the data being encoded in offchain or by caller should have values set in this sequence of properties in this struct\n    struct StargateBridgeDataNoToken {\n        address receiverAddress;\n        address senderAddress;\n        uint16 stargateDstChainId; // stargate defines chain id in its way\n        uint256 value;\n        // a unique identifier that is uses to dedup transfers\n        // this value is the a timestamp sent from frontend, but in theory can be any unique number\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        uint256 minReceivedAmt; // defines the slippage, the min qty you would accept on the destination\n        uint256 optionalValue;\n        uint256 destinationGasLimit;\n        bytes32 metadata;\n        bytes destinationPayload;\n    }\n\n    struct StargateBridgeData {\n        address token;\n        address receiverAddress;\n        address senderAddress;\n        uint16 stargateDstChainId; // stargate defines chain id in its way\n        uint256 value;\n        // a unique identifier that is uses to dedup transfers\n        // this value is the a timestamp sent from frontend, but in theory can be any unique number\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        uint256 minReceivedAmt; // defines the slippage, the min qty you would accept on the destination\n        uint256 optionalValue;\n        uint256 destinationGasLimit;\n        bytes32 metadata;\n        bytes destinationPayload;\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from swapAndBridge, this function is called when the swap has already happened at a different place.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in Stargate-BridgeData struct\n     * @param amount amount of tokens being bridged. this can be ERC20 or native\n     * @param bridgeData encoded data for Stargate-L1-Bridge\n     */\n    function bridgeAfterSwap(\n        uint256 amount,\n        bytes calldata bridgeData\n    ) external payable override {\n        StargateBridgeData memory stargateBridgeData = abi.decode(\n            bridgeData,\n            (StargateBridgeData)\n        );\n\n        if (stargateBridgeData.token == NATIVE_TOKEN_ADDRESS) {\n            // perform bridging\n            routerETH.swapETH{value: amount + stargateBridgeData.optionalValue}(\n                stargateBridgeData.stargateDstChainId,\n                payable(stargateBridgeData.senderAddress),\n                abi.encodePacked(stargateBridgeData.receiverAddress),\n                amount,\n                stargateBridgeData.minReceivedAmt\n            );\n        } else {\n            ERC20(stargateBridgeData.token).safeApprove(\n                address(router),\n                amount\n            );\n            {\n                router.swap{value: stargateBridgeData.value}(\n                    stargateBridgeData.stargateDstChainId,\n                    stargateBridgeData.srcPoolId,\n                    stargateBridgeData.dstPoolId,\n                    payable(stargateBridgeData.senderAddress), // default to refund to main contract\n                    amount,\n                    stargateBridgeData.minReceivedAmt,\n                    IBridgeStargate.lzTxObj(\n                        stargateBridgeData.destinationGasLimit,\n                        0, // zero amount since this is a ERC20 bridging\n                        \"0x\" //empty data since this is for only ERC20\n                    ),\n                    abi.encodePacked(stargateBridgeData.receiverAddress),\n                    stargateBridgeData.destinationPayload\n                );\n            }\n        }\n\n        emit SocketBridge(\n            amount,\n            stargateBridgeData.token,\n            stargateBridgeData.stargateDstChainId,\n            StargateIdentifier,\n            msg.sender,\n            stargateBridgeData.receiverAddress,\n            stargateBridgeData.metadata\n        );\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from bridgeAfterSwap since this function holds the logic for swapping tokens too.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in Stargate-BridgeData struct\n     * @param swapId routeId for the swapImpl\n     * @param swapData encoded data for swap\n     * @param stargateBridgeData encoded data for StargateBridgeData\n     */\n    function swapAndBridge(\n        uint32 swapId,\n        bytes calldata swapData,\n        StargateBridgeDataNoToken calldata stargateBridgeData\n    ) external payable {\n        (bool success, bytes memory result) = socketRoute\n            .getRoute(swapId)\n            .delegatecall(swapData);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        (uint256 bridgeAmount, address token) = abi.decode(\n            result,\n            (uint256, address)\n        );\n\n        if (token == NATIVE_TOKEN_ADDRESS) {\n            // perform bridging\n            routerETH.swapETH{\n                value: bridgeAmount + stargateBridgeData.optionalValue\n            }(\n                stargateBridgeData.stargateDstChainId,\n                payable(stargateBridgeData.senderAddress),\n                abi.encodePacked(stargateBridgeData.receiverAddress),\n                bridgeAmount,\n                stargateBridgeData.minReceivedAmt\n            );\n        } else {\n            ERC20(token).safeApprove(address(router), bridgeAmount);\n            {\n                router.swap{value: stargateBridgeData.value}(\n                    stargateBridgeData.stargateDstChainId,\n                    stargateBridgeData.srcPoolId,\n                    stargateBridgeData.dstPoolId,\n                    payable(stargateBridgeData.senderAddress), // default to refund to main contract\n                    bridgeAmount,\n                    stargateBridgeData.minReceivedAmt,\n                    IBridgeStargate.lzTxObj(\n                        stargateBridgeData.destinationGasLimit,\n                        0, // zero amount since this is a ERC20 bridging\n                        \"0x\" //empty data since this is for only ERC20\n                    ),\n                    abi.encodePacked(stargateBridgeData.receiverAddress),\n                    stargateBridgeData.destinationPayload\n                );\n            }\n        }\n\n        emit SocketBridge(\n            bridgeAmount,\n            token,\n            stargateBridgeData.stargateDstChainId,\n            StargateIdentifier,\n            msg.sender,\n            stargateBridgeData.receiverAddress,\n            stargateBridgeData.metadata\n        );\n    }\n\n    /**\n     * @notice function to handle ERC20 bridging to receipent via Stargate-L1-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param token address of token being bridged\n     * @param senderAddress address of sender\n     * @param receiverAddress address of recipient\n     * @param amount amount of token being bridge\n     * @param value value\n     * @param stargateBridgeExtraData stargate bridge extradata\n     */\n    function bridgeERC20To(\n        address token,\n        address senderAddress,\n        address receiverAddress,\n        uint256 amount,\n        uint256 value,\n        StargateBridgeExtraData calldata stargateBridgeExtraData\n    ) external payable {\n        ERC20 tokenInstance = ERC20(token);\n        tokenInstance.safeTransferFrom(msg.sender, socketGateway, amount);\n        tokenInstance.safeApprove(address(router), amount);\n        {\n            router.swap{value: value}(\n                stargateBridgeExtraData.stargateDstChainId,\n                stargateBridgeExtraData.srcPoolId,\n                stargateBridgeExtraData.dstPoolId,\n                payable(senderAddress), // default to refund to main contract\n                amount,\n                stargateBridgeExtraData.minReceivedAmt,\n                IBridgeStargate.lzTxObj(\n                    stargateBridgeExtraData.destinationGasLimit,\n                    0, // zero amount since this is a ERC20 bridging\n                    \"0x\" //empty data since this is for only ERC20\n                ),\n                abi.encodePacked(receiverAddress),\n                stargateBridgeExtraData.destinationPayload\n            );\n        }\n\n        emit SocketBridge(\n            amount,\n            token,\n            stargateBridgeExtraData.stargateDstChainId,\n            StargateIdentifier,\n            msg.sender,\n            receiverAddress,\n            stargateBridgeExtraData.metadata\n        );\n    }\n\n    /**\n     * @notice function to handle Native bridging to receipent via Stargate-L1-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param receiverAddress address of receipient\n     * @param senderAddress address of sender\n     * @param stargateDstChainId stargate defines chain id in its way\n     * @param amount amount of token being bridge\n     * @param minReceivedAmt defines the slippage, the min qty you would accept on the destination\n     * @param optionalValue optionalValue Native amount\n     */\n    function bridgeNativeTo(\n        address receiverAddress,\n        address senderAddress,\n        uint16 stargateDstChainId,\n        uint256 amount,\n        uint256 minReceivedAmt,\n        uint256 optionalValue,\n        bytes32 metadata\n    ) external payable {\n        // perform bridging\n        routerETH.swapETH{value: amount + optionalValue}(\n            stargateDstChainId,\n            payable(senderAddress),\n            abi.encodePacked(receiverAddress),\n            amount,\n            minReceivedAmt\n        );\n\n        emit SocketBridge(\n            amount,\n            NATIVE_TOKEN_ADDRESS,\n            stargateDstChainId,\n            StargateIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n}\n"},"src/bridges/hop/l2/HopImplL2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/amm.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {BridgeImplBase} from \"../../BridgeImplBase.sol\";\nimport {HOP} from \"../../../static/RouteIdentifiers.sol\";\n\n/**\n * @title Hop-L2 Route Implementation\n * @notice This is the L2 implementation, so this is used when transferring from l2 to supported l2s\n * Called via SocketGateway if the routeId in the request maps to the routeId of HopL2-Implementation\n * Contains function to handle bridging as post-step i.e linked to a preceeding step for swap\n * RequestData is different to just bride and bridging chained with swap\n * @author Socket dot tech.\n */\ncontract HopImplL2 is BridgeImplBase {\n    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens\n    using SafeTransferLib for ERC20;\n\n    bytes32 public immutable HopIdentifier = HOP;\n\n    /// @notice Function-selector for ERC20-token bridging on Hop-L2-Route\n    /// @dev This function selector is to be used while buidling transaction-data to bridge ERC20 tokens\n    bytes4 public immutable HOP_L2_ERC20_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeERC20To(address,address,address,uint256,uint256,(uint256,uint256,uint256,uint256,uint256,bytes32))\"\n            )\n        );\n\n    /// @notice Function-selector for Native bridging on Hop-L2-Route\n    /// @dev This function selector is to be used while building transaction-data to bridge Native tokens\n    bytes4 public immutable HOP_L2_NATIVE_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeNativeTo(address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bytes32)\"\n            )\n        );\n\n    bytes4 public immutable HOP_L2_SWAP_BRIDGE_SELECTOR =\n        bytes4(\n            keccak256(\n                \"swapAndBridge(uint32,bytes,(address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes32))\"\n            )\n        );\n\n    /// @notice socketGatewayAddress to be initialised via storage variable BridgeImplBase\n    constructor(\n        address _socketGateway,\n        address _socketDeployFactory\n    ) BridgeImplBase(_socketGateway, _socketDeployFactory) {}\n\n    /// @notice Struct to be used as a input parameter for Bridging tokens via Hop-L2-route\n    /// @dev while building transactionData,values should be set in this sequence of properties in this struct\n    struct HopBridgeRequestData {\n        // fees passed to relayer\n        uint256 bonderFee;\n        // The minimum amount received after attempting to swap in the destination AMM market. 0 if no swap is intended.\n        uint256 amountOutMin;\n        // The deadline for swapping in the destination AMM market. 0 if no swap is intended.\n        uint256 deadline;\n        // Minimum amount expected to be received or bridged to destination\n        uint256 amountOutMinDestination;\n        // deadline for bridging to destination\n        uint256 deadlineDestination;\n        // socket offchain created hash\n        bytes32 metadata;\n    }\n\n    /// @notice Struct to be used in decode step from input parameter - a specific case of bridging after swap.\n    /// @dev the data being encoded in offchain or by caller should have values set in this sequence of properties in this struct\n    struct HopBridgeDataNoToken {\n        // The address receiving funds at the destination\n        address receiverAddress;\n        // AMM address of Hop on L2\n        address hopAMM;\n        // The chainId of the destination chain\n        uint256 toChainId;\n        // fees passed to relayer\n        uint256 bonderFee;\n        // The minimum amount received after attempting to swap in the destination AMM market. 0 if no swap is intended.\n        uint256 amountOutMin;\n        // The deadline for swapping in the destination AMM market. 0 if no swap is intended.\n        uint256 deadline;\n        // Minimum amount expected to be received or bridged to destination\n        uint256 amountOutMinDestination;\n        // deadline for bridging to destination\n        uint256 deadlineDestination;\n        // socket offchain created hash\n        bytes32 metadata;\n    }\n\n    struct HopBridgeData {\n        /// @notice address of token being bridged\n        address token;\n        // The address receiving funds at the destination\n        address receiverAddress;\n        // AMM address of Hop on L2\n        address hopAMM;\n        // The chainId of the destination chain\n        uint256 toChainId;\n        // fees passed to relayer\n        uint256 bonderFee;\n        // The minimum amount received after attempting to swap in the destination AMM market. 0 if no swap is intended.\n        uint256 amountOutMin;\n        // The deadline for swapping in the destination AMM market. 0 if no swap is intended.\n        uint256 deadline;\n        // Minimum amount expected to be received or bridged to destination\n        uint256 amountOutMinDestination;\n        // deadline for bridging to destination\n        uint256 deadlineDestination;\n        // socket offchain created hash\n        bytes32 metadata;\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from swapAndBridge, this function is called when the swap has already happened at a different place.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in HopBridgeData struct\n     * @param amount amount of tokens being bridged. this can be ERC20 or native\n     * @param bridgeData encoded data for Hop-L2-Bridge\n     */\n    function bridgeAfterSwap(\n        uint256 amount,\n        bytes calldata bridgeData\n    ) external payable override {\n        HopBridgeData memory hopData = abi.decode(bridgeData, (HopBridgeData));\n\n        if (hopData.token == NATIVE_TOKEN_ADDRESS) {\n            HopAMM(hopData.hopAMM).swapAndSend{value: amount}(\n                hopData.toChainId,\n                hopData.receiverAddress,\n                amount,\n                hopData.bonderFee,\n                hopData.amountOutMin,\n                hopData.deadline,\n                hopData.amountOutMinDestination,\n                hopData.deadlineDestination\n            );\n        } else {\n            // perform bridging\n            HopAMM(hopData.hopAMM).swapAndSend(\n                hopData.toChainId,\n                hopData.receiverAddress,\n                amount,\n                hopData.bonderFee,\n                hopData.amountOutMin,\n                hopData.deadline,\n                hopData.amountOutMinDestination,\n                hopData.deadlineDestination\n            );\n        }\n\n        emit SocketBridge(\n            amount,\n            hopData.token,\n            hopData.toChainId,\n            HopIdentifier,\n            msg.sender,\n            hopData.receiverAddress,\n            hopData.metadata\n        );\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from bridgeAfterSwap since this function holds the logic for swapping tokens too.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in HopBridgeData struct\n     * @param swapId routeId for the swapImpl\n     * @param swapData encoded data for swap\n     * @param hopData encoded data for HopData\n     */\n    function swapAndBridge(\n        uint32 swapId,\n        bytes calldata swapData,\n        HopBridgeDataNoToken calldata hopData\n    ) external payable {\n        (bool success, bytes memory result) = socketRoute\n            .getRoute(swapId)\n            .delegatecall(swapData);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        (uint256 bridgeAmount, address token) = abi.decode(\n            result,\n            (uint256, address)\n        );\n\n        if (token == NATIVE_TOKEN_ADDRESS) {\n            HopAMM(hopData.hopAMM).swapAndSend{value: bridgeAmount}(\n                hopData.toChainId,\n                hopData.receiverAddress,\n                bridgeAmount,\n                hopData.bonderFee,\n                hopData.amountOutMin,\n                hopData.deadline,\n                hopData.amountOutMinDestination,\n                hopData.deadlineDestination\n            );\n        } else {\n            // perform bridging\n            HopAMM(hopData.hopAMM).swapAndSend(\n                hopData.toChainId,\n                hopData.receiverAddress,\n                bridgeAmount,\n                hopData.bonderFee,\n                hopData.amountOutMin,\n                hopData.deadline,\n                hopData.amountOutMinDestination,\n                hopData.deadlineDestination\n            );\n        }\n\n        emit SocketBridge(\n            bridgeAmount,\n            token,\n            hopData.toChainId,\n            HopIdentifier,\n            msg.sender,\n            hopData.receiverAddress,\n            hopData.metadata\n        );\n    }\n\n    /**\n     * @notice function to handle ERC20 bridging to receipent via Hop-L2-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param receiverAddress The address receiving funds at the destination\n     * @param token token being bridged\n     * @param hopAMM AMM address of Hop on L2\n     * @param amount The amount being bridged\n     * @param toChainId The chainId of the destination chain\n     * @param hopBridgeRequestData extraData for Bridging across Hop-L2\n     */\n    function bridgeERC20To(\n        address receiverAddress,\n        address token,\n        address hopAMM,\n        uint256 amount,\n        uint256 toChainId,\n        HopBridgeRequestData calldata hopBridgeRequestData\n    ) external payable {\n        ERC20 tokenInstance = ERC20(token);\n        tokenInstance.safeTransferFrom(msg.sender, socketGateway, amount);\n\n        HopAMM(hopAMM).swapAndSend(\n            toChainId,\n            receiverAddress,\n            amount,\n            hopBridgeRequestData.bonderFee,\n            hopBridgeRequestData.amountOutMin,\n            hopBridgeRequestData.deadline,\n            hopBridgeRequestData.amountOutMinDestination,\n            hopBridgeRequestData.deadlineDestination\n        );\n\n        emit SocketBridge(\n            amount,\n            token,\n            toChainId,\n            HopIdentifier,\n            msg.sender,\n            receiverAddress,\n            hopBridgeRequestData.metadata\n        );\n    }\n\n    /**\n     * @notice function to handle Native bridging to receipent via Hop-L2-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param receiverAddress The address receiving funds at the destination\n     * @param hopAMM AMM address of Hop on L2\n     * @param amount The amount being bridged\n     * @param toChainId The chainId of the destination chain\n     * @param bonderFee fees passed to relayer\n     * @param amountOutMin The minimum amount received after attempting to swap in the destination AMM market. 0 if no swap is intended.\n     * @param deadline The deadline for swapping in the destination AMM market. 0 if no swap is intended.\n     * @param amountOutMinDestination Minimum amount expected to be received or bridged to destination\n     * @param deadlineDestination deadline for bridging to destination\n     */\n    function bridgeNativeTo(\n        address receiverAddress,\n        address hopAMM,\n        uint256 amount,\n        uint256 toChainId,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 deadline,\n        uint256 amountOutMinDestination,\n        uint256 deadlineDestination,\n        bytes32 metadata\n    ) external payable {\n        // token address might not be indication thats why passed through extraData\n        // perform bridging\n        HopAMM(hopAMM).swapAndSend{value: amount}(\n            toChainId,\n            receiverAddress,\n            amount,\n            bonderFee,\n            amountOutMin,\n            deadline,\n            amountOutMinDestination,\n            deadlineDestination\n        );\n\n        emit SocketBridge(\n            amount,\n            NATIVE_TOKEN_ADDRESS,\n            toChainId,\n            HopIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n}\n"},"src/bridges/anyswap-router-v4/l2/Anyswap.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {BridgeImplBase} from \"../../BridgeImplBase.sol\";\nimport {ANYSWAP} from \"../../../static/RouteIdentifiers.sol\";\n\n/**\n * @title Anyswap-V4-Route L1 Implementation\n * @notice Route implementation with functions to bridge ERC20 via Anyswap-Bridge\n * Called via SocketGateway if the routeId in the request maps to the routeId of AnyswapImplementation\n * This is the L2 implementation, so this is used when transferring from l2.\n * Contains function to handle bridging as post-step i.e linked to a preceeding step for swap\n * RequestData is different to just bride and bridging chained with swap\n * @author Socket dot tech.\n */\ninterface AnyswapV4Router {\n    function anySwapOutUnderlying(\n        address token,\n        address to,\n        uint256 amount,\n        uint256 toChainID\n    ) external;\n}\n\ncontract AnyswapL2Impl is BridgeImplBase {\n    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens\n    using SafeTransferLib for ERC20;\n\n    bytes32 public immutable AnyswapIdentifier = ANYSWAP;\n\n    /// @notice Function-selector for ERC20-token bridging on Anyswap-Route\n    /// @dev This function selector is to be used while buidling transaction-data to bridge ERC20 tokens\n    bytes4 public immutable ANYSWAP_L2_ERC20_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeERC20To(uint256,uint256,bytes32,address,address,address)\"\n            )\n        );\n\n    bytes4 public immutable ANYSWAP_SWAP_BRIDGE_SELECTOR =\n        bytes4(\n            keccak256(\n                \"swapAndBridge(uint32,bytes,(uint256,address,address,bytes32))\"\n            )\n        );\n\n    // polygon router multichain router v4\n    AnyswapV4Router public immutable router;\n\n    /**\n     * @notice Constructor sets the router address and socketGateway address.\n     * @dev anyswap v4 router is immutable. so no setter function required.\n     */\n    constructor(\n        address _router,\n        address _socketGateway,\n        address _socketDeployFactory\n    ) BridgeImplBase(_socketGateway, _socketDeployFactory) {\n        router = AnyswapV4Router(_router);\n    }\n\n    /// @notice Struct to be used in decode step from input parameter - a specific case of bridging after swap.\n    /// @dev the data being encoded in offchain or by caller should have values set in this sequence of properties in this struct\n    struct AnyswapBridgeDataNoToken {\n        /// @notice destination ChainId\n        uint256 toChainId;\n        /// @notice address of receiver of bridged tokens\n        address receiverAddress;\n        /// @notice address of wrapperToken, WrappedVersion of the token being bridged\n        address wrapperTokenAddress;\n        /// @notice socket offchain created hash\n        bytes32 metadata;\n    }\n\n    /// @notice Struct to be used in decode step from input parameter - a specific case of bridging after swap.\n    /// @dev the data being encoded in offchain or by caller should have values set in this sequence of properties in this struct\n    struct AnyswapBridgeData {\n        /// @notice destination ChainId\n        uint256 toChainId;\n        /// @notice address of receiver of bridged tokens\n        address receiverAddress;\n        /// @notice address of wrapperToken, WrappedVersion of the token being bridged\n        address wrapperTokenAddress;\n        /// @notice address of token being bridged\n        address token;\n        /// @notice socket offchain created hash\n        bytes32 metadata;\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from swapAndBridge, this function is called when the swap has already happened at a different place.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in AnyswapBridgeData struct\n     * @param amount amount of tokens being bridged. this can be ERC20 or native\n     * @param bridgeData encoded data for AnyswapBridge\n     */\n    function bridgeAfterSwap(\n        uint256 amount,\n        bytes calldata bridgeData\n    ) external payable override {\n        AnyswapBridgeData memory anyswapBridgeData = abi.decode(\n            bridgeData,\n            (AnyswapBridgeData)\n        );\n        ERC20(anyswapBridgeData.token).safeApprove(address(router), amount);\n        router.anySwapOutUnderlying(\n            anyswapBridgeData.wrapperTokenAddress,\n            anyswapBridgeData.receiverAddress,\n            amount,\n            anyswapBridgeData.toChainId\n        );\n\n        emit SocketBridge(\n            amount,\n            anyswapBridgeData.token,\n            anyswapBridgeData.toChainId,\n            AnyswapIdentifier,\n            msg.sender,\n            anyswapBridgeData.receiverAddress,\n            anyswapBridgeData.metadata\n        );\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from bridgeAfterSwap since this function holds the logic for swapping tokens too.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in AnyswapBridgeData struct\n     * @param swapId routeId for the swapImpl\n     * @param swapData encoded data for swap\n     * @param anyswapBridgeData encoded data for AnyswapBridge\n     */\n    function swapAndBridge(\n        uint32 swapId,\n        bytes calldata swapData,\n        AnyswapBridgeDataNoToken calldata anyswapBridgeData\n    ) external payable {\n        (bool success, bytes memory result) = socketRoute\n            .getRoute(swapId)\n            .delegatecall(swapData);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        (uint256 bridgeAmount, address token) = abi.decode(\n            result,\n            (uint256, address)\n        );\n\n        ERC20(token).safeApprove(address(router), bridgeAmount);\n        router.anySwapOutUnderlying(\n            anyswapBridgeData.wrapperTokenAddress,\n            anyswapBridgeData.receiverAddress,\n            bridgeAmount,\n            anyswapBridgeData.toChainId\n        );\n\n        emit SocketBridge(\n            bridgeAmount,\n            token,\n            anyswapBridgeData.toChainId,\n            AnyswapIdentifier,\n            msg.sender,\n            anyswapBridgeData.receiverAddress,\n            anyswapBridgeData.metadata\n        );\n    }\n\n    /**\n     * @notice function to handle ERC20 bridging to receipent via Anyswap-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param amount amount being bridged\n     * @param toChainId destination ChainId\n     * @param receiverAddress address of receiver of bridged tokens\n     * @param token address of token being bridged\n     * @param wrapperTokenAddress address of wrapperToken, WrappedVersion of the token being bridged\n     */\n    function bridgeERC20To(\n        uint256 amount,\n        uint256 toChainId,\n        bytes32 metadata,\n        address receiverAddress,\n        address token,\n        address wrapperTokenAddress\n    ) external payable {\n        ERC20 tokenInstance = ERC20(token);\n        tokenInstance.safeTransferFrom(msg.sender, socketGateway, amount);\n        tokenInstance.safeApprove(address(router), amount);\n        router.anySwapOutUnderlying(\n            wrapperTokenAddress,\n            receiverAddress,\n            amount,\n            toChainId\n        );\n\n        emit SocketBridge(\n            amount,\n            token,\n            toChainId,\n            AnyswapIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n}\n"},"src/bridges/hyphen/Hyphen.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./interfaces/hyphen.sol\";\nimport \"../BridgeImplBase.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {HYPHEN} from \"../../static/RouteIdentifiers.sol\";\n\n/**\n * @title Hyphen-Route Implementation\n * @notice Route implementation with functions to bridge ERC20 and Native via Hyphen-Bridge\n * Called via SocketGateway if the routeId in the request maps to the routeId of HyphenImplementation\n * Contains function to handle bridging as post-step i.e linked to a preceeding step for swap\n * RequestData is different to just bride and bridging chained with swap\n * @author Socket dot tech.\n */\ncontract HyphenImpl is BridgeImplBase {\n    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens\n    using SafeTransferLib for ERC20;\n\n    bytes32 public immutable HyphenIdentifier = HYPHEN;\n\n    /// @notice Function-selector for ERC20-token bridging on Hyphen-Route\n    /// @dev This function selector is to be used while buidling transaction-data to bridge ERC20 tokens\n    bytes4 public immutable HYPHEN_ERC20_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\"bridgeERC20To(uint256,bytes32,address,address,uint256)\")\n        );\n\n    /// @notice Function-selector for Native bridging on Hyphen-Route\n    /// @dev This function selector is to be used while buidling transaction-data to bridge Native tokens\n    bytes4 public immutable HYPHEN_NATIVE_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(keccak256(\"bridgeNativeTo(uint256,bytes32,address,uint256)\"));\n\n    bytes4 public immutable HYPHEN_SWAP_BRIDGE_SELECTOR =\n        bytes4(\n            keccak256(\"swapAndBridge(uint32,bytes,(address,uint256,bytes32))\")\n        );\n\n    /// @notice liquidityPoolManager - liquidityPool Manager of Hyphen used to bridge ERC20 and native\n    /// @dev this is to be initialized in constructor with a valid deployed address of hyphen-liquidityPoolManager\n    HyphenLiquidityPoolManager public immutable liquidityPoolManager;\n\n    /// @notice socketGatewayAddress to be initialised via storage variable BridgeImplBase\n    /// @dev ensure liquidityPoolManager-address are set properly for the chainId in which the contract is being deployed\n    constructor(\n        address _liquidityPoolManager,\n        address _socketGateway,\n        address _socketDeployFactory\n    ) BridgeImplBase(_socketGateway, _socketDeployFactory) {\n        liquidityPoolManager = HyphenLiquidityPoolManager(\n            _liquidityPoolManager\n        );\n    }\n\n    /// @notice Struct to be used in decode step from input parameter - a specific case of bridging after swap.\n    /// @dev the data being encoded in offchain or by caller should have values set in this sequence of properties in this struct\n    struct HyphenData {\n        /// @notice address of token being bridged\n        address token;\n        /// @notice address of receiver\n        address receiverAddress;\n        /// @notice chainId of destination\n        uint256 toChainId;\n        /// @notice socket offchain created hash\n        bytes32 metadata;\n    }\n\n    struct HyphenDataNoToken {\n        /// @notice address of receiver\n        address receiverAddress;\n        /// @notice chainId of destination\n        uint256 toChainId;\n        /// @notice chainId of destination\n        bytes32 metadata;\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from swapAndBridge, this function is called when the swap has already happened at a different place.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in HyphenBridgeData struct\n     * @param amount amount of tokens being bridged. this can be ERC20 or native\n     * @param bridgeData encoded data for HyphenBridge\n     */\n    function bridgeAfterSwap(\n        uint256 amount,\n        bytes calldata bridgeData\n    ) external payable override {\n        HyphenData memory hyphenData = abi.decode(bridgeData, (HyphenData));\n\n        if (hyphenData.token == NATIVE_TOKEN_ADDRESS) {\n            liquidityPoolManager.depositNative{value: amount}(\n                hyphenData.receiverAddress,\n                hyphenData.toChainId,\n                \"SOCKET\"\n            );\n        } else {\n            ERC20(hyphenData.token).safeApprove(\n                address(liquidityPoolManager),\n                amount\n            );\n            liquidityPoolManager.depositErc20(\n                hyphenData.toChainId,\n                hyphenData.token,\n                hyphenData.receiverAddress,\n                amount,\n                \"SOCKET\"\n            );\n        }\n\n        emit SocketBridge(\n            amount,\n            hyphenData.token,\n            hyphenData.toChainId,\n            HyphenIdentifier,\n            msg.sender,\n            hyphenData.receiverAddress,\n            hyphenData.metadata\n        );\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from bridgeAfterSwap since this function holds the logic for swapping tokens too.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in HyphenBridgeData struct\n     * @param swapId routeId for the swapImpl\n     * @param swapData encoded data for swap\n     * @param hyphenData encoded data for hyphenData\n     */\n    function swapAndBridge(\n        uint32 swapId,\n        bytes calldata swapData,\n        HyphenDataNoToken calldata hyphenData\n    ) external payable {\n        (bool success, bytes memory result) = socketRoute\n            .getRoute(swapId)\n            .delegatecall(swapData);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        (uint256 bridgeAmount, address token) = abi.decode(\n            result,\n            (uint256, address)\n        );\n        if (token == NATIVE_TOKEN_ADDRESS) {\n            liquidityPoolManager.depositNative{value: bridgeAmount}(\n                hyphenData.receiverAddress,\n                hyphenData.toChainId,\n                \"SOCKET\"\n            );\n        } else {\n            ERC20(token).safeApprove(\n                address(liquidityPoolManager),\n                bridgeAmount\n            );\n            liquidityPoolManager.depositErc20(\n                hyphenData.toChainId,\n                token,\n                hyphenData.receiverAddress,\n                bridgeAmount,\n                \"SOCKET\"\n            );\n        }\n\n        emit SocketBridge(\n            bridgeAmount,\n            token,\n            hyphenData.toChainId,\n            HyphenIdentifier,\n            msg.sender,\n            hyphenData.receiverAddress,\n            hyphenData.metadata\n        );\n    }\n\n    /**\n     * @notice function to handle ERC20 bridging to receipent via Hyphen-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param amount amount to be sent\n     * @param receiverAddress address of the token to bridged to the destination chain.\n     * @param token address of token being bridged\n     * @param toChainId chainId of destination\n     */\n    function bridgeERC20To(\n        uint256 amount,\n        bytes32 metadata,\n        address receiverAddress,\n        address token,\n        uint256 toChainId\n    ) external payable {\n        ERC20 tokenInstance = ERC20(token);\n        tokenInstance.safeTransferFrom(msg.sender, socketGateway, amount);\n        tokenInstance.safeApprove(address(liquidityPoolManager), amount);\n        liquidityPoolManager.depositErc20(\n            toChainId,\n            token,\n            receiverAddress,\n            amount,\n            \"SOCKET\"\n        );\n\n        emit SocketBridge(\n            amount,\n            token,\n            toChainId,\n            HyphenIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n\n    /**\n     * @notice function to handle Native bridging to receipent via Hyphen-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param amount amount to be sent\n     * @param receiverAddress address of the token to bridged to the destination chain.\n     * @param toChainId chainId of destination\n     */\n    function bridgeNativeTo(\n        uint256 amount,\n        bytes32 metadata,\n        address receiverAddress,\n        uint256 toChainId\n    ) external payable {\n        liquidityPoolManager.depositNative{value: amount}(\n            receiverAddress,\n            toChainId,\n            \"SOCKET\"\n        );\n\n        emit SocketBridge(\n            amount,\n            NATIVE_TOKEN_ADDRESS,\n            toChainId,\n            HyphenIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n}\n"},"src/bridges/optimism/l1/NativeOptimism.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport \"../interfaces/optimism.sol\";\nimport {BridgeImplBase} from \"../../BridgeImplBase.sol\";\nimport {UnsupportedInterfaceId} from \"../../../errors/SocketErrors.sol\";\nimport {NATIVE_OPTIMISM} from \"../../../static/RouteIdentifiers.sol\";\n\n/**\n * @title NativeOptimism-Route Implementation\n * @notice Route implementation with functions to bridge ERC20 and Native via NativeOptimism-Bridge\n * Tokens are bridged from Ethereum to Optimism Chain.\n * Called via SocketGateway if the routeId in the request maps to the routeId of NativeOptimism-Implementation\n * Contains function to handle bridging as post-step i.e linked to a preceeding step for swap\n * RequestData is different to just bride and bridging chained with swap\n * @author Socket dot tech.\n */\ncontract NativeOptimismImpl is BridgeImplBase {\n    using SafeTransferLib for ERC20;\n\n    bytes32 public immutable NativeOptimismIdentifier = NATIVE_OPTIMISM;\n\n    uint256 public constant DESTINATION_CHAIN_ID = 10;\n\n    /// @notice Function-selector for ERC20-token bridging on Native-Optimism-Route\n    /// @dev This function selector is to be used while buidling transaction-data to bridge ERC20 tokens\n    bytes4\n        public immutable NATIVE_OPTIMISM_ERC20_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeERC20To(address,address,address,uint32,(bytes32,bytes32),uint256,uint256,address,bytes)\"\n            )\n        );\n\n    /// @notice Function-selector for Native bridging on Native-Optimism-Route\n    /// @dev This function selector is to be used while buidling transaction-data to bridge Native balance\n    bytes4\n        public immutable NATIVE_OPTIMISM_NATIVE_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeNativeTo(address,address,uint32,uint256,bytes32,bytes)\"\n            )\n        );\n\n    bytes4 public immutable NATIVE_OPTIMISM_SWAP_BRIDGE_SELECTOR =\n        bytes4(\n            keccak256(\n                \"swapAndBridge(uint32,bytes,(uint256,bytes32,bytes32,address,address,uint32,address,bytes))\"\n            )\n        );\n\n    /// @notice socketGatewayAddress to be initialised via storage variable BridgeImplBase\n    constructor(\n        address _socketGateway,\n        address _socketDeployFactory\n    ) BridgeImplBase(_socketGateway, _socketDeployFactory) {}\n\n    /// @notice Struct to be used in decode step from input parameter - a specific case of bridging after swap.\n    /// @dev the data being encoded in offchain or by caller should have values set in this sequence of properties in this struct\n    struct OptimismBridgeDataNoToken {\n        // interfaceId to be set offchain which is used to select one of the 3 kinds of bridging (standard bridge / old standard / synthetic)\n        uint256 interfaceId;\n        // currencyKey of the token beingBridged\n        bytes32 currencyKey;\n        // socket offchain created hash\n        bytes32 metadata;\n        // address of receiver of bridged tokens\n        address receiverAddress;\n        /**\n         * OptimismBridge that Performs the logic for deposits by informing the L2 Deposited Token\n         * contract of the deposit and calling a handler to lock the L1 funds. (e.g. transferFrom)\n         */\n        address customBridgeAddress;\n        // Gas limit required to complete the deposit on L2.\n        uint32 l2Gas;\n        // Address of the L1 respective L2 ERC20\n        address l2Token;\n        // additional data , for ll contracts this will be 0x data or empty data\n        bytes data;\n    }\n\n    struct OptimismBridgeData {\n        // interfaceId to be set offchain which is used to select one of the 3 kinds of bridging (standard bridge / old standard / synthetic)\n        uint256 interfaceId;\n        // currencyKey of the token beingBridged\n        bytes32 currencyKey;\n        // socket offchain created hash\n        bytes32 metadata;\n        // address of receiver of bridged tokens\n        address receiverAddress;\n        /**\n         * OptimismBridge that Performs the logic for deposits by informing the L2 Deposited Token\n         * contract of the deposit and calling a handler to lock the L1 funds. (e.g. transferFrom)\n         */\n        address customBridgeAddress;\n        /// @notice address of token being bridged\n        address token;\n        // Gas limit required to complete the deposit on L2.\n        uint32 l2Gas;\n        // Address of the L1 respective L2 ERC20\n        address l2Token;\n        // additional data , for ll contracts this will be 0x data or empty data\n        bytes data;\n    }\n\n    struct OptimismERC20Data {\n        bytes32 currencyKey;\n        bytes32 metadata;\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from swapAndBridge, this function is called when the swap has already happened at a different place.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in OptimismBridgeData struct\n     * @param amount amount of tokens being bridged. this can be ERC20 or native\n     * @param bridgeData encoded data for Optimism-Bridge\n     */\n    function bridgeAfterSwap(\n        uint256 amount,\n        bytes calldata bridgeData\n    ) external payable override {\n        OptimismBridgeData memory optimismBridgeData = abi.decode(\n            bridgeData,\n            (OptimismBridgeData)\n        );\n\n        emit SocketBridge(\n            amount,\n            optimismBridgeData.token,\n            DESTINATION_CHAIN_ID,\n            NativeOptimismIdentifier,\n            msg.sender,\n            optimismBridgeData.receiverAddress,\n            optimismBridgeData.metadata\n        );\n        if (optimismBridgeData.token == NATIVE_TOKEN_ADDRESS) {\n            L1StandardBridge(optimismBridgeData.customBridgeAddress)\n                .depositETHTo{value: amount}(\n                optimismBridgeData.receiverAddress,\n                optimismBridgeData.l2Gas,\n                optimismBridgeData.data\n            );\n        } else {\n            if (optimismBridgeData.interfaceId == 0) {\n                revert UnsupportedInterfaceId();\n            }\n\n            ERC20(optimismBridgeData.token).safeApprove(\n                optimismBridgeData.customBridgeAddress,\n                amount\n            );\n\n            if (optimismBridgeData.interfaceId == 1) {\n                // deposit into standard bridge\n                L1StandardBridge(optimismBridgeData.customBridgeAddress)\n                    .depositERC20To(\n                        optimismBridgeData.token,\n                        optimismBridgeData.l2Token,\n                        optimismBridgeData.receiverAddress,\n                        amount,\n                        optimismBridgeData.l2Gas,\n                        optimismBridgeData.data\n                    );\n                return;\n            }\n\n            // Deposit Using Old Standard - iOVM_L1TokenGateway(Example - SNX Token)\n            if (optimismBridgeData.interfaceId == 2) {\n                OldL1TokenGateway(optimismBridgeData.customBridgeAddress)\n                    .depositTo(optimismBridgeData.receiverAddress, amount);\n                return;\n            }\n\n            if (optimismBridgeData.interfaceId == 3) {\n                OldL1TokenGateway(optimismBridgeData.customBridgeAddress)\n                    .initiateSynthTransfer(\n                        optimismBridgeData.currencyKey,\n                        optimismBridgeData.receiverAddress,\n                        amount\n                    );\n                return;\n            }\n        }\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from bridgeAfterSwap since this function holds the logic for swapping tokens too.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in OptimismBridgeData struct\n     * @param swapId routeId for the swapImpl\n     * @param swapData encoded data for swap\n     * @param optimismBridgeData encoded data for OptimismBridgeData\n     */\n    function swapAndBridge(\n        uint32 swapId,\n        bytes calldata swapData,\n        OptimismBridgeDataNoToken calldata optimismBridgeData\n    ) external payable {\n        (bool success, bytes memory result) = socketRoute\n            .getRoute(swapId)\n            .delegatecall(swapData);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        (uint256 bridgeAmount, address token) = abi.decode(\n            result,\n            (uint256, address)\n        );\n\n        emit SocketBridge(\n            bridgeAmount,\n            token,\n            DESTINATION_CHAIN_ID,\n            NativeOptimismIdentifier,\n            msg.sender,\n            optimismBridgeData.receiverAddress,\n            optimismBridgeData.metadata\n        );\n        if (token == NATIVE_TOKEN_ADDRESS) {\n            L1StandardBridge(optimismBridgeData.customBridgeAddress)\n                .depositETHTo{value: bridgeAmount}(\n                optimismBridgeData.receiverAddress,\n                optimismBridgeData.l2Gas,\n                optimismBridgeData.data\n            );\n        } else {\n            if (optimismBridgeData.interfaceId == 0) {\n                revert UnsupportedInterfaceId();\n            }\n\n            ERC20(token).safeApprove(\n                optimismBridgeData.customBridgeAddress,\n                bridgeAmount\n            );\n\n            if (optimismBridgeData.interfaceId == 1) {\n                // deposit into standard bridge\n                L1StandardBridge(optimismBridgeData.customBridgeAddress)\n                    .depositERC20To(\n                        token,\n                        optimismBridgeData.l2Token,\n                        optimismBridgeData.receiverAddress,\n                        bridgeAmount,\n                        optimismBridgeData.l2Gas,\n                        optimismBridgeData.data\n                    );\n                return;\n            }\n\n            // Deposit Using Old Standard - iOVM_L1TokenGateway(Example - SNX Token)\n            if (optimismBridgeData.interfaceId == 2) {\n                OldL1TokenGateway(optimismBridgeData.customBridgeAddress)\n                    .depositTo(\n                        optimismBridgeData.receiverAddress,\n                        bridgeAmount\n                    );\n                return;\n            }\n\n            if (optimismBridgeData.interfaceId == 3) {\n                OldL1TokenGateway(optimismBridgeData.customBridgeAddress)\n                    .initiateSynthTransfer(\n                        optimismBridgeData.currencyKey,\n                        optimismBridgeData.receiverAddress,\n                        bridgeAmount\n                    );\n                return;\n            }\n        }\n    }\n\n    /**\n     * @notice function to handle ERC20 bridging to receipent via NativeOptimism-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param token address of token being bridged\n     * @param receiverAddress address of receiver of bridged tokens\n     * @param customBridgeAddress OptimismBridge that Performs the logic for deposits by informing the L2 Deposited Token\n     *                           contract of the deposit and calling a handler to lock the L1 funds. (e.g. transferFrom)\n     * @param l2Gas Gas limit required to complete the deposit on L2.\n     * @param optimismData extra data needed for optimism bridge\n     * @param amount amount being bridged\n     * @param interfaceId interfaceId to be set offchain which is used to select one of the 3 kinds of bridging (standard bridge / old standard / synthetic)\n     * @param l2Token Address of the L1 respective L2 ERC20\n     * @param data additional data , for ll contracts this will be 0x data or empty data\n     */\n    function bridgeERC20To(\n        address token,\n        address receiverAddress,\n        address customBridgeAddress,\n        uint32 l2Gas,\n        OptimismERC20Data calldata optimismData,\n        uint256 amount,\n        uint256 interfaceId,\n        address l2Token,\n        bytes calldata data\n    ) external payable {\n        if (interfaceId == 0) {\n            revert UnsupportedInterfaceId();\n        }\n\n        ERC20 tokenInstance = ERC20(token);\n        tokenInstance.safeTransferFrom(msg.sender, socketGateway, amount);\n        tokenInstance.safeApprove(customBridgeAddress, amount);\n\n        emit SocketBridge(\n            amount,\n            token,\n            DESTINATION_CHAIN_ID,\n            NativeOptimismIdentifier,\n            msg.sender,\n            receiverAddress,\n            optimismData.metadata\n        );\n        if (interfaceId == 1) {\n            // deposit into standard bridge\n            L1StandardBridge(customBridgeAddress).depositERC20To(\n                token,\n                l2Token,\n                receiverAddress,\n                amount,\n                l2Gas,\n                data\n            );\n            return;\n        }\n\n        // Deposit Using Old Standard - iOVM_L1TokenGateway(Example - SNX Token)\n        if (interfaceId == 2) {\n            OldL1TokenGateway(customBridgeAddress).depositTo(\n                receiverAddress,\n                amount\n            );\n            return;\n        }\n\n        if (interfaceId == 3) {\n            OldL1TokenGateway(customBridgeAddress).initiateSynthTransfer(\n                optimismData.currencyKey,\n                receiverAddress,\n                amount\n            );\n            return;\n        }\n    }\n\n    /**\n     * @notice function to handle native balance bridging to receipent via NativeOptimism-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param receiverAddress address of receiver of bridged tokens\n     * @param customBridgeAddress OptimismBridge that Performs the logic for deposits by informing the L2 Deposited Token\n     *                           contract of the deposit and calling a handler to lock the L1 funds. (e.g. transferFrom)\n     * @param l2Gas Gas limit required to complete the deposit on L2.\n     * @param amount amount being bridged\n     * @param data additional data , for ll contracts this will be 0x data or empty data\n     */\n    function bridgeNativeTo(\n        address receiverAddress,\n        address customBridgeAddress,\n        uint32 l2Gas,\n        uint256 amount,\n        bytes32 metadata,\n        bytes calldata data\n    ) external payable {\n        L1StandardBridge(customBridgeAddress).depositETHTo{value: amount}(\n            receiverAddress,\n            l2Gas,\n            data\n        );\n\n        emit SocketBridge(\n            amount,\n            NATIVE_TOKEN_ADDRESS,\n            DESTINATION_CHAIN_ID,\n            NativeOptimismIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n}\n"},"src/deployFactory/SocketDeployFactory.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/Ownable.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {ISocketBridgeBase} from \"../interfaces/ISocketBridgeBase.sol\";\n\n/**\n * @dev In the constructor, set up the initialization code for socket\n * contracts as well as the keccak256 hash of the given initialization code.\n * that will be used to deploy any transient contracts, which will deploy any\n * socket contracts that require the use of a constructor.\n *\n * Socket contract initialization code (29 bytes):\n *\n *       0x5860208158601c335a63aaf10f428752fa158151803b80938091923cf3\n *\n * Description:\n *\n * pc|op|name         | [stack]                                | <memory>\n *\n * ** set the first stack item to zero - used later **\n * 00 58 getpc          [0]                                       <>\n *\n * ** set second stack item to 32, length of word returned from staticcall **\n * 01 60 push1\n * 02 20 outsize        [0, 32]                                   <>\n *\n * ** set third stack item to 0, position of word returned from staticcall **\n * 03 81 dup2           [0, 32, 0]                                <>\n *\n * ** set fourth stack item to 4, length of selector given to staticcall **\n * 04 58 getpc          [0, 32, 0, 4]                             <>\n *\n * ** set fifth stack item to 28, position of selector given to staticcall **\n * 05 60 push1\n * 06 1c inpos          [0, 32, 0, 4, 28]                         <>\n *\n * ** set the sixth stack item to msg.sender, target address for staticcall **\n * 07 33 caller         [0, 32, 0, 4, 28, caller]                 <>\n *\n * ** set the seventh stack item to msg.gas, gas to forward for staticcall **\n * 08 5a gas            [0, 32, 0, 4, 28, caller, gas]            <>\n *\n * ** set the eighth stack item to selector, \"what\" to store via mstore **\n * 09 63 push4\n * 10 aaf10f42 selector [0, 32, 0, 4, 28, caller, gas, 0xaaf10f42]    <>\n *\n * ** set the ninth stack item to 0, \"where\" to store via mstore ***\n * 11 87 dup8           [0, 32, 0, 4, 28, caller, gas, 0xaaf10f42, 0] <>\n *\n * ** call mstore, consume 8 and 9 from the stack, place selector in memory **\n * 12 52 mstore         [0, 32, 0, 4, 0, caller, gas]             <0xaaf10f42>\n *\n * ** call staticcall, consume items 2 through 7, place address in memory **\n * 13 fa staticcall     [0, 1 (if successful)]                    <address>\n *\n * ** flip success bit in second stack item to set to 0 **\n * 14 15 iszero         [0, 0]                                    <address>\n *\n * ** push a third 0 to the stack, position of address in memory **\n * 15 81 dup2           [0, 0, 0]                                 <address>\n *\n * ** place address from position in memory onto third stack item **\n * 16 51 mload          [0, 0, address]                           <>\n *\n * ** place address to fourth stack item for extcodesize to consume **\n * 17 80 dup1           [0, 0, address, address]                  <>\n *\n * ** get extcodesize on fourth stack item for extcodecopy **\n * 18 3b extcodesize    [0, 0, address, size]                     <>\n *\n * ** dup and swap size for use by return at end of init code **\n * 19 80 dup1           [0, 0, address, size, size]               <>\n * 20 93 swap4          [size, 0, address, size, 0]               <>\n *\n * ** push code position 0 to stack and reorder stack items for extcodecopy **\n * 21 80 dup1           [size, 0, address, size, 0, 0]            <>\n * 22 91 swap2          [size, 0, address, 0, 0, size]            <>\n * 23 92 swap3          [size, 0, size, 0, 0, address]            <>\n *\n * ** call extcodecopy, consume four items, clone runtime code to memory **\n * 24 3c extcodecopy    [size, 0]                                 <code>\n *\n * ** return to deploy final code in memory **\n * 25 f3 return         []                                        *deployed!*\n */\ncontract SocketDeployFactory is Ownable {\n    using SafeTransferLib for ERC20;\n    address public immutable disabledRouteAddress;\n\n    mapping(address => address) _implementations;\n    mapping(uint256 => bool) isDisabled;\n    mapping(uint256 => bool) isRouteDeployed;\n    mapping(address => bool) canDisableRoute;\n\n    event Deployed(address _addr);\n    event DisabledRoute(address _addr);\n    event Destroyed(address _addr);\n    error ContractAlreadyDeployed();\n    error NothingToDestroy();\n    error AlreadyDisabled();\n    error CannotBeDisabled();\n    error OnlyDisabler();\n\n    constructor(address _owner, address disabledRoute) Ownable(_owner) {\n        disabledRouteAddress = disabledRoute;\n        canDisableRoute[_owner] = true;\n    }\n\n    modifier onlyDisabler() {\n        if (!canDisableRoute[msg.sender]) {\n            revert OnlyDisabler();\n        }\n        _;\n    }\n\n    function addDisablerAddress(address disabler) external onlyOwner {\n        canDisableRoute[disabler] = true;\n    }\n\n    function removeDisablerAddress(address disabler) external onlyOwner {\n        canDisableRoute[disabler] = false;\n    }\n\n    /**\n     * @notice Deploys a route contract at predetermined location\n     * @notice Caller must first deploy the route contract at another location and pass its address as implementation.\n     * @param routeId route identifier\n     * @param implementationContract address of deployed route contract. Its byte code will be copied to predetermined location.\n     */\n    function deploy(\n        uint256 routeId,\n        address implementationContract\n    ) external onlyOwner returns (address) {\n        // assign the initialization code for the socket contract.\n\n        bytes memory initCode = (\n            hex\"5860208158601c335a63aaf10f428752fa158151803b80938091923cf3\"\n        );\n\n        // determine the address of the socket contract.\n        address routeContractAddress = _getContractAddress(routeId);\n\n        if (isRouteDeployed[routeId]) {\n            revert ContractAlreadyDeployed();\n        }\n\n        isRouteDeployed[routeId] = true;\n\n        //first we deploy the code we want to deploy on a separate address\n        // store the implementation to be retrieved by the socket contract.\n        _implementations[routeContractAddress] = implementationContract;\n        address addr;\n        assembly {\n            let encoded_data := add(0x20, initCode) // load initialization code.\n            let encoded_size := mload(initCode) // load init code's length.\n            addr := create2(0, encoded_data, encoded_size, routeId) // routeId is used as salt\n        }\n        require(\n            addr == routeContractAddress,\n            \"Failed to deploy the new socket contract.\"\n        );\n        emit Deployed(addr);\n        return addr;\n    }\n\n    /**\n     * @notice Destroy the route deployed at a location.\n     * @param routeId route identifier to be destroyed.\n     */\n    function destroy(uint256 routeId) external onlyDisabler {\n        // determine the address of the socket contract.\n        _destroy(routeId);\n    }\n\n    /**\n     * @notice Deploy a disabled contract at destroyed route to handle it gracefully.\n     * @param routeId route identifier to be disabled.\n     */\n    function disableRoute(\n        uint256 routeId\n    ) external onlyDisabler returns (address) {\n        return _disableRoute(routeId);\n    }\n\n    /**\n     * @notice Destroy a list of routeIds\n     * @param routeIds array of routeIds to be destroyed.\n     */\n    function multiDestroy(uint256[] calldata routeIds) external onlyDisabler {\n        for (uint32 index = 0; index < routeIds.length; ) {\n            _destroy(routeIds[index]);\n            unchecked {\n                ++index;\n            }\n        }\n    }\n\n    /**\n     * @notice Deploy a disabled contract at list of routeIds.\n     * @param routeIds array of routeIds to be disabled.\n     */\n    function multiDisableRoute(\n        uint256[] calldata routeIds\n    ) external onlyDisabler {\n        for (uint32 index = 0; index < routeIds.length; ) {\n            _disableRoute(routeIds[index]);\n            unchecked {\n                ++index;\n            }\n        }\n    }\n\n    /**\n     * @dev External view function for calculating a socket contract address\n     * given a particular routeId.\n     */\n    function getContractAddress(\n        uint256 routeId\n    ) external view returns (address) {\n        // determine the address of the socket contract.\n        return _getContractAddress(routeId);\n    }\n\n    //those two functions are getting called by the socket Contract\n    function getImplementation()\n        external\n        view\n        returns (address implementation)\n    {\n        return _implementations[msg.sender];\n    }\n\n    function _disableRoute(uint256 routeId) internal returns (address) {\n        // assign the initialization code for the socket contract.\n        bytes memory initCode = (\n            hex\"5860208158601c335a63aaf10f428752fa158151803b80938091923cf3\"\n        );\n\n        // determine the address of the socket contract.\n        address routeContractAddress = _getContractAddress(routeId);\n\n        if (!isRouteDeployed[routeId]) {\n            revert CannotBeDisabled();\n        }\n\n        if (isDisabled[routeId]) {\n            revert AlreadyDisabled();\n        }\n\n        isDisabled[routeId] = true;\n\n        //first we deploy the code we want to deploy on a separate address\n        // store the implementation to be retrieved by the socket contract.\n        _implementations[routeContractAddress] = disabledRouteAddress;\n        address addr;\n        assembly {\n            let encoded_data := add(0x20, initCode) // load initialization code.\n            let encoded_size := mload(initCode) // load init code's length.\n            addr := create2(0, encoded_data, encoded_size, routeId) // routeId is used as salt.\n        }\n        require(\n            addr == routeContractAddress,\n            \"Failed to deploy the new socket contract.\"\n        );\n        emit Deployed(addr);\n        return addr;\n    }\n\n    function _destroy(uint256 routeId) internal {\n        // determine the address of the socket contract.\n        address routeContractAddress = _getContractAddress(routeId);\n\n        if (!isRouteDeployed[routeId]) {\n            revert NothingToDestroy();\n        }\n        ISocketBridgeBase(routeContractAddress).killme();\n        emit Destroyed(routeContractAddress);\n    }\n\n    /**\n     * @dev Internal view function for calculating a socket contract address\n     * given a particular routeId.\n     */\n    function _getContractAddress(\n        uint256 routeId\n    ) internal view returns (address) {\n        // determine the address of the socket contract.\n\n        bytes memory initCode = (\n            hex\"5860208158601c335a63aaf10f428752fa158151803b80938091923cf3\"\n        );\n        return\n            address(\n                uint160( // downcast to match the address type.\n                    uint256( // convert to uint to truncate upper digits.\n                        keccak256( // compute the CREATE2 hash using 4 inputs.\n                            abi.encodePacked( // pack all inputs to the hash together.\n                                hex\"ff\", // start with 0xff to distinguish from RLP.\n                                address(this), // this contract will be the caller.\n                                routeId, // the routeId is used as salt.\n                                keccak256(abi.encodePacked(initCode)) // the init code hash.\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    /**\n     * @notice Rescues the ERC20 token to an address\n               this is a restricted function to be called by only socketGatewayOwner\n     * @dev as this is a restricted to socketGatewayOwner, ensure the userAddress is a known address\n     * @param token address of the ERC20 token being rescued\n     * @param userAddress address to which ERC20 is to be rescued\n     * @param amount amount of ERC20 tokens being rescued\n     */\n    function rescueFunds(\n        address token,\n        address userAddress,\n        uint256 amount\n    ) external onlyOwner {\n        ERC20(token).safeTransfer(userAddress, amount);\n    }\n\n    /**\n     * @notice Rescues the native balance to an address\n               this is a restricted function to be called by only socketGatewayOwner\n     * @dev as this is a restricted to socketGatewayOwner, ensure the userAddress is a known address\n     * @param userAddress address to which native-balance is to be rescued\n     * @param amount amount of native-balance being rescued\n     */\n    function rescueEther(\n        address payable userAddress,\n        uint256 amount\n    ) external onlyOwner {\n        userAddress.transfer(amount);\n    }\n}\n"},"src/interfaces/ISocketController.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ISocketController\n * @notice Interface for SocketController functions.\n * @dev functions can be added here for invocation from external contracts or off-chain\n *      only restriction is that this should have functions to manage controllers\n * @author Socket dot tech.\n */\ninterface ISocketController {\n    /**\n     * @notice Add controller to the socketGateway\n               This is a restricted function to be called by only socketGatewayOwner\n     * @dev ensure controllerAddress is a verified controller implementation address\n     * @param _controllerAddress The address of controller implementation contract deployed\n     * @return Id of the controller added to the controllers-mapping in socketGateway storage\n     */\n    function addController(\n        address _controllerAddress\n    ) external returns (uint32);\n\n    /**\n     * @notice disable controller by setting ZeroAddress to the entry in controllers-mapping\n               identified by controllerId as key.\n               This is a restricted function to be called by only socketGatewayOwner\n     * @param _controllerId The Id of controller-implementation in the controllers mapping\n     */\n    function disableController(uint32 _controllerId) external;\n\n    /**\n     * @notice Get controllerImplementation address mapped to the controllerId\n     * @param _controllerId controllerId is the key in the mapping for controllers\n     * @return controller-implementation address\n     */\n    function getController(uint32 _controllerId) external returns (address);\n}\n"},"lib/solmate/src/utils/SafeTransferLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"},"src/controllers/BaseController.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {ISocketRequest} from \"../interfaces/ISocketRequest.sol\";\nimport {ISocketRoute} from \"../interfaces/ISocketRoute.sol\";\n\n/// @title BaseController Controller\n/// @notice Base contract for all controller contracts\nabstract contract BaseController {\n    /// @notice Address used to identify if it is a native token transfer or not\n    address public immutable NATIVE_TOKEN_ADDRESS =\n        address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    /// @notice Address used to identify if it is a Zero address\n    address public immutable NULL_ADDRESS = address(0);\n\n    /// @notice FunctionSelector used to delegatecall from swap to the function of bridge router implementation\n    bytes4 public immutable BRIDGE_AFTER_SWAP_SELECTOR =\n        bytes4(keccak256(\"bridgeAfterSwap(uint256,bytes)\"));\n\n    /// @notice immutable variable to store the socketGateway address\n    address public immutable socketGatewayAddress;\n\n    /// @notice immutable variable with instance of SocketRoute to access route functions\n    ISocketRoute public immutable socketRoute;\n\n    /**\n     * @notice Construct the base for all controllers.\n     * @param _socketGatewayAddress Socketgateway address, an immutable variable to set.\n     * @notice initialize the immutable variables of SocketRoute, SocketGateway\n     */\n    constructor(address _socketGatewayAddress) {\n        socketGatewayAddress = _socketGatewayAddress;\n        socketRoute = ISocketRoute(_socketGatewayAddress);\n    }\n\n    /**\n     * @notice Construct the base for all BridgeImplementations.\n     * @param routeId routeId mapped to the routrImplementation\n     * @param data transactionData generated with arguments of bridgeRequest (offchain or by caller)\n     * @return returns the bytes response of the route execution (bridging, refuel or swap executions)\n     */\n    function _executeRoute(\n        uint32 routeId,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory result) = socketRoute\n            .getRoute(routeId)\n            .delegatecall(data);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        return result;\n    }\n}\n"},"src/interfaces/ISocketRoute.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ISocketRoute\n * @notice Interface for routeManagement functions in SocketGateway.\n * @author Socket dot tech.\n */\ninterface ISocketRoute {\n    /**\n     * @notice Add route to the socketGateway\n               This is a restricted function to be called by only socketGatewayOwner\n     * @dev ensure routeAddress is a verified bridge or middleware implementation address\n     * @param routeAddress The address of bridge or middleware implementation contract deployed\n     * @return Id of the route added to the routes-mapping in socketGateway storage\n     */\n    function addRoute(address routeAddress) external returns (uint256);\n\n    /**\n     * @notice disable a route by setting ZeroAddress to the entry in routes-mapping\n               identified by routeId as key.\n               This is a restricted function to be called by only socketGatewayOwner\n     * @param routeId The Id of route-implementation in the routes mapping\n     */\n    function disableRoute(uint32 routeId) external;\n\n    /**\n     * @notice Get routeImplementation address mapped to the routeId\n     * @param routeId routeId is the key in the mapping for routes\n     * @return route-implementation address\n     */\n    function getRoute(uint32 routeId) external view returns (address);\n}\n"},"src/SocketGatewayDeployment.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\npragma experimental ABIEncoderV2;\n\nimport \"./utils/Ownable.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {LibUtil} from \"./libraries/LibUtil.sol\";\nimport \"./libraries/LibBytes.sol\";\nimport {ISocketRoute} from \"./interfaces/ISocketRoute.sol\";\nimport {ISocketRequest} from \"./interfaces/ISocketRequest.sol\";\nimport {ISocketGateway} from \"./interfaces/ISocketGateway.sol\";\nimport {IncorrectBridgeRatios, ZeroAddressNotAllowed, ArrayLengthMismatch} from \"./errors/SocketErrors.sol\";\n\n/// @title SocketGatewayContract\n/// @notice Socketgateway is a contract with entrypoint functions for all interactions with socket liquidity layer\n/// @author Socket Team\ncontract SocketGateway is Ownable {\n    using LibBytes for bytes;\n    using LibBytes for bytes4;\n    using SafeTransferLib for ERC20;\n\n    /// @notice FunctionSelector used to delegatecall from swap to the function of bridge router implementation\n    bytes4 public immutable BRIDGE_AFTER_SWAP_SELECTOR =\n        bytes4(keccak256(\"bridgeAfterSwap(uint256,bytes)\"));\n\n    /// @notice storage variable to keep track of total number of routes registered in socketgateway\n    uint32 public routesCount = 385;\n\n    /// @notice storage variable to keep track of total number of controllers registered in socketgateway\n    uint32 public controllerCount;\n\n    address public immutable disabledRouteAddress;\n\n    uint256 public constant CENT_PERCENT = 100e18;\n\n    /// @notice storage mapping for route implementation addresses\n    mapping(uint32 => address) public routes;\n\n    /// storage mapping for controller implemenation addresses\n    mapping(uint32 => address) public controllers;\n\n    // Events ------------------------------------------------------------------------------------------------------->\n\n    /// @notice Event emitted when a router is added to socketgateway\n    event NewRouteAdded(uint32 indexed routeId, address indexed route);\n\n    /// @notice Event emitted when a route is disabled\n    event RouteDisabled(uint32 indexed routeId);\n\n    /// @notice Event emitted when ownership transfer is requested by socket-gateway-owner\n    event OwnershipTransferRequested(\n        address indexed _from,\n        address indexed _to\n    );\n\n    /// @notice Event emitted when a controller is added to socketgateway\n    event ControllerAdded(\n        uint32 indexed controllerId,\n        address indexed controllerAddress\n    );\n\n    /// @notice Event emitted when a controller is disabled\n    event ControllerDisabled(uint32 indexed controllerId);\n\n    constructor(address _owner, address _disabledRoute) Ownable(_owner) {\n        disabledRouteAddress = _disabledRoute;\n    }\n\n    // Able to receive ether\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    /*******************************************\n     *          EXTERNAL AND PUBLIC FUNCTIONS  *\n     *******************************************/\n\n    /**\n     * @notice executes functions in the routes identified using routeId and functionSelectorData\n     * @notice The caller must first approve this contract to spend amount of ERC20-Token being bridged/swapped\n     * @dev ensure the data in routeData to be built using the function-selector defined as a\n     *         constant in the route implementation contract\n     * @param routeId route identifier\n     * @param routeData functionSelectorData generated using the function-selector defined in the route Implementation\n     */\n    function executeRoute(\n        uint32 routeId,\n        bytes calldata routeData\n    ) external payable returns (bytes memory) {\n        (bool success, bytes memory result) = addressAt(routeId).delegatecall(\n            routeData\n        );\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice swaps a token on sourceChain and split it across multiple bridge-recipients\n     * @notice The caller must first approve this contract to spend amount of ERC20-Token being swapped\n     * @dev ensure the swap-data and bridge-data is generated using the function-selector defined as a constant in the implementation address\n     * @param swapMultiBridgeRequest request\n     */\n    function swapAndMultiBridge(\n        ISocketRequest.SwapMultiBridgeRequest calldata swapMultiBridgeRequest\n    ) external payable {\n        uint256 requestLength = swapMultiBridgeRequest.bridgeRouteIds.length;\n\n        if (\n            requestLength != swapMultiBridgeRequest.bridgeImplDataItems.length\n        ) {\n            revert ArrayLengthMismatch();\n        }\n        uint256 ratioAggregate;\n        for (uint256 index = 0; index < requestLength; ) {\n            ratioAggregate += swapMultiBridgeRequest.bridgeRatios[index];\n        }\n\n        if (ratioAggregate != CENT_PERCENT) {\n            revert IncorrectBridgeRatios();\n        }\n\n        (bool swapSuccess, bytes memory swapResult) = addressAt(\n            swapMultiBridgeRequest.swapRouteId\n        ).delegatecall(swapMultiBridgeRequest.swapImplData);\n\n        if (!swapSuccess) {\n            assembly {\n                revert(add(swapResult, 32), mload(swapResult))\n            }\n        }\n\n        uint256 amountReceivedFromSwap = abi.decode(swapResult, (uint256));\n\n        uint256 bridgedAmount;\n\n        for (uint256 index = 0; index < requestLength; ) {\n            uint256 bridgingAmount;\n\n            // if it is the last bridge request, bridge the remaining amount\n            if (index == requestLength - 1) {\n                bridgingAmount = amountReceivedFromSwap - bridgedAmount;\n            } else {\n                // bridging amount is the multiplication of bridgeRatio and amountReceivedFromSwap\n                bridgingAmount =\n                    (amountReceivedFromSwap *\n                        swapMultiBridgeRequest.bridgeRatios[index]) /\n                    (CENT_PERCENT);\n            }\n\n            // update the bridged amount, this would be used for computation for last bridgeRequest\n            bridgedAmount += bridgingAmount;\n\n            bytes memory bridgeImpldata = abi.encodeWithSelector(\n                BRIDGE_AFTER_SWAP_SELECTOR,\n                bridgingAmount,\n                swapMultiBridgeRequest.bridgeImplDataItems[index]\n            );\n\n            (bool bridgeSuccess, bytes memory bridgeResult) = addressAt(\n                swapMultiBridgeRequest.bridgeRouteIds[index]\n            ).delegatecall(bridgeImpldata);\n\n            if (!bridgeSuccess) {\n                assembly {\n                    revert(add(bridgeResult, 32), mload(bridgeResult))\n                }\n            }\n\n            unchecked {\n                ++index;\n            }\n        }\n    }\n\n    /**\n     * @notice sequentially executes functions in the routes identified using routeId and functionSelectorData\n     * @notice The caller must first approve this contract to spend amount of ERC20-Token being bridged/swapped\n     * @dev ensure the data in each dataItem to be built using the function-selector defined as a\n     *         constant in the route implementation contract\n     * @param routeIds a list of route identifiers\n     * @param dataItems a list of functionSelectorData generated using the function-selector defined in the route Implementation\n     */\n    function executeRoutes(\n        uint32[] calldata routeIds,\n        bytes[] calldata dataItems\n    ) external payable {\n        uint256 routeIdslength = routeIds.length;\n        if (routeIdslength != dataItems.length) revert ArrayLengthMismatch();\n        for (uint256 index = 0; index < routeIdslength; ) {\n            (bool success, bytes memory result) = addressAt(routeIds[index])\n                .delegatecall(dataItems[index]);\n\n            if (!success) {\n                assembly {\n                    revert(add(result, 32), mload(result))\n                }\n            }\n\n            unchecked {\n                ++index;\n            }\n        }\n    }\n\n    /**\n     * @notice execute a controller function identified using the controllerId in the request\n     * @notice The caller must first approve this contract to spend amount of ERC20-Token being bridged/swapped\n     * @dev ensure the data in request to be built using the function-selector defined as a\n     *         constant in the controller implementation contract\n     * @param socketControllerRequest socketControllerRequest with controllerId to identify the\n     *                                   controllerAddress and byteData constructed using functionSelector\n     *                                   of the function being invoked\n     * @return bytes data received from the call delegated to controller\n     */\n    function executeController(\n        ISocketGateway.SocketControllerRequest calldata socketControllerRequest\n    ) external payable returns (bytes memory) {\n        (bool success, bytes memory result) = controllers[\n            socketControllerRequest.controllerId\n        ].delegatecall(socketControllerRequest.data);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice sequentially executes all controller requests\n     * @notice The caller must first approve this contract to spend amount of ERC20-Token being bridged/swapped\n     * @dev ensure the data in each controller-request to be built using the function-selector defined as a\n     *         constant in the controller implementation contract\n     * @param controllerRequests a list of socketControllerRequest\n     *                              Each controllerRequest contains controllerId to identify the controllerAddress and\n     *                              byteData constructed using functionSelector of the function being invoked\n     */\n    function executeControllers(\n        ISocketGateway.SocketControllerRequest[] calldata controllerRequests\n    ) external payable {\n        for (uint32 index = 0; index < controllerRequests.length; ) {\n            (bool success, bytes memory result) = controllers[\n                controllerRequests[index].controllerId\n            ].delegatecall(controllerRequests[index].data);\n\n            if (!success) {\n                assembly {\n                    revert(add(result, 32), mload(result))\n                }\n            }\n\n            unchecked {\n                ++index;\n            }\n        }\n    }\n\n    /**************************************\n     *          ADMIN FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Add route to the socketGateway\n               This is a restricted function to be called by only socketGatewayOwner\n     * @dev ensure routeAddress is a verified bridge or middleware implementation address\n     * @param routeAddress The address of bridge or middleware implementation contract deployed\n     * @return Id of the route added to the routes-mapping in socketGateway storage\n     */\n    function addRoute(\n        address routeAddress\n    ) external onlyOwner returns (uint32) {\n        uint32 routeId = routesCount;\n        routes[routeId] = routeAddress;\n\n        routesCount += 1;\n\n        emit NewRouteAdded(routeId, routeAddress);\n\n        return routeId;\n    }\n\n    /**\n     * @notice Give Infinite or 0 approval to bridgeRoute for the tokenAddress\n               This is a restricted function to be called by only socketGatewayOwner\n     */\n\n    function setApprovalForRouters(\n        address[] memory routeAddresses,\n        address[] memory tokenAddresses,\n        bool isMax\n    ) external onlyOwner {\n        for (uint32 index = 0; index < routeAddresses.length; ) {\n            ERC20(tokenAddresses[index]).approve(\n                routeAddresses[index],\n                isMax ? type(uint256).max : 0\n            );\n            unchecked {\n                ++index;\n            }\n        }\n    }\n\n    /**\n     * @notice Add controller to the socketGateway\n               This is a restricted function to be called by only socketGatewayOwner\n     * @dev ensure controllerAddress is a verified controller implementation address\n     * @param controllerAddress The address of controller implementation contract deployed\n     * @return Id of the controller added to the controllers-mapping in socketGateway storage\n     */\n    function addController(\n        address controllerAddress\n    ) external onlyOwner returns (uint32) {\n        uint32 controllerId = controllerCount;\n\n        controllers[controllerId] = controllerAddress;\n\n        controllerCount += 1;\n\n        emit ControllerAdded(controllerId, controllerAddress);\n\n        return controllerId;\n    }\n\n    /**\n     * @notice disable controller by setting ZeroAddress to the entry in controllers-mapping\n               identified by controllerId as key.\n               This is a restricted function to be called by only socketGatewayOwner\n     * @param controllerId The Id of controller-implementation in the controllers mapping\n     */\n    function disableController(uint32 controllerId) public onlyOwner {\n        controllers[controllerId] = disabledRouteAddress;\n        emit ControllerDisabled(controllerId);\n    }\n\n    /**\n     * @notice disable a route by setting ZeroAddress to the entry in routes-mapping\n               identified by routeId as key.\n               This is a restricted function to be called by only socketGatewayOwner\n     * @param routeId The Id of route-implementation in the routes mapping\n     */\n    function disableRoute(uint32 routeId) external onlyOwner {\n        routes[routeId] = disabledRouteAddress;\n        emit RouteDisabled(routeId);\n    }\n\n    /*******************************************\n     *          RESTRICTED RESCUE FUNCTIONS    *\n     *******************************************/\n\n    /**\n     * @notice Rescues the ERC20 token to an address\n               this is a restricted function to be called by only socketGatewayOwner\n     * @dev as this is a restricted to socketGatewayOwner, ensure the userAddress is a known address\n     * @param token address of the ERC20 token being rescued\n     * @param userAddress address to which ERC20 is to be rescued\n     * @param amount amount of ERC20 tokens being rescued\n     */\n    function rescueFunds(\n        address token,\n        address userAddress,\n        uint256 amount\n    ) external onlyOwner {\n        ERC20(token).safeTransfer(userAddress, amount);\n    }\n\n    /**\n     * @notice Rescues the native balance to an address\n               this is a restricted function to be called by only socketGatewayOwner\n     * @dev as this is a restricted to socketGatewayOwner, ensure the userAddress is a known address\n     * @param userAddress address to which native-balance is to be rescued\n     * @param amount amount of native-balance being rescued\n     */\n    function rescueEther(\n        address payable userAddress,\n        uint256 amount\n    ) external onlyOwner {\n        userAddress.transfer(amount);\n    }\n\n    /*******************************************\n     *          VIEW FUNCTIONS                  *\n     *******************************************/\n\n    /**\n     * @notice Get routeImplementation address mapped to the routeId\n     * @param routeId routeId is the key in the mapping for routes\n     * @return route-implementation address\n     */\n    function getRoute(uint32 routeId) public view returns (address) {\n        return addressAt(routeId);\n    }\n\n    /**\n     * @notice Get controllerImplementation address mapped to the controllerId\n     * @param controllerId controllerId is the key in the mapping for controllers\n     * @return controller-implementation address\n     */\n    function getController(uint32 controllerId) public view returns (address) {\n        return controllers[controllerId];\n    }\n\n    function addressAt(uint32 routeId) public view returns (address) {\n        if (routeId < 385) {\n            if (routeId < 257) {\n                if (routeId < 129) {\n                    if (routeId < 65) {\n                        if (routeId < 33) {\n                            if (routeId < 17) {\n                                if (routeId < 9) {\n                                    if (routeId < 5) {\n                                        if (routeId < 3) {\n                                            if (routeId == 1) {\n                                                return\n                                                    0x8cd6BaCDAe46B449E2e5B34e348A4eD459c84D50;\n                                            } else {\n                                                return\n                                                    0x31524750Cd865fF6A3540f232754Fb974c18585C;\n                                            }\n                                        } else {\n                                            if (routeId == 3) {\n                                                return\n                                                    0xEd9b37342BeC8f3a2D7b000732ec87498aA6EC6a;\n                                            } else {\n                                                return\n                                                    0xE8704Ef6211F8988Ccbb11badC89841808d66890;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 7) {\n                                            if (routeId == 5) {\n                                                return\n                                                    0x9aFF58C460a461578C433e11C4108D1c4cF77761;\n                                            } else {\n                                                return\n                                                    0x2D1733886cFd465B0B99F1492F40847495f334C5;\n                                            }\n                                        } else {\n                                            if (routeId == 7) {\n                                                return\n                                                    0x715497Be4D130F04B8442F0A1F7a9312D4e54FC4;\n                                            } else {\n                                                return\n                                                    0x90C8a40c38E633B5B0e0d0585b9F7FA05462CaaF;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 13) {\n                                        if (routeId < 11) {\n                                            if (routeId == 9) {\n                                                return\n                                                    0xa402b70FCfF3F4a8422B93Ef58E895021eAdE4F6;\n                                            } else {\n                                                return\n                                                    0xc1B718522E15CD42C4Ac385a929fc2B51f5B892e;\n                                            }\n                                        } else {\n                                            if (routeId == 11) {\n                                                return\n                                                    0xa97bf2f7c26C43c010c349F52f5eA5dC49B2DD38;\n                                            } else {\n                                                return\n                                                    0x969423d71b62C81d2f28d707364c9Dc4a0764c53;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 15) {\n                                            if (routeId == 13) {\n                                                return\n                                                    0xF86729934C083fbEc8C796068A1fC60701Ea1207;\n                                            } else {\n                                                return\n                                                    0xD7cC2571F5823caCA26A42690D2BE7803DD5393f;\n                                            }\n                                        } else {\n                                            if (routeId == 15) {\n                                                return\n                                                    0x7c8837a279bbbf7d8B93413763176de9F65d5bB9;\n                                            } else {\n                                                return\n                                                    0x13b81C27B588C07D04458ed7dDbdbD26D1e39bcc;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 25) {\n                                    if (routeId < 21) {\n                                        if (routeId < 19) {\n                                            if (routeId == 17) {\n                                                return\n                                                    0x52560Ac678aFA1345D15474287d16Dc1eA3F78aE;\n                                            } else {\n                                                return\n                                                    0x1E31e376551459667cd7643440c1b21CE69065A0;\n                                            }\n                                        } else {\n                                            if (routeId == 19) {\n                                                return\n                                                    0xc57D822CB3288e7b97EF8f8af0EcdcD1B783529B;\n                                            } else {\n                                                return\n                                                    0x2197A1D9Af24b4d6a64Bff95B4c29Fcd3Ff28C30;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 23) {\n                                            if (routeId == 21) {\n                                                return\n                                                    0xE3700feAa5100041Bf6b7AdBA1f72f647809Fd00;\n                                            } else {\n                                                return\n                                                    0xc02E8a0Fdabf0EeFCEA025163d90B5621E2b9948;\n                                            }\n                                        } else {\n                                            if (routeId == 23) {\n                                                return\n                                                    0xF5144235E2926cAb3c69b30113254Fa632f72d62;\n                                            } else {\n                                                return\n                                                    0xBa3F92313B00A1f7Bc53b2c24EB195c8b2F57682;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 29) {\n                                        if (routeId < 27) {\n                                            if (routeId == 25) {\n                                                return\n                                                    0x77a6856fe1fFA5bEB55A1d2ED86E27C7c482CB76;\n                                            } else {\n                                                return\n                                                    0x4826Ff4e01E44b1FCEFBfb38cd96687Eb7786b44;\n                                            }\n                                        } else {\n                                            if (routeId == 27) {\n                                                return\n                                                    0x55FF3f5493cf5e80E76DEA7E327b9Cd8440Af646;\n                                            } else {\n                                                return\n                                                    0xF430Db544bE9770503BE4aa51997aA19bBd5BA4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 31) {\n                                            if (routeId == 29) {\n                                                return\n                                                    0x0f166446ce1484EE3B0663E7E67DF10F5D240115;\n                                            } else {\n                                                return\n                                                    0x6365095D92537f242Db5EdFDd572745E72aC33d9;\n                                            }\n                                        } else {\n                                            if (routeId == 31) {\n                                                return\n                                                    0x5c7BC93f06ce3eAe75ADf55E10e23d2c1dE5Bc65;\n                                            } else {\n                                                return\n                                                    0xe46383bAD90d7A08197ccF08972e9DCdccCE9BA4;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            if (routeId < 49) {\n                                if (routeId < 41) {\n                                    if (routeId < 37) {\n                                        if (routeId < 35) {\n                                            if (routeId == 33) {\n                                                return\n                                                    0xf0f21710c071E3B728bdc4654c3c0b873aAaa308;\n                                            } else {\n                                                return\n                                                    0x63Bc9ed3AcAAeB0332531C9fB03b0a2352E9Ff25;\n                                            }\n                                        } else {\n                                            if (routeId == 35) {\n                                                return\n                                                    0xd1CE808625CB4007a1708824AE82CdB0ece57De9;\n                                            } else {\n                                                return\n                                                    0x57BbB148112f4ba224841c3FE018884171004661;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 39) {\n                                            if (routeId == 37) {\n                                                return\n                                                    0x037f7d6933036F34DFabd40Ff8e4D789069f92e3;\n                                            } else {\n                                                return\n                                                    0xeF978c280915CfF3Dca4EDfa8932469e40ADA1e1;\n                                            }\n                                        } else {\n                                            if (routeId == 39) {\n                                                return\n                                                    0x92ee9e071B13f7ecFD62B7DED404A16CBc223CD3;\n                                            } else {\n                                                return\n                                                    0x94Ae539c186e41ed762271338Edf140414D1E442;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 45) {\n                                        if (routeId < 43) {\n                                            if (routeId == 41) {\n                                                return\n                                                    0x30A64BBe4DdBD43dA2368EFd1eB2d80C10d84DAb;\n                                            } else {\n                                                return\n                                                    0x3aEABf81c1Dc4c1b73d5B2a95410f126426FB596;\n                                            }\n                                        } else {\n                                            if (routeId == 43) {\n                                                return\n                                                    0x25b08aB3D0C8ea4cC9d967b79688C6D98f3f563a;\n                                            } else {\n                                                return\n                                                    0xea40cB15C9A3BBd27af6474483886F7c0c9AE406;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 47) {\n                                            if (routeId == 45) {\n                                                return\n                                                    0x9580113Cc04e5a0a03359686304EF3A80b936Dd3;\n                                            } else {\n                                                return\n                                                    0xD211c826d568957F3b66a3F4d9c5f68cCc66E619;\n                                            }\n                                        } else {\n                                            if (routeId == 47) {\n                                                return\n                                                    0xCEE24D0635c4C56315d133b031984d4A6f509476;\n                                            } else {\n                                                return\n                                                    0x3922e6B987983229798e7A20095EC372744d4D4c;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 57) {\n                                    if (routeId < 53) {\n                                        if (routeId < 51) {\n                                            if (routeId == 49) {\n                                                return\n                                                    0x2d92D03413d296e1F31450479349757187F2a2b7;\n                                            } else {\n                                                return\n                                                    0x0fe5308eE90FC78F45c89dB6053eA859097860CA;\n                                            }\n                                        } else {\n                                            if (routeId == 51) {\n                                                return\n                                                    0x08Ba68e067C0505bAF0C1311E0cFB2B1B59b969c;\n                                            } else {\n                                                return\n                                                    0x9bee5DdDF75C24897374f92A534B7A6f24e97f4a;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 55) {\n                                            if (routeId == 53) {\n                                                return\n                                                    0x1FC5A90B232208704B930c1edf82FFC6ACc02734;\n                                            } else {\n                                                return\n                                                    0x5b1B0417cb44c761C2a23ee435d011F0214b3C85;\n                                            }\n                                        } else {\n                                            if (routeId == 55) {\n                                                return\n                                                    0x9d70cDaCA12A738C283020760f449D7816D592ec;\n                                            } else {\n                                                return\n                                                    0x95a23b9CB830EcCFDDD5dF56A4ec665e3381Fa12;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 61) {\n                                        if (routeId < 59) {\n                                            if (routeId == 57) {\n                                                return\n                                                    0x483a957Cf1251c20e096C35c8399721D1200A3Fc;\n                                            } else {\n                                                return\n                                                    0xb4AD39Cb293b0Ec7FEDa743442769A7FF04987CD;\n                                            }\n                                        } else {\n                                            if (routeId == 59) {\n                                                return\n                                                    0x4C543AD78c1590D81BAe09Fc5B6Df4132A2461d0;\n                                            } else {\n                                                return\n                                                    0x471d5E5195c563902781734cfe1FF3981F8B6c86;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 63) {\n                                            if (routeId == 61) {\n                                                return\n                                                    0x1B12a54B5E606D95B8B8D123c9Cb09221Ee37584;\n                                            } else {\n                                                return\n                                                    0xE4127cC550baC433646a7D998775a84daC16c7f3;\n                                            }\n                                        } else {\n                                            if (routeId == 63) {\n                                                return\n                                                    0xecb1b55AB12E7dd788D585c6C5cD61B5F87be836;\n                                            } else {\n                                                return\n                                                    0xf91ef487C5A1579f70601b6D347e19756092eEBf;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        if (routeId < 97) {\n                            if (routeId < 81) {\n                                if (routeId < 73) {\n                                    if (routeId < 69) {\n                                        if (routeId < 67) {\n                                            if (routeId == 65) {\n                                                return\n                                                    0x34a16a7e9BADEEFD4f056310cbE0b1423Fa1b760;\n                                            } else {\n                                                return\n                                                    0x60E10E80c7680f429dBbC232830BEcd3D623c4CF;\n                                            }\n                                        } else {\n                                            if (routeId == 67) {\n                                                return\n                                                    0x66465285B8D65362A1d86CE00fE2bE949Fd6debF;\n                                            } else {\n                                                return\n                                                    0x5aB231B7e1A3A74a48f67Ab7bde5Cdd4267022E0;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 71) {\n                                            if (routeId == 69) {\n                                                return\n                                                    0x3A1C3633eE79d43366F5c67802a746aFD6b162Ba;\n                                            } else {\n                                                return\n                                                    0x0C4BfCbA8dC3C811437521a80E81e41DAF479039;\n                                            }\n                                        } else {\n                                            if (routeId == 71) {\n                                                return\n                                                    0x6caf25d2e139C5431a1FA526EAf8d73ff2e6252C;\n                                            } else {\n                                                return\n                                                    0x74ad21e09FDa68638CE14A3009A79B6D16574257;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 77) {\n                                        if (routeId < 75) {\n                                            if (routeId == 73) {\n                                                return\n                                                    0xD4923A61008894b99cc1CD3407eF9524f02aA0Ca;\n                                            } else {\n                                                return\n                                                    0x6F159b5EB823BD415886b9271aA2A723a00a1987;\n                                            }\n                                        } else {\n                                            if (routeId == 75) {\n                                                return\n                                                    0x742a8aA42E7bfB4554dE30f4Fb07FFb6f2068863;\n                                            } else {\n                                                return\n                                                    0x4AE9702d3360400E47B446e76DE063ACAb930101;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 79) {\n                                            if (routeId == 77) {\n                                                return\n                                                    0x0E19a0a44ddA7dAD854ec5Cc867d16869c4E80F4;\n                                            } else {\n                                                return\n                                                    0xE021A51968f25148F726E326C88d2556c5647557;\n                                            }\n                                        } else {\n                                            if (routeId == 79) {\n                                                return\n                                                    0x64287BDDDaeF4d94E4599a3D882bed29E6Ada4B6;\n                                            } else {\n                                                return\n                                                    0xcBB57Fd2e19cc7e9D444d5b4325A2F1047d0C73f;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 89) {\n                                    if (routeId < 85) {\n                                        if (routeId < 83) {\n                                            if (routeId == 81) {\n                                                return\n                                                    0x373DE80DF7D82cFF6D76F29581b360C56331e957;\n                                            } else {\n                                                return\n                                                    0x0466356E131AD61596a51F86BAd1C03A328960D8;\n                                            }\n                                        } else {\n                                            if (routeId == 83) {\n                                                return\n                                                    0x01726B960992f1b74311b248E2a922fC707d43A6;\n                                            } else {\n                                                return\n                                                    0x2E21bdf9A4509b89795BCE7E132f248a75814CEc;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 87) {\n                                            if (routeId == 85) {\n                                                return\n                                                    0x769512b23aEfF842379091d3B6E4B5456F631D42;\n                                            } else {\n                                                return\n                                                    0xe7eD9be946a74Ec19325D39C6EEb57887ccB2B0D;\n                                            }\n                                        } else {\n                                            if (routeId == 87) {\n                                                return\n                                                    0xc4D01Ec357c2b511d10c15e6b6974380F0E62e67;\n                                            } else {\n                                                return\n                                                    0x5bC49CC9dD77bECF2fd3A3C55611e84E69AFa3AE;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 93) {\n                                        if (routeId < 91) {\n                                            if (routeId == 89) {\n                                                return\n                                                    0x48bcD879954fA14e7DbdAeb56F79C1e9DDcb69ec;\n                                            } else {\n                                                return\n                                                    0xE929bDde21b462572FcAA4de6F49B9D3246688D0;\n                                            }\n                                        } else {\n                                            if (routeId == 91) {\n                                                return\n                                                    0x85Aae300438222f0e3A9Bc870267a5633A9438bd;\n                                            } else {\n                                                return\n                                                    0x51f72E1096a81C55cd142d66d39B688C657f9Be8;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 95) {\n                                            if (routeId == 93) {\n                                                return\n                                                    0x3A8a05BF68ac54B01E6C0f492abF97465F3d15f9;\n                                            } else {\n                                                return\n                                                    0x145aA67133F0c2C36b9771e92e0B7655f0D59040;\n                                            }\n                                        } else {\n                                            if (routeId == 95) {\n                                                return\n                                                    0xa030315d7DB11F9892758C9e7092D841e0ADC618;\n                                            } else {\n                                                return\n                                                    0xdF1f8d81a3734bdDdEfaC6Ca1596E081e57c3044;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            if (routeId < 113) {\n                                if (routeId < 105) {\n                                    if (routeId < 101) {\n                                        if (routeId < 99) {\n                                            if (routeId == 97) {\n                                                return\n                                                    0xFF2833123B58aa05d04D7fb99f5FB768B2b435F8;\n                                            } else {\n                                                return\n                                                    0xc8f09c1fD751C570233765f71b0e280d74e6e743;\n                                            }\n                                        } else {\n                                            if (routeId == 99) {\n                                                return\n                                                    0x3026DA6Ceca2E5A57A05153653D9212FFAaA49d8;\n                                            } else {\n                                                return\n                                                    0xdE68Ee703dE0D11f67B0cE5891cB4a903de6D160;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 103) {\n                                            if (routeId == 101) {\n                                                return\n                                                    0xE23a7730e81FB4E87A6D0bd9f63EE77ac86C3DA4;\n                                            } else {\n                                                return\n                                                    0x8b1DBe04aD76a7d8bC079cACd3ED4D99B897F4a0;\n                                            }\n                                        } else {\n                                            if (routeId == 103) {\n                                                return\n                                                    0xBB227240FA459b69C6889B2b8cb1BE76F118061f;\n                                            } else {\n                                                return\n                                                    0xC062b9b3f0dB28BB8afAfcD4d075729344114ffe;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 109) {\n                                        if (routeId < 107) {\n                                            if (routeId == 105) {\n                                                return\n                                                    0x553188Aa45f5FDB83EC4Ca485982F8fC082480D1;\n                                            } else {\n                                                return\n                                                    0x0109d83D746EaCb6d4014953D9E12d6ca85e330b;\n                                            }\n                                        } else {\n                                            if (routeId == 107) {\n                                                return\n                                                    0x45B1bEd29812F5bf6711074ACD180B2aeB783AD9;\n                                            } else {\n                                                return\n                                                    0xdA06eC8c19aea31D77F60299678Cba40E743e1aD;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 111) {\n                                            if (routeId == 109) {\n                                                return\n                                                    0x3cC5235c97d975a9b4FD4501B3446c981ea3D855;\n                                            } else {\n                                                return\n                                                    0xa1827267d6Bd989Ff38580aE3d9deff6Acf19163;\n                                            }\n                                        } else {\n                                            if (routeId == 111) {\n                                                return\n                                                    0x3663CAA0433A3D4171b3581Cf2410702840A735A;\n                                            } else {\n                                                return\n                                                    0x7575D0a7614F655BA77C74a72a43bbd4fA6246a3;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 121) {\n                                    if (routeId < 117) {\n                                        if (routeId < 115) {\n                                            if (routeId == 113) {\n                                                return\n                                                    0x2516Defc18bc07089c5dAFf5eafD7B0EF64611E2;\n                                            } else {\n                                                return\n                                                    0xfec5FF08E20fbc107a97Af2D38BD0025b84ee233;\n                                            }\n                                        } else {\n                                            if (routeId == 115) {\n                                                return\n                                                    0x0FB5763a87242B25243e23D73f55945fE787523A;\n                                            } else {\n                                                return\n                                                    0xe4C00db89678dBf8391f430C578Ca857Dd98aDE1;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 119) {\n                                            if (routeId == 117) {\n                                                return\n                                                    0x8F2A22061F9F35E64f14523dC1A5f8159e6a21B7;\n                                            } else {\n                                                return\n                                                    0x18e4b838ae966917E20E9c9c5Ad359cDD38303bB;\n                                            }\n                                        } else {\n                                            if (routeId == 119) {\n                                                return\n                                                    0x61ACb1d3Dcb3e3429832A164Cc0fC9849fb75A4a;\n                                            } else {\n                                                return\n                                                    0x7681e3c8e7A41DCA55C257cc0d1Ae757f5530E65;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 125) {\n                                        if (routeId < 123) {\n                                            if (routeId == 121) {\n                                                return\n                                                    0x806a2AB9748C3D1DB976550890E3f528B7E8Faec;\n                                            } else {\n                                                return\n                                                    0xBDb8A5DD52C2c239fbC31E9d43B763B0197028FF;\n                                            }\n                                        } else {\n                                            if (routeId == 123) {\n                                                return\n                                                    0x474EC9203706010B9978D6bD0b105D36755e4848;\n                                            } else {\n                                                return\n                                                    0x8dfd0D829b303F2239212E591a0F92a32880f36E;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 127) {\n                                            if (routeId == 125) {\n                                                return\n                                                    0xad4BcE9745860B1adD6F1Bd34a916f050E4c82C2;\n                                            } else {\n                                                return\n                                                    0xBC701115b9fe14bC8CC5934cdC92517173e308C4;\n                                            }\n                                        } else {\n                                            if (routeId == 127) {\n                                                return\n                                                    0x0D1918d786Db8546a11aDeD475C98370E06f255E;\n                                            } else {\n                                                return\n                                                    0xee44f57cD6936DB55B99163f3Df367B01EdA785a;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    if (routeId < 193) {\n                        if (routeId < 161) {\n                            if (routeId < 145) {\n                                if (routeId < 137) {\n                                    if (routeId < 133) {\n                                        if (routeId < 131) {\n                                            if (routeId == 129) {\n                                                return\n                                                    0x63044521fe5a1e488D7eD419cD0e35b7C24F2aa7;\n                                            } else {\n                                                return\n                                                    0x410085E73BD85e90d97b84A68C125aDB9F91f85b;\n                                            }\n                                        } else {\n                                            if (routeId == 131) {\n                                                return\n                                                    0x7913fe97E07C7A397Ec274Ab1d4E2622C88EC5D1;\n                                            } else {\n                                                return\n                                                    0x977f9fE93c064DCf54157406DaABC3a722e8184C;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 135) {\n                                            if (routeId == 133) {\n                                                return\n                                                    0xCD2236468722057cFbbABad2db3DEA9c20d5B01B;\n                                            } else {\n                                                return\n                                                    0x17c7287A491cf5Ff81E2678cF2BfAE4333F6108c;\n                                            }\n                                        } else {\n                                            if (routeId == 135) {\n                                                return\n                                                    0x354D9a5Dbf96c71B79a265F03B595C6Fdc04dadd;\n                                            } else {\n                                                return\n                                                    0xb4e409EB8e775eeFEb0344f9eee884cc7ed21c69;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 141) {\n                                        if (routeId < 139) {\n                                            if (routeId == 137) {\n                                                return\n                                                    0xa1a3c4670Ad69D9be4ab2D39D1231FEC2a63b519;\n                                            } else {\n                                                return\n                                                    0x4589A22199870729C1be5CD62EE93BeD858113E6;\n                                            }\n                                        } else {\n                                            if (routeId == 139) {\n                                                return\n                                                    0x8E7b864dB26Bd6C798C38d4Ba36EbA0d6602cF11;\n                                            } else {\n                                                return\n                                                    0xA2D17C7260a4CB7b9854e89Fc367E80E87872a2d;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 143) {\n                                            if (routeId == 141) {\n                                                return\n                                                    0xC7F0EDf0A1288627b0432304918A75e9084CBD46;\n                                            } else {\n                                                return\n                                                    0xE4B4EF1f9A4aBFEdB371fA7a6143993B15d4df25;\n                                            }\n                                        } else {\n                                            if (routeId == 143) {\n                                                return\n                                                    0xfe3D84A2Ef306FEBb5452441C9BDBb6521666F6A;\n                                            } else {\n                                                return\n                                                    0x8A12B6C64121920110aE58F7cd67DfEc21c6a4C3;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 153) {\n                                    if (routeId < 149) {\n                                        if (routeId < 147) {\n                                            if (routeId == 145) {\n                                                return\n                                                    0x76c4d9aFC4717a2BAac4e5f26CccF02351f7a3DA;\n                                            } else {\n                                                return\n                                                    0xd4719BA550E397aeAcca1Ad2201c1ba69024FAAf;\n                                            }\n                                        } else {\n                                            if (routeId == 147) {\n                                                return\n                                                    0x9646126Ce025224d1682C227d915a386efc0A1Fb;\n                                            } else {\n                                                return\n                                                    0x4DD8Af2E3F2044842f0247920Bc4BABb636915ea;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 151) {\n                                            if (routeId == 149) {\n                                                return\n                                                    0x8e8a327183Af0cf8C2ece9F0ed547C42A160D409;\n                                            } else {\n                                                return\n                                                    0x9D49614CaE1C685C71678CA6d8CDF7584bfd0740;\n                                            }\n                                        } else {\n                                            if (routeId == 151) {\n                                                return\n                                                    0x5a00ef257394cbc31828d48655E3d39e9c11c93d;\n                                            } else {\n                                                return\n                                                    0xC9a2751b38d3dDD161A41Ca0135C5C6c09EC1d56;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 157) {\n                                        if (routeId < 155) {\n                                            if (routeId == 153) {\n                                                return\n                                                    0x7e1c261640a525C94Ca4f8c25b48CF754DD83590;\n                                            } else {\n                                                return\n                                                    0x409Fe24ba6F6BD5aF31C1aAf8059b986A3158233;\n                                            }\n                                        } else {\n                                            if (routeId == 155) {\n                                                return\n                                                    0x704Cf5BFDADc0f55fDBb53B6ed8B582E018A72A2;\n                                            } else {\n                                                return\n                                                    0x3982bF65d7d6E77E3b6661cd6F6468c247512737;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 159) {\n                                            if (routeId == 157) {\n                                                return\n                                                    0x3982b9f26FFD67a13Ee371e2C0a9Da338BA70E7f;\n                                            } else {\n                                                return\n                                                    0x6D834AB385900c1f49055D098e90264077FbC4f2;\n                                            }\n                                        } else {\n                                            if (routeId == 159) {\n                                                return\n                                                    0x11FE5F70779A094B7166B391e1Fb73d422eF4e4d;\n                                            } else {\n                                                return\n                                                    0xD347e4E47280d21F13B73D89c6d16f867D50DD13;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            if (routeId < 177) {\n                                if (routeId < 169) {\n                                    if (routeId < 165) {\n                                        if (routeId < 163) {\n                                            if (routeId == 161) {\n                                                return\n                                                    0xb6035eDD53DDA28d8B69b4ae9836E40C80306CD7;\n                                            } else {\n                                                return\n                                                    0x54c884e6f5C7CcfeCA990396c520C858c922b6CA;\n                                            }\n                                        } else {\n                                            if (routeId == 163) {\n                                                return\n                                                    0x5eA93E240b083d686558Ed607BC013d88057cE46;\n                                            } else {\n                                                return\n                                                    0x4C7131eE812De685cBe4e2cCb033d46ecD46612E;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 167) {\n                                            if (routeId == 165) {\n                                                return\n                                                    0xc1a5Be9F0c33D8483801D702111068669f81fF91;\n                                            } else {\n                                                return\n                                                    0x9E5fAb91455Be5E5b2C05967E73F456c8118B1Fc;\n                                            }\n                                        } else {\n                                            if (routeId == 167) {\n                                                return\n                                                    0x3d9A05927223E0DC2F382831770405885e22F0d8;\n                                            } else {\n                                                return\n                                                    0x6303A011fB6063f5B1681cb5a9938EA278dc6128;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 173) {\n                                        if (routeId < 171) {\n                                            if (routeId == 169) {\n                                                return\n                                                    0xe9c60795c90C66797e4c8E97511eA07CdAda32bE;\n                                            } else {\n                                                return\n                                                    0xD56cC98e69A1e13815818b466a8aA6163d84234A;\n                                            }\n                                        } else {\n                                            if (routeId == 171) {\n                                                return\n                                                    0x47EbB9D36a6e40895316cD894E4860D774E2c531;\n                                            } else {\n                                                return\n                                                    0xA5EB293629410065d14a7B1663A67829b0618292;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 175) {\n                                            if (routeId == 173) {\n                                                return\n                                                    0x1b3B4C8146F939cE00899db8B3ddeF0062b7E023;\n                                            } else {\n                                                return\n                                                    0x257Bbc11653625EbfB6A8587eF4f4FBe49828EB3;\n                                            }\n                                        } else {\n                                            if (routeId == 175) {\n                                                return\n                                                    0x44cc979C01b5bB1eAC21301E73C37200dFD06F59;\n                                            } else {\n                                                return\n                                                    0x2972fDF43352225D82754C0174Ff853819D1ef2A;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 185) {\n                                    if (routeId < 181) {\n                                        if (routeId < 179) {\n                                            if (routeId == 177) {\n                                                return\n                                                    0x3e54144f032648A04D62d79f7B4b93FF3aC2333b;\n                                            } else {\n                                                return\n                                                    0x444016102dB8adbE73C3B6703a1ea7F2f75A510D;\n                                            }\n                                        } else {\n                                            if (routeId == 179) {\n                                                return\n                                                    0xac079143f98a6eb744Fde34541ebF243DF5B5dED;\n                                            } else {\n                                                return\n                                                    0xAe9010767Fb112d29d35CEdfba2b372Ad7A308d3;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 183) {\n                                            if (routeId == 181) {\n                                                return\n                                                    0xfE0BCcF9cCC2265D5fB3450743f17DfE57aE1e56;\n                                            } else {\n                                                return\n                                                    0x04ED8C0545716119437a45386B1d691C63234C7D;\n                                            }\n                                        } else {\n                                            if (routeId == 183) {\n                                                return\n                                                    0x636c14013e531A286Bc4C848da34585f0bB73d59;\n                                            } else {\n                                                return\n                                                    0x2Fa67fc7ECC5cAA01C653d3BFeA98ecc5db9C42A;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 189) {\n                                        if (routeId < 187) {\n                                            if (routeId == 185) {\n                                                return\n                                                    0x23e9a0FC180818aA872D2079a985217017E97bd9;\n                                            } else {\n                                                return\n                                                    0x79A95c3Ef81b3ae64ee03A9D5f73e570495F164E;\n                                            }\n                                        } else {\n                                            if (routeId == 187) {\n                                                return\n                                                    0xa7EA0E88F04a84ba0ad1E396cb07Fa3fDAD7dF6D;\n                                            } else {\n                                                return\n                                                    0xd23cA1278a2B01a3C0Ca1a00d104b11c1Ebe6f42;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 191) {\n                                            if (routeId == 189) {\n                                                return\n                                                    0x707bc4a9FA2E349AED5df4e9f5440C15aA9D14Bd;\n                                            } else {\n                                                return\n                                                    0x7E290F2dd539Ac6CE58d8B4C2B944931a1fD3612;\n                                            }\n                                        } else {\n                                            if (routeId == 191) {\n                                                return\n                                                    0x707AA5503088Ce06Ba450B6470A506122eA5c8eF;\n                                            } else {\n                                                return\n                                                    0xFbB3f7BF680deeb149f4E7BC30eA3DDfa68F3C3f;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        if (routeId < 225) {\n                            if (routeId < 209) {\n                                if (routeId < 201) {\n                                    if (routeId < 197) {\n                                        if (routeId < 195) {\n                                            if (routeId == 193) {\n                                                return\n                                                    0xDE74aD8cCC3dbF14992f49Cf24f36855912f4934;\n                                            } else {\n                                                return\n                                                    0x409BA83df7777F070b2B50a10a41DE2468d2a3B3;\n                                            }\n                                        } else {\n                                            if (routeId == 195) {\n                                                return\n                                                    0x5CB7Be90A5DD7CfDa54e87626e254FE8C18255B4;\n                                            } else {\n                                                return\n                                                    0x0A684fE12BC64fb72B59d0771a566F49BC090356;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 199) {\n                                            if (routeId == 197) {\n                                                return\n                                                    0xDf30048d91F8FA2bCfC54952B92bFA8e161D3360;\n                                            } else {\n                                                return\n                                                    0x050825Fff032a547C47061CF0696FDB0f65AEa5D;\n                                            }\n                                        } else {\n                                            if (routeId == 199) {\n                                                return\n                                                    0xd55e671dAC1f03d366d8535073ada5DB2Aab1Ea2;\n                                            } else {\n                                                return\n                                                    0x9470C704A9616c8Cd41c595Fcd2181B6fe2183C2;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 205) {\n                                        if (routeId < 203) {\n                                            if (routeId == 201) {\n                                                return\n                                                    0x2D9ffD275181F5865d5e11CbB4ced1521C4dF9f1;\n                                            } else {\n                                                return\n                                                    0x816d28Dec10ec95DF5334f884dE85cA6215918d8;\n                                            }\n                                        } else {\n                                            if (routeId == 203) {\n                                                return\n                                                    0xd1f87267c4A43835E666dd69Df077e578A3b6299;\n                                            } else {\n                                                return\n                                                    0x39E89Bde9DACbe5468C025dE371FbDa12bDeBAB1;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 207) {\n                                            if (routeId == 205) {\n                                                return\n                                                    0x7b40A3207956ecad6686E61EfcaC48912FcD0658;\n                                            } else {\n                                                return\n                                                    0x090cF10D793B1Efba9c7D76115878814B663859A;\n                                            }\n                                        } else {\n                                            if (routeId == 207) {\n                                                return\n                                                    0x312A59c06E41327878F2063eD0e9c282C1DA3AfC;\n                                            } else {\n                                                return\n                                                    0x4F1188f46236DD6B5de11Ebf2a9fF08716E7DeB6;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 217) {\n                                    if (routeId < 213) {\n                                        if (routeId < 211) {\n                                            if (routeId == 209) {\n                                                return\n                                                    0x0A6F9a3f4fA49909bBfb4339cbE12B42F53BbBeD;\n                                            } else {\n                                                return\n                                                    0x01d13d7aCaCbB955B81935c80ffF31e14BdFa71f;\n                                            }\n                                        } else {\n                                            if (routeId == 211) {\n                                                return\n                                                    0x691a14Fa6C7360422EC56dF5876f84d4eDD7f00A;\n                                            } else {\n                                                return\n                                                    0x97Aad18d886d181a9c726B3B6aE15a0A69F5aF73;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 215) {\n                                            if (routeId == 213) {\n                                                return\n                                                    0x2917241371D2099049Fa29432DC46735baEC33b4;\n                                            } else {\n                                                return\n                                                    0x5F20F20F7890c2e383E29D4147C9695A371165f5;\n                                            }\n                                        } else {\n                                            if (routeId == 215) {\n                                                return\n                                                    0xeC0a60e639958335662C5219A320cCEbb56C6077;\n                                            } else {\n                                                return\n                                                    0x96d63CF5062975C09845d17ec672E10255866053;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 221) {\n                                        if (routeId < 219) {\n                                            if (routeId == 217) {\n                                                return\n                                                    0xFF57429e57D383939CAB50f09ABBfB63C0e6c9AD;\n                                            } else {\n                                                return\n                                                    0x18E393A7c8578fb1e235C242076E50013cDdD0d7;\n                                            }\n                                        } else {\n                                            if (routeId == 219) {\n                                                return\n                                                    0xE7E5238AF5d61f52E9B4ACC025F713d1C0216507;\n                                            } else {\n                                                return\n                                                    0x428401D4d0F25A2EE1DA4d5366cB96Ded425D9bD;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 223) {\n                                            if (routeId == 221) {\n                                                return\n                                                    0x42E5733551ff1Ee5B48Aa9fc2B61Af9b58C812E6;\n                                            } else {\n                                                return\n                                                    0x64Df9c7A0551B056d860Bc2419Ca4c1EF75320bE;\n                                            }\n                                        } else {\n                                            if (routeId == 223) {\n                                                return\n                                                    0x46006925506145611bBf0263243D8627dAf26B0F;\n                                            } else {\n                                                return\n                                                    0x8D64BE884314662804eAaB884531f5C50F4d500c;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            if (routeId < 241) {\n                                if (routeId < 233) {\n                                    if (routeId < 229) {\n                                        if (routeId < 227) {\n                                            if (routeId == 225) {\n                                                return\n                                                    0x157a62D92D07B5ce221A5429645a03bBaCE85373;\n                                            } else {\n                                                return\n                                                    0xaF037D33e1F1F2F87309B425fe8a9d895Ef3722B;\n                                            }\n                                        } else {\n                                            if (routeId == 227) {\n                                                return\n                                                    0x921D1154E494A2f7218a37ad7B17701f94b4B40e;\n                                            } else {\n                                                return\n                                                    0xF282b4555186d8Dea51B8b3F947E1E0568d09bc4;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 231) {\n                                            if (routeId == 229) {\n                                                return\n                                                    0xa794E2E1869765a4600b3DFd8a4ebcF16350f6B6;\n                                            } else {\n                                                return\n                                                    0xFEFb048e20c5652F7940A49B1980E0125Ec4D358;\n                                            }\n                                        } else {\n                                            if (routeId == 231) {\n                                                return\n                                                    0x220104b641971e9b25612a8F001bf48AbB23f1cF;\n                                            } else {\n                                                return\n                                                    0xcB9D373Bb54A501B35dd3be5bF4Ba43cA31F7035;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 237) {\n                                        if (routeId < 235) {\n                                            if (routeId == 233) {\n                                                return\n                                                    0x37D627F56e3FF36aC316372109ea82E03ac97DAc;\n                                            } else {\n                                                return\n                                                    0x4E81355FfB4A271B4EA59ff78da2b61c7833161f;\n                                            }\n                                        } else {\n                                            if (routeId == 235) {\n                                                return\n                                                    0xADd8D65cAF6Cc9ad73127B49E16eA7ac29d91e87;\n                                            } else {\n                                                return\n                                                    0x630F9b95626487dfEAe3C97A44DB6C59cF35d996;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 239) {\n                                            if (routeId == 237) {\n                                                return\n                                                    0x78CE2BC8238B679680A67FCB98C5A60E4ec17b2D;\n                                            } else {\n                                                return\n                                                    0xA38D776028eD1310b9A6b086f67F788201762E21;\n                                            }\n                                        } else {\n                                            if (routeId == 239) {\n                                                return\n                                                    0x7Bb5178827B76B86753Ed62a0d662c72cEcb1bD3;\n                                            } else {\n                                                return\n                                                    0x4faC26f61C76eC5c3D43b43eDfAFF0736Ae0e3da;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 249) {\n                                    if (routeId < 245) {\n                                        if (routeId < 243) {\n                                            if (routeId == 241) {\n                                                return\n                                                    0x791Bb49bfFA7129D6889FDB27744422Ac4571A85;\n                                            } else {\n                                                return\n                                                    0x26766fFEbb5fa564777913A6f101dF019AB32afa;\n                                            }\n                                        } else {\n                                            if (routeId == 243) {\n                                                return\n                                                    0x05e98E5e95b4ECBbbAf3258c3999Cc81ed8048Be;\n                                            } else {\n                                                return\n                                                    0xC5c4621e52f1D6A1825A5ed4F95855401a3D9C6b;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 247) {\n                                            if (routeId == 245) {\n                                                return\n                                                    0xfcb15f909BA7FC7Ea083503Fb4c1020203c107EB;\n                                            } else {\n                                                return\n                                                    0xbD27603279d969c74f2486ad14E71080829DFd38;\n                                            }\n                                        } else {\n                                            if (routeId == 247) {\n                                                return\n                                                    0xff2f756BcEcC1A55BFc09a30cc5F64720458cFCB;\n                                            } else {\n                                                return\n                                                    0x3bfB968FEbC12F4e8420B2d016EfcE1E615f7246;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 253) {\n                                        if (routeId < 251) {\n                                            if (routeId == 249) {\n                                                return\n                                                    0x982EE9Ffe23051A2ec945ed676D864fa8345222b;\n                                            } else {\n                                                return\n                                                    0xe101899100785E74767d454FFF0131277BaD48d9;\n                                            }\n                                        } else {\n                                            if (routeId == 251) {\n                                                return\n                                                    0x4F730C0c6b3B5B7d06ca511379f4Aa5BfB2E9525;\n                                            } else {\n                                                return\n                                                    0x5499c36b365795e4e0Ef671aF6C2ce26D7c78265;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 255) {\n                                            if (routeId == 253) {\n                                                return\n                                                    0x8AF51F7237Fc8fB2fc3E700488a94a0aC6Ad8b5a;\n                                            } else {\n                                                return\n                                                    0xda8716df61213c0b143F2849785FB85928084857;\n                                            }\n                                        } else {\n                                            if (routeId == 255) {\n                                                return\n                                                    0xF040Cf9b1ebD11Bf28e04e80740DF3DDe717e4f5;\n                                            } else {\n                                                return\n                                                    0xB87ba32f759D14023C7520366B844dF7f0F036C2;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } else {\n                if (routeId < 321) {\n                    if (routeId < 289) {\n                        if (routeId < 273) {\n                            if (routeId < 265) {\n                                if (routeId < 261) {\n                                    if (routeId < 259) {\n                                        if (routeId == 257) {\n                                            return\n                                                0x0Edde681b8478F0c3194f468EdD2dB5e75c65CDD;\n                                        } else {\n                                            return\n                                                0x59C70900Fca06eE2aCE1BDd5A8D0Af0cc3BBA720;\n                                        }\n                                    } else {\n                                        if (routeId == 259) {\n                                            return\n                                                0x8041F0f180D17dD07087199632c45E17AeB0BAd5;\n                                        } else {\n                                            return\n                                                0x4fB4727064BA595995DD516b63b5921Df9B93aC6;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 263) {\n                                        if (routeId == 261) {\n                                            return\n                                                0x86e98b594565857eD098864F560915C0dAfd6Ea1;\n                                        } else {\n                                            return\n                                                0x70f8818E8B698EFfeCd86A513a4c87c0c380Bef6;\n                                        }\n                                    } else {\n                                        if (routeId == 263) {\n                                            return\n                                                0x78Ed227c8A897A21Da2875a752142dd80d865158;\n                                        } else {\n                                            return\n                                                0xd02A30BB5C3a8C51d2751A029a6fcfDE2Af9fbc6;\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 269) {\n                                    if (routeId < 267) {\n                                        if (routeId == 265) {\n                                            return\n                                                0x0F00d5c5acb24e975e2a56730609f7F40aa763b8;\n                                        } else {\n                                            return\n                                                0xC3e2091edc2D3D9D98ba09269138b617B536834A;\n                                        }\n                                    } else {\n                                        if (routeId == 267) {\n                                            return\n                                                0xa6FbaF7F30867C9633908998ea8C3da28920E75C;\n                                        } else {\n                                            return\n                                                0xE6dDdcD41E2bBe8122AE32Ac29B8fbAB79CD21d9;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 271) {\n                                        if (routeId == 269) {\n                                            return\n                                                0x537aa8c1Ef6a8Eaf039dd6e1Eb67694a48195cE4;\n                                        } else {\n                                            return\n                                                0x96ABAC485fd2D0B03CF4a10df8BD58b8dED28300;\n                                        }\n                                    } else {\n                                        if (routeId == 271) {\n                                            return\n                                                0xda8e7D46d04Bd4F62705Cd80355BDB6d441DafFD;\n                                        } else {\n                                            return\n                                                0xbE50018E7a5c67E2e5f5414393e971CC96F293f2;\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            if (routeId < 281) {\n                                if (routeId < 277) {\n                                    if (routeId < 275) {\n                                        if (routeId == 273) {\n                                            return\n                                                0xa1b3907D6CB542a4cbe2eE441EfFAA909FAb62C3;\n                                        } else {\n                                            return\n                                                0x6d08ee8511C0237a515013aC389e7B3968Cb1753;\n                                        }\n                                    } else {\n                                        if (routeId == 275) {\n                                            return\n                                                0x22faa5B5Fe43eAdbB52745e35a5cdA8bD5F96bbA;\n                                        } else {\n                                            return\n                                                0x7a673eB74D79e4868D689E7852abB5f93Ec2fD4b;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 279) {\n                                        if (routeId == 277) {\n                                            return\n                                                0x0b8531F8AFD4190b76F3e10deCaDb84c98b4d419;\n                                        } else {\n                                            return\n                                                0x78eABC743A93583DeE403D6b84795490e652216B;\n                                        }\n                                    } else {\n                                        if (routeId == 279) {\n                                            return\n                                                0x3A95D907b2a7a8604B59BccA08585F58Afe0Aa64;\n                                        } else {\n                                            return\n                                                0xf4271f0C8c9Af0F06A80b8832fa820ccE64FAda8;\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 285) {\n                                    if (routeId < 283) {\n                                        if (routeId == 281) {\n                                            return\n                                                0x74b2DF841245C3748c0d31542e1335659a25C33b;\n                                        } else {\n                                            return\n                                                0xdFC99Fd0Ad7D16f30f295a5EEFcE029E04d0fa65;\n                                        }\n                                    } else {\n                                        if (routeId == 283) {\n                                            return\n                                                0xE992416b6aC1144eD8148a9632973257839027F6;\n                                        } else {\n                                            return\n                                                0x54ce55ba954E981BB1fd9399054B35Ce1f2C0816;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 287) {\n                                        if (routeId == 285) {\n                                            return\n                                                0xD4AB52f9e7E5B315Bd7471920baD04F405Ab1c38;\n                                        } else {\n                                            return\n                                                0x3670C990994d12837e95eE127fE2f06FD3E2104B;\n                                        }\n                                    } else {\n                                        if (routeId == 287) {\n                                            return\n                                                0xDcf190B09C47E4f551E30BBb79969c3FdEA1e992;\n                                        } else {\n                                            return\n                                                0xa65057B967B59677237e57Ab815B209744b9bc40;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        if (routeId < 305) {\n                            if (routeId < 297) {\n                                if (routeId < 293) {\n                                    if (routeId < 291) {\n                                        if (routeId == 289) {\n                                            return\n                                                0x6Efc86B40573e4C7F28659B13327D55ae955C483;\n                                        } else {\n                                            return\n                                                0x06BcC25CF8e0E72316F53631b3aA7134E9f73Ae0;\n                                        }\n                                    } else {\n                                        if (routeId == 291) {\n                                            return\n                                                0x710b6414E1D53882b1FCD3A168aD5Ccd435fc6D0;\n                                        } else {\n                                            return\n                                                0x5Ebb2C3d78c4e9818074559e7BaE7FCc99781DC1;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 295) {\n                                        if (routeId == 293) {\n                                            return\n                                                0xAf0a409c3AEe0bD08015cfb29D89E90b6e89A88F;\n                                        } else {\n                                            return\n                                                0x522559d8b99773C693B80cE06DF559036295Ce44;\n                                        }\n                                    } else {\n                                        if (routeId == 295) {\n                                            return\n                                                0xB65290A5Bae838aaa7825c9ECEC68041841a1B64;\n                                        } else {\n                                            return\n                                                0x801b8F2068edd5Bcb659E6BDa0c425909043C420;\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 301) {\n                                    if (routeId < 299) {\n                                        if (routeId == 297) {\n                                            return\n                                                0x29b5F00515d093627E0B7bd0b5c8E84F6b4cDb87;\n                                        } else {\n                                            return\n                                                0x652839Ae74683cbF9f1293F1019D938F87464D3E;\n                                        }\n                                    } else {\n                                        if (routeId == 299) {\n                                            return\n                                                0x5Bc95dCebDDE9B79F2b6DC76121BC7936eF8D666;\n                                        } else {\n                                            return\n                                                0x90db359CEA62E53051158Ab5F99811C0a07Fe686;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 303) {\n                                        if (routeId == 301) {\n                                            return\n                                                0x2c3625EedadbDcDbB5330eb0d17b3C39ff269807;\n                                        } else {\n                                            return\n                                                0xC3f0324471b5c9d415acD625b8d8694a4e48e001;\n                                        }\n                                    } else {\n                                        if (routeId == 303) {\n                                            return\n                                                0x8C60e7E05fa0FfB6F720233736f245134685799d;\n                                        } else {\n                                            return\n                                                0x98fAF2c09aa4EBb995ad0B56152993E7291a500e;\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            if (routeId < 313) {\n                                if (routeId < 309) {\n                                    if (routeId < 307) {\n                                        if (routeId == 305) {\n                                            return\n                                                0x802c1063a861414dFAEc16bacb81429FC0d40D6e;\n                                        } else {\n                                            return\n                                                0x11C4AeFCC0dC156f64195f6513CB1Fb3Be0Ae056;\n                                        }\n                                    } else {\n                                        if (routeId == 307) {\n                                            return\n                                                0xEff1F3258214E31B6B4F640b4389d55715C3Be2B;\n                                        } else {\n                                            return\n                                                0x47e379Abe8DDFEA4289aBa01235EFF7E93758fd7;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 311) {\n                                        if (routeId == 309) {\n                                            return\n                                                0x3CC26384c3eA31dDc8D9789e8872CeA6F20cD3ff;\n                                        } else {\n                                            return\n                                                0xEdd9EFa6c69108FAA4611097d643E20Ba0Ed1634;\n                                        }\n                                    } else {\n                                        if (routeId == 311) {\n                                            return\n                                                0xCb93525CA5f3D371F74F3D112bC19526740717B8;\n                                        } else {\n                                            return\n                                                0x7071E0124EB4438137e60dF1b8DD8Af1BfB362cF;\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 317) {\n                                    if (routeId < 315) {\n                                        if (routeId == 313) {\n                                            return\n                                                0x4691096EB0b78C8F4b4A8091E5B66b18e1835c10;\n                                        } else {\n                                            return\n                                                0x8d953c9b2d1C2137CF95992079f3A77fCd793272;\n                                        }\n                                    } else {\n                                        if (routeId == 315) {\n                                            return\n                                                0xbdCc2A3Bf6e3Ba49ff86595e6b2b8D70d8368c92;\n                                        } else {\n                                            return\n                                                0x95E6948aB38c61b2D294E8Bd896BCc4cCC0713cf;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 319) {\n                                        if (routeId == 317) {\n                                            return\n                                                0x607b27C881fFEE4Cb95B1c5862FaE7224ccd0b4A;\n                                        } else {\n                                            return\n                                                0x09D28aFA166e566A2Ee1cB834ea8e78C7E627eD2;\n                                        }\n                                    } else {\n                                        if (routeId == 319) {\n                                            return\n                                                0x9c01449b38bDF0B263818401044Fb1401B29fDfA;\n                                        } else {\n                                            return\n                                                0x1F7723599bbB658c051F8A39bE2688388d22ceD6;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    if (routeId < 353) {\n                        if (routeId < 337) {\n                            if (routeId < 329) {\n                                if (routeId < 325) {\n                                    if (routeId < 323) {\n                                        if (routeId == 321) {\n                                            return\n                                                0x52B71603f7b8A5d15B4482e965a0619aa3210194;\n                                        } else {\n                                            return\n                                                0x01c0f072CB210406653752FecFA70B42dA9173a2;\n                                        }\n                                    } else {\n                                        if (routeId == 323) {\n                                            return\n                                                0x3021142f021E943e57fc1886cAF58D06147D09A6;\n                                        } else {\n                                            return\n                                                0xe6f2AF38e76AB09Db59225d97d3E770942D3D842;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 327) {\n                                        if (routeId == 325) {\n                                            return\n                                                0x06a25554e5135F08b9e2eD1DEC1fc3CEd52e0B48;\n                                        } else {\n                                            return\n                                                0x71d75e670EE3511C8290C705E0620126B710BF8D;\n                                        }\n                                    } else {\n                                        if (routeId == 327) {\n                                            return\n                                                0x8b9cE142b80FeA7c932952EC533694b1DF9B3c54;\n                                        } else {\n                                            return\n                                                0xd7Be24f32f39231116B3fDc483C2A12E1521f73B;\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 333) {\n                                    if (routeId < 331) {\n                                        if (routeId == 329) {\n                                            return\n                                                0xb40cafBC4797d4Ff64087E087F6D2e661f954CbE;\n                                        } else {\n                                            return\n                                                0xBdDCe7771EfEe81893e838f62204A4c76D72757e;\n                                        }\n                                    } else {\n                                        if (routeId == 331) {\n                                            return\n                                                0x5d3D299EA7Fd4F39AcDb336E26631Dfee41F9287;\n                                        } else {\n                                            return\n                                                0x6BfEE09E1Fc0684e0826A9A0dC1352a14B136FAC;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 335) {\n                                        if (routeId == 333) {\n                                            return\n                                                0xd0001bB8E2Cb661436093f96458a4358B5156E3c;\n                                        } else {\n                                            return\n                                                0x1867c6485CfD1eD448988368A22bfB17a7747293;\n                                        }\n                                    } else {\n                                        if (routeId == 335) {\n                                            return\n                                                0x8997EF9F95dF24aB67703AB6C262aABfeEBE33bD;\n                                        } else {\n                                            return\n                                                0x1e39E9E601922deD91BCFc8F78836302133465e2;\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            if (routeId < 345) {\n                                if (routeId < 341) {\n                                    if (routeId < 339) {\n                                        if (routeId == 337) {\n                                            return\n                                                0x8A8ec6CeacFf502a782216774E5AF3421562C6ff;\n                                        } else {\n                                            return\n                                                0x3B8FC561df5415c8DC01e97Ee6E38435A8F9C40A;\n                                        }\n                                    } else {\n                                        if (routeId == 339) {\n                                            return\n                                                0xD5d5f5B37E67c43ceA663aEDADFFc3a93a2065B0;\n                                        } else {\n                                            return\n                                                0xCC8F55EC43B4f25013CE1946FBB740c43Be5B96D;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 343) {\n                                        if (routeId == 341) {\n                                            return\n                                                0x18f586E816eEeDbb57B8011239150367561B58Fb;\n                                        } else {\n                                            return\n                                                0xd0CD802B19c1a52501cb2f07d656e3Cd7B0Ce124;\n                                        }\n                                    } else {\n                                        if (routeId == 343) {\n                                            return\n                                                0xe0AeD899b39C6e4f2d83e4913a1e9e0cf6368abE;\n                                        } else {\n                                            return\n                                                0x0606e1b6c0f1A398C38825DCcc4678a7Cbc2737c;\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 349) {\n                                    if (routeId < 347) {\n                                        if (routeId == 345) {\n                                            return\n                                                0x2d188e85b27d18EF80f16686EA1593ABF7Ed2A63;\n                                        } else {\n                                            return\n                                                0x64412292fA4A135a3300E24366E99ff59Db2eAc1;\n                                        }\n                                    } else {\n                                        if (routeId == 347) {\n                                            return\n                                                0x38b74c173f3733E8b90aAEf0e98B89791266149F;\n                                        } else {\n                                            return\n                                                0x36DAA49A79aaEF4E7a217A11530D3cCD84414124;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 351) {\n                                        if (routeId == 349) {\n                                            return\n                                                0x10f088FE2C88F90270E4449c46c8B1b232511d58;\n                                        } else {\n                                            return\n                                                0x4FeDbd25B58586838ABD17D10272697dF1dC3087;\n                                        }\n                                    } else {\n                                        if (routeId == 351) {\n                                            return\n                                                0x685278209248CB058E5cEe93e37f274A80Faf6eb;\n                                        } else {\n                                            return\n                                                0xDd9F8F1eeC3955f78168e2Fb2d1e808fa8A8f15b;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        if (routeId < 369) {\n                            if (routeId < 361) {\n                                if (routeId < 357) {\n                                    if (routeId < 355) {\n                                        if (routeId == 353) {\n                                            return\n                                                0x7392aEeFD5825aaC28817031dEEBbFaAA20983D9;\n                                        } else {\n                                            return\n                                                0x0Cc182555E00767D6FB8AD161A10d0C04C476d91;\n                                        }\n                                    } else {\n                                        if (routeId == 355) {\n                                            return\n                                                0x90E52837d56715c79FD592E8D58bFD20365798b2;\n                                        } else {\n                                            return\n                                                0x6F4451DE14049B6770ad5BF4013118529e68A40C;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 359) {\n                                        if (routeId == 357) {\n                                            return\n                                                0x89B97ef2aFAb9ed9c7f0FDb095d02E6840b52d9c;\n                                        } else {\n                                            return\n                                                0x92A5cC5C42d94d3e23aeB1214fFf43Db2B97759E;\n                                        }\n                                    } else {\n                                        if (routeId == 359) {\n                                            return\n                                                0x63ddc52F135A1dcBA831EAaC11C63849F018b739;\n                                        } else {\n                                            return\n                                                0x692A691533B571C2c54C1D7F8043A204b3d8120E;\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 365) {\n                                    if (routeId < 363) {\n                                        if (routeId == 361) {\n                                            return\n                                                0x97c7492CF083969F61C6f302d45c8270391b921c;\n                                        } else {\n                                            return\n                                                0xDeFD2B8643553dAd19548eB14fd94A57F4B9e543;\n                                        }\n                                    } else {\n                                        if (routeId == 363) {\n                                            return\n                                                0x30645C04205cA3f670B67b02F971B088930ACB8C;\n                                        } else {\n                                            return\n                                                0xA6f80ed2d607Cd67aEB4109B64A0BEcc4D7d03CF;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 367) {\n                                        if (routeId == 365) {\n                                            return\n                                                0xBbbbC6c276eB3F7E674f2D39301509236001c42f;\n                                        } else {\n                                            return\n                                                0xC20E77d349FB40CE88eB01824e2873ad9f681f3C;\n                                        }\n                                    } else {\n                                        if (routeId == 367) {\n                                            return\n                                                0x5fCfD9a962De19294467C358C1FA55082285960b;\n                                        } else {\n                                            return\n                                                0x4D87BD6a0E4E5cc6332923cb3E85fC71b287F58A;\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            if (routeId < 377) {\n                                if (routeId < 373) {\n                                    if (routeId < 371) {\n                                        if (routeId == 369) {\n                                            return\n                                                0x3AA5B757cd6Dde98214E56D57Dde7fcF0F7aB04E;\n                                        } else {\n                                            return\n                                                0xe28eFCE7192e11a2297f44059113C1fD6967b2d4;\n                                        }\n                                    } else {\n                                        if (routeId == 371) {\n                                            return\n                                                0x3251cAE10a1Cf246e0808D76ACC26F7B5edA0eE5;\n                                        } else {\n                                            return\n                                                0xbA2091cc9357Cf4c4F25D64F30d1b4Ba3A5a174B;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 375) {\n                                        if (routeId == 373) {\n                                            return\n                                                0x49c8e1Da9693692096F63C82D11b52d738566d55;\n                                        } else {\n                                            return\n                                                0xA0731615aB5FFF451031E9551367A4F7dB27b39c;\n                                        }\n                                    } else {\n                                        if (routeId == 375) {\n                                            return\n                                                0xFb214541888671AE1403CecC1D59763a12fc1609;\n                                        } else {\n                                            return\n                                                0x1D6bCB17642E2336405df73dF22F07688cAec020;\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 381) {\n                                    if (routeId < 379) {\n                                        if (routeId == 377) {\n                                            return\n                                                0xfC9c0C7bfe187120fF7f4E21446161794A617a9e;\n                                        } else {\n                                            return\n                                                0xBa5bF37678EeE2dAB17AEf9D898153258252250E;\n                                        }\n                                    } else {\n                                        if (routeId == 379) {\n                                            return\n                                                0x7c55690bd2C9961576A32c02f8EB29ed36415Ec7;\n                                        } else {\n                                            return\n                                                0xcA40073E868E8Bc611aEc8Fe741D17E68Fe422f6;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 383) {\n                                        if (routeId == 381) {\n                                            return\n                                                0x31641bAFb87E9A58f78835050a7BE56921986339;\n                                        } else {\n                                            return\n                                                0xA54766424f6dA74b45EbCc5Bf0Bd1D74D2CCcaAB;\n                                        }\n                                    } else {\n                                        if (routeId == 383) {\n                                            return\n                                                0xc7bBa57F8C179EDDBaa62117ddA360e28f3F8252;\n                                        } else {\n                                            return\n                                                0x5e663ED97ea77d393B8858C90d0683bF180E0ffd;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (routes[routeId] == address(0)) revert ZeroAddressNotAllowed();\n        return routes[routeId];\n    }\n\n    /// @notice fallback function to handle swap, bridge execution\n    /// @dev ensure routeId is converted to bytes4 and sent as msg.sig in the transaction\n    fallback() external payable {\n        address routeAddress = addressAt(uint32(msg.sig));\n\n        bytes memory result;\n\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 4, sub(calldatasize(), 4))\n            // execute function call using the facet\n            result := delegatecall(\n                gas(),\n                routeAddress,\n                0,\n                sub(calldatasize(), 4),\n                0,\n                0\n            )\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"},"src/bridges/hop/interfaces/IHopL1Bridge.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title L1Bridge Hop Interface\n * @notice L1 Hop Bridge, Used to transfer from L1 to L2s.\n */\ninterface IHopL1Bridge {\n    /**\n     * @notice `amountOutMin` and `deadline` should be 0 when no swap is intended at the destination.\n     * @notice `amount` is the total amount the user wants to send including the relayer fee\n     * @dev Send tokens to a supported layer-2 to mint hToken and optionally swap the hToken in the\n     * AMM at the destination.\n     * @param chainId The chainId of the destination chain\n     * @param recipient The address receiving funds at the destination\n     * @param amount The amount being sent\n     * @param amountOutMin The minimum amount received after attempting to swap in the destination\n     * AMM market. 0 if no swap is intended.\n     * @param deadline The deadline for swapping in the destination AMM market. 0 if no\n     * swap is intended.\n     * @param relayer The address of the relayer at the destination.\n     * @param relayerFee The amount distributed to the relayer at the destination. This is subtracted from the `amount`.\n     */\n    function sendToL2(\n        uint256 chainId,\n        address recipient,\n        uint256 amount,\n        uint256 amountOutMin,\n        uint256 deadline,\n        address relayer,\n        uint256 relayerFee\n    ) external payable;\n}\n"},"src/bridges/refuel/interfaces/refuel.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.0;\n\n/// @notice interface with functions to interact with Refuel contract\ninterface IRefuel {\n    /**\n     * @notice function to deposit nativeToken to Destination-address on destinationChain\n     * @param destinationChainId chainId of the Destination chain\n     * @param _to recipient address\n     */\n    function depositNativeToken(\n        uint256 destinationChainId,\n        address _to\n    ) external payable;\n}\n"},"src/bridges/stargate/interfaces/stargate.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\n/**\n * @title IBridgeStargate Interface Contract.\n * @notice Interface used by Stargate-L1 and L2 Router implementations\n * @dev router and routerETH addresses will be distinct for L1 and L2\n */\ninterface IBridgeStargate {\n    // @notice Struct to hold the additional-data for bridging ERC20 token\n    struct lzTxObj {\n        // gas limit to bridge the token in Stargate to destinationChain\n        uint256 dstGasForCall;\n        // destination nativeAmount, this is always set as 0\n        uint256 dstNativeAmount;\n        // destination nativeAddress, this is always set as 0x\n        bytes dstNativeAddr;\n    }\n\n    /// @notice function in stargate bridge which is used to bridge ERC20 tokens to recipient on destinationChain\n    function swap(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        address payable _refundAddress,\n        uint256 _amountLD,\n        uint256 _minAmountLD,\n        lzTxObj memory _lzTxParams,\n        bytes calldata _to,\n        bytes calldata _payload\n    ) external payable;\n\n    /// @notice function in stargate bridge which is used to bridge native tokens to recipient on destinationChain\n    function swapETH(\n        uint16 _dstChainId, // destination Stargate chainId\n        address payable _refundAddress, // refund additional messageFee to this address\n        bytes calldata _toAddress, // the receiver of the destination ETH\n        uint256 _amountLD, // the amount, in Local Decimals, to be swapped\n        uint256 _minAmountLD // the minimum amount accepted out on destination\n    ) external payable;\n}\n"},"src/controllers/FeesTakerController.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {BaseController} from \"./BaseController.sol\";\nimport {ISocketRequest} from \"../interfaces/ISocketRequest.sol\";\n\n/**\n * @title FeesTaker-Controller Implementation\n * @notice Controller with composed actions to deduct-fees followed by Refuel, Swap and Bridge\n *          to be executed Sequentially and this is atomic\n * @author Socket dot tech.\n */\ncontract FeesTakerController is BaseController {\n    using SafeTransferLib for ERC20;\n\n    /// @notice event emitted upon fee-deduction to fees-taker address\n    event SocketFeesDeducted(\n        uint256 fees,\n        address feesToken,\n        address feesTaker\n    );\n\n    /// @notice Function-selector to invoke deduct-fees and swap token\n    /// @dev This function selector is to be used while building transaction-data\n    bytes4 public immutable FEES_TAKER_SWAP_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\"takeFeesAndSwap((address,address,uint256,uint32,bytes))\")\n        );\n\n    /// @notice Function-selector to invoke deduct-fees and bridge token\n    /// @dev This function selector is to be used while building transaction-data\n    bytes4 public immutable FEES_TAKER_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"takeFeesAndBridge((address,address,uint256,uint32,bytes))\"\n            )\n        );\n\n    /// @notice Function-selector to invoke deduct-fees and bridge multiple tokens\n    /// @dev This function selector is to be used while building transaction-data\n    bytes4 public immutable FEES_TAKER_MULTI_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"takeFeesAndMultiBridge((address,address,uint256,uint32[],bytes[]))\"\n            )\n        );\n\n    /// @notice Function-selector to invoke deduct-fees followed by swapping of a token and bridging the swapped bridge\n    /// @dev This function selector is to be used while building transaction-data\n    bytes4 public immutable FEES_TAKER_SWAP_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"takeFeeAndSwapAndBridge((address,address,uint256,uint32,bytes,uint32,bytes))\"\n            )\n        );\n\n    /// @notice Function-selector to invoke deduct-fees refuel\n    /// @notice followed by swapping of a token and bridging the swapped bridge\n    /// @dev This function selector is to be used while building transaction-data\n    bytes4 public immutable FEES_TAKER_REFUEL_SWAP_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"takeFeeAndRefuelAndSwapAndBridge((address,address,uint256,uint32,bytes,uint32,bytes,uint32,bytes))\"\n            )\n        );\n\n    /// @notice socketGatewayAddress to be initialised via storage variable BaseController\n    constructor(\n        address _socketGatewayAddress\n    ) BaseController(_socketGatewayAddress) {}\n\n    /**\n     * @notice function to deduct-fees to fees-taker address on source-chain and swap token\n     * @dev ensure correct function selector is used to generate transaction-data for bridgeRequest\n     * @param ftsRequest feesTakerSwapRequest object generated either off-chain or the calling contract using\n     *                   the function-selector FEES_TAKER_SWAP_FUNCTION_SELECTOR\n     * @return output bytes from the swap operation (last operation in the composed actions)\n     */\n    function takeFeesAndSwap(\n        ISocketRequest.FeesTakerSwapRequest calldata ftsRequest\n    ) external payable returns (bytes memory) {\n        if (ftsRequest.feesToken == NATIVE_TOKEN_ADDRESS) {\n            //transfer the native amount to the feeTakerAddress\n            payable(ftsRequest.feesTakerAddress).transfer(\n                ftsRequest.feesAmount\n            );\n        } else {\n            //transfer feesAmount to feesTakerAddress\n            ERC20(ftsRequest.feesToken).safeTransferFrom(\n                msg.sender,\n                ftsRequest.feesTakerAddress,\n                ftsRequest.feesAmount\n            );\n        }\n\n        emit SocketFeesDeducted(\n            ftsRequest.feesAmount,\n            ftsRequest.feesTakerAddress,\n            ftsRequest.feesToken\n        );\n\n        //call bridge function (executeRoute for the swapRequestData)\n        return _executeRoute(ftsRequest.routeId, ftsRequest.swapRequestData);\n    }\n\n    /**\n     * @notice function to deduct-fees to fees-taker address on source-chain and bridge amount to destinationChain\n     * @dev ensure correct function selector is used to generate transaction-data for bridgeRequest\n     * @param ftbRequest feesTakerBridgeRequest object generated either off-chain or the calling contract using\n     *                   the function-selector FEES_TAKER_BRIDGE_FUNCTION_SELECTOR\n     * @return output bytes from the bridge operation (last operation in the composed actions)\n     */\n    function takeFeesAndBridge(\n        ISocketRequest.FeesTakerBridgeRequest calldata ftbRequest\n    ) external payable returns (bytes memory) {\n        if (ftbRequest.feesToken == NATIVE_TOKEN_ADDRESS) {\n            //transfer the native amount to the feeTakerAddress\n            payable(ftbRequest.feesTakerAddress).transfer(\n                ftbRequest.feesAmount\n            );\n        } else {\n            //transfer feesAmount to feesTakerAddress\n            ERC20(ftbRequest.feesToken).safeTransferFrom(\n                msg.sender,\n                ftbRequest.feesTakerAddress,\n                ftbRequest.feesAmount\n            );\n        }\n\n        emit SocketFeesDeducted(\n            ftbRequest.feesAmount,\n            ftbRequest.feesTakerAddress,\n            ftbRequest.feesToken\n        );\n\n        //call bridge function (executeRoute for the bridgeData)\n        return _executeRoute(ftbRequest.routeId, ftbRequest.bridgeRequestData);\n    }\n\n    /**\n     * @notice function to deduct-fees to fees-taker address on source-chain and bridge amount to destinationChain\n     * @notice multiple bridge-requests are to be generated and sequence and number of routeIds should match with the bridgeData array\n     * @dev ensure correct function selector is used to generate transaction-data for bridgeRequest\n     * @param ftmbRequest feesTakerMultiBridgeRequest object generated either off-chain or the calling contract using\n     *                   the function-selector FEES_TAKER_MULTI_BRIDGE_FUNCTION_SELECTOR\n     */\n    function takeFeesAndMultiBridge(\n        ISocketRequest.FeesTakerMultiBridgeRequest calldata ftmbRequest\n    ) external payable {\n        if (ftmbRequest.feesToken == NATIVE_TOKEN_ADDRESS) {\n            //transfer the native amount to the feeTakerAddress\n            payable(ftmbRequest.feesTakerAddress).transfer(\n                ftmbRequest.feesAmount\n            );\n        } else {\n            //transfer feesAmount to feesTakerAddress\n            ERC20(ftmbRequest.feesToken).safeTransferFrom(\n                msg.sender,\n                ftmbRequest.feesTakerAddress,\n                ftmbRequest.feesAmount\n            );\n        }\n\n        emit SocketFeesDeducted(\n            ftmbRequest.feesAmount,\n            ftmbRequest.feesTakerAddress,\n            ftmbRequest.feesToken\n        );\n\n        // multiple bridge-requests are to be generated and sequence and number of routeIds should match with the bridgeData array\n        for (\n            uint256 index = 0;\n            index < ftmbRequest.bridgeRouteIds.length;\n            ++index\n        ) {\n            //call bridge function (executeRoute for the bridgeData)\n            _executeRoute(\n                ftmbRequest.bridgeRouteIds[index],\n                ftmbRequest.bridgeRequestDataItems[index]\n            );\n        }\n    }\n\n    /**\n     * @notice function to deduct-fees to fees-taker address on source-chain followed by swap the amount on sourceChain followed by\n     *         bridging the swapped amount to destinationChain\n     * @dev while generating implData for swap and bridgeRequests, ensure correct function selector is used\n     *      bridge action corresponds to the bridgeAfterSwap function of the bridgeImplementation\n     * @param fsbRequest feesTakerSwapBridgeRequest object generated either off-chain or the calling contract using\n     *                   the function-selector FEES_TAKER_SWAP_BRIDGE_FUNCTION_SELECTOR\n     */\n    function takeFeeAndSwapAndBridge(\n        ISocketRequest.FeesTakerSwapBridgeRequest calldata fsbRequest\n    ) external payable returns (bytes memory) {\n        if (fsbRequest.feesToken == NATIVE_TOKEN_ADDRESS) {\n            //transfer the native amount to the feeTakerAddress\n            payable(fsbRequest.feesTakerAddress).transfer(\n                fsbRequest.feesAmount\n            );\n        } else {\n            //transfer feesAmount to feesTakerAddress\n            ERC20(fsbRequest.feesToken).safeTransferFrom(\n                msg.sender,\n                fsbRequest.feesTakerAddress,\n                fsbRequest.feesAmount\n            );\n        }\n\n        emit SocketFeesDeducted(\n            fsbRequest.feesAmount,\n            fsbRequest.feesTakerAddress,\n            fsbRequest.feesToken\n        );\n\n        // execute swap operation\n        bytes memory swapResponseData = _executeRoute(\n            fsbRequest.swapRouteId,\n            fsbRequest.swapData\n        );\n\n        uint256 swapAmount = abi.decode(swapResponseData, (uint256));\n\n        // swapped amount is to be bridged to the recipient on destinationChain\n        bytes memory bridgeImpldata = abi.encodeWithSelector(\n            BRIDGE_AFTER_SWAP_SELECTOR,\n            swapAmount,\n            fsbRequest.bridgeData\n        );\n\n        // execute bridge operation and return the byte-data from response of bridge operation\n        return _executeRoute(fsbRequest.bridgeRouteId, bridgeImpldata);\n    }\n\n    /**\n     * @notice function to deduct-fees to fees-taker address on source-chain followed by refuel followed by\n     *          swap the amount on sourceChain followed by bridging the swapped amount to destinationChain\n     * @dev while generating implData for refuel, swap and bridge Requests, ensure correct function selector is used\n     *      bridge action corresponds to the bridgeAfterSwap function of the bridgeImplementation\n     * @param frsbRequest feesTakerRefuelSwapBridgeRequest object generated either off-chain or the calling contract using\n     *                   the function-selector FEES_TAKER_REFUEL_SWAP_BRIDGE_FUNCTION_SELECTOR\n     */\n    function takeFeeAndRefuelAndSwapAndBridge(\n        ISocketRequest.FeesTakerRefuelSwapBridgeRequest calldata frsbRequest\n    ) external payable returns (bytes memory) {\n        if (frsbRequest.feesToken == NATIVE_TOKEN_ADDRESS) {\n            //transfer the native amount to the feeTakerAddress\n            payable(frsbRequest.feesTakerAddress).transfer(\n                frsbRequest.feesAmount\n            );\n        } else {\n            //transfer feesAmount to feesTakerAddress\n            ERC20(frsbRequest.feesToken).safeTransferFrom(\n                msg.sender,\n                frsbRequest.feesTakerAddress,\n                frsbRequest.feesAmount\n            );\n        }\n\n        emit SocketFeesDeducted(\n            frsbRequest.feesAmount,\n            frsbRequest.feesTakerAddress,\n            frsbRequest.feesToken\n        );\n\n        // refuel is also done via bridge execution via refuelRouteImplementation identified by refuelRouteId\n        _executeRoute(frsbRequest.refuelRouteId, frsbRequest.refuelData);\n\n        // execute swap operation\n        bytes memory swapResponseData = _executeRoute(\n            frsbRequest.swapRouteId,\n            frsbRequest.swapData\n        );\n\n        uint256 swapAmount = abi.decode(swapResponseData, (uint256));\n\n        // swapped amount is to be bridged to the recipient on destinationChain\n        bytes memory bridgeImpldata = abi.encodeWithSelector(\n            BRIDGE_AFTER_SWAP_SELECTOR,\n            swapAmount,\n            frsbRequest.bridgeData\n        );\n\n        // execute bridge operation and return the byte-data from response of bridge operation\n        return _executeRoute(frsbRequest.bridgeRouteId, bridgeImpldata);\n    }\n}\n"},"src/errors/SocketErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nerror CelerRefundNotReady();\nerror OnlySocketDeployer();\nerror OnlySocketGatewayOwner();\nerror OnlySocketGateway();\nerror OnlyOwner();\nerror OnlyNominee();\nerror TransferIdExists();\nerror TransferIdDoesnotExist();\nerror Address0Provided();\nerror SwapFailed();\nerror UnsupportedInterfaceId();\nerror InvalidCelerRefund();\nerror CelerAlreadyRefunded();\nerror IncorrectBridgeRatios();\nerror ZeroAddressNotAllowed();\nerror ArrayLengthMismatch();\n"},"src/bridges/hop/l1/HopImplL1.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"../interfaces/IHopL1Bridge.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {BridgeImplBase} from \"../../BridgeImplBase.sol\";\nimport {HOP} from \"../../../static/RouteIdentifiers.sol\";\n\n/**\n * @title Hop-L1 Route Implementation\n * @notice Route implementation with functions to bridge ERC20 and Native via Hop-Bridge from L1 to Supported L2s\n * Called via SocketGateway if the routeId in the request maps to the routeId of HopImplementation\n * Contains function to handle bridging as post-step i.e linked to a preceeding step for swap\n * RequestData is different to just bride and bridging chained with swap\n * @author Socket dot tech.\n */\ncontract HopImplL1 is BridgeImplBase {\n    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens\n    using SafeTransferLib for ERC20;\n\n    bytes32 public immutable HopIdentifier = HOP;\n\n    /// @notice Function-selector for ERC20-token bridging on Hop-L1-Route\n    /// @dev This function selector is to be used while buidling transaction-data to bridge ERC20 tokens\n    bytes4 public immutable HOP_L1_ERC20_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeERC20To(address,address,address,address,uint256,uint256,uint256,uint256,(uint256,bytes32))\"\n            )\n        );\n\n    /// @notice Function-selector for Native bridging on Hop-L1-Route\n    /// @dev This function selector is to be used while building transaction-data to bridge Native tokens\n    bytes4 public immutable HOP_L1_NATIVE_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeNativeTo(address,address,address,uint256,uint256,uint256,uint256,uint256,bytes32)\"\n            )\n        );\n\n    bytes4 public immutable HOP_L1_SWAP_BRIDGE_SELECTOR =\n        bytes4(\n            keccak256(\n                \"swapAndBridge(uint32,bytes,(address,address,address,uint256,uint256,uint256,uint256,bytes32))\"\n            )\n        );\n\n    /// @notice socketGatewayAddress to be initialised via storage variable BridgeImplBase\n    constructor(\n        address _socketGateway,\n        address _socketDeployFactory\n    ) BridgeImplBase(_socketGateway, _socketDeployFactory) {}\n\n    /// @notice Struct to be used in decode step from input parameter - a specific case of bridging after swap.\n    /// @dev the data being encoded in offchain or by caller should have values set in this sequence of properties in this struct\n    struct HopDataNoToken {\n        // The address receiving funds at the destination\n        address receiverAddress;\n        // address of the Hop-L1-Bridge to handle bridging the tokens\n        address l1bridgeAddr;\n        // relayerFee The amount distributed to the relayer at the destination. This is subtracted from the `_amount`.\n        address relayer;\n        // The chainId of the destination chain\n        uint256 toChainId;\n        // The minimum amount received after attempting to swap in the destination AMM market. 0 if no swap is intended.\n        uint256 amountOutMin;\n        // The amount distributed to the relayer at the destination. This is subtracted from the `amount`.\n        uint256 relayerFee;\n        // The deadline for swapping in the destination AMM market. 0 if no swap is intended.\n        uint256 deadline;\n        // socket offchain created hash\n        bytes32 metadata;\n    }\n\n    struct HopData {\n        /// @notice address of token being bridged\n        address token;\n        // The address receiving funds at the destination\n        address receiverAddress;\n        // address of the Hop-L1-Bridge to handle bridging the tokens\n        address l1bridgeAddr;\n        // relayerFee The amount distributed to the relayer at the destination. This is subtracted from the `_amount`.\n        address relayer;\n        // The chainId of the destination chain\n        uint256 toChainId;\n        // The minimum amount received after attempting to swap in the destination AMM market. 0 if no swap is intended.\n        uint256 amountOutMin;\n        // The amount distributed to the relayer at the destination. This is subtracted from the `amount`.\n        uint256 relayerFee;\n        // The deadline for swapping in the destination AMM market. 0 if no swap is intended.\n        uint256 deadline;\n        // socket offchain created hash\n        bytes32 metadata;\n    }\n\n    struct HopERC20Data {\n        uint256 deadline;\n        bytes32 metadata;\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from swapAndBridge, this function is called when the swap has already happened at a different place.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in HopBridgeData struct\n     * @param amount amount of tokens being bridged. this can be ERC20 or native\n     * @param bridgeData encoded data for Hop-L1-Bridge\n     */\n    function bridgeAfterSwap(\n        uint256 amount,\n        bytes calldata bridgeData\n    ) external payable override {\n        HopData memory hopData = abi.decode(bridgeData, (HopData));\n\n        if (hopData.token == NATIVE_TOKEN_ADDRESS) {\n            IHopL1Bridge(hopData.l1bridgeAddr).sendToL2{value: amount}(\n                hopData.toChainId,\n                hopData.receiverAddress,\n                amount,\n                hopData.amountOutMin,\n                hopData.deadline,\n                hopData.relayer,\n                hopData.relayerFee\n            );\n        } else {\n            ERC20(hopData.token).safeApprove(hopData.l1bridgeAddr, amount);\n\n            // perform bridging\n            IHopL1Bridge(hopData.l1bridgeAddr).sendToL2(\n                hopData.toChainId,\n                hopData.receiverAddress,\n                amount,\n                hopData.amountOutMin,\n                hopData.deadline,\n                hopData.relayer,\n                hopData.relayerFee\n            );\n        }\n\n        emit SocketBridge(\n            amount,\n            hopData.token,\n            hopData.toChainId,\n            HopIdentifier,\n            msg.sender,\n            hopData.receiverAddress,\n            hopData.metadata\n        );\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from bridgeAfterSwap since this function holds the logic for swapping tokens too.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in HopBridgeData struct\n     * @param swapId routeId for the swapImpl\n     * @param swapData encoded data for swap\n     * @param hopData encoded data for HopData\n     */\n    function swapAndBridge(\n        uint32 swapId,\n        bytes calldata swapData,\n        HopDataNoToken calldata hopData\n    ) external payable {\n        (bool success, bytes memory result) = socketRoute\n            .getRoute(swapId)\n            .delegatecall(swapData);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        (uint256 bridgeAmount, address token) = abi.decode(\n            result,\n            (uint256, address)\n        );\n\n        if (token == NATIVE_TOKEN_ADDRESS) {\n            IHopL1Bridge(hopData.l1bridgeAddr).sendToL2{value: bridgeAmount}(\n                hopData.toChainId,\n                hopData.receiverAddress,\n                bridgeAmount,\n                hopData.amountOutMin,\n                hopData.deadline,\n                hopData.relayer,\n                hopData.relayerFee\n            );\n        } else {\n            ERC20(token).safeApprove(hopData.l1bridgeAddr, bridgeAmount);\n\n            // perform bridging\n            IHopL1Bridge(hopData.l1bridgeAddr).sendToL2(\n                hopData.toChainId,\n                hopData.receiverAddress,\n                bridgeAmount,\n                hopData.amountOutMin,\n                hopData.deadline,\n                hopData.relayer,\n                hopData.relayerFee\n            );\n        }\n\n        emit SocketBridge(\n            bridgeAmount,\n            token,\n            hopData.toChainId,\n            HopIdentifier,\n            msg.sender,\n            hopData.receiverAddress,\n            hopData.metadata\n        );\n    }\n\n    /**\n     * @notice function to handle ERC20 bridging to receipent via Hop-L1-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param receiverAddress The address receiving funds at the destination\n     * @param token token being bridged\n     * @param l1bridgeAddr address of the Hop-L1-Bridge to handle bridging the tokens\n     * @param relayer The amount distributed to the relayer at the destination. This is subtracted from the `_amount`.\n     * @param toChainId The chainId of the destination chain\n     * @param amount The amount being sent\n     * @param amountOutMin The minimum amount received after attempting to swap in the destination AMM market. 0 if no swap is intended.\n     * @param relayerFee The amount distributed to the relayer at the destination. This is subtracted from the `amount`.\n     * @param hopData extra data needed to build the tx\n     */\n    function bridgeERC20To(\n        address receiverAddress,\n        address token,\n        address l1bridgeAddr,\n        address relayer,\n        uint256 toChainId,\n        uint256 amount,\n        uint256 amountOutMin,\n        uint256 relayerFee,\n        HopERC20Data calldata hopData\n    ) external payable {\n        ERC20 tokenInstance = ERC20(token);\n        tokenInstance.safeTransferFrom(msg.sender, socketGateway, amount);\n        tokenInstance.safeApprove(l1bridgeAddr, amount);\n\n        // perform bridging\n        IHopL1Bridge(l1bridgeAddr).sendToL2(\n            toChainId,\n            receiverAddress,\n            amount,\n            amountOutMin,\n            hopData.deadline,\n            relayer,\n            relayerFee\n        );\n\n        emit SocketBridge(\n            amount,\n            token,\n            toChainId,\n            HopIdentifier,\n            msg.sender,\n            receiverAddress,\n            hopData.metadata\n        );\n    }\n\n    /**\n     * @notice function to handle Native bridging to receipent via Hop-L1-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param receiverAddress The address receiving funds at the destination\n     * @param l1bridgeAddr address of the Hop-L1-Bridge to handle bridging the tokens\n     * @param relayer The amount distributed to the relayer at the destination. This is subtracted from the `_amount`.\n     * @param toChainId The chainId of the destination chain\n     * @param amount The amount being sent\n     * @param amountOutMin The minimum amount received after attempting to swap in the destination AMM market. 0 if no swap is intended.\n     * @param relayerFee The amount distributed to the relayer at the destination. This is subtracted from the `amount`.\n     * @param deadline The deadline for swapping in the destination AMM market. 0 if no swap is intended.\n     */\n    function bridgeNativeTo(\n        address receiverAddress,\n        address l1bridgeAddr,\n        address relayer,\n        uint256 toChainId,\n        uint256 amount,\n        uint256 amountOutMin,\n        uint256 relayerFee,\n        uint256 deadline,\n        bytes32 metadata\n    ) external payable {\n        IHopL1Bridge(l1bridgeAddr).sendToL2{value: amount}(\n            toChainId,\n            receiverAddress,\n            amount,\n            amountOutMin,\n            deadline,\n            relayer,\n            relayerFee\n        );\n\n        emit SocketBridge(\n            amount,\n            NATIVE_TOKEN_ADDRESS,\n            toChainId,\n            HopIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n}\n"},"src/static/RouteIdentifiers.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nbytes32 constant ACROSS = keccak256(\"Across\");\n\nbytes32 constant ANYSWAP = keccak256(\"Anyswap\");\n\nbytes32 constant CBRIDGE = keccak256(\"CBridge\");\n\nbytes32 constant HOP = keccak256(\"Hop\");\n\nbytes32 constant HYPHEN = keccak256(\"Hyphen\");\n\nbytes32 constant NATIVE_OPTIMISM = keccak256(\"NativeOptimism\");\n\nbytes32 constant NATIVE_ARBITRUM = keccak256(\"NativeArbitrum\");\n\nbytes32 constant NATIVE_POLYGON = keccak256(\"NativePolygon\");\n\nbytes32 constant REFUEL = keccak256(\"Refuel\");\n\nbytes32 constant STARGATE = keccak256(\"Stargate\");\n\nbytes32 constant ONEINCH = keccak256(\"OneInch\");\n\nbytes32 constant ZEROX = keccak256(\"Zerox\");\n\nbytes32 constant RAINBOW = keccak256(\"Rainbow\");\n"},"src/SocketGateway.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\npragma experimental ABIEncoderV2;\n\nimport \"./utils/Ownable.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {LibUtil} from \"./libraries/LibUtil.sol\";\nimport \"./libraries/LibBytes.sol\";\nimport {ISocketRoute} from \"./interfaces/ISocketRoute.sol\";\nimport {ISocketRequest} from \"./interfaces/ISocketRequest.sol\";\nimport {ISocketGateway} from \"./interfaces/ISocketGateway.sol\";\nimport {IncorrectBridgeRatios, ZeroAddressNotAllowed, ArrayLengthMismatch} from \"./errors/SocketErrors.sol\";\n\n/// @title SocketGatewayContract\n/// @notice Socketgateway is a contract with entrypoint functions for all interactions with socket liquidity layer\n/// @author Socket Team\ncontract SocketGatewayTemplate is Ownable {\n    using LibBytes for bytes;\n    using LibBytes for bytes4;\n    using SafeTransferLib for ERC20;\n\n    /// @notice FunctionSelector used to delegatecall from swap to the function of bridge router implementation\n    bytes4 public immutable BRIDGE_AFTER_SWAP_SELECTOR =\n        bytes4(keccak256(\"bridgeAfterSwap(uint256,bytes)\"));\n\n    /// @notice storage variable to keep track of total number of routes registered in socketgateway\n    uint32 public routesCount = 385;\n\n    /// @notice storage variable to keep track of total number of controllers registered in socketgateway\n    uint32 public controllerCount;\n\n    address public immutable disabledRouteAddress;\n\n    uint256 public constant CENT_PERCENT = 100e18;\n\n    /// @notice storage mapping for route implementation addresses\n    mapping(uint32 => address) public routes;\n\n    /// storage mapping for controller implemenation addresses\n    mapping(uint32 => address) public controllers;\n\n    // Events ------------------------------------------------------------------------------------------------------->\n\n    /// @notice Event emitted when a router is added to socketgateway\n    event NewRouteAdded(uint32 indexed routeId, address indexed route);\n\n    /// @notice Event emitted when a route is disabled\n    event RouteDisabled(uint32 indexed routeId);\n\n    /// @notice Event emitted when ownership transfer is requested by socket-gateway-owner\n    event OwnershipTransferRequested(\n        address indexed _from,\n        address indexed _to\n    );\n\n    /// @notice Event emitted when a controller is added to socketgateway\n    event ControllerAdded(\n        uint32 indexed controllerId,\n        address indexed controllerAddress\n    );\n\n    /// @notice Event emitted when a controller is disabled\n    event ControllerDisabled(uint32 indexed controllerId);\n\n    constructor(address _owner, address _disabledRoute) Ownable(_owner) {\n        disabledRouteAddress = _disabledRoute;\n    }\n\n    // Able to receive ether\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    /*******************************************\n     *          EXTERNAL AND PUBLIC FUNCTIONS  *\n     *******************************************/\n\n    /**\n     * @notice executes functions in the routes identified using routeId and functionSelectorData\n     * @notice The caller must first approve this contract to spend amount of ERC20-Token being bridged/swapped\n     * @dev ensure the data in routeData to be built using the function-selector defined as a\n     *         constant in the route implementation contract\n     * @param routeId route identifier\n     * @param routeData functionSelectorData generated using the function-selector defined in the route Implementation\n     */\n    function executeRoute(\n        uint32 routeId,\n        bytes calldata routeData\n    ) external payable returns (bytes memory) {\n        (bool success, bytes memory result) = addressAt(routeId).delegatecall(\n            routeData\n        );\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice swaps a token on sourceChain and split it across multiple bridge-recipients\n     * @notice The caller must first approve this contract to spend amount of ERC20-Token being swapped\n     * @dev ensure the swap-data and bridge-data is generated using the function-selector defined as a constant in the implementation address\n     * @param swapMultiBridgeRequest request\n     */\n    function swapAndMultiBridge(\n        ISocketRequest.SwapMultiBridgeRequest calldata swapMultiBridgeRequest\n    ) external payable {\n        uint256 requestLength = swapMultiBridgeRequest.bridgeRouteIds.length;\n\n        if (\n            requestLength != swapMultiBridgeRequest.bridgeImplDataItems.length\n        ) {\n            revert ArrayLengthMismatch();\n        }\n        uint256 ratioAggregate;\n        for (uint256 index = 0; index < requestLength; ) {\n            ratioAggregate += swapMultiBridgeRequest.bridgeRatios[index];\n        }\n\n        if (ratioAggregate != CENT_PERCENT) {\n            revert IncorrectBridgeRatios();\n        }\n\n        (bool swapSuccess, bytes memory swapResult) = addressAt(\n            swapMultiBridgeRequest.swapRouteId\n        ).delegatecall(swapMultiBridgeRequest.swapImplData);\n\n        if (!swapSuccess) {\n            assembly {\n                revert(add(swapResult, 32), mload(swapResult))\n            }\n        }\n\n        uint256 amountReceivedFromSwap = abi.decode(swapResult, (uint256));\n\n        uint256 bridgedAmount;\n\n        for (uint256 index = 0; index < requestLength; ) {\n            uint256 bridgingAmount;\n\n            // if it is the last bridge request, bridge the remaining amount\n            if (index == requestLength - 1) {\n                bridgingAmount = amountReceivedFromSwap - bridgedAmount;\n            } else {\n                // bridging amount is the multiplication of bridgeRatio and amountReceivedFromSwap\n                bridgingAmount =\n                    (amountReceivedFromSwap *\n                        swapMultiBridgeRequest.bridgeRatios[index]) /\n                    (CENT_PERCENT);\n            }\n\n            // update the bridged amount, this would be used for computation for last bridgeRequest\n            bridgedAmount += bridgingAmount;\n\n            bytes memory bridgeImpldata = abi.encodeWithSelector(\n                BRIDGE_AFTER_SWAP_SELECTOR,\n                bridgingAmount,\n                swapMultiBridgeRequest.bridgeImplDataItems[index]\n            );\n\n            (bool bridgeSuccess, bytes memory bridgeResult) = addressAt(\n                swapMultiBridgeRequest.bridgeRouteIds[index]\n            ).delegatecall(bridgeImpldata);\n\n            if (!bridgeSuccess) {\n                assembly {\n                    revert(add(bridgeResult, 32), mload(bridgeResult))\n                }\n            }\n\n            unchecked {\n                ++index;\n            }\n        }\n    }\n\n    /**\n     * @notice sequentially executes functions in the routes identified using routeId and functionSelectorData\n     * @notice The caller must first approve this contract to spend amount of ERC20-Token being bridged/swapped\n     * @dev ensure the data in each dataItem to be built using the function-selector defined as a\n     *         constant in the route implementation contract\n     * @param routeIds a list of route identifiers\n     * @param dataItems a list of functionSelectorData generated using the function-selector defined in the route Implementation\n     */\n    function executeRoutes(\n        uint32[] calldata routeIds,\n        bytes[] calldata dataItems\n    ) external payable {\n        uint256 routeIdslength = routeIds.length;\n        if (routeIdslength != dataItems.length) revert ArrayLengthMismatch();\n        for (uint256 index = 0; index < routeIdslength; ) {\n            (bool success, bytes memory result) = addressAt(routeIds[index])\n                .delegatecall(dataItems[index]);\n\n            if (!success) {\n                assembly {\n                    revert(add(result, 32), mload(result))\n                }\n            }\n\n            unchecked {\n                ++index;\n            }\n        }\n    }\n\n    /**\n     * @notice execute a controller function identified using the controllerId in the request\n     * @notice The caller must first approve this contract to spend amount of ERC20-Token being bridged/swapped\n     * @dev ensure the data in request to be built using the function-selector defined as a\n     *         constant in the controller implementation contract\n     * @param socketControllerRequest socketControllerRequest with controllerId to identify the\n     *                                   controllerAddress and byteData constructed using functionSelector\n     *                                   of the function being invoked\n     * @return bytes data received from the call delegated to controller\n     */\n    function executeController(\n        ISocketGateway.SocketControllerRequest calldata socketControllerRequest\n    ) external payable returns (bytes memory) {\n        (bool success, bytes memory result) = controllers[\n            socketControllerRequest.controllerId\n        ].delegatecall(socketControllerRequest.data);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice sequentially executes all controller requests\n     * @notice The caller must first approve this contract to spend amount of ERC20-Token being bridged/swapped\n     * @dev ensure the data in each controller-request to be built using the function-selector defined as a\n     *         constant in the controller implementation contract\n     * @param controllerRequests a list of socketControllerRequest\n     *                              Each controllerRequest contains controllerId to identify the controllerAddress and\n     *                              byteData constructed using functionSelector of the function being invoked\n     */\n    function executeControllers(\n        ISocketGateway.SocketControllerRequest[] calldata controllerRequests\n    ) external payable {\n        for (uint32 index = 0; index < controllerRequests.length; ) {\n            (bool success, bytes memory result) = controllers[\n                controllerRequests[index].controllerId\n            ].delegatecall(controllerRequests[index].data);\n\n            if (!success) {\n                assembly {\n                    revert(add(result, 32), mload(result))\n                }\n            }\n\n            unchecked {\n                ++index;\n            }\n        }\n    }\n\n    /**************************************\n     *          ADMIN FUNCTIONS           *\n     **************************************/\n\n    /**\n     * @notice Add route to the socketGateway\n               This is a restricted function to be called by only socketGatewayOwner\n     * @dev ensure routeAddress is a verified bridge or middleware implementation address\n     * @param routeAddress The address of bridge or middleware implementation contract deployed\n     * @return Id of the route added to the routes-mapping in socketGateway storage\n     */\n    function addRoute(\n        address routeAddress\n    ) external onlyOwner returns (uint32) {\n        uint32 routeId = routesCount;\n        routes[routeId] = routeAddress;\n\n        routesCount += 1;\n\n        emit NewRouteAdded(routeId, routeAddress);\n\n        return routeId;\n    }\n\n    /**\n     * @notice Give Infinite or 0 approval to bridgeRoute for the tokenAddress\n               This is a restricted function to be called by only socketGatewayOwner\n     */\n\n    function setApprovalForRouters(\n        address[] memory routeAddresses,\n        address[] memory tokenAddresses,\n        bool isMax\n    ) external onlyOwner {\n        for (uint32 index = 0; index < routeAddresses.length; ) {\n            ERC20(tokenAddresses[index]).approve(\n                routeAddresses[index],\n                isMax ? type(uint256).max : 0\n            );\n            unchecked {\n                ++index;\n            }\n        }\n    }\n\n    /**\n     * @notice Add controller to the socketGateway\n               This is a restricted function to be called by only socketGatewayOwner\n     * @dev ensure controllerAddress is a verified controller implementation address\n     * @param controllerAddress The address of controller implementation contract deployed\n     * @return Id of the controller added to the controllers-mapping in socketGateway storage\n     */\n    function addController(\n        address controllerAddress\n    ) external onlyOwner returns (uint32) {\n        uint32 controllerId = controllerCount;\n\n        controllers[controllerId] = controllerAddress;\n\n        controllerCount += 1;\n\n        emit ControllerAdded(controllerId, controllerAddress);\n\n        return controllerId;\n    }\n\n    /**\n     * @notice disable controller by setting ZeroAddress to the entry in controllers-mapping\n               identified by controllerId as key.\n               This is a restricted function to be called by only socketGatewayOwner\n     * @param controllerId The Id of controller-implementation in the controllers mapping\n     */\n    function disableController(uint32 controllerId) public onlyOwner {\n        controllers[controllerId] = disabledRouteAddress;\n        emit ControllerDisabled(controllerId);\n    }\n\n    /**\n     * @notice disable a route by setting ZeroAddress to the entry in routes-mapping\n               identified by routeId as key.\n               This is a restricted function to be called by only socketGatewayOwner\n     * @param routeId The Id of route-implementation in the routes mapping\n     */\n    function disableRoute(uint32 routeId) external onlyOwner {\n        routes[routeId] = disabledRouteAddress;\n        emit RouteDisabled(routeId);\n    }\n\n    /*******************************************\n     *          RESTRICTED RESCUE FUNCTIONS    *\n     *******************************************/\n\n    /**\n     * @notice Rescues the ERC20 token to an address\n               this is a restricted function to be called by only socketGatewayOwner\n     * @dev as this is a restricted to socketGatewayOwner, ensure the userAddress is a known address\n     * @param token address of the ERC20 token being rescued\n     * @param userAddress address to which ERC20 is to be rescued\n     * @param amount amount of ERC20 tokens being rescued\n     */\n    function rescueFunds(\n        address token,\n        address userAddress,\n        uint256 amount\n    ) external onlyOwner {\n        ERC20(token).safeTransfer(userAddress, amount);\n    }\n\n    /**\n     * @notice Rescues the native balance to an address\n               this is a restricted function to be called by only socketGatewayOwner\n     * @dev as this is a restricted to socketGatewayOwner, ensure the userAddress is a known address\n     * @param userAddress address to which native-balance is to be rescued\n     * @param amount amount of native-balance being rescued\n     */\n    function rescueEther(\n        address payable userAddress,\n        uint256 amount\n    ) external onlyOwner {\n        userAddress.transfer(amount);\n    }\n\n    /*******************************************\n     *          VIEW FUNCTIONS                  *\n     *******************************************/\n\n    /**\n     * @notice Get routeImplementation address mapped to the routeId\n     * @param routeId routeId is the key in the mapping for routes\n     * @return route-implementation address\n     */\n    function getRoute(uint32 routeId) public view returns (address) {\n        return addressAt(routeId);\n    }\n\n    /**\n     * @notice Get controllerImplementation address mapped to the controllerId\n     * @param controllerId controllerId is the key in the mapping for controllers\n     * @return controller-implementation address\n     */\n    function getController(uint32 controllerId) public view returns (address) {\n        return controllers[controllerId];\n    }\n\n    function addressAt(uint32 routeId) public view returns (address) {\n        if (routeId < 385) {\n            if (routeId < 257) {\n                if (routeId < 129) {\n                    if (routeId < 65) {\n                        if (routeId < 33) {\n                            if (routeId < 17) {\n                                if (routeId < 9) {\n                                    if (routeId < 5) {\n                                        if (routeId < 3) {\n                                            if (routeId == 1) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 3) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 7) {\n                                            if (routeId == 5) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 7) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 13) {\n                                        if (routeId < 11) {\n                                            if (routeId == 9) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 11) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 15) {\n                                            if (routeId == 13) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 15) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 25) {\n                                    if (routeId < 21) {\n                                        if (routeId < 19) {\n                                            if (routeId == 17) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 19) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 23) {\n                                            if (routeId == 21) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 23) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 29) {\n                                        if (routeId < 27) {\n                                            if (routeId == 25) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 27) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 31) {\n                                            if (routeId == 29) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 31) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            if (routeId < 49) {\n                                if (routeId < 41) {\n                                    if (routeId < 37) {\n                                        if (routeId < 35) {\n                                            if (routeId == 33) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 35) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 39) {\n                                            if (routeId == 37) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 39) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 45) {\n                                        if (routeId < 43) {\n                                            if (routeId == 41) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 43) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 47) {\n                                            if (routeId == 45) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 47) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 57) {\n                                    if (routeId < 53) {\n                                        if (routeId < 51) {\n                                            if (routeId == 49) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 51) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 55) {\n                                            if (routeId == 53) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 55) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 61) {\n                                        if (routeId < 59) {\n                                            if (routeId == 57) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 59) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 63) {\n                                            if (routeId == 61) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 63) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        if (routeId < 97) {\n                            if (routeId < 81) {\n                                if (routeId < 73) {\n                                    if (routeId < 69) {\n                                        if (routeId < 67) {\n                                            if (routeId == 65) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 67) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 71) {\n                                            if (routeId == 69) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 71) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 77) {\n                                        if (routeId < 75) {\n                                            if (routeId == 73) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 75) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 79) {\n                                            if (routeId == 77) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 79) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 89) {\n                                    if (routeId < 85) {\n                                        if (routeId < 83) {\n                                            if (routeId == 81) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 83) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 87) {\n                                            if (routeId == 85) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 87) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 93) {\n                                        if (routeId < 91) {\n                                            if (routeId == 89) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 91) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 95) {\n                                            if (routeId == 93) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 95) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            if (routeId < 113) {\n                                if (routeId < 105) {\n                                    if (routeId < 101) {\n                                        if (routeId < 99) {\n                                            if (routeId == 97) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 99) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 103) {\n                                            if (routeId == 101) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 103) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 109) {\n                                        if (routeId < 107) {\n                                            if (routeId == 105) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 107) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 111) {\n                                            if (routeId == 109) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 111) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 121) {\n                                    if (routeId < 117) {\n                                        if (routeId < 115) {\n                                            if (routeId == 113) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 115) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 119) {\n                                            if (routeId == 117) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 119) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 125) {\n                                        if (routeId < 123) {\n                                            if (routeId == 121) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 123) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 127) {\n                                            if (routeId == 125) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 127) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    if (routeId < 193) {\n                        if (routeId < 161) {\n                            if (routeId < 145) {\n                                if (routeId < 137) {\n                                    if (routeId < 133) {\n                                        if (routeId < 131) {\n                                            if (routeId == 129) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 131) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 135) {\n                                            if (routeId == 133) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 135) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 141) {\n                                        if (routeId < 139) {\n                                            if (routeId == 137) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 139) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 143) {\n                                            if (routeId == 141) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 143) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 153) {\n                                    if (routeId < 149) {\n                                        if (routeId < 147) {\n                                            if (routeId == 145) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 147) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 151) {\n                                            if (routeId == 149) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 151) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 157) {\n                                        if (routeId < 155) {\n                                            if (routeId == 153) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 155) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 159) {\n                                            if (routeId == 157) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 159) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            if (routeId < 177) {\n                                if (routeId < 169) {\n                                    if (routeId < 165) {\n                                        if (routeId < 163) {\n                                            if (routeId == 161) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 163) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 167) {\n                                            if (routeId == 165) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 167) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 173) {\n                                        if (routeId < 171) {\n                                            if (routeId == 169) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 171) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 175) {\n                                            if (routeId == 173) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 175) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 185) {\n                                    if (routeId < 181) {\n                                        if (routeId < 179) {\n                                            if (routeId == 177) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 179) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 183) {\n                                            if (routeId == 181) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 183) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 189) {\n                                        if (routeId < 187) {\n                                            if (routeId == 185) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 187) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 191) {\n                                            if (routeId == 189) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 191) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        if (routeId < 225) {\n                            if (routeId < 209) {\n                                if (routeId < 201) {\n                                    if (routeId < 197) {\n                                        if (routeId < 195) {\n                                            if (routeId == 193) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 195) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 199) {\n                                            if (routeId == 197) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 199) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 205) {\n                                        if (routeId < 203) {\n                                            if (routeId == 201) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 203) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 207) {\n                                            if (routeId == 205) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 207) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 217) {\n                                    if (routeId < 213) {\n                                        if (routeId < 211) {\n                                            if (routeId == 209) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 211) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 215) {\n                                            if (routeId == 213) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 215) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 221) {\n                                        if (routeId < 219) {\n                                            if (routeId == 217) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 219) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 223) {\n                                            if (routeId == 221) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 223) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            if (routeId < 241) {\n                                if (routeId < 233) {\n                                    if (routeId < 229) {\n                                        if (routeId < 227) {\n                                            if (routeId == 225) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 227) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 231) {\n                                            if (routeId == 229) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 231) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 237) {\n                                        if (routeId < 235) {\n                                            if (routeId == 233) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 235) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 239) {\n                                            if (routeId == 237) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 239) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 249) {\n                                    if (routeId < 245) {\n                                        if (routeId < 243) {\n                                            if (routeId == 241) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 243) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 247) {\n                                            if (routeId == 245) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 247) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 253) {\n                                        if (routeId < 251) {\n                                            if (routeId == 249) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 251) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    } else {\n                                        if (routeId < 255) {\n                                            if (routeId == 253) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        } else {\n                                            if (routeId == 255) {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            } else {\n                                                return\n                                                    0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } else {\n                if (routeId < 321) {\n                    if (routeId < 289) {\n                        if (routeId < 273) {\n                            if (routeId < 265) {\n                                if (routeId < 261) {\n                                    if (routeId < 259) {\n                                        if (routeId == 257) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 259) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 263) {\n                                        if (routeId == 261) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 263) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 269) {\n                                    if (routeId < 267) {\n                                        if (routeId == 265) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 267) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 271) {\n                                        if (routeId == 269) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 271) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            if (routeId < 281) {\n                                if (routeId < 277) {\n                                    if (routeId < 275) {\n                                        if (routeId == 273) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 275) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 279) {\n                                        if (routeId == 277) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 279) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 285) {\n                                    if (routeId < 283) {\n                                        if (routeId == 281) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 283) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 287) {\n                                        if (routeId == 285) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 287) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        if (routeId < 305) {\n                            if (routeId < 297) {\n                                if (routeId < 293) {\n                                    if (routeId < 291) {\n                                        if (routeId == 289) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 291) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 295) {\n                                        if (routeId == 293) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 295) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 301) {\n                                    if (routeId < 299) {\n                                        if (routeId == 297) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 299) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 303) {\n                                        if (routeId == 301) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 303) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            if (routeId < 313) {\n                                if (routeId < 309) {\n                                    if (routeId < 307) {\n                                        if (routeId == 305) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 307) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 311) {\n                                        if (routeId == 309) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 311) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 317) {\n                                    if (routeId < 315) {\n                                        if (routeId == 313) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 315) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 319) {\n                                        if (routeId == 317) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 319) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    if (routeId < 353) {\n                        if (routeId < 337) {\n                            if (routeId < 329) {\n                                if (routeId < 325) {\n                                    if (routeId < 323) {\n                                        if (routeId == 321) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 323) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 327) {\n                                        if (routeId == 325) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 327) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 333) {\n                                    if (routeId < 331) {\n                                        if (routeId == 329) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 331) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 335) {\n                                        if (routeId == 333) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 335) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            if (routeId < 345) {\n                                if (routeId < 341) {\n                                    if (routeId < 339) {\n                                        if (routeId == 337) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 339) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 343) {\n                                        if (routeId == 341) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 343) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 349) {\n                                    if (routeId < 347) {\n                                        if (routeId == 345) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 347) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 351) {\n                                        if (routeId == 349) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 351) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        if (routeId < 369) {\n                            if (routeId < 361) {\n                                if (routeId < 357) {\n                                    if (routeId < 355) {\n                                        if (routeId == 353) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 355) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 359) {\n                                        if (routeId == 357) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 359) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 365) {\n                                    if (routeId < 363) {\n                                        if (routeId == 361) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 363) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 367) {\n                                        if (routeId == 365) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 367) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            if (routeId < 377) {\n                                if (routeId < 373) {\n                                    if (routeId < 371) {\n                                        if (routeId == 369) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 371) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 375) {\n                                        if (routeId == 373) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 375) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (routeId < 381) {\n                                    if (routeId < 379) {\n                                        if (routeId == 377) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 379) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                } else {\n                                    if (routeId < 383) {\n                                        if (routeId == 381) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    } else {\n                                        if (routeId == 383) {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        } else {\n                                            return\n                                                0x822D4B4e63499a576Ab1cc152B86D1CFFf794F4f;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (routes[routeId] == address(0)) revert ZeroAddressNotAllowed();\n        return routes[routeId];\n    }\n\n    /// @notice fallback function to handle swap, bridge execution\n    /// @dev ensure routeId is converted to bytes4 and sent as msg.sig in the transaction\n    fallback() external payable {\n        address routeAddress = addressAt(uint32(msg.sig));\n\n        bytes memory result;\n\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 4, sub(calldatasize(), 4))\n            // execute function call using the facet\n            result := delegatecall(\n                gas(),\n                routeAddress,\n                0,\n                sub(calldatasize(), 4),\n                0,\n                0\n            )\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"},"src/swap/rainbow/Rainbow.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport \"../SwapImplBase.sol\";\nimport {Address0Provided, SwapFailed} from \"../../errors/SocketErrors.sol\";\nimport {RAINBOW} from \"../../static/RouteIdentifiers.sol\";\n\n/**\n * @title Rainbow-Swap-Route Implementation\n * @notice Route implementation with functions to swap tokens via Rainbow-Swap\n * Called via SocketGateway if the routeId in the request maps to the routeId of RainbowImplementation\n * @author Socket dot tech.\n */\ncontract RainbowSwapImpl is SwapImplBase {\n    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens\n    using SafeTransferLib for ERC20;\n\n    bytes32 public immutable RainbowIdentifier = RAINBOW;\n\n    /// @notice unique name to identify the router, used to emit event upon successful bridging\n    bytes32 public immutable NAME = keccak256(\"Rainbow-Router\");\n\n    /// @notice address of rainbow-swap-aggregator to swap the tokens on Chain\n    address payable public immutable rainbowSwapAggregator;\n\n    /// @notice socketGatewayAddress to be initialised via storage variable SwapImplBase\n    /// @notice rainbow swap aggregator contract is payable to allow ethereum swaps\n    /// @dev ensure _rainbowSwapAggregator are set properly for the chainId in which the contract is being deployed\n    constructor(\n        address _rainbowSwapAggregator,\n        address _socketGateway,\n        address _socketDeployFactory\n    ) SwapImplBase(_socketGateway, _socketDeployFactory) {\n        rainbowSwapAggregator = payable(_rainbowSwapAggregator);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    /**\n     * @notice function to swap tokens on the chain and transfer to receiver address\n     * @notice This method is payable because the caller is doing token transfer and swap operation\n     * @param fromToken address of token being Swapped\n     * @param toToken address of token that recipient will receive after swap\n     * @param amount amount of fromToken being swapped\n     * @param receiverAddress recipient-address\n     * @param swapExtraData additional Data to perform Swap via Rainbow-Aggregator\n     * @return swapped amount (in toToken Address)\n     */\n    function performAction(\n        address fromToken,\n        address toToken,\n        uint256 amount,\n        address receiverAddress,\n        bytes calldata swapExtraData\n    ) external payable override returns (uint256) {\n        if (fromToken == address(0)) {\n            revert Address0Provided();\n        }\n\n        bytes memory swapCallData = abi.decode(swapExtraData, (bytes));\n\n        uint256 _initialBalanceTokenOut;\n        uint256 _finalBalanceTokenOut;\n\n        ERC20 toTokenERC20 = ERC20(toToken);\n        if (toToken != NATIVE_TOKEN_ADDRESS) {\n            _initialBalanceTokenOut = toTokenERC20.balanceOf(socketGateway);\n        } else {\n            _initialBalanceTokenOut = address(this).balance;\n        }\n\n        if (fromToken != NATIVE_TOKEN_ADDRESS) {\n            ERC20 token = ERC20(fromToken);\n            token.safeTransferFrom(msg.sender, socketGateway, amount);\n            token.safeApprove(rainbowSwapAggregator, amount);\n\n            // solhint-disable-next-line\n            (bool success, ) = rainbowSwapAggregator.call(swapCallData);\n\n            if (!success) {\n                revert SwapFailed();\n            }\n\n            token.safeApprove(rainbowSwapAggregator, 0);\n        } else {\n            (bool success, ) = rainbowSwapAggregator.call{value: amount}(\n                swapCallData\n            );\n            if (!success) {\n                revert SwapFailed();\n            }\n        }\n\n        if (toToken != NATIVE_TOKEN_ADDRESS) {\n            _finalBalanceTokenOut = toTokenERC20.balanceOf(socketGateway);\n        } else {\n            _finalBalanceTokenOut = address(this).balance;\n        }\n\n        uint256 returnAmount = _finalBalanceTokenOut - _initialBalanceTokenOut;\n\n        if (toToken == NATIVE_TOKEN_ADDRESS) {\n            payable(receiverAddress).transfer(returnAmount);\n        } else {\n            toTokenERC20.transfer(receiverAddress, returnAmount);\n        }\n\n        emit SocketSwapTokens(\n            fromToken,\n            toToken,\n            returnAmount,\n            amount,\n            RainbowIdentifier,\n            receiverAddress\n        );\n\n        return returnAmount;\n    }\n\n    /**\n     * @notice function to swapWithIn SocketGateway - swaps tokens on the chain to socketGateway as recipient\n     * @param fromToken token to be swapped\n     * @param toToken token to which fromToken has to be swapped\n     * @param amount amount of fromToken being swapped\n     * @param swapExtraData encoded value of properties in the swapData Struct\n     * @return swapped amount (in toToken Address)\n     */\n    function performActionWithIn(\n        address fromToken,\n        address toToken,\n        uint256 amount,\n        bytes calldata swapExtraData\n    ) external payable override returns (uint256, address) {\n        if (fromToken == address(0)) {\n            revert Address0Provided();\n        }\n\n        bytes memory swapCallData = abi.decode(swapExtraData, (bytes));\n\n        uint256 _initialBalanceTokenOut;\n        uint256 _finalBalanceTokenOut;\n\n        ERC20 toTokenERC20 = ERC20(toToken);\n        if (toToken != NATIVE_TOKEN_ADDRESS) {\n            _initialBalanceTokenOut = toTokenERC20.balanceOf(socketGateway);\n        } else {\n            _initialBalanceTokenOut = address(this).balance;\n        }\n\n        if (fromToken != NATIVE_TOKEN_ADDRESS) {\n            ERC20 token = ERC20(fromToken);\n            token.safeTransferFrom(msg.sender, socketGateway, amount);\n            token.safeApprove(rainbowSwapAggregator, amount);\n\n            // solhint-disable-next-line\n            (bool success, ) = rainbowSwapAggregator.call(swapCallData);\n\n            if (!success) {\n                revert SwapFailed();\n            }\n\n            token.safeApprove(rainbowSwapAggregator, 0);\n        } else {\n            (bool success, ) = rainbowSwapAggregator.call{value: amount}(\n                swapCallData\n            );\n            if (!success) {\n                revert SwapFailed();\n            }\n        }\n\n        if (toToken != NATIVE_TOKEN_ADDRESS) {\n            _finalBalanceTokenOut = toTokenERC20.balanceOf(socketGateway);\n        } else {\n            _finalBalanceTokenOut = address(this).balance;\n        }\n\n        uint256 returnAmount = _finalBalanceTokenOut - _initialBalanceTokenOut;\n\n        emit SocketSwapTokens(\n            fromToken,\n            toToken,\n            returnAmount,\n            amount,\n            RainbowIdentifier,\n            socketGateway\n        );\n\n        return (returnAmount, toToken);\n    }\n}\n"},"src/interfaces/ISocketBridgeBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface ISocketBridgeBase {\n    function killme() external;\n}\n"},"src/interfaces/ISocketRequest.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ISocketRoute\n * @notice Interface with Request DataStructures to invoke controller functions.\n * @author Socket dot tech.\n */\ninterface ISocketRequest {\n    struct SwapMultiBridgeRequest {\n        uint32 swapRouteId;\n        bytes swapImplData;\n        uint32[] bridgeRouteIds;\n        bytes[] bridgeImplDataItems;\n        uint256[] bridgeRatios;\n        bytes[] eventDataItems;\n    }\n\n    // Datastructure for Refuel-Swap-Bridge function\n    struct RefuelSwapBridgeRequest {\n        uint32 refuelRouteId;\n        bytes refuelData;\n        uint32 swapRouteId;\n        bytes swapData;\n        uint32 bridgeRouteId;\n        bytes bridgeData;\n    }\n\n    // Datastructure for DeductFees-Swap function\n    struct FeesTakerSwapRequest {\n        address feesTakerAddress;\n        address feesToken;\n        uint256 feesAmount;\n        uint32 routeId;\n        bytes swapRequestData;\n    }\n\n    // Datastructure for DeductFees-Bridge function\n    struct FeesTakerBridgeRequest {\n        address feesTakerAddress;\n        address feesToken;\n        uint256 feesAmount;\n        uint32 routeId;\n        bytes bridgeRequestData;\n    }\n\n    // Datastructure for DeductFees-MultiBridge function\n    struct FeesTakerMultiBridgeRequest {\n        address feesTakerAddress;\n        address feesToken;\n        uint256 feesAmount;\n        uint32[] bridgeRouteIds;\n        bytes[] bridgeRequestDataItems;\n    }\n\n    // Datastructure for DeductFees-Swap-Bridge function\n    struct FeesTakerSwapBridgeRequest {\n        address feesTakerAddress;\n        address feesToken;\n        uint256 feesAmount;\n        uint32 swapRouteId;\n        bytes swapData;\n        uint32 bridgeRouteId;\n        bytes bridgeData;\n    }\n\n    // Datastructure for DeductFees-Refuel-Swap-Bridge function\n    struct FeesTakerRefuelSwapBridgeRequest {\n        address feesTakerAddress;\n        address feesToken;\n        uint256 feesAmount;\n        uint32 refuelRouteId;\n        bytes refuelData;\n        uint32 swapRouteId;\n        bytes swapData;\n        uint32 bridgeRouteId;\n        bytes bridgeData;\n    }\n}\n"},"src/utils/Ownable.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport {OnlyOwner, OnlyNominee} from \"../errors/SocketErrors.sol\";\n\nabstract contract Ownable {\n    address private _owner;\n    address private _nominee;\n\n    event OwnerNominated(address indexed nominee);\n    event OwnerClaimed(address indexed claimer);\n\n    constructor(address owner_) {\n        _claimOwner(owner_);\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != _owner) {\n            revert OnlyOwner();\n        }\n        _;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function nominee() public view returns (address) {\n        return _nominee;\n    }\n\n    function nominateOwner(address nominee_) external {\n        if (msg.sender != _owner) {\n            revert OnlyOwner();\n        }\n        _nominee = nominee_;\n        emit OwnerNominated(_nominee);\n    }\n\n    function claimOwner() external {\n        if (msg.sender != _nominee) {\n            revert OnlyNominee();\n        }\n        _claimOwner(msg.sender);\n    }\n\n    function _claimOwner(address claimer_) internal {\n        _owner = claimer_;\n        _nominee = address(0);\n        emit OwnerClaimed(claimer_);\n    }\n}\n"},"lib/solmate/src/tokens/ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"},"src/controllers/RefuelSwapAndBridgeController.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {ISocketRequest} from \"../interfaces/ISocketRequest.sol\";\nimport {ISocketRoute} from \"../interfaces/ISocketRoute.sol\";\nimport {BaseController} from \"./BaseController.sol\";\n\n/**\n * @title RefuelSwapAndBridge Controller Implementation\n * @notice Controller with composed actions for Refuel,Swap and Bridge to be executed Sequentially and this is atomic\n * @author Socket dot tech.\n */\ncontract RefuelSwapAndBridgeController is BaseController {\n    /// @notice Function-selector to invoke refuel-swap-bridge function\n    /// @dev This function selector is to be used while buidling transaction-data\n    bytes4 public immutable REFUEL_SWAP_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"refuelAndSwapAndBridge((uint32,bytes,uint32,bytes,uint32,bytes))\"\n            )\n        );\n\n    /// @notice socketGatewayAddress to be initialised via storage variable BaseController\n    constructor(\n        address _socketGatewayAddress\n    ) BaseController(_socketGatewayAddress) {}\n\n    /**\n     * @notice function to handle refuel followed by Swap and Bridge actions\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param rsbRequest Request with data to execute refuel followed by swap and bridge\n     * @return output data from bridging operation\n     */\n    function refuelAndSwapAndBridge(\n        ISocketRequest.RefuelSwapBridgeRequest calldata rsbRequest\n    ) public payable returns (bytes memory) {\n        _executeRoute(rsbRequest.refuelRouteId, rsbRequest.refuelData);\n\n        // refuel is also a bridging activity via refuel-route-implementation\n        bytes memory swapResponseData = _executeRoute(\n            rsbRequest.swapRouteId,\n            rsbRequest.swapData\n        );\n\n        uint256 swapAmount = abi.decode(swapResponseData, (uint256));\n\n        //sequence of arguments for implData: amount, token, data\n        // Bridging the swapAmount received in the preceeding step\n        bytes memory bridgeImpldata = abi.encodeWithSelector(\n            BRIDGE_AFTER_SWAP_SELECTOR,\n            swapAmount,\n            rsbRequest.bridgeData\n        );\n\n        return _executeRoute(rsbRequest.bridgeRouteId, bridgeImpldata);\n    }\n}\n"},"src/interfaces/ISocketGateway.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ISocketGateway\n * @notice Interface for SocketGateway functions.\n * @dev functions can be added here for invocation from external contracts or off-chain\n * @author Socket dot tech.\n */\ninterface ISocketGateway {\n    /**\n     * @notice Request-struct for controllerRequests\n     * @dev ensure the value for data is generated using the function-selectors defined in the controllerImplementation contracts\n     */\n    struct SocketControllerRequest {\n        // controllerId is the id mapped to the controllerAddress\n        uint32 controllerId;\n        // transactionImplData generated off-chain or by caller using function-selector of the controllerContract\n        bytes data;\n    }\n\n    // @notice view to get owner-address\n    function owner() external view returns (address);\n}\n"},"src/libraries/Pb.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.4;\n\n// runtime proto sol library\nlibrary Pb {\n    enum WireType {\n        Varint,\n        Fixed64,\n        LengthDelim,\n        StartGroup,\n        EndGroup,\n        Fixed32\n    }\n\n    struct Buffer {\n        uint256 idx; // the start index of next read. when idx=b.length, we're done\n        bytes b; // hold serialized proto msg, readonly\n    }\n\n    // create a new in-memory Buffer object from raw msg bytes\n    function fromBytes(\n        bytes memory raw\n    ) internal pure returns (Buffer memory buf) {\n        buf.b = raw;\n        buf.idx = 0;\n    }\n\n    // whether there are unread bytes\n    function hasMore(Buffer memory buf) internal pure returns (bool) {\n        return buf.idx < buf.b.length;\n    }\n\n    // decode current field number and wiretype\n    function decKey(\n        Buffer memory buf\n    ) internal pure returns (uint256 tag, WireType wiretype) {\n        uint256 v = decVarint(buf);\n        tag = v / 8;\n        wiretype = WireType(v & 7);\n    }\n\n    // read varint from current buf idx, move buf.idx to next read, return the int value\n    function decVarint(Buffer memory buf) internal pure returns (uint256 v) {\n        bytes10 tmp; // proto int is at most 10 bytes (7 bits can be used per byte)\n        bytes memory bb = buf.b; // get buf.b mem addr to use in assembly\n        v = buf.idx; // use v to save one additional uint variable\n        assembly {\n            tmp := mload(add(add(bb, 32), v)) // load 10 bytes from buf.b[buf.idx] to tmp\n        }\n        uint256 b; // store current byte content\n        v = 0; // reset to 0 for return value\n        for (uint256 i = 0; i < 10; i++) {\n            assembly {\n                b := byte(i, tmp) // don't use tmp[i] because it does bound check and costs extra\n            }\n            v |= (b & 0x7F) << (i * 7);\n            if (b & 0x80 == 0) {\n                buf.idx += i + 1;\n                return v;\n            }\n        }\n        revert(); // i=10, invalid varint stream\n    }\n\n    // read length delimited field and return bytes\n    function decBytes(\n        Buffer memory buf\n    ) internal pure returns (bytes memory b) {\n        uint256 len = decVarint(buf);\n        uint256 end = buf.idx + len;\n        require(end <= buf.b.length); // avoid overflow\n        b = new bytes(len);\n        bytes memory bufB = buf.b; // get buf.b mem addr to use in assembly\n        uint256 bStart;\n        uint256 bufBStart = buf.idx;\n        assembly {\n            bStart := add(b, 32)\n            bufBStart := add(add(bufB, 32), bufBStart)\n        }\n        for (uint256 i = 0; i < len; i += 32) {\n            assembly {\n                mstore(add(bStart, i), mload(add(bufBStart, i)))\n            }\n        }\n        buf.idx = end;\n    }\n\n    // move idx pass current value field, to beginning of next tag or msg end\n    function skipValue(Buffer memory buf, WireType wire) internal pure {\n        if (wire == WireType.Varint) {\n            decVarint(buf);\n        } else if (wire == WireType.LengthDelim) {\n            uint256 len = decVarint(buf);\n            buf.idx += len; // skip len bytes value data\n            require(buf.idx <= buf.b.length); // avoid overflow\n        } else {\n            revert();\n        } // unsupported wiretype\n    }\n\n    function _uint256(bytes memory b) internal pure returns (uint256 v) {\n        require(b.length <= 32); // b's length must be smaller than or equal to 32\n        assembly {\n            v := mload(add(b, 32))\n        } // load all 32bytes to v\n        v = v >> (8 * (32 - b.length)); // only first b.length is valid\n    }\n\n    function _address(bytes memory b) internal pure returns (address v) {\n        v = _addressPayable(b);\n    }\n\n    function _addressPayable(\n        bytes memory b\n    ) internal pure returns (address payable v) {\n        require(b.length == 20);\n        //load 32bytes then shift right 12 bytes\n        assembly {\n            v := div(mload(add(b, 32)), 0x1000000000000000000000000)\n        }\n    }\n\n    function _bytes32(bytes memory b) internal pure returns (bytes32 v) {\n        require(b.length == 32);\n        assembly {\n            v := mload(add(b, 32))\n        }\n    }\n}\n"},"src/bridges/BridgeImplBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {ISocketGateway} from \"../interfaces/ISocketGateway.sol\";\nimport {ISocketRoute} from \"../interfaces/ISocketRoute.sol\";\nimport {OnlySocketGatewayOwner, OnlySocketDeployer} from \"../errors/SocketErrors.sol\";\n\n/**\n * @title Abstract Implementation Contract.\n * @notice All Bridge Implementation will follow this interface.\n */\nabstract contract BridgeImplBase {\n    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens\n    using SafeTransferLib for ERC20;\n\n    /// @notice Address used to identify if it is a native token transfer or not\n    address public immutable NATIVE_TOKEN_ADDRESS =\n        address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    /// @notice immutable variable to store the socketGateway address\n    address public immutable socketGateway;\n\n    /// @notice immutable variable to store the socketGateway address\n    address public immutable socketDeployFactory;\n\n    /// @notice immutable variable with instance of SocketRoute to access route functions\n    ISocketRoute public immutable socketRoute;\n\n    /// @notice FunctionSelector used to delegatecall from swap to the function of bridge router implementation\n    bytes4 public immutable BRIDGE_AFTER_SWAP_SELECTOR =\n        bytes4(keccak256(\"bridgeAfterSwap(uint256,bytes)\"));\n\n    /****************************************\n     *               EVENTS                 *\n     ****************************************/\n\n    event SocketBridge(\n        uint256 amount,\n        address token,\n        uint256 toChainId,\n        bytes32 bridgeName,\n        address sender,\n        address receiver,\n        bytes32 metadata\n    );\n\n    /**\n     * @notice Construct the base for all BridgeImplementations.\n     * @param _socketGateway Socketgateway address, an immutable variable to set.\n     * @param _socketDeployFactory Socket Deploy Factory address, an immutable variable to set.\n     */\n    constructor(address _socketGateway, address _socketDeployFactory) {\n        socketGateway = _socketGateway;\n        socketDeployFactory = _socketDeployFactory;\n        socketRoute = ISocketRoute(_socketGateway);\n    }\n\n    /****************************************\n     *               MODIFIERS              *\n     ****************************************/\n\n    /// @notice Implementing contract needs to make use of the modifier where restricted access is to be used\n    modifier isSocketGatewayOwner() {\n        if (msg.sender != ISocketGateway(socketGateway).owner()) {\n            revert OnlySocketGatewayOwner();\n        }\n        _;\n    }\n\n    /// @notice Implementing contract needs to make use of the modifier where restricted access is to be used\n    modifier isSocketDeployFactory() {\n        if (msg.sender != socketDeployFactory) {\n            revert OnlySocketDeployer();\n        }\n        _;\n    }\n\n    /****************************************\n     *    RESTRICTED FUNCTIONS              *\n     ****************************************/\n\n    /**\n     * @notice function to rescue the ERC20 tokens in the bridge Implementation contract\n     * @notice this is a function restricted to Owner of SocketGateway only\n     * @param token address of ERC20 token being rescued\n     * @param userAddress receipient address to which ERC20 tokens will be rescued to\n     * @param amount amount of ERC20 tokens being rescued\n     */\n    function rescueFunds(\n        address token,\n        address userAddress,\n        uint256 amount\n    ) external isSocketGatewayOwner {\n        ERC20(token).safeTransfer(userAddress, amount);\n    }\n\n    /**\n     * @notice function to rescue the native-balance in the bridge Implementation contract\n     * @notice this is a function restricted to Owner of SocketGateway only\n     * @param userAddress receipient address to which native-balance will be rescued to\n     * @param amount amount of native balance tokens being rescued\n     */\n    function rescueEther(\n        address payable userAddress,\n        uint256 amount\n    ) external isSocketGatewayOwner {\n        userAddress.transfer(amount);\n    }\n\n    function killme() external isSocketDeployFactory {\n        selfdestruct(payable(msg.sender));\n    }\n\n    /******************************\n     *    VIRTUAL FUNCTIONS       *\n     *****************************/\n\n    /**\n     * @notice function to bridge which is succeeding the swap function\n     * @notice this function is to be used only when bridging as a succeeding step\n     * @notice All bridge implementation contracts must implement this function\n     * @notice bridge-implementations will have a bridge specific struct with properties used in bridging\n     * @param bridgeData encoded value of properties in the bridgeData Struct\n     */\n    function bridgeAfterSwap(\n        uint256 amount,\n        bytes calldata bridgeData\n    ) external payable virtual;\n}\n"},"src/bridges/cbridge/CelerImpl.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../libraries/Pb.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport \"./interfaces/cbridge.sol\";\nimport \"./interfaces/ICelerStorageWrapper.sol\";\nimport {TransferIdExists, InvalidCelerRefund, CelerAlreadyRefunded, CelerRefundNotReady} from \"../../errors/SocketErrors.sol\";\nimport {BridgeImplBase} from \"../BridgeImplBase.sol\";\nimport {CBRIDGE} from \"../../static/RouteIdentifiers.sol\";\n\n/**\n * @title Celer-Route Implementation\n * @notice Route implementation with functions to bridge ERC20 and Native via Celer-Bridge\n * Called via SocketGateway if the routeId in the request maps to the routeId of CelerImplementation\n * Contains function to handle bridging as post-step i.e linked to a preceeding step for swap\n * RequestData is different to just bride and bridging chained with swap\n * @author Socket dot tech.\n */\ncontract CelerImpl is BridgeImplBase {\n    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens\n    using SafeTransferLib for ERC20;\n\n    bytes32 public immutable CBridgeIdentifier = CBRIDGE;\n\n    /// @notice Utility to perform operation on Buffer\n    using Pb for Pb.Buffer;\n\n    /// @notice Function-selector for ERC20-token bridging on Celer-Route\n    /// @dev This function selector is to be used while building transaction-data to bridge ERC20 tokens\n    bytes4 public immutable CELER_ERC20_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeERC20To(address,address,uint256,bytes32,uint64,uint64,uint32)\"\n            )\n        );\n\n    /// @notice Function-selector for Native bridging on Celer-Route\n    /// @dev This function selector is to be used while building transaction-data to bridge Native tokens\n    bytes4 public immutable CELER_NATIVE_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeNativeTo(address,uint256,bytes32,uint64,uint64,uint32)\"\n            )\n        );\n\n    bytes4 public immutable CELER_SWAP_BRIDGE_SELECTOR =\n        bytes4(\n            keccak256(\n                \"swapAndBridge(uint32,bytes,(address,uint64,uint32,uint64,bytes32))\"\n            )\n        );\n\n    /// @notice router Contract instance used to deposit ERC20 and Native on to Celer-Bridge\n    /// @dev contract instance is to be initialized in the constructor using the routerAddress passed as constructor argument\n    ICBridge public immutable router;\n\n    /// @notice celerStorageWrapper Contract instance used to store the transferId generated during ERC20 and Native bridge on to Celer-Bridge\n    /// @dev contract instance is to be initialized in the constructor using the celerStorageWrapperAddress passed as constructor argument\n    ICelerStorageWrapper public immutable celerStorageWrapper;\n\n    /// @notice WETH token address\n    address public immutable weth;\n\n    /// @notice chainId used during generation of transferId generated while bridging ERC20 and Native on to Celer-Bridge\n    /// @dev this is to be initialised in the constructor\n    uint64 public immutable chainId;\n\n    struct WithdrawMsg {\n        uint64 chainid; // tag: 1\n        uint64 seqnum; // tag: 2\n        address receiver; // tag: 3\n        address token; // tag: 4\n        uint256 amount; // tag: 5\n        bytes32 refid; // tag: 6\n    }\n\n    /// @notice socketGatewayAddress to be initialised via storage variable BridgeImplBase\n    /// @dev ensure routerAddress, weth-address, celerStorageWrapperAddress are set properly for the chainId in which the contract is being deployed\n    constructor(\n        address _routerAddress,\n        address _weth,\n        address _celerStorageWrapperAddress,\n        address _socketGateway,\n        address _socketDeployFactory\n    ) BridgeImplBase(_socketGateway, _socketDeployFactory) {\n        router = ICBridge(_routerAddress);\n        celerStorageWrapper = ICelerStorageWrapper(_celerStorageWrapperAddress);\n        weth = _weth;\n        chainId = uint64(block.chainid);\n    }\n\n    // Function to receive Ether. msg.data must be empty\n    receive() external payable {}\n\n    /// @notice Struct to be used in decode step from input parameter - a specific case of bridging after swap.\n    /// @dev the data being encoded in offchain or by caller should have values set in this sequence of properties in this struct\n    struct CelerBridgeDataNoToken {\n        address receiverAddress;\n        uint64 toChainId;\n        uint32 maxSlippage;\n        uint64 nonce;\n        bytes32 metadata;\n    }\n\n    struct CelerBridgeData {\n        address token;\n        address receiverAddress;\n        uint64 toChainId;\n        uint32 maxSlippage;\n        uint64 nonce;\n        bytes32 metadata;\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from swapAndBridge, this function is called when the swap has already happened at a different place.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in CelerBridgeData struct\n     * @param amount amount of tokens being bridged. this can be ERC20 or native\n     * @param bridgeData encoded data for CelerBridge\n     */\n    function bridgeAfterSwap(\n        uint256 amount,\n        bytes calldata bridgeData\n    ) external payable override {\n        CelerBridgeData memory celerBridgeData = abi.decode(\n            bridgeData,\n            (CelerBridgeData)\n        );\n\n        if (celerBridgeData.token == NATIVE_TOKEN_ADDRESS) {\n            // transferId is generated using the request-params and nonce of the account\n            // transferId should be unique for each request and this is used while handling refund from celerBridge\n            bytes32 transferId = keccak256(\n                abi.encodePacked(\n                    address(this),\n                    celerBridgeData.receiverAddress,\n                    weth,\n                    amount,\n                    celerBridgeData.toChainId,\n                    celerBridgeData.nonce,\n                    chainId\n                )\n            );\n\n            // transferId is stored in CelerStorageWrapper with in a mapping where key is transferId and value is the msg-sender\n            celerStorageWrapper.setAddressForTransferId(transferId, msg.sender);\n\n            router.sendNative{value: amount}(\n                celerBridgeData.receiverAddress,\n                amount,\n                celerBridgeData.toChainId,\n                celerBridgeData.nonce,\n                celerBridgeData.maxSlippage\n            );\n        } else {\n            // transferId is generated using the request-params and nonce of the account\n            // transferId should be unique for each request and this is used while handling refund from celerBridge\n            bytes32 transferId = keccak256(\n                abi.encodePacked(\n                    address(this),\n                    celerBridgeData.receiverAddress,\n                    celerBridgeData.token,\n                    amount,\n                    celerBridgeData.toChainId,\n                    celerBridgeData.nonce,\n                    chainId\n                )\n            );\n\n            // transferId is stored in CelerStorageWrapper with in a mapping where key is transferId and value is the msg-sender\n            celerStorageWrapper.setAddressForTransferId(transferId, msg.sender);\n            router.send(\n                celerBridgeData.receiverAddress,\n                celerBridgeData.token,\n                amount,\n                celerBridgeData.toChainId,\n                celerBridgeData.nonce,\n                celerBridgeData.maxSlippage\n            );\n        }\n\n        emit SocketBridge(\n            amount,\n            celerBridgeData.token,\n            celerBridgeData.toChainId,\n            CBridgeIdentifier,\n            msg.sender,\n            celerBridgeData.receiverAddress,\n            celerBridgeData.metadata\n        );\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from bridgeAfterSwap since this function holds the logic for swapping tokens too.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in CelerBridgeData struct\n     * @param swapId routeId for the swapImpl\n     * @param swapData encoded data for swap\n     * @param celerBridgeData encoded data for CelerBridgeData\n     */\n    function swapAndBridge(\n        uint32 swapId,\n        bytes calldata swapData,\n        CelerBridgeDataNoToken calldata celerBridgeData\n    ) external payable {\n        (bool success, bytes memory result) = socketRoute\n            .getRoute(swapId)\n            .delegatecall(swapData);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        (uint256 bridgeAmount, address token) = abi.decode(\n            result,\n            (uint256, address)\n        );\n\n        if (token == NATIVE_TOKEN_ADDRESS) {\n            // transferId is generated using the request-params and nonce of the account\n            // transferId should be unique for each request and this is used while handling refund from celerBridge\n            bytes32 transferId = keccak256(\n                abi.encodePacked(\n                    address(this),\n                    celerBridgeData.receiverAddress,\n                    weth,\n                    bridgeAmount,\n                    celerBridgeData.toChainId,\n                    celerBridgeData.nonce,\n                    chainId\n                )\n            );\n\n            // transferId is stored in CelerStorageWrapper with in a mapping where key is transferId and value is the msg-sender\n            celerStorageWrapper.setAddressForTransferId(transferId, msg.sender);\n\n            router.sendNative{value: bridgeAmount}(\n                celerBridgeData.receiverAddress,\n                bridgeAmount,\n                celerBridgeData.toChainId,\n                celerBridgeData.nonce,\n                celerBridgeData.maxSlippage\n            );\n        } else {\n            // transferId is generated using the request-params and nonce of the account\n            // transferId should be unique for each request and this is used while handling refund from celerBridge\n            bytes32 transferId = keccak256(\n                abi.encodePacked(\n                    address(this),\n                    celerBridgeData.receiverAddress,\n                    token,\n                    bridgeAmount,\n                    celerBridgeData.toChainId,\n                    celerBridgeData.nonce,\n                    chainId\n                )\n            );\n\n            // transferId is stored in CelerStorageWrapper with in a mapping where key is transferId and value is the msg-sender\n            celerStorageWrapper.setAddressForTransferId(transferId, msg.sender);\n            router.send(\n                celerBridgeData.receiverAddress,\n                token,\n                bridgeAmount,\n                celerBridgeData.toChainId,\n                celerBridgeData.nonce,\n                celerBridgeData.maxSlippage\n            );\n        }\n\n        emit SocketBridge(\n            bridgeAmount,\n            token,\n            celerBridgeData.toChainId,\n            CBridgeIdentifier,\n            msg.sender,\n            celerBridgeData.receiverAddress,\n            celerBridgeData.metadata\n        );\n    }\n\n    /**\n     * @notice function to handle ERC20 bridging to receipent via Celer-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param receiverAddress address of recipient\n     * @param token address of token being bridged\n     * @param amount amount of token for bridging\n     * @param toChainId destination ChainId\n     * @param nonce nonce of the sender-account address\n     * @param maxSlippage maximum Slippage for the bridging\n     */\n    function bridgeERC20To(\n        address receiverAddress,\n        address token,\n        uint256 amount,\n        bytes32 metadata,\n        uint64 toChainId,\n        uint64 nonce,\n        uint32 maxSlippage\n    ) external payable {\n        /// @notice transferId is generated using the request-params and nonce of the account\n        /// @notice transferId should be unique for each request and this is used while handling refund from celerBridge\n        bytes32 transferId = keccak256(\n            abi.encodePacked(\n                address(this),\n                receiverAddress,\n                token,\n                amount,\n                toChainId,\n                nonce,\n                chainId\n            )\n        );\n\n        /// @notice stored in the CelerStorageWrapper contract\n        celerStorageWrapper.setAddressForTransferId(transferId, msg.sender);\n\n        ERC20 tokenInstance = ERC20(token);\n        tokenInstance.safeTransferFrom(msg.sender, socketGateway, amount);\n        router.send(\n            receiverAddress,\n            token,\n            amount,\n            toChainId,\n            nonce,\n            maxSlippage\n        );\n\n        emit SocketBridge(\n            amount,\n            token,\n            toChainId,\n            CBridgeIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n\n    /**\n     * @notice function to handle Native bridging to receipent via Celer-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param receiverAddress address of recipient\n     * @param amount amount of token for bridging\n     * @param toChainId destination ChainId\n     * @param nonce nonce of the sender-account address\n     * @param maxSlippage maximum Slippage for the bridging\n     */\n    function bridgeNativeTo(\n        address receiverAddress,\n        uint256 amount,\n        bytes32 metadata,\n        uint64 toChainId,\n        uint64 nonce,\n        uint32 maxSlippage\n    ) external payable {\n        bytes32 transferId = keccak256(\n            abi.encodePacked(\n                address(this),\n                receiverAddress,\n                weth,\n                amount,\n                toChainId,\n                nonce,\n                chainId\n            )\n        );\n\n        celerStorageWrapper.setAddressForTransferId(transferId, msg.sender);\n\n        router.sendNative{value: amount}(\n            receiverAddress,\n            amount,\n            toChainId,\n            nonce,\n            maxSlippage\n        );\n\n        emit SocketBridge(\n            amount,\n            NATIVE_TOKEN_ADDRESS,\n            toChainId,\n            CBridgeIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n\n    /**\n     * @notice function to handle refund from CelerBridge-Router\n     * @param _request request data generated offchain using the celer-SDK\n     * @param _sigs generated offchain using the celer-SDK\n     * @param _signers  generated offchain using the celer-SDK\n     * @param _powers generated offchain using the celer-SDK\n     */\n    function refundCelerUser(\n        bytes calldata _request,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external payable {\n        WithdrawMsg memory request = decWithdrawMsg(_request);\n        bytes32 transferId = keccak256(\n            abi.encodePacked(\n                request.chainid,\n                request.seqnum,\n                request.receiver,\n                request.token,\n                request.amount\n            )\n        );\n        uint256 _initialNativeBalance = address(this).balance;\n        uint256 _initialTokenBalance = ERC20(request.token).balanceOf(\n            address(this)\n        );\n        if (!router.withdraws(transferId)) {\n            router.withdraw(_request, _sigs, _signers, _powers);\n        }\n\n        if (request.receiver != socketGateway) {\n            revert InvalidCelerRefund();\n        }\n\n        address _receiver = celerStorageWrapper.getAddressFromTransferId(\n            request.refid\n        );\n        celerStorageWrapper.deleteTransferId(request.refid);\n\n        if (_receiver == address(0)) {\n            revert CelerAlreadyRefunded();\n        }\n\n        uint256 _nativeBalanceAfter = address(this).balance;\n        uint256 _tokenBalanceAfter = ERC20(request.token).balanceOf(\n            address(this)\n        );\n        if (_nativeBalanceAfter > _initialNativeBalance) {\n            if ((_nativeBalanceAfter - _initialNativeBalance) != request.amount)\n                revert CelerRefundNotReady();\n            payable(_receiver).transfer(request.amount);\n            return;\n        }\n\n        if (_tokenBalanceAfter > _initialTokenBalance) {\n            if ((_tokenBalanceAfter - _initialTokenBalance) != request.amount)\n                revert CelerRefundNotReady();\n            ERC20(request.token).safeTransfer(_receiver, request.amount);\n            return;\n        }\n\n        revert CelerRefundNotReady();\n    }\n\n    function decWithdrawMsg(\n        bytes memory raw\n    ) internal pure returns (WithdrawMsg memory m) {\n        Pb.Buffer memory buf = Pb.fromBytes(raw);\n\n        uint256 tag;\n        Pb.WireType wire;\n        while (buf.hasMore()) {\n            (tag, wire) = buf.decKey();\n            if (false) {}\n            // solidity has no switch/case\n            else if (tag == 1) {\n                m.chainid = uint64(buf.decVarint());\n            } else if (tag == 2) {\n                m.seqnum = uint64(buf.decVarint());\n            } else if (tag == 3) {\n                m.receiver = Pb._address(buf.decBytes());\n            } else if (tag == 4) {\n                m.token = Pb._address(buf.decBytes());\n            } else if (tag == 5) {\n                m.amount = Pb._uint256(buf.decBytes());\n            } else if (tag == 6) {\n                m.refid = Pb._bytes32(buf.decBytes());\n            } else {\n                buf.skipValue(wire);\n            } // skip value of unknown tag\n        }\n    } // end decoder WithdrawMsg\n}\n"},"src/libraries/LibBytes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// Functions taken out from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\nlibrary LibBytes {\n    // solhint-disable no-inline-assembly\n\n    // LibBytes specific errors\n    error SliceOverflow();\n    error SliceOutOfBounds();\n    error AddressOutOfBounds();\n    error UintOutOfBounds();\n\n    // -------------------------\n\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    ) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        if (_length + 31 < _length) {\n            revert SliceOverflow();\n        }\n        if (_bytes.length < _start + _length) {\n            revert SliceOutOfBounds();\n        }\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(\n                    add(tempBytes, lengthmod),\n                    mul(0x20, iszero(lengthmod))\n                )\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(\n                        add(\n                            add(_bytes, lengthmod),\n                            mul(0x20, iszero(lengthmod))\n                        ),\n                        _start\n                    )\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n"},"src/bridges/hyphen/interfaces/hyphen.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.0;\n\n/**\n * @title HyphenLiquidityPoolManager\n * @notice interface with functions to bridge ERC20 and Native via Hyphen-Bridge\n * @author Socket dot tech.\n */\ninterface HyphenLiquidityPoolManager {\n    /**\n     * @dev Function used to deposit tokens into pool to initiate a cross chain token transfer.\n     * @param toChainId Chain id where funds needs to be transfered\n     * @param tokenAddress ERC20 Token address that needs to be transfered\n     * @param receiver Address on toChainId where tokens needs to be transfered\n     * @param amount Amount of token being transfered\n     */\n    function depositErc20(\n        uint256 toChainId,\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        string calldata tag\n    ) external;\n\n    /**\n     * @dev Function used to deposit native token into pool to initiate a cross chain token transfer.\n     * @param receiver Address on toChainId where tokens needs to be transfered\n     * @param toChainId Chain id where funds needs to be transfered\n     */\n    function depositNative(\n        address receiver,\n        uint256 toChainId,\n        string calldata tag\n    ) external payable;\n}\n"},"src/swap/SwapImplBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {ISocketGateway} from \"../interfaces/ISocketGateway.sol\";\nimport {OnlySocketGatewayOwner, OnlySocketDeployer} from \"../errors/SocketErrors.sol\";\n\n/**\n * @title Abstract Implementation Contract.\n * @notice All Swap Implementation will follow this interface.\n * @author Socket dot tech.\n */\nabstract contract SwapImplBase {\n    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens\n    using SafeTransferLib for ERC20;\n\n    /// @notice Address used to identify if it is a native token transfer or not\n    address public immutable NATIVE_TOKEN_ADDRESS =\n        address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    /// @notice immutable variable to store the socketGateway address\n    address public immutable socketGateway;\n\n    /// @notice immutable variable to store the socketGateway address\n    address public immutable socketDeployFactory;\n\n    /// @notice FunctionSelector used to delegatecall to the performAction function of swap-router-implementation\n    bytes4 public immutable SWAP_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\"performAction(address,address,uint256,address,bytes)\")\n        );\n\n    /// @notice FunctionSelector used to delegatecall to the performActionWithIn function of swap-router-implementation\n    bytes4 public immutable SWAP_WITHIN_FUNCTION_SELECTOR =\n        bytes4(keccak256(\"performActionWithIn(address,address,uint256,bytes)\"));\n\n    /****************************************\n     *               EVENTS                 *\n     ****************************************/\n\n    event SocketSwapTokens(\n        address fromToken,\n        address toToken,\n        uint256 buyAmount,\n        uint256 sellAmount,\n        bytes32 routeName,\n        address receiver\n    );\n\n    /**\n     * @notice Construct the base for all SwapImplementations.\n     * @param _socketGateway Socketgateway address, an immutable variable to set.\n     */\n    constructor(address _socketGateway, address _socketDeployFactory) {\n        socketGateway = _socketGateway;\n        socketDeployFactory = _socketDeployFactory;\n    }\n\n    /****************************************\n     *               MODIFIERS              *\n     ****************************************/\n\n    /// @notice Implementing contract needs to make use of the modifier where restricted access is to be used\n    modifier isSocketGatewayOwner() {\n        if (msg.sender != ISocketGateway(socketGateway).owner()) {\n            revert OnlySocketGatewayOwner();\n        }\n        _;\n    }\n\n    /// @notice Implementing contract needs to make use of the modifier where restricted access is to be used\n    modifier isSocketDeployFactory() {\n        if (msg.sender != socketDeployFactory) {\n            revert OnlySocketDeployer();\n        }\n        _;\n    }\n\n    /****************************************\n     *    RESTRICTED FUNCTIONS              *\n     ****************************************/\n\n    /**\n     * @notice function to rescue the ERC20 tokens in the Swap-Implementation contract\n     * @notice this is a function restricted to Owner of SocketGateway only\n     * @param token address of ERC20 token being rescued\n     * @param userAddress receipient address to which ERC20 tokens will be rescued to\n     * @param amount amount of ERC20 tokens being rescued\n     */\n    function rescueFunds(\n        address token,\n        address userAddress,\n        uint256 amount\n    ) external isSocketGatewayOwner {\n        ERC20(token).safeTransfer(userAddress, amount);\n    }\n\n    /**\n     * @notice function to rescue the native-balance in the  Swap-Implementation contract\n     * @notice this is a function restricted to Owner of SocketGateway only\n     * @param userAddress receipient address to which native-balance will be rescued to\n     * @param amount amount of native balance tokens being rescued\n     */\n    function rescueEther(\n        address payable userAddress,\n        uint256 amount\n    ) external isSocketGatewayOwner {\n        userAddress.transfer(amount);\n    }\n\n    function killme() external isSocketDeployFactory {\n        selfdestruct(payable(msg.sender));\n    }\n\n    /******************************\n     *    VIRTUAL FUNCTIONS       *\n     *****************************/\n\n    /**\n     * @notice function to swap tokens on the chain\n     *         All swap implementation contracts must implement this function\n     * @param fromToken token to be swapped\n     * @param  toToken token to which fromToken has to be swapped\n     * @param amount amount of fromToken being swapped\n     * @param receiverAddress recipient address of toToken\n     * @param data encoded value of properties in the swapData Struct\n     */\n    function performAction(\n        address fromToken,\n        address toToken,\n        uint256 amount,\n        address receiverAddress,\n        bytes memory data\n    ) external payable virtual returns (uint256);\n\n    /**\n     * @notice function to swapWith - swaps tokens on the chain to socketGateway as recipient\n     *         All swap implementation contracts must implement this function\n     * @param fromToken token to be swapped\n     * @param toToken token to which fromToken has to be swapped\n     * @param amount amount of fromToken being swapped\n     * @param swapExtraData encoded value of properties in the swapData Struct\n     */\n    function performActionWithIn(\n        address fromToken,\n        address toToken,\n        uint256 amount,\n        bytes memory swapExtraData\n    ) external payable virtual returns (uint256, address);\n}\n"},"src/swap/zerox/ZeroXSwapImpl.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport \"../SwapImplBase.sol\";\nimport {Address0Provided, SwapFailed} from \"../../errors/SocketErrors.sol\";\nimport {ZEROX} from \"../../static/RouteIdentifiers.sol\";\n\n/**\n * @title ZeroX-Swap-Route Implementation\n * @notice Route implementation with functions to swap tokens via ZeroX-Swap\n * Called via SocketGateway if the routeId in the request maps to the routeId of ZeroX-Swap-Implementation\n * @author Socket dot tech.\n */\ncontract ZeroXSwapImpl is SwapImplBase {\n    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens\n    using SafeTransferLib for ERC20;\n\n    bytes32 public immutable ZeroXIdentifier = ZEROX;\n\n    /// @notice unique name to identify the router, used to emit event upon successful bridging\n    bytes32 public immutable NAME = keccak256(\"Zerox-Router\");\n\n    /// @notice address of ZeroX-Exchange-Proxy to swap the tokens on Chain\n    address payable public immutable zeroXExchangeProxy;\n\n    /// @notice socketGatewayAddress to be initialised via storage variable SwapImplBase\n    /// @notice ZeroXExchangeProxy contract is payable to allow ethereum swaps\n    /// @dev ensure _zeroXExchangeProxy are set properly for the chainId in which the contract is being deployed\n    constructor(\n        address _zeroXExchangeProxy,\n        address _socketGateway,\n        address _socketDeployFactory\n    ) SwapImplBase(_socketGateway, _socketDeployFactory) {\n        zeroXExchangeProxy = payable(_zeroXExchangeProxy);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    /**\n     * @notice function to swap tokens on the chain and transfer to receiver address\n     * @dev This is called only when there is a request for a swap.\n     * @param fromToken token to be swapped\n     * @param toToken token to which fromToken is to be swapped\n     * @param amount amount to be swapped\n     * @param receiverAddress address of toToken recipient\n     * @param swapExtraData data required for zeroX Exchange to get the swap done\n     */\n    function performAction(\n        address fromToken,\n        address toToken,\n        uint256 amount,\n        address receiverAddress,\n        bytes calldata swapExtraData\n    ) external payable override returns (uint256) {\n        if (fromToken == address(0)) {\n            revert Address0Provided();\n        }\n\n        bytes memory swapCallData = abi.decode(swapExtraData, (bytes));\n\n        uint256 _initialBalanceTokenOut;\n        uint256 _finalBalanceTokenOut;\n\n        ERC20 erc20ToToken = ERC20(toToken);\n        if (toToken != NATIVE_TOKEN_ADDRESS) {\n            _initialBalanceTokenOut = erc20ToToken.balanceOf(address(this));\n        } else {\n            _initialBalanceTokenOut = address(this).balance;\n        }\n\n        if (fromToken != NATIVE_TOKEN_ADDRESS) {\n            ERC20 token = ERC20(fromToken);\n            token.safeTransferFrom(msg.sender, address(this), amount);\n            token.safeApprove(zeroXExchangeProxy, amount);\n\n            // solhint-disable-next-line\n            (bool success, ) = zeroXExchangeProxy.call(swapCallData);\n\n            if (!success) {\n                revert SwapFailed();\n            }\n\n            token.safeApprove(zeroXExchangeProxy, 0);\n        } else {\n            (bool success, ) = zeroXExchangeProxy.call{value: amount}(\n                swapCallData\n            );\n            if (!success) {\n                revert SwapFailed();\n            }\n        }\n\n        if (toToken != NATIVE_TOKEN_ADDRESS) {\n            _finalBalanceTokenOut = erc20ToToken.balanceOf(address(this));\n        } else {\n            _finalBalanceTokenOut = address(this).balance;\n        }\n\n        uint256 returnAmount = _finalBalanceTokenOut - _initialBalanceTokenOut;\n\n        if (toToken == NATIVE_TOKEN_ADDRESS) {\n            payable(receiverAddress).transfer(returnAmount);\n        } else {\n            erc20ToToken.transfer(receiverAddress, returnAmount);\n        }\n\n        emit SocketSwapTokens(\n            fromToken,\n            toToken,\n            returnAmount,\n            amount,\n            ZeroXIdentifier,\n            receiverAddress\n        );\n\n        return returnAmount;\n    }\n\n    /**\n     * @notice function to swapWithIn SocketGateway - swaps tokens on the chain to socketGateway as recipient\n     * @param fromToken token to be swapped\n     * @param toToken token to which fromToken has to be swapped\n     * @param amount amount of fromToken being swapped\n     * @param swapExtraData encoded value of properties in the swapData Struct\n     * @return swapped amount (in toToken Address)\n     */\n    function performActionWithIn(\n        address fromToken,\n        address toToken,\n        uint256 amount,\n        bytes calldata swapExtraData\n    ) external payable override returns (uint256, address) {\n        if (fromToken == address(0)) {\n            revert Address0Provided();\n        }\n\n        bytes memory swapCallData = abi.decode(swapExtraData, (bytes));\n\n        uint256 _initialBalanceTokenOut;\n        uint256 _finalBalanceTokenOut;\n\n        ERC20 erc20ToToken = ERC20(toToken);\n        if (toToken != NATIVE_TOKEN_ADDRESS) {\n            _initialBalanceTokenOut = erc20ToToken.balanceOf(address(this));\n        } else {\n            _initialBalanceTokenOut = address(this).balance;\n        }\n\n        if (fromToken != NATIVE_TOKEN_ADDRESS) {\n            ERC20 token = ERC20(fromToken);\n            token.safeTransferFrom(msg.sender, address(this), amount);\n            token.safeApprove(zeroXExchangeProxy, amount);\n\n            // solhint-disable-next-line\n            (bool success, ) = zeroXExchangeProxy.call(swapCallData);\n\n            if (!success) {\n                revert SwapFailed();\n            }\n\n            token.safeApprove(zeroXExchangeProxy, 0);\n        } else {\n            (bool success, ) = zeroXExchangeProxy.call{value: amount}(\n                swapCallData\n            );\n            if (!success) {\n                revert SwapFailed();\n            }\n        }\n\n        if (toToken != NATIVE_TOKEN_ADDRESS) {\n            _finalBalanceTokenOut = erc20ToToken.balanceOf(address(this));\n        } else {\n            _finalBalanceTokenOut = address(this).balance;\n        }\n\n        uint256 returnAmount = _finalBalanceTokenOut - _initialBalanceTokenOut;\n\n        emit SocketSwapTokens(\n            fromToken,\n            toToken,\n            returnAmount,\n            amount,\n            ZeroXIdentifier,\n            socketGateway\n        );\n\n        return (returnAmount, toToken);\n    }\n}\n"},"src/bridges/cbridge/interfaces/cbridge.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.0;\n\ninterface ICBridge {\n    function send(\n        address _receiver,\n        address _token,\n        uint256 _amount,\n        uint64 _dstChinId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external;\n\n    function sendNative(\n        address _receiver,\n        uint256 _amount,\n        uint64 _dstChinId,\n        uint64 _nonce,\n        uint32 _maxSlippage\n    ) external payable;\n\n    function withdraws(bytes32 withdrawId) external view returns (bool);\n\n    function withdraw(\n        bytes calldata _wdmsg,\n        bytes[] calldata _sigs,\n        address[] calldata _signers,\n        uint256[] calldata _powers\n    ) external;\n}\n"},"src/bridges/stargate/l2/Stargate.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport \"../interfaces/stargate.sol\";\nimport \"../../../errors/SocketErrors.sol\";\nimport {BridgeImplBase} from \"../../BridgeImplBase.sol\";\nimport {STARGATE} from \"../../../static/RouteIdentifiers.sol\";\n\n/**\n * @title Stargate-L2-Route Implementation\n * @notice Route implementation with functions to bridge ERC20 and Native via Stargate-L2-Bridge\n * Called via SocketGateway if the routeId in the request maps to the routeId of Stargate-L2-Implementation\n * Contains function to handle bridging as post-step i.e linked to a preceeding step for swap\n * RequestData is different to just bride and bridging chained with swap\n * @author Socket dot tech.\n */\ncontract StargateImplL2 is BridgeImplBase {\n    /// @notice SafeTransferLib - library for safe and optimised operations on ERC20 tokens\n    using SafeTransferLib for ERC20;\n\n    bytes32 public immutable StargateIdentifier = STARGATE;\n\n    /// @notice Function-selector for ERC20-token bridging on Stargate-L2-Route\n    /// @dev This function selector is to be used while buidling transaction-data to bridge ERC20 tokens\n    bytes4\n        public immutable STARGATE_L2_ERC20_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeERC20To(address,address,address,uint256,uint256,uint256,(uint256,uint256,uint256,uint256,bytes32,bytes,uint16))\"\n            )\n        );\n\n    bytes4 public immutable STARGATE_L1_SWAP_BRIDGE_SELECTOR =\n        bytes4(\n            keccak256(\n                \"swapAndBridge(uint32,bytes,(address,address,uint16,uint256,uint256,uint256,uint256,uint256,uint256,bytes32,bytes))\"\n            )\n        );\n\n    /// @notice Function-selector for Native bridging on Stargate-L2-Route\n    /// @dev This function selector is to be used while buidling transaction-data to bridge Native tokens\n    bytes4\n        public immutable STARGATE_L2_NATIVE_EXTERNAL_BRIDGE_FUNCTION_SELECTOR =\n        bytes4(\n            keccak256(\n                \"bridgeNativeTo(address,address,uint16,uint256,uint256,uint256,bytes32)\"\n            )\n        );\n\n    /// @notice Stargate Router to bridge ERC20 tokens\n    IBridgeStargate public immutable router;\n\n    /// @notice Stargate Router to bridge native tokens\n    IBridgeStargate public immutable routerETH;\n\n    /// @notice socketGatewayAddress to be initialised via storage variable BridgeImplBase\n    /// @dev ensure router, routerEth are set properly for the chainId in which the contract is being deployed\n    constructor(\n        address _router,\n        address _routerEth,\n        address _socketGateway,\n        address _socketDeployFactory\n    ) BridgeImplBase(_socketGateway, _socketDeployFactory) {\n        router = IBridgeStargate(_router);\n        routerETH = IBridgeStargate(_routerEth);\n    }\n\n    /// @notice Struct to be used as a input parameter for Bridging tokens via Stargate-L2-route\n    /// @dev while building transactionData,values should be set in this sequence of properties in this struct\n    struct StargateBridgeExtraData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        uint256 destinationGasLimit;\n        uint256 minReceivedAmt;\n        bytes32 metadata;\n        bytes destinationPayload;\n        uint16 stargateDstChainId; // stargate defines chain id in its way\n    }\n\n    /// @notice Struct to be used in decode step from input parameter - a specific case of bridging after swap.\n    /// @dev the data being encoded in offchain or by caller should have values set in this sequence of properties in this struct\n    struct StargateBridgeDataNoToken {\n        address receiverAddress;\n        address senderAddress;\n        uint16 stargateDstChainId; // stargate defines chain id in its way\n        uint256 value;\n        // a unique identifier that is uses to dedup transfers\n        // this value is the a timestamp sent from frontend, but in theory can be any unique number\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        uint256 minReceivedAmt; // defines the slippage, the min qty you would accept on the destination\n        uint256 optionalValue;\n        uint256 destinationGasLimit;\n        bytes32 metadata;\n        bytes destinationPayload;\n    }\n\n    struct StargateBridgeData {\n        address token;\n        address receiverAddress;\n        address senderAddress;\n        uint16 stargateDstChainId; // stargate defines chain id in its way\n        uint256 value;\n        // a unique identifier that is uses to dedup transfers\n        // this value is the a timestamp sent from frontend, but in theory can be any unique number\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        uint256 minReceivedAmt; // defines the slippage, the min qty you would accept on the destination\n        uint256 optionalValue;\n        uint256 destinationGasLimit;\n        bytes32 metadata;\n        bytes destinationPayload;\n    }\n\n    /**\n     * @notice function to bridge tokens after swap.\n     * @notice this is different from swapAndBridge, this function is called when the swap has already happened at a different place.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in Stargate-BridgeData struct\n     * @param amount amount of tokens being bridged. this can be ERC20 or native\n     * @param bridgeData encoded data for Stargate-L1-Bridge\n     */\n    function bridgeAfterSwap(\n        uint256 amount,\n        bytes calldata bridgeData\n    ) external payable override {\n        StargateBridgeData memory stargateBridgeData = abi.decode(\n            bridgeData,\n            (StargateBridgeData)\n        );\n\n        if (stargateBridgeData.token == NATIVE_TOKEN_ADDRESS) {\n            // perform bridging\n            routerETH.swapETH{value: amount + stargateBridgeData.optionalValue}(\n                stargateBridgeData.stargateDstChainId,\n                payable(stargateBridgeData.senderAddress),\n                abi.encodePacked(stargateBridgeData.receiverAddress),\n                amount,\n                stargateBridgeData.minReceivedAmt\n            );\n        } else {\n            ERC20(stargateBridgeData.token).safeApprove(\n                address(router),\n                amount\n            );\n            {\n                router.swap{value: stargateBridgeData.value}(\n                    stargateBridgeData.stargateDstChainId,\n                    stargateBridgeData.srcPoolId,\n                    stargateBridgeData.dstPoolId,\n                    payable(stargateBridgeData.senderAddress), // default to refund to main contract\n                    amount,\n                    stargateBridgeData.minReceivedAmt,\n                    IBridgeStargate.lzTxObj(\n                        stargateBridgeData.destinationGasLimit,\n                        0, // zero amount since this is a ERC20 bridging\n                        \"0x\" //empty data since this is for only ERC20\n                    ),\n                    abi.encodePacked(stargateBridgeData.receiverAddress),\n                    stargateBridgeData.destinationPayload\n                );\n            }\n        }\n\n        emit SocketBridge(\n            amount,\n            stargateBridgeData.token,\n            stargateBridgeData.stargateDstChainId,\n            StargateIdentifier,\n            msg.sender,\n            stargateBridgeData.receiverAddress,\n            stargateBridgeData.metadata\n        );\n    }\n\n    /**\n     * @notice function to bridge tokens after swapping.\n     * @notice this is different from bridgeAfterSwap since this function holds the logic for swapping tokens too.\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @dev for usage, refer to controller implementations\n     *      encodedData for bridge should follow the sequence of properties in Stargate-BridgeData struct\n     * @param swapId routeId for the swapImpl\n     * @param swapData encoded data for swap\n     * @param stargateBridgeData encoded data for StargateBridgeData\n     */\n    function swapAndBridge(\n        uint32 swapId,\n        bytes calldata swapData,\n        StargateBridgeDataNoToken calldata stargateBridgeData\n    ) external payable {\n        (bool success, bytes memory result) = socketRoute\n            .getRoute(swapId)\n            .delegatecall(swapData);\n\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n\n        (uint256 bridgeAmount, address token) = abi.decode(\n            result,\n            (uint256, address)\n        );\n\n        if (token == NATIVE_TOKEN_ADDRESS) {\n            routerETH.swapETH{\n                value: bridgeAmount + stargateBridgeData.optionalValue\n            }(\n                stargateBridgeData.stargateDstChainId,\n                payable(stargateBridgeData.senderAddress),\n                abi.encodePacked(stargateBridgeData.receiverAddress),\n                bridgeAmount,\n                stargateBridgeData.minReceivedAmt\n            );\n        } else {\n            ERC20(token).safeApprove(address(router), bridgeAmount);\n            {\n                router.swap{value: stargateBridgeData.value}(\n                    stargateBridgeData.stargateDstChainId,\n                    stargateBridgeData.srcPoolId,\n                    stargateBridgeData.dstPoolId,\n                    payable(stargateBridgeData.senderAddress), // default to refund to main contract\n                    bridgeAmount,\n                    stargateBridgeData.minReceivedAmt,\n                    IBridgeStargate.lzTxObj(\n                        stargateBridgeData.destinationGasLimit,\n                        0,\n                        \"0x\"\n                    ),\n                    abi.encodePacked(stargateBridgeData.receiverAddress),\n                    stargateBridgeData.destinationPayload\n                );\n            }\n        }\n\n        emit SocketBridge(\n            bridgeAmount,\n            token,\n            stargateBridgeData.stargateDstChainId,\n            StargateIdentifier,\n            msg.sender,\n            stargateBridgeData.receiverAddress,\n            stargateBridgeData.metadata\n        );\n    }\n\n    /**\n     * @notice function to handle ERC20 bridging to receipent via Stargate-L1-Bridge\n     * @notice This method is payable because the caller is doing token transfer and briding operation\n     * @param token address of token being bridged\n     * @param senderAddress address of sender\n     * @param receiverAddress address of recipient\n     * @param amount amount of token being bridge\n     * @param value value\n     * @param optionalValue optionalValue\n     * @param stargateBridgeExtraData stargate bridge extradata\n     */\n    function bridgeERC20To(\n        address token,\n        address senderAddress,\n        address receiverAddress,\n        uint256 amount,\n        uint256 value,\n        uint256 optionalValue,\n        StargateBridgeExtraData calldata stargateBridgeExtraData\n    ) external payable {\n        // token address might not be indication thats why passed through extraData\n        if (token == NATIVE_TOKEN_ADDRESS) {\n            // perform bridging\n            routerETH.swapETH{value: amount + optionalValue}(\n                stargateBridgeExtraData.stargateDstChainId,\n                payable(senderAddress),\n                abi.encodePacked(receiverAddress),\n                amount,\n                stargateBridgeExtraData.minReceivedAmt\n            );\n        } else {\n            ERC20 tokenInstance = ERC20(token);\n            tokenInstance.safeTransferFrom(msg.sender, socketGateway, amount);\n            tokenInstance.safeApprove(address(router), amount);\n            {\n                router.swap{value: value}(\n                    stargateBridgeExtraData.stargateDstChainId,\n                    stargateBridgeExtraData.srcPoolId,\n                    stargateBridgeExtraData.dstPoolId,\n                    payable(senderAddress), // default to refund to main contract\n                    amount,\n                    stargateBridgeExtraData.minReceivedAmt,\n                    IBridgeStargate.lzTxObj(\n                        stargateBridgeExtraData.destinationGasLimit,\n                        0, // zero amount since this is a ERC20 bridging\n                        \"0x\" //empty data since this is for only ERC20\n                    ),\n                    abi.encodePacked(receiverAddress),\n                    stargateBridgeExtraData.destinationPayload\n                );\n            }\n        }\n\n        emit SocketBridge(\n            amount,\n            token,\n            stargateBridgeExtraData.stargateDstChainId,\n            StargateIdentifier,\n            msg.sender,\n            receiverAddress,\n            stargateBridgeExtraData.metadata\n        );\n    }\n\n    function bridgeNativeTo(\n        address receiverAddress,\n        address senderAddress,\n        uint16 stargateDstChainId,\n        uint256 amount,\n        uint256 minReceivedAmt,\n        uint256 optionalValue,\n        bytes32 metadata\n    ) external payable {\n        // perform bridging\n        routerETH.swapETH{value: amount + optionalValue}(\n            stargateDstChainId,\n            payable(senderAddress),\n            abi.encodePacked(receiverAddress),\n            amount,\n            minReceivedAmt\n        );\n\n        emit SocketBridge(\n            amount,\n            NATIVE_TOKEN_ADDRESS,\n            stargateDstChainId,\n            StargateIdentifier,\n            msg.sender,\n            receiverAddress,\n            metadata\n        );\n    }\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":1000000},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"metadata":{"useLiteralContent":true},"libraries":{}}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_disabledRoute\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ArrayLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectBridgeRatios\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyNominee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"controllerId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"controllerAddress\",\"type\":\"address\"}],\"name\":\"ControllerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"controllerId\",\"type\":\"uint32\"}],\"name\":\"ControllerDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"routeId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"route\",\"type\":\"address\"}],\"name\":\"NewRouteAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"name\":\"OwnerClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nominee\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"routeId\",\"type\":\"uint32\"}],\"name\":\"RouteDisabled\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"BRIDGE_AFTER_SWAP_SELECTOR\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CENT_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controllerAddress\",\"type\":\"address\"}],\"name\":\"addController\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"routeAddress\",\"type\":\"address\"}],\"name\":\"addRoute\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"routeId\",\"type\":\"uint32\"}],\"name\":\"addressAt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controllerCount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"controllers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"controllerId\",\"type\":\"uint32\"}],\"name\":\"disableController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"routeId\",\"type\":\"uint32\"}],\"name\":\"disableRoute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disabledRouteAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"controllerId\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct ISocketGateway.SocketControllerRequest\",\"name\":\"socketControllerRequest\",\"type\":\"tuple\"}],\"name\":\"executeController\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"controllerId\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct ISocketGateway.SocketControllerRequest[]\",\"name\":\"controllerRequests\",\"type\":\"tuple[]\"}],\"name\":\"executeControllers\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"routeId\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"routeData\",\"type\":\"bytes\"}],\"name\":\"executeRoute\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"routeIds\",\"type\":\"uint32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"dataItems\",\"type\":\"bytes[]\"}],\"name\":\"executeRoutes\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"controllerId\",\"type\":\"uint32\"}],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"routeId\",\"type\":\"uint32\"}],\"name\":\"getRoute\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nominee_\",\"type\":\"address\"}],\"name\":\"nominateOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"routes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routesCount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"routeAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"isMax\",\"type\":\"bool\"}],\"name\":\"setApprovalForRouters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"swapRouteId\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"swapImplData\",\"type\":\"bytes\"},{\"internalType\":\"uint32[]\",\"name\":\"bridgeRouteIds\",\"type\":\"uint32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"bridgeImplDataItems\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"bridgeRatios\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"eventDataItems\",\"type\":\"bytes[]\"}],\"internalType\":\"struct ISocketRequest.SwapMultiBridgeRequest\",\"name\":\"swapMultiBridgeRequest\",\"type\":\"tuple\"}],\"name\":\"swapAndMultiBridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SocketGateway","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":1,"Runs":1000000,"ConstructorArguments":"0x000000000000000000000000e8dd38e673a93ccfc2e3d7053efccb5c93f493650000000000000000000000000f34a522ff82151c90679b73211955068fd854f1","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":1,"Implementation":"0xa3c4e32af0da5efaddb20cc9fb26159f55c8c42f","SwarmSource":""}]