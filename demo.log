diff --git a/crates/evm/mutator/src/lib.rs b/crates/evm/mutator/src/lib.rs
index b53c5999..3006842b 100644
--- a/crates/evm/mutator/src/lib.rs
+++ b/crates/evm/mutator/src/lib.rs
@@ -10,7 +10,7 @@ use gambit::{run_mutate, MutateParams};
 use itertools::Itertools;
 use std::{
     collections::{BTreeMap, HashMap},
-    path::{PathBuf}
+    path::PathBuf
 };
 
 mod filter;
@@ -111,8 +111,20 @@ impl Mutator {
             seed: 0,
             outdir: Some(DEFAULT_GAMBIT_DIR_OUT.into()),
             sourceroot: Some(source_root.into()),
-            mutations: None,
-            no_export: true,
+            // mutations: None,
+            // unary operators generate quite a lot
+            // of invalid 
+            mutations: Some(vec![
+                "binary-op-mutation".into(),
+                "delete-expression-mutation".into(),
+                "elim-delegate-mutation".into(),
+                "function-call-mutation".into(),
+                "if-statement-mutation".into(),
+                "require-mutation".into(),
+                "swap-arguments-function-mutation".into(),
+                "swap-arguments-operator-mutation".into(),
+            ]),
+            no_export: false,
             no_overwrite: false,
             solc: solc.into(),
             solc_optimize,
diff --git a/crates/forge/bin/cmd/mutate/html.rs b/crates/forge/bin/cmd/mutate/html.rs
index fbd0dd0c..f1f03ecf 100644
--- a/crates/forge/bin/cmd/mutate/html.rs
+++ b/crates/forge/bin/cmd/mutate/html.rs
@@ -1,9 +1,9 @@
 
-pub struct HTMLExporter {
+pub struct MarkdownExporter {
     
 }
 
-impl HTMLExporter {
+impl MarkdownExporter {
 
     pub fn new() -> Self {
 
diff --git a/crates/forge/bin/cmd/mutate/mod.rs b/crates/forge/bin/cmd/mutate/mod.rs
index 5f13de3c..ab071319 100644
--- a/crates/forge/bin/cmd/mutate/mod.rs
+++ b/crates/forge/bin/cmd/mutate/mod.rs
@@ -12,15 +12,13 @@ use forge::{
     TestOptionsBuilder,
 };
 use foundry_cli::{
-    init_progress,
     opts::CoreBuildArgs,
-    update_progress,
     utils::{self, LoadConfig},
 };
 use foundry_common::{
-    compile::ProjectCompiler,
+    compile::{ProjectCompiler, self},
     evm::EvmArgs,
-    shell::{self}, term::{MutatorSpinnerReporter, ProgressReporter}
+    shell::{self, println}, term::{MutatorSpinnerReporter, ProgressReporter}
 };
 use foundry_compilers::{
     project_util::{copy_dir, TempProject},
@@ -36,16 +34,18 @@ use foundry_config::{
 };
 use foundry_evm::opts::EvmOpts;
 use foundry_evm_mutator::{Mutant, MutatorConfigBuilder};
-use futures::future::try_join_all;
+use futures::future::{try_join_all, join_all};
 use itertools::Itertools;
 use std::{
     collections::BTreeMap,
     fs,
     path::{PathBuf},
-    sync::mpsc::channel,
+    sync::mpsc::{channel, sync_channel},
     time::{Duration, Instant},
 };
 
+use rayon::prelude::*;
+
 mod filter;
 pub use filter::*;
 mod summary;
@@ -182,19 +182,55 @@ impl MutateTestArgs {
         trace!(?elapsed, "finished running gambit");
         drop(spinner);
 
-        // this is bad
-        let mutants_len_iterator: Vec<&Mutant> = mutants_output.iter()
+        let mutants_len_size = mutants_output.iter()
             .flat_map(|(_, v)| v)
-            .collect();
+            .count();
 
         println!(
             "Generated {} mutants in {:.2?}",
-            mutants_len_iterator.len(), elapsed
+            mutants_len_size, elapsed
         );
+
+    //     // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+    //     let mutation_project_root = project.root();
+    //     for (contract_out_dir, contract_mutants) in mutants_output.into_iter() {
+    //         let mut contract_mutants_iterator = contract_mutants.chunks(std::thread::available_parallelism().expect("value").into());
+
+    //         while let Some(mutant_chunks) = contract_mutants_iterator.next() {
+    //             let mutant_data_iterator = mutant_chunks.iter().map(
+    //                 |mutant| (
+    //                     mutation_project_root.clone(),
+    //                     mutant.source.filename_as_str(),
+    //                     mutant.as_source_string().expect("Failed to read a file")
+    //                 )
+    //             );
+
+    //             // we compile the projects here
+    //             let mutant_project_and_compile_output: Vec<_> = join_all(
+    //                 mutant_data_iterator
+    //                 .map(
+    //                     |(root, file_name, mutant_contents)| tokio::task::spawn_blocking(
+    //                         || setup_and_compile_mutant(root, file_name, mutant_contents )
+    //                     )
+    //                 )
+    //             ).await.into_iter().filter_map(|x| x.ok()).collect();
+
+    //             println!(">>>>>>>>>>>>>>>>>>>>>>>>>> {}", mutant_project_and_compile_output.len());
+    //             for item in mutant_project_and_compile_output.into_iter() {
+    //                 if item.is_err() {
+    //                     println!(">>>>>>>>>>>>>>>>>>>>>> {:?}", item);
+    //                 }
+    //             }
+    //         }
+
+    //     }   
         
-        // this is required for progress bar
+
+    //    Ok(MutationTestOutcome::new(false, Default::default()))
+
+    //    // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
         println!("[â †] Testing Mutants...");
-        let progress_bar_reporter = ProgressReporter::spawn("Mutants".into(), mutants_len_iterator.len());
+        let progress_bar_reporter = ProgressReporter::spawn("Mutants".into(), mutants_len_size);
 
         let mut mutant_test_suite_results: BTreeMap<String, MutationTestSuiteResult> =
             BTreeMap::new();
@@ -207,7 +243,7 @@ impl MutateTestArgs {
             // a file can have hundreds of mutants depending on design
             // we chunk there to prevent huge memory consumption
             // try_join_all which launches all the futures and polls
-            let mut contract_mutants_iterator = contract_mutants.chunks(32);
+            let mut contract_mutants_iterator = contract_mutants.chunks(6);
             
             while let Some(mutant_chunks) = contract_mutants_iterator.next() {
                 let mutant_data_iterator = mutant_chunks.iter().map(
@@ -219,16 +255,28 @@ impl MutateTestArgs {
                 );
 
                 // we compile the projects here
-                let mutant_project_and_compile_output: Vec<_> = try_join_all(
-                    mutant_data_iterator
+                let mutant_project_and_compile_output_data: Vec<_> = mutant_data_iterator
+                    .into_iter()
                     .map(
-                        |(root, file_name, mutant_contents)| tokio::task::spawn_blocking(
-                            || setup_and_compile_mutant(root, file_name, mutant_contents )
-                        )
+                        |(root, file_name, mutant_contents)| 
+                            setup_and_compile_mutant(root, file_name, mutant_contents )
                     )
-                ).await?.into_iter().filter_map(|x| x.ok()).collect();
-
-                let test_output = try_join_all(mutant_project_and_compile_output.into_iter().map(
+                    .collect();
+                
+                
+                mutant_project_and_compile_output_data.iter().for_each(|x| match x {
+                    Err(x) => {
+                        println!("{:?}", x);
+                        progress_bar_reporter.increment();
+                    },
+                    _ => {}
+                });
+
+                let mutant_project_and_compile_output: Vec<_> = mutant_project_and_compile_output_data.into_iter().filter_map(|x| x.ok()).collect();
+
+                trace!(target: "forget:mutate", "successfully compiled");
+                // we test the projects here
+                let test_output = join_all(mutant_project_and_compile_output.into_iter().map(
                     |(temp_project, mutant_compile_output, mutant_config)| {
                         test_mutant(
                             progress_bar_reporter.clone(), 
@@ -239,9 +287,12 @@ impl MutateTestArgs {
                             &evm_opts
                         )
                     }
-                )).await?;
+                )).await;
+                
+                let filtered_test_output: Vec<_> = test_output.into_iter().filter_map(|x| x.ok()).collect();
+                trace!(target: "forget:mutate", "successfully tested");
 
-                mutant_test_statuses.extend(test_output);
+                mutant_test_statuses.extend(filtered_test_output);
             }
 
             let mutant_test_results: Vec<_> =  mutant_test_statuses.into_iter().enumerate().map(|(index, (duration, status))| {
@@ -419,6 +470,8 @@ pub fn setup_and_compile_mutant(
     mutant_file: String,
     mutant_contents: String 
 ) -> Result<(TempProject, ProjectCompileOutput, Config)> {
+    info!(target: "forge:mutate", "Compiling Mutant");
+
     let start = Instant::now();
 
     // we do not support hardhat style testing
@@ -438,19 +491,58 @@ pub fn setup_and_compile_mutant(
     config.invariant.runs = 0;
 
     let mutant_file_path= temp_project_root.join(mutant_file);
+
     // Write Mutant contents to file in temp_directory
-    fs::write(&mutant_file_path.as_path(), mutant_contents)?;
+    fs::write(&mutant_file_path.as_path(), mutant_contents.clone())?;
 
     debug!(
         duration = ?start.elapsed(),
         "compilation times",
     );
     
-    let mut project = config.project()?;
-    project.set_solc_jobs(4);
+    let project = config.project()?;
 
-    let compile_output = project.compile().map_err(|_| eyre!("compilation failed"))?;
+    // let (tx, rx) = std::sync::mpsc
+    let (tx, rx) = sync_channel::<Result<ProjectCompileOutput, eyre::Error>>(1);
 
+    println!(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> gets before after1");
+
+    std::thread::Builder::new()
+        // .name("compilation_thread".into())
+        .spawn(move || {
+            println!(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> gets before after2");
+
+            let result: std::prelude::v1::Result<ProjectCompileOutput, eyre::Error> = project.compile().map_err(|_| eyre!("compilation failed"));
+            let _ = tx.send(result);
+        }).expect("valid thread");
+        // .join()
+        // .map_err(|e| {
+        //     println!(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> error 1");
+        //     eyre!("{:?}", e)
+        // })?
+        // .map_err(|e| {
+        //     println!(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> error 2");
+        //     eyre!("{:?}", e)
+        // })?;
+    
+    let compile_output = match rx.recv_timeout(Duration::from_secs(20)) {
+        Ok(x) => x,
+        Err(e) => {
+
+            // output the source code
+            // println!("{:?}", mutant_contents);
+            std::process::exit(0);
+            return Err(eyre!("{:?}", e))
+        }
+    }?;
+
+    // let compile_output =  std::panic::catch_unwind(|| project.compile().map_err(|_| eyre!("compilation failed"))).map_err(|e| eyre!("{:?}", e))??;
+    // let compile_output = project.compile().map_err(|_| eyre!("compilation failed"))?;
+    println!(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> gets here after3");
+    if compile_output.has_compiler_errors() {
+        error!(target: "forge:mutate", "failed to compile project");
+        return Err(eyre!("Failed to compile"));
+    }
     Ok((temp_project, compile_output, config))
 }
 
@@ -489,7 +581,7 @@ pub async fn test_mutant(
         .with_test_options(test_options.clone());
 
     let mut runner =
-        runner_builder.build(project_root, output.clone(), env.clone(), evm_opts.clone())?;
+        runner_builder.build(project_root, output, env, evm_opts.clone())?;
     
     // We use a thread and recv_timeout here because Gambit generates 
     // valid solidity grammar mutants that leads to very long running
@@ -506,25 +598,27 @@ pub async fn test_mutant(
     //    }
     //
     // 
-    let test_timeout = Duration::from_millis(100);
+    let test_timeout = Duration::from_millis(300);
     // mpsc channel for reporting test results
     let (tx, rx) = channel::<(String, SuiteResult)>();
     
-    std::thread::Builder::new()
+    println!(">>>>>>>>>>>>>>>>> gets here to thread");
+    let handle = std::thread::Builder::new()
         .name("mutation_test_execution_backend".into())
         .spawn(move || {
             let rt = tokio::runtime::Builder::new_current_thread()
-                .enable_all()
+                .on_thread_stop(|| println!("stopping thread"))
+                .on_thread_start(|| println!("starting thread"))
+                .on_thread_park(|| println!("parking thread"))
+                // .enable_all()
+                // .enable_time()
                 .build()
                 .expect("failed to build tokio runtime");
 
             rt.block_on(async move {
-                // flush cache every 60s, this ensures that long-running fork tests get their
-                // cache flushed from time to time
-                // NOTE: we install the interval here because the `tokio::timer::Interval`
-                // requires a rt
                 runner.test(&filter, tx, test_options).await;
             });
+            // println!("exiting thread");
         }).expect("failed to spawn thread");
 
     let mut status: MutantTestStatus = MutantTestStatus::Survived;
@@ -538,6 +632,7 @@ pub async fn test_mutant(
             },
             Err(std::sync::mpsc::RecvTimeoutError::Timeout) => {
                 trace!(target: "forge:mutate", "test timeout");
+                println!("Timed out");
                 status = MutantTestStatus::Timeout;
                 break;
             },
@@ -545,11 +640,13 @@ pub async fn test_mutant(
                 break;
             }
         }
-    }
+    };
+    drop(rx);
 
     progress_bar.increment();
+    
 
     trace!(target: "forge::mutate", "received mutant test results");
-
+    // println!("gets here");
     Ok((start.elapsed(), status))
 }
\ No newline at end of file
