/*
 * Compute Engine API
 *
 * Creates and runs virtual machines on Google Cloud Platform.
 *
 * The version of the OpenAPI document: v1
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::google_rest_apis::compute_v1::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct RouterStatusBgpPeerStatus {
    /// Routes that were advertised to the remote BGP peer
    #[serde(rename = "advertisedRoutes", skip_serializing_if = "Option::is_none")]
    pub advertised_routes: Option<Vec<models::Route>>,
    #[serde(rename = "bfdStatus", skip_serializing_if = "Option::is_none")]
    pub bfd_status: Option<Box<models::BfdStatus>>,
    /// Enable IPv6 traffic over BGP Peer. If not specified, it is disabled by default.
    #[serde(rename = "enableIpv6", skip_serializing_if = "Option::is_none")]
    pub enable_ipv6: Option<bool>,
    /// IP address of the local BGP interface.
    #[serde(rename = "ipAddress", skip_serializing_if = "Option::is_none")]
    pub ip_address: Option<String>,
    /// IPv6 address of the local BGP interface.
    #[serde(rename = "ipv6NexthopAddress", skip_serializing_if = "Option::is_none")]
    pub ipv6_nexthop_address: Option<String>,
    /// URL of the VPN tunnel that this BGP peer controls.
    #[serde(rename = "linkedVpnTunnel", skip_serializing_if = "Option::is_none")]
    pub linked_vpn_tunnel: Option<String>,
    /// Informs whether MD5 authentication is enabled on this BGP peer.
    #[serde(rename = "md5AuthEnabled", skip_serializing_if = "Option::is_none")]
    pub md5_auth_enabled: Option<bool>,
    /// Name of this BGP peer. Unique within the Routers resource.
    #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Number of routes learned from the remote BGP Peer.
    #[serde(rename = "numLearnedRoutes", skip_serializing_if = "Option::is_none")]
    pub num_learned_routes: Option<i32>,
    /// IP address of the remote BGP interface.
    #[serde(rename = "peerIpAddress", skip_serializing_if = "Option::is_none")]
    pub peer_ip_address: Option<String>,
    /// IPv6 address of the remote BGP interface.
    #[serde(
        rename = "peerIpv6NexthopAddress",
        skip_serializing_if = "Option::is_none"
    )]
    pub peer_ipv6_nexthop_address: Option<String>,
    /// [Output only] URI of the VM instance that is used as third-party router appliances such as Next Gen Firewalls, Virtual Routers, or Router Appliances. The VM instance is the peer side of the BGP session.
    #[serde(
        rename = "routerApplianceInstance",
        skip_serializing_if = "Option::is_none"
    )]
    pub router_appliance_instance: Option<String>,
    /// The state of the BGP session. For a list of possible values for this field, see BGP session states.
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<String>,
    /// Status of the BGP peer: {UP, DOWN}
    #[serde(rename = "status", skip_serializing_if = "Option::is_none")]
    pub status: Option<Status>,
    /// Indicates why particular status was returned.
    #[serde(rename = "statusReason", skip_serializing_if = "Option::is_none")]
    pub status_reason: Option<StatusReason>,
    /// Time this session has been up. Format: 14 years, 51 weeks, 6 days, 23 hours, 59 minutes, 59 seconds
    #[serde(rename = "uptime", skip_serializing_if = "Option::is_none")]
    pub uptime: Option<String>,
    /// Time this session has been up, in seconds. Format: 145
    #[serde(rename = "uptimeSeconds", skip_serializing_if = "Option::is_none")]
    pub uptime_seconds: Option<String>,
}

impl RouterStatusBgpPeerStatus {
    pub fn new() -> RouterStatusBgpPeerStatus {
        RouterStatusBgpPeerStatus {
            advertised_routes: None,
            bfd_status: None,
            enable_ipv6: None,
            ip_address: None,
            ipv6_nexthop_address: None,
            linked_vpn_tunnel: None,
            md5_auth_enabled: None,
            name: None,
            num_learned_routes: None,
            peer_ip_address: None,
            peer_ipv6_nexthop_address: None,
            router_appliance_instance: None,
            state: None,
            status: None,
            status_reason: None,
            uptime: None,
            uptime_seconds: None,
        }
    }
}
/// Status of the BGP peer: {UP, DOWN}
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Status {
    #[serde(rename = "DOWN")]
    Down,
    #[serde(rename = "UNKNOWN")]
    Unknown,
    #[serde(rename = "UP")]
    Up,
}

impl Default for Status {
    fn default() -> Status {
        Self::Down
    }
}
/// Indicates why particular status was returned.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum StatusReason {
    #[serde(rename = "MD5_AUTH_INTERNAL_PROBLEM")]
    Md5AuthInternalProblem,
    #[serde(rename = "STATUS_REASON_UNSPECIFIED")]
    StatusReasonUnspecified,
}

impl Default for StatusReason {
    fn default() -> StatusReason {
        Self::Md5AuthInternalProblem
    }
}
