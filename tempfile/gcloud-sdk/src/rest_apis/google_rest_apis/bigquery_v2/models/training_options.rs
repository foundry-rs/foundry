/*
 * BigQuery API
 *
 * A data platform for customers to create, manage, share and query data.
 *
 * The version of the OpenAPI document: v2
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::google_rest_apis::bigquery_v2::models;
use serde::{Deserialize, Serialize};

/// TrainingOptions : Options used in model training.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct TrainingOptions {
    /// If true, detect step changes and make data adjustment in the input time series.
    #[serde(rename = "adjustStepChanges", skip_serializing_if = "Option::is_none")]
    pub adjust_step_changes: Option<bool>,
    /// Whether to enable auto ARIMA or not.
    #[serde(rename = "autoArima", skip_serializing_if = "Option::is_none")]
    pub auto_arima: Option<bool>,
    /// The max value of non-seasonal p and q.
    #[serde(rename = "autoArimaMaxOrder", skip_serializing_if = "Option::is_none")]
    pub auto_arima_max_order: Option<String>,
    /// Batch size for dnn models.
    #[serde(rename = "batchSize", skip_serializing_if = "Option::is_none")]
    pub batch_size: Option<String>,
    /// Booster type for boosted tree models.
    #[serde(rename = "boosterType", skip_serializing_if = "Option::is_none")]
    pub booster_type: Option<BoosterType>,
    /// Whether or not p-value test should be computed for this model. Only available for linear and logistic regression models.
    #[serde(rename = "calculatePValues", skip_serializing_if = "Option::is_none")]
    pub calculate_p_values: Option<bool>,
    /// If true, clean spikes and dips in the input time series.
    #[serde(rename = "cleanSpikesAndDips", skip_serializing_if = "Option::is_none")]
    pub clean_spikes_and_dips: Option<bool>,
    /// Enums for color space, used for processing images in Object Table. See more details at https://www.tensorflow.org/io/tutorials/colorspace.
    #[serde(rename = "colorSpace", skip_serializing_if = "Option::is_none")]
    pub color_space: Option<ColorSpace>,
    /// Subsample ratio of columns for each level for boosted tree models.
    #[serde(rename = "colsampleBylevel", skip_serializing_if = "Option::is_none")]
    pub colsample_bylevel: Option<f64>,
    /// Subsample ratio of columns for each node(split) for boosted tree models.
    #[serde(rename = "colsampleBynode", skip_serializing_if = "Option::is_none")]
    pub colsample_bynode: Option<f64>,
    /// Subsample ratio of columns when constructing each tree for boosted tree models.
    #[serde(rename = "colsampleBytree", skip_serializing_if = "Option::is_none")]
    pub colsample_bytree: Option<f64>,
    /// Type of normalization algorithm for boosted tree models using dart booster.
    #[serde(rename = "dartNormalizeType", skip_serializing_if = "Option::is_none")]
    pub dart_normalize_type: Option<DartNormalizeType>,
    /// The data frequency of a time series.
    #[serde(rename = "dataFrequency", skip_serializing_if = "Option::is_none")]
    pub data_frequency: Option<DataFrequency>,
    /// The column to split data with. This column won't be used as a feature. 1. When data_split_method is CUSTOM, the corresponding column should be boolean. The rows with true value tag are eval data, and the false are training data. 2. When data_split_method is SEQ, the first DATA_SPLIT_EVAL_FRACTION rows (from smallest to largest) in the corresponding column are used as training data, and the rest are eval data. It respects the order in Orderable data types: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#data-type-properties
    #[serde(rename = "dataSplitColumn", skip_serializing_if = "Option::is_none")]
    pub data_split_column: Option<String>,
    /// The fraction of evaluation data over the whole input data. The rest of data will be used as training data. The format should be double. Accurate to two decimal places. Default value is 0.2.
    #[serde(
        rename = "dataSplitEvalFraction",
        skip_serializing_if = "Option::is_none"
    )]
    pub data_split_eval_fraction: Option<f64>,
    /// The data split type for training and evaluation, e.g. RANDOM.
    #[serde(rename = "dataSplitMethod", skip_serializing_if = "Option::is_none")]
    pub data_split_method: Option<DataSplitMethod>,
    /// If true, perform decompose time series and save the results.
    #[serde(
        rename = "decomposeTimeSeries",
        skip_serializing_if = "Option::is_none"
    )]
    pub decompose_time_series: Option<bool>,
    /// Distance type for clustering models.
    #[serde(rename = "distanceType", skip_serializing_if = "Option::is_none")]
    pub distance_type: Option<DistanceType>,
    /// Dropout probability for dnn models.
    #[serde(rename = "dropout", skip_serializing_if = "Option::is_none")]
    pub dropout: Option<f64>,
    /// Whether to stop early when the loss doesn't improve significantly any more (compared to min_relative_progress). Used only for iterative training algorithms.
    #[serde(rename = "earlyStop", skip_serializing_if = "Option::is_none")]
    pub early_stop: Option<bool>,
    /// If true, enable global explanation during training.
    #[serde(
        rename = "enableGlobalExplain",
        skip_serializing_if = "Option::is_none"
    )]
    pub enable_global_explain: Option<bool>,
    /// Feedback type that specifies which algorithm to run for matrix factorization.
    #[serde(rename = "feedbackType", skip_serializing_if = "Option::is_none")]
    pub feedback_type: Option<FeedbackType>,
    /// Hidden units for dnn models.
    #[serde(rename = "hiddenUnits", skip_serializing_if = "Option::is_none")]
    pub hidden_units: Option<Vec<String>>,
    /// The geographical region based on which the holidays are considered in time series modeling. If a valid value is specified, then holiday effects modeling is enabled.
    #[serde(rename = "holidayRegion", skip_serializing_if = "Option::is_none")]
    pub holiday_region: Option<HolidayRegion>,
    /// The number of periods ahead that need to be forecasted.
    #[serde(rename = "horizon", skip_serializing_if = "Option::is_none")]
    pub horizon: Option<String>,
    /// The target evaluation metrics to optimize the hyperparameters for.
    #[serde(
        rename = "hparamTuningObjectives",
        skip_serializing_if = "Option::is_none"
    )]
    pub hparam_tuning_objectives: Option<Vec<HparamTuningObjectives>>,
    /// Include drift when fitting an ARIMA model.
    #[serde(rename = "includeDrift", skip_serializing_if = "Option::is_none")]
    pub include_drift: Option<bool>,
    /// Specifies the initial learning rate for the line search learn rate strategy.
    #[serde(rename = "initialLearnRate", skip_serializing_if = "Option::is_none")]
    pub initial_learn_rate: Option<f64>,
    /// Name of input label columns in training data.
    #[serde(rename = "inputLabelColumns", skip_serializing_if = "Option::is_none")]
    pub input_label_columns: Option<Vec<String>>,
    /// Number of integral steps for the integrated gradients explain method.
    #[serde(
        rename = "integratedGradientsNumSteps",
        skip_serializing_if = "Option::is_none"
    )]
    pub integrated_gradients_num_steps: Option<String>,
    /// Item column specified for matrix factorization models.
    #[serde(rename = "itemColumn", skip_serializing_if = "Option::is_none")]
    pub item_column: Option<String>,
    /// The column used to provide the initial centroids for kmeans algorithm when kmeans_initialization_method is CUSTOM.
    #[serde(
        rename = "kmeansInitializationColumn",
        skip_serializing_if = "Option::is_none"
    )]
    pub kmeans_initialization_column: Option<String>,
    /// The method used to initialize the centroids for kmeans algorithm.
    #[serde(
        rename = "kmeansInitializationMethod",
        skip_serializing_if = "Option::is_none"
    )]
    pub kmeans_initialization_method: Option<KmeansInitializationMethod>,
    /// L1 regularization coefficient.
    #[serde(rename = "l1Regularization", skip_serializing_if = "Option::is_none")]
    pub l1_regularization: Option<f64>,
    /// L2 regularization coefficient.
    #[serde(rename = "l2Regularization", skip_serializing_if = "Option::is_none")]
    pub l2_regularization: Option<f64>,
    /// Weights associated with each label class, for rebalancing the training data. Only applicable for classification models.
    #[serde(rename = "labelClassWeights", skip_serializing_if = "Option::is_none")]
    pub label_class_weights: Option<std::collections::HashMap<String, f64>>,
    /// Learning rate in training. Used only for iterative training algorithms.
    #[serde(rename = "learnRate", skip_serializing_if = "Option::is_none")]
    pub learn_rate: Option<f64>,
    /// The strategy to determine learn rate for the current iteration.
    #[serde(rename = "learnRateStrategy", skip_serializing_if = "Option::is_none")]
    pub learn_rate_strategy: Option<LearnRateStrategy>,
    /// Type of loss function used during training run.
    #[serde(rename = "lossType", skip_serializing_if = "Option::is_none")]
    pub loss_type: Option<LossType>,
    /// The maximum number of iterations in training. Used only for iterative training algorithms.
    #[serde(rename = "maxIterations", skip_serializing_if = "Option::is_none")]
    pub max_iterations: Option<String>,
    /// Maximum number of trials to run in parallel.
    #[serde(rename = "maxParallelTrials", skip_serializing_if = "Option::is_none")]
    pub max_parallel_trials: Option<String>,
    /// Get truncated length by last n points in time series. Use separately from time_series_length_fraction and min_time_series_length.
    #[serde(
        rename = "maxTimeSeriesLength",
        skip_serializing_if = "Option::is_none"
    )]
    pub max_time_series_length: Option<String>,
    /// Maximum depth of a tree for boosted tree models.
    #[serde(rename = "maxTreeDepth", skip_serializing_if = "Option::is_none")]
    pub max_tree_depth: Option<String>,
    /// When early_stop is true, stops training when accuracy improvement is less than 'min_relative_progress'. Used only for iterative training algorithms.
    #[serde(
        rename = "minRelativeProgress",
        skip_serializing_if = "Option::is_none"
    )]
    pub min_relative_progress: Option<f64>,
    /// Minimum split loss for boosted tree models.
    #[serde(rename = "minSplitLoss", skip_serializing_if = "Option::is_none")]
    pub min_split_loss: Option<f64>,
    /// Set fast trend ARIMA_PLUS model minimum training length. Use in pair with time_series_length_fraction.
    #[serde(
        rename = "minTimeSeriesLength",
        skip_serializing_if = "Option::is_none"
    )]
    pub min_time_series_length: Option<String>,
    /// Minimum sum of instance weight needed in a child for boosted tree models.
    #[serde(rename = "minTreeChildWeight", skip_serializing_if = "Option::is_none")]
    pub min_tree_child_weight: Option<String>,
    /// Google Cloud Storage URI from which the model was imported. Only applicable for imported models.
    #[serde(rename = "modelUri", skip_serializing_if = "Option::is_none")]
    pub model_uri: Option<String>,
    #[serde(rename = "nonSeasonalOrder", skip_serializing_if = "Option::is_none")]
    pub non_seasonal_order: Option<Box<models::ArimaOrder>>,
    /// Number of clusters for clustering models.
    #[serde(rename = "numClusters", skip_serializing_if = "Option::is_none")]
    pub num_clusters: Option<String>,
    /// Num factors specified for matrix factorization models.
    #[serde(rename = "numFactors", skip_serializing_if = "Option::is_none")]
    pub num_factors: Option<String>,
    /// Number of parallel trees constructed during each iteration for boosted tree models.
    #[serde(rename = "numParallelTree", skip_serializing_if = "Option::is_none")]
    pub num_parallel_tree: Option<String>,
    /// Number of trials to run this hyperparameter tuning job.
    #[serde(rename = "numTrials", skip_serializing_if = "Option::is_none")]
    pub num_trials: Option<String>,
    /// Optimization strategy for training linear regression models.
    #[serde(
        rename = "optimizationStrategy",
        skip_serializing_if = "Option::is_none"
    )]
    pub optimization_strategy: Option<OptimizationStrategy>,
    /// Whether to preserve the input structs in output feature names. Suppose there is a struct A with field b. When false (default), the output feature name is A_b. When true, the output feature name is A.b.
    #[serde(
        rename = "preserveInputStructs",
        skip_serializing_if = "Option::is_none"
    )]
    pub preserve_input_structs: Option<bool>,
    /// Number of paths for the sampled Shapley explain method.
    #[serde(
        rename = "sampledShapleyNumPaths",
        skip_serializing_if = "Option::is_none"
    )]
    pub sampled_shapley_num_paths: Option<String>,
    /// Subsample fraction of the training data to grow tree to prevent overfitting for boosted tree models.
    #[serde(rename = "subsample", skip_serializing_if = "Option::is_none")]
    pub subsample: Option<f64>,
    /// Column to be designated as time series data for ARIMA model.
    #[serde(
        rename = "timeSeriesDataColumn",
        skip_serializing_if = "Option::is_none"
    )]
    pub time_series_data_column: Option<String>,
    /// The time series id column that was used during ARIMA model training.
    #[serde(rename = "timeSeriesIdColumn", skip_serializing_if = "Option::is_none")]
    pub time_series_id_column: Option<String>,
    /// The time series id columns that were used during ARIMA model training.
    #[serde(
        rename = "timeSeriesIdColumns",
        skip_serializing_if = "Option::is_none"
    )]
    pub time_series_id_columns: Option<Vec<String>>,
    /// Get truncated length by fraction in time series.
    #[serde(
        rename = "timeSeriesLengthFraction",
        skip_serializing_if = "Option::is_none"
    )]
    pub time_series_length_fraction: Option<f64>,
    /// Column to be designated as time series timestamp for ARIMA model.
    #[serde(
        rename = "timeSeriesTimestampColumn",
        skip_serializing_if = "Option::is_none"
    )]
    pub time_series_timestamp_column: Option<String>,
    /// Tree construction algorithm for boosted tree models.
    #[serde(rename = "treeMethod", skip_serializing_if = "Option::is_none")]
    pub tree_method: Option<TreeMethod>,
    /// The smoothing window size for the trend component of the time series.
    #[serde(
        rename = "trendSmoothingWindowSize",
        skip_serializing_if = "Option::is_none"
    )]
    pub trend_smoothing_window_size: Option<String>,
    /// User column specified for matrix factorization models.
    #[serde(rename = "userColumn", skip_serializing_if = "Option::is_none")]
    pub user_column: Option<String>,
    /// Hyperparameter for matrix factoration when implicit feedback type is specified.
    #[serde(rename = "walsAlpha", skip_serializing_if = "Option::is_none")]
    pub wals_alpha: Option<f64>,
    /// Whether to train a model from the last checkpoint.
    #[serde(rename = "warmStart", skip_serializing_if = "Option::is_none")]
    pub warm_start: Option<bool>,
}

impl TrainingOptions {
    /// Options used in model training.
    pub fn new() -> TrainingOptions {
        TrainingOptions {
            adjust_step_changes: None,
            auto_arima: None,
            auto_arima_max_order: None,
            batch_size: None,
            booster_type: None,
            calculate_p_values: None,
            clean_spikes_and_dips: None,
            color_space: None,
            colsample_bylevel: None,
            colsample_bynode: None,
            colsample_bytree: None,
            dart_normalize_type: None,
            data_frequency: None,
            data_split_column: None,
            data_split_eval_fraction: None,
            data_split_method: None,
            decompose_time_series: None,
            distance_type: None,
            dropout: None,
            early_stop: None,
            enable_global_explain: None,
            feedback_type: None,
            hidden_units: None,
            holiday_region: None,
            horizon: None,
            hparam_tuning_objectives: None,
            include_drift: None,
            initial_learn_rate: None,
            input_label_columns: None,
            integrated_gradients_num_steps: None,
            item_column: None,
            kmeans_initialization_column: None,
            kmeans_initialization_method: None,
            l1_regularization: None,
            l2_regularization: None,
            label_class_weights: None,
            learn_rate: None,
            learn_rate_strategy: None,
            loss_type: None,
            max_iterations: None,
            max_parallel_trials: None,
            max_time_series_length: None,
            max_tree_depth: None,
            min_relative_progress: None,
            min_split_loss: None,
            min_time_series_length: None,
            min_tree_child_weight: None,
            model_uri: None,
            non_seasonal_order: None,
            num_clusters: None,
            num_factors: None,
            num_parallel_tree: None,
            num_trials: None,
            optimization_strategy: None,
            preserve_input_structs: None,
            sampled_shapley_num_paths: None,
            subsample: None,
            time_series_data_column: None,
            time_series_id_column: None,
            time_series_id_columns: None,
            time_series_length_fraction: None,
            time_series_timestamp_column: None,
            tree_method: None,
            trend_smoothing_window_size: None,
            user_column: None,
            wals_alpha: None,
            warm_start: None,
        }
    }
}
/// Booster type for boosted tree models.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum BoosterType {
    #[serde(rename = "BOOSTER_TYPE_UNSPECIFIED")]
    BoosterTypeUnspecified,
    #[serde(rename = "GBTREE")]
    Gbtree,
    #[serde(rename = "DART")]
    Dart,
}

impl Default for BoosterType {
    fn default() -> BoosterType {
        Self::BoosterTypeUnspecified
    }
}
/// Enums for color space, used for processing images in Object Table. See more details at https://www.tensorflow.org/io/tutorials/colorspace.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ColorSpace {
    #[serde(rename = "COLOR_SPACE_UNSPECIFIED")]
    ColorSpaceUnspecified,
    #[serde(rename = "RGB")]
    Rgb,
    #[serde(rename = "HSV")]
    Hsv,
    #[serde(rename = "YIQ")]
    Yiq,
    #[serde(rename = "YUV")]
    Yuv,
    #[serde(rename = "GRAYSCALE")]
    Grayscale,
}

impl Default for ColorSpace {
    fn default() -> ColorSpace {
        Self::ColorSpaceUnspecified
    }
}
/// Type of normalization algorithm for boosted tree models using dart booster.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum DartNormalizeType {
    #[serde(rename = "DART_NORMALIZE_TYPE_UNSPECIFIED")]
    DartNormalizeTypeUnspecified,
    #[serde(rename = "TREE")]
    Tree,
    #[serde(rename = "FOREST")]
    Forest,
}

impl Default for DartNormalizeType {
    fn default() -> DartNormalizeType {
        Self::DartNormalizeTypeUnspecified
    }
}
/// The data frequency of a time series.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum DataFrequency {
    #[serde(rename = "DATA_FREQUENCY_UNSPECIFIED")]
    DataFrequencyUnspecified,
    #[serde(rename = "AUTO_FREQUENCY")]
    AutoFrequency,
    #[serde(rename = "YEARLY")]
    Yearly,
    #[serde(rename = "QUARTERLY")]
    Quarterly,
    #[serde(rename = "MONTHLY")]
    Monthly,
    #[serde(rename = "WEEKLY")]
    Weekly,
    #[serde(rename = "DAILY")]
    Daily,
    #[serde(rename = "HOURLY")]
    Hourly,
    #[serde(rename = "PER_MINUTE")]
    PerMinute,
}

impl Default for DataFrequency {
    fn default() -> DataFrequency {
        Self::DataFrequencyUnspecified
    }
}
/// The data split type for training and evaluation, e.g. RANDOM.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum DataSplitMethod {
    #[serde(rename = "DATA_SPLIT_METHOD_UNSPECIFIED")]
    DataSplitMethodUnspecified,
    #[serde(rename = "RANDOM")]
    Random,
    #[serde(rename = "CUSTOM")]
    Custom,
    #[serde(rename = "SEQUENTIAL")]
    Sequential,
    #[serde(rename = "NO_SPLIT")]
    NoSplit,
    #[serde(rename = "AUTO_SPLIT")]
    AutoSplit,
}

impl Default for DataSplitMethod {
    fn default() -> DataSplitMethod {
        Self::DataSplitMethodUnspecified
    }
}
/// Distance type for clustering models.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum DistanceType {
    #[serde(rename = "DISTANCE_TYPE_UNSPECIFIED")]
    DistanceTypeUnspecified,
    #[serde(rename = "EUCLIDEAN")]
    Euclidean,
    #[serde(rename = "COSINE")]
    Cosine,
}

impl Default for DistanceType {
    fn default() -> DistanceType {
        Self::DistanceTypeUnspecified
    }
}
/// Feedback type that specifies which algorithm to run for matrix factorization.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum FeedbackType {
    #[serde(rename = "FEEDBACK_TYPE_UNSPECIFIED")]
    FeedbackTypeUnspecified,
    #[serde(rename = "IMPLICIT")]
    Implicit,
    #[serde(rename = "EXPLICIT")]
    Explicit,
}

impl Default for FeedbackType {
    fn default() -> FeedbackType {
        Self::FeedbackTypeUnspecified
    }
}
/// The geographical region based on which the holidays are considered in time series modeling. If a valid value is specified, then holiday effects modeling is enabled.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum HolidayRegion {
    #[serde(rename = "HOLIDAY_REGION_UNSPECIFIED")]
    HolidayRegionUnspecified,
    #[serde(rename = "GLOBAL")]
    Global,
    #[serde(rename = "NA")]
    Na,
    #[serde(rename = "JAPAC")]
    Japac,
    #[serde(rename = "EMEA")]
    Emea,
    #[serde(rename = "LAC")]
    Lac,
    #[serde(rename = "AE")]
    Ae,
    #[serde(rename = "AR")]
    Ar,
    #[serde(rename = "AT")]
    At,
    #[serde(rename = "AU")]
    Au,
    #[serde(rename = "BE")]
    Be,
    #[serde(rename = "BR")]
    Br,
    #[serde(rename = "CA")]
    Ca,
    #[serde(rename = "CH")]
    Ch,
    #[serde(rename = "CL")]
    Cl,
    #[serde(rename = "CN")]
    Cn,
    #[serde(rename = "CO")]
    Co,
    #[serde(rename = "CS")]
    Cs,
    #[serde(rename = "CZ")]
    Cz,
    #[serde(rename = "DE")]
    De,
    #[serde(rename = "DK")]
    Dk,
    #[serde(rename = "DZ")]
    Dz,
    #[serde(rename = "EC")]
    Ec,
    #[serde(rename = "EE")]
    Ee,
    #[serde(rename = "EG")]
    Eg,
    #[serde(rename = "ES")]
    Es,
    #[serde(rename = "FI")]
    Fi,
    #[serde(rename = "FR")]
    Fr,
    #[serde(rename = "GB")]
    Gb,
    #[serde(rename = "GR")]
    Gr,
    #[serde(rename = "HK")]
    Hk,
    #[serde(rename = "HU")]
    Hu,
    #[serde(rename = "ID")]
    Id,
    #[serde(rename = "IE")]
    Ie,
    #[serde(rename = "IL")]
    Il,
    #[serde(rename = "IN")]
    In,
    #[serde(rename = "IR")]
    Ir,
    #[serde(rename = "IT")]
    It,
    #[serde(rename = "JP")]
    Jp,
    #[serde(rename = "KR")]
    Kr,
    #[serde(rename = "LV")]
    Lv,
    #[serde(rename = "MA")]
    Ma,
    #[serde(rename = "MX")]
    Mx,
    #[serde(rename = "MY")]
    My,
    #[serde(rename = "NG")]
    Ng,
    #[serde(rename = "NL")]
    Nl,
    #[serde(rename = "false")]
    False,
    #[serde(rename = "NZ")]
    Nz,
    #[serde(rename = "PE")]
    Pe,
    #[serde(rename = "PH")]
    Ph,
    #[serde(rename = "PK")]
    Pk,
    #[serde(rename = "PL")]
    Pl,
    #[serde(rename = "PT")]
    Pt,
    #[serde(rename = "RO")]
    Ro,
    #[serde(rename = "RS")]
    Rs,
    #[serde(rename = "RU")]
    Ru,
    #[serde(rename = "SA")]
    Sa,
    #[serde(rename = "SE")]
    Se,
    #[serde(rename = "SG")]
    Sg,
    #[serde(rename = "SI")]
    Si,
    #[serde(rename = "SK")]
    Sk,
    #[serde(rename = "TH")]
    Th,
    #[serde(rename = "TR")]
    Tr,
    #[serde(rename = "TW")]
    Tw,
    #[serde(rename = "UA")]
    Ua,
    #[serde(rename = "US")]
    Us,
    #[serde(rename = "VE")]
    Ve,
    #[serde(rename = "VN")]
    Vn,
    #[serde(rename = "ZA")]
    Za,
}

impl Default for HolidayRegion {
    fn default() -> HolidayRegion {
        Self::HolidayRegionUnspecified
    }
}
/// The target evaluation metrics to optimize the hyperparameters for.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum HparamTuningObjectives {
    #[serde(rename = "HPARAM_TUNING_OBJECTIVE_UNSPECIFIED")]
    HparamTuningObjectiveUnspecified,
    #[serde(rename = "MEAN_ABSOLUTE_ERROR")]
    MeanAbsoluteError,
    #[serde(rename = "MEAN_SQUARED_ERROR")]
    MeanSquaredError,
    #[serde(rename = "MEAN_SQUARED_LOG_ERROR")]
    MeanSquaredLogError,
    #[serde(rename = "MEDIAN_ABSOLUTE_ERROR")]
    MedianAbsoluteError,
    #[serde(rename = "R_SQUARED")]
    RSquared,
    #[serde(rename = "EXPLAINED_VARIANCE")]
    ExplainedVariance,
    #[serde(rename = "PRECISION")]
    Precision,
    #[serde(rename = "RECALL")]
    Recall,
    #[serde(rename = "ACCURACY")]
    Accuracy,
    #[serde(rename = "F1_SCORE")]
    F1Score,
    #[serde(rename = "LOG_LOSS")]
    LogLoss,
    #[serde(rename = "ROC_AUC")]
    RocAuc,
    #[serde(rename = "DAVIES_BOULDIN_INDEX")]
    DaviesBouldinIndex,
    #[serde(rename = "MEAN_AVERAGE_PRECISION")]
    MeanAveragePrecision,
    #[serde(rename = "NORMALIZED_DISCOUNTED_CUMULATIVE_GAIN")]
    NormalizedDiscountedCumulativeGain,
    #[serde(rename = "AVERAGE_RANK")]
    AverageRank,
}

impl Default for HparamTuningObjectives {
    fn default() -> HparamTuningObjectives {
        Self::HparamTuningObjectiveUnspecified
    }
}
/// The method used to initialize the centroids for kmeans algorithm.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum KmeansInitializationMethod {
    #[serde(rename = "KMEANS_INITIALIZATION_METHOD_UNSPECIFIED")]
    KmeansInitializationMethodUnspecified,
    #[serde(rename = "RANDOM")]
    Random,
    #[serde(rename = "CUSTOM")]
    Custom,
    #[serde(rename = "KMEANS_PLUS_PLUS")]
    KmeansPlusPlus,
}

impl Default for KmeansInitializationMethod {
    fn default() -> KmeansInitializationMethod {
        Self::KmeansInitializationMethodUnspecified
    }
}
/// The strategy to determine learn rate for the current iteration.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum LearnRateStrategy {
    #[serde(rename = "LEARN_RATE_STRATEGY_UNSPECIFIED")]
    LearnRateStrategyUnspecified,
    #[serde(rename = "LINE_SEARCH")]
    LineSearch,
    #[serde(rename = "CONSTANT")]
    Constant,
}

impl Default for LearnRateStrategy {
    fn default() -> LearnRateStrategy {
        Self::LearnRateStrategyUnspecified
    }
}
/// Type of loss function used during training run.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum LossType {
    #[serde(rename = "LOSS_TYPE_UNSPECIFIED")]
    LossTypeUnspecified,
    #[serde(rename = "MEAN_SQUARED_LOSS")]
    MeanSquaredLoss,
    #[serde(rename = "MEAN_LOG_LOSS")]
    MeanLogLoss,
}

impl Default for LossType {
    fn default() -> LossType {
        Self::LossTypeUnspecified
    }
}
/// Optimization strategy for training linear regression models.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum OptimizationStrategy {
    #[serde(rename = "OPTIMIZATION_STRATEGY_UNSPECIFIED")]
    OptimizationStrategyUnspecified,
    #[serde(rename = "BATCH_GRADIENT_DESCENT")]
    BatchGradientDescent,
    #[serde(rename = "NORMAL_EQUATION")]
    NormalEquation,
}

impl Default for OptimizationStrategy {
    fn default() -> OptimizationStrategy {
        Self::OptimizationStrategyUnspecified
    }
}
/// Tree construction algorithm for boosted tree models.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum TreeMethod {
    #[serde(rename = "TREE_METHOD_UNSPECIFIED")]
    TreeMethodUnspecified,
    #[serde(rename = "AUTO")]
    Auto,
    #[serde(rename = "EXACT")]
    Exact,
    #[serde(rename = "APPROX")]
    Approx,
    #[serde(rename = "HIST")]
    Hist,
}

impl Default for TreeMethod {
    fn default() -> TreeMethod {
        Self::TreeMethodUnspecified
    }
}
