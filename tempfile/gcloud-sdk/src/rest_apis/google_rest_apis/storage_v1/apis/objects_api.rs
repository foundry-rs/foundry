/*
 * Cloud Storage JSON API
 *
 * Stores and retrieves potentially large, immutable data objects.
 *
 * The version of the OpenAPI document: v1
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::google_rest_apis::storage_v1::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize};

/// struct for passing parameters to the method [`storage_objects_bulk_restore`]
#[derive(Clone, Debug, Default)]
pub struct StoragePeriodObjectsPeriodBulkRestoreParams {
    /// Name of the bucket in which the object resides.
    pub bucket: String,
    /// Data format for the response.
    pub alt: Option<String>,
    /// Selector specifying which fields to include in a partial response.
    pub fields: Option<String>,
    /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    pub key: Option<String>,
    /// OAuth 2.0 token for the current user.
    pub oauth_token: Option<String>,
    /// Returns response with indentations and line breaks.
    pub pretty_print: Option<bool>,
    /// An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
    pub quota_user: Option<String>,
    /// Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
    pub upload_type: Option<String>,
    /// Deprecated. Please use quotaUser instead.
    pub user_ip: Option<String>,
    pub bulk_restore_objects_request: Option<models::BulkRestoreObjectsRequest>,
}

/// struct for passing parameters to the method [`storage_objects_compose`]
#[derive(Clone, Debug, Default)]
pub struct StoragePeriodObjectsPeriodComposeParams {
    /// Name of the bucket containing the source objects. The destination object is stored in this bucket.
    pub destination_bucket: String,
    /// Name of the new object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
    pub destination_object: String,
    /// Data format for the response.
    pub alt: Option<String>,
    /// Selector specifying which fields to include in a partial response.
    pub fields: Option<String>,
    /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    pub key: Option<String>,
    /// OAuth 2.0 token for the current user.
    pub oauth_token: Option<String>,
    /// Returns response with indentations and line breaks.
    pub pretty_print: Option<bool>,
    /// An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
    pub quota_user: Option<String>,
    /// Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
    pub upload_type: Option<String>,
    /// Deprecated. Please use quotaUser instead.
    pub user_ip: Option<String>,
    /// Apply a predefined set of access controls to the destination object.
    pub destination_predefined_acl: Option<String>,
    /// Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
    pub if_generation_match: Option<String>,
    /// Makes the operation conditional on whether the object's current metageneration matches the given value.
    pub if_metageneration_match: Option<String>,
    /// Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
    pub kms_key_name: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays buckets.
    pub user_project: Option<String>,
    pub compose_request: Option<models::ComposeRequest>,
}

/// struct for passing parameters to the method [`storage_objects_copy`]
#[derive(Clone, Debug, Default)]
pub struct StoragePeriodObjectsPeriodCopyParams {
    /// Name of the bucket in which to find the source object.
    pub source_bucket: String,
    /// Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
    pub source_object: String,
    /// Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
    pub destination_bucket: String,
    /// Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any.
    pub destination_object: String,
    /// Data format for the response.
    pub alt: Option<String>,
    /// Selector specifying which fields to include in a partial response.
    pub fields: Option<String>,
    /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    pub key: Option<String>,
    /// OAuth 2.0 token for the current user.
    pub oauth_token: Option<String>,
    /// Returns response with indentations and line breaks.
    pub pretty_print: Option<bool>,
    /// An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
    pub quota_user: Option<String>,
    /// Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
    pub upload_type: Option<String>,
    /// Deprecated. Please use quotaUser instead.
    pub user_ip: Option<String>,
    /// Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
    pub destination_kms_key_name: Option<String>,
    /// Apply a predefined set of access controls to the destination object.
    pub destination_predefined_acl: Option<String>,
    /// Makes the operation conditional on whether the destination object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
    pub if_generation_match: Option<String>,
    /// Makes the operation conditional on whether the destination object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
    pub if_generation_not_match: Option<String>,
    /// Makes the operation conditional on whether the destination object's current metageneration matches the given value.
    pub if_metageneration_match: Option<String>,
    /// Makes the operation conditional on whether the destination object's current metageneration does not match the given value.
    pub if_metageneration_not_match: Option<String>,
    /// Makes the operation conditional on whether the source object's current generation matches the given value.
    pub if_source_generation_match: Option<String>,
    /// Makes the operation conditional on whether the source object's current generation does not match the given value.
    pub if_source_generation_not_match: Option<String>,
    /// Makes the operation conditional on whether the source object's current metageneration matches the given value.
    pub if_source_metageneration_match: Option<String>,
    /// Makes the operation conditional on whether the source object's current metageneration does not match the given value.
    pub if_source_metageneration_not_match: Option<String>,
    /// Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.
    pub projection: Option<String>,
    /// If present, selects a specific revision of the source object (as opposed to the latest version, the default).
    pub source_generation: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays buckets.
    pub user_project: Option<String>,
    pub object: Option<models::Object>,
}

/// struct for passing parameters to the method [`storage_objects_delete`]
#[derive(Clone, Debug, Default)]
pub struct StoragePeriodObjectsPeriodDeleteParams {
    /// Name of the bucket in which the object resides.
    pub bucket: String,
    /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
    pub object: String,
    /// Data format for the response.
    pub alt: Option<String>,
    /// Selector specifying which fields to include in a partial response.
    pub fields: Option<String>,
    /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    pub key: Option<String>,
    /// OAuth 2.0 token for the current user.
    pub oauth_token: Option<String>,
    /// Returns response with indentations and line breaks.
    pub pretty_print: Option<bool>,
    /// An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
    pub quota_user: Option<String>,
    /// Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
    pub upload_type: Option<String>,
    /// Deprecated. Please use quotaUser instead.
    pub user_ip: Option<String>,
    /// If present, permanently deletes a specific revision of this object (as opposed to the latest version, the default).
    pub generation: Option<String>,
    /// Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
    pub if_generation_match: Option<String>,
    /// Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
    pub if_generation_not_match: Option<String>,
    /// Makes the operation conditional on whether the object's current metageneration matches the given value.
    pub if_metageneration_match: Option<String>,
    /// Makes the operation conditional on whether the object's current metageneration does not match the given value.
    pub if_metageneration_not_match: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays buckets.
    pub user_project: Option<String>,
}

/// struct for passing parameters to the method [`storage_objects_get`]
#[derive(Clone, Debug, Default)]
pub struct StoragePeriodObjectsPeriodGetParams {
    /// Name of the bucket in which the object resides.
    pub bucket: String,
    /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
    pub object: String,
    /// Data format for the response.
    pub alt: Option<String>,
    /// Selector specifying which fields to include in a partial response.
    pub fields: Option<String>,
    /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    pub key: Option<String>,
    /// OAuth 2.0 token for the current user.
    pub oauth_token: Option<String>,
    /// Returns response with indentations and line breaks.
    pub pretty_print: Option<bool>,
    /// An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
    pub quota_user: Option<String>,
    /// Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
    pub upload_type: Option<String>,
    /// Deprecated. Please use quotaUser instead.
    pub user_ip: Option<String>,
    /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
    pub generation: Option<String>,
    /// Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
    pub if_generation_match: Option<String>,
    /// Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
    pub if_generation_not_match: Option<String>,
    /// Makes the operation conditional on whether the object's current metageneration matches the given value.
    pub if_metageneration_match: Option<String>,
    /// Makes the operation conditional on whether the object's current metageneration does not match the given value.
    pub if_metageneration_not_match: Option<String>,
    /// Set of properties to return. Defaults to noAcl.
    pub projection: Option<String>,
    /// If true, only soft-deleted object versions will be listed. The default is false. For more information, see Soft Delete.
    pub soft_deleted: Option<bool>,
    /// The project to be billed for this request. Required for Requester Pays buckets.
    pub user_project: Option<String>,
}

/// struct for passing parameters to the method [`storage_objects_get_iam_policy`]
#[derive(Clone, Debug, Default)]
pub struct StoragePeriodObjectsPeriodGetIamPolicyParams {
    /// Name of the bucket in which the object resides.
    pub bucket: String,
    /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
    pub object: String,
    /// Data format for the response.
    pub alt: Option<String>,
    /// Selector specifying which fields to include in a partial response.
    pub fields: Option<String>,
    /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    pub key: Option<String>,
    /// OAuth 2.0 token for the current user.
    pub oauth_token: Option<String>,
    /// Returns response with indentations and line breaks.
    pub pretty_print: Option<bool>,
    /// An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
    pub quota_user: Option<String>,
    /// Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
    pub upload_type: Option<String>,
    /// Deprecated. Please use quotaUser instead.
    pub user_ip: Option<String>,
    /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
    pub generation: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays buckets.
    pub user_project: Option<String>,
}

/// struct for passing parameters to the method [`storage_objects_insert`]
#[derive(Clone, Debug, Default)]
pub struct StoragePeriodObjectsPeriodInsertParams {
    /// Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.
    pub bucket: String,
    /// Data format for the response.
    pub alt: Option<String>,
    /// Selector specifying which fields to include in a partial response.
    pub fields: Option<String>,
    /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    pub key: Option<String>,
    /// OAuth 2.0 token for the current user.
    pub oauth_token: Option<String>,
    /// Returns response with indentations and line breaks.
    pub pretty_print: Option<bool>,
    /// An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
    pub quota_user: Option<String>,
    /// Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
    pub upload_type: Option<String>,
    /// Deprecated. Please use quotaUser instead.
    pub user_ip: Option<String>,
    /// If set, sets the contentEncoding property of the final object to this value. Setting this parameter is equivalent to setting the contentEncoding metadata property. This can be useful when uploading an object with uploadType=media to indicate the encoding of the content being uploaded.
    pub content_encoding: Option<String>,
    /// Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
    pub if_generation_match: Option<String>,
    /// Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
    pub if_generation_not_match: Option<String>,
    /// Makes the operation conditional on whether the object's current metageneration matches the given value.
    pub if_metageneration_match: Option<String>,
    /// Makes the operation conditional on whether the object's current metageneration does not match the given value.
    pub if_metageneration_not_match: Option<String>,
    /// Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
    pub kms_key_name: Option<String>,
    /// Name of the object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
    pub name: Option<String>,
    /// Apply a predefined set of access controls to this object.
    pub predefined_acl: Option<String>,
    /// Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.
    pub projection: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays buckets.
    pub user_project: Option<String>,
    pub object: Option<models::Object>,
}

/// struct for passing parameters to the method [`storage_objects_list`]
#[derive(Clone, Debug, Default)]
pub struct StoragePeriodObjectsPeriodListParams {
    /// Name of the bucket in which to look for objects.
    pub bucket: String,
    /// Data format for the response.
    pub alt: Option<String>,
    /// Selector specifying which fields to include in a partial response.
    pub fields: Option<String>,
    /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    pub key: Option<String>,
    /// OAuth 2.0 token for the current user.
    pub oauth_token: Option<String>,
    /// Returns response with indentations and line breaks.
    pub pretty_print: Option<bool>,
    /// An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
    pub quota_user: Option<String>,
    /// Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
    pub upload_type: Option<String>,
    /// Deprecated. Please use quotaUser instead.
    pub user_ip: Option<String>,
    /// Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.
    pub delimiter: Option<String>,
    /// Filter results to objects whose names are lexicographically before endOffset. If startOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
    pub end_offset: Option<String>,
    /// Only applicable if delimiter is set to '/'. If true, will also include folders and managed folders (besides objects) in the returned prefixes.
    pub include_folders_as_prefixes: Option<bool>,
    /// If true, objects that end in exactly one instance of delimiter will have their metadata included in items in addition to prefixes.
    pub include_trailing_delimiter: Option<bool>,
    /// Filter results to objects and prefixes that match this glob pattern.
    pub match_glob: Option<String>,
    /// Maximum number of items plus prefixes to return in a single page of responses. As duplicate prefixes are omitted, fewer total results may be returned than requested. The service will use this parameter or 1,000 items, whichever is smaller.
    pub max_results: Option<i32>,
    /// A previously-returned page token representing part of the larger set of results to view.
    pub page_token: Option<String>,
    /// Filter results to objects whose names begin with this prefix.
    pub prefix: Option<String>,
    /// Set of properties to return. Defaults to noAcl.
    pub projection: Option<String>,
    /// If true, only soft-deleted object versions will be listed. The default is false. For more information, see Soft Delete.
    pub soft_deleted: Option<bool>,
    /// Filter results to objects whose names are lexicographically equal to or after startOffset. If endOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
    pub start_offset: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays buckets.
    pub user_project: Option<String>,
    /// If true, lists all versions of an object as distinct results. The default is false. For more information, see Object Versioning.
    pub versions: Option<bool>,
}

/// struct for passing parameters to the method [`storage_objects_patch`]
#[derive(Clone, Debug, Default)]
pub struct StoragePeriodObjectsPeriodPatchParams {
    /// Name of the bucket in which the object resides.
    pub bucket: String,
    /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
    pub object: String,
    /// Data format for the response.
    pub alt: Option<String>,
    /// Selector specifying which fields to include in a partial response.
    pub fields: Option<String>,
    /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    pub key: Option<String>,
    /// OAuth 2.0 token for the current user.
    pub oauth_token: Option<String>,
    /// Returns response with indentations and line breaks.
    pub pretty_print: Option<bool>,
    /// An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
    pub quota_user: Option<String>,
    /// Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
    pub upload_type: Option<String>,
    /// Deprecated. Please use quotaUser instead.
    pub user_ip: Option<String>,
    /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
    pub generation: Option<String>,
    /// Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
    pub if_generation_match: Option<String>,
    /// Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
    pub if_generation_not_match: Option<String>,
    /// Makes the operation conditional on whether the object's current metageneration matches the given value.
    pub if_metageneration_match: Option<String>,
    /// Makes the operation conditional on whether the object's current metageneration does not match the given value.
    pub if_metageneration_not_match: Option<String>,
    /// Must be true to remove the retention configuration, reduce its unlocked retention period, or change its mode from unlocked to locked.
    pub override_unlocked_retention: Option<bool>,
    /// Apply a predefined set of access controls to this object.
    pub predefined_acl: Option<String>,
    /// Set of properties to return. Defaults to full.
    pub projection: Option<String>,
    /// The project to be billed for this request, for Requester Pays buckets.
    pub user_project: Option<String>,
    pub object2: Option<models::Object>,
}

/// struct for passing parameters to the method [`storage_objects_restore`]
#[derive(Clone, Debug, Default)]
pub struct StoragePeriodObjectsPeriodRestoreParams {
    /// Name of the bucket in which the object resides.
    pub bucket: String,
    /// Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    pub object: String,
    /// Selects a specific revision of this object.
    pub generation: String,
    /// Data format for the response.
    pub alt: Option<String>,
    /// Selector specifying which fields to include in a partial response.
    pub fields: Option<String>,
    /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    pub key: Option<String>,
    /// OAuth 2.0 token for the current user.
    pub oauth_token: Option<String>,
    /// Returns response with indentations and line breaks.
    pub pretty_print: Option<bool>,
    /// An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
    pub quota_user: Option<String>,
    /// Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
    pub upload_type: Option<String>,
    /// Deprecated. Please use quotaUser instead.
    pub user_ip: Option<String>,
    /// If true, copies the source object's ACL; otherwise, uses the bucket's default object ACL. The default is false.
    pub copy_source_acl: Option<bool>,
    /// Makes the operation conditional on whether the object's one live generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
    pub if_generation_match: Option<String>,
    /// Makes the operation conditional on whether none of the object's live generations match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
    pub if_generation_not_match: Option<String>,
    /// Makes the operation conditional on whether the object's one live metageneration matches the given value.
    pub if_metageneration_match: Option<String>,
    /// Makes the operation conditional on whether none of the object's live metagenerations match the given value.
    pub if_metageneration_not_match: Option<String>,
    /// Set of properties to return. Defaults to full.
    pub projection: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays buckets.
    pub user_project: Option<String>,
    pub object2: Option<models::Object>,
}

/// struct for passing parameters to the method [`storage_objects_rewrite`]
#[derive(Clone, Debug, Default)]
pub struct StoragePeriodObjectsPeriodRewriteParams {
    /// Name of the bucket in which to find the source object.
    pub source_bucket: String,
    /// Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
    pub source_object: String,
    /// Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.
    pub destination_bucket: String,
    /// Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
    pub destination_object: String,
    /// Data format for the response.
    pub alt: Option<String>,
    /// Selector specifying which fields to include in a partial response.
    pub fields: Option<String>,
    /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    pub key: Option<String>,
    /// OAuth 2.0 token for the current user.
    pub oauth_token: Option<String>,
    /// Returns response with indentations and line breaks.
    pub pretty_print: Option<bool>,
    /// An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
    pub quota_user: Option<String>,
    /// Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
    pub upload_type: Option<String>,
    /// Deprecated. Please use quotaUser instead.
    pub user_ip: Option<String>,
    /// Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
    pub destination_kms_key_name: Option<String>,
    /// Apply a predefined set of access controls to the destination object.
    pub destination_predefined_acl: Option<String>,
    /// Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
    pub if_generation_match: Option<String>,
    /// Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
    pub if_generation_not_match: Option<String>,
    /// Makes the operation conditional on whether the destination object's current metageneration matches the given value.
    pub if_metageneration_match: Option<String>,
    /// Makes the operation conditional on whether the destination object's current metageneration does not match the given value.
    pub if_metageneration_not_match: Option<String>,
    /// Makes the operation conditional on whether the source object's current generation matches the given value.
    pub if_source_generation_match: Option<String>,
    /// Makes the operation conditional on whether the source object's current generation does not match the given value.
    pub if_source_generation_not_match: Option<String>,
    /// Makes the operation conditional on whether the source object's current metageneration matches the given value.
    pub if_source_metageneration_match: Option<String>,
    /// Makes the operation conditional on whether the source object's current metageneration does not match the given value.
    pub if_source_metageneration_not_match: Option<String>,
    /// The maximum number of bytes that will be rewritten per rewrite request. Most callers shouldn't need to specify this parameter - it is primarily in place to support testing. If specified the value must be an integral multiple of 1 MiB (1048576). Also, this only applies to requests where the source and destination span locations and/or storage classes. Finally, this value must not change across rewrite calls else you'll get an error that the rewriteToken is invalid.
    pub max_bytes_rewritten_per_call: Option<String>,
    /// Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.
    pub projection: Option<String>,
    /// Include this field (from the previous rewrite response) on each rewrite request after the first one, until the rewrite response 'done' flag is true. Calls that provide a rewriteToken can omit all other request fields, but if included those fields must match the values provided in the first rewrite request.
    pub rewrite_token: Option<String>,
    /// If present, selects a specific revision of the source object (as opposed to the latest version, the default).
    pub source_generation: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays buckets.
    pub user_project: Option<String>,
    pub object: Option<models::Object>,
}

/// struct for passing parameters to the method [`storage_objects_set_iam_policy`]
#[derive(Clone, Debug, Default)]
pub struct StoragePeriodObjectsPeriodSetIamPolicyParams {
    /// Name of the bucket in which the object resides.
    pub bucket: String,
    /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
    pub object: String,
    /// Data format for the response.
    pub alt: Option<String>,
    /// Selector specifying which fields to include in a partial response.
    pub fields: Option<String>,
    /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    pub key: Option<String>,
    /// OAuth 2.0 token for the current user.
    pub oauth_token: Option<String>,
    /// Returns response with indentations and line breaks.
    pub pretty_print: Option<bool>,
    /// An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
    pub quota_user: Option<String>,
    /// Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
    pub upload_type: Option<String>,
    /// Deprecated. Please use quotaUser instead.
    pub user_ip: Option<String>,
    /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
    pub generation: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays buckets.
    pub user_project: Option<String>,
    pub policy: Option<models::Policy>,
}

/// struct for passing parameters to the method [`storage_objects_test_iam_permissions`]
#[derive(Clone, Debug, Default)]
pub struct StoragePeriodObjectsPeriodTestIamPermissionsParams {
    /// Name of the bucket in which the object resides.
    pub bucket: String,
    /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
    pub object: String,
    /// Permissions to test.
    pub permissions: Vec<String>,
    /// Data format for the response.
    pub alt: Option<String>,
    /// Selector specifying which fields to include in a partial response.
    pub fields: Option<String>,
    /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    pub key: Option<String>,
    /// OAuth 2.0 token for the current user.
    pub oauth_token: Option<String>,
    /// Returns response with indentations and line breaks.
    pub pretty_print: Option<bool>,
    /// An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
    pub quota_user: Option<String>,
    /// Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
    pub upload_type: Option<String>,
    /// Deprecated. Please use quotaUser instead.
    pub user_ip: Option<String>,
    /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
    pub generation: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays buckets.
    pub user_project: Option<String>,
}

/// struct for passing parameters to the method [`storage_objects_update`]
#[derive(Clone, Debug, Default)]
pub struct StoragePeriodObjectsPeriodUpdateParams {
    /// Name of the bucket in which the object resides.
    pub bucket: String,
    /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
    pub object: String,
    /// Data format for the response.
    pub alt: Option<String>,
    /// Selector specifying which fields to include in a partial response.
    pub fields: Option<String>,
    /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    pub key: Option<String>,
    /// OAuth 2.0 token for the current user.
    pub oauth_token: Option<String>,
    /// Returns response with indentations and line breaks.
    pub pretty_print: Option<bool>,
    /// An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
    pub quota_user: Option<String>,
    /// Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
    pub upload_type: Option<String>,
    /// Deprecated. Please use quotaUser instead.
    pub user_ip: Option<String>,
    /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
    pub generation: Option<String>,
    /// Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
    pub if_generation_match: Option<String>,
    /// Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
    pub if_generation_not_match: Option<String>,
    /// Makes the operation conditional on whether the object's current metageneration matches the given value.
    pub if_metageneration_match: Option<String>,
    /// Makes the operation conditional on whether the object's current metageneration does not match the given value.
    pub if_metageneration_not_match: Option<String>,
    /// Must be true to remove the retention configuration, reduce its unlocked retention period, or change its mode from unlocked to locked.
    pub override_unlocked_retention: Option<bool>,
    /// Apply a predefined set of access controls to this object.
    pub predefined_acl: Option<String>,
    /// Set of properties to return. Defaults to full.
    pub projection: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays buckets.
    pub user_project: Option<String>,
    pub object2: Option<models::Object>,
}

/// struct for passing parameters to the method [`storage_objects_watch_all`]
#[derive(Clone, Debug, Default)]
pub struct StoragePeriodObjectsPeriodWatchAllParams {
    /// Name of the bucket in which to look for objects.
    pub bucket: String,
    /// Data format for the response.
    pub alt: Option<String>,
    /// Selector specifying which fields to include in a partial response.
    pub fields: Option<String>,
    /// API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
    pub key: Option<String>,
    /// OAuth 2.0 token for the current user.
    pub oauth_token: Option<String>,
    /// Returns response with indentations and line breaks.
    pub pretty_print: Option<bool>,
    /// An opaque string that represents a user for quota purposes. Must not exceed 40 characters.
    pub quota_user: Option<String>,
    /// Upload protocol for media (e.g. \"media\", \"multipart\", \"resumable\").
    pub upload_type: Option<String>,
    /// Deprecated. Please use quotaUser instead.
    pub user_ip: Option<String>,
    /// Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.
    pub delimiter: Option<String>,
    /// Filter results to objects whose names are lexicographically before endOffset. If startOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
    pub end_offset: Option<String>,
    /// If true, objects that end in exactly one instance of delimiter will have their metadata included in items in addition to prefixes.
    pub include_trailing_delimiter: Option<bool>,
    /// Maximum number of items plus prefixes to return in a single page of responses. As duplicate prefixes are omitted, fewer total results may be returned than requested. The service will use this parameter or 1,000 items, whichever is smaller.
    pub max_results: Option<i32>,
    /// A previously-returned page token representing part of the larger set of results to view.
    pub page_token: Option<String>,
    /// Filter results to objects whose names begin with this prefix.
    pub prefix: Option<String>,
    /// Set of properties to return. Defaults to noAcl.
    pub projection: Option<String>,
    /// Filter results to objects whose names are lexicographically equal to or after startOffset. If endOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
    pub start_offset: Option<String>,
    /// The project to be billed for this request. Required for Requester Pays buckets.
    pub user_project: Option<String>,
    /// If true, lists all versions of an object as distinct results. The default is false. For more information, see Object Versioning.
    pub versions: Option<bool>,
    pub channel: Option<models::Channel>,
}

/// struct for typed errors of method [`storage_objects_bulk_restore`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePeriodObjectsPeriodBulkRestoreError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_objects_compose`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePeriodObjectsPeriodComposeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_objects_copy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePeriodObjectsPeriodCopyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_objects_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePeriodObjectsPeriodDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_objects_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePeriodObjectsPeriodGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_objects_get_iam_policy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePeriodObjectsPeriodGetIamPolicyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_objects_insert`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePeriodObjectsPeriodInsertError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_objects_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePeriodObjectsPeriodListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_objects_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePeriodObjectsPeriodPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_objects_restore`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePeriodObjectsPeriodRestoreError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_objects_rewrite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePeriodObjectsPeriodRewriteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_objects_set_iam_policy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePeriodObjectsPeriodSetIamPolicyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_objects_test_iam_permissions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePeriodObjectsPeriodTestIamPermissionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_objects_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePeriodObjectsPeriodUpdateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`storage_objects_watch_all`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StoragePeriodObjectsPeriodWatchAllError {
    UnknownValue(serde_json::Value),
}

/// Initiates a long-running bulk restore operation on the specified bucket.
pub async fn storage_objects_bulk_restore(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodBulkRestoreParams,
) -> Result<models::GoogleLongrunningOperation, Error<StoragePeriodObjectsPeriodBulkRestoreError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let alt = params.alt;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let bulk_restore_objects_request = params.bulk_restore_objects_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/b/{bucket}/o/bulkRestore",
        local_var_configuration.base_path,
        bucket = crate::google_rest_apis::storage_v1::apis::urlencode(bucket)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = alt {
        local_var_req_builder = local_var_req_builder.query(&[("alt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&bulk_restore_objects_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StoragePeriodObjectsPeriodBulkRestoreError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Concatenates a list of existing objects into a new object in the same bucket.
pub async fn storage_objects_compose(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodComposeParams,
) -> Result<models::Object, Error<StoragePeriodObjectsPeriodComposeError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let destination_bucket = params.destination_bucket;
    let destination_object = params.destination_object;
    let alt = params.alt;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let destination_predefined_acl = params.destination_predefined_acl;
    let if_generation_match = params.if_generation_match;
    let if_metageneration_match = params.if_metageneration_match;
    let kms_key_name = params.kms_key_name;
    let user_project = params.user_project;
    let compose_request = params.compose_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/b/{destinationBucket}/o/{destinationObject}/compose",
        local_var_configuration.base_path,
        destinationBucket =
            crate::google_rest_apis::storage_v1::apis::urlencode(destination_bucket),
        destinationObject =
            crate::google_rest_apis::storage_v1::apis::urlencode(destination_object)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = alt {
        local_var_req_builder = local_var_req_builder.query(&[("alt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = destination_predefined_acl {
        local_var_req_builder = local_var_req_builder
            .query(&[("destinationPredefinedAcl", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifMetagenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = kms_key_name {
        local_var_req_builder =
            local_var_req_builder.query(&[("kmsKeyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&compose_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StoragePeriodObjectsPeriodComposeError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Copies a source object to a destination object. Optionally overrides metadata.
pub async fn storage_objects_copy(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodCopyParams,
) -> Result<models::Object, Error<StoragePeriodObjectsPeriodCopyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let source_bucket = params.source_bucket;
    let source_object = params.source_object;
    let destination_bucket = params.destination_bucket;
    let destination_object = params.destination_object;
    let alt = params.alt;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let destination_kms_key_name = params.destination_kms_key_name;
    let destination_predefined_acl = params.destination_predefined_acl;
    let if_generation_match = params.if_generation_match;
    let if_generation_not_match = params.if_generation_not_match;
    let if_metageneration_match = params.if_metageneration_match;
    let if_metageneration_not_match = params.if_metageneration_not_match;
    let if_source_generation_match = params.if_source_generation_match;
    let if_source_generation_not_match = params.if_source_generation_not_match;
    let if_source_metageneration_match = params.if_source_metageneration_match;
    let if_source_metageneration_not_match = params.if_source_metageneration_not_match;
    let projection = params.projection;
    let source_generation = params.source_generation;
    let user_project = params.user_project;
    let object = params.object;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/b/{sourceBucket}/o/{sourceObject}/copyTo/b/{destinationBucket}/o/{destinationObject}",
        local_var_configuration.base_path,
        sourceBucket = crate::google_rest_apis::storage_v1::apis::urlencode(source_bucket),
        sourceObject = crate::google_rest_apis::storage_v1::apis::urlencode(source_object),
        destinationBucket =
            crate::google_rest_apis::storage_v1::apis::urlencode(destination_bucket),
        destinationObject =
            crate::google_rest_apis::storage_v1::apis::urlencode(destination_object)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = alt {
        local_var_req_builder = local_var_req_builder.query(&[("alt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = destination_kms_key_name {
        local_var_req_builder =
            local_var_req_builder.query(&[("destinationKmsKeyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = destination_predefined_acl {
        local_var_req_builder = local_var_req_builder
            .query(&[("destinationPredefinedAcl", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_not_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifMetagenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_not_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifMetagenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_source_generation_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifSourceGenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_source_generation_not_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifSourceGenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_source_metageneration_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifSourceMetagenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_source_metageneration_not_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifSourceMetagenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = projection {
        local_var_req_builder =
            local_var_req_builder.query(&[("projection", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = source_generation {
        local_var_req_builder =
            local_var_req_builder.query(&[("sourceGeneration", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&object);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StoragePeriodObjectsPeriodCopyError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes an object and its metadata. Deletions are permanent if versioning is not enabled for the bucket, or if the generation parameter is used.
pub async fn storage_objects_delete(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodDeleteParams,
) -> Result<(), Error<StoragePeriodObjectsPeriodDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let object = params.object;
    let alt = params.alt;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let generation = params.generation;
    let if_generation_match = params.if_generation_match;
    let if_generation_not_match = params.if_generation_not_match;
    let if_metageneration_match = params.if_metageneration_match;
    let if_metageneration_not_match = params.if_metageneration_not_match;
    let user_project = params.user_project;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/b/{bucket}/o/{object}",
        local_var_configuration.base_path,
        bucket = crate::google_rest_apis::storage_v1::apis::urlencode(bucket),
        object = crate::google_rest_apis::storage_v1::apis::urlencode(object)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = alt {
        local_var_req_builder = local_var_req_builder.query(&[("alt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = generation {
        local_var_req_builder =
            local_var_req_builder.query(&[("generation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_not_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifMetagenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_not_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifMetagenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<StoragePeriodObjectsPeriodDeleteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves an object or its metadata.
pub async fn storage_objects_get(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodGetParams,
) -> Result<models::Object, Error<StoragePeriodObjectsPeriodGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let object = params.object;
    let alt = params.alt;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let generation = params.generation;
    let if_generation_match = params.if_generation_match;
    let if_generation_not_match = params.if_generation_not_match;
    let if_metageneration_match = params.if_metageneration_match;
    let if_metageneration_not_match = params.if_metageneration_not_match;
    let projection = params.projection;
    let soft_deleted = params.soft_deleted;
    let user_project = params.user_project;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/b/{bucket}/o/{object}",
        local_var_configuration.base_path,
        bucket = crate::google_rest_apis::storage_v1::apis::urlencode(bucket),
        object = crate::google_rest_apis::storage_v1::apis::urlencode(object)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = alt {
        local_var_req_builder = local_var_req_builder.query(&[("alt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = generation {
        local_var_req_builder =
            local_var_req_builder.query(&[("generation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_not_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifMetagenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_not_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifMetagenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = projection {
        local_var_req_builder =
            local_var_req_builder.query(&[("projection", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = soft_deleted {
        local_var_req_builder =
            local_var_req_builder.query(&[("softDeleted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StoragePeriodObjectsPeriodGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns an IAM policy for the specified object.
pub async fn storage_objects_get_iam_policy(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodGetIamPolicyParams,
) -> Result<models::Policy, Error<StoragePeriodObjectsPeriodGetIamPolicyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let object = params.object;
    let alt = params.alt;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let generation = params.generation;
    let user_project = params.user_project;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/b/{bucket}/o/{object}/iam",
        local_var_configuration.base_path,
        bucket = crate::google_rest_apis::storage_v1::apis::urlencode(bucket),
        object = crate::google_rest_apis::storage_v1::apis::urlencode(object)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = alt {
        local_var_req_builder = local_var_req_builder.query(&[("alt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = generation {
        local_var_req_builder =
            local_var_req_builder.query(&[("generation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StoragePeriodObjectsPeriodGetIamPolicyError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Stores a new object and metadata.
pub async fn storage_objects_insert(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodInsertParams,
) -> Result<models::Object, Error<StoragePeriodObjectsPeriodInsertError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let alt = params.alt;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let content_encoding = params.content_encoding;
    let if_generation_match = params.if_generation_match;
    let if_generation_not_match = params.if_generation_not_match;
    let if_metageneration_match = params.if_metageneration_match;
    let if_metageneration_not_match = params.if_metageneration_not_match;
    let kms_key_name = params.kms_key_name;
    let name = params.name;
    let predefined_acl = params.predefined_acl;
    let projection = params.projection;
    let user_project = params.user_project;
    let object = params.object;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/b/{bucket}/o",
        local_var_configuration.base_path,
        bucket = crate::google_rest_apis::storage_v1::apis::urlencode(bucket)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = alt {
        local_var_req_builder = local_var_req_builder.query(&[("alt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = content_encoding {
        local_var_req_builder =
            local_var_req_builder.query(&[("contentEncoding", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_not_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifMetagenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_not_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifMetagenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = kms_key_name {
        local_var_req_builder =
            local_var_req_builder.query(&[("kmsKeyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = name {
        local_var_req_builder =
            local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = predefined_acl {
        local_var_req_builder =
            local_var_req_builder.query(&[("predefinedAcl", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = projection {
        local_var_req_builder =
            local_var_req_builder.query(&[("projection", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&object);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StoragePeriodObjectsPeriodInsertError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves a list of objects matching the criteria.
pub async fn storage_objects_list(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodListParams,
) -> Result<models::Objects, Error<StoragePeriodObjectsPeriodListError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let alt = params.alt;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let delimiter = params.delimiter;
    let end_offset = params.end_offset;
    let include_folders_as_prefixes = params.include_folders_as_prefixes;
    let include_trailing_delimiter = params.include_trailing_delimiter;
    let match_glob = params.match_glob;
    let max_results = params.max_results;
    let page_token = params.page_token;
    let prefix = params.prefix;
    let projection = params.projection;
    let soft_deleted = params.soft_deleted;
    let start_offset = params.start_offset;
    let user_project = params.user_project;
    let versions = params.versions;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/b/{bucket}/o",
        local_var_configuration.base_path,
        bucket = crate::google_rest_apis::storage_v1::apis::urlencode(bucket)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = alt {
        local_var_req_builder = local_var_req_builder.query(&[("alt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = delimiter {
        local_var_req_builder =
            local_var_req_builder.query(&[("delimiter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_offset {
        local_var_req_builder =
            local_var_req_builder.query(&[("endOffset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_folders_as_prefixes {
        local_var_req_builder = local_var_req_builder
            .query(&[("includeFoldersAsPrefixes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_trailing_delimiter {
        local_var_req_builder = local_var_req_builder
            .query(&[("includeTrailingDelimiter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = match_glob {
        local_var_req_builder =
            local_var_req_builder.query(&[("matchGlob", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_results {
        local_var_req_builder =
            local_var_req_builder.query(&[("maxResults", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("pageToken", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = prefix {
        local_var_req_builder =
            local_var_req_builder.query(&[("prefix", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = projection {
        local_var_req_builder =
            local_var_req_builder.query(&[("projection", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = soft_deleted {
        local_var_req_builder =
            local_var_req_builder.query(&[("softDeleted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_offset {
        local_var_req_builder =
            local_var_req_builder.query(&[("startOffset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = versions {
        local_var_req_builder =
            local_var_req_builder.query(&[("versions", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StoragePeriodObjectsPeriodListError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Patches an object's metadata.
pub async fn storage_objects_patch(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodPatchParams,
) -> Result<models::Object, Error<StoragePeriodObjectsPeriodPatchError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let object = params.object;
    let alt = params.alt;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let generation = params.generation;
    let if_generation_match = params.if_generation_match;
    let if_generation_not_match = params.if_generation_not_match;
    let if_metageneration_match = params.if_metageneration_match;
    let if_metageneration_not_match = params.if_metageneration_not_match;
    let override_unlocked_retention = params.override_unlocked_retention;
    let predefined_acl = params.predefined_acl;
    let projection = params.projection;
    let user_project = params.user_project;
    let object2 = params.object2;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/b/{bucket}/o/{object}",
        local_var_configuration.base_path,
        bucket = crate::google_rest_apis::storage_v1::apis::urlencode(bucket),
        object = crate::google_rest_apis::storage_v1::apis::urlencode(object)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = alt {
        local_var_req_builder = local_var_req_builder.query(&[("alt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = generation {
        local_var_req_builder =
            local_var_req_builder.query(&[("generation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_not_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifMetagenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_not_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifMetagenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = override_unlocked_retention {
        local_var_req_builder = local_var_req_builder
            .query(&[("overrideUnlockedRetention", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = predefined_acl {
        local_var_req_builder =
            local_var_req_builder.query(&[("predefinedAcl", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = projection {
        local_var_req_builder =
            local_var_req_builder.query(&[("projection", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&object2);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StoragePeriodObjectsPeriodPatchError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Restores a soft-deleted object.
pub async fn storage_objects_restore(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodRestoreParams,
) -> Result<models::Object, Error<StoragePeriodObjectsPeriodRestoreError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let object = params.object;
    let generation = params.generation;
    let alt = params.alt;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let copy_source_acl = params.copy_source_acl;
    let if_generation_match = params.if_generation_match;
    let if_generation_not_match = params.if_generation_not_match;
    let if_metageneration_match = params.if_metageneration_match;
    let if_metageneration_not_match = params.if_metageneration_not_match;
    let projection = params.projection;
    let user_project = params.user_project;
    let object2 = params.object2;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/b/{bucket}/o/{object}/restore",
        local_var_configuration.base_path,
        bucket = crate::google_rest_apis::storage_v1::apis::urlencode(bucket),
        object = crate::google_rest_apis::storage_v1::apis::urlencode(object)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = alt {
        local_var_req_builder = local_var_req_builder.query(&[("alt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = copy_source_acl {
        local_var_req_builder =
            local_var_req_builder.query(&[("copySourceAcl", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("generation", &generation.to_string())]);
    if let Some(ref local_var_str) = if_generation_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_not_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifMetagenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_not_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifMetagenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = projection {
        local_var_req_builder =
            local_var_req_builder.query(&[("projection", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&object2);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StoragePeriodObjectsPeriodRestoreError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Rewrites a source object to a destination object. Optionally overrides metadata.
pub async fn storage_objects_rewrite(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodRewriteParams,
) -> Result<models::RewriteResponse, Error<StoragePeriodObjectsPeriodRewriteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let source_bucket = params.source_bucket;
    let source_object = params.source_object;
    let destination_bucket = params.destination_bucket;
    let destination_object = params.destination_object;
    let alt = params.alt;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let destination_kms_key_name = params.destination_kms_key_name;
    let destination_predefined_acl = params.destination_predefined_acl;
    let if_generation_match = params.if_generation_match;
    let if_generation_not_match = params.if_generation_not_match;
    let if_metageneration_match = params.if_metageneration_match;
    let if_metageneration_not_match = params.if_metageneration_not_match;
    let if_source_generation_match = params.if_source_generation_match;
    let if_source_generation_not_match = params.if_source_generation_not_match;
    let if_source_metageneration_match = params.if_source_metageneration_match;
    let if_source_metageneration_not_match = params.if_source_metageneration_not_match;
    let max_bytes_rewritten_per_call = params.max_bytes_rewritten_per_call;
    let projection = params.projection;
    let rewrite_token = params.rewrite_token;
    let source_generation = params.source_generation;
    let user_project = params.user_project;
    let object = params.object;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/b/{sourceBucket}/o/{sourceObject}/rewriteTo/b/{destinationBucket}/o/{destinationObject}", local_var_configuration.base_path, sourceBucket=crate::google_rest_apis::storage_v1::apis::urlencode(source_bucket), sourceObject=crate::google_rest_apis::storage_v1::apis::urlencode(source_object), destinationBucket=crate::google_rest_apis::storage_v1::apis::urlencode(destination_bucket), destinationObject=crate::google_rest_apis::storage_v1::apis::urlencode(destination_object));
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = alt {
        local_var_req_builder = local_var_req_builder.query(&[("alt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = destination_kms_key_name {
        local_var_req_builder =
            local_var_req_builder.query(&[("destinationKmsKeyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = destination_predefined_acl {
        local_var_req_builder = local_var_req_builder
            .query(&[("destinationPredefinedAcl", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_not_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifMetagenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_not_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifMetagenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_source_generation_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifSourceGenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_source_generation_not_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifSourceGenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_source_metageneration_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifSourceMetagenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_source_metageneration_not_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifSourceMetagenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_bytes_rewritten_per_call {
        local_var_req_builder = local_var_req_builder
            .query(&[("maxBytesRewrittenPerCall", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = projection {
        local_var_req_builder =
            local_var_req_builder.query(&[("projection", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = rewrite_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("rewriteToken", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = source_generation {
        local_var_req_builder =
            local_var_req_builder.query(&[("sourceGeneration", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&object);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StoragePeriodObjectsPeriodRewriteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates an IAM policy for the specified object.
pub async fn storage_objects_set_iam_policy(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodSetIamPolicyParams,
) -> Result<models::Policy, Error<StoragePeriodObjectsPeriodSetIamPolicyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let object = params.object;
    let alt = params.alt;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let generation = params.generation;
    let user_project = params.user_project;
    let policy = params.policy;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/b/{bucket}/o/{object}/iam",
        local_var_configuration.base_path,
        bucket = crate::google_rest_apis::storage_v1::apis::urlencode(bucket),
        object = crate::google_rest_apis::storage_v1::apis::urlencode(object)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = alt {
        local_var_req_builder = local_var_req_builder.query(&[("alt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = generation {
        local_var_req_builder =
            local_var_req_builder.query(&[("generation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&policy);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StoragePeriodObjectsPeriodSetIamPolicyError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Tests a set of permissions on the given object to see which, if any, are held by the caller.
pub async fn storage_objects_test_iam_permissions(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodTestIamPermissionsParams,
) -> Result<
    models::TestIamPermissionsResponse,
    Error<StoragePeriodObjectsPeriodTestIamPermissionsError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let object = params.object;
    let permissions = params.permissions;
    let alt = params.alt;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let generation = params.generation;
    let user_project = params.user_project;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/b/{bucket}/o/{object}/iam/testPermissions",
        local_var_configuration.base_path,
        bucket = crate::google_rest_apis::storage_v1::apis::urlencode(bucket),
        object = crate::google_rest_apis::storage_v1::apis::urlencode(object)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = alt {
        local_var_req_builder = local_var_req_builder.query(&[("alt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(
            &permissions
                .into_iter()
                .map(|p| ("permissions".to_owned(), p.to_string()))
                .collect::<Vec<(std::string::String, std::string::String)>>(),
        ),
        _ => local_var_req_builder.query(&[(
            "permissions",
            &permissions
                .into_iter()
                .map(|p| p.to_string())
                .collect::<Vec<String>>()
                .join(",")
                .to_string(),
        )]),
    };
    if let Some(ref local_var_str) = generation {
        local_var_req_builder =
            local_var_req_builder.query(&[("generation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StoragePeriodObjectsPeriodTestIamPermissionsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates an object's metadata.
pub async fn storage_objects_update(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodUpdateParams,
) -> Result<models::Object, Error<StoragePeriodObjectsPeriodUpdateError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let object = params.object;
    let alt = params.alt;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let generation = params.generation;
    let if_generation_match = params.if_generation_match;
    let if_generation_not_match = params.if_generation_not_match;
    let if_metageneration_match = params.if_metageneration_match;
    let if_metageneration_not_match = params.if_metageneration_not_match;
    let override_unlocked_retention = params.override_unlocked_retention;
    let predefined_acl = params.predefined_acl;
    let projection = params.projection;
    let user_project = params.user_project;
    let object2 = params.object2;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/b/{bucket}/o/{object}",
        local_var_configuration.base_path,
        bucket = crate::google_rest_apis::storage_v1::apis::urlencode(bucket),
        object = crate::google_rest_apis::storage_v1::apis::urlencode(object)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = alt {
        local_var_req_builder = local_var_req_builder.query(&[("alt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = generation {
        local_var_req_builder =
            local_var_req_builder.query(&[("generation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_not_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifMetagenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_not_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifMetagenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = override_unlocked_retention {
        local_var_req_builder = local_var_req_builder
            .query(&[("overrideUnlockedRetention", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = predefined_acl {
        local_var_req_builder =
            local_var_req_builder.query(&[("predefinedAcl", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = projection {
        local_var_req_builder =
            local_var_req_builder.query(&[("projection", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&object2);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StoragePeriodObjectsPeriodUpdateError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Watch for changes on all objects in a bucket.
pub async fn storage_objects_watch_all(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodWatchAllParams,
) -> Result<models::Channel, Error<StoragePeriodObjectsPeriodWatchAllError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let alt = params.alt;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let delimiter = params.delimiter;
    let end_offset = params.end_offset;
    let include_trailing_delimiter = params.include_trailing_delimiter;
    let max_results = params.max_results;
    let page_token = params.page_token;
    let prefix = params.prefix;
    let projection = params.projection;
    let start_offset = params.start_offset;
    let user_project = params.user_project;
    let versions = params.versions;
    let channel = params.channel;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/b/{bucket}/o/watch",
        local_var_configuration.base_path,
        bucket = crate::google_rest_apis::storage_v1::apis::urlencode(bucket)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = alt {
        local_var_req_builder = local_var_req_builder.query(&[("alt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = delimiter {
        local_var_req_builder =
            local_var_req_builder.query(&[("delimiter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_offset {
        local_var_req_builder =
            local_var_req_builder.query(&[("endOffset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_trailing_delimiter {
        local_var_req_builder = local_var_req_builder
            .query(&[("includeTrailingDelimiter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_results {
        local_var_req_builder =
            local_var_req_builder.query(&[("maxResults", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("pageToken", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = prefix {
        local_var_req_builder =
            local_var_req_builder.query(&[("prefix", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = projection {
        local_var_req_builder =
            local_var_req_builder.query(&[("projection", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start_offset {
        local_var_req_builder =
            local_var_req_builder.query(&[("startOffset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = versions {
        local_var_req_builder =
            local_var_req_builder.query(&[("versions", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&channel);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StoragePeriodObjectsPeriodWatchAllError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub type BoxStreamWithSync<'a, T> =
    std::pin::Pin<Box<dyn futures::Stream<Item = T> + Send + 'a + Sync>>;
pub type BoxStreamWithSend<'a, T> = std::pin::Pin<Box<dyn futures::Stream<Item = T> + Send + 'a>>;

/// Stores a new object and metadata.
/// Open API doesn't support binary streams and this particular endpoint uses another base URL.
/// Tha means generated `storage_objects_insert` can't be used.
pub async fn storage_objects_insert_ext_stream<S>(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodInsertParams,
    content_type: Option<String>,
    bytes_stream: S,
) -> Result<
    crate::google_rest_apis::storage_v1::models::Object,
    Error<StoragePeriodObjectsPeriodInsertError>,
>
where
    S: futures::stream::TryStream + Send + 'static,
    S::Error: Into<Box<dyn std::error::Error + Send + Sync>>,
    bytes::Bytes: From<S::Ok>,
{
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let alt = params.alt;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = "media";
    let user_ip = params.user_ip;
    let content_encoding = params.content_encoding;
    let if_generation_match = params.if_generation_match;
    let if_generation_not_match = params.if_generation_not_match;
    let if_metageneration_match = params.if_metageneration_match;
    let if_metageneration_not_match = params.if_metageneration_not_match;
    let kms_key_name = params.kms_key_name;
    let name = params.name;
    let predefined_acl = params.predefined_acl;
    let projection = params.projection;
    let user_project = params.user_project;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "https://storage.googleapis.com/upload/storage/v1/b/{bucket}/o",
        bucket = crate::google_rest_apis::storage_v1::apis::urlencode(bucket)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(content_type) = content_type {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::CONTENT_TYPE, content_type);
    }
    if let Some(ref local_var_str) = alt {
        local_var_req_builder = local_var_req_builder.query(&[("alt", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }

    local_var_req_builder = local_var_req_builder.query(&[("uploadType", &upload_type)]);

    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = content_encoding {
        local_var_req_builder =
            local_var_req_builder.query(&[("contentEncoding", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_not_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifMetagenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_not_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifMetagenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = kms_key_name {
        local_var_req_builder =
            local_var_req_builder.query(&[("kmsKeyName", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = name {
        local_var_req_builder =
            local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = predefined_acl {
        local_var_req_builder =
            local_var_req_builder.query(&[("predefinedAcl", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = projection {
        local_var_req_builder =
            local_var_req_builder.query(&[("projection", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    use reqwest::Body;
    local_var_req_builder = local_var_req_builder.body(Body::wrap_stream(bytes_stream));

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StoragePeriodObjectsPeriodInsertError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn storage_objects_insert_ext_bytes(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodInsertParams,
    content_type: Option<String>,
    bytes: Vec<u8>,
) -> Result<
    crate::google_rest_apis::storage_v1::models::Object,
    Error<StoragePeriodObjectsPeriodInsertError>,
> {
    use futures::StreamExt;

    let bytes_stream: BoxStreamWithSend<
        'static,
        std::result::Result<bytes::Bytes, Box<(dyn std::error::Error + Send + Sync + 'static)>>,
    > = Box::pin(
        futures::stream::iter(bytes)
            .chunks(64 * 1024)
            .map(|chunk| Ok(bytes::Bytes::from(chunk))),
    );

    storage_objects_insert_ext_stream(configuration, params, content_type, bytes_stream).await
}

/// Retrieves the contents of an object as bytes
pub async fn storage_objects_get_bytes(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodGetParams,
) -> Result<bytes::Bytes, Error<StoragePeriodObjectsPeriodGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let object = params.object;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let generation = params.generation;
    let if_generation_match = params.if_generation_match;
    let if_generation_not_match = params.if_generation_not_match;
    let if_metageneration_match = params.if_metageneration_match;
    let if_metageneration_not_match = params.if_metageneration_not_match;
    let projection = params.projection;
    let user_project = params.user_project;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/b/{bucket}/o/{object}",
        local_var_configuration.base_path,
        bucket = crate::google_rest_apis::storage_v1::apis::urlencode(bucket),
        object = crate::google_rest_apis::storage_v1::apis::urlencode(object)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    // The user-supplied `alt` parameter is ignored, because it must be "media"
    local_var_req_builder = local_var_req_builder.query(&[("alt", "media".to_string())]);

    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = generation {
        local_var_req_builder =
            local_var_req_builder.query(&[("generation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_not_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifMetagenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_not_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifMetagenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = projection {
        local_var_req_builder =
            local_var_req_builder.query(&[("projection", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(local_var_resp.bytes().await?)
    } else {
        let local_var_content = local_var_resp.text().await?;
        let local_var_entity: Option<StoragePeriodObjectsPeriodGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves the contents of an object as stream
pub async fn storage_objects_get_stream(
    configuration: &configuration::Configuration,
    params: StoragePeriodObjectsPeriodGetParams,
) -> Result<
    impl futures::stream::Stream<Item = std::result::Result<bytes::Bytes, reqwest::Error>>,
    Error<StoragePeriodObjectsPeriodGetError>,
> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let object = params.object;
    let fields = params.fields;
    let key = params.key;
    let oauth_token = params.oauth_token;
    let pretty_print = params.pretty_print;
    let quota_user = params.quota_user;
    let upload_type = params.upload_type;
    let user_ip = params.user_ip;
    let generation = params.generation;
    let if_generation_match = params.if_generation_match;
    let if_generation_not_match = params.if_generation_not_match;
    let if_metageneration_match = params.if_metageneration_match;
    let if_metageneration_not_match = params.if_metageneration_not_match;
    let projection = params.projection;
    let user_project = params.user_project;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/b/{bucket}/o/{object}",
        local_var_configuration.base_path,
        bucket = crate::google_rest_apis::storage_v1::apis::urlencode(bucket),
        object = crate::google_rest_apis::storage_v1::apis::urlencode(object)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    // The user-supplied `alt` parameter is ignored, because it must be "media"
    local_var_req_builder = local_var_req_builder.query(&[("alt", "media".to_string())]);

    if let Some(ref local_var_str) = fields {
        local_var_req_builder =
            local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = oauth_token {
        local_var_req_builder =
            local_var_req_builder.query(&[("oauth_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pretty_print {
        local_var_req_builder =
            local_var_req_builder.query(&[("prettyPrint", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = quota_user {
        local_var_req_builder =
            local_var_req_builder.query(&[("quotaUser", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = upload_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("uploadType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_ip {
        local_var_req_builder =
            local_var_req_builder.query(&[("userIp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = generation {
        local_var_req_builder =
            local_var_req_builder.query(&[("generation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_generation_not_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifGenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_match {
        local_var_req_builder =
            local_var_req_builder.query(&[("ifMetagenerationMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = if_metageneration_not_match {
        local_var_req_builder = local_var_req_builder
            .query(&[("ifMetagenerationNotMatch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = projection {
        local_var_req_builder =
            local_var_req_builder.query(&[("projection", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_project {
        local_var_req_builder =
            local_var_req_builder.query(&[("userProject", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(local_var_resp.bytes_stream())
    } else {
        let local_var_content = local_var_resp.text().await?;
        let local_var_entity: Option<StoragePeriodObjectsPeriodGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
