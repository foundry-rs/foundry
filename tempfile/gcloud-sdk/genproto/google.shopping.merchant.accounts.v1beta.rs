// This file is @generated by prost-build.
/// The access right.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AccessRight {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// Standard access rights.
    Standard = 1,
    /// Admin access rights.
    Admin = 2,
    /// Users with this right have access to performance and insights.
    PerformanceReporting = 3,
}
impl AccessRight {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ACCESS_RIGHT_UNSPECIFIED",
            Self::Standard => "STANDARD",
            Self::Admin => "ADMIN",
            Self::PerformanceReporting => "PERFORMANCE_REPORTING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACCESS_RIGHT_UNSPECIFIED" => Some(Self::Unspecified),
            "STANDARD" => Some(Self::Standard),
            "ADMIN" => Some(Self::Admin),
            "PERFORMANCE_REPORTING" => Some(Self::PerformanceReporting),
            _ => None,
        }
    }
}
/// Primary type convension
///
/// percent micro : 100% = 1 000 000 and 1% = 10 000
///                  cannot be negative.
///
/// Information about tax nexus and related parameters applicable to orders
/// delivered to the area covered by a single tax admin. Nexus is created when a
/// merchant is doing business in an area administered by tax admin (only US
/// states are supported for nexus configuration). If merchant has nexus in a US
/// state, merchant needs to pay tax to all tax authorities associated with
/// the shipping destination.
/// Next Id : 8
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaxRule {
    /// Region code in which this rule is applicable
    #[prost(string, tag = "1")]
    pub region_code: ::prost::alloc::string::String,
    /// If set, shipping charge is taxed (at the same rate as product) when
    /// delivering to this admin's area.
    /// Can only be set on US states without category.
    #[prost(bool, tag = "6")]
    pub shipping_taxed: bool,
    /// Required. Time period when this rule is effective. If the duration is
    /// missing from effective_time listed, then it is open ended to the future.
    /// The start of this time period is inclusive, and the end is exclusive.
    #[prost(message, optional, tag = "7")]
    pub effective_time_period: ::core::option::Option<
        super::super::super::super::r#type::Interval,
    >,
    /// Describe the location through either postal code range or a criteria id.
    #[prost(oneof = "tax_rule::Location", tags = "2, 3")]
    pub location: ::core::option::Option<tax_rule::Location>,
    /// What is the way to calculate tax rate for deliveries to this admin's area.
    /// Can only be set on US states.
    #[prost(oneof = "tax_rule::RateCalculation", tags = "4, 5")]
    pub rate_calculation: ::core::option::Option<tax_rule::RateCalculation>,
}
/// Nested message and enum types in `TaxRule`.
pub mod tax_rule {
    /// A range of postal codes that defines the area.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TaxPostalCodeRange {
        /// Required. The start of the postal code range, which is also the smallest
        /// in the range.
        #[prost(string, tag = "1")]
        pub start: ::prost::alloc::string::String,
        /// The end of the postal code range. Will be the same as start if not
        /// specified.
        #[prost(string, tag = "2")]
        pub end: ::prost::alloc::string::String,
    }
    /// Describe the location through either postal code range or a criteria id.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Location {
        /// The admin_id or criteria_id of the region in which this rule is
        /// applicable.
        #[prost(int64, tag = "2")]
        LocationId(i64),
        /// The range of postal codes in which this rule is applicable.
        #[prost(message, tag = "3")]
        PostCodeRange(TaxPostalCodeRange),
    }
    /// What is the way to calculate tax rate for deliveries to this admin's area.
    /// Can only be set on US states.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum RateCalculation {
        /// Rate that depends on delivery location: if merchant has a nexus in
        /// corresponding US state, rates from authorities with jurisdiction over
        /// delivery area are added up.
        #[prost(bool, tag = "4")]
        UseGoogleRate(bool),
        /// A fixed rate specified in micros, where 100% = 1_000_000.
        /// Suitable for origin-based states.
        #[prost(int64, tag = "5")]
        SelfSpecifiedRateMicros(i64),
    }
}
/// The tax settings of a merchant account. All methods require the admin role.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountTax {
    /// Identifier. The name of the tax setting.
    /// Format:
    /// "{account_tax.name=accounts/{account}}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The ID of the account to which these account tax settings
    /// belong.
    #[prost(int64, tag = "2")]
    pub account: i64,
    /// Tax rules. "Define the tax rules in each region.
    /// No tax will be presented if a region has no rule."
    #[prost(message, repeated, tag = "3")]
    pub tax_rules: ::prost::alloc::vec::Vec<TaxRule>,
}
/// Request to get tax settings
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountTaxRequest {
    /// Required. The name from which tax settings will be retrieved
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request to update the tax settings
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAccountTaxRequest {
    /// Required. The tax setting that will be updated
    #[prost(message, optional, tag = "1")]
    pub account_tax: ::core::option::Option<AccountTax>,
    /// The list of fields to be updated
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request to list all sub-account tax settings only for the requesting merchant
/// This method can only be called on a multi-client account, otherwise it'll
/// return an error.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccountTaxRequest {
    /// Required. The parent, which owns this collection of account tax.
    /// Format: accounts/{account}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of tax settings to return in the response, used for
    /// paging.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The token returned by the previous request.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response to account tax list request
/// This method can only be called on a multi-client account, otherwise it'll
/// return an error.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccountTaxResponse {
    /// Page of accounttax settings
    #[prost(message, repeated, tag = "1")]
    pub account_taxes: ::prost::alloc::vec::Vec<AccountTax>,
    /// The token for the retrieval of the next page of account tax settings.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod account_tax_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Manages account level tax setting data.
    ///
    /// This API defines the following resource model:
    ///
    /// - [AccountTax][google.shopping.merchant.accounts.v1main.AccountTax]
    #[derive(Debug, Clone)]
    pub struct AccountTaxServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AccountTaxServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AccountTaxServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AccountTaxServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AccountTaxServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the tax rules that match the conditions of GetAccountTaxRequest
        pub async fn get_account_tax(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAccountTaxRequest>,
        ) -> std::result::Result<tonic::Response<super::AccountTax>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.AccountTaxService/GetAccountTax",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.AccountTaxService",
                        "GetAccountTax",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the tax settings of the sub-accounts only in your
        /// Merchant Center account.
        /// This method can only be called on a multi-client account, otherwise it'll
        /// return an error.
        pub async fn list_account_tax(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAccountTaxRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAccountTaxResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.AccountTaxService/ListAccountTax",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.AccountTaxService",
                        "ListAccountTax",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the tax settings of the account.
        pub async fn update_account_tax(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAccountTaxRequest>,
        ) -> std::result::Result<tonic::Response<super::AccountTax>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.AccountTaxService/UpdateAccountTax",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.AccountTaxService",
                        "UpdateAccountTax",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// An
/// [`AccountIssue`](<https://support.google.com/merchants/answer/12153802?sjid=17798438912526418908-EU#account>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountIssue {
    /// Identifier. The resource name of the account issue.
    /// Format: `accounts/{account}/issues/{id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The localized title of the issue.
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    /// The overall severity of the issue.
    #[prost(enumeration = "account_issue::Severity", tag = "3")]
    pub severity: i32,
    /// The impact this issue has on various destinations.
    #[prost(message, repeated, tag = "4")]
    pub impacted_destinations: ::prost::alloc::vec::Vec<
        account_issue::ImpactedDestination,
    >,
    /// Further localized details about the issue.
    #[prost(string, tag = "5")]
    pub detail: ::prost::alloc::string::String,
    /// Link to Merchant Center Help Center providing further information about the
    /// issue and how to fix it.
    #[prost(string, tag = "6")]
    pub documentation_uri: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AccountIssue`.
pub mod account_issue {
    /// The impact of the issue on a destination.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImpactedDestination {
        /// The impacted reporting context.
        #[prost(
            enumeration = "super::super::super::super::r#type::reporting_context::ReportingContextEnum",
            optional,
            tag = "1"
        )]
        pub reporting_context: ::core::option::Option<i32>,
        /// The (negative) impact for various regions on the given destination.
        #[prost(message, repeated, tag = "2")]
        pub impacts: ::prost::alloc::vec::Vec<impacted_destination::Impact>,
    }
    /// Nested message and enum types in `ImpactedDestination`.
    pub mod impacted_destination {
        /// The impact of the issue on a region.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Impact {
            /// The [CLDR region code](<https://cldr.unicode.org/>) where this issue
            /// applies.
            #[prost(string, tag = "1")]
            pub region_code: ::prost::alloc::string::String,
            /// The severity of the issue on the destination and region.
            #[prost(enumeration = "super::Severity", tag = "2")]
            pub severity: i32,
        }
    }
    /// All possible issue severities.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Severity {
        /// The severity is unknown.
        Unspecified = 0,
        /// The issue causes offers to not serve.
        Critical = 1,
        /// The issue might affect offers (in the future) or might be an
        /// indicator of issues with offers.
        Error = 2,
        /// The issue is a suggestion for improvement.
        Suggestion = 3,
    }
    impl Severity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SEVERITY_UNSPECIFIED",
                Self::Critical => "CRITICAL",
                Self::Error => "ERROR",
                Self::Suggestion => "SUGGESTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
                "CRITICAL" => Some(Self::Critical),
                "ERROR" => Some(Self::Error),
                "SUGGESTION" => Some(Self::Suggestion),
                _ => None,
            }
        }
    }
}
/// Request message for the `ListAccountIssues` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccountIssuesRequest {
    /// Required. The parent, which owns this collection of issues.
    /// Format: `accounts/{account}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of issues to return. The service may return
    /// fewer than this value. If unspecified, at most 50 users will be returned.
    /// The maximum value is 100; values above 100 will be coerced to 100
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListAccountIssues` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListAccountIssues` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. The issues in the response will have human-readable fields in the
    /// given language. The format is [BCP-47](<https://tools.ietf.org/html/bcp47>),
    /// such as `en-US` or `sr-Latn`. If not value is provided, `en-US` will be
    /// used.
    #[prost(string, tag = "4")]
    pub language_code: ::prost::alloc::string::String,
    /// Optional. The [IANA](<https://www.iana.org/time-zones>) timezone used to
    /// localize times in human-readable fields. For example 'America/Los_Angeles'.
    /// If not set, 'America/Los_Angeles' will be used.
    #[prost(string, tag = "5")]
    pub time_zone: ::prost::alloc::string::String,
}
/// Response message for the `ListAccountIssues` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccountIssuesResponse {
    /// The issues from the specified account.
    #[prost(message, repeated, tag = "1")]
    pub account_issues: ::prost::alloc::vec::Vec<AccountIssue>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod account_issue_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to support `AccountIssueService` API.
    #[derive(Debug, Clone)]
    pub struct AccountIssueServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AccountIssueServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AccountIssueServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AccountIssueServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AccountIssueServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists all account issues of a Merchant Center account.
        pub async fn list_account_issues(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAccountIssuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAccountIssuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.AccountIssueService/ListAccountIssues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.AccountIssueService",
                        "ListAccountIssues",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// `AccountAggregation` payload.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccountAggregation {}
/// A [user](<https://support.google.com/merchants/answer/12160472>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    /// Identifier. The resource name of the user.
    /// Format: `accounts/{account}/user/{email}`
    ///
    /// Use `me` to refer to your own email address, for example
    /// `accounts/{account}/users/me`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The state of the user.
    #[prost(enumeration = "user::State", tag = "2")]
    pub state: i32,
    /// Optional. The [access
    /// rights](<https://support.google.com/merchants/answer/12160472?sjid=6789834943175119429-EU#accesstypes>)
    /// the user has.
    #[prost(enumeration = "AccessRight", repeated, packed = "false", tag = "4")]
    pub access_rights: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `User`.
pub mod user {
    /// The possible states of a user.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The user is pending confirmation. In this state, the user first needs to
        /// accept the invitation before performing other actions.
        Pending = 1,
        /// The user is verified.
        Verified = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Verified => "VERIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "VERIFIED" => Some(Self::Verified),
                _ => None,
            }
        }
    }
}
/// Request message for the `GetUser` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserRequest {
    /// Required. The name of the user to retrieve.
    /// Format: `accounts/{account}/users/{email}`
    ///
    /// It is also possible to retrieve the user corresponding to the caller by
    /// using `me` rather than an email address as in
    /// `accounts/{account}/users/me`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `CreateUser` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateUserRequest {
    /// Required. The resource name of the account for which a user will be
    /// created. Format: `accounts/{account}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The email address of the user (for example,
    /// `john.doe@gmail.com`).
    #[prost(string, tag = "2")]
    pub user_id: ::prost::alloc::string::String,
    /// Required. The user to create.
    #[prost(message, optional, tag = "3")]
    pub user: ::core::option::Option<User>,
}
/// Request message for the `DeleteUser` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteUserRequest {
    /// Required. The name of the user to delete.
    /// Format: `accounts/{account}/users/{email}`
    ///
    /// It is also possible to delete the user corresponding to the caller by using
    /// `me` rather than an email address as in `accounts/{account}/users/me`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `UpdateUser` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUserRequest {
    /// Required. The new version of the user.
    ///
    /// Use `me` to refer to your own email address, for example
    /// `accounts/{account}/users/me`.
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
    /// Required. List of fields being updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for the `ListUsers` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUsersRequest {
    /// Required. The parent, which owns this collection of users.
    /// Format: `accounts/{account}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of users to return. The service may return
    /// fewer than this value. If unspecified, at most 50 users will be returned.
    /// The maximum value is 100; values above 100 will be coerced to 100
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListUsers` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListUsers` must match
    /// the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for the `ListUsers` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUsersResponse {
    /// The users from the specified account.
    #[prost(message, repeated, tag = "1")]
    pub users: ::prost::alloc::vec::Vec<User>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod user_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to support user API.
    #[derive(Debug, Clone)]
    pub struct UserServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UserServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UserServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UserServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            UserServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves a Merchant Center account user.
        pub async fn get_user(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUserRequest>,
        ) -> std::result::Result<tonic::Response<super::User>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.UserService/GetUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.UserService",
                        "GetUser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a Merchant Center account user. Executing this method requires
        /// admin access.
        pub async fn create_user(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateUserRequest>,
        ) -> std::result::Result<tonic::Response<super::User>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.UserService/CreateUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.UserService",
                        "CreateUser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Merchant Center account user. Executing this method requires
        /// admin access.
        pub async fn delete_user(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteUserRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.UserService/DeleteUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.UserService",
                        "DeleteUser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a Merchant Center account user. Executing this method requires
        /// admin access.
        pub async fn update_user(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateUserRequest>,
        ) -> std::result::Result<tonic::Response<super::User>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.UserService/UpdateUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.UserService",
                        "UpdateUser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all users of a Merchant Center account.
        pub async fn list_users(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUsersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUsersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.UserService/ListUsers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.UserService",
                        "ListUsers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// An account.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Account {
    /// Identifier. The resource name of the account.
    /// Format: `accounts/{account}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The ID of the account.
    #[prost(int64, tag = "2")]
    pub account_id: i64,
    /// Required. A human-readable name of the account. See
    /// [store name](<https://support.google.com/merchants/answer/160556>) and
    /// [business name](<https://support.google.com/merchants/answer/12159159>) for
    /// more information.
    #[prost(string, tag = "3")]
    pub account_name: ::prost::alloc::string::String,
    /// Whether this account contains adult content.
    #[prost(bool, tag = "4")]
    pub adult_content: bool,
    /// Output only. Whether this is a test account.
    #[prost(bool, tag = "5")]
    pub test_account: bool,
    /// Required. The time zone of the account.
    ///
    /// On writes, `time_zone` sets both the `reporting_time_zone` and the
    /// `display_time_zone`.
    ///
    /// For reads, `time_zone` always returns the `display_time_zone`. If
    /// `display_time_zone` doesn't exist for your account, `time_zone` is empty.
    #[prost(message, optional, tag = "6")]
    pub time_zone: ::core::option::Option<super::super::super::super::r#type::TimeZone>,
    /// Required. The account's [BCP-47 language
    /// code](<https://tools.ietf.org/html/bcp47>), such as `en-US` or `sr-Latn`.
    #[prost(string, tag = "7")]
    pub language_code: ::prost::alloc::string::String,
}
/// Request message for the `GetAccount` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountRequest {
    /// Required. The name of the account to retrieve.
    /// Format: `accounts/{account}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `CreateAndConfigureAccount` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAndConfigureAccountRequest {
    /// Required. The account to be created.
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Account>,
    /// Optional. Users to be added to the account.
    #[prost(message, repeated, tag = "2")]
    pub users: ::prost::alloc::vec::Vec<CreateUserRequest>,
    /// Optional. The Terms of Service (ToS) to be accepted immediately upon
    /// account creation.
    #[prost(message, optional, tag = "3")]
    pub accept_terms_of_service: ::core::option::Option<
        create_and_configure_account_request::AcceptTermsOfService,
    >,
    /// Required. An account service between the account to be created and the
    /// provider account is initialized as part of the creation. At least one such
    /// service needs to be provided. Currently exactly one of these needs to be
    /// `account_aggregation`, which means you can only create sub accounts, not
    /// standalone account through this method. Additional `account_management` or
    /// `product_management` services may be provided.
    #[prost(message, repeated, tag = "4")]
    pub service: ::prost::alloc::vec::Vec<
        create_and_configure_account_request::AddAccountService,
    >,
}
/// Nested message and enum types in `CreateAndConfigureAccountRequest`.
pub mod create_and_configure_account_request {
    /// Reference to a Terms of Service resource.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AcceptTermsOfService {
        /// Required. The resource name of the terms of service version in the format
        /// `termsOfService/{version}`. To retrieve the latest version, use the
        /// [termsOfService.retrieveLatest](/merchant/api/reference/rest/accounts_v1beta/termsOfService/retrieveLatest)
        /// method.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Required. Region code as defined by [CLDR](<https://cldr.unicode.org/>).
        /// This is either a country when the ToS applies specifically to that
        /// country or `001` when it applies globally.
        #[prost(string, tag = "3")]
        pub region_code: ::prost::alloc::string::String,
    }
    /// Additional instructions to add account services during creation of the
    /// account.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AddAccountService {
        /// Optional. The provider of the service.
        /// Format: `accounts/{account}`
        #[prost(string, optional, tag = "1")]
        pub provider: ::core::option::Option<::prost::alloc::string::String>,
        /// The service type to be added.
        #[prost(oneof = "add_account_service::ServiceType", tags = "103")]
        pub service_type: ::core::option::Option<add_account_service::ServiceType>,
    }
    /// Nested message and enum types in `AddAccountService`.
    pub mod add_account_service {
        /// The service type to be added.
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum ServiceType {
            /// The provider is an
            /// [aggregator](<https://support.google.com/merchants/answer/188487>) for
            /// the account. Payload for service type Account Aggregation.
            #[prost(message, tag = "103")]
            AccountAggregation(super::super::AccountAggregation),
        }
    }
}
/// Request message for the `DeleteAccount` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAccountRequest {
    /// Required. The name of the account to delete.
    /// Format: `accounts/{account}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If set to `true`, the account is deleted even if it provides
    /// services to other accounts or has processed offers.
    #[prost(bool, tag = "2")]
    pub force: bool,
}
/// Request message for the `UpdateAccount` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAccountRequest {
    /// Required. The new version of the account.
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Account>,
    /// Required. List of fields being updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for the `ListAccounts` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccountsRequest {
    /// Optional. The maximum number of accounts to return. The service may return
    /// fewer than this value.  If unspecified, at most 250 accounts are returned.
    /// The maximum value is 500; values above 500 are coerced to 500.
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListAccounts` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListAccounts` must match
    /// the call that provided the page token.
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Returns only accounts that match the
    /// [filter](/merchant/api/guides/accounts/filter).
    /// For more details, see the
    /// [filter syntax reference](/merchant/api/guides/accounts/filter-syntax).
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
}
/// Response message for the `ListAccounts` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccountsResponse {
    /// The accounts matching the `ListAccountsRequest`.
    #[prost(message, repeated, tag = "1")]
    pub accounts: ::prost::alloc::vec::Vec<Account>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for the `ListSubAccounts` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubAccountsRequest {
    /// Required. The parent account.
    /// Format: `accounts/{account}`
    #[prost(string, tag = "1")]
    pub provider: ::prost::alloc::string::String,
    /// Optional. The maximum number of accounts to return. The service may return
    /// fewer than this value.  If unspecified, at most 250 accounts are returned.
    /// The maximum value is 500; values above 500 are coerced to 500.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListAccounts` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListAccounts` must match
    /// the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for the `ListSubAccounts` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubAccountsResponse {
    /// The accounts for which the given parent account is an aggregator.
    #[prost(message, repeated, tag = "1")]
    pub accounts: ::prost::alloc::vec::Vec<Account>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod accounts_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to support Accounts API.
    #[derive(Debug, Clone)]
    pub struct AccountsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AccountsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AccountsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AccountsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AccountsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an account from your Merchant Center account.
        /// After inserting, updating, or deleting an account, it may take several
        /// minutes before changes take effect.
        pub async fn get_account(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAccountRequest>,
        ) -> std::result::Result<tonic::Response<super::Account>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.AccountsService/GetAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.AccountsService",
                        "GetAccount",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a standalone Merchant Center account with additional configuration.
        /// Adds the user that makes the request as an admin for the new account.
        pub async fn create_and_configure_account(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAndConfigureAccountRequest>,
        ) -> std::result::Result<tonic::Response<super::Account>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.AccountsService/CreateAndConfigureAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.AccountsService",
                        "CreateAndConfigureAccount",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified account regardless of its type: standalone, MCA or
        /// sub-account. Deleting an MCA leads to the deletion of all of its
        /// sub-accounts. Executing this method requires admin access.
        /// The deletion succeeds only if the account does not provide services
        /// to any other account and has no processed offers. You can use the `force`
        /// parameter to override this.
        pub async fn delete_account(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAccountRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.AccountsService/DeleteAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.AccountsService",
                        "DeleteAccount",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an account regardless of its type: standalone, MCA or sub-account.
        /// Executing this method requires admin access.
        pub async fn update_account(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAccountRequest>,
        ) -> std::result::Result<tonic::Response<super::Account>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.AccountsService/UpdateAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.AccountsService",
                        "UpdateAccount",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists accounts accessible to the calling user and matching the
        /// constraints of the request such as page size or filters.
        /// This is not just listing the sub-accounts of an MCA, but all accounts the
        /// calling user has access to including other MCAs, linked accounts,
        /// standalone accounts and so on. If no filter is provided, then it returns
        /// accounts the user is directly added to.
        pub async fn list_accounts(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAccountsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAccountsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.AccountsService/ListAccounts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.AccountsService",
                        "ListAccounts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all sub-accounts for a given multi client account. This is a
        /// convenience wrapper for the more powerful `ListAccounts` method. This
        /// method will produce the same results as calling `ListsAccounts` with the
        /// following filter:
        /// `relationship(providerId={parent} AND service(type="ACCOUNT_AGGREGATION"))`
        pub async fn list_sub_accounts(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSubAccountsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSubAccountsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.AccountsService/ListSubAccounts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.AccountsService",
                        "ListSubAccounts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Collection of information related to the
/// [autofeed](<https://support.google.com/merchants/answer/7538732>) settings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutofeedSettings {
    /// Identifier. The resource name of the autofeed settings.
    /// Format: `accounts/{account}/autofeedSettings`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Enables or disables product crawling through the autofeed for the
    /// given account. Autofeed accounts must meet [certain
    /// conditions](<https://support.google.com/merchants/answer/7538732#Configure_automated_feeds_Standard_Experience>),
    /// which can be checked through the `eligible` field.
    /// The account must **not** be a marketplace.
    /// When the autofeed is enabled for the first time, the products usually
    /// appear instantly. When re-enabling, it might take up to 24 hours for
    /// products to appear.
    #[prost(bool, tag = "2")]
    pub enable_products: bool,
    /// Output only. Determines whether merchant is eligible for being enrolled
    /// into an autofeed.
    #[prost(bool, tag = "3")]
    pub eligible: bool,
}
/// Request message for the `GetAutofeedSettings` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAutofeedSettingsRequest {
    /// Required. The resource name of the autofeed settings.
    /// Format: `accounts/{account}/autofeedSettings`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `UpdateAutofeedSettings` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAutofeedSettingsRequest {
    /// Required. The new version of the autofeed setting.
    #[prost(message, optional, tag = "1")]
    pub autofeed_settings: ::core::option::Option<AutofeedSettings>,
    /// Required. List of fields being updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod autofeed_settings_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to support
    /// [autofeed](https://support.google.com/merchants/answer/7538732) setting.
    #[derive(Debug, Clone)]
    pub struct AutofeedSettingsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AutofeedSettingsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AutofeedSettingsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AutofeedSettingsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AutofeedSettingsServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the autofeed settings of an account.
        pub async fn get_autofeed_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAutofeedSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AutofeedSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.AutofeedSettingsService/GetAutofeedSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.AutofeedSettingsService",
                        "GetAutofeedSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the autofeed settings of an account.
        pub async fn update_autofeed_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAutofeedSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AutofeedSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.AutofeedSettingsService/UpdateAutofeedSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.AutofeedSettingsService",
                        "UpdateAutofeedSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Collection of information related to the [identity of a
/// business](<https://support.google.com/merchants/answer/12564247>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BusinessIdentity {
    /// Identifier. The resource name of the business identity.
    /// Format: `accounts/{account}/businessIdentity`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Whether the identity attributes may be used for promotions.
    #[prost(enumeration = "business_identity::PromotionsConsent", tag = "2")]
    pub promotions_consent: i32,
    /// Optional. Specifies whether the business identifies itself as being
    /// black-owned. This optional field will only be available for merchants with
    /// a business country set to `US`. It is also not applicable for marketplaces
    /// or marketplace sellers.
    #[prost(message, optional, tag = "3")]
    pub black_owned: ::core::option::Option<business_identity::IdentityAttribute>,
    /// Optional. Specifies whether the business identifies itself as being
    /// women-owned. This optional field will only be available for merchants with
    /// a business country set to `US`. It is also not applicable for marketplaces
    /// or marketplace sellers.
    #[prost(message, optional, tag = "4")]
    pub women_owned: ::core::option::Option<business_identity::IdentityAttribute>,
    /// Optional. Specifies whether the business identifies itself as being
    /// veteran-owned. This optional field will only be available for merchants
    /// with a business country set to `US`. It is also not applicable for
    /// marketplaces or marketplace sellers.
    #[prost(message, optional, tag = "5")]
    pub veteran_owned: ::core::option::Option<business_identity::IdentityAttribute>,
    /// Optional. Specifies whether the business identifies itself as being
    /// latino-owned. This optional field will only be available for merchants with
    /// a business country set to `US`. It is also not applicable for marketplaces
    /// or marketplace sellers.
    #[prost(message, optional, tag = "6")]
    pub latino_owned: ::core::option::Option<business_identity::IdentityAttribute>,
    /// Optional. Specifies whether the business identifies itself as a small
    /// business. This optional field will only be available for merchants with a
    /// business country set to `US`. It is also not applicable for marketplaces.
    #[prost(message, optional, tag = "7")]
    pub small_business: ::core::option::Option<business_identity::IdentityAttribute>,
}
/// Nested message and enum types in `BusinessIdentity`.
pub mod business_identity {
    /// All information related to an identity attribute.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct IdentityAttribute {
        /// Required. The declaration of identity for this attribute.
        #[prost(enumeration = "identity_attribute::IdentityDeclaration", tag = "1")]
        pub identity_declaration: i32,
    }
    /// Nested message and enum types in `IdentityAttribute`.
    pub mod identity_attribute {
        /// All possible settings regarding the declaration of an identity.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum IdentityDeclaration {
            /// Default value indicating that no selection was made.
            Unspecified = 0,
            /// Indicates that the account identifies with the attribute.
            SelfIdentifiesAs = 1,
            /// Indicates that the account does not identify with the attribute.
            DoesNotSelfIdentifyAs = 2,
        }
        impl IdentityDeclaration {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "IDENTITY_DECLARATION_UNSPECIFIED",
                    Self::SelfIdentifiesAs => "SELF_IDENTIFIES_AS",
                    Self::DoesNotSelfIdentifyAs => "DOES_NOT_SELF_IDENTIFY_AS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "IDENTITY_DECLARATION_UNSPECIFIED" => Some(Self::Unspecified),
                    "SELF_IDENTIFIES_AS" => Some(Self::SelfIdentifiesAs),
                    "DOES_NOT_SELF_IDENTIFY_AS" => Some(Self::DoesNotSelfIdentifyAs),
                    _ => None,
                }
            }
        }
    }
    /// All possible settings regarding promotions related to the business
    /// identity.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PromotionsConsent {
        /// Default value indicating that no selection was made.
        Unspecified = 0,
        /// Indicates that the account consented to having their business identity
        /// used for promotions.
        Given = 1,
        /// Indicates that the account did not consent to having their business
        /// identity used for promotions.
        Denied = 2,
    }
    impl PromotionsConsent {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROMOTIONS_CONSENT_UNSPECIFIED",
                Self::Given => "PROMOTIONS_CONSENT_GIVEN",
                Self::Denied => "PROMOTIONS_CONSENT_DENIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROMOTIONS_CONSENT_UNSPECIFIED" => Some(Self::Unspecified),
                "PROMOTIONS_CONSENT_GIVEN" => Some(Self::Given),
                "PROMOTIONS_CONSENT_DENIED" => Some(Self::Denied),
                _ => None,
            }
        }
    }
}
/// Request message for the `GetBusinessIdentity` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBusinessIdentityRequest {
    /// Required. The resource name of the business identity.
    /// Format: `accounts/{account}/businessIdentity`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `UpdateBusinessIdentity` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBusinessIdentityRequest {
    /// Required. The new version of the business identity.
    #[prost(message, optional, tag = "1")]
    pub business_identity: ::core::option::Option<BusinessIdentity>,
    /// Required. List of fields being updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod business_identity_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to support [business
    /// identity](https://support.google.com/merchants/answer/12564247) API.
    #[derive(Debug, Clone)]
    pub struct BusinessIdentityServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BusinessIdentityServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BusinessIdentityServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BusinessIdentityServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            BusinessIdentityServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the business identity of an account.
        pub async fn get_business_identity(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBusinessIdentityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BusinessIdentity>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.BusinessIdentityService/GetBusinessIdentity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.BusinessIdentityService",
                        "GetBusinessIdentity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the business identity of an account. Executing this method requires
        /// admin access.
        pub async fn update_business_identity(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBusinessIdentityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BusinessIdentity>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.BusinessIdentityService/UpdateBusinessIdentity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.BusinessIdentityService",
                        "UpdateBusinessIdentity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Customer service information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerService {
    /// Optional. The URI where customer service may be found.
    #[prost(string, optional, tag = "1")]
    pub uri: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The email address where customer service may be reached.
    #[prost(string, optional, tag = "2")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The phone number where customer service may be called.
    #[prost(message, optional, tag = "3")]
    pub phone: ::core::option::Option<super::super::super::super::r#type::PhoneNumber>,
}
/// The phone verification state.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PhoneVerificationState {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// The phone is verified.
    Verified = 1,
    /// The phone is unverified
    Unverified = 2,
}
impl PhoneVerificationState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PHONE_VERIFICATION_STATE_UNSPECIFIED",
            Self::Verified => "PHONE_VERIFICATION_STATE_VERIFIED",
            Self::Unverified => "PHONE_VERIFICATION_STATE_UNVERIFIED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PHONE_VERIFICATION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "PHONE_VERIFICATION_STATE_VERIFIED" => Some(Self::Verified),
            "PHONE_VERIFICATION_STATE_UNVERIFIED" => Some(Self::Unverified),
            _ => None,
        }
    }
}
/// Collection of information related to a business.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BusinessInfo {
    /// Identifier. The resource name of the business info.
    /// Format: `accounts/{account}/businessInfo`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The address of the business.
    #[prost(message, optional, tag = "2")]
    pub address: ::core::option::Option<
        super::super::super::super::r#type::PostalAddress,
    >,
    /// Output only. The phone number of the business.
    #[prost(message, optional, tag = "3")]
    pub phone: ::core::option::Option<super::super::super::super::r#type::PhoneNumber>,
    /// Output only. The phone verification state of the business.
    #[prost(enumeration = "PhoneVerificationState", optional, tag = "4")]
    pub phone_verification_state: ::core::option::Option<i32>,
    /// Optional. The customer service of the business.
    #[prost(message, optional, tag = "5")]
    pub customer_service: ::core::option::Option<CustomerService>,
    /// Optional. The 10-digit [Korean business registration
    /// number](<https://support.google.com/merchants/answer/9037766>) separated with
    /// dashes in the format: XXX-XX-XXXXX.
    #[prost(string, optional, tag = "6")]
    pub korean_business_registration_number: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
/// Request message for the `GetBusinessInfo` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBusinessInfoRequest {
    /// Required. The resource name of the business info.
    /// Format: `accounts/{account}/businessInfo`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `UpdateBusinessInfo` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBusinessInfoRequest {
    /// Required. The new version of the business info.
    #[prost(message, optional, tag = "1")]
    pub business_info: ::core::option::Option<BusinessInfo>,
    /// Required. List of fields being updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod business_info_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to support business info API.
    #[derive(Debug, Clone)]
    pub struct BusinessInfoServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BusinessInfoServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BusinessInfoServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BusinessInfoServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            BusinessInfoServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the business info of an account.
        pub async fn get_business_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBusinessInfoRequest>,
        ) -> std::result::Result<tonic::Response<super::BusinessInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.BusinessInfoService/GetBusinessInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.BusinessInfoService",
                        "GetBusinessInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the business info of an account. Executing this method requires
        /// admin access.
        pub async fn update_business_info(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBusinessInfoRequest>,
        ) -> std::result::Result<tonic::Response<super::BusinessInfo>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.BusinessInfoService/UpdateBusinessInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.BusinessInfoService",
                        "UpdateBusinessInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The categories of notifications the user opted into / opted out of. The email
/// preferences do not include mandatory announcements as users can't opt out of
/// them.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmailPreferences {
    /// Identifier. The name of the EmailPreferences. The endpoint is only
    /// supported for the authenticated user.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Updates on new features, tips and best practices.
    #[prost(enumeration = "email_preferences::OptInState", tag = "2")]
    pub news_and_tips: i32,
}
/// Nested message and enum types in `EmailPreferences`.
pub mod email_preferences {
    /// Opt in state of the email preference.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OptInState {
        /// Opt-in status is not specified.
        Unspecified = 0,
        /// User has opted out of receiving this type of email.
        OptedOut = 1,
        /// User has opted in to receiving this type of email.
        OptedIn = 2,
        /// User has opted in to receiving this type of email and the confirmation
        /// email has been sent, but user has not yet confirmed the opt in (applies
        /// only to certain countries).
        Unconfirmed = 3,
    }
    impl OptInState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OPT_IN_STATE_UNSPECIFIED",
                Self::OptedOut => "OPTED_OUT",
                Self::OptedIn => "OPTED_IN",
                Self::Unconfirmed => "UNCONFIRMED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPT_IN_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "OPTED_OUT" => Some(Self::OptedOut),
                "OPTED_IN" => Some(Self::OptedIn),
                "UNCONFIRMED" => Some(Self::Unconfirmed),
                _ => None,
            }
        }
    }
}
/// Request message for GetEmailPreferences method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEmailPreferencesRequest {
    /// Required. The name of the `EmailPreferences` resource.
    /// Format: `accounts/{account}/users/{email}/emailPreferences`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for UpdateEmailPreferences method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEmailPreferencesRequest {
    /// Required. Email Preferences to be updated.
    #[prost(message, optional, tag = "1")]
    pub email_preferences: ::core::option::Option<EmailPreferences>,
    /// Required. List of fields being updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod email_preferences_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to support the `EmailPreferences` API.
    ///
    /// This service only permits retrieving and updating email preferences for the
    /// authenticated user.
    #[derive(Debug, Clone)]
    pub struct EmailPreferencesServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl EmailPreferencesServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> EmailPreferencesServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> EmailPreferencesServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            EmailPreferencesServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the email preferences for a Merchant Center account user.
        ///
        /// Use the name=accounts/*/users/me/emailPreferences alias to get preferences
        /// for the authenticated user.
        pub async fn get_email_preferences(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEmailPreferencesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EmailPreferences>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.EmailPreferencesService/GetEmailPreferences",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.EmailPreferencesService",
                        "GetEmailPreferences",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the email preferences for a Merchant Center account user. MCA users
        /// should specify the MCA account rather than a sub-account of the MCA.
        ///
        /// Preferences which are not explicitly selected in the update mask will not
        /// be updated.
        ///
        /// It is invalid for updates to specify an UNCONFIRMED opt-in status value.
        ///
        /// Use the name=accounts/*/users/me/emailPreferences alias to update
        /// preferences
        /// for the authenticated user.
        pub async fn update_email_preferences(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEmailPreferencesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EmailPreferences>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.EmailPreferencesService/UpdateEmailPreferences",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.EmailPreferencesService",
                        "UpdateEmailPreferences",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// A store's homepage.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Homepage {
    /// Identifier. The resource name of the store's homepage.
    /// Format: `accounts/{account}/homepage`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The URI (typically a URL) of the store's homepage.
    #[prost(string, optional, tag = "2")]
    pub uri: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Whether the homepage is claimed. See
    /// <https://support.google.com/merchants/answer/176793.>
    #[prost(bool, tag = "3")]
    pub claimed: bool,
}
/// Request message for the `GetHomepage` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHomepageRequest {
    /// Required. The name of the homepage to retrieve.
    /// Format: `accounts/{account}/homepage`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `UpdateHomepage` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateHomepageRequest {
    /// Required. The new version of the homepage.
    #[prost(message, optional, tag = "1")]
    pub homepage: ::core::option::Option<Homepage>,
    /// Required. List of fields being updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for the `ClaimHomepage` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimHomepageRequest {
    /// Required. The name of the homepage to claim.
    /// Format: `accounts/{account}/homepage`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `UnclaimHomepage` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnclaimHomepageRequest {
    /// Required. The name of the homepage to unclaim.
    /// Format: `accounts/{account}/homepage`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod homepage_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to support an API for a store's homepage.
    #[derive(Debug, Clone)]
    pub struct HomepageServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl HomepageServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> HomepageServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> HomepageServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            HomepageServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves a store's homepage.
        pub async fn get_homepage(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHomepageRequest>,
        ) -> std::result::Result<tonic::Response<super::Homepage>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.HomepageService/GetHomepage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.HomepageService",
                        "GetHomepage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a store's homepage. Executing this method requires admin access.
        pub async fn update_homepage(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateHomepageRequest>,
        ) -> std::result::Result<tonic::Response<super::Homepage>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.HomepageService/UpdateHomepage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.HomepageService",
                        "UpdateHomepage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Claims a store's homepage. Executing this method requires admin access.
        ///
        /// If the homepage is already claimed, this will recheck the
        /// verification (unless the merchant is exempted from claiming, which also
        /// exempts from verification) and return a successful response. If ownership
        /// can no longer be verified, it will return an error, but it won't clear the
        /// claim. In case of failure, a canonical error message will be returned:
        ///    * PERMISSION_DENIED: user doesn't have the necessary permissions on this
        ///    MC account;
        ///    * FAILED_PRECONDITION:
        ///      - The account is not a Merchant Center account;
        ///      - MC account doesn't have a homepage;
        ///      - claiming failed (in this case the error message will contain more
        ///      details).
        pub async fn claim_homepage(
            &mut self,
            request: impl tonic::IntoRequest<super::ClaimHomepageRequest>,
        ) -> std::result::Result<tonic::Response<super::Homepage>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.HomepageService/ClaimHomepage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.HomepageService",
                        "ClaimHomepage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Unclaims a store's homepage. Executing this method requires admin access.
        pub async fn unclaim_homepage(
            &mut self,
            request: impl tonic::IntoRequest<super::UnclaimHomepageRequest>,
        ) -> std::result::Result<tonic::Response<super::Homepage>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.HomepageService/UnclaimHomepage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.HomepageService",
                        "UnclaimHomepage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Request message for the `GetOnlineReturnPolicy` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOnlineReturnPolicyRequest {
    /// Required. The name of the return policy to retrieve.
    /// Format: `accounts/{account}/onlineReturnPolicies/{return_policy}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `ListOnlineReturnPolicies` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOnlineReturnPoliciesRequest {
    /// Required. The merchant account for which to list return policies.
    /// Format: `accounts/{account}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `OnlineReturnPolicy` resources to return.
    /// The service returns fewer than this value if the number of return policies
    /// for the given merchant is less that than the `pageSize`. The default value
    /// is 10. The maximum value is 100; If a value higher than the maximum is
    /// specified, then the `pageSize` will default to the maximum
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListOnlineReturnPolicies`
    /// call. Provide the page token to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListOnlineReturnPolicies` must match the call that provided the page
    /// token. The token returned as
    /// [nextPageToken][google.shopping.merchant.accounts.v1beta.ListOnlineReturnPoliciesResponse.next_page_token]
    /// in the response to the previous request.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for the `ListOnlineReturnPolicies` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOnlineReturnPoliciesResponse {
    /// The retrieved return policies.
    #[prost(message, repeated, tag = "1")]
    pub online_return_policies: ::prost::alloc::vec::Vec<OnlineReturnPolicy>,
    /// A token, which can be sent as `pageToken` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// [Online return policy](<https://support.google.com/merchants/answer/10220642>)
/// object. This is currently used to represent return policies for ads and free
/// listings programs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnlineReturnPolicy {
    /// Identifier. The name of the `OnlineReturnPolicy` resource.
    /// Format: `accounts/{account}/onlineReturnPolicies/{return_policy}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Return policy ID generated by Google.
    #[prost(string, tag = "2")]
    pub return_policy_id: ::prost::alloc::string::String,
    /// This field represents the unique user-defined label of the return policy.
    /// It is important to note that the same label cannot be used in different
    /// return policies for the same country. Unless a product specifies a specific
    /// label attribute, policies will be automatically labeled as 'default'.
    /// To assign a custom return policy to certain product groups, follow the
    /// instructions provided in the \[Return policy label\]
    /// (<https://support.google.com/merchants/answer/9445425>).
    /// The label can contain up to 50 characters.
    #[prost(string, tag = "3")]
    pub label: ::prost::alloc::string::String,
    /// The countries of sale where the return policy applies. The values
    /// must be a valid 2 letter ISO 3166 code.
    #[prost(string, repeated, tag = "4")]
    pub countries: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The return policy.
    #[prost(message, optional, tag = "5")]
    pub policy: ::core::option::Option<online_return_policy::Policy>,
    /// The restocking fee that applies to all return reason categories. This would
    /// be treated as a free restocking fee if the value is not set.
    #[prost(message, optional, tag = "6")]
    pub restocking_fee: ::core::option::Option<online_return_policy::RestockingFee>,
    /// The return methods of how customers can return an item. This value is
    /// required to not be empty unless the type of return policy is noReturns.
    #[prost(enumeration = "online_return_policy::ReturnMethod", repeated, tag = "7")]
    pub return_methods: ::prost::alloc::vec::Vec<i32>,
    /// The item conditions accepted for returns must not be empty unless the type
    /// of return policy is 'noReturns'.
    #[prost(enumeration = "online_return_policy::ItemCondition", repeated, tag = "8")]
    pub item_conditions: ::prost::alloc::vec::Vec<i32>,
    /// The return shipping fee. Should be set only when customer need to download
    /// and print the return label.
    #[prost(message, optional, tag = "9")]
    pub return_shipping_fee: ::core::option::Option<
        online_return_policy::ReturnShippingFee,
    >,
    /// The return policy uri. This can used by Google to do a sanity check for the
    /// policy. It must be a valid URL.
    #[prost(string, tag = "10")]
    pub return_policy_uri: ::prost::alloc::string::String,
    /// This field specifies if merchant only accepts defective products for
    /// returns, and this field is required.
    #[prost(bool, optional, tag = "11")]
    pub accept_defective_only: ::core::option::Option<bool>,
    /// The field specifies the number of days it takes for merchants to process
    /// refunds, field is optional.
    #[prost(int32, optional, tag = "12")]
    pub process_refund_days: ::core::option::Option<i32>,
    /// This field specifies if merchant allows customers to exchange products,
    /// this field is required.
    #[prost(bool, optional, tag = "13")]
    pub accept_exchange: ::core::option::Option<bool>,
}
/// Nested message and enum types in `OnlineReturnPolicy`.
pub mod online_return_policy {
    /// The return shipping fee. This can either be a fixed fee or a boolean to
    /// indicate that the customer pays the actual shipping cost.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReturnShippingFee {
        /// Type of return shipping fee.
        #[prost(enumeration = "return_shipping_fee::Type", tag = "1")]
        pub r#type: i32,
        /// Fixed return shipping fee amount. This value is only applicable when type
        /// is `FIXED`. We will treat the return shipping fee as free if type is
        /// `FIXED` and this value is not set.
        #[prost(message, optional, tag = "2")]
        pub fixed_fee: ::core::option::Option<super::super::super::super::r#type::Price>,
    }
    /// Nested message and enum types in `ReturnShippingFee`.
    pub mod return_shipping_fee {
        /// Return shipping fee types.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            /// Default value. This value is unused.
            Unspecified = 0,
            /// The return shipping fee is a fixed value.
            Fixed = 1,
            /// Customers will pay the actual return shipping fee.
            CustomerPayingActualFee = 2,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TYPE_UNSPECIFIED",
                    Self::Fixed => "FIXED",
                    Self::CustomerPayingActualFee => "CUSTOMER_PAYING_ACTUAL_FEE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "FIXED" => Some(Self::Fixed),
                    "CUSTOMER_PAYING_ACTUAL_FEE" => Some(Self::CustomerPayingActualFee),
                    _ => None,
                }
            }
        }
    }
    /// The restocking fee. This can be a flat fee or a micro percent.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RestockingFee {
        #[prost(oneof = "restocking_fee::Type", tags = "1, 2")]
        pub r#type: ::core::option::Option<restocking_fee::Type>,
    }
    /// Nested message and enum types in `RestockingFee`.
    pub mod restocking_fee {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Type {
            /// Fixed restocking fee.
            #[prost(message, tag = "1")]
            FixedFee(super::super::super::super::super::r#type::Price),
            /// Percent of total price in micros. 15,000,000 means 15% of the total
            /// price would be charged.
            #[prost(int32, tag = "2")]
            MicroPercent(i32),
        }
    }
    /// The available policies.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Policy {
        /// Policy type.
        #[prost(enumeration = "policy::Type", tag = "1")]
        pub r#type: i32,
        /// The number of days items can be returned after delivery, where one day
        /// is defined as 24 hours after the delivery timestamp. Required for
        /// `NUMBER_OF_DAYS_AFTER_DELIVERY` returns.
        #[prost(int64, tag = "2")]
        pub days: i64,
    }
    /// Nested message and enum types in `Policy`.
    pub mod policy {
        /// Return policy types.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            /// Default value. This value is unused.
            Unspecified = 0,
            /// The number of days within which a return is valid after delivery.
            NumberOfDaysAfterDelivery = 1,
            /// No returns.
            NoReturns = 2,
            /// Life time returns.
            LifetimeReturns = 3,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TYPE_UNSPECIFIED",
                    Self::NumberOfDaysAfterDelivery => "NUMBER_OF_DAYS_AFTER_DELIVERY",
                    Self::NoReturns => "NO_RETURNS",
                    Self::LifetimeReturns => "LIFETIME_RETURNS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "NUMBER_OF_DAYS_AFTER_DELIVERY" => {
                        Some(Self::NumberOfDaysAfterDelivery)
                    }
                    "NO_RETURNS" => Some(Self::NoReturns),
                    "LIFETIME_RETURNS" => Some(Self::LifetimeReturns),
                    _ => None,
                }
            }
        }
    }
    /// The available return methods.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReturnMethod {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Return by mail.
        ByMail = 1,
        /// Return in store.
        InStore = 2,
        /// Return at a kiosk.
        AtAKiosk = 3,
    }
    impl ReturnMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RETURN_METHOD_UNSPECIFIED",
                Self::ByMail => "BY_MAIL",
                Self::InStore => "IN_STORE",
                Self::AtAKiosk => "AT_A_KIOSK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RETURN_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                "BY_MAIL" => Some(Self::ByMail),
                "IN_STORE" => Some(Self::InStore),
                "AT_A_KIOSK" => Some(Self::AtAKiosk),
                _ => None,
            }
        }
    }
    /// The available item conditions.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ItemCondition {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// New.
        New = 1,
        /// Used.
        Used = 2,
    }
    impl ItemCondition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ITEM_CONDITION_UNSPECIFIED",
                Self::New => "NEW",
                Self::Used => "USED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ITEM_CONDITION_UNSPECIFIED" => Some(Self::Unspecified),
                "NEW" => Some(Self::New),
                "USED" => Some(Self::Used),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod online_return_policy_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The service facilitates the management of a merchant's remorse return policy
    /// configuration, encompassing return policies for both ads and free listings
    /// ## programs. This API defines the following resource model:
    ///
    /// [OnlineReturnPolicy][google.shopping.merchant.accounts.v1.OnlineReturnPolicy]
    #[derive(Debug, Clone)]
    pub struct OnlineReturnPolicyServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl OnlineReturnPolicyServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> OnlineReturnPolicyServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> OnlineReturnPolicyServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            OnlineReturnPolicyServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Gets an existing return policy.
        pub async fn get_online_return_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOnlineReturnPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OnlineReturnPolicy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.OnlineReturnPolicyService/GetOnlineReturnPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.OnlineReturnPolicyService",
                        "GetOnlineReturnPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all existing return policies.
        pub async fn list_online_return_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOnlineReturnPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOnlineReturnPoliciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.OnlineReturnPolicyService/ListOnlineReturnPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.OnlineReturnPolicyService",
                        "ListOnlineReturnPolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Defines participation in a given program for the specified account.
///
/// Programs provide a mechanism for adding functionality to merchant accounts. A
/// typical example of this is the [Free product
/// listings](<https://support.google.com/merchants/topic/9240261?ref_topic=7257954,7259405,&sjid=796648681813264022-EU>)
/// program, which enables products from a merchant's store to be shown across
/// Google for free.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Program {
    /// Identifier. The resource name of the program.
    /// Format: `accounts/{account}/programs/{program}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The URL of a Merchant Center help page describing the program.
    #[prost(string, tag = "2")]
    pub documentation_uri: ::prost::alloc::string::String,
    /// Output only. The participation state of the account in the program.
    #[prost(enumeration = "program::State", tag = "3")]
    pub state: i32,
    /// Output only. The regions in which the account is actively participating in
    /// the program. Active regions are defined as those where all program
    /// requirements affecting the regions have been met.
    ///
    /// Region codes are defined by [CLDR](<https://cldr.unicode.org/>). This is
    /// either a country where the program applies specifically to that country or
    /// `001` when the program applies globally.
    #[prost(string, repeated, tag = "4")]
    pub active_region_codes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The requirements that the account has not yet satisfied that
    /// are affecting participation in the program.
    #[prost(message, repeated, tag = "5")]
    pub unmet_requirements: ::prost::alloc::vec::Vec<program::Requirement>,
}
/// Nested message and enum types in `Program`.
pub mod program {
    /// Defines a requirement specified for participation in the program.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Requirement {
        /// Output only. Name of the requirement.
        #[prost(string, tag = "1")]
        pub title: ::prost::alloc::string::String,
        /// Output only. The URL of a help page describing the requirement.
        #[prost(string, tag = "2")]
        pub documentation_uri: ::prost::alloc::string::String,
        /// Output only. The regions that are currently affected by this requirement
        /// not being met.
        ///
        /// Region codes are defined by [CLDR](<https://cldr.unicode.org/>). This is
        /// either a country where the program applies specifically to that country
        /// or `001` when the program applies globally.
        #[prost(string, repeated, tag = "3")]
        pub affected_region_codes: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
    /// Possible program participation states for the account.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The account is not eligible to participate in the program.
        NotEligible = 1,
        /// The account is eligible to participate in the program.
        Eligible = 2,
        /// The program is enabled for the account.
        Enabled = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::NotEligible => "NOT_ELIGIBLE",
                Self::Eligible => "ELIGIBLE",
                Self::Enabled => "ENABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "NOT_ELIGIBLE" => Some(Self::NotEligible),
                "ELIGIBLE" => Some(Self::Eligible),
                "ENABLED" => Some(Self::Enabled),
                _ => None,
            }
        }
    }
}
/// Request message for the GetProgram method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProgramRequest {
    /// Required. The name of the program to retrieve.
    /// Format: `accounts/{account}/programs/{program}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the ListPrograms method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProgramsRequest {
    /// Required. The name of the account for which to retrieve all programs.
    /// Format: `accounts/{account}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of programs to return in a single response. If
    /// unspecified (or 0), a default size of 1000 is used. The maximum value is
    /// 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A continuation token, received from a previous `ListPrograms`
    /// call. Provide this to retrieve the next page.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for the ListPrograms method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProgramsResponse {
    /// The programs for the given account.
    #[prost(message, repeated, tag = "1")]
    pub programs: ::prost::alloc::vec::Vec<Program>,
    /// A token that can be sent as `page_token` to retrieve the next page. If this
    /// field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for the EnableProgram method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnableProgramRequest {
    /// Required. The name of the program for which to enable participation for the
    /// given account. Format: `accounts/{account}/programs/{program}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the DisableProgram method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisableProgramRequest {
    /// Required. The name of the program for which to disable participation for
    /// the given account. Format: `accounts/{account}/programs/{program}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod programs_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for program management.
    ///
    /// Programs provide a mechanism for adding functionality to merchant accounts. A
    /// typical example of this is the [Free product
    /// listings](https://support.google.com/merchants/topic/9240261?ref_topic=7257954,7259405,&sjid=796648681813264022-EU)
    /// program, which enables products from a merchant's store to be shown across
    /// Google for free.
    ///
    /// This service exposes methods to retrieve a merchant's
    /// participation in all available programs, in addition to methods for
    /// explicitly enabling or disabling participation in each program.
    #[derive(Debug, Clone)]
    pub struct ProgramsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ProgramsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ProgramsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ProgramsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ProgramsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the specified program for the account.
        pub async fn get_program(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProgramRequest>,
        ) -> std::result::Result<tonic::Response<super::Program>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.ProgramsService/GetProgram",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.ProgramsService",
                        "GetProgram",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves all programs for the account.
        pub async fn list_programs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListProgramsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListProgramsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.ProgramsService/ListPrograms",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.ProgramsService",
                        "ListPrograms",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Enable participation in the specified program for the account. Executing
        /// this method requires admin access.
        pub async fn enable_program(
            &mut self,
            request: impl tonic::IntoRequest<super::EnableProgramRequest>,
        ) -> std::result::Result<tonic::Response<super::Program>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.ProgramsService/EnableProgram",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.ProgramsService",
                        "EnableProgram",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Disable participation in the specified program for the account. Executing
        /// this method requires admin access.
        pub async fn disable_program(
            &mut self,
            request: impl tonic::IntoRequest<super::DisableProgramRequest>,
        ) -> std::result::Result<tonic::Response<super::Program>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.ProgramsService/DisableProgram",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.ProgramsService",
                        "DisableProgram",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Request message for the `GetRegion` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionRequest {
    /// Required. The name of the region to retrieve.
    /// Format: `accounts/{account}/regions/{region}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `CreateRegion` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRegionRequest {
    /// Required. The account to create a region for.
    /// Format: `accounts/{account}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The identifier for the region, unique over all regions of the
    /// same account.
    #[prost(string, tag = "2")]
    pub region_id: ::prost::alloc::string::String,
    /// Required. The region to create.
    #[prost(message, optional, tag = "3")]
    pub region: ::core::option::Option<Region>,
}
/// Request message for the `UpdateRegion` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRegionRequest {
    /// Required. The updated region.
    #[prost(message, optional, tag = "1")]
    pub region: ::core::option::Option<Region>,
    /// Optional. The comma-separated field mask indicating the fields to update.
    /// Example:
    /// `"displayName,postalCodeArea.regionCode"`.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for the `DeleteRegion` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionRequest {
    /// Required. The name of the region to delete.
    /// Format: `accounts/{account}/regions/{region}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `ListRegions` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionsRequest {
    /// Required. The account to list regions for.
    /// Format: `accounts/{account}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of regions to return. The service may return
    /// fewer than this value.
    /// If unspecified, at most 50 regions will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListRegions` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListRegions` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for the `ListRegions` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionsResponse {
    /// The regions from the specified merchant.
    #[prost(message, repeated, tag = "1")]
    pub regions: ::prost::alloc::vec::Vec<Region>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Represents a geographic region that you can use as a target with both the
/// `RegionalInventory` and `ShippingSettings` services. You can define regions
/// as collections of either postal codes or, in some countries, using predefined
/// geotargets. For more information, see [Set up regions
/// ](<https://support.google.com/merchants/answer/7410946#zippy=%2Ccreate-a-new-region>)
/// for more information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Region {
    /// Identifier. The resource name of the region.
    /// Format: `accounts/{account}/regions/{region}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The display name of the region.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. A list of postal codes that defines the region area.
    #[prost(message, optional, tag = "3")]
    pub postal_code_area: ::core::option::Option<region::PostalCodeArea>,
    /// Optional. A list of geotargets that defines the region area.
    #[prost(message, optional, tag = "4")]
    pub geotarget_area: ::core::option::Option<region::GeoTargetArea>,
    /// Output only. Indicates if the region is eligible for use in the Regional
    /// Inventory configuration.
    #[prost(message, optional, tag = "5")]
    pub regional_inventory_eligible: ::core::option::Option<bool>,
    /// Output only. Indicates if the region is eligible for use in the Shipping
    /// Services configuration.
    #[prost(message, optional, tag = "6")]
    pub shipping_eligible: ::core::option::Option<bool>,
}
/// Nested message and enum types in `Region`.
pub mod region {
    /// A list of postal codes that defines the region area.
    /// Note: All regions defined using postal codes are accessible through the
    /// account's `ShippingSettings.postalCodeGroups` resource.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PostalCodeArea {
        /// Required. [CLDR territory
        /// code](<http://www.unicode.org/repos/cldr/tags/latest/common/main/en.xml>)
        /// or the country the postal code group applies to.
        #[prost(string, tag = "1")]
        pub region_code: ::prost::alloc::string::String,
        /// Required. A range of postal codes.
        #[prost(message, repeated, tag = "2")]
        pub postal_codes: ::prost::alloc::vec::Vec<postal_code_area::PostalCodeRange>,
    }
    /// Nested message and enum types in `PostalCodeArea`.
    pub mod postal_code_area {
        /// A range of postal codes that defines the region area.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PostalCodeRange {
            /// Required. A postal code or a pattern of the form prefix* denoting the
            /// inclusive lower bound of the range defining the area. Examples values:
            /// `94108`, `9410*`, `9*`.
            #[prost(string, tag = "1")]
            pub begin: ::prost::alloc::string::String,
            /// Optional. A postal code or a pattern of the form `prefix*` denoting the
            /// inclusive upper bound of the range defining the area. It must have the
            /// same length as postalCodeRangeBegin: if postalCodeRangeBegin is a
            /// postal code then postalCodeRangeEnd must be a postal code too; if
            /// postalCodeRangeBegin is a pattern then postalCodeRangeEnd must be a
            /// pattern with the same prefix length. Optional: if not set, then the
            /// area is defined as being all the postal codes matching
            /// postalCodeRangeBegin.
            #[prost(string, tag = "2")]
            pub end: ::prost::alloc::string::String,
        }
    }
    /// A list of geotargets that defines the region area.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GeoTargetArea {
        /// Required. A non-empty list of [location
        /// IDs](<https://developers.google.com/adwords/api/docs/appendix/geotargeting>).
        /// They must all be of the same location type (for example, state).
        #[prost(int64, repeated, packed = "false", tag = "1")]
        pub geotarget_criteria_ids: ::prost::alloc::vec::Vec<i64>,
    }
}
/// Generated client implementations.
pub mod regions_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Manages regions configuration.
    ///
    /// This API defines the following resource model:
    ///
    /// - [Region][google.shopping.merchant.accounts.v1main.Region]
    #[derive(Debug, Clone)]
    pub struct RegionsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RegionsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RegionsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            RegionsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves a region defined in your Merchant Center account.
        pub async fn get_region(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionRequest>,
        ) -> std::result::Result<tonic::Response<super::Region>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.RegionsService/GetRegion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.RegionsService",
                        "GetRegion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a region definition in your Merchant Center account. Executing this
        /// method requires admin access.
        pub async fn create_region(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateRegionRequest>,
        ) -> std::result::Result<tonic::Response<super::Region>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.RegionsService/CreateRegion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.RegionsService",
                        "CreateRegion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a region definition in your Merchant Center account. Executing this
        /// method requires admin access.
        pub async fn update_region(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateRegionRequest>,
        ) -> std::result::Result<tonic::Response<super::Region>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.RegionsService/UpdateRegion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.RegionsService",
                        "UpdateRegion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a region definition from your Merchant Center account. Executing
        /// this method requires admin access.
        pub async fn delete_region(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRegionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.RegionsService/DeleteRegion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.RegionsService",
                        "DeleteRegion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the regions in your Merchant Center account.
        pub async fn list_regions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRegionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.RegionsService/ListRegions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.RegionsService",
                        "ListRegions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The merchant account's [shipping
/// setting](<https://support.google.com/merchants/answer/6069284>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShippingSettings {
    /// Identifier. The resource name of the shipping setting.
    /// Format: `accounts/{account}/shippingSetting`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The target account's list of services.
    #[prost(message, repeated, tag = "2")]
    pub services: ::prost::alloc::vec::Vec<Service>,
    /// Optional. A list of warehouses which can be referred to in `services`.
    #[prost(message, repeated, tag = "3")]
    pub warehouses: ::prost::alloc::vec::Vec<Warehouse>,
    /// Required. This field is used for avoid async issue. Make sure shipping
    /// setting data
    ///   didn't change between get call and insert call. The user should do
    ///   following steps
    ///
    /// 1. Set etag field as empty string for initial shipping setting creation.
    ///
    /// 2. After initial creation, call get method to obtain an etag and current
    /// shipping setting data before call insert.
    ///
    /// 3. Modify to wanted shipping setting information.
    ///
    /// 4. Call insert method with the wanted shipping setting information with
    /// the etag obtained from step 2.
    ///
    /// 5. If shipping setting data changed between step 2 and step 4. Insert
    /// request will fail because the etag changes every time the shipping setting
    /// data changes. User should repeate step 2-4 with the new etag.
    #[prost(string, tag = "4")]
    pub etag: ::prost::alloc::string::String,
}
/// Shipping service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Service {
    /// Required. Free-form name of the service. Must be unique within target
    /// account.
    #[prost(string, optional, tag = "1")]
    pub service_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. A boolean exposing the active status of the shipping service.
    #[prost(bool, optional, tag = "2")]
    pub active: ::core::option::Option<bool>,
    /// Required. The CLDR territory code of the countries to which the service
    /// applies.
    #[prost(string, repeated, tag = "3")]
    pub delivery_countries: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The CLDR code of the currency to which this service applies. Must match
    /// that of the prices in rate groups.
    #[prost(string, optional, tag = "4")]
    pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. Time spent in various aspects from order to the delivery of the
    /// product.
    #[prost(message, optional, tag = "5")]
    pub delivery_time: ::core::option::Option<DeliveryTime>,
    /// Optional. Shipping rate group definitions. Only the last one is allowed to
    /// have an empty `applicable_shipping_labels`, which means "everything else".
    /// The other `applicable_shipping_labels` must not overlap.
    #[prost(message, repeated, tag = "6")]
    pub rate_groups: ::prost::alloc::vec::Vec<RateGroup>,
    /// Type of locations this service ships orders to.
    #[prost(enumeration = "service::ShipmentType", optional, tag = "7")]
    pub shipment_type: ::core::option::Option<i32>,
    /// Minimum order value for this service. If set, indicates that customers
    /// will have to spend at least this amount.
    /// All prices within a service must have the same currency.
    /// Cannot be set together with minimum_order_value_table.
    #[prost(message, optional, tag = "8")]
    pub minimum_order_value: ::core::option::Option<super::super::super::r#type::Price>,
    /// Table of per store minimum order values for the pickup fulfillment type.
    /// Cannot be set together with minimum_order_value.
    #[prost(message, optional, tag = "9")]
    pub minimum_order_value_table: ::core::option::Option<MinimumOrderValueTable>,
    /// A list of stores your products are delivered from.
    /// This is only valid for the local delivery shipment type.
    #[prost(message, optional, tag = "10")]
    pub store_config: ::core::option::Option<service::StoreConfig>,
    /// Optional. Loyalty programs that this shipping service is limited to.
    #[prost(message, repeated, tag = "11")]
    pub loyalty_programs: ::prost::alloc::vec::Vec<service::LoyaltyProgram>,
}
/// Nested message and enum types in `Service`.
pub mod service {
    /// A list of stores your products are delivered from.
    /// This is only valid for the local delivery shipment type.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StoreConfig {
        /// Indicates whether all stores, or selected stores, listed by this
        /// merchant provide local delivery.
        #[prost(enumeration = "store_config::StoreServiceType", optional, tag = "1")]
        pub store_service_type: ::core::option::Option<i32>,
        /// Optional. A list of store codes that provide local delivery.
        /// If empty, then `all_stores` must be true.
        #[prost(string, repeated, tag = "2")]
        pub store_codes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Configs related to local delivery ends for the day.
        #[prost(message, optional, tag = "3")]
        pub cutoff_config: ::core::option::Option<store_config::CutoffConfig>,
        /// Maximum delivery radius.
        /// This is only required for the local delivery shipment type.
        #[prost(message, optional, tag = "4")]
        pub service_radius: ::core::option::Option<super::Distance>,
    }
    /// Nested message and enum types in `StoreConfig`.
    pub mod store_config {
        /// Configs related to local delivery ends for the day.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct CutoffConfig {
            /// Time that local delivery ends for the day.
            #[prost(message, optional, tag = "1")]
            pub local_cutoff_time: ::core::option::Option<
                cutoff_config::LocalCutoffTime,
            >,
            /// Only valid with local delivery fulfillment. Represents cutoff time
            /// as the number of hours before store closing. Mutually exclusive
            /// with `local_cutoff_time`.
            #[prost(int64, optional, tag = "2")]
            pub store_close_offset_hours: ::core::option::Option<i64>,
            /// Merchants can opt-out of showing n+1 day local delivery when they have
            /// a shipping service configured to n day local delivery. For example, if
            /// the shipping service defines same-day delivery, and it's past the
            /// cut-off, setting this field to `true` results in the calculated
            /// shipping service rate returning `NO_DELIVERY_POST_CUTOFF`. In the
            /// same example, setting this field to `false` results in the calculated
            /// shipping time being one day. This is only for local delivery.
            #[prost(bool, optional, tag = "3")]
            pub no_delivery_post_cutoff: ::core::option::Option<bool>,
        }
        /// Nested message and enum types in `CutoffConfig`.
        pub mod cutoff_config {
            /// Time that local delivery ends for the day.
            #[derive(Clone, Copy, PartialEq, ::prost::Message)]
            pub struct LocalCutoffTime {
                /// Hour local delivery orders must be placed by to process the same
                /// day.
                #[prost(int64, optional, tag = "1")]
                pub hour: ::core::option::Option<i64>,
                /// Minute local delivery orders must be placed by to process the same
                /// day.
                #[prost(int64, optional, tag = "2")]
                pub minute: ::core::option::Option<i64>,
            }
        }
        /// Indicates whether all stores, or selected stores, listed by the
        /// merchant provide local delivery.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum StoreServiceType {
            /// Did not specify store service type.
            Unspecified = 0,
            /// Indicates whether all stores, current and future, listed by this
            /// merchant provide local delivery.
            AllStores = 1,
            /// Indicates that only the stores listed in `store_codes` are eligible
            /// for local delivery.
            SelectedStores = 2,
        }
        impl StoreServiceType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STORE_SERVICE_TYPE_UNSPECIFIED",
                    Self::AllStores => "ALL_STORES",
                    Self::SelectedStores => "SELECTED_STORES",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STORE_SERVICE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ALL_STORES" => Some(Self::AllStores),
                    "SELECTED_STORES" => Some(Self::SelectedStores),
                    _ => None,
                }
            }
        }
    }
    /// [Loyalty program](<https://support.google.com/merchants/answer/12922446>)
    /// provided by a merchant.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LoyaltyProgram {
        /// This is the loyalty program label set in your loyalty program settings in
        /// Merchant Center. This sub-attribute allows Google to map your loyalty
        /// program to eligible offers.
        #[prost(string, optional, tag = "1")]
        pub program_label: ::core::option::Option<::prost::alloc::string::String>,
        /// Optional. Loyalty program tier of this shipping service.
        #[prost(message, repeated, tag = "2")]
        pub loyalty_program_tiers: ::prost::alloc::vec::Vec<
            loyalty_program::LoyaltyProgramTiers,
        >,
    }
    /// Nested message and enum types in `LoyaltyProgram`.
    pub mod loyalty_program {
        /// Subset of a merchants loyalty program.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct LoyaltyProgramTiers {
            /// The tier label \[tier_label\] sub-attribute differentiates offer level
            /// benefits between each tier. This value is also set in your program
            /// settings in Merchant Center, and is required for data source changes
            /// even if your loyalty program only has 1 tier.
            #[prost(string, optional, tag = "1")]
            pub tier_label: ::core::option::Option<::prost::alloc::string::String>,
        }
    }
    /// Shipment type of shipping service.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ShipmentType {
        /// This service did not specify shipment type.
        Unspecified = 0,
        /// This service ships orders to an address chosen by the customer.
        Delivery = 1,
        /// This service ships orders to an address chosen by the customer.
        /// The order is shipped from a local store near by.
        LocalDelivery = 2,
        /// This service ships orders to an address chosen by the customer.
        /// The order is shipped from a collection point.
        CollectionPoint = 3,
    }
    impl ShipmentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SHIPMENT_TYPE_UNSPECIFIED",
                Self::Delivery => "DELIVERY",
                Self::LocalDelivery => "LOCAL_DELIVERY",
                Self::CollectionPoint => "COLLECTION_POINT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SHIPMENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "DELIVERY" => Some(Self::Delivery),
                "LOCAL_DELIVERY" => Some(Self::LocalDelivery),
                "COLLECTION_POINT" => Some(Self::CollectionPoint),
                _ => None,
            }
        }
    }
}
/// Maximum delivery radius.
/// This is only required for the local delivery shipment type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Distance {
    /// Integer value of distance.
    #[prost(int64, optional, tag = "1")]
    pub value: ::core::option::Option<i64>,
    /// Unit can differ based on country, it is parameterized to include miles
    /// and kilometers.
    #[prost(enumeration = "distance::Unit", optional, tag = "2")]
    pub unit: ::core::option::Option<i32>,
}
/// Nested message and enum types in `Distance`.
pub mod distance {
    /// Unit can differ based on country, it is parameterized to include miles
    /// and kilometers.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Unit {
        /// Unit unspecified
        Unspecified = 0,
        /// Unit in miles
        Miles = 1,
        /// Unit in kilometers
        Kilometers = 2,
    }
    impl Unit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNIT_UNSPECIFIED",
                Self::Miles => "MILES",
                Self::Kilometers => "KILOMETERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNIT_UNSPECIFIED" => Some(Self::Unspecified),
                "MILES" => Some(Self::Miles),
                "KILOMETERS" => Some(Self::Kilometers),
                _ => None,
            }
        }
    }
}
/// A fulfillment warehouse, which stores and handles inventory.
/// Next tag: 7
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Warehouse {
    /// Required. The name of the warehouse. Must be unique within account.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. Shipping address of the warehouse.
    #[prost(message, optional, tag = "2")]
    pub shipping_address: ::core::option::Option<Address>,
    /// Required. The latest time of day that an order can be accepted and begin
    /// processing. Later orders will be processed in the next day. The time is
    /// based on the warehouse postal code.
    #[prost(message, optional, tag = "3")]
    pub cutoff_time: ::core::option::Option<WarehouseCutoffTime>,
    /// Required. The number of days it takes for this warehouse to pack up and
    /// ship an item. This is on the warehouse level, but can be overridden on the
    /// offer level based on the attributes of an item.
    #[prost(int64, optional, tag = "4")]
    pub handling_days: ::core::option::Option<i64>,
    /// Business days of the warehouse.
    /// If not set, will be Monday to Friday by default.
    #[prost(message, optional, tag = "5")]
    pub business_day_config: ::core::option::Option<BusinessDayConfig>,
}
/// The latest time of day that an order can be accepted and begin processing.
/// Later orders will be processed in the next day. The time is based on the
/// warehouse postal code.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WarehouseCutoffTime {
    /// Required. Hour of the cutoff time until which an order has to be placed to
    /// be processed in the same day by the warehouse. Hour is based on the
    /// timezone of warehouse.
    #[prost(int32, optional, tag = "1")]
    pub hour: ::core::option::Option<i32>,
    /// Required. Minute of the cutoff time until which an order has to be placed
    /// to be processed in the same day by the warehouse. Minute is based on the
    /// timezone of warehouse.
    #[prost(int32, optional, tag = "2")]
    pub minute: ::core::option::Option<i32>,
}
/// Shipping address of the warehouse.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Address {
    /// Street-level part of the address. For example: `111w 31st Street`.
    #[prost(string, optional, tag = "1")]
    pub street_address: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. City, town or commune. May also include dependent localities or
    /// sublocalities (For example neighborhoods or suburbs).
    #[prost(string, optional, tag = "2")]
    pub city: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. Top-level administrative subdivision of the country. For example,
    /// a state like California ("CA") or a province like Quebec ("QC").
    #[prost(string, optional, tag = "3")]
    pub administrative_area: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. Postal code or ZIP (For example "94043").
    #[prost(string, optional, tag = "4")]
    pub postal_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. [CLDR country
    /// code](<http://www.unicode.org/repos/cldr/tags/latest/common/main/en.xml>)
    /// (For example "US").
    #[prost(string, optional, tag = "5")]
    pub region_code: ::core::option::Option<::prost::alloc::string::String>,
}
/// Time spent in various aspects from order to the delivery of the product.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeliveryTime {
    /// Minimum number of business days that is spent in transit. 0 means same
    /// day delivery, 1 means next day delivery.
    /// Either `min_transit_days`, `max_transit_days` or
    /// `transit_time_table` must be set, but not both.
    #[prost(int32, optional, tag = "1")]
    pub min_transit_days: ::core::option::Option<i32>,
    /// Maximum number of business days that is spent in transit. 0 means same
    /// day delivery, 1 means next day delivery. Must be greater than or equal
    /// to `min_transit_days`.
    #[prost(int32, optional, tag = "2")]
    pub max_transit_days: ::core::option::Option<i32>,
    /// Business days cutoff time definition.
    /// If not configured the cutoff time will be defaulted to 8AM PST.
    #[prost(message, optional, tag = "3")]
    pub cutoff_time: ::core::option::Option<CutoffTime>,
    /// Minimum number of business days spent before an order is shipped.
    /// 0 means same day shipped, 1 means next day shipped.
    /// 'min_handling_days' and 'max_handling_days' should be either set or not set
    /// at the same time.
    #[prost(int32, optional, tag = "4")]
    pub min_handling_days: ::core::option::Option<i32>,
    /// Maximum number of business days spent before an order is shipped.
    /// 0 means same day shipped, 1 means next day shipped.
    /// Must be greater than or equal to `min_handling_days`.
    /// 'min_handling_days' and 'max_handling_days' should be either set or not set
    /// at the same time.
    #[prost(int32, optional, tag = "5")]
    pub max_handling_days: ::core::option::Option<i32>,
    /// Transit time table, number of business days spent in transit based on row
    /// and column dimensions. Either `min_transit_days`, `max_transit_days` or
    /// `transit_time_table` can be set, but not both.
    #[prost(message, optional, tag = "6")]
    pub transit_time_table: ::core::option::Option<TransitTable>,
    /// The business days during which orders can be handled.
    /// If not provided, Monday to Friday business days will be assumed.
    #[prost(message, optional, tag = "7")]
    pub handling_business_day_config: ::core::option::Option<BusinessDayConfig>,
    /// The business days during which orders can be in-transit.
    /// If not provided, Monday to Friday business days will be assumed.
    #[prost(message, optional, tag = "8")]
    pub transit_business_day_config: ::core::option::Option<BusinessDayConfig>,
    /// Optional. Indicates that the delivery time should be calculated per
    /// warehouse (shipping origin location) based on the settings of the selected
    /// carrier. When set, no other transit time related field in [delivery
    /// time][\[google.shopping.content.bundles.ShippingSetting.DeliveryTime\] should
    /// be set.
    #[prost(message, repeated, tag = "9")]
    pub warehouse_based_delivery_times: ::prost::alloc::vec::Vec<
        WarehouseBasedDeliveryTime,
    >,
}
/// Business days cutoff time definition.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CutoffTime {
    /// Required. Hour of the cutoff time until which an order has to be placed to
    /// be processed in the same day.
    #[prost(int32, optional, tag = "1")]
    pub hour: ::core::option::Option<i32>,
    /// Required. Minute of the cutoff time until which an order has to be placed
    /// to be processed in the same day.
    #[prost(int32, optional, tag = "2")]
    pub minute: ::core::option::Option<i32>,
    /// Required. [Timezone
    /// identifier](<https://developers.google.com/adwords/api/docs/appendix/codes-formats#timezone-ids>)
    /// For example "Europe/Zurich".
    #[prost(string, optional, tag = "3")]
    pub time_zone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Business days of the warehouse.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BusinessDayConfig {
    /// Required. Regular business days.
    /// May not be empty.
    #[prost(
        enumeration = "business_day_config::Weekday",
        repeated,
        packed = "false",
        tag = "1"
    )]
    pub business_days: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `BusinessDayConfig`.
pub mod business_day_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Weekday {
        Unspecified = 0,
        Monday = 1,
        Tuesday = 2,
        Wednesday = 3,
        Thursday = 4,
        Friday = 5,
        Saturday = 6,
        Sunday = 7,
    }
    impl Weekday {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "WEEKDAY_UNSPECIFIED",
                Self::Monday => "MONDAY",
                Self::Tuesday => "TUESDAY",
                Self::Wednesday => "WEDNESDAY",
                Self::Thursday => "THURSDAY",
                Self::Friday => "FRIDAY",
                Self::Saturday => "SATURDAY",
                Self::Sunday => "SUNDAY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WEEKDAY_UNSPECIFIED" => Some(Self::Unspecified),
                "MONDAY" => Some(Self::Monday),
                "TUESDAY" => Some(Self::Tuesday),
                "WEDNESDAY" => Some(Self::Wednesday),
                "THURSDAY" => Some(Self::Thursday),
                "FRIDAY" => Some(Self::Friday),
                "SATURDAY" => Some(Self::Saturday),
                "SUNDAY" => Some(Self::Sunday),
                _ => None,
            }
        }
    }
}
/// Indicates that the delivery time should be calculated per warehouse
/// (shipping origin location) based on the settings of the selected carrier.
/// When set, no other transit time related field in `delivery_time` should be
/// set.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WarehouseBasedDeliveryTime {
    /// Required. Carrier, such as `"UPS"` or `"Fedex"`.
    #[prost(string, optional, tag = "1")]
    pub carrier: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. Carrier service, such as `"ground"` or `"2 days"`. The name of
    /// the service must be in the eddSupportedServices list.
    #[prost(string, optional, tag = "2")]
    pub carrier_service: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. Warehouse name. This should match
    /// [warehouse][ShippingSetting.warehouses.name]
    #[prost(string, optional, tag = "3")]
    pub warehouse: ::core::option::Option<::prost::alloc::string::String>,
}
/// Shipping rate group definitions. Only the last one is allowed to have an
/// empty `applicable_shipping_labels`, which means
/// "everything else". The other `applicable_shipping_labels` must
/// not overlap.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RateGroup {
    /// Required. A list of [shipping
    /// labels](<https://support.google.com/merchants/answer/6324504>) defining the
    /// products to which this rate group applies to. This is a disjunction: only
    /// one of the labels has to match for the rate group to apply. May only be
    /// empty for the last rate group of a service.
    #[prost(string, repeated, tag = "1")]
    pub applicable_shipping_labels: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// The value of the rate group (For example flat rate $10). Can only be set
    /// if `main_table` and `subtables` are not set.
    #[prost(message, optional, tag = "2")]
    pub single_value: ::core::option::Option<Value>,
    /// A table defining the rate group, when `single_value` is not
    /// expressive enough. Can only be set if `single_value` is not
    /// set.
    #[prost(message, optional, tag = "3")]
    pub main_table: ::core::option::Option<Table>,
    /// Optional. A list of subtables referred to by `main_table`. Can only
    /// be set if `main_table` is set.
    #[prost(message, repeated, tag = "4")]
    pub subtables: ::prost::alloc::vec::Vec<Table>,
    /// Optional. A list of carrier rates that can be referred to by
    /// `main_table` or `single_value`.
    #[prost(message, repeated, tag = "5")]
    pub carrier_rates: ::prost::alloc::vec::Vec<CarrierRate>,
    /// Optional. Name of the rate group.
    /// If set has to be unique within shipping service.
    #[prost(string, optional, tag = "6")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
/// A table defining the rate group, when `single_value` is not
/// expressive enough.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Table {
    /// Name of the table. Required for subtables, ignored for the main table.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. Headers of the table's rows.
    #[prost(message, optional, tag = "2")]
    pub row_headers: ::core::option::Option<Headers>,
    /// Headers of the table's columns. Optional: if not set then the table has
    /// only one dimension.
    #[prost(message, optional, tag = "3")]
    pub column_headers: ::core::option::Option<Headers>,
    /// Required. The list of rows that constitute the table. Must have the same
    /// length as `row_headers`.
    #[prost(message, repeated, tag = "4")]
    pub rows: ::prost::alloc::vec::Vec<Row>,
}
/// Transit time table, number of business days spent in transit based on row
/// and column dimensions. Either `min_transit_days`, `max_transit_days` or
/// `transit_time_table` can be set, but not both.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransitTable {
    /// Required. A list of region names
    /// [Region.name][google.shopping.merchant.accounts.v1beta.Region.name] . The
    /// last value can be
    /// `"all other locations"`. Example:
    /// `\["zone 1", "zone 2", "all other locations"\]`. The referred
    /// postal code groups must match the delivery country of the service.
    #[prost(string, repeated, tag = "1")]
    pub postal_code_group_names: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Required. A list of transit time labels. The last value can be
    /// `"all other labels"`. Example:
    /// `\["food", "electronics", "all other labels"\]`.
    #[prost(string, repeated, tag = "2")]
    pub transit_time_labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required. If there's only one dimension set of `postal_code_group_names` or
    /// `transit_time_labels`, there are multiple rows each with one value
    /// for that dimension. If there are two dimensions, each row corresponds to a
    /// `postal_code_group_names`, and columns (values) to a
    /// `transit_time_labels`.
    #[prost(message, repeated, tag = "3")]
    pub rows: ::prost::alloc::vec::Vec<transit_table::TransitTimeRow>,
}
/// Nested message and enum types in `TransitTable`.
pub mod transit_table {
    /// If there's only one dimension set of `postal_code_group_names` or
    /// `transit_time_labels`, there are multiple rows each with one value
    /// for that dimension. If there are two dimensions, each row corresponds to a
    /// `postal_code_group_names`, and columns (values) to a
    /// `transit_time_labels`.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransitTimeRow {
        /// Required. Transit time range (min-max) in business days.
        #[prost(message, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<transit_time_row::TransitTimeValue>,
    }
    /// Nested message and enum types in `TransitTimeRow`.
    pub mod transit_time_row {
        /// Transit time range (min-max) in business days.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct TransitTimeValue {
            /// Minimum transit time range in business days. 0 means same
            /// day delivery, 1 means next day delivery.
            #[prost(int32, optional, tag = "1")]
            pub min_transit_days: ::core::option::Option<i32>,
            /// Must be greater than or equal to `min_transit_days`.
            #[prost(int32, optional, tag = "2")]
            pub max_transit_days: ::core::option::Option<i32>,
        }
    }
}
/// Table of per store minimum order values for the pickup fulfillment type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MinimumOrderValueTable {
    /// Required. A list of store code sets sharing the same minimum order value
    /// (MOV). At least two sets are required and the last one must be empty, which
    /// signifies 'MOV for all other stores'. Each store code can only appear once
    /// across all the sets. All prices within a service must have the same
    /// currency.
    #[prost(message, repeated, tag = "1")]
    pub store_code_set_with_movs: ::prost::alloc::vec::Vec<
        minimum_order_value_table::StoreCodeSetWithMov,
    >,
}
/// Nested message and enum types in `MinimumOrderValueTable`.
pub mod minimum_order_value_table {
    /// A list of store code sets sharing the same minimum order value. At least
    /// two sets are required and the last one must be empty, which signifies
    /// 'MOV for all other stores'.
    /// Each store code can only appear once across all the sets.
    /// All prices within a service must have the same currency.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StoreCodeSetWithMov {
        /// Optional. A list of unique store codes or empty for the catch all.
        #[prost(string, repeated, tag = "1")]
        pub store_codes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// The minimum order value for the given stores.
        #[prost(message, optional, tag = "2")]
        pub value: ::core::option::Option<super::super::super::super::r#type::Price>,
    }
}
/// A non-empty list of row or column headers for a table.
/// Exactly one of `prices`, `weights`,
/// `num_items`, `postal_code_group_names`, or
/// `location` must be set.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Headers {
    /// Required. A list of inclusive order price upper bounds. The last price's
    /// value can be infinity by setting price amount_micros = -1. For example
    /// `[{"amount_micros": 10000000, "currency_code": "USD"},
    /// {"amount_micros": 500000000, "currency_code": "USD"},
    /// {"amount_micros": -1, "currency_code": "USD"}]` represents the headers
    /// "<= $10", "<= $500", and "> $500". All prices within a service must have
    /// the same currency. Must be non-empty. Must be positive except -1. Can only
    /// be set if all other fields are not set.
    #[prost(message, repeated, tag = "1")]
    pub prices: ::prost::alloc::vec::Vec<super::super::super::r#type::Price>,
    /// Required. A list of inclusive order weight upper bounds. The last weight's
    /// value can be infinity by setting price amount_micros = -1. For example
    /// `[{"amount_micros": 10000000, "unit": "kg"}, {"amount_micros": 50000000,
    /// "unit": "kg"},
    /// {"amount_micros": -1, "unit": "kg"}]` represents the headers
    /// "<= 10kg", "<= 50kg", and "> 50kg". All weights within a service must have
    /// the same unit. Must be non-empty. Must be positive except -1. Can only be
    /// set if all other fields are not set.
    #[prost(message, repeated, tag = "2")]
    pub weights: ::prost::alloc::vec::Vec<super::super::super::r#type::Weight>,
    /// Required. A list of inclusive number of items upper bounds. The last value
    /// can be
    /// `"infinity"`. For example
    /// `\["10", "50", "infinity"\]` represents the headers
    /// "<= 10 items", "<= 50 items", and "> 50 items". Must be non-empty. Can
    /// only be set if all other fields are not set.
    #[prost(string, repeated, tag = "3")]
    pub number_of_items: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required. A list of postal group names. The last value can be
    /// `"all other locations"`. Example:
    /// `\["zone 1", "zone 2", "all other locations"\]`. The referred
    /// postal code groups must match the delivery country of the service. Must
    /// be non-empty. Can only be set if all other fields are not set.
    #[prost(string, repeated, tag = "4")]
    pub postal_code_group_names: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Required. A list of location ID sets. Must be non-empty. Can only be set if
    /// all other fields are not set.
    #[prost(message, repeated, tag = "5")]
    pub locations: ::prost::alloc::vec::Vec<LocationIdSet>,
}
/// A list of location ID sets. Must be non-empty. Can only be set if all
/// other fields are not set.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationIdSet {
    /// Required. A non-empty list of
    /// [location
    /// IDs](<https://developers.google.com/adwords/api/docs/appendix/geotargeting>).
    /// They must all be of the same location type (For
    /// example, state).
    #[prost(string, repeated, tag = "1")]
    pub location_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Include a list of cells.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Row {
    /// Required. The list of cells that constitute the row. Must have the same
    /// length as `columnHeaders` for two-dimensional tables, a length of 1 for
    /// one-dimensional tables.
    #[prost(message, repeated, tag = "1")]
    pub cells: ::prost::alloc::vec::Vec<Value>,
}
/// The single value of a rate group or the value of a rate group table's cell.
/// Exactly one of `no_shipping`, `flat_rate`,
/// `price_percentage`, `carrier_rateName`,
/// `subtable_name` must be set.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    /// If true, then the product can't be shipped. Must be true when set, can only
    /// be set if all other fields are not set.
    #[prost(bool, optional, tag = "1")]
    pub no_shipping: ::core::option::Option<bool>,
    /// A flat rate. Can only be set if all other fields are not set.
    #[prost(message, optional, tag = "2")]
    pub flat_rate: ::core::option::Option<super::super::super::r#type::Price>,
    /// A percentage of the price represented as a number in decimal notation
    /// (For example, `"5.4"`). Can only be set if all other fields are not
    /// set.
    #[prost(string, optional, tag = "3")]
    pub price_percentage: ::core::option::Option<::prost::alloc::string::String>,
    /// The name of a carrier rate referring to a carrier rate defined in the
    /// same rate group. Can only be set if all other fields are not set.
    #[prost(string, optional, tag = "4")]
    pub carrier_rate: ::core::option::Option<::prost::alloc::string::String>,
    /// The name of a subtable. Can only be set in table cells (For example, not
    /// for single values), and only if all other fields are not set.
    #[prost(string, optional, tag = "5")]
    pub subtable: ::core::option::Option<::prost::alloc::string::String>,
}
/// A list of carrier rates that can be referred to by
/// `main_table` or `single_value`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CarrierRate {
    /// Required. Name of the carrier rate. Must be unique per rate group.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. Carrier service, such as `"UPS"` or `"Fedex"`.
    #[prost(string, optional, tag = "2")]
    pub carrier: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. Carrier service, such as `"ground"` or `"2 days"`.
    #[prost(string, optional, tag = "3")]
    pub carrier_service: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. Shipping origin for this carrier rate.
    #[prost(string, optional, tag = "4")]
    pub origin_postal_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Multiplicative shipping rate modifier as a number in decimal
    /// notation. Can be negative. For example `"5.4"` increases the rate by 5.4%,
    /// `"-3"` decreases the rate by 3%.
    #[prost(string, optional, tag = "5")]
    pub percentage_adjustment: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Additive shipping rate modifier. Can be negative. For example
    /// `{ "amount_micros": 1, "currency_code" : "USD" }` adds $1 to the rate,
    /// `{ "amount_micros": -3, "currency_code" : "USD" }` removes $3 from the
    /// rate.
    #[prost(message, optional, tag = "6")]
    pub flat_adjustment: ::core::option::Option<super::super::super::r#type::Price>,
}
/// Request message for the `GetShippingSetting` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetShippingSettingsRequest {
    /// Required. The name of the shipping setting to retrieve.
    /// Format: `accounts/{account}/shippingsetting`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `InsertShippingSetting` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertShippingSettingsRequest {
    /// Required. The account where this product will be inserted.
    /// Format: accounts/{account}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The new version of the account.
    #[prost(message, optional, tag = "2")]
    pub shipping_setting: ::core::option::Option<ShippingSettings>,
}
/// Generated client implementations.
pub mod shipping_settings_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to get method call shipping setting information per Merchant API
    /// method.
    #[derive(Debug, Clone)]
    pub struct ShippingSettingsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ShippingSettingsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ShippingSettingsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ShippingSettingsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ShippingSettingsServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieve shipping setting information.
        pub async fn get_shipping_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetShippingSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ShippingSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.ShippingSettingsService/GetShippingSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.ShippingSettingsService",
                        "GetShippingSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Replace the shipping setting of a merchant with the request shipping
        /// setting. Executing this method requires admin access.
        pub async fn insert_shipping_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertShippingSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ShippingSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.ShippingSettingsService/InsertShippingSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.ShippingSettingsService",
                        "InsertShippingSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The TermsOfService Kind.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TermsOfServiceKind {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// Merchant Center application.
    MerchantCenter = 1,
}
impl TermsOfServiceKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TERMS_OF_SERVICE_KIND_UNSPECIFIED",
            Self::MerchantCenter => "MERCHANT_CENTER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TERMS_OF_SERVICE_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "MERCHANT_CENTER" => Some(Self::MerchantCenter),
            _ => None,
        }
    }
}
/// A `TermsOfService`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TermsOfService {
    /// Identifier. The resource name of the terms of service version.
    /// Format: `termsOfService/{version}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Region code as defined by [CLDR](<https://cldr.unicode.org/>). This is either
    /// a country where the ToS applies specifically to that country or `001` when
    /// the same `TermsOfService` can be signed in any country. However note that
    /// when signing a ToS that applies globally we still expect that a specific
    /// country is provided  (this should be merchant business country or program
    /// country of participation).
    #[prost(string, tag = "2")]
    pub region_code: ::prost::alloc::string::String,
    /// The Kind this terms of service version applies to.
    #[prost(enumeration = "TermsOfServiceKind", tag = "3")]
    pub kind: i32,
    /// URI for terms of service file that needs to be displayed to signing users.
    #[prost(string, optional, tag = "4")]
    pub file_uri: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether this terms of service version is external. External terms of
    /// service versions can only be agreed through external processes and not
    /// directly by the merchant through UI or API.
    #[prost(bool, tag = "5")]
    pub external: bool,
}
/// Request message for the `GetTermsOfService` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTermsOfServiceRequest {
    /// Required. The resource name of the terms of service version.
    /// Format: `termsOfService/{version}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `RetrieveLatestTermsOfService` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveLatestTermsOfServiceRequest {
    /// Required. Region code as defined by [CLDR](<https://cldr.unicode.org/>). This
    /// is either a country when the ToS applies specifically to that country or
    /// 001 when it applies globally.
    #[prost(string, tag = "1")]
    pub region_code: ::prost::alloc::string::String,
    /// Required. The Kind this terms of service version applies to.
    #[prost(enumeration = "TermsOfServiceKind", tag = "2")]
    pub kind: i32,
}
/// Request message for the `AcceptTermsOfService` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceptTermsOfServiceRequest {
    /// Required. The resource name of the terms of service version.
    /// Format: `termsOfService/{version}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The account for which to accept the ToS.
    #[prost(string, tag = "2")]
    pub account: ::prost::alloc::string::String,
    /// Required. Region code as defined by [CLDR](<https://cldr.unicode.org/>). This
    /// is either a country when the ToS applies specifically to that country or
    /// 001 when it applies globally.
    #[prost(string, tag = "3")]
    pub region_code: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod terms_of_service_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to support `TermsOfService` API.
    #[derive(Debug, Clone)]
    pub struct TermsOfServiceServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TermsOfServiceServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TermsOfServiceServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TermsOfServiceServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TermsOfServiceServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the `TermsOfService` associated with the provided version.
        pub async fn get_terms_of_service(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTermsOfServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::TermsOfService>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.TermsOfServiceService/GetTermsOfService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.TermsOfServiceService",
                        "GetTermsOfService",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the latest version of the `TermsOfService` for a given `kind` and
        /// `region_code`.
        pub async fn retrieve_latest_terms_of_service(
            &mut self,
            request: impl tonic::IntoRequest<super::RetrieveLatestTermsOfServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::TermsOfService>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.TermsOfServiceService/RetrieveLatestTermsOfService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.TermsOfServiceService",
                        "RetrieveLatestTermsOfService",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Accepts a `TermsOfService`. Executing this method requires admin access.
        pub async fn accept_terms_of_service(
            &mut self,
            request: impl tonic::IntoRequest<super::AcceptTermsOfServiceRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.TermsOfServiceService/AcceptTermsOfService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.TermsOfServiceService",
                        "AcceptTermsOfService",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// This resource represents the agreement state for a given account and terms of
/// service kind.
/// The state is as follows:
///
/// * If the merchant has accepted a terms of service:
/// [accepted](TermsOfServiceAggrementState.accepted) will be populated,
/// otherwise it will be empty
/// * If the merchant must sign a terms of service:
/// [required](TermsOfServiceAggrementState.required) will be populated,
/// otherwise it will be empty.
///
/// Note that both [required](TermsOfServiceAggrementState.required) and
/// [accepted](TermsOfServiceAggrementState.accepted) can be present. In this
/// case the `accepted` terms of services will have an expiration date set in the
/// [valid_until](Accepted.valid_until) field. The `required` terms of services
/// need to be accepted before `valid_until` in order for the account to continue
/// having a valid agreement. When accepting new terms of services we expect 3Ps
/// to display the text associated with the given terms of service agreement (the
/// url to the file containing the text is added in the Required message below as
/// [tos_file_uri](Accepted.tos_file_uri). The actual acceptance of the terms of
/// service is done by calling accept on the [TermsOfService](TermsOfService)
/// resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TermsOfServiceAgreementState {
    /// Identifier. The resource name of the terms of service version.
    /// Format: `accounts/{account}/termsOfServiceAgreementState/{identifier}`
    /// The identifier format is: `{TermsOfServiceKind}-{country}`
    /// For example, an identifier could be: `MERCHANT_CENTER-US`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Region code as defined by <https://cldr.unicode.org/.> This is the
    /// country the current state applies to.
    #[prost(string, tag = "2")]
    pub region_code: ::prost::alloc::string::String,
    /// Terms of Service kind associated with the particular version.
    #[prost(enumeration = "TermsOfServiceKind", tag = "3")]
    pub terms_of_service_kind: i32,
    /// The accepted terms of service of this kind and for the associated
    /// region_code
    #[prost(message, optional, tag = "4")]
    pub accepted: ::core::option::Option<Accepted>,
    /// The required terms of service
    #[prost(message, optional, tag = "5")]
    pub required: ::core::option::Option<Required>,
}
/// Describes the accepted terms of service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Accepted {
    /// The accepted
    /// [termsOfService](google.shopping.merchant.accounts.v1main.TermsOfService).
    #[prost(string, tag = "1")]
    pub terms_of_service: ::prost::alloc::string::String,
    /// The account where the acceptance was recorded. This can be the account
    /// itself or, in the case of subaccounts, the MCA account.
    #[prost(string, tag = "2")]
    pub accepted_by: ::prost::alloc::string::String,
    /// When set, it states that the accepted
    /// [TermsOfService](google.shopping.merchant.accounts.v1main.TermsOfService)
    /// is only valid until the end of this date (in UTC). A new one must be
    /// accepted before then. The information of the required
    /// [TermsOfService](google.shopping.merchant.accounts.v1main.TermsOfService)
    /// is found in the [Required](Required) message.
    #[prost(message, optional, tag = "3")]
    pub valid_until: ::core::option::Option<super::super::super::super::r#type::Date>,
}
/// Describes the terms of service which are required to be accepted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Required {
    /// The
    /// [termsOfService](google.shopping.merchant.accounts.v1main.TermsOfService)
    /// that need to be accepted.
    #[prost(string, tag = "1")]
    pub terms_of_service: ::prost::alloc::string::String,
    /// Full URL to the terms of service file. This field is the same as
    /// [TermsOfService.file_uri](TermsOfService.file_uri), it is added
    /// here for convenience only.
    #[prost(string, tag = "2")]
    pub tos_file_uri: ::prost::alloc::string::String,
}
/// Request message for the `GetTermsOfServiceAgreementState` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTermsOfServiceAgreementStateRequest {
    /// Required. The resource name of the terms of service version.
    /// Format: `accounts/{account}/termsOfServiceAgreementState/{identifier}`
    /// The identifier format is: `{TermsOfServiceKind}-{country}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `RetrieveForApplicationTermsOfServiceAgreementState`
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveForApplicationTermsOfServiceAgreementStateRequest {
    /// Required. The account for which to get a TermsOfServiceAgreementState
    /// Format: `accounts/{account}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod terms_of_service_agreement_state_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to support `TermsOfServiceAgreementState` API.
    #[derive(Debug, Clone)]
    pub struct TermsOfServiceAgreementStateServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TermsOfServiceAgreementStateServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TermsOfServiceAgreementStateServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TermsOfServiceAgreementStateServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TermsOfServiceAgreementStateServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the state of a terms of service agreement.
        pub async fn get_terms_of_service_agreement_state(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetTermsOfServiceAgreementStateRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TermsOfServiceAgreementState>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.TermsOfServiceAgreementStateService/GetTermsOfServiceAgreementState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.TermsOfServiceAgreementStateService",
                        "GetTermsOfServiceAgreementState",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the state of the agreement for the application terms of service.
        pub async fn retrieve_for_application_terms_of_service_agreement_state(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RetrieveForApplicationTermsOfServiceAgreementStateRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TermsOfServiceAgreementState>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.accounts.v1beta.TermsOfServiceAgreementStateService/RetrieveForApplicationTermsOfServiceAgreementState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.accounts.v1beta.TermsOfServiceAgreementStateService",
                        "RetrieveForApplicationTermsOfServiceAgreementState",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
