// This file is @generated by prost-build.
/// Parameters that can be configured on Linux nodes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxNodeConfig {
    /// The Linux kernel parameters to be applied to the nodes and all pods running
    /// on the nodes.
    ///
    /// The following parameters are supported.
    ///
    /// net.core.busy_poll
    /// net.core.busy_read
    /// net.core.netdev_max_backlog
    /// net.core.rmem_max
    /// net.core.wmem_default
    /// net.core.wmem_max
    /// net.core.optmem_max
    /// net.core.somaxconn
    /// net.ipv4.tcp_rmem
    /// net.ipv4.tcp_wmem
    /// net.ipv4.tcp_tw_reuse
    /// kernel.shmmni
    /// kernel.shmmax
    /// kernel.shmall
    #[prost(map = "string, string", tag = "1")]
    pub sysctls: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// cgroup_mode specifies the cgroup mode to be used on the node.
    #[prost(enumeration = "linux_node_config::CgroupMode", tag = "2")]
    pub cgroup_mode: i32,
    /// Optional. Amounts for 2M and 1G hugepages
    #[prost(message, optional, tag = "3")]
    pub hugepages: ::core::option::Option<linux_node_config::HugepagesConfig>,
}
/// Nested message and enum types in `LinuxNodeConfig`.
pub mod linux_node_config {
    /// Hugepages amount in both 2m and 1g size
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct HugepagesConfig {
        /// Optional. Amount of 2M hugepages
        #[prost(int32, optional, tag = "1")]
        pub hugepage_size2m: ::core::option::Option<i32>,
        /// Optional. Amount of 1G hugepages
        #[prost(int32, optional, tag = "2")]
        pub hugepage_size1g: ::core::option::Option<i32>,
    }
    /// Possible cgroup modes that can be used.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CgroupMode {
        /// CGROUP_MODE_UNSPECIFIED is when unspecified cgroup configuration is used.
        /// The default for the GKE node OS image will be used.
        Unspecified = 0,
        /// CGROUP_MODE_V1 specifies to use cgroupv1 for the cgroup configuration on
        /// the node image.
        V1 = 1,
        /// CGROUP_MODE_V2 specifies to use cgroupv2 for the cgroup configuration on
        /// the node image.
        V2 = 2,
    }
    impl CgroupMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CGROUP_MODE_UNSPECIFIED",
                Self::V1 => "CGROUP_MODE_V1",
                Self::V2 => "CGROUP_MODE_V2",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CGROUP_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "CGROUP_MODE_V1" => Some(Self::V1),
                "CGROUP_MODE_V2" => Some(Self::V2),
                _ => None,
            }
        }
    }
}
/// Parameters that can be configured on Windows nodes.
/// Windows Node Config that define the parameters that will be used to
/// configure the Windows node pool settings
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WindowsNodeConfig {
    /// OSVersion specifies the Windows node config to be used on the node
    #[prost(enumeration = "windows_node_config::OsVersion", tag = "1")]
    pub os_version: i32,
}
/// Nested message and enum types in `WindowsNodeConfig`.
pub mod windows_node_config {
    /// Possible OS version that can be used.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OsVersion {
        /// When OSVersion is not specified
        Unspecified = 0,
        /// LTSC2019 specifies to use LTSC2019 as the Windows Servercore Base Image
        Ltsc2019 = 1,
        /// LTSC2022 specifies to use LTSC2022 as the Windows Servercore Base Image
        Ltsc2022 = 2,
    }
    impl OsVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OS_VERSION_UNSPECIFIED",
                Self::Ltsc2019 => "OS_VERSION_LTSC2019",
                Self::Ltsc2022 => "OS_VERSION_LTSC2022",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OS_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
                "OS_VERSION_LTSC2019" => Some(Self::Ltsc2019),
                "OS_VERSION_LTSC2022" => Some(Self::Ltsc2022),
                _ => None,
            }
        }
    }
}
/// Node kubelet configs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeKubeletConfig {
    /// Control the CPU management policy on the node.
    /// See
    /// <https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/>
    ///
    /// The following values are allowed.
    /// * "none": the default, which represents the existing scheduling behavior.
    /// * "static": allows pods with certain resource characteristics to be granted
    /// increased CPU affinity and exclusivity on the node.
    /// The default value is 'none' if unspecified.
    #[prost(string, tag = "1")]
    pub cpu_manager_policy: ::prost::alloc::string::String,
    /// Enable CPU CFS quota enforcement for containers that specify CPU limits.
    ///
    /// This option is enabled by default which makes kubelet use CFS quota
    /// (<https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt>) to
    /// enforce container CPU limits. Otherwise, CPU limits will not be enforced at
    /// all.
    ///
    /// Disable this option to mitigate CPU throttling problems while still having
    /// your pods to be in Guaranteed QoS class by specifying the CPU limits.
    ///
    /// The default value is 'true' if unspecified.
    #[prost(message, optional, tag = "2")]
    pub cpu_cfs_quota: ::core::option::Option<bool>,
    /// Set the CPU CFS quota period value 'cpu.cfs_period_us'.
    ///
    /// The string must be a sequence of decimal numbers, each with optional
    /// fraction and a unit suffix, such as "300ms".
    /// Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h".
    /// The value must be a positive duration.
    #[prost(string, tag = "3")]
    pub cpu_cfs_quota_period: ::prost::alloc::string::String,
    /// Set the Pod PID limits. See
    /// <https://kubernetes.io/docs/concepts/policy/pid-limiting/#pod-pid-limits>
    ///
    /// Controls the maximum number of processes allowed to run in a pod. The value
    /// must be greater than or equal to 1024 and less than 4194304.
    #[prost(int64, tag = "4")]
    pub pod_pids_limit: i64,
    /// Enable or disable Kubelet read only port.
    #[prost(bool, optional, tag = "7")]
    pub insecure_kubelet_readonly_port_enabled: ::core::option::Option<bool>,
}
/// Parameters that describe the nodes in a cluster.
///
/// GKE Autopilot clusters do not
/// recognize parameters in `NodeConfig`. Use
/// [AutoprovisioningNodePoolDefaults][google.container.v1.AutoprovisioningNodePoolDefaults]
/// instead.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeConfig {
    /// The name of a Google Compute Engine [machine
    /// type](<https://cloud.google.com/compute/docs/machine-types>)
    ///
    /// If unspecified, the default machine type is `e2-medium`.
    #[prost(string, tag = "1")]
    pub machine_type: ::prost::alloc::string::String,
    /// Size of the disk attached to each node, specified in GB.
    /// The smallest allowed disk size is 10GB.
    ///
    /// If unspecified, the default disk size is 100GB.
    #[prost(int32, tag = "2")]
    pub disk_size_gb: i32,
    /// The set of Google API scopes to be made available on all of the
    /// node VMs under the "default" service account.
    ///
    /// The following scopes are recommended, but not required, and by default are
    /// not included:
    ///
    /// * `<https://www.googleapis.com/auth/compute`> is required for mounting
    /// persistent storage on your nodes.
    /// * `<https://www.googleapis.com/auth/devstorage.read_only`> is required for
    /// communicating with **gcr.io**
    /// (the [Google Container
    /// Registry](<https://cloud.google.com/container-registry/>)).
    ///
    /// If unspecified, no scopes are added, unless Cloud Logging or Cloud
    /// Monitoring are enabled, in which case their required scopes will be added.
    #[prost(string, repeated, tag = "3")]
    pub oauth_scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The Google Cloud Platform Service Account to be used by the node VMs.
    /// Specify the email address of the Service Account; otherwise, if no Service
    /// Account is specified, the "default" service account is used.
    #[prost(string, tag = "9")]
    pub service_account: ::prost::alloc::string::String,
    /// The metadata key/value pairs assigned to instances in the cluster.
    ///
    /// Keys must conform to the regexp `\[a-zA-Z0-9-_\]+` and be less than 128 bytes
    /// in length. These are reflected as part of a URL in the metadata server.
    /// Additionally, to avoid ambiguity, keys must not conflict with any other
    /// metadata keys for the project or be one of the reserved keys:
    ///
    ///   - "cluster-location"
    ///   - "cluster-name"
    ///   - "cluster-uid"
    ///   - "configure-sh"
    ///   - "containerd-configure-sh"
    ///   - "enable-os-login"
    ///   - "gci-ensure-gke-docker"
    ///   - "gci-metrics-enabled"
    ///   - "gci-update-strategy"
    ///   - "instance-template"
    ///   - "kube-env"
    ///   - "startup-script"
    ///   - "user-data"
    ///   - "disable-address-manager"
    ///   - "windows-startup-script-ps1"
    ///   - "common-psm1"
    ///   - "k8s-node-setup-psm1"
    ///   - "install-ssh-psm1"
    ///   - "user-profile-psm1"
    ///
    /// Values are free-form strings, and only have meaning as interpreted by
    /// the image running in the instance. The only restriction placed on them is
    /// that each value's size must be less than or equal to 32 KB.
    ///
    /// The total size of all keys and values must be less than 512 KB.
    #[prost(map = "string, string", tag = "4")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The image type to use for this node. Note that for a given image type,
    /// the latest version of it will be used. Please see
    /// <https://cloud.google.com/kubernetes-engine/docs/concepts/node-images> for
    /// available image types.
    #[prost(string, tag = "5")]
    pub image_type: ::prost::alloc::string::String,
    /// The map of Kubernetes labels (key/value pairs) to be applied to each node.
    /// These will added in addition to any default label(s) that
    /// Kubernetes may apply to the node.
    /// In case of conflict in label keys, the applied set may differ depending on
    /// the Kubernetes version -- it's best to assume the behavior is undefined
    /// and conflicts should be avoided.
    /// For more information, including usage and the valid values, see:
    /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/>
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The number of local SSD disks to be attached to the node.
    ///
    /// The limit for this value is dependent upon the maximum number of
    /// disks available on a machine per zone. See:
    /// <https://cloud.google.com/compute/docs/disks/local-ssd>
    /// for more information.
    #[prost(int32, tag = "7")]
    pub local_ssd_count: i32,
    /// The list of instance tags applied to all nodes. Tags are used to identify
    /// valid sources or targets for network firewalls and are specified by
    /// the client during cluster or node pool creation. Each tag within the list
    /// must comply with RFC1035.
    #[prost(string, repeated, tag = "8")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Whether the nodes are created as preemptible VM instances. See:
    /// <https://cloud.google.com/compute/docs/instances/preemptible> for more
    /// information about preemptible VM instances.
    #[prost(bool, tag = "10")]
    pub preemptible: bool,
    /// A list of hardware accelerators to be attached to each node.
    /// See <https://cloud.google.com/compute/docs/gpus> for more information about
    /// support for GPUs.
    #[prost(message, repeated, tag = "11")]
    pub accelerators: ::prost::alloc::vec::Vec<AcceleratorConfig>,
    /// Type of the disk attached to each node (e.g. 'pd-standard', 'pd-ssd' or
    /// 'pd-balanced')
    ///
    /// If unspecified, the default disk type is 'pd-standard'
    #[prost(string, tag = "12")]
    pub disk_type: ::prost::alloc::string::String,
    /// Minimum CPU platform to be used by this instance. The instance may be
    /// scheduled on the specified or newer CPU platform. Applicable values are the
    /// friendly names of CPU platforms, such as
    /// `minCpuPlatform: "Intel Haswell"` or
    /// `minCpuPlatform: "Intel Sandy Bridge"`. For more
    /// information, read [how to specify min CPU
    /// platform](<https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform>)
    #[prost(string, tag = "13")]
    pub min_cpu_platform: ::prost::alloc::string::String,
    /// The workload metadata configuration for this node.
    #[prost(message, optional, tag = "14")]
    pub workload_metadata_config: ::core::option::Option<WorkloadMetadataConfig>,
    /// List of kubernetes taints to be applied to each node.
    ///
    /// For more information, including usage and the valid values, see:
    /// <https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/>
    #[prost(message, repeated, tag = "15")]
    pub taints: ::prost::alloc::vec::Vec<NodeTaint>,
    /// Sandbox configuration for this node.
    #[prost(message, optional, tag = "17")]
    pub sandbox_config: ::core::option::Option<SandboxConfig>,
    /// Setting this field will assign instances of this
    /// pool to run on the specified node group. This is useful for running
    /// workloads on [sole tenant
    /// nodes](<https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes>).
    #[prost(string, tag = "18")]
    pub node_group: ::prost::alloc::string::String,
    /// The optional reservation affinity. Setting this field will apply
    /// the specified [Zonal Compute
    /// Reservation](<https://cloud.google.com/compute/docs/instances/reserving-zonal-resources>)
    /// to this node pool.
    #[prost(message, optional, tag = "19")]
    pub reservation_affinity: ::core::option::Option<ReservationAffinity>,
    /// Shielded Instance options.
    #[prost(message, optional, tag = "20")]
    pub shielded_instance_config: ::core::option::Option<ShieldedInstanceConfig>,
    /// Parameters that can be configured on Linux nodes.
    #[prost(message, optional, tag = "21")]
    pub linux_node_config: ::core::option::Option<LinuxNodeConfig>,
    /// Node kubelet configs.
    #[prost(message, optional, tag = "22")]
    pub kubelet_config: ::core::option::Option<NodeKubeletConfig>,
    ///
    /// The Customer Managed Encryption Key used to encrypt the boot disk attached
    /// to each node in the node pool. This should be of the form
    /// projects/\[KEY_PROJECT_ID\]/locations/\[LOCATION\]/keyRings/\[RING_NAME\]/cryptoKeys/\[KEY_NAME\].
    /// For more information about protecting resources with Cloud KMS Keys please
    /// see:
    /// <https://cloud.google.com/compute/docs/disks/customer-managed-encryption>
    #[prost(string, tag = "23")]
    pub boot_disk_kms_key: ::prost::alloc::string::String,
    /// Google Container File System (image streaming) configs.
    #[prost(message, optional, tag = "25")]
    pub gcfs_config: ::core::option::Option<GcfsConfig>,
    /// Advanced features for the Compute Engine VM.
    #[prost(message, optional, tag = "26")]
    pub advanced_machine_features: ::core::option::Option<AdvancedMachineFeatures>,
    /// Enable or disable gvnic in the node pool.
    #[prost(message, optional, tag = "29")]
    pub gvnic: ::core::option::Option<VirtualNic>,
    /// Spot flag for enabling Spot VM, which is a rebrand of
    /// the existing preemptible flag.
    #[prost(bool, tag = "32")]
    pub spot: bool,
    /// Confidential nodes config.
    /// All the nodes in the node pool will be Confidential VM once enabled.
    #[prost(message, optional, tag = "35")]
    pub confidential_nodes: ::core::option::Option<ConfidentialNodes>,
    /// Enable or disable NCCL fast socket for the node pool.
    #[prost(message, optional, tag = "36")]
    pub fast_socket: ::core::option::Option<FastSocket>,
    /// The resource labels for the node pool to use to annotate any related
    /// Google Compute Engine resources.
    #[prost(map = "string, string", tag = "37")]
    pub resource_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Logging configuration.
    #[prost(message, optional, tag = "38")]
    pub logging_config: ::core::option::Option<NodePoolLoggingConfig>,
    /// Parameters that can be configured on Windows nodes.
    #[prost(message, optional, tag = "39")]
    pub windows_node_config: ::core::option::Option<WindowsNodeConfig>,
    /// Parameters for using raw-block Local NVMe SSDs.
    #[prost(message, optional, tag = "40")]
    pub local_nvme_ssd_block_config: ::core::option::Option<LocalNvmeSsdBlockConfig>,
    /// Parameters for the node ephemeral storage using Local SSDs.
    /// If unspecified, ephemeral storage is backed by the boot disk.
    #[prost(message, optional, tag = "41")]
    pub ephemeral_storage_local_ssd_config: ::core::option::Option<
        EphemeralStorageLocalSsdConfig,
    >,
    /// Parameters for node pools to be backed by shared sole tenant node groups.
    #[prost(message, optional, tag = "42")]
    pub sole_tenant_config: ::core::option::Option<SoleTenantConfig>,
    /// Parameters for containerd customization.
    #[prost(message, optional, tag = "43")]
    pub containerd_config: ::core::option::Option<ContainerdConfig>,
    /// A map of resource manager tag keys and values to be attached to the nodes.
    #[prost(message, optional, tag = "45")]
    pub resource_manager_tags: ::core::option::Option<ResourceManagerTags>,
    /// Optional. Reserved for future use.
    #[prost(bool, tag = "46")]
    pub enable_confidential_storage: bool,
    /// List of secondary boot disks attached to the nodes.
    #[prost(message, repeated, tag = "48")]
    pub secondary_boot_disks: ::prost::alloc::vec::Vec<SecondaryBootDisk>,
    /// List of Storage Pools where boot disks are provisioned.
    #[prost(string, repeated, tag = "49")]
    pub storage_pools: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Secondary boot disk update strategy.
    #[prost(message, optional, tag = "50")]
    pub secondary_boot_disk_update_strategy: ::core::option::Option<
        SecondaryBootDiskUpdateStrategy,
    >,
    /// Specifies which method should be used for encrypting the
    /// Local SSDs attahced to the node.
    #[prost(enumeration = "node_config::LocalSsdEncryptionMode", optional, tag = "54")]
    pub local_ssd_encryption_mode: ::core::option::Option<i32>,
    /// Output only. effective_cgroup_mode is the cgroup mode actually used by the
    /// node pool. It is determined by the cgroup mode specified in the
    /// LinuxNodeConfig or the default cgroup mode based on the cluster creation
    /// version.
    #[prost(enumeration = "node_config::EffectiveCgroupMode", tag = "55")]
    pub effective_cgroup_mode: i32,
}
/// Nested message and enum types in `NodeConfig`.
pub mod node_config {
    /// LocalSsdEncryptionMode specifies the method used for encrypting the Local
    /// SSDs attached to the node.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalSsdEncryptionMode {
        /// The given node will be encrypted using keys managed by Google
        /// infrastructure and the keys will be deleted when the node is
        /// deleted.
        Unspecified = 0,
        /// The given node will be encrypted using keys managed by Google
        /// infrastructure and the keys will be deleted when the node is
        /// deleted.
        StandardEncryption = 1,
        /// The given node will opt-in for using ephemeral key for
        /// encryption of Local SSDs.
        /// The Local SSDs will not be able to recover data in case of node
        /// crash.
        EphemeralKeyEncryption = 2,
    }
    impl LocalSsdEncryptionMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LOCAL_SSD_ENCRYPTION_MODE_UNSPECIFIED",
                Self::StandardEncryption => "STANDARD_ENCRYPTION",
                Self::EphemeralKeyEncryption => "EPHEMERAL_KEY_ENCRYPTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOCAL_SSD_ENCRYPTION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "STANDARD_ENCRYPTION" => Some(Self::StandardEncryption),
                "EPHEMERAL_KEY_ENCRYPTION" => Some(Self::EphemeralKeyEncryption),
                _ => None,
            }
        }
    }
    /// Possible effective cgroup modes for the node.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EffectiveCgroupMode {
        /// EFFECTIVE_CGROUP_MODE_UNSPECIFIED means the cgroup configuration for the
        /// node pool is unspecified, i.e. the node pool is a Windows node pool.
        Unspecified = 0,
        /// CGROUP_MODE_V1 means the node pool is configured to use cgroupv1 for the
        /// cgroup configuration.
        V1 = 1,
        /// CGROUP_MODE_V2 means the node pool is configured to use cgroupv2 for the
        /// cgroup configuration.
        V2 = 2,
    }
    impl EffectiveCgroupMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EFFECTIVE_CGROUP_MODE_UNSPECIFIED",
                Self::V1 => "EFFECTIVE_CGROUP_MODE_V1",
                Self::V2 => "EFFECTIVE_CGROUP_MODE_V2",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EFFECTIVE_CGROUP_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "EFFECTIVE_CGROUP_MODE_V1" => Some(Self::V1),
                "EFFECTIVE_CGROUP_MODE_V2" => Some(Self::V2),
                _ => None,
            }
        }
    }
}
/// Specifies options for controlling advanced machine features.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdvancedMachineFeatures {
    /// The number of threads per physical core. To disable simultaneous
    /// multithreading (SMT) set this to 1. If unset, the maximum number of threads
    /// supported per core by the underlying processor is assumed.
    #[prost(int64, optional, tag = "1")]
    pub threads_per_core: ::core::option::Option<i64>,
    /// Whether or not to enable nested virtualization (defaults to false).
    #[prost(bool, optional, tag = "2")]
    pub enable_nested_virtualization: ::core::option::Option<bool>,
}
/// Parameters for node pool-level network config.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeNetworkConfig {
    /// Input only. Whether to create a new range for pod IPs in this node pool.
    /// Defaults are provided for `pod_range` and `pod_ipv4_cidr_block` if they
    /// are not specified.
    ///
    /// If neither `create_pod_range` or `pod_range` are specified, the
    /// cluster-level default (`ip_allocation_policy.cluster_ipv4_cidr_block`) is
    /// used.
    ///
    /// Only applicable if `ip_allocation_policy.use_ip_aliases` is true.
    ///
    /// This field cannot be changed after the node pool has been created.
    #[prost(bool, tag = "4")]
    pub create_pod_range: bool,
    /// The ID of the secondary range for pod IPs.
    /// If `create_pod_range` is true, this ID is used for the new range.
    /// If `create_pod_range` is false, uses an existing secondary range with this
    /// ID.
    ///
    /// Only applicable if `ip_allocation_policy.use_ip_aliases` is true.
    ///
    /// This field cannot be changed after the node pool has been created.
    #[prost(string, tag = "5")]
    pub pod_range: ::prost::alloc::string::String,
    /// The IP address range for pod IPs in this node pool.
    ///
    /// Only applicable if `create_pod_range` is true.
    ///
    /// Set to blank to have a range chosen with the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](<https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing>)
    /// notation (e.g. `10.96.0.0/14`) to pick a specific range to use.
    ///
    /// Only applicable if `ip_allocation_policy.use_ip_aliases` is true.
    ///
    /// This field cannot be changed after the node pool has been created.
    #[prost(string, tag = "6")]
    pub pod_ipv4_cidr_block: ::prost::alloc::string::String,
    /// Whether nodes have internal IP addresses only.
    /// If enable_private_nodes is not specified, then the value is derived from
    /// [Cluster.NetworkConfig.default_enable_private_nodes][]
    #[prost(bool, optional, tag = "9")]
    pub enable_private_nodes: ::core::option::Option<bool>,
    /// Network bandwidth tier configuration.
    #[prost(message, optional, tag = "11")]
    pub network_performance_config: ::core::option::Option<
        node_network_config::NetworkPerformanceConfig,
    >,
    /// \[PRIVATE FIELD\]
    /// Pod CIDR size overprovisioning config for the nodepool.
    ///
    /// Pod CIDR size per node depends on max_pods_per_node. By default, the value
    /// of max_pods_per_node is rounded off to next power of 2 and we then double
    /// that to get the size of pod CIDR block per node.
    /// Example: max_pods_per_node of 30 would result in 64 IPs (/26).
    ///
    /// This config can disable the doubling of IPs (we still round off to next
    /// power of 2)
    /// Example: max_pods_per_node of 30 will result in 32 IPs (/27) when
    /// overprovisioning is disabled.
    #[prost(message, optional, tag = "13")]
    pub pod_cidr_overprovision_config: ::core::option::Option<
        PodCidrOverprovisionConfig,
    >,
    /// We specify the additional node networks for this node pool using this list.
    /// Each node network corresponds to an additional interface
    #[prost(message, repeated, tag = "14")]
    pub additional_node_network_configs: ::prost::alloc::vec::Vec<
        AdditionalNodeNetworkConfig,
    >,
    /// We specify the additional pod networks for this node pool using this list.
    /// Each pod network corresponds to an additional alias IP range for the node
    #[prost(message, repeated, tag = "15")]
    pub additional_pod_network_configs: ::prost::alloc::vec::Vec<
        AdditionalPodNetworkConfig,
    >,
    /// Output only. The utilization of the IPv4 range for the pod.
    /// The ratio is Usage/\[Total number of IPs in the secondary range\],
    /// Usage=numNodes*numZones*podIPsPerNode.
    #[prost(double, tag = "16")]
    pub pod_ipv4_range_utilization: f64,
}
/// Nested message and enum types in `NodeNetworkConfig`.
pub mod node_network_config {
    /// Configuration of all network bandwidth tiers
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct NetworkPerformanceConfig {
        /// Specifies the total network bandwidth tier for the NodePool.
        #[prost(enumeration = "network_performance_config::Tier", optional, tag = "1")]
        pub total_egress_bandwidth_tier: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `NetworkPerformanceConfig`.
    pub mod network_performance_config {
        /// Node network tier
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Tier {
            /// Default value
            Unspecified = 0,
            /// Higher bandwidth, actual values based on VM size.
            Tier1 = 1,
        }
        impl Tier {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TIER_UNSPECIFIED",
                    Self::Tier1 => "TIER_1",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TIER_UNSPECIFIED" => Some(Self::Unspecified),
                    "TIER_1" => Some(Self::Tier1),
                    _ => None,
                }
            }
        }
    }
}
/// AdditionalNodeNetworkConfig is the configuration for additional node networks
/// within the NodeNetworkConfig message
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionalNodeNetworkConfig {
    /// Name of the VPC where the additional interface belongs
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    /// Name of the subnetwork where the additional interface belongs
    #[prost(string, tag = "2")]
    pub subnetwork: ::prost::alloc::string::String,
}
/// AdditionalPodNetworkConfig is the configuration for additional pod networks
/// within the NodeNetworkConfig message
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionalPodNetworkConfig {
    /// Name of the subnetwork where the additional pod network belongs.
    #[prost(string, tag = "1")]
    pub subnetwork: ::prost::alloc::string::String,
    /// The name of the secondary range on the subnet which provides IP address for
    /// this pod range.
    #[prost(string, tag = "2")]
    pub secondary_pod_range: ::prost::alloc::string::String,
    /// The maximum number of pods per node which use this pod network.
    #[prost(message, optional, tag = "3")]
    pub max_pods_per_node: ::core::option::Option<MaxPodsConstraint>,
}
/// A set of Shielded Instance options.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShieldedInstanceConfig {
    /// Defines whether the instance has Secure Boot enabled.
    ///
    /// Secure Boot helps ensure that the system only runs authentic software by
    /// verifying the digital signature of all boot components, and halting the
    /// boot process if signature verification fails.
    #[prost(bool, tag = "1")]
    pub enable_secure_boot: bool,
    /// Defines whether the instance has integrity monitoring enabled.
    ///
    /// Enables monitoring and attestation of the boot integrity of the instance.
    /// The attestation is performed against the integrity policy baseline. This
    /// baseline is initially derived from the implicitly trusted boot image when
    /// the instance is created.
    #[prost(bool, tag = "2")]
    pub enable_integrity_monitoring: bool,
}
/// SandboxConfig contains configurations of the sandbox to use for the node.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SandboxConfig {
    /// Type of the sandbox to use for the node.
    #[prost(enumeration = "sandbox_config::Type", tag = "2")]
    pub r#type: i32,
}
/// Nested message and enum types in `SandboxConfig`.
pub mod sandbox_config {
    /// Possible types of sandboxes.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Default value. This should not be used.
        Unspecified = 0,
        /// Run sandbox using gvisor.
        Gvisor = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Gvisor => "GVISOR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "GVISOR" => Some(Self::Gvisor),
                _ => None,
            }
        }
    }
}
/// GcfsConfig contains configurations of Google Container File System
/// (image streaming).
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcfsConfig {
    /// Whether to use GCFS.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// [ReservationAffinity](<https://cloud.google.com/compute/docs/instances/reserving-zonal-resources>)
/// is the configuration of desired reservation which instances could take
/// capacity from.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReservationAffinity {
    /// Corresponds to the type of reservation consumption.
    #[prost(enumeration = "reservation_affinity::Type", tag = "1")]
    pub consume_reservation_type: i32,
    /// Corresponds to the label key of a reservation resource. To target a
    /// SPECIFIC_RESERVATION by name, specify
    /// "compute.googleapis.com/reservation-name" as the key and specify the name
    /// of your reservation as its value.
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    /// Corresponds to the label value(s) of reservation resource(s).
    #[prost(string, repeated, tag = "3")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ReservationAffinity`.
pub mod reservation_affinity {
    /// Indicates whether to consume capacity from a reservation or not.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Default value. This should not be used.
        Unspecified = 0,
        /// Do not consume from any reserved capacity.
        NoReservation = 1,
        /// Consume any reservation available.
        AnyReservation = 2,
        /// Must consume from a specific reservation. Must specify key value fields
        /// for specifying the reservations.
        SpecificReservation = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::NoReservation => "NO_RESERVATION",
                Self::AnyReservation => "ANY_RESERVATION",
                Self::SpecificReservation => "SPECIFIC_RESERVATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "NO_RESERVATION" => Some(Self::NoReservation),
                "ANY_RESERVATION" => Some(Self::AnyReservation),
                "SPECIFIC_RESERVATION" => Some(Self::SpecificReservation),
                _ => None,
            }
        }
    }
}
/// SoleTenantConfig contains the NodeAffinities to specify what shared sole
/// tenant node groups should back the node pool.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SoleTenantConfig {
    /// NodeAffinities used to match to a shared sole tenant node group.
    #[prost(message, repeated, tag = "1")]
    pub node_affinities: ::prost::alloc::vec::Vec<sole_tenant_config::NodeAffinity>,
}
/// Nested message and enum types in `SoleTenantConfig`.
pub mod sole_tenant_config {
    /// Specifies the NodeAffinity key, values, and affinity operator according to
    /// [shared sole tenant node group
    /// affinities](<https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes#node_affinity_and_anti-affinity>).
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NodeAffinity {
        /// Key for NodeAffinity.
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        /// Operator for NodeAffinity.
        #[prost(enumeration = "node_affinity::Operator", tag = "2")]
        pub operator: i32,
        /// Values for NodeAffinity.
        #[prost(string, repeated, tag = "3")]
        pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `NodeAffinity`.
    pub mod node_affinity {
        /// Operator allows user to specify affinity or anti-affinity for the
        /// given key values.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Operator {
            /// Invalid or unspecified affinity operator.
            Unspecified = 0,
            /// Affinity operator.
            In = 1,
            /// Anti-affinity operator.
            NotIn = 2,
        }
        impl Operator {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "OPERATOR_UNSPECIFIED",
                    Self::In => "IN",
                    Self::NotIn => "NOT_IN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                    "IN" => Some(Self::In),
                    "NOT_IN" => Some(Self::NotIn),
                    _ => None,
                }
            }
        }
    }
}
/// ContainerdConfig contains configuration to customize containerd.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerdConfig {
    /// PrivateRegistryAccessConfig is used to configure access configuration
    /// for private container registries.
    #[prost(message, optional, tag = "1")]
    pub private_registry_access_config: ::core::option::Option<
        containerd_config::PrivateRegistryAccessConfig,
    >,
}
/// Nested message and enum types in `ContainerdConfig`.
pub mod containerd_config {
    /// PrivateRegistryAccessConfig contains access configuration for
    /// private container registries.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PrivateRegistryAccessConfig {
        /// Private registry access is enabled.
        #[prost(bool, tag = "1")]
        pub enabled: bool,
        /// Private registry access configuration.
        #[prost(message, repeated, tag = "2")]
        pub certificate_authority_domain_config: ::prost::alloc::vec::Vec<
            private_registry_access_config::CertificateAuthorityDomainConfig,
        >,
    }
    /// Nested message and enum types in `PrivateRegistryAccessConfig`.
    pub mod private_registry_access_config {
        /// CertificateAuthorityDomainConfig configures one or more fully qualified
        /// domain names (FQDN) to a specific certificate.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CertificateAuthorityDomainConfig {
            /// List of fully qualified domain names (FQDN).
            /// Specifying port is supported.
            /// Wilcards are NOT supported.
            /// Examples:
            /// - my.customdomain.com
            /// - 10.0.1.2:5000
            #[prost(string, repeated, tag = "1")]
            pub fqdns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// Certificate access config. The following are supported:
            /// - GCPSecretManagerCertificateConfig
            #[prost(
                oneof = "certificate_authority_domain_config::CertificateConfig",
                tags = "2"
            )]
            pub certificate_config: ::core::option::Option<
                certificate_authority_domain_config::CertificateConfig,
            >,
        }
        /// Nested message and enum types in `CertificateAuthorityDomainConfig`.
        pub mod certificate_authority_domain_config {
            /// GCPSecretManagerCertificateConfig configures a secret from
            /// [Google Secret Manager](<https://cloud.google.com/secret-manager>).
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct GcpSecretManagerCertificateConfig {
                /// Secret URI, in the form
                /// "projects/$PROJECT_ID/secrets/$SECRET_NAME/versions/$VERSION".
                /// Version can be fixed (e.g. "2") or "latest"
                #[prost(string, tag = "1")]
                pub secret_uri: ::prost::alloc::string::String,
            }
            /// Certificate access config. The following are supported:
            /// - GCPSecretManagerCertificateConfig
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum CertificateConfig {
                /// Google Secret Manager (GCP) certificate configuration.
                #[prost(message, tag = "2")]
                GcpSecretManagerCertificateConfig(GcpSecretManagerCertificateConfig),
            }
        }
    }
}
/// Kubernetes taint is composed of three fields: key, value, and effect. Effect
/// can only be one of three types:  NoSchedule, PreferNoSchedule or NoExecute.
///
/// See
/// [here](<https://kubernetes.io/docs/concepts/configuration/taint-and-toleration>)
/// for more information, including usage and the valid values.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeTaint {
    /// Key for taint.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// Value for taint.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    /// Effect for taint.
    #[prost(enumeration = "node_taint::Effect", tag = "3")]
    pub effect: i32,
}
/// Nested message and enum types in `NodeTaint`.
pub mod node_taint {
    /// Possible values for Effect in taint.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Effect {
        /// Not set
        Unspecified = 0,
        /// NoSchedule
        NoSchedule = 1,
        /// PreferNoSchedule
        PreferNoSchedule = 2,
        /// NoExecute
        NoExecute = 3,
    }
    impl Effect {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EFFECT_UNSPECIFIED",
                Self::NoSchedule => "NO_SCHEDULE",
                Self::PreferNoSchedule => "PREFER_NO_SCHEDULE",
                Self::NoExecute => "NO_EXECUTE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EFFECT_UNSPECIFIED" => Some(Self::Unspecified),
                "NO_SCHEDULE" => Some(Self::NoSchedule),
                "PREFER_NO_SCHEDULE" => Some(Self::PreferNoSchedule),
                "NO_EXECUTE" => Some(Self::NoExecute),
                _ => None,
            }
        }
    }
}
/// Collection of Kubernetes [node
/// taints](<https://kubernetes.io/docs/concepts/configuration/taint-and-toleration>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeTaints {
    /// List of node taints.
    #[prost(message, repeated, tag = "1")]
    pub taints: ::prost::alloc::vec::Vec<NodeTaint>,
}
/// Collection of node-level [Kubernetes
/// labels](<https://kubernetes.io/docs/concepts/overview/working-with-objects/labels>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeLabels {
    /// Map of node label keys and node label values.
    #[prost(map = "string, string", tag = "1")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Collection of [GCP
/// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceLabels {
    /// Map of node label keys and node label values.
    #[prost(map = "string, string", tag = "1")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Collection of Compute Engine network tags that can be applied to a node's
/// underlying VM instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkTags {
    /// List of network tags.
    #[prost(string, repeated, tag = "1")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The authentication information for accessing the master endpoint.
/// Authentication can be done using HTTP basic auth or using client
/// certificates.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MasterAuth {
    /// The username to use for HTTP basic authentication to the master endpoint.
    /// For clusters v1.6.0 and later, basic authentication can be disabled by
    /// leaving username unspecified (or setting it to the empty string).
    ///
    /// Warning: basic authentication is deprecated, and will be removed in GKE
    /// control plane versions 1.19 and newer. For a list of recommended
    /// authentication methods, see:
    /// <https://cloud.google.com/kubernetes-engine/docs/how-to/api-server-authentication>
    #[deprecated]
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    /// The password to use for HTTP basic authentication to the master endpoint.
    /// Because the master endpoint is open to the Internet, you should create a
    /// strong password.  If a password is provided for cluster creation, username
    /// must be non-empty.
    ///
    /// Warning: basic authentication is deprecated, and will be removed in GKE
    /// control plane versions 1.19 and newer. For a list of recommended
    /// authentication methods, see:
    /// <https://cloud.google.com/kubernetes-engine/docs/how-to/api-server-authentication>
    #[deprecated]
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
    /// Configuration for client certificate authentication on the cluster. For
    /// clusters before v1.12, if no configuration is specified, a client
    /// certificate is issued.
    #[prost(message, optional, tag = "3")]
    pub client_certificate_config: ::core::option::Option<ClientCertificateConfig>,
    /// Output only. Base64-encoded public certificate that is the root of
    /// trust for the cluster.
    #[prost(string, tag = "100")]
    pub cluster_ca_certificate: ::prost::alloc::string::String,
    /// Output only. Base64-encoded public certificate used by clients to
    /// authenticate to the cluster endpoint. Issued only if
    /// client_certificate_config is set.
    #[prost(string, tag = "101")]
    pub client_certificate: ::prost::alloc::string::String,
    /// Output only. Base64-encoded private key used by clients to authenticate
    /// to the cluster endpoint.
    #[prost(string, tag = "102")]
    pub client_key: ::prost::alloc::string::String,
}
/// Configuration for client certificates on the cluster.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientCertificateConfig {
    /// Issue a client certificate.
    #[prost(bool, tag = "1")]
    pub issue_client_certificate: bool,
}
/// Configuration for the addons that can be automatically spun up in the
/// cluster, enabling additional functionality.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddonsConfig {
    /// Configuration for the HTTP (L7) load balancing controller addon, which
    /// makes it easy to set up HTTP load balancers for services in a cluster.
    #[prost(message, optional, tag = "1")]
    pub http_load_balancing: ::core::option::Option<HttpLoadBalancing>,
    /// Configuration for the horizontal pod autoscaling feature, which
    /// increases or decreases the number of replica pods a replication controller
    /// has based on the resource usage of the existing pods.
    #[prost(message, optional, tag = "2")]
    pub horizontal_pod_autoscaling: ::core::option::Option<HorizontalPodAutoscaling>,
    /// Configuration for the Kubernetes Dashboard.
    /// This addon is deprecated, and will be disabled in 1.15. It is recommended
    /// to use the Cloud Console to manage and monitor your Kubernetes clusters,
    /// workloads and applications. For more information, see:
    /// <https://cloud.google.com/kubernetes-engine/docs/concepts/dashboards>
    #[deprecated]
    #[prost(message, optional, tag = "3")]
    pub kubernetes_dashboard: ::core::option::Option<KubernetesDashboard>,
    /// Configuration for NetworkPolicy. This only tracks whether the addon
    /// is enabled or not on the Master, it does not track whether network policy
    /// is enabled for the nodes.
    #[prost(message, optional, tag = "4")]
    pub network_policy_config: ::core::option::Option<NetworkPolicyConfig>,
    /// Configuration for the Cloud Run addon, which allows the user to use a
    /// managed Knative service.
    #[prost(message, optional, tag = "7")]
    pub cloud_run_config: ::core::option::Option<CloudRunConfig>,
    /// Configuration for NodeLocalDNS, a dns cache running on cluster nodes
    #[prost(message, optional, tag = "8")]
    pub dns_cache_config: ::core::option::Option<DnsCacheConfig>,
    /// Configuration for the ConfigConnector add-on, a Kubernetes
    /// extension to manage hosted GCP services through the Kubernetes API
    #[prost(message, optional, tag = "10")]
    pub config_connector_config: ::core::option::Option<ConfigConnectorConfig>,
    /// Configuration for the Compute Engine Persistent Disk CSI driver.
    #[prost(message, optional, tag = "11")]
    pub gce_persistent_disk_csi_driver_config: ::core::option::Option<
        GcePersistentDiskCsiDriverConfig,
    >,
    /// Configuration for the GCP Filestore CSI driver.
    #[prost(message, optional, tag = "14")]
    pub gcp_filestore_csi_driver_config: ::core::option::Option<
        GcpFilestoreCsiDriverConfig,
    >,
    /// Configuration for the Backup for GKE agent addon.
    #[prost(message, optional, tag = "16")]
    pub gke_backup_agent_config: ::core::option::Option<GkeBackupAgentConfig>,
    /// Configuration for the Cloud Storage Fuse CSI driver.
    #[prost(message, optional, tag = "17")]
    pub gcs_fuse_csi_driver_config: ::core::option::Option<GcsFuseCsiDriverConfig>,
    /// Optional. Configuration for the StatefulHA add-on.
    #[prost(message, optional, tag = "18")]
    pub stateful_ha_config: ::core::option::Option<StatefulHaConfig>,
    /// Configuration for the Cloud Storage Parallelstore CSI driver.
    #[prost(message, optional, tag = "19")]
    pub parallelstore_csi_driver_config: ::core::option::Option<
        ParallelstoreCsiDriverConfig,
    >,
    /// Optional. Configuration for Ray Operator addon.
    #[prost(message, optional, tag = "21")]
    pub ray_operator_config: ::core::option::Option<RayOperatorConfig>,
}
/// Configuration options for the HTTP (L7) load balancing controller addon,
/// which makes it easy to set up HTTP load balancers for services in a cluster.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HttpLoadBalancing {
    /// Whether the HTTP Load Balancing controller is enabled in the cluster.
    /// When enabled, it runs a small pod in the cluster that manages the load
    /// balancers.
    #[prost(bool, tag = "1")]
    pub disabled: bool,
}
/// Configuration options for the horizontal pod autoscaling feature, which
/// increases or decreases the number of replica pods a replication controller
/// has based on the resource usage of the existing pods.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HorizontalPodAutoscaling {
    /// Whether the Horizontal Pod Autoscaling feature is enabled in the cluster.
    /// When enabled, it ensures that metrics are collected into Stackdriver
    /// Monitoring.
    #[prost(bool, tag = "1")]
    pub disabled: bool,
}
/// Configuration for the Kubernetes Dashboard.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KubernetesDashboard {
    /// Whether the Kubernetes Dashboard is enabled for this cluster.
    #[prost(bool, tag = "1")]
    pub disabled: bool,
}
/// Configuration for NetworkPolicy. This only tracks whether the addon
/// is enabled or not on the Master, it does not track whether network policy
/// is enabled for the nodes.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NetworkPolicyConfig {
    /// Whether NetworkPolicy is enabled for this cluster.
    #[prost(bool, tag = "1")]
    pub disabled: bool,
}
/// Configuration for NodeLocal DNSCache
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DnsCacheConfig {
    /// Whether NodeLocal DNSCache is enabled for this cluster.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// Configuration for controlling master global access settings.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PrivateClusterMasterGlobalAccessConfig {
    /// Whenever master is accessible globally or not.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// Configuration options for private clusters.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateClusterConfig {
    /// Whether nodes have internal IP addresses only. If enabled, all nodes are
    /// given only RFC 1918 private addresses and communicate with the master via
    /// private networking.
    ///
    /// Deprecated: Use
    /// [NetworkConfig.default_enable_private_nodes][google.container.v1.NetworkConfig.default_enable_private_nodes]
    /// instead.
    #[deprecated]
    #[prost(bool, tag = "1")]
    pub enable_private_nodes: bool,
    /// Whether the master's internal IP address is used as the cluster endpoint.
    ///
    /// Deprecated: Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.enable_public_endpoint][google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.enable_public_endpoint]
    /// instead. Note that the value of enable_public_endpoint is reversed: if
    /// enable_private_endpoint is false, then enable_public_endpoint will be true.
    #[deprecated]
    #[prost(bool, tag = "2")]
    pub enable_private_endpoint: bool,
    /// The IP range in CIDR notation to use for the hosted master network. This
    /// range will be used for assigning internal IP addresses to the master or
    /// set of masters, as well as the ILB VIP. This range must not overlap with
    /// any other ranges in use within the cluster's network.
    #[prost(string, tag = "3")]
    pub master_ipv4_cidr_block: ::prost::alloc::string::String,
    /// Output only. The internal IP address of this cluster's master endpoint.
    ///
    /// Deprecated: Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.private_endpoint][google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.private_endpoint]
    /// instead.
    #[deprecated]
    #[prost(string, tag = "4")]
    pub private_endpoint: ::prost::alloc::string::String,
    /// Output only. The external IP address of this cluster's master endpoint.
    ///
    /// Deprecated:Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.public_endpoint][google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.public_endpoint]
    /// instead.
    #[deprecated]
    #[prost(string, tag = "5")]
    pub public_endpoint: ::prost::alloc::string::String,
    /// Output only. The peering name in the customer VPC used by this cluster.
    #[prost(string, tag = "7")]
    pub peering_name: ::prost::alloc::string::String,
    /// Controls master global access settings.
    ///
    /// Deprecated: Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.enable_global_access][]
    /// instead.
    #[deprecated]
    #[prost(message, optional, tag = "8")]
    pub master_global_access_config: ::core::option::Option<
        PrivateClusterMasterGlobalAccessConfig,
    >,
    /// Subnet to provision the master's private endpoint during cluster creation.
    /// Specified in projects/*/regions/*/subnetworks/* format.
    ///
    /// Deprecated: Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.private_endpoint_subnetwork][google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.private_endpoint_subnetwork]
    /// instead.
    #[deprecated]
    #[prost(string, tag = "10")]
    pub private_endpoint_subnetwork: ::prost::alloc::string::String,
}
/// Configuration for returning group information from authenticators.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticatorGroupsConfig {
    /// Whether this cluster should return group membership lookups
    /// during authentication using a group of security groups.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// The name of the security group-of-groups to be used. Only relevant
    /// if enabled = true.
    #[prost(string, tag = "2")]
    pub security_group: ::prost::alloc::string::String,
}
/// Configuration options for the Cloud Run feature.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CloudRunConfig {
    /// Whether Cloud Run addon is enabled for this cluster.
    #[prost(bool, tag = "1")]
    pub disabled: bool,
    /// Which load balancer type is installed for Cloud Run.
    #[prost(enumeration = "cloud_run_config::LoadBalancerType", tag = "3")]
    pub load_balancer_type: i32,
}
/// Nested message and enum types in `CloudRunConfig`.
pub mod cloud_run_config {
    /// Load balancer type of ingress service of Cloud Run.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LoadBalancerType {
        /// Load balancer type for Cloud Run is unspecified.
        Unspecified = 0,
        /// Install external load balancer for Cloud Run.
        External = 1,
        /// Install internal load balancer for Cloud Run.
        Internal = 2,
    }
    impl LoadBalancerType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LOAD_BALANCER_TYPE_UNSPECIFIED",
                Self::External => "LOAD_BALANCER_TYPE_EXTERNAL",
                Self::Internal => "LOAD_BALANCER_TYPE_INTERNAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOAD_BALANCER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "LOAD_BALANCER_TYPE_EXTERNAL" => Some(Self::External),
                "LOAD_BALANCER_TYPE_INTERNAL" => Some(Self::Internal),
                _ => None,
            }
        }
    }
}
/// Configuration options for the Config Connector add-on.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConfigConnectorConfig {
    /// Whether Cloud Connector is enabled for this cluster.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// Configuration for the Compute Engine PD CSI driver.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcePersistentDiskCsiDriverConfig {
    /// Whether the Compute Engine PD CSI driver is enabled for this cluster.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// Configuration for the GCP Filestore CSI driver.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcpFilestoreCsiDriverConfig {
    /// Whether the GCP Filestore CSI driver is enabled for this cluster.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// Configuration for the Cloud Storage Fuse CSI driver.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GcsFuseCsiDriverConfig {
    /// Whether the Cloud Storage Fuse CSI driver is enabled for this cluster.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// Configuration for the Cloud Storage Parallelstore CSI driver.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ParallelstoreCsiDriverConfig {
    /// Whether the Cloud Storage Parallelstore CSI driver is enabled for this
    /// cluster.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// Configuration options for the Ray Operator add-on.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RayOperatorConfig {
    /// Whether the Ray Operator addon is enabled for this cluster.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Optional. Logging configuration for Ray clusters.
    #[prost(message, optional, tag = "2")]
    pub ray_cluster_logging_config: ::core::option::Option<RayClusterLoggingConfig>,
    /// Optional. Monitoring configuration for Ray clusters.
    #[prost(message, optional, tag = "3")]
    pub ray_cluster_monitoring_config: ::core::option::Option<
        RayClusterMonitoringConfig,
    >,
}
/// Configuration for the Backup for GKE Agent.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GkeBackupAgentConfig {
    /// Whether the Backup for GKE agent is enabled for this cluster.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// Configuration for the Stateful HA add-on.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StatefulHaConfig {
    /// Whether the Stateful HA add-on is enabled for this cluster.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// Configuration options for the master authorized networks feature. Enabled
/// master authorized networks will disallow all external traffic to access
/// Kubernetes master through HTTPS except traffic from the given CIDR blocks,
/// Google Compute Engine Public IPs and Google Prod IPs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MasterAuthorizedNetworksConfig {
    /// Whether or not master authorized networks is enabled.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// cidr_blocks define up to 50 external networks that could access
    /// Kubernetes master through HTTPS.
    #[prost(message, repeated, tag = "2")]
    pub cidr_blocks: ::prost::alloc::vec::Vec<
        master_authorized_networks_config::CidrBlock,
    >,
    /// Whether master is accessbile via Google Compute Engine Public IP addresses.
    #[prost(bool, optional, tag = "3")]
    pub gcp_public_cidrs_access_enabled: ::core::option::Option<bool>,
    /// Whether master authorized networks is enforced on private endpoint or not.
    #[prost(bool, optional, tag = "5")]
    pub private_endpoint_enforcement_enabled: ::core::option::Option<bool>,
}
/// Nested message and enum types in `MasterAuthorizedNetworksConfig`.
pub mod master_authorized_networks_config {
    /// CidrBlock contains an optional name and one CIDR block.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CidrBlock {
        /// display_name is an optional field for users to identify CIDR blocks.
        #[prost(string, tag = "1")]
        pub display_name: ::prost::alloc::string::String,
        /// cidr_block must be specified in CIDR notation.
        #[prost(string, tag = "2")]
        pub cidr_block: ::prost::alloc::string::String,
    }
}
/// Configuration for the legacy Attribute Based Access Control authorization
/// mode.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LegacyAbac {
    /// Whether the ABAC authorizer is enabled for this cluster. When enabled,
    /// identities in the system, including service accounts, nodes, and
    /// controllers, will have statically granted permissions beyond those
    /// provided by the RBAC configuration or IAM.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// Configuration options for the NetworkPolicy feature.
/// <https://kubernetes.io/docs/concepts/services-networking/networkpolicies/>
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NetworkPolicy {
    /// The selected network policy provider.
    #[prost(enumeration = "network_policy::Provider", tag = "1")]
    pub provider: i32,
    /// Whether network policy is enabled on the cluster.
    #[prost(bool, tag = "2")]
    pub enabled: bool,
}
/// Nested message and enum types in `NetworkPolicy`.
pub mod network_policy {
    /// Allowed Network Policy providers.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Provider {
        /// Not set
        Unspecified = 0,
        /// Tigera (Calico Felix).
        Calico = 1,
    }
    impl Provider {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROVIDER_UNSPECIFIED",
                Self::Calico => "CALICO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROVIDER_UNSPECIFIED" => Some(Self::Unspecified),
                "CALICO" => Some(Self::Calico),
                _ => None,
            }
        }
    }
}
/// Configuration for Binary Authorization.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BinaryAuthorization {
    /// This field is deprecated. Leave this unset and instead configure
    /// BinaryAuthorization using evaluation_mode. If evaluation_mode is set to
    /// anything other than EVALUATION_MODE_UNSPECIFIED, this field is ignored.
    #[deprecated]
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Mode of operation for binauthz policy evaluation. If unspecified, defaults
    /// to DISABLED.
    #[prost(enumeration = "binary_authorization::EvaluationMode", tag = "2")]
    pub evaluation_mode: i32,
}
/// Nested message and enum types in `BinaryAuthorization`.
pub mod binary_authorization {
    /// Binary Authorization mode of operation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EvaluationMode {
        /// Default value
        Unspecified = 0,
        /// Disable BinaryAuthorization
        Disabled = 1,
        /// Enforce Kubernetes admission requests with BinaryAuthorization using the
        /// project's singleton policy. This is equivalent to setting the
        /// enabled boolean to true.
        ProjectSingletonPolicyEnforce = 2,
    }
    impl EvaluationMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EVALUATION_MODE_UNSPECIFIED",
                Self::Disabled => "DISABLED",
                Self::ProjectSingletonPolicyEnforce => "PROJECT_SINGLETON_POLICY_ENFORCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVALUATION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "DISABLED" => Some(Self::Disabled),
                "PROJECT_SINGLETON_POLICY_ENFORCE" => {
                    Some(Self::ProjectSingletonPolicyEnforce)
                }
                _ => None,
            }
        }
    }
}
/// \[PRIVATE FIELD\]
/// Config for pod CIDR size overprovisioning.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PodCidrOverprovisionConfig {
    /// Whether Pod CIDR overprovisioning is disabled.
    /// Note: Pod CIDR overprovisioning is enabled by default.
    #[prost(bool, tag = "1")]
    pub disable: bool,
}
/// Configuration for controlling how IPs are allocated in the cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpAllocationPolicy {
    /// Whether alias IPs will be used for pod IPs in the cluster.
    /// This is used in conjunction with use_routes. It cannot
    /// be true if use_routes is true. If both use_ip_aliases and use_routes are
    /// false, then the server picks the default IP allocation mode
    #[prost(bool, tag = "1")]
    pub use_ip_aliases: bool,
    /// Whether a new subnetwork will be created automatically for the cluster.
    ///
    /// This field is only applicable when `use_ip_aliases` is true.
    #[prost(bool, tag = "2")]
    pub create_subnetwork: bool,
    /// A custom subnetwork name to be used if `create_subnetwork` is true.  If
    /// this field is empty, then an automatic name will be chosen for the new
    /// subnetwork.
    #[prost(string, tag = "3")]
    pub subnetwork_name: ::prost::alloc::string::String,
    /// This field is deprecated, use cluster_ipv4_cidr_block.
    #[deprecated]
    #[prost(string, tag = "4")]
    pub cluster_ipv4_cidr: ::prost::alloc::string::String,
    /// This field is deprecated, use node_ipv4_cidr_block.
    #[deprecated]
    #[prost(string, tag = "5")]
    pub node_ipv4_cidr: ::prost::alloc::string::String,
    /// This field is deprecated, use services_ipv4_cidr_block.
    #[deprecated]
    #[prost(string, tag = "6")]
    pub services_ipv4_cidr: ::prost::alloc::string::String,
    /// The name of the secondary range to be used for the cluster CIDR
    /// block.  The secondary range will be used for pod IP
    /// addresses. This must be an existing secondary range associated
    /// with the cluster subnetwork.
    ///
    /// This field is only applicable with use_ip_aliases is true and
    /// create_subnetwork is false.
    #[prost(string, tag = "7")]
    pub cluster_secondary_range_name: ::prost::alloc::string::String,
    /// The name of the secondary range to be used as for the services
    /// CIDR block.  The secondary range will be used for service
    /// ClusterIPs. This must be an existing secondary range associated
    /// with the cluster subnetwork.
    ///
    /// This field is only applicable with use_ip_aliases is true and
    /// create_subnetwork is false.
    #[prost(string, tag = "8")]
    pub services_secondary_range_name: ::prost::alloc::string::String,
    /// The IP address range for the cluster pod IPs. If this field is set, then
    /// `cluster.cluster_ipv4_cidr` must be left blank.
    ///
    /// This field is only applicable when `use_ip_aliases` is true.
    ///
    /// Set to blank to have a range chosen with the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](<http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing>)
    /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
    /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
    /// to use.
    #[prost(string, tag = "9")]
    pub cluster_ipv4_cidr_block: ::prost::alloc::string::String,
    /// The IP address range of the instance IPs in this cluster.
    ///
    /// This is applicable only if `create_subnetwork` is true.
    ///
    /// Set to blank to have a range chosen with the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](<http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing>)
    /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
    /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
    /// to use.
    #[prost(string, tag = "10")]
    pub node_ipv4_cidr_block: ::prost::alloc::string::String,
    /// The IP address range of the services IPs in this cluster. If blank, a range
    /// will be automatically chosen with the default size.
    ///
    /// This field is only applicable when `use_ip_aliases` is true.
    ///
    /// Set to blank to have a range chosen with the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](<http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing>)
    /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
    /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
    /// to use.
    #[prost(string, tag = "11")]
    pub services_ipv4_cidr_block: ::prost::alloc::string::String,
    /// The IP address range of the Cloud TPUs in this cluster. If unspecified, a
    /// range will be automatically chosen with the default size.
    ///
    /// This field is only applicable when `use_ip_aliases` is true.
    ///
    /// If unspecified, the range will use the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](<http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing>)
    /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
    /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
    /// to use.
    #[prost(string, tag = "13")]
    pub tpu_ipv4_cidr_block: ::prost::alloc::string::String,
    /// Whether routes will be used for pod IPs in the cluster.
    /// This is used in conjunction with use_ip_aliases. It cannot be true if
    /// use_ip_aliases is true. If both use_ip_aliases and use_routes are false,
    /// then the server picks the default IP allocation mode
    #[prost(bool, tag = "15")]
    pub use_routes: bool,
    /// The IP stack type of the cluster
    #[prost(enumeration = "StackType", tag = "16")]
    pub stack_type: i32,
    /// The ipv6 access type (internal or external) when create_subnetwork is true
    #[prost(enumeration = "IPv6AccessType", tag = "17")]
    pub ipv6_access_type: i32,
    /// \[PRIVATE FIELD\]
    /// Pod CIDR size overprovisioning config for the cluster.
    ///
    /// Pod CIDR size per node depends on max_pods_per_node. By default, the value
    /// of max_pods_per_node is doubled and then rounded off to next power of 2 to
    /// get the size of pod CIDR block per node.
    /// Example: max_pods_per_node of 30 would result in 64 IPs (/26).
    ///
    /// This config can disable the doubling of IPs (we still round off to next
    /// power of 2)
    /// Example: max_pods_per_node of 30 will result in 32 IPs (/27) when
    /// overprovisioning is disabled.
    #[prost(message, optional, tag = "21")]
    pub pod_cidr_overprovision_config: ::core::option::Option<
        PodCidrOverprovisionConfig,
    >,
    /// Output only. The subnet's IPv6 CIDR block used by nodes and pods.
    #[prost(string, tag = "22")]
    pub subnet_ipv6_cidr_block: ::prost::alloc::string::String,
    /// Output only. The services IPv6 CIDR block for the cluster.
    #[prost(string, tag = "23")]
    pub services_ipv6_cidr_block: ::prost::alloc::string::String,
    /// Output only. The additional pod ranges that are added to the cluster.
    /// These pod ranges can be used by new node pools to allocate pod IPs
    /// automatically. Once the range is removed it will not show up in
    /// IPAllocationPolicy.
    #[prost(message, optional, tag = "24")]
    pub additional_pod_ranges_config: ::core::option::Option<AdditionalPodRangesConfig>,
    /// Output only. The utilization of the cluster default IPv4 range for the
    /// pod. The ratio is Usage/\[Total number of IPs in the secondary range\],
    /// Usage=numNodes*numZones*podIPsPerNode.
    #[prost(double, tag = "25")]
    pub default_pod_ipv4_range_utilization: f64,
}
/// A Google Kubernetes Engine cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cluster {
    /// The name of this cluster. The name must be unique within this project
    /// and location (e.g. zone or region), and can be up to 40 characters with
    /// the following restrictions:
    ///
    /// * Lowercase letters, numbers, and hyphens only.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// An optional description of this cluster.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// The number of nodes to create in this cluster. You must ensure that your
    /// Compute Engine [resource quota](<https://cloud.google.com/compute/quotas>)
    /// is sufficient for this number of instances. You must also have available
    /// firewall and routes quota.
    /// For requests, this field should only be used in lieu of a
    /// "node_pool" object, since this configuration (along with the
    /// "node_config") will be used to create a "NodePool" object with an
    /// auto-generated name. Do not use this and a node_pool at the same time.
    ///
    /// This field is deprecated, use node_pool.initial_node_count instead.
    #[deprecated]
    #[prost(int32, tag = "3")]
    pub initial_node_count: i32,
    /// Parameters used in creating the cluster's nodes.
    /// For requests, this field should only be used in lieu of a
    /// "node_pool" object, since this configuration (along with the
    /// "initial_node_count") will be used to create a "NodePool" object with an
    /// auto-generated name. Do not use this and a node_pool at the same time.
    /// For responses, this field will be populated with the node configuration of
    /// the first node pool. (For configuration of each node pool, see
    /// `node_pool.config`)
    ///
    /// If unspecified, the defaults are used.
    /// This field is deprecated, use node_pool.config instead.
    #[deprecated]
    #[prost(message, optional, tag = "4")]
    pub node_config: ::core::option::Option<NodeConfig>,
    /// The authentication information for accessing the master endpoint.
    /// If unspecified, the defaults are used:
    /// For clusters before v1.12, if master_auth is unspecified, `username` will
    /// be set to "admin", a random password will be generated, and a client
    /// certificate will be issued.
    #[prost(message, optional, tag = "5")]
    pub master_auth: ::core::option::Option<MasterAuth>,
    /// The logging service the cluster should use to write logs.
    /// Currently available options:
    ///
    /// * `logging.googleapis.com/kubernetes` - The Cloud Logging
    /// service with a Kubernetes-native resource model
    /// * `logging.googleapis.com` - The legacy Cloud Logging service (no longer
    ///    available as of GKE 1.15).
    /// * `none` - no logs will be exported from the cluster.
    ///
    /// If left as an empty string,`logging.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `logging.googleapis.com` for earlier versions.
    #[prost(string, tag = "6")]
    pub logging_service: ::prost::alloc::string::String,
    /// The monitoring service the cluster should use to write metrics.
    /// Currently available options:
    ///
    /// * "monitoring.googleapis.com/kubernetes" - The Cloud Monitoring
    /// service with a Kubernetes-native resource model
    /// * `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no
    ///    longer available as of GKE 1.15).
    /// * `none` - No metrics will be exported from the cluster.
    ///
    /// If left as an empty string,`monitoring.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `monitoring.googleapis.com` for earlier versions.
    #[prost(string, tag = "7")]
    pub monitoring_service: ::prost::alloc::string::String,
    /// The name of the Google Compute Engine
    /// [network](<https://cloud.google.com/compute/docs/networks-and-firewalls#networks>)
    /// to which the cluster is connected. If left unspecified, the `default`
    /// network will be used.
    #[prost(string, tag = "8")]
    pub network: ::prost::alloc::string::String,
    /// The IP address range of the container pods in this cluster, in
    /// [CIDR](<http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing>)
    /// notation (e.g. `10.96.0.0/14`). Leave blank to have
    /// one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
    #[prost(string, tag = "9")]
    pub cluster_ipv4_cidr: ::prost::alloc::string::String,
    /// Configurations for the various addons available to run in the cluster.
    #[prost(message, optional, tag = "10")]
    pub addons_config: ::core::option::Option<AddonsConfig>,
    /// The name of the Google Compute Engine
    /// [subnetwork](<https://cloud.google.com/compute/docs/subnetworks>) to which
    /// the cluster is connected.
    #[prost(string, tag = "11")]
    pub subnetwork: ::prost::alloc::string::String,
    /// The node pools associated with this cluster.
    /// This field should not be set if "node_config" or "initial_node_count" are
    /// specified.
    #[prost(message, repeated, tag = "12")]
    pub node_pools: ::prost::alloc::vec::Vec<NodePool>,
    /// The list of Google Compute Engine
    /// [zones](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster's nodes should be located.
    ///
    /// This field provides a default value if
    /// [NodePool.Locations](<https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools#NodePool.FIELDS.locations>)
    /// are not specified during node pool creation.
    ///
    /// Warning: changing cluster locations will update the
    /// [NodePool.Locations](<https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools#NodePool.FIELDS.locations>)
    /// of all node pools and will result in nodes being added and/or removed.
    #[prost(string, repeated, tag = "13")]
    pub locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Kubernetes alpha features are enabled on this cluster. This includes alpha
    /// API groups (e.g. v1alpha1) and features that may not be production ready in
    /// the kubernetes version of the master and nodes.
    /// The cluster has no SLA for uptime and master/node upgrades are disabled.
    /// Alpha enabled clusters are automatically deleted thirty days after
    /// creation.
    #[prost(bool, tag = "14")]
    pub enable_kubernetes_alpha: bool,
    /// The resource labels for the cluster to use to annotate any related
    /// Google Compute Engine resources.
    #[prost(map = "string, string", tag = "15")]
    pub resource_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The fingerprint of the set of labels for this cluster.
    #[prost(string, tag = "16")]
    pub label_fingerprint: ::prost::alloc::string::String,
    /// Configuration for the legacy ABAC authorization mode.
    #[prost(message, optional, tag = "18")]
    pub legacy_abac: ::core::option::Option<LegacyAbac>,
    /// Configuration options for the NetworkPolicy feature.
    #[prost(message, optional, tag = "19")]
    pub network_policy: ::core::option::Option<NetworkPolicy>,
    /// Configuration for cluster IP allocation.
    #[prost(message, optional, tag = "20")]
    pub ip_allocation_policy: ::core::option::Option<IpAllocationPolicy>,
    /// The configuration options for master authorized networks feature.
    ///
    /// Deprecated: Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.authorized_networks_config][google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.authorized_networks_config]
    /// instead.
    #[deprecated]
    #[prost(message, optional, tag = "22")]
    pub master_authorized_networks_config: ::core::option::Option<
        MasterAuthorizedNetworksConfig,
    >,
    /// Configure the maintenance policy for this cluster.
    #[prost(message, optional, tag = "23")]
    pub maintenance_policy: ::core::option::Option<MaintenancePolicy>,
    /// Configuration for Binary Authorization.
    #[prost(message, optional, tag = "24")]
    pub binary_authorization: ::core::option::Option<BinaryAuthorization>,
    /// Cluster-level autoscaling configuration.
    #[prost(message, optional, tag = "26")]
    pub autoscaling: ::core::option::Option<ClusterAutoscaling>,
    /// Configuration for cluster networking.
    #[prost(message, optional, tag = "27")]
    pub network_config: ::core::option::Option<NetworkConfig>,
    /// The default constraint on the maximum number of pods that can be run
    /// simultaneously on a node in the node pool of this cluster. Only honored
    /// if cluster created with IP Alias support.
    #[prost(message, optional, tag = "30")]
    pub default_max_pods_constraint: ::core::option::Option<MaxPodsConstraint>,
    /// Configuration for exporting resource usages. Resource usage export is
    /// disabled when this config is unspecified.
    #[prost(message, optional, tag = "33")]
    pub resource_usage_export_config: ::core::option::Option<ResourceUsageExportConfig>,
    /// Configuration controlling RBAC group membership information.
    #[prost(message, optional, tag = "34")]
    pub authenticator_groups_config: ::core::option::Option<AuthenticatorGroupsConfig>,
    /// Configuration for private cluster.
    #[prost(message, optional, tag = "37")]
    pub private_cluster_config: ::core::option::Option<PrivateClusterConfig>,
    /// Configuration of etcd encryption.
    #[prost(message, optional, tag = "38")]
    pub database_encryption: ::core::option::Option<DatabaseEncryption>,
    /// Cluster-level Vertical Pod Autoscaling configuration.
    #[prost(message, optional, tag = "39")]
    pub vertical_pod_autoscaling: ::core::option::Option<VerticalPodAutoscaling>,
    /// Shielded Nodes configuration.
    #[prost(message, optional, tag = "40")]
    pub shielded_nodes: ::core::option::Option<ShieldedNodes>,
    /// Release channel configuration. If left unspecified on cluster creation and
    /// a version is specified, the cluster is enrolled in the most mature release
    /// channel where the version is available (first checking STABLE, then
    /// REGULAR, and finally RAPID). Otherwise, if no release channel
    /// configuration and no version is specified, the cluster is enrolled in the
    /// REGULAR channel with its default version.
    #[prost(message, optional, tag = "41")]
    pub release_channel: ::core::option::Option<ReleaseChannel>,
    /// Configuration for the use of Kubernetes Service Accounts in GCP IAM
    /// policies.
    #[prost(message, optional, tag = "43")]
    pub workload_identity_config: ::core::option::Option<WorkloadIdentityConfig>,
    /// Configuration for issuance of mTLS keys and certificates to Kubernetes
    /// pods.
    #[prost(message, optional, tag = "67")]
    pub mesh_certificates: ::core::option::Option<MeshCertificates>,
    /// Configuration for the fine-grained cost management feature.
    #[prost(message, optional, tag = "45")]
    pub cost_management_config: ::core::option::Option<CostManagementConfig>,
    /// Notification configuration of the cluster.
    #[prost(message, optional, tag = "49")]
    pub notification_config: ::core::option::Option<NotificationConfig>,
    /// Configuration of Confidential Nodes.
    /// All the nodes in the cluster will be Confidential VM once enabled.
    #[prost(message, optional, tag = "50")]
    pub confidential_nodes: ::core::option::Option<ConfidentialNodes>,
    /// Configuration for Identity Service component.
    #[prost(message, optional, tag = "54")]
    pub identity_service_config: ::core::option::Option<IdentityServiceConfig>,
    /// Output only. Server-defined URL for the resource.
    #[prost(string, tag = "100")]
    pub self_link: ::prost::alloc::string::String,
    /// Output only. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field is deprecated, use location instead.
    #[deprecated]
    #[prost(string, tag = "101")]
    pub zone: ::prost::alloc::string::String,
    /// Output only. The IP address of this cluster's master endpoint.
    /// The endpoint can be accessed from the internet at
    /// `<https://username:password@endpoint/`.>
    ///
    /// See the `masterAuth` property of this resource for username and
    /// password information.
    #[prost(string, tag = "102")]
    pub endpoint: ::prost::alloc::string::String,
    /// The initial Kubernetes version for this cluster.  Valid versions are those
    /// found in validMasterVersions returned by getServerConfig.  The version can
    /// be upgraded over time; such upgrades are reflected in
    /// currentMasterVersion and currentNodeVersion.
    ///
    /// Users may specify either explicit versions offered by
    /// Kubernetes Engine or version aliases, which have the following behavior:
    ///
    /// - "latest": picks the highest valid Kubernetes version
    /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
    /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
    /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
    /// - "","-": picks the default Kubernetes version
    #[prost(string, tag = "103")]
    pub initial_cluster_version: ::prost::alloc::string::String,
    /// Output only. The current software version of the master endpoint.
    #[prost(string, tag = "104")]
    pub current_master_version: ::prost::alloc::string::String,
    /// Output only. Deprecated, use
    /// [NodePools.version](<https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools>)
    /// instead. The current version of the node software components. If they are
    /// currently at multiple versions because they're in the process of being
    /// upgraded, this reflects the minimum version of all nodes.
    #[deprecated]
    #[prost(string, tag = "105")]
    pub current_node_version: ::prost::alloc::string::String,
    /// Output only. The time the cluster was created, in
    /// [RFC3339](<https://www.ietf.org/rfc/rfc3339.txt>) text format.
    #[prost(string, tag = "106")]
    pub create_time: ::prost::alloc::string::String,
    /// Output only. The current status of this cluster.
    #[prost(enumeration = "cluster::Status", tag = "107")]
    pub status: i32,
    /// Output only. Deprecated. Use conditions instead.
    /// Additional information about the current status of this
    /// cluster, if available.
    #[deprecated]
    #[prost(string, tag = "108")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. The size of the address space on each node for hosting
    /// containers. This is provisioned from within the `container_ipv4_cidr`
    /// range. This field will only be set when cluster is in route-based network
    /// mode.
    #[prost(int32, tag = "109")]
    pub node_ipv4_cidr_size: i32,
    /// Output only. The IP address range of the Kubernetes services in
    /// this cluster, in
    /// [CIDR](<http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing>)
    /// notation (e.g. `1.2.3.4/29`). Service addresses are
    /// typically put in the last `/16` from the container CIDR.
    #[prost(string, tag = "110")]
    pub services_ipv4_cidr: ::prost::alloc::string::String,
    /// Output only. Deprecated. Use node_pools.instance_group_urls.
    #[deprecated]
    #[prost(string, repeated, tag = "111")]
    pub instance_group_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The number of nodes currently in the cluster. Deprecated.
    /// Call Kubernetes API directly to retrieve node information.
    #[deprecated]
    #[prost(int32, tag = "112")]
    pub current_node_count: i32,
    /// Output only. The time the cluster will be automatically
    /// deleted in [RFC3339](<https://www.ietf.org/rfc/rfc3339.txt>) text format.
    #[prost(string, tag = "113")]
    pub expire_time: ::prost::alloc::string::String,
    /// Output only. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/regions-zones/regions-zones#available>)
    /// or
    /// [region](<https://cloud.google.com/compute/docs/regions-zones/regions-zones#available>)
    /// in which the cluster resides.
    #[prost(string, tag = "114")]
    pub location: ::prost::alloc::string::String,
    /// Enable the ability to use Cloud TPUs in this cluster.
    #[prost(bool, tag = "115")]
    pub enable_tpu: bool,
    /// Output only. The IP address range of the Cloud TPUs in this cluster, in
    /// [CIDR](<http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing>)
    /// notation (e.g. `1.2.3.4/29`).
    #[prost(string, tag = "116")]
    pub tpu_ipv4_cidr_block: ::prost::alloc::string::String,
    /// Which conditions caused the current cluster state.
    #[prost(message, repeated, tag = "118")]
    pub conditions: ::prost::alloc::vec::Vec<StatusCondition>,
    /// Autopilot configuration for the cluster.
    #[prost(message, optional, tag = "128")]
    pub autopilot: ::core::option::Option<Autopilot>,
    /// Output only. Unique id for the cluster.
    #[prost(string, tag = "129")]
    pub id: ::prost::alloc::string::String,
    /// Default NodePool settings for the entire cluster. These settings are
    /// overridden if specified on the specific NodePool object.
    #[prost(message, optional, tag = "131")]
    pub node_pool_defaults: ::core::option::Option<NodePoolDefaults>,
    /// Logging configuration for the cluster.
    #[prost(message, optional, tag = "132")]
    pub logging_config: ::core::option::Option<LoggingConfig>,
    /// Monitoring configuration for the cluster.
    #[prost(message, optional, tag = "133")]
    pub monitoring_config: ::core::option::Option<MonitoringConfig>,
    /// Node pool configs that apply to all auto-provisioned node pools
    /// in autopilot clusters and node auto-provisioning enabled clusters.
    #[prost(message, optional, tag = "136")]
    pub node_pool_auto_config: ::core::option::Option<NodePoolAutoConfig>,
    /// This checksum is computed by the server based on the value of cluster
    /// fields, and may be sent on update requests to ensure the client has an
    /// up-to-date value before proceeding.
    #[prost(string, tag = "139")]
    pub etag: ::prost::alloc::string::String,
    /// Fleet information for the cluster.
    #[prost(message, optional, tag = "140")]
    pub fleet: ::core::option::Option<Fleet>,
    /// Enable/Disable Security Posture API features for the cluster.
    #[prost(message, optional, tag = "145")]
    pub security_posture_config: ::core::option::Option<SecurityPostureConfig>,
    /// Configuration for all cluster's control plane endpoints.
    #[prost(message, optional, tag = "146")]
    pub control_plane_endpoints_config: ::core::option::Option<
        ControlPlaneEndpointsConfig,
    >,
    /// Beta APIs Config
    #[prost(message, optional, tag = "143")]
    pub enable_k8s_beta_apis: ::core::option::Option<K8sBetaApiConfig>,
    /// GKE Enterprise Configuration.
    #[prost(message, optional, tag = "149")]
    pub enterprise_config: ::core::option::Option<EnterpriseConfig>,
    /// Secret CSI driver configuration.
    #[prost(message, optional, tag = "150")]
    pub secret_manager_config: ::core::option::Option<SecretManagerConfig>,
    /// Enable/Disable Compliance Posture features for the cluster.
    #[prost(message, optional, tag = "151")]
    pub compliance_posture_config: ::core::option::Option<CompliancePostureConfig>,
    /// Output only. Reserved for future use.
    #[prost(bool, optional, tag = "152")]
    pub satisfies_pzs: ::core::option::Option<bool>,
    /// Output only. Reserved for future use.
    #[prost(bool, optional, tag = "153")]
    pub satisfies_pzi: ::core::option::Option<bool>,
    /// The Custom keys configuration for the cluster.
    #[prost(message, optional, tag = "154")]
    pub user_managed_keys_config: ::core::option::Option<UserManagedKeysConfig>,
    /// RBACBindingConfig allows user to restrict ClusterRoleBindings an
    /// RoleBindings that can be created.
    #[prost(message, optional, tag = "156")]
    pub rbac_binding_config: ::core::option::Option<RbacBindingConfig>,
}
/// Nested message and enum types in `Cluster`.
pub mod cluster {
    /// The current status of the cluster.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Not set.
        Unspecified = 0,
        /// The PROVISIONING state indicates the cluster is being created.
        Provisioning = 1,
        /// The RUNNING state indicates the cluster has been created and is fully
        /// usable.
        Running = 2,
        /// The RECONCILING state indicates that some work is actively being done on
        /// the cluster, such as upgrading the master or node software. Details can
        /// be found in the `statusMessage` field.
        Reconciling = 3,
        /// The STOPPING state indicates the cluster is being deleted.
        Stopping = 4,
        /// The ERROR state indicates the cluster is unusable. It will be
        /// automatically deleted. Details can be found in the `statusMessage` field.
        Error = 5,
        /// The DEGRADED state indicates the cluster requires user action to restore
        /// full functionality. Details can be found in the `statusMessage` field.
        Degraded = 6,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATUS_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Running => "RUNNING",
                Self::Reconciling => "RECONCILING",
                Self::Stopping => "STOPPING",
                Self::Error => "ERROR",
                Self::Degraded => "DEGRADED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "RUNNING" => Some(Self::Running),
                "RECONCILING" => Some(Self::Reconciling),
                "STOPPING" => Some(Self::Stopping),
                "ERROR" => Some(Self::Error),
                "DEGRADED" => Some(Self::Degraded),
                _ => None,
            }
        }
    }
}
/// RBACBindingConfig allows user to restrict ClusterRoleBindings an RoleBindings
/// that can be created.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RbacBindingConfig {
    /// Setting this to true will allow any ClusterRoleBinding and RoleBinding
    /// with subjets system:anonymous or system:unauthenticated.
    #[prost(bool, optional, tag = "1")]
    pub enable_insecure_binding_system_unauthenticated: ::core::option::Option<bool>,
    /// Setting this to true will allow any ClusterRoleBinding and RoleBinding
    /// with subjects system:authenticated.
    #[prost(bool, optional, tag = "2")]
    pub enable_insecure_binding_system_authenticated: ::core::option::Option<bool>,
}
/// UserManagedKeysConfig holds the resource address to Keys which are used
/// for signing certs and token that are used for communication within cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserManagedKeysConfig {
    /// The Certificate Authority Service caPool to use for the cluster CA in this
    /// cluster.
    #[prost(string, tag = "10")]
    pub cluster_ca: ::prost::alloc::string::String,
    /// Resource path of the Certificate Authority Service caPool to use for the
    /// etcd API CA in this cluster.
    #[prost(string, tag = "11")]
    pub etcd_api_ca: ::prost::alloc::string::String,
    /// Resource path of the Certificate Authority Service caPool to use for the
    /// etcd peer CA in this cluster.
    #[prost(string, tag = "12")]
    pub etcd_peer_ca: ::prost::alloc::string::String,
    /// The Cloud KMS cryptoKeyVersions to use for signing service account JWTs
    /// issued by this cluster.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{cryptoKey}/cryptoKeyVersions/{cryptoKeyVersion}`
    #[prost(string, repeated, tag = "13")]
    pub service_account_signing_keys: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// The Cloud KMS cryptoKeyVersions to use for verifying service account JWTs
    /// issued by this cluster.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{cryptoKey}/cryptoKeyVersions/{cryptoKeyVersion}`
    #[prost(string, repeated, tag = "14")]
    pub service_account_verification_keys: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// The Certificate Authority Service caPool to use for the aggregation CA in
    /// this cluster.
    #[prost(string, tag = "15")]
    pub aggregation_ca: ::prost::alloc::string::String,
    /// The Cloud KMS cryptoKey to use for Confidential Hyperdisk on the control
    /// plane nodes.
    #[prost(string, tag = "16")]
    pub control_plane_disk_encryption_key: ::prost::alloc::string::String,
    /// Resource path of the Cloud KMS cryptoKey to use for encryption of internal
    /// etcd backups.
    #[prost(string, tag = "17")]
    pub gkeops_etcd_backup_encryption_key: ::prost::alloc::string::String,
}
/// CompliancePostureConfig defines the settings needed to enable/disable
/// features for the Compliance Posture.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompliancePostureConfig {
    /// Defines the enablement mode for Compliance Posture.
    #[prost(enumeration = "compliance_posture_config::Mode", optional, tag = "1")]
    pub mode: ::core::option::Option<i32>,
    /// List of enabled compliance standards.
    #[prost(message, repeated, tag = "2")]
    pub compliance_standards: ::prost::alloc::vec::Vec<
        compliance_posture_config::ComplianceStandard,
    >,
}
/// Nested message and enum types in `CompliancePostureConfig`.
pub mod compliance_posture_config {
    /// Defines the details of a compliance standard.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ComplianceStandard {
        /// Name of the compliance standard.
        #[prost(string, optional, tag = "1")]
        pub standard: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Mode defines enablement mode for Compliance Posture.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        /// Default value not specified.
        Unspecified = 0,
        /// Disables Compliance Posture features on the cluster.
        Disabled = 1,
        /// Enables Compliance Posture features on the cluster.
        Enabled = 2,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODE_UNSPECIFIED",
                Self::Disabled => "DISABLED",
                Self::Enabled => "ENABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "DISABLED" => Some(Self::Disabled),
                "ENABLED" => Some(Self::Enabled),
                _ => None,
            }
        }
    }
}
/// K8sBetaAPIConfig , configuration for beta APIs
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct K8sBetaApiConfig {
    /// Enabled k8s beta APIs.
    #[prost(string, repeated, tag = "1")]
    pub enabled_apis: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// SecurityPostureConfig defines the flags needed to enable/disable features for
/// the Security Posture API.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SecurityPostureConfig {
    /// Sets which mode to use for Security Posture features.
    #[prost(enumeration = "security_posture_config::Mode", optional, tag = "1")]
    pub mode: ::core::option::Option<i32>,
    /// Sets which mode to use for vulnerability scanning.
    #[prost(
        enumeration = "security_posture_config::VulnerabilityMode",
        optional,
        tag = "2"
    )]
    pub vulnerability_mode: ::core::option::Option<i32>,
}
/// Nested message and enum types in `SecurityPostureConfig`.
pub mod security_posture_config {
    /// Mode defines enablement mode for GKE Security posture features.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        /// Default value not specified.
        Unspecified = 0,
        /// Disables Security Posture features on the cluster.
        Disabled = 1,
        /// Applies Security Posture features on the cluster.
        Basic = 2,
        /// Applies the Security Posture off cluster Enterprise level features.
        Enterprise = 3,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODE_UNSPECIFIED",
                Self::Disabled => "DISABLED",
                Self::Basic => "BASIC",
                Self::Enterprise => "ENTERPRISE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "DISABLED" => Some(Self::Disabled),
                "BASIC" => Some(Self::Basic),
                "ENTERPRISE" => Some(Self::Enterprise),
                _ => None,
            }
        }
    }
    /// VulnerabilityMode defines enablement mode for vulnerability scanning.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VulnerabilityMode {
        /// Default value not specified.
        Unspecified = 0,
        /// Disables vulnerability scanning on the cluster.
        VulnerabilityDisabled = 1,
        /// Applies basic vulnerability scanning on the cluster.
        VulnerabilityBasic = 2,
        /// Applies the Security Posture's vulnerability on cluster Enterprise level
        /// features.
        VulnerabilityEnterprise = 3,
    }
    impl VulnerabilityMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "VULNERABILITY_MODE_UNSPECIFIED",
                Self::VulnerabilityDisabled => "VULNERABILITY_DISABLED",
                Self::VulnerabilityBasic => "VULNERABILITY_BASIC",
                Self::VulnerabilityEnterprise => "VULNERABILITY_ENTERPRISE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VULNERABILITY_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "VULNERABILITY_DISABLED" => Some(Self::VulnerabilityDisabled),
                "VULNERABILITY_BASIC" => Some(Self::VulnerabilityBasic),
                "VULNERABILITY_ENTERPRISE" => Some(Self::VulnerabilityEnterprise),
                _ => None,
            }
        }
    }
}
/// Node pool configs that apply to all auto-provisioned node pools
/// in autopilot clusters and node auto-provisioning enabled clusters.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodePoolAutoConfig {
    /// The list of instance tags applied to all nodes. Tags are used to identify
    /// valid sources or targets for network firewalls and are specified by
    /// the client during cluster creation. Each tag within the list
    /// must comply with RFC1035.
    #[prost(message, optional, tag = "1")]
    pub network_tags: ::core::option::Option<NetworkTags>,
    /// Resource manager tag keys and values to be attached to the nodes
    /// for managing Compute Engine firewalls using Network Firewall Policies.
    #[prost(message, optional, tag = "2")]
    pub resource_manager_tags: ::core::option::Option<ResourceManagerTags>,
    /// NodeKubeletConfig controls the defaults for autoprovisioned node-pools.
    ///
    /// Currently only `insecure_kubelet_readonly_port_enabled` can be set here.
    #[prost(message, optional, tag = "3")]
    pub node_kubelet_config: ::core::option::Option<NodeKubeletConfig>,
    /// Output only. Configuration options for Linux nodes.
    #[prost(message, optional, tag = "4")]
    pub linux_node_config: ::core::option::Option<LinuxNodeConfig>,
}
/// Subset of Nodepool message that has defaults.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodePoolDefaults {
    /// Subset of NodeConfig message that has defaults.
    #[prost(message, optional, tag = "1")]
    pub node_config_defaults: ::core::option::Option<NodeConfigDefaults>,
}
/// Subset of NodeConfig message that has defaults.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeConfigDefaults {
    /// GCFS (Google Container File System, also known as Riptide) options.
    #[prost(message, optional, tag = "1")]
    pub gcfs_config: ::core::option::Option<GcfsConfig>,
    /// Logging configuration for node pools.
    #[prost(message, optional, tag = "3")]
    pub logging_config: ::core::option::Option<NodePoolLoggingConfig>,
    /// Parameters for containerd customization.
    #[prost(message, optional, tag = "4")]
    pub containerd_config: ::core::option::Option<ContainerdConfig>,
    /// NodeKubeletConfig controls the defaults for new node-pools.
    ///
    /// Currently only `insecure_kubelet_readonly_port_enabled` can be set here.
    #[prost(message, optional, tag = "6")]
    pub node_kubelet_config: ::core::option::Option<NodeKubeletConfig>,
}
/// ClusterUpdate describes an update to the cluster. Exactly one update can
/// be applied to a cluster with each request, so at most one field can be
/// provided.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterUpdate {
    /// The Kubernetes version to change the nodes to (typically an
    /// upgrade).
    ///
    /// Users may specify either explicit versions offered by
    /// Kubernetes Engine or version aliases, which have the following behavior:
    ///
    /// - "latest": picks the highest valid Kubernetes version
    /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
    /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
    /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
    /// - "-": picks the Kubernetes master version
    #[prost(string, tag = "4")]
    pub desired_node_version: ::prost::alloc::string::String,
    /// The monitoring service the cluster should use to write metrics.
    /// Currently available options:
    ///
    /// * "monitoring.googleapis.com/kubernetes" - The Cloud Monitoring
    /// service with a Kubernetes-native resource model
    /// * `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no
    ///    longer available as of GKE 1.15).
    /// * `none` - No metrics will be exported from the cluster.
    ///
    /// If left as an empty string,`monitoring.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `monitoring.googleapis.com` for earlier versions.
    #[prost(string, tag = "5")]
    pub desired_monitoring_service: ::prost::alloc::string::String,
    /// Configurations for the various addons available to run in the cluster.
    #[prost(message, optional, tag = "6")]
    pub desired_addons_config: ::core::option::Option<AddonsConfig>,
    /// The node pool to be upgraded. This field is mandatory if
    /// "desired_node_version", "desired_image_family" or
    /// "desired_node_pool_autoscaling" is specified and there is more than one
    /// node pool on the cluster.
    #[prost(string, tag = "7")]
    pub desired_node_pool_id: ::prost::alloc::string::String,
    /// The desired image type for the node pool.
    /// NOTE: Set the "desired_node_pool" field as well.
    #[prost(string, tag = "8")]
    pub desired_image_type: ::prost::alloc::string::String,
    /// Configuration of etcd encryption.
    #[prost(message, optional, tag = "46")]
    pub desired_database_encryption: ::core::option::Option<DatabaseEncryption>,
    /// Configuration for Workload Identity.
    #[prost(message, optional, tag = "47")]
    pub desired_workload_identity_config: ::core::option::Option<WorkloadIdentityConfig>,
    /// Configuration for issuance of mTLS keys and certificates to Kubernetes
    /// pods.
    #[prost(message, optional, tag = "67")]
    pub desired_mesh_certificates: ::core::option::Option<MeshCertificates>,
    /// Configuration for Shielded Nodes.
    #[prost(message, optional, tag = "48")]
    pub desired_shielded_nodes: ::core::option::Option<ShieldedNodes>,
    /// The desired configuration for the fine-grained cost management feature.
    #[prost(message, optional, tag = "49")]
    pub desired_cost_management_config: ::core::option::Option<CostManagementConfig>,
    /// DNSConfig contains clusterDNS config for this cluster.
    #[prost(message, optional, tag = "53")]
    pub desired_dns_config: ::core::option::Option<DnsConfig>,
    /// Autoscaler configuration for the node pool specified in
    /// desired_node_pool_id. If there is only one pool in the
    /// cluster and desired_node_pool_id is not provided then
    /// the change applies to that single node pool.
    #[prost(message, optional, tag = "9")]
    pub desired_node_pool_autoscaling: ::core::option::Option<NodePoolAutoscaling>,
    /// The desired list of Google Compute Engine
    /// [zones](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster's nodes should be located.
    ///
    /// This list must always include the cluster's primary zone.
    ///
    /// Warning: changing cluster locations will update the locations of all node
    /// pools and will result in nodes being added and/or removed.
    #[prost(string, repeated, tag = "10")]
    pub desired_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The desired configuration options for master authorized networks feature.
    ///
    /// Deprecated: Use
    /// desired_control_plane_endpoints_config.ip_endpoints_config.authorized_networks_config
    /// instead.
    #[deprecated]
    #[prost(message, optional, tag = "12")]
    pub desired_master_authorized_networks_config: ::core::option::Option<
        MasterAuthorizedNetworksConfig,
    >,
    /// Cluster-level autoscaling configuration.
    #[prost(message, optional, tag = "15")]
    pub desired_cluster_autoscaling: ::core::option::Option<ClusterAutoscaling>,
    /// The desired configuration options for the Binary Authorization feature.
    #[prost(message, optional, tag = "16")]
    pub desired_binary_authorization: ::core::option::Option<BinaryAuthorization>,
    /// The logging service the cluster should use to write logs.
    /// Currently available options:
    ///
    /// * `logging.googleapis.com/kubernetes` - The Cloud Logging
    /// service with a Kubernetes-native resource model
    /// * `logging.googleapis.com` - The legacy Cloud Logging service (no longer
    ///    available as of GKE 1.15).
    /// * `none` - no logs will be exported from the cluster.
    ///
    /// If left as an empty string,`logging.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `logging.googleapis.com` for earlier versions.
    #[prost(string, tag = "19")]
    pub desired_logging_service: ::prost::alloc::string::String,
    /// The desired configuration for exporting resource usage.
    #[prost(message, optional, tag = "21")]
    pub desired_resource_usage_export_config: ::core::option::Option<
        ResourceUsageExportConfig,
    >,
    /// Cluster-level Vertical Pod Autoscaling configuration.
    #[prost(message, optional, tag = "22")]
    pub desired_vertical_pod_autoscaling: ::core::option::Option<VerticalPodAutoscaling>,
    /// The desired private cluster configuration. master_global_access_config is
    /// the only field that can be changed via this field.
    /// See also
    /// [ClusterUpdate.desired_enable_private_endpoint][google.container.v1.ClusterUpdate.desired_enable_private_endpoint]
    /// for modifying other fields within
    /// [PrivateClusterConfig][google.container.v1.PrivateClusterConfig].
    ///
    /// Deprecated: Use
    /// desired_control_plane_endpoints_config.ip_endpoints_config.global_access
    /// instead.
    #[deprecated]
    #[prost(message, optional, tag = "25")]
    pub desired_private_cluster_config: ::core::option::Option<PrivateClusterConfig>,
    /// The desired config of Intra-node visibility.
    #[prost(message, optional, tag = "26")]
    pub desired_intra_node_visibility_config: ::core::option::Option<
        IntraNodeVisibilityConfig,
    >,
    /// The desired status of whether to disable default sNAT for this cluster.
    #[prost(message, optional, tag = "28")]
    pub desired_default_snat_status: ::core::option::Option<DefaultSnatStatus>,
    /// The desired release channel configuration.
    #[prost(message, optional, tag = "31")]
    pub desired_release_channel: ::core::option::Option<ReleaseChannel>,
    /// The desired L4 Internal Load Balancer Subsetting configuration.
    #[prost(message, optional, tag = "39")]
    pub desired_l4ilb_subsetting_config: ::core::option::Option<IlbSubsettingConfig>,
    /// The desired datapath provider for the cluster.
    #[prost(enumeration = "DatapathProvider", tag = "50")]
    pub desired_datapath_provider: i32,
    /// The desired state of IPv6 connectivity to Google Services.
    #[prost(enumeration = "PrivateIPv6GoogleAccess", tag = "51")]
    pub desired_private_ipv6_google_access: i32,
    /// The desired notification configuration.
    #[prost(message, optional, tag = "55")]
    pub desired_notification_config: ::core::option::Option<NotificationConfig>,
    /// The desired authenticator groups config for the cluster.
    #[prost(message, optional, tag = "63")]
    pub desired_authenticator_groups_config: ::core::option::Option<
        AuthenticatorGroupsConfig,
    >,
    /// The desired logging configuration.
    #[prost(message, optional, tag = "64")]
    pub desired_logging_config: ::core::option::Option<LoggingConfig>,
    /// The desired monitoring configuration.
    #[prost(message, optional, tag = "65")]
    pub desired_monitoring_config: ::core::option::Option<MonitoringConfig>,
    /// The desired Identity Service component configuration.
    #[prost(message, optional, tag = "66")]
    pub desired_identity_service_config: ::core::option::Option<IdentityServiceConfig>,
    /// ServiceExternalIPsConfig specifies the config for the use of Services with
    /// ExternalIPs field.
    #[prost(message, optional, tag = "60")]
    pub desired_service_external_ips_config: ::core::option::Option<
        ServiceExternalIPsConfig,
    >,
    /// Enable/Disable private endpoint for the cluster's master.
    ///
    /// Deprecated: Use
    /// desired_control_plane_endpoints_config.ip_endpoints_config.enable_public_endpoint
    /// instead. Note that the value of enable_public_endpoint is reversed: if
    /// enable_private_endpoint is false, then enable_public_endpoint will be true.
    #[deprecated]
    #[prost(bool, optional, tag = "71")]
    pub desired_enable_private_endpoint: ::core::option::Option<bool>,
    /// Override the default setting of whether future created
    /// nodes have private IP addresses only, namely
    /// [NetworkConfig.default_enable_private_nodes][google.container.v1.NetworkConfig.default_enable_private_nodes]
    #[prost(bool, optional, tag = "72")]
    pub desired_default_enable_private_nodes: ::core::option::Option<bool>,
    /// [Control plane
    /// endpoints][google.container.v1.Cluster.control_plane_endpoints_config]
    /// configuration.
    #[prost(message, optional, tag = "73")]
    pub desired_control_plane_endpoints_config: ::core::option::Option<
        ControlPlaneEndpointsConfig,
    >,
    /// The Kubernetes version to change the master to.
    ///
    /// Users may specify either explicit versions offered by
    /// Kubernetes Engine or version aliases, which have the following behavior:
    ///
    /// - "latest": picks the highest valid Kubernetes version
    /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
    /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
    /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
    /// - "-": picks the default Kubernetes version
    #[prost(string, tag = "100")]
    pub desired_master_version: ::prost::alloc::string::String,
    /// The desired GCFS config for the cluster
    #[prost(message, optional, tag = "109")]
    pub desired_gcfs_config: ::core::option::Option<GcfsConfig>,
    /// The desired network tags that apply to all auto-provisioned node pools
    /// in autopilot clusters and node auto-provisioning enabled clusters.
    #[prost(message, optional, tag = "110")]
    pub desired_node_pool_auto_config_network_tags: ::core::option::Option<NetworkTags>,
    /// The desired config of Gateway API on this cluster.
    #[prost(message, optional, tag = "114")]
    pub desired_gateway_api_config: ::core::option::Option<GatewayApiConfig>,
    /// The current etag of the cluster.
    /// If an etag is provided and does not match the current etag of the cluster,
    /// update will be blocked and an ABORTED error will be returned.
    #[prost(string, tag = "115")]
    pub etag: ::prost::alloc::string::String,
    /// The desired node pool logging configuration defaults for the cluster.
    #[prost(message, optional, tag = "116")]
    pub desired_node_pool_logging_config: ::core::option::Option<NodePoolLoggingConfig>,
    /// The desired fleet configuration for the cluster.
    #[prost(message, optional, tag = "117")]
    pub desired_fleet: ::core::option::Option<Fleet>,
    /// The desired stack type of the cluster.
    /// If a stack type is provided and does not match the current stack type of
    /// the cluster, update will attempt to change the stack type to the new type.
    #[prost(enumeration = "StackType", tag = "119")]
    pub desired_stack_type: i32,
    /// The additional pod ranges to be added to the cluster. These pod ranges
    /// can be used by node pools to allocate pod IPs.
    #[prost(message, optional, tag = "120")]
    pub additional_pod_ranges_config: ::core::option::Option<AdditionalPodRangesConfig>,
    /// The additional pod ranges that are to be removed from the cluster.
    /// The pod ranges specified here must have been specified earlier in the
    /// 'additional_pod_ranges_config' argument.
    #[prost(message, optional, tag = "121")]
    pub removed_additional_pod_ranges_config: ::core::option::Option<
        AdditionalPodRangesConfig,
    >,
    /// Kubernetes open source beta apis enabled on the cluster. Only beta apis
    #[prost(message, optional, tag = "122")]
    pub enable_k8s_beta_apis: ::core::option::Option<K8sBetaApiConfig>,
    /// Enable/Disable Security Posture API features for the cluster.
    #[prost(message, optional, tag = "124")]
    pub desired_security_posture_config: ::core::option::Option<SecurityPostureConfig>,
    /// The desired network performance config.
    #[prost(message, optional, tag = "125")]
    pub desired_network_performance_config: ::core::option::Option<
        network_config::ClusterNetworkPerformanceConfig,
    >,
    /// Enable/Disable FQDN Network Policy for the cluster.
    #[prost(bool, optional, tag = "126")]
    pub desired_enable_fqdn_network_policy: ::core::option::Option<bool>,
    /// The desired workload policy configuration for the autopilot cluster.
    #[prost(message, optional, tag = "128")]
    pub desired_autopilot_workload_policy_config: ::core::option::Option<
        WorkloadPolicyConfig,
    >,
    /// Desired Beta APIs to be enabled for cluster.
    #[prost(message, optional, tag = "131")]
    pub desired_k8s_beta_apis: ::core::option::Option<K8sBetaApiConfig>,
    /// The desired containerd config for the cluster.
    #[prost(message, optional, tag = "134")]
    pub desired_containerd_config: ::core::option::Option<ContainerdConfig>,
    /// Enable/Disable Multi-Networking for the cluster
    #[prost(bool, optional, tag = "135")]
    pub desired_enable_multi_networking: ::core::option::Option<bool>,
    /// The desired resource manager tags that apply to all auto-provisioned node
    /// pools in autopilot clusters and node auto-provisioning enabled clusters.
    #[prost(message, optional, tag = "136")]
    pub desired_node_pool_auto_config_resource_manager_tags: ::core::option::Option<
        ResourceManagerTags,
    >,
    /// Specify the details of in-transit encryption.
    #[prost(enumeration = "InTransitEncryptionConfig", optional, tag = "137")]
    pub desired_in_transit_encryption_config: ::core::option::Option<i32>,
    /// Enable/Disable Cilium Clusterwide Network Policy for the cluster.
    #[prost(bool, optional, tag = "138")]
    pub desired_enable_cilium_clusterwide_network_policy: ::core::option::Option<bool>,
    /// Enable/Disable Secret Manager Config.
    #[prost(message, optional, tag = "139")]
    pub desired_secret_manager_config: ::core::option::Option<SecretManagerConfig>,
    /// Enable/Disable Compliance Posture features for the cluster.
    #[prost(message, optional, tag = "140")]
    pub desired_compliance_posture_config: ::core::option::Option<
        CompliancePostureConfig,
    >,
    /// The desired node kubelet config for the cluster.
    #[prost(message, optional, tag = "141")]
    pub desired_node_kubelet_config: ::core::option::Option<NodeKubeletConfig>,
    /// The desired node kubelet config for all auto-provisioned node pools
    /// in autopilot clusters and node auto-provisioning enabled clusters.
    #[prost(message, optional, tag = "142")]
    pub desired_node_pool_auto_config_kubelet_config: ::core::option::Option<
        NodeKubeletConfig,
    >,
    /// The Custom keys configuration for the cluster.
    #[prost(message, optional, tag = "143")]
    pub user_managed_keys_config: ::core::option::Option<UserManagedKeysConfig>,
    /// RBACBindingConfig allows user to restrict ClusterRoleBindings an
    /// RoleBindings that can be created.
    #[prost(message, optional, tag = "144")]
    pub desired_rbac_binding_config: ::core::option::Option<RbacBindingConfig>,
    /// The desired enterprise configuration for the cluster.
    #[prost(message, optional, tag = "147")]
    pub desired_enterprise_config: ::core::option::Option<DesiredEnterpriseConfig>,
    /// The desired Linux node config for all auto-provisioned node pools
    /// in autopilot clusters and node auto-provisioning enabled clusters.
    ///
    /// Currently only `cgroup_mode` can be set here.
    #[prost(message, optional, tag = "150")]
    pub desired_node_pool_auto_config_linux_node_config: ::core::option::Option<
        LinuxNodeConfig,
    >,
}
/// AdditionalPodRangesConfig is the configuration for additional pod secondary
/// ranges supporting the ClusterUpdate message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionalPodRangesConfig {
    /// Name for pod secondary ipv4 range which has the actual range defined ahead.
    #[prost(string, repeated, tag = "1")]
    pub pod_range_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. Information for additional pod range.
    #[prost(message, repeated, tag = "2")]
    pub pod_range_info: ::prost::alloc::vec::Vec<RangeInfo>,
}
/// RangeInfo contains the range name and the range utilization by this cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeInfo {
    /// Output only. Name of a range.
    #[prost(string, tag = "1")]
    pub range_name: ::prost::alloc::string::String,
    /// Output only. The utilization of the range.
    #[prost(double, tag = "2")]
    pub utilization: f64,
}
/// DesiredEnterpriseConfig is a wrapper used for updating enterprise_config.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DesiredEnterpriseConfig {
    /// desired_tier specifies the desired tier of the cluster.
    #[prost(enumeration = "enterprise_config::ClusterTier", tag = "1")]
    pub desired_tier: i32,
}
/// This operation resource represents operations that may have happened or are
/// happening on the cluster. All fields are output only.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Operation {
    /// Output only. The server-assigned ID for the operation.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// operation is taking place. This field is deprecated, use location instead.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Output only. The operation type.
    #[prost(enumeration = "operation::Type", tag = "3")]
    pub operation_type: i32,
    /// Output only. The current status of the operation.
    #[prost(enumeration = "operation::Status", tag = "4")]
    pub status: i32,
    /// Output only. Detailed operation progress, if available.
    #[prost(string, tag = "8")]
    pub detail: ::prost::alloc::string::String,
    /// Output only. If an error has occurred, a textual description of the error.
    /// Deprecated. Use the field error instead.
    #[deprecated]
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Server-defined URI for the operation. Example:
    /// `<https://container.googleapis.com/v1alpha1/projects/123/locations/us-central1/operations/operation-123`.>
    #[prost(string, tag = "6")]
    pub self_link: ::prost::alloc::string::String,
    /// Output only. Server-defined URI for the target of the operation. The format
    /// of this is a URI to the resource being modified (such as a cluster, node
    /// pool, or node). For node pool repairs, there may be multiple nodes being
    /// repaired, but only one will be the target.
    ///
    /// Examples:
    ///
    /// -
    /// ##
    /// `<https://container.googleapis.com/v1/projects/123/locations/us-central1/clusters/my-cluster`>
    ///
    /// ##
    /// `<https://container.googleapis.com/v1/projects/123/zones/us-central1-c/clusters/my-cluster/nodePools/my-np`>
    ///
    /// `<https://container.googleapis.com/v1/projects/123/zones/us-central1-c/clusters/my-cluster/nodePools/my-np/node/my-node`>
    #[prost(string, tag = "7")]
    pub target_link: ::prost::alloc::string::String,
    /// Output only. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/regions-zones/regions-zones#available>)
    /// or
    /// [region](<https://cloud.google.com/compute/docs/regions-zones/regions-zones#available>)
    /// in which the cluster resides.
    #[prost(string, tag = "9")]
    pub location: ::prost::alloc::string::String,
    /// Output only. The time the operation started, in
    /// [RFC3339](<https://www.ietf.org/rfc/rfc3339.txt>) text format.
    #[prost(string, tag = "10")]
    pub start_time: ::prost::alloc::string::String,
    /// Output only. The time the operation completed, in
    /// [RFC3339](<https://www.ietf.org/rfc/rfc3339.txt>) text format.
    #[prost(string, tag = "11")]
    pub end_time: ::prost::alloc::string::String,
    /// Output only. Progress information for an operation.
    #[prost(message, optional, tag = "12")]
    pub progress: ::core::option::Option<OperationProgress>,
    /// Which conditions caused the current cluster state.
    /// Deprecated. Use field error instead.
    #[deprecated]
    #[prost(message, repeated, tag = "13")]
    pub cluster_conditions: ::prost::alloc::vec::Vec<StatusCondition>,
    /// Which conditions caused the current node pool state.
    /// Deprecated. Use field error instead.
    #[deprecated]
    #[prost(message, repeated, tag = "14")]
    pub nodepool_conditions: ::prost::alloc::vec::Vec<StatusCondition>,
    /// The error result of the operation in case of failure.
    #[prost(message, optional, tag = "15")]
    pub error: ::core::option::Option<super::super::rpc::Status>,
}
/// Nested message and enum types in `Operation`.
pub mod operation {
    /// Current status of the operation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Not set.
        Unspecified = 0,
        /// The operation has been created.
        Pending = 1,
        /// The operation is currently running.
        Running = 2,
        /// The operation is done, either cancelled or completed.
        Done = 3,
        /// The operation is aborting.
        Aborting = 4,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATUS_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Running => "RUNNING",
                Self::Done => "DONE",
                Self::Aborting => "ABORTING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "RUNNING" => Some(Self::Running),
                "DONE" => Some(Self::Done),
                "ABORTING" => Some(Self::Aborting),
                _ => None,
            }
        }
    }
    /// Operation type categorizes the operation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Not set.
        Unspecified = 0,
        /// The cluster is being created. The cluster should be assumed to be
        /// unusable until the operation finishes.
        ///
        /// In the event of the operation failing, the cluster will enter the [ERROR
        /// state][Cluster.Status.ERROR] and eventually be deleted.
        CreateCluster = 1,
        /// The cluster is being deleted. The cluster should be assumed to be
        /// unusable as soon as this operation starts.
        ///
        /// In the event of the operation failing, the cluster will enter the [ERROR
        /// state][Cluster.Status.ERROR] and the deletion will be automatically
        /// retried until completed.
        DeleteCluster = 2,
        /// The [cluster
        /// version][google.container.v1.ClusterUpdate.desired_master_version] is
        /// being updated. Note that this includes "upgrades" to the same version,
        /// which are simply a recreation. This also includes
        /// [auto-upgrades](<https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-upgrades#upgrading_automatically>).
        /// For more details, see [documentation on cluster
        /// upgrades](<https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-upgrades#cluster_upgrades>).
        UpgradeMaster = 3,
        /// A node pool is being updated. Despite calling this an "upgrade", this
        /// includes most forms of updates to node pools. This also includes
        /// [auto-upgrades](<https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-upgrades>).
        ///
        /// This operation sets the
        /// [progress][google.container.v1.Operation.progress] field and may be
        /// [canceled][google.container.v1.ClusterManager.CancelOperation].
        ///
        /// The upgrade strategy depends on [node pool
        /// configuration](<https://cloud.google.com/kubernetes-engine/docs/concepts/node-pool-upgrade-strategies>).
        /// The nodes are generally still usable during this operation.
        UpgradeNodes = 4,
        /// A problem has been detected with the control plane and is being repaired.
        /// This operation type is initiated by GKE. For more details, see
        /// [documentation on
        /// repairs](<https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions#repairs>).
        RepairCluster = 5,
        /// The cluster is being updated. This is a broad category of operations and
        /// includes operations that only change metadata as well as those that must
        /// recreate the entire cluster. If the control plane must be recreated, this
        /// will cause temporary downtime for zonal clusters.
        ///
        /// Some features require recreating the nodes as well. Those will be
        /// recreated as separate operations and the update may not be completely
        /// functional until the node pools recreations finish. Node recreations will
        /// generally follow [maintenance
        /// policies](<https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions>).
        ///
        /// Some GKE-initiated operations use this type. This includes certain types
        /// of auto-upgrades and incident mitigations.
        UpdateCluster = 6,
        /// A node pool is being created. The node pool should be assumed to be
        /// unusable until this operation finishes. In the event of an error, the
        /// node pool may be partially created.
        ///
        /// If enabled, [node
        /// autoprovisioning](<https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-provisioning>)
        /// may have automatically initiated such operations.
        CreateNodePool = 7,
        /// The node pool is being deleted. The node pool should be assumed to be
        /// unusable as soon as this operation starts.
        DeleteNodePool = 8,
        /// The node pool's [manamagent][google.container.v1.NodePool.management]
        /// field is being updated. These operations only update metadata and may be
        /// concurrent with most other operations.
        SetNodePoolManagement = 9,
        /// A problem has been detected with nodes and [they are being
        /// repaired](<https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-repair>).
        /// This operation type is initiated by GKE, typically automatically. This
        /// operation may be concurrent with other operations and there may be
        /// multiple repairs occurring on the same node pool.
        AutoRepairNodes = 10,
        /// Unused. Automatic node upgrade uses
        /// [UPGRADE_NODES][google.container.v1.Operation.Type.UPGRADE_NODES].
        AutoUpgradeNodes = 11,
        /// Unused. Updating labels uses
        /// [UPDATE_CLUSTER][google.container.v1.Operation.Type.UPDATE_CLUSTER].
        SetLabels = 12,
        /// Unused. Updating master auth uses
        /// [UPDATE_CLUSTER][google.container.v1.Operation.Type.UPDATE_CLUSTER].
        SetMasterAuth = 13,
        /// The node pool is being resized. With the exception of resizing to or from
        /// size zero, the node pool is generally usable during this operation.
        SetNodePoolSize = 14,
        /// Unused. Updating network policy uses
        /// [UPDATE_CLUSTER][google.container.v1.Operation.Type.UPDATE_CLUSTER].
        SetNetworkPolicy = 15,
        /// Unused. Updating maintenance policy uses
        /// [UPDATE_CLUSTER][google.container.v1.Operation.Type.UPDATE_CLUSTER].
        SetMaintenancePolicy = 16,
        /// The control plane is being resized. This operation type is initiated by
        /// GKE. These operations are often performed preemptively to ensure that the
        /// control plane has sufficient resources and is not typically an indication
        /// of issues. For more details, see
        /// [documentation on
        /// resizes](<https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions#repairs>).
        ResizeCluster = 18,
        /// Fleet features of GKE Enterprise are being upgraded. The cluster should
        /// be assumed to be blocked for other upgrades until the operation finishes.
        FleetFeatureUpgrade = 19,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::CreateCluster => "CREATE_CLUSTER",
                Self::DeleteCluster => "DELETE_CLUSTER",
                Self::UpgradeMaster => "UPGRADE_MASTER",
                Self::UpgradeNodes => "UPGRADE_NODES",
                Self::RepairCluster => "REPAIR_CLUSTER",
                Self::UpdateCluster => "UPDATE_CLUSTER",
                Self::CreateNodePool => "CREATE_NODE_POOL",
                Self::DeleteNodePool => "DELETE_NODE_POOL",
                Self::SetNodePoolManagement => "SET_NODE_POOL_MANAGEMENT",
                Self::AutoRepairNodes => "AUTO_REPAIR_NODES",
                Self::AutoUpgradeNodes => "AUTO_UPGRADE_NODES",
                Self::SetLabels => "SET_LABELS",
                Self::SetMasterAuth => "SET_MASTER_AUTH",
                Self::SetNodePoolSize => "SET_NODE_POOL_SIZE",
                Self::SetNetworkPolicy => "SET_NETWORK_POLICY",
                Self::SetMaintenancePolicy => "SET_MAINTENANCE_POLICY",
                Self::ResizeCluster => "RESIZE_CLUSTER",
                Self::FleetFeatureUpgrade => "FLEET_FEATURE_UPGRADE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATE_CLUSTER" => Some(Self::CreateCluster),
                "DELETE_CLUSTER" => Some(Self::DeleteCluster),
                "UPGRADE_MASTER" => Some(Self::UpgradeMaster),
                "UPGRADE_NODES" => Some(Self::UpgradeNodes),
                "REPAIR_CLUSTER" => Some(Self::RepairCluster),
                "UPDATE_CLUSTER" => Some(Self::UpdateCluster),
                "CREATE_NODE_POOL" => Some(Self::CreateNodePool),
                "DELETE_NODE_POOL" => Some(Self::DeleteNodePool),
                "SET_NODE_POOL_MANAGEMENT" => Some(Self::SetNodePoolManagement),
                "AUTO_REPAIR_NODES" => Some(Self::AutoRepairNodes),
                "AUTO_UPGRADE_NODES" => Some(Self::AutoUpgradeNodes),
                "SET_LABELS" => Some(Self::SetLabels),
                "SET_MASTER_AUTH" => Some(Self::SetMasterAuth),
                "SET_NODE_POOL_SIZE" => Some(Self::SetNodePoolSize),
                "SET_NETWORK_POLICY" => Some(Self::SetNetworkPolicy),
                "SET_MAINTENANCE_POLICY" => Some(Self::SetMaintenancePolicy),
                "RESIZE_CLUSTER" => Some(Self::ResizeCluster),
                "FLEET_FEATURE_UPGRADE" => Some(Self::FleetFeatureUpgrade),
                _ => None,
            }
        }
    }
}
/// Information about operation (or operation stage) progress.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationProgress {
    /// A non-parameterized string describing an operation stage.
    /// Unset for single-stage operations.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Status of an operation stage.
    /// Unset for single-stage operations.
    #[prost(enumeration = "operation::Status", tag = "2")]
    pub status: i32,
    /// Progress metric bundle, for example:
    ///    metrics: [{name: "nodes done",     int_value: 15},
    ///              {name: "nodes total",    int_value: 32}]
    /// or
    ///    metrics: [{name: "progress",       double_value: 0.56},
    ///              {name: "progress scale", double_value: 1.0}]
    #[prost(message, repeated, tag = "3")]
    pub metrics: ::prost::alloc::vec::Vec<operation_progress::Metric>,
    /// Substages of an operation or a stage.
    #[prost(message, repeated, tag = "4")]
    pub stages: ::prost::alloc::vec::Vec<OperationProgress>,
}
/// Nested message and enum types in `OperationProgress`.
pub mod operation_progress {
    /// Progress metric is (string, int|float|string) pair.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Metric {
        /// Required. Metric name, e.g., "nodes total", "percent done".
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Strictly one of the values is required.
        #[prost(oneof = "metric::Value", tags = "2, 3, 4")]
        pub value: ::core::option::Option<metric::Value>,
    }
    /// Nested message and enum types in `Metric`.
    pub mod metric {
        /// Strictly one of the values is required.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            /// For metrics with integer value.
            #[prost(int64, tag = "2")]
            IntValue(i64),
            /// For metrics with floating point value.
            #[prost(double, tag = "3")]
            DoubleValue(f64),
            /// For metrics with custom values (ratios, visual progress, etc.).
            #[prost(string, tag = "4")]
            StringValue(::prost::alloc::string::String),
        }
    }
}
/// CreateClusterRequest creates a cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateClusterRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the parent field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the parent
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Required. A [cluster
    /// resource](<https://cloud.google.com/container-engine/reference/rest/v1/projects.locations.clusters>)
    #[prost(message, optional, tag = "3")]
    pub cluster: ::core::option::Option<Cluster>,
    /// The parent (project and location) where the cluster will be created.
    /// Specified in the format `projects/*/locations/*`.
    #[prost(string, tag = "5")]
    pub parent: ::prost::alloc::string::String,
}
/// GetClusterRequest gets the settings of a cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClusterRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster to retrieve.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// The name (project, location, cluster) of the cluster to retrieve.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
}
/// UpdateClusterRequest updates the settings of a cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateClusterRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Required. A description of the update.
    #[prost(message, optional, tag = "4")]
    pub update: ::core::option::Option<ClusterUpdate>,
    /// The name (project, location, cluster) of the cluster to update.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
}
/// UpdateNodePoolRequests update a node pool's image and/or version.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNodePoolRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the node pool to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "4")]
    pub node_pool_id: ::prost::alloc::string::String,
    /// Required. The Kubernetes version to change the nodes to (typically an
    /// upgrade).
    ///
    /// Users may specify either explicit versions offered by Kubernetes Engine or
    /// version aliases, which have the following behavior:
    ///
    /// - "latest": picks the highest valid Kubernetes version
    /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
    /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
    /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
    /// - "-": picks the Kubernetes master version
    #[prost(string, tag = "5")]
    pub node_version: ::prost::alloc::string::String,
    /// Required. The desired image type for the node pool. Please see
    /// <https://cloud.google.com/kubernetes-engine/docs/concepts/node-images> for
    /// available image types.
    #[prost(string, tag = "6")]
    pub image_type: ::prost::alloc::string::String,
    /// The name (project, location, cluster, node pool) of the node pool to
    /// update. Specified in the format
    /// `projects/*/locations/*/clusters/*/nodePools/*`.
    #[prost(string, tag = "8")]
    pub name: ::prost::alloc::string::String,
    /// The desired list of Google Compute Engine
    /// [zones](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// node pool's nodes should be located. Changing the locations for a node pool
    /// will result in nodes being either created or removed from the node pool,
    /// depending on whether locations are being added or removed.
    #[prost(string, repeated, tag = "13")]
    pub locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The desired workload metadata config for the node pool.
    #[prost(message, optional, tag = "14")]
    pub workload_metadata_config: ::core::option::Option<WorkloadMetadataConfig>,
    /// Upgrade settings control disruption and speed of the upgrade.
    #[prost(message, optional, tag = "15")]
    pub upgrade_settings: ::core::option::Option<node_pool::UpgradeSettings>,
    /// The desired network tags to be applied to all nodes in the node pool.
    /// If this field is not present, the tags will not be changed. Otherwise,
    /// the existing network tags will be *replaced* with the provided tags.
    #[prost(message, optional, tag = "16")]
    pub tags: ::core::option::Option<NetworkTags>,
    /// The desired node taints to be applied to all nodes in the node pool.
    /// If this field is not present, the taints will not be changed. Otherwise,
    /// the existing node taints will be *replaced* with the provided taints.
    #[prost(message, optional, tag = "17")]
    pub taints: ::core::option::Option<NodeTaints>,
    /// The desired node labels to be applied to all nodes in the node pool.
    /// If this field is not present, the labels will not be changed. Otherwise,
    /// the existing node labels will be *replaced* with the provided labels.
    #[prost(message, optional, tag = "18")]
    pub labels: ::core::option::Option<NodeLabels>,
    /// Parameters that can be configured on Linux nodes.
    #[prost(message, optional, tag = "19")]
    pub linux_node_config: ::core::option::Option<LinuxNodeConfig>,
    /// Node kubelet configs.
    #[prost(message, optional, tag = "20")]
    pub kubelet_config: ::core::option::Option<NodeKubeletConfig>,
    /// Node network config.
    #[prost(message, optional, tag = "21")]
    pub node_network_config: ::core::option::Option<NodeNetworkConfig>,
    /// GCFS config.
    #[prost(message, optional, tag = "22")]
    pub gcfs_config: ::core::option::Option<GcfsConfig>,
    /// Confidential nodes config.
    /// All the nodes in the node pool will be Confidential VM once enabled.
    #[prost(message, optional, tag = "23")]
    pub confidential_nodes: ::core::option::Option<ConfidentialNodes>,
    /// Enable or disable gvnic on the node pool.
    #[prost(message, optional, tag = "29")]
    pub gvnic: ::core::option::Option<VirtualNic>,
    /// The current etag of the node pool.
    /// If an etag is provided and does not match the current etag of the node
    /// pool, update will be blocked and an ABORTED error will be returned.
    #[prost(string, tag = "30")]
    pub etag: ::prost::alloc::string::String,
    /// Enable or disable NCCL fast socket for the node pool.
    #[prost(message, optional, tag = "31")]
    pub fast_socket: ::core::option::Option<FastSocket>,
    /// Logging configuration.
    #[prost(message, optional, tag = "32")]
    pub logging_config: ::core::option::Option<NodePoolLoggingConfig>,
    /// The resource labels for the node pool to use to annotate any related
    /// Google Compute Engine resources.
    #[prost(message, optional, tag = "33")]
    pub resource_labels: ::core::option::Option<ResourceLabels>,
    /// Parameters that can be configured on Windows nodes.
    #[prost(message, optional, tag = "34")]
    pub windows_node_config: ::core::option::Option<WindowsNodeConfig>,
    /// A list of hardware accelerators to be attached to each node.
    /// See <https://cloud.google.com/compute/docs/gpus> for more information about
    /// support for GPUs.
    #[prost(message, repeated, tag = "35")]
    pub accelerators: ::prost::alloc::vec::Vec<AcceleratorConfig>,
    /// Optional. The desired [Google Compute Engine machine
    /// type](<https://cloud.google.com/compute/docs/machine-types>) for nodes in the
    /// node pool. Initiates an upgrade operation that migrates the nodes in the
    /// node pool to the specified machine type.
    #[prost(string, tag = "36")]
    pub machine_type: ::prost::alloc::string::String,
    /// Optional. The desired disk type (e.g. 'pd-standard', 'pd-ssd' or
    /// 'pd-balanced') for nodes in the node pool.
    /// Initiates an upgrade operation that migrates the nodes in the
    /// node pool to the specified disk type.
    #[prost(string, tag = "37")]
    pub disk_type: ::prost::alloc::string::String,
    /// Optional. The desired disk size for nodes in the node pool specified in GB.
    /// The smallest allowed disk size is 10GB.
    /// Initiates an upgrade operation that migrates the nodes in the
    /// node pool to the specified disk size.
    #[prost(int64, tag = "38")]
    pub disk_size_gb: i64,
    /// Desired resource manager tag keys and values to be attached to the nodes
    /// for managing Compute Engine firewalls using Network Firewall Policies.
    /// Existing tags will be replaced with new values.
    #[prost(message, optional, tag = "39")]
    pub resource_manager_tags: ::core::option::Option<ResourceManagerTags>,
    /// The desired containerd config for nodes in the node pool.
    /// Initiates an upgrade operation that recreates the nodes with the new
    /// config.
    #[prost(message, optional, tag = "40")]
    pub containerd_config: ::core::option::Option<ContainerdConfig>,
    /// Specifies the configuration of queued provisioning.
    #[prost(message, optional, tag = "42")]
    pub queued_provisioning: ::core::option::Option<node_pool::QueuedProvisioning>,
    /// List of Storage Pools where boot disks are provisioned.
    /// Existing Storage Pools will be replaced with storage-pools.
    #[prost(string, repeated, tag = "43")]
    pub storage_pools: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// SetNodePoolAutoscalingRequest sets the autoscaler settings of a node pool.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetNodePoolAutoscalingRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the node pool to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "4")]
    pub node_pool_id: ::prost::alloc::string::String,
    /// Required. Autoscaling configuration for the node pool.
    #[prost(message, optional, tag = "5")]
    pub autoscaling: ::core::option::Option<NodePoolAutoscaling>,
    /// The name (project, location, cluster, node pool) of the node pool to set
    /// autoscaler settings. Specified in the format
    /// `projects/*/locations/*/clusters/*/nodePools/*`.
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
}
/// SetLoggingServiceRequest sets the logging service of a cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLoggingServiceRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Required. The logging service the cluster should use to write logs.
    /// Currently available options:
    ///
    /// * `logging.googleapis.com/kubernetes` - The Cloud Logging
    /// service with a Kubernetes-native resource model
    /// * `logging.googleapis.com` - The legacy Cloud Logging service (no longer
    ///    available as of GKE 1.15).
    /// * `none` - no logs will be exported from the cluster.
    ///
    /// If left as an empty string,`logging.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `logging.googleapis.com` for earlier versions.
    #[prost(string, tag = "4")]
    pub logging_service: ::prost::alloc::string::String,
    /// The name (project, location, cluster) of the cluster to set logging.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
}
/// SetMonitoringServiceRequest sets the monitoring service of a cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetMonitoringServiceRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Required. The monitoring service the cluster should use to write metrics.
    /// Currently available options:
    ///
    /// * "monitoring.googleapis.com/kubernetes" - The Cloud Monitoring
    /// service with a Kubernetes-native resource model
    /// * `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no
    ///    longer available as of GKE 1.15).
    /// * `none` - No metrics will be exported from the cluster.
    ///
    /// If left as an empty string,`monitoring.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `monitoring.googleapis.com` for earlier versions.
    #[prost(string, tag = "4")]
    pub monitoring_service: ::prost::alloc::string::String,
    /// The name (project, location, cluster) of the cluster to set monitoring.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
}
/// SetAddonsConfigRequest sets the addons associated with the cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAddonsConfigRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Required. The desired configurations for the various addons available to
    /// run in the cluster.
    #[prost(message, optional, tag = "4")]
    pub addons_config: ::core::option::Option<AddonsConfig>,
    /// The name (project, location, cluster) of the cluster to set addons.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
}
/// SetLocationsRequest sets the locations of the cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLocationsRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Required. The desired list of Google Compute Engine
    /// [zones](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster's nodes should be located. Changing the locations a cluster is in
    /// will result in nodes being either created or removed from the cluster,
    /// depending on whether locations are being added or removed.
    ///
    /// This list must always include the cluster's primary zone.
    #[prost(string, repeated, tag = "4")]
    pub locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The name (project, location, cluster) of the cluster to set locations.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
}
/// UpdateMasterRequest updates the master of the cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateMasterRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Required. The Kubernetes version to change the master to.
    ///
    /// Users may specify either explicit versions offered by Kubernetes Engine or
    /// version aliases, which have the following behavior:
    ///
    /// - "latest": picks the highest valid Kubernetes version
    /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
    /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
    /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
    /// - "-": picks the default Kubernetes version
    #[prost(string, tag = "4")]
    pub master_version: ::prost::alloc::string::String,
    /// The name (project, location, cluster) of the cluster to update.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
}
/// SetMasterAuthRequest updates the admin password of a cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetMasterAuthRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Required. The exact form of action to be taken on the master auth.
    #[prost(enumeration = "set_master_auth_request::Action", tag = "4")]
    pub action: i32,
    /// Required. A description of the update.
    #[prost(message, optional, tag = "5")]
    pub update: ::core::option::Option<MasterAuth>,
    /// The name (project, location, cluster) of the cluster to set auth.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SetMasterAuthRequest`.
pub mod set_master_auth_request {
    /// Operation type: what type update to perform.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        /// Operation is unknown and will error out.
        Unknown = 0,
        /// Set the password to a user generated value.
        SetPassword = 1,
        /// Generate a new password and set it to that.
        GeneratePassword = 2,
        /// Set the username.  If an empty username is provided, basic authentication
        /// is disabled for the cluster.  If a non-empty username is provided, basic
        /// authentication is enabled, with either a provided password or a generated
        /// one.
        SetUsername = 3,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::SetPassword => "SET_PASSWORD",
                Self::GeneratePassword => "GENERATE_PASSWORD",
                Self::SetUsername => "SET_USERNAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "SET_PASSWORD" => Some(Self::SetPassword),
                "GENERATE_PASSWORD" => Some(Self::GeneratePassword),
                "SET_USERNAME" => Some(Self::SetUsername),
                _ => None,
            }
        }
    }
}
/// DeleteClusterRequest deletes a cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteClusterRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster to delete.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// The name (project, location, cluster) of the cluster to delete.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
}
/// ListClustersRequest lists clusters.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClustersRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the parent field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides, or "-" for all zones. This field has been deprecated and
    /// replaced by the parent field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// The parent (project and location) where the clusters will be listed.
    /// Specified in the format `projects/*/locations/*`.
    /// Location "-" matches all zones and all regions.
    #[prost(string, tag = "4")]
    pub parent: ::prost::alloc::string::String,
}
/// ListClustersResponse is the result of ListClustersRequest.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClustersResponse {
    /// A list of clusters in the project in the specified zone, or
    /// across all ones.
    #[prost(message, repeated, tag = "1")]
    pub clusters: ::prost::alloc::vec::Vec<Cluster>,
    /// If any zones are listed here, the list of clusters returned
    /// may be missing those zones.
    #[prost(string, repeated, tag = "2")]
    pub missing_zones: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// GetOperationRequest gets a single operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOperationRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The server-assigned `name` of the operation.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub operation_id: ::prost::alloc::string::String,
    /// The name (project, location, operation id) of the operation to get.
    /// Specified in the format `projects/*/locations/*/operations/*`.
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
}
/// ListOperationsRequest lists operations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOperationsRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the parent field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) to return
    /// operations for, or `-` for all zones. This field has been deprecated and
    /// replaced by the parent field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// The parent (project and location) where the operations will be listed.
    /// Specified in the format `projects/*/locations/*`.
    /// Location "-" matches all zones and all regions.
    #[prost(string, tag = "4")]
    pub parent: ::prost::alloc::string::String,
}
/// CancelOperationRequest cancels a single operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelOperationRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// operation resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The server-assigned `name` of the operation.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub operation_id: ::prost::alloc::string::String,
    /// The name (project, location, operation id) of the operation to cancel.
    /// Specified in the format `projects/*/locations/*/operations/*`.
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
}
/// ListOperationsResponse is the result of ListOperationsRequest.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOperationsResponse {
    /// A list of operations in the project in the specified zone.
    #[prost(message, repeated, tag = "1")]
    pub operations: ::prost::alloc::vec::Vec<Operation>,
    /// If any zones are listed here, the list of operations returned
    /// may be missing the operations from those zones.
    #[prost(string, repeated, tag = "2")]
    pub missing_zones: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Gets the current Kubernetes Engine service configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServerConfigRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) to return
    /// operations for. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// The name (project and location) of the server config to get,
    /// specified in the format `projects/*/locations/*`.
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
}
/// Kubernetes Engine service configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerConfig {
    /// Version of Kubernetes the service deploys by default.
    #[prost(string, tag = "1")]
    pub default_cluster_version: ::prost::alloc::string::String,
    /// List of valid node upgrade target versions, in descending order.
    #[prost(string, repeated, tag = "3")]
    pub valid_node_versions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Default image type.
    #[prost(string, tag = "4")]
    pub default_image_type: ::prost::alloc::string::String,
    /// List of valid image types.
    #[prost(string, repeated, tag = "5")]
    pub valid_image_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of valid master versions, in descending order.
    #[prost(string, repeated, tag = "6")]
    pub valid_master_versions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of release channel configurations.
    #[prost(message, repeated, tag = "9")]
    pub channels: ::prost::alloc::vec::Vec<server_config::ReleaseChannelConfig>,
}
/// Nested message and enum types in `ServerConfig`.
pub mod server_config {
    /// ReleaseChannelConfig exposes configuration for a release channel.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReleaseChannelConfig {
        /// The release channel this configuration applies to.
        #[prost(enumeration = "super::release_channel::Channel", tag = "1")]
        pub channel: i32,
        /// The default version for newly created clusters on the channel.
        #[prost(string, tag = "2")]
        pub default_version: ::prost::alloc::string::String,
        /// List of valid versions for the channel.
        #[prost(string, repeated, tag = "4")]
        pub valid_versions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// The auto upgrade target version for clusters on the channel.
        #[prost(string, tag = "5")]
        pub upgrade_target_version: ::prost::alloc::string::String,
    }
}
/// CreateNodePoolRequest creates a node pool for a cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNodePoolRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the parent field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the parent
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the parent field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Required. The node pool to create.
    #[prost(message, optional, tag = "4")]
    pub node_pool: ::core::option::Option<NodePool>,
    /// The parent (project, location, cluster name) where the node pool will be
    /// created. Specified in the format
    /// `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "6")]
    pub parent: ::prost::alloc::string::String,
}
/// DeleteNodePoolRequest deletes a node pool for a cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNodePoolRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the node pool to delete.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "4")]
    pub node_pool_id: ::prost::alloc::string::String,
    /// The name (project, location, cluster, node pool id) of the node pool to
    /// delete. Specified in the format
    /// `projects/*/locations/*/clusters/*/nodePools/*`.
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
}
/// ListNodePoolsRequest lists the node pool(s) for a cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodePoolsRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the parent field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the parent
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the parent field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// The parent (project, location, cluster name) where the node pools will be
    /// listed. Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "5")]
    pub parent: ::prost::alloc::string::String,
}
/// GetNodePoolRequest retrieves a node pool for a cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodePoolRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the node pool.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "4")]
    pub node_pool_id: ::prost::alloc::string::String,
    /// The name (project, location, cluster, node pool id) of the node pool to
    /// get. Specified in the format
    /// `projects/*/locations/*/clusters/*/nodePools/*`.
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
}
/// Settings for blue-green upgrade.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlueGreenSettings {
    /// Time needed after draining entire blue pool. After this period, blue pool
    /// will be cleaned up.
    #[prost(message, optional, tag = "2")]
    pub node_pool_soak_duration: ::core::option::Option<::prost_types::Duration>,
    /// The rollout policy controls the general rollout progress of blue-green.
    #[prost(oneof = "blue_green_settings::RolloutPolicy", tags = "1")]
    pub rollout_policy: ::core::option::Option<blue_green_settings::RolloutPolicy>,
}
/// Nested message and enum types in `BlueGreenSettings`.
pub mod blue_green_settings {
    /// Standard rollout policy is the default policy for blue-green.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct StandardRolloutPolicy {
        /// Soak time after each batch gets drained. Default to zero.
        #[prost(message, optional, tag = "3")]
        pub batch_soak_duration: ::core::option::Option<::prost_types::Duration>,
        /// Blue pool size to drain in a batch.
        #[prost(oneof = "standard_rollout_policy::UpdateBatchSize", tags = "1, 2")]
        pub update_batch_size: ::core::option::Option<
            standard_rollout_policy::UpdateBatchSize,
        >,
    }
    /// Nested message and enum types in `StandardRolloutPolicy`.
    pub mod standard_rollout_policy {
        /// Blue pool size to drain in a batch.
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum UpdateBatchSize {
            /// Percentage of the blue pool nodes to drain in a batch.
            /// The range of this field should be (0.0, 1.0].
            #[prost(float, tag = "1")]
            BatchPercentage(f32),
            /// Number of blue nodes to drain in a batch.
            #[prost(int32, tag = "2")]
            BatchNodeCount(i32),
        }
    }
    /// The rollout policy controls the general rollout progress of blue-green.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum RolloutPolicy {
        /// Standard policy for the blue-green upgrade.
        #[prost(message, tag = "1")]
        StandardRolloutPolicy(StandardRolloutPolicy),
    }
}
/// NodePool contains the name and configuration for a cluster's node pool.
/// Node pools are a set of nodes (i.e. VM's), with a common configuration and
/// specification, under the control of the cluster master. They may have a set
/// of Kubernetes labels applied to them, which may be used to reference them
/// during pod scheduling. They may also be resized up or down, to accommodate
/// the workload.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodePool {
    /// The name of the node pool.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The node configuration of the pool.
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<NodeConfig>,
    /// The initial node count for the pool. You must ensure that your
    /// Compute Engine [resource quota](<https://cloud.google.com/compute/quotas>)
    /// is sufficient for this number of instances. You must also have available
    /// firewall and routes quota.
    #[prost(int32, tag = "3")]
    pub initial_node_count: i32,
    /// The list of Google Compute Engine
    /// [zones](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// NodePool's nodes should be located.
    ///
    /// If this value is unspecified during node pool creation, the
    /// [Cluster.Locations](<https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters#Cluster.FIELDS.locations>)
    /// value will be used, instead.
    ///
    /// Warning: changing node pool locations will result in nodes being added
    /// and/or removed.
    #[prost(string, repeated, tag = "13")]
    pub locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Networking configuration for this NodePool. If specified, it overrides the
    /// cluster-level defaults.
    #[prost(message, optional, tag = "14")]
    pub network_config: ::core::option::Option<NodeNetworkConfig>,
    /// Output only. Server-defined URL for the resource.
    #[prost(string, tag = "100")]
    pub self_link: ::prost::alloc::string::String,
    /// The version of Kubernetes running on this NodePool's nodes. If unspecified,
    /// it defaults as described
    /// [here](<https://cloud.google.com/kubernetes-engine/versioning#specifying_node_version>).
    #[prost(string, tag = "101")]
    pub version: ::prost::alloc::string::String,
    /// Output only. The resource URLs of the [managed instance
    /// groups](<https://cloud.google.com/compute/docs/instance-groups/creating-groups-of-managed-instances>)
    /// associated with this node pool.
    /// During the node pool blue-green upgrade operation, the URLs contain both
    /// blue and green resources.
    #[prost(string, repeated, tag = "102")]
    pub instance_group_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The status of the nodes in this pool instance.
    #[prost(enumeration = "node_pool::Status", tag = "103")]
    pub status: i32,
    /// Output only. Deprecated. Use conditions instead.
    /// Additional information about the current status of this
    /// node pool instance, if available.
    #[deprecated]
    #[prost(string, tag = "104")]
    pub status_message: ::prost::alloc::string::String,
    /// Autoscaler configuration for this NodePool. Autoscaler is enabled
    /// only if a valid configuration is present.
    #[prost(message, optional, tag = "4")]
    pub autoscaling: ::core::option::Option<NodePoolAutoscaling>,
    /// NodeManagement configuration for this NodePool.
    #[prost(message, optional, tag = "5")]
    pub management: ::core::option::Option<NodeManagement>,
    /// The constraint on the maximum number of pods that can be run
    /// simultaneously on a node in the node pool.
    #[prost(message, optional, tag = "6")]
    pub max_pods_constraint: ::core::option::Option<MaxPodsConstraint>,
    /// Which conditions caused the current node pool state.
    #[prost(message, repeated, tag = "105")]
    pub conditions: ::prost::alloc::vec::Vec<StatusCondition>,
    /// Output only. The pod CIDR block size per node in this node pool.
    #[prost(int32, tag = "7")]
    pub pod_ipv4_cidr_size: i32,
    /// Upgrade settings control disruption and speed of the upgrade.
    #[prost(message, optional, tag = "107")]
    pub upgrade_settings: ::core::option::Option<node_pool::UpgradeSettings>,
    /// Specifies the node placement policy.
    #[prost(message, optional, tag = "108")]
    pub placement_policy: ::core::option::Option<node_pool::PlacementPolicy>,
    /// Output only. Update info contains relevant information during a node
    /// pool update.
    #[prost(message, optional, tag = "109")]
    pub update_info: ::core::option::Option<node_pool::UpdateInfo>,
    /// This checksum is computed by the server based on the value of node pool
    /// fields, and may be sent on update requests to ensure the client has an
    /// up-to-date value before proceeding.
    #[prost(string, tag = "110")]
    pub etag: ::prost::alloc::string::String,
    /// Specifies the configuration of queued provisioning.
    #[prost(message, optional, tag = "112")]
    pub queued_provisioning: ::core::option::Option<node_pool::QueuedProvisioning>,
    /// Enable best effort provisioning for nodes
    #[prost(message, optional, tag = "113")]
    pub best_effort_provisioning: ::core::option::Option<BestEffortProvisioning>,
}
/// Nested message and enum types in `NodePool`.
pub mod node_pool {
    /// These upgrade settings control the level of parallelism and the level of
    /// disruption caused by an upgrade.
    ///
    /// maxUnavailable controls the number of nodes that can be simultaneously
    /// unavailable.
    ///
    /// maxSurge controls the number of additional nodes that can be added to the
    /// node pool temporarily for the time of the upgrade to increase the number of
    /// available nodes.
    ///
    /// (maxUnavailable + maxSurge) determines the level of parallelism (how many
    /// nodes are being upgraded at the same time).
    ///
    /// Note: upgrades inevitably introduce some disruption since workloads need to
    /// be moved from old nodes to new, upgraded ones. Even if maxUnavailable=0,
    /// this holds true. (Disruption stays within the limits of
    /// PodDisruptionBudget, if it is configured.)
    ///
    /// Consider a hypothetical node pool with 5 nodes having maxSurge=2,
    /// maxUnavailable=1. This means the upgrade process upgrades 3 nodes
    /// simultaneously. It creates 2 additional (upgraded) nodes, then it brings
    /// down 3 old (not yet upgraded) nodes at the same time. This ensures that
    /// there are always at least 4 nodes available.
    ///
    /// These upgrade settings configure the upgrade strategy for the node pool.
    /// Use strategy to switch between the strategies applied to the node pool.
    ///
    /// If the strategy is ROLLING, use max_surge and max_unavailable to control
    /// the level of parallelism and the level of disruption caused by upgrade.
    /// 1. maxSurge controls the number of additional nodes that can be added to
    /// the node pool temporarily for the time of the upgrade to increase the
    /// number of available nodes.
    /// 2. maxUnavailable controls the number of nodes that can be simultaneously
    /// unavailable.
    /// 3. (maxUnavailable + maxSurge) determines the level of parallelism (how
    /// many nodes are being upgraded at the same time).
    ///
    /// If the strategy is BLUE_GREEN, use blue_green_settings to configure the
    /// blue-green upgrade related settings.
    /// 1. standard_rollout_policy is the default policy. The policy is used to
    /// control the way blue pool gets drained. The draining is executed in the
    /// batch mode. The batch size could be specified as either percentage of the
    /// node pool size or the number of nodes. batch_soak_duration is the soak
    /// time after each batch gets drained.
    /// 2. node_pool_soak_duration is the soak time after all blue nodes are
    /// drained. After this period, the blue pool nodes will be deleted.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpgradeSettings {
        /// The maximum number of nodes that can be created beyond the current size
        /// of the node pool during the upgrade process.
        #[prost(int32, tag = "1")]
        pub max_surge: i32,
        /// The maximum number of nodes that can be simultaneously unavailable during
        /// the upgrade process. A node is considered available if its status is
        /// Ready.
        #[prost(int32, tag = "2")]
        pub max_unavailable: i32,
        /// Update strategy of the node pool.
        #[prost(enumeration = "super::NodePoolUpdateStrategy", optional, tag = "3")]
        pub strategy: ::core::option::Option<i32>,
        /// Settings for blue-green upgrade strategy.
        #[prost(message, optional, tag = "4")]
        pub blue_green_settings: ::core::option::Option<super::BlueGreenSettings>,
    }
    /// UpdateInfo contains resource (instance groups, etc), status and other
    /// intermediate information relevant to a node pool upgrade.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpdateInfo {
        /// Information of a blue-green upgrade.
        #[prost(message, optional, tag = "1")]
        pub blue_green_info: ::core::option::Option<update_info::BlueGreenInfo>,
    }
    /// Nested message and enum types in `UpdateInfo`.
    pub mod update_info {
        /// Information relevant to blue-green upgrade.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BlueGreenInfo {
            /// Current blue-green upgrade phase.
            #[prost(enumeration = "blue_green_info::Phase", tag = "1")]
            pub phase: i32,
            /// The resource URLs of the \[managed instance groups\]
            /// (/compute/docs/instance-groups/creating-groups-of-managed-instances)
            /// associated with blue pool.
            #[prost(string, repeated, tag = "2")]
            pub blue_instance_group_urls: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            /// The resource URLs of the \[managed instance groups\]
            /// (/compute/docs/instance-groups/creating-groups-of-managed-instances)
            /// associated with green pool.
            #[prost(string, repeated, tag = "3")]
            pub green_instance_group_urls: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            /// Time to start deleting blue pool to complete blue-green upgrade,
            /// in [RFC3339](<https://www.ietf.org/rfc/rfc3339.txt>) text format.
            #[prost(string, tag = "4")]
            pub blue_pool_deletion_start_time: ::prost::alloc::string::String,
            /// Version of green pool.
            #[prost(string, tag = "5")]
            pub green_pool_version: ::prost::alloc::string::String,
        }
        /// Nested message and enum types in `BlueGreenInfo`.
        pub mod blue_green_info {
            /// Phase represents the different stages blue-green upgrade is running in.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Phase {
                /// Unspecified phase.
                Unspecified = 0,
                /// blue-green upgrade has been initiated.
                UpdateStarted = 1,
                /// Start creating green pool nodes.
                CreatingGreenPool = 2,
                /// Start cordoning blue pool nodes.
                CordoningBluePool = 3,
                /// Start draining blue pool nodes.
                DrainingBluePool = 4,
                /// Start soaking time after draining entire blue pool.
                NodePoolSoaking = 5,
                /// Start deleting blue nodes.
                DeletingBluePool = 6,
                /// Rollback has been initiated.
                RollbackStarted = 7,
            }
            impl Phase {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "PHASE_UNSPECIFIED",
                        Self::UpdateStarted => "UPDATE_STARTED",
                        Self::CreatingGreenPool => "CREATING_GREEN_POOL",
                        Self::CordoningBluePool => "CORDONING_BLUE_POOL",
                        Self::DrainingBluePool => "DRAINING_BLUE_POOL",
                        Self::NodePoolSoaking => "NODE_POOL_SOAKING",
                        Self::DeletingBluePool => "DELETING_BLUE_POOL",
                        Self::RollbackStarted => "ROLLBACK_STARTED",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "PHASE_UNSPECIFIED" => Some(Self::Unspecified),
                        "UPDATE_STARTED" => Some(Self::UpdateStarted),
                        "CREATING_GREEN_POOL" => Some(Self::CreatingGreenPool),
                        "CORDONING_BLUE_POOL" => Some(Self::CordoningBluePool),
                        "DRAINING_BLUE_POOL" => Some(Self::DrainingBluePool),
                        "NODE_POOL_SOAKING" => Some(Self::NodePoolSoaking),
                        "DELETING_BLUE_POOL" => Some(Self::DeletingBluePool),
                        "ROLLBACK_STARTED" => Some(Self::RollbackStarted),
                        _ => None,
                    }
                }
            }
        }
    }
    /// PlacementPolicy defines the placement policy used by the node pool.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PlacementPolicy {
        /// The type of placement.
        #[prost(enumeration = "placement_policy::Type", tag = "1")]
        pub r#type: i32,
        /// Optional. TPU placement topology for pod slice node pool.
        /// <https://cloud.google.com/tpu/docs/types-topologies#tpu_topologies>
        #[prost(string, tag = "2")]
        pub tpu_topology: ::prost::alloc::string::String,
        /// If set, refers to the name of a custom resource policy supplied by the
        /// user. The resource policy must be in the same project and region as the
        /// node pool. If not found, InvalidArgument error is returned.
        #[prost(string, tag = "3")]
        pub policy_name: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `PlacementPolicy`.
    pub mod placement_policy {
        /// Type defines the type of placement policy.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            /// TYPE_UNSPECIFIED specifies no requirements on nodes
            /// placement.
            Unspecified = 0,
            /// COMPACT specifies node placement in the same availability domain to
            /// ensure low communication latency.
            Compact = 1,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TYPE_UNSPECIFIED",
                    Self::Compact => "COMPACT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "COMPACT" => Some(Self::Compact),
                    _ => None,
                }
            }
        }
    }
    /// QueuedProvisioning defines the queued provisioning used by the node pool.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct QueuedProvisioning {
        /// Denotes that this nodepool is QRM specific, meaning nodes can be only
        /// obtained through queuing via the Cluster Autoscaler ProvisioningRequest
        /// API.
        #[prost(bool, tag = "1")]
        pub enabled: bool,
    }
    /// The current status of the node pool instance.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Not set.
        Unspecified = 0,
        /// The PROVISIONING state indicates the node pool is being created.
        Provisioning = 1,
        /// The RUNNING state indicates the node pool has been created
        /// and is fully usable.
        Running = 2,
        /// The RUNNING_WITH_ERROR state indicates the node pool has been created
        /// and is partially usable. Some error state has occurred and some
        /// functionality may be impaired. Customer may need to reissue a request
        /// or trigger a new update.
        RunningWithError = 3,
        /// The RECONCILING state indicates that some work is actively being done on
        /// the node pool, such as upgrading node software. Details can
        /// be found in the `statusMessage` field.
        Reconciling = 4,
        /// The STOPPING state indicates the node pool is being deleted.
        Stopping = 5,
        /// The ERROR state indicates the node pool may be unusable. Details
        /// can be found in the `statusMessage` field.
        Error = 6,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATUS_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Running => "RUNNING",
                Self::RunningWithError => "RUNNING_WITH_ERROR",
                Self::Reconciling => "RECONCILING",
                Self::Stopping => "STOPPING",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "RUNNING" => Some(Self::Running),
                "RUNNING_WITH_ERROR" => Some(Self::RunningWithError),
                "RECONCILING" => Some(Self::Reconciling),
                "STOPPING" => Some(Self::Stopping),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
/// NodeManagement defines the set of node management services turned on for the
/// node pool.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeManagement {
    /// A flag that specifies whether node auto-upgrade is enabled for the node
    /// pool. If enabled, node auto-upgrade helps keep the nodes in your node pool
    /// up to date with the latest release version of Kubernetes.
    #[prost(bool, tag = "1")]
    pub auto_upgrade: bool,
    /// A flag that specifies whether the node auto-repair is enabled for the node
    /// pool. If enabled, the nodes in this node pool will be monitored and, if
    /// they fail health checks too many times, an automatic repair action will be
    /// triggered.
    #[prost(bool, tag = "2")]
    pub auto_repair: bool,
    /// Specifies the Auto Upgrade knobs for the node pool.
    #[prost(message, optional, tag = "10")]
    pub upgrade_options: ::core::option::Option<AutoUpgradeOptions>,
}
/// Best effort provisioning.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BestEffortProvisioning {
    /// When this is enabled, cluster/node pool creations will ignore non-fatal
    /// errors like stockout to best provision as many nodes as possible right now
    /// and eventually bring up all target number of nodes
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Minimum number of nodes to be provisioned to be considered as succeeded,
    /// and the rest of nodes will be provisioned gradually and eventually when
    /// stockout issue has been resolved.
    #[prost(int32, tag = "2")]
    pub min_provision_nodes: i32,
}
/// AutoUpgradeOptions defines the set of options for the user to control how
/// the Auto Upgrades will proceed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoUpgradeOptions {
    /// Output only. This field is set when upgrades are about to commence
    /// with the approximate start time for the upgrades, in
    /// [RFC3339](<https://www.ietf.org/rfc/rfc3339.txt>) text format.
    #[prost(string, tag = "1")]
    pub auto_upgrade_start_time: ::prost::alloc::string::String,
    /// Output only. This field is set when upgrades are about to commence
    /// with the description of the upgrade.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
}
/// MaintenancePolicy defines the maintenance policy to be used for the cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaintenancePolicy {
    /// Specifies the maintenance window in which maintenance may be performed.
    #[prost(message, optional, tag = "1")]
    pub window: ::core::option::Option<MaintenanceWindow>,
    /// A hash identifying the version of this policy, so that updates to fields of
    /// the policy won't accidentally undo intermediate changes (and so that users
    /// of the API unaware of some fields won't accidentally remove other fields).
    /// Make a `get()` request to the cluster to get the current
    /// resource version and include it with requests to set the policy.
    #[prost(string, tag = "3")]
    pub resource_version: ::prost::alloc::string::String,
}
/// MaintenanceWindow defines the maintenance window to be used for the cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaintenanceWindow {
    /// Exceptions to maintenance window. Non-emergency maintenance should not
    /// occur in these windows.
    #[prost(map = "string, message", tag = "4")]
    pub maintenance_exclusions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        TimeWindow,
    >,
    #[prost(oneof = "maintenance_window::Policy", tags = "2, 3")]
    pub policy: ::core::option::Option<maintenance_window::Policy>,
}
/// Nested message and enum types in `MaintenanceWindow`.
pub mod maintenance_window {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Policy {
        /// DailyMaintenanceWindow specifies a daily maintenance operation window.
        #[prost(message, tag = "2")]
        DailyMaintenanceWindow(super::DailyMaintenanceWindow),
        /// RecurringWindow specifies some number of recurring time periods for
        /// maintenance to occur. The time windows may be overlapping. If no
        /// maintenance windows are set, maintenance can occur at any time.
        #[prost(message, tag = "3")]
        RecurringWindow(super::RecurringTimeWindow),
    }
}
/// Represents an arbitrary window of time.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeWindow {
    /// The time that the window first starts.
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time that the window ends. The end time should take place after the
    /// start time.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "time_window::Options", tags = "3")]
    pub options: ::core::option::Option<time_window::Options>,
}
/// Nested message and enum types in `TimeWindow`.
pub mod time_window {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Options {
        /// MaintenanceExclusionOptions provides maintenance exclusion related
        /// options.
        #[prost(message, tag = "3")]
        MaintenanceExclusionOptions(super::MaintenanceExclusionOptions),
    }
}
/// Represents the Maintenance exclusion option.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaintenanceExclusionOptions {
    /// Scope specifies the upgrade scope which upgrades are blocked by the
    /// exclusion.
    #[prost(enumeration = "maintenance_exclusion_options::Scope", tag = "1")]
    pub scope: i32,
}
/// Nested message and enum types in `MaintenanceExclusionOptions`.
pub mod maintenance_exclusion_options {
    /// Scope of exclusion.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Scope {
        /// NO_UPGRADES excludes all upgrades, including patch upgrades and minor
        /// upgrades across control planes and nodes. This is the default exclusion
        /// behavior.
        NoUpgrades = 0,
        /// NO_MINOR_UPGRADES excludes all minor upgrades for the cluster, only
        /// patches are allowed.
        NoMinorUpgrades = 1,
        /// NO_MINOR_OR_NODE_UPGRADES excludes all minor upgrades for the cluster,
        /// and also exclude all node pool upgrades. Only control
        /// plane patches are allowed.
        NoMinorOrNodeUpgrades = 2,
    }
    impl Scope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::NoUpgrades => "NO_UPGRADES",
                Self::NoMinorUpgrades => "NO_MINOR_UPGRADES",
                Self::NoMinorOrNodeUpgrades => "NO_MINOR_OR_NODE_UPGRADES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NO_UPGRADES" => Some(Self::NoUpgrades),
                "NO_MINOR_UPGRADES" => Some(Self::NoMinorUpgrades),
                "NO_MINOR_OR_NODE_UPGRADES" => Some(Self::NoMinorOrNodeUpgrades),
                _ => None,
            }
        }
    }
}
/// Represents an arbitrary window of time that recurs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecurringTimeWindow {
    /// The window of the first recurrence.
    #[prost(message, optional, tag = "1")]
    pub window: ::core::option::Option<TimeWindow>,
    /// An RRULE (<https://tools.ietf.org/html/rfc5545#section-3.8.5.3>) for how
    /// this window reccurs. They go on for the span of time between the start and
    /// end time.
    ///
    /// For example, to have something repeat every weekday, you'd use:
    /// `FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR`
    ///
    /// To repeat some window daily (equivalent to the DailyMaintenanceWindow):
    /// `FREQ=DAILY`
    ///
    /// For the first weekend of every month:
    /// `FREQ=MONTHLY;BYSETPOS=1;BYDAY=SA,SU`
    ///
    /// This specifies how frequently the window starts. Eg, if you wanted to have
    /// a 9-5 UTC-4 window every weekday, you'd use something like:
    /// ```
    /// start time = 2019-01-01T09:00:00-0400
    /// end time = 2019-01-01T17:00:00-0400
    /// recurrence = FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR
    /// ```
    ///
    /// Windows can span multiple days. Eg, to make the window encompass every
    /// weekend from midnight Saturday till the last minute of Sunday UTC:
    /// ```
    /// start time = 2019-01-05T00:00:00Z
    /// end time = 2019-01-07T23:59:00Z
    /// recurrence = FREQ=WEEKLY;BYDAY=SA
    /// ```
    ///
    /// Note the start and end time's specific dates are largely arbitrary except
    /// to specify duration of the window and when it first starts.
    /// The FREQ values of HOURLY, MINUTELY, and SECONDLY are not supported.
    #[prost(string, tag = "2")]
    pub recurrence: ::prost::alloc::string::String,
}
/// Time window specified for daily maintenance operations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DailyMaintenanceWindow {
    /// Time within the maintenance window to start the maintenance operations.
    /// Time format should be in [RFC3339](<https://www.ietf.org/rfc/rfc3339.txt>)
    /// format "HH:MM", where HH : \[00-23\] and MM : \[00-59\] GMT.
    #[prost(string, tag = "2")]
    pub start_time: ::prost::alloc::string::String,
    /// Output only. Duration of the time window, automatically chosen to be
    /// smallest possible in the given scenario.
    /// Duration will be in [RFC3339](<https://www.ietf.org/rfc/rfc3339.txt>)
    /// format "PTnHnMnS".
    #[prost(string, tag = "3")]
    pub duration: ::prost::alloc::string::String,
}
/// SetNodePoolManagementRequest sets the node management properties of a node
/// pool.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetNodePoolManagementRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster to update.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the node pool to update.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "4")]
    pub node_pool_id: ::prost::alloc::string::String,
    /// Required. NodeManagement configuration for the node pool.
    #[prost(message, optional, tag = "5")]
    pub management: ::core::option::Option<NodeManagement>,
    /// The name (project, location, cluster, node pool id) of the node pool to set
    /// management properties. Specified in the format
    /// `projects/*/locations/*/clusters/*/nodePools/*`.
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
}
/// SetNodePoolSizeRequest sets the size of a node pool.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetNodePoolSizeRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster to update.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the node pool to update.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "4")]
    pub node_pool_id: ::prost::alloc::string::String,
    /// Required. The desired node count for the pool.
    #[prost(int32, tag = "5")]
    pub node_count: i32,
    /// The name (project, location, cluster, node pool id) of the node pool to set
    /// size.
    /// Specified in the format `projects/*/locations/*/clusters/*/nodePools/*`.
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
}
/// CompleteNodePoolUpgradeRequest sets the name of target node pool to complete
/// upgrade.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteNodePoolUpgradeRequest {
    /// The name (project, location, cluster, node pool id) of the node pool to
    /// complete upgrade.
    /// Specified in the format `projects/*/locations/*/clusters/*/nodePools/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// RollbackNodePoolUpgradeRequest rollbacks the previously Aborted or Failed
/// NodePool upgrade. This will be an no-op if the last upgrade successfully
/// completed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackNodePoolUpgradeRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster to rollback.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the node pool to rollback.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "4")]
    pub node_pool_id: ::prost::alloc::string::String,
    /// The name (project, location, cluster, node pool id) of the node poll to
    /// rollback upgrade.
    /// Specified in the format `projects/*/locations/*/clusters/*/nodePools/*`.
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
    /// Option for rollback to ignore the PodDisruptionBudget.
    /// Default value is false.
    #[prost(bool, tag = "7")]
    pub respect_pdb: bool,
}
/// ListNodePoolsResponse is the result of ListNodePoolsRequest.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodePoolsResponse {
    /// A list of node pools for a cluster.
    #[prost(message, repeated, tag = "1")]
    pub node_pools: ::prost::alloc::vec::Vec<NodePool>,
}
/// ClusterAutoscaling contains global, per-cluster information
/// required by Cluster Autoscaler to automatically adjust
/// the size of the cluster and create/delete
/// node pools based on the current needs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterAutoscaling {
    /// Enables automatic node pool creation and deletion.
    #[prost(bool, tag = "1")]
    pub enable_node_autoprovisioning: bool,
    /// Contains global constraints regarding minimum and maximum
    /// amount of resources in the cluster.
    #[prost(message, repeated, tag = "2")]
    pub resource_limits: ::prost::alloc::vec::Vec<ResourceLimit>,
    /// Defines autoscaling behaviour.
    #[prost(enumeration = "cluster_autoscaling::AutoscalingProfile", tag = "3")]
    pub autoscaling_profile: i32,
    /// AutoprovisioningNodePoolDefaults contains defaults for a node pool
    /// created by NAP.
    #[prost(message, optional, tag = "4")]
    pub autoprovisioning_node_pool_defaults: ::core::option::Option<
        AutoprovisioningNodePoolDefaults,
    >,
    /// The list of Google Compute Engine
    /// [zones](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// NodePool's nodes can be created by NAP.
    #[prost(string, repeated, tag = "5")]
    pub autoprovisioning_locations: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `ClusterAutoscaling`.
pub mod cluster_autoscaling {
    /// Defines possible options for autoscaling_profile field.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AutoscalingProfile {
        /// No change to autoscaling configuration.
        ProfileUnspecified = 0,
        /// Prioritize optimizing utilization of resources.
        OptimizeUtilization = 1,
        /// Use default (balanced) autoscaling configuration.
        Balanced = 2,
    }
    impl AutoscalingProfile {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ProfileUnspecified => "PROFILE_UNSPECIFIED",
                Self::OptimizeUtilization => "OPTIMIZE_UTILIZATION",
                Self::Balanced => "BALANCED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROFILE_UNSPECIFIED" => Some(Self::ProfileUnspecified),
                "OPTIMIZE_UTILIZATION" => Some(Self::OptimizeUtilization),
                "BALANCED" => Some(Self::Balanced),
                _ => None,
            }
        }
    }
}
/// AutoprovisioningNodePoolDefaults contains defaults for a node pool created
/// by NAP.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoprovisioningNodePoolDefaults {
    /// Scopes that are used by NAP when creating node pools.
    #[prost(string, repeated, tag = "1")]
    pub oauth_scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The Google Cloud Platform Service Account to be used by the node VMs.
    #[prost(string, tag = "2")]
    pub service_account: ::prost::alloc::string::String,
    /// Specifies the upgrade settings for NAP created node pools
    #[prost(message, optional, tag = "3")]
    pub upgrade_settings: ::core::option::Option<node_pool::UpgradeSettings>,
    /// Specifies the node management options for NAP created node-pools.
    #[prost(message, optional, tag = "4")]
    pub management: ::core::option::Option<NodeManagement>,
    /// Deprecated. Minimum CPU platform to be used for NAP created node pools.
    /// The instance may be scheduled on the specified or newer CPU platform.
    /// Applicable values are the friendly names of CPU platforms, such as
    /// minCpuPlatform: Intel Haswell or
    /// minCpuPlatform: Intel Sandy Bridge. For more
    /// information, read [how to specify min CPU
    /// platform](<https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform>).
    /// This field is deprecated, min_cpu_platform should be specified using
    /// `cloud.google.com/requested-min-cpu-platform` label selector on the pod.
    /// To unset the min cpu platform field pass "automatic"
    /// as field value.
    #[deprecated]
    #[prost(string, tag = "5")]
    pub min_cpu_platform: ::prost::alloc::string::String,
    /// Size of the disk attached to each node, specified in GB.
    /// The smallest allowed disk size is 10GB.
    ///
    /// If unspecified, the default disk size is 100GB.
    #[prost(int32, tag = "6")]
    pub disk_size_gb: i32,
    /// Type of the disk attached to each node (e.g. 'pd-standard', 'pd-ssd' or
    /// 'pd-balanced')
    ///
    /// If unspecified, the default disk type is 'pd-standard'
    #[prost(string, tag = "7")]
    pub disk_type: ::prost::alloc::string::String,
    /// Shielded Instance options.
    #[prost(message, optional, tag = "8")]
    pub shielded_instance_config: ::core::option::Option<ShieldedInstanceConfig>,
    /// The Customer Managed Encryption Key used to encrypt the boot disk attached
    /// to each node in the node pool. This should be of the form
    /// projects/\[KEY_PROJECT_ID\]/locations/\[LOCATION\]/keyRings/\[RING_NAME\]/cryptoKeys/\[KEY_NAME\].
    /// For more information about protecting resources with Cloud KMS Keys please
    /// see:
    /// <https://cloud.google.com/compute/docs/disks/customer-managed-encryption>
    #[prost(string, tag = "9")]
    pub boot_disk_kms_key: ::prost::alloc::string::String,
    /// The image type to use for NAP created node. Please see
    /// <https://cloud.google.com/kubernetes-engine/docs/concepts/node-images> for
    /// available image types.
    #[prost(string, tag = "10")]
    pub image_type: ::prost::alloc::string::String,
    /// Enable or disable Kubelet read only port.
    #[prost(bool, optional, tag = "13")]
    pub insecure_kubelet_readonly_port_enabled: ::core::option::Option<bool>,
}
/// Contains information about amount of some resource in the cluster.
/// For memory, value should be in GB.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceLimit {
    /// Resource name "cpu", "memory" or gpu-specific string.
    #[prost(string, tag = "1")]
    pub resource_type: ::prost::alloc::string::String,
    /// Minimum amount of the resource in the cluster.
    #[prost(int64, tag = "2")]
    pub minimum: i64,
    /// Maximum amount of the resource in the cluster.
    #[prost(int64, tag = "3")]
    pub maximum: i64,
}
/// NodePoolAutoscaling contains information required by cluster autoscaler to
/// adjust the size of the node pool to the current cluster usage.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NodePoolAutoscaling {
    /// Is autoscaling enabled for this node pool.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Minimum number of nodes for one location in the node pool. Must be greater
    /// than or equal to 0 and less than or equal to max_node_count.
    #[prost(int32, tag = "2")]
    pub min_node_count: i32,
    /// Maximum number of nodes for one location in the node pool. Must be >=
    /// min_node_count. There has to be enough quota to scale up the cluster.
    #[prost(int32, tag = "3")]
    pub max_node_count: i32,
    /// Can this node pool be deleted automatically.
    #[prost(bool, tag = "4")]
    pub autoprovisioned: bool,
    /// Location policy used when scaling up a nodepool.
    #[prost(enumeration = "node_pool_autoscaling::LocationPolicy", tag = "5")]
    pub location_policy: i32,
    /// Minimum number of nodes in the node pool. Must be greater than or equal
    /// to 0 and less than or equal to total_max_node_count.
    /// The total_*_node_count fields are mutually exclusive with the *_node_count
    /// fields.
    #[prost(int32, tag = "6")]
    pub total_min_node_count: i32,
    /// Maximum number of nodes in the node pool. Must be greater than or equal to
    /// total_min_node_count. There has to be enough quota to scale up the cluster.
    /// The total_*_node_count fields are mutually exclusive with the *_node_count
    /// fields.
    #[prost(int32, tag = "7")]
    pub total_max_node_count: i32,
}
/// Nested message and enum types in `NodePoolAutoscaling`.
pub mod node_pool_autoscaling {
    /// Location policy specifies how zones are picked when scaling up the
    /// nodepool.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationPolicy {
        /// Not set.
        Unspecified = 0,
        /// BALANCED is a best effort policy that aims to balance the sizes of
        /// different zones.
        Balanced = 1,
        /// ANY policy picks zones that have the highest capacity available.
        Any = 2,
    }
    impl LocationPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LOCATION_POLICY_UNSPECIFIED",
                Self::Balanced => "BALANCED",
                Self::Any => "ANY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOCATION_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "BALANCED" => Some(Self::Balanced),
                "ANY" => Some(Self::Any),
                _ => None,
            }
        }
    }
}
/// SetLabelsRequest sets the Google Cloud Platform labels on a Google Container
/// Engine cluster, which will in turn set them for Google Compute Engine
/// resources used by that cluster
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Required. The labels to set for that cluster.
    #[prost(map = "string, string", tag = "4")]
    pub resource_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. The fingerprint of the previous set of labels for this resource,
    /// used to detect conflicts. The fingerprint is initially generated by
    /// Kubernetes Engine and changes after every request to modify or update
    /// labels. You must always provide an up-to-date fingerprint hash when
    /// updating or changing labels. Make a `get()` request to the
    /// resource to get the latest fingerprint.
    #[prost(string, tag = "5")]
    pub label_fingerprint: ::prost::alloc::string::String,
    /// The name (project, location, cluster name) of the cluster to set labels.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
}
/// SetLegacyAbacRequest enables or disables the ABAC authorization mechanism for
/// a cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLegacyAbacRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster to update.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Required. Whether ABAC authorization will be enabled in the cluster.
    #[prost(bool, tag = "4")]
    pub enabled: bool,
    /// The name (project, location, cluster name) of the cluster to set legacy
    /// abac. Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
}
/// StartIPRotationRequest creates a new IP for the cluster and then performs
/// a node upgrade on each node pool to point to the new IP.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartIpRotationRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// The name (project, location, cluster name) of the cluster to start IP
    /// rotation. Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
    /// Whether to rotate credentials during IP rotation.
    #[prost(bool, tag = "7")]
    pub rotate_credentials: bool,
}
/// CompleteIPRotationRequest moves the cluster master back into single-IP mode.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteIpRotationRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// The name (project, location, cluster name) of the cluster to complete IP
    /// rotation. Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
}
/// AcceleratorConfig represents a Hardware Accelerator request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceleratorConfig {
    /// The number of the accelerator cards exposed to an instance.
    #[prost(int64, tag = "1")]
    pub accelerator_count: i64,
    /// The accelerator type resource name. List of supported accelerators
    /// [here](<https://cloud.google.com/compute/docs/gpus>)
    #[prost(string, tag = "2")]
    pub accelerator_type: ::prost::alloc::string::String,
    /// Size of partitions to create on the GPU. Valid values are described in the
    /// NVIDIA [mig user
    /// guide](<https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning>).
    #[prost(string, tag = "3")]
    pub gpu_partition_size: ::prost::alloc::string::String,
    /// The configuration for GPU sharing options.
    #[prost(message, optional, tag = "5")]
    pub gpu_sharing_config: ::core::option::Option<GpuSharingConfig>,
    /// The configuration for auto installation of GPU driver.
    #[prost(message, optional, tag = "6")]
    pub gpu_driver_installation_config: ::core::option::Option<
        GpuDriverInstallationConfig,
    >,
}
/// GPUSharingConfig represents the GPU sharing configuration for Hardware
/// Accelerators.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GpuSharingConfig {
    /// The max number of containers that can share a physical GPU.
    #[prost(int64, tag = "1")]
    pub max_shared_clients_per_gpu: i64,
    /// The type of GPU sharing strategy to enable on the GPU node.
    #[prost(enumeration = "gpu_sharing_config::GpuSharingStrategy", optional, tag = "2")]
    pub gpu_sharing_strategy: ::core::option::Option<i32>,
}
/// Nested message and enum types in `GPUSharingConfig`.
pub mod gpu_sharing_config {
    /// The type of GPU sharing strategy currently provided.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GpuSharingStrategy {
        /// Default value.
        Unspecified = 0,
        /// GPUs are time-shared between containers.
        TimeSharing = 1,
        /// GPUs are shared between containers with NVIDIA MPS.
        Mps = 2,
    }
    impl GpuSharingStrategy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "GPU_SHARING_STRATEGY_UNSPECIFIED",
                Self::TimeSharing => "TIME_SHARING",
                Self::Mps => "MPS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GPU_SHARING_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
                "TIME_SHARING" => Some(Self::TimeSharing),
                "MPS" => Some(Self::Mps),
                _ => None,
            }
        }
    }
}
/// GPUDriverInstallationConfig specifies the version of GPU driver to be auto
/// installed.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GpuDriverInstallationConfig {
    /// Mode for how the GPU driver is installed.
    #[prost(
        enumeration = "gpu_driver_installation_config::GpuDriverVersion",
        optional,
        tag = "1"
    )]
    pub gpu_driver_version: ::core::option::Option<i32>,
}
/// Nested message and enum types in `GPUDriverInstallationConfig`.
pub mod gpu_driver_installation_config {
    /// The GPU driver version to install.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GpuDriverVersion {
        /// Default value is to not install any GPU driver.
        Unspecified = 0,
        /// Disable GPU driver auto installation and needs manual installation
        InstallationDisabled = 1,
        /// "Default" GPU driver in COS and Ubuntu.
        Default = 2,
        /// "Latest" GPU driver in COS.
        Latest = 3,
    }
    impl GpuDriverVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "GPU_DRIVER_VERSION_UNSPECIFIED",
                Self::InstallationDisabled => "INSTALLATION_DISABLED",
                Self::Default => "DEFAULT",
                Self::Latest => "LATEST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GPU_DRIVER_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
                "INSTALLATION_DISABLED" => Some(Self::InstallationDisabled),
                "DEFAULT" => Some(Self::Default),
                "LATEST" => Some(Self::Latest),
                _ => None,
            }
        }
    }
}
/// WorkloadMetadataConfig defines the metadata configuration to expose to
/// workloads on the node pool.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorkloadMetadataConfig {
    /// Mode is the configuration for how to expose metadata to workloads running
    /// on the node pool.
    #[prost(enumeration = "workload_metadata_config::Mode", tag = "2")]
    pub mode: i32,
}
/// Nested message and enum types in `WorkloadMetadataConfig`.
pub mod workload_metadata_config {
    /// Mode is the configuration for how to expose metadata to workloads running
    /// on the node.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        /// Not set.
        Unspecified = 0,
        /// Expose all Compute Engine metadata to pods.
        GceMetadata = 1,
        /// Run the GKE Metadata Server on this node. The GKE Metadata Server exposes
        /// a metadata API to workloads that is compatible with the V1 Compute
        /// Metadata APIs exposed by the Compute Engine and App Engine Metadata
        /// Servers. This feature can only be enabled if Workload Identity is enabled
        /// at the cluster level.
        GkeMetadata = 2,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODE_UNSPECIFIED",
                Self::GceMetadata => "GCE_METADATA",
                Self::GkeMetadata => "GKE_METADATA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "GCE_METADATA" => Some(Self::GceMetadata),
                "GKE_METADATA" => Some(Self::GkeMetadata),
                _ => None,
            }
        }
    }
}
/// SetNetworkPolicyRequest enables/disables network policy for a cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetNetworkPolicyRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Deprecated. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides. This field has been deprecated and replaced by the name
    /// field.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Required. Configuration options for the NetworkPolicy feature.
    #[prost(message, optional, tag = "4")]
    pub network_policy: ::core::option::Option<NetworkPolicy>,
    /// The name (project, location, cluster name) of the cluster to set networking
    /// policy. Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
}
/// SetMaintenancePolicyRequest sets the maintenance policy for a cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetMaintenancePolicyRequest {
    /// Required. The Google Developers Console [project ID or project
    /// number](<https://cloud.google.com/resource-manager/docs/creating-managing-projects>).
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. The name of the Google Compute Engine
    /// [zone](<https://cloud.google.com/compute/docs/zones#available>) in which the
    /// cluster resides.
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Required. The name of the cluster to update.
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Required. The maintenance policy to be set for the cluster. An empty field
    /// clears the existing maintenance policy.
    #[prost(message, optional, tag = "4")]
    pub maintenance_policy: ::core::option::Option<MaintenancePolicy>,
    /// The name (project, location, cluster name) of the cluster to set
    /// maintenance policy.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
}
/// StatusCondition describes why a cluster or a node pool has a certain status
/// (e.g., ERROR or DEGRADED).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatusCondition {
    /// Machine-friendly representation of the condition
    /// Deprecated. Use canonical_code instead.
    #[deprecated]
    #[prost(enumeration = "status_condition::Code", tag = "1")]
    pub code: i32,
    /// Human-friendly representation of the condition
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Canonical code of the condition.
    #[prost(enumeration = "super::super::rpc::Code", tag = "3")]
    pub canonical_code: i32,
}
/// Nested message and enum types in `StatusCondition`.
pub mod status_condition {
    /// Code for each condition
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Code {
        /// UNKNOWN indicates a generic condition.
        Unknown = 0,
        /// GCE_STOCKOUT indicates that Google Compute Engine resources are
        /// temporarily unavailable.
        GceStockout = 1,
        /// GKE_SERVICE_ACCOUNT_DELETED indicates that the user deleted their robot
        /// service account.
        GkeServiceAccountDeleted = 2,
        /// Google Compute Engine quota was exceeded.
        GceQuotaExceeded = 3,
        /// Cluster state was manually changed by an SRE due to a system logic error.
        SetByOperator = 4,
        /// Unable to perform an encrypt operation against the CloudKMS key used for
        /// etcd level encryption.
        CloudKmsKeyError = 7,
        /// Cluster CA is expiring soon.
        CaExpiring = 9,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::GceStockout => "GCE_STOCKOUT",
                Self::GkeServiceAccountDeleted => "GKE_SERVICE_ACCOUNT_DELETED",
                Self::GceQuotaExceeded => "GCE_QUOTA_EXCEEDED",
                Self::SetByOperator => "SET_BY_OPERATOR",
                Self::CloudKmsKeyError => "CLOUD_KMS_KEY_ERROR",
                Self::CaExpiring => "CA_EXPIRING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "GCE_STOCKOUT" => Some(Self::GceStockout),
                "GKE_SERVICE_ACCOUNT_DELETED" => Some(Self::GkeServiceAccountDeleted),
                "GCE_QUOTA_EXCEEDED" => Some(Self::GceQuotaExceeded),
                "SET_BY_OPERATOR" => Some(Self::SetByOperator),
                "CLOUD_KMS_KEY_ERROR" => Some(Self::CloudKmsKeyError),
                "CA_EXPIRING" => Some(Self::CaExpiring),
                _ => None,
            }
        }
    }
}
/// NetworkConfig reports the relative names of network & subnetwork.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkConfig {
    /// Output only. The relative name of the Google Compute Engine
    /// [network](<https://cloud.google.com/compute/docs/networks-and-firewalls#networks>)
    /// to which the cluster is connected. Example:
    /// projects/my-project/global/networks/my-network
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    /// Output only. The relative name of the Google Compute Engine
    /// [subnetwork](<https://cloud.google.com/compute/docs/vpc>) to which the
    /// cluster is connected. Example:
    /// projects/my-project/regions/us-central1/subnetworks/my-subnet
    #[prost(string, tag = "2")]
    pub subnetwork: ::prost::alloc::string::String,
    /// Whether Intra-node visibility is enabled for this cluster.
    /// This makes same node pod to pod traffic visible for VPC network.
    #[prost(bool, tag = "5")]
    pub enable_intra_node_visibility: bool,
    /// Whether the cluster disables default in-node sNAT rules. In-node sNAT rules
    /// will be disabled when default_snat_status is disabled. When disabled is set
    /// to false, default IP masquerade rules will be applied to the nodes to
    /// prevent sNAT on cluster internal traffic.
    #[prost(message, optional, tag = "7")]
    pub default_snat_status: ::core::option::Option<DefaultSnatStatus>,
    /// Whether L4ILB Subsetting is enabled for this cluster.
    #[prost(bool, tag = "10")]
    pub enable_l4ilb_subsetting: bool,
    /// The desired datapath provider for this cluster. By default, uses the
    /// IPTables-based kube-proxy implementation.
    #[prost(enumeration = "DatapathProvider", tag = "11")]
    pub datapath_provider: i32,
    /// The desired state of IPv6 connectivity to Google Services.
    /// By default, no private IPv6 access to or from Google Services (all access
    /// will be via IPv4)
    #[prost(enumeration = "PrivateIPv6GoogleAccess", tag = "12")]
    pub private_ipv6_google_access: i32,
    /// DNSConfig contains clusterDNS config for this cluster.
    #[prost(message, optional, tag = "13")]
    pub dns_config: ::core::option::Option<DnsConfig>,
    /// ServiceExternalIPsConfig specifies if services with externalIPs field are
    /// blocked or not.
    #[prost(message, optional, tag = "15")]
    pub service_external_ips_config: ::core::option::Option<ServiceExternalIPsConfig>,
    /// GatewayAPIConfig contains the desired config of Gateway API on this
    /// cluster.
    #[prost(message, optional, tag = "16")]
    pub gateway_api_config: ::core::option::Option<GatewayApiConfig>,
    /// Whether multi-networking is enabled for this cluster.
    #[prost(bool, tag = "17")]
    pub enable_multi_networking: bool,
    /// Network bandwidth tier configuration.
    #[prost(message, optional, tag = "18")]
    pub network_performance_config: ::core::option::Option<
        network_config::ClusterNetworkPerformanceConfig,
    >,
    /// Whether FQDN Network Policy is enabled on this cluster.
    #[prost(bool, optional, tag = "19")]
    pub enable_fqdn_network_policy: ::core::option::Option<bool>,
    /// Specify the details of in-transit encryption.
    /// Now named inter-node transparent encryption.
    #[prost(enumeration = "InTransitEncryptionConfig", optional, tag = "20")]
    pub in_transit_encryption_config: ::core::option::Option<i32>,
    /// Whether CiliumClusterwideNetworkPolicy is enabled on this cluster.
    #[prost(bool, optional, tag = "21")]
    pub enable_cilium_clusterwide_network_policy: ::core::option::Option<bool>,
    /// Controls whether by default nodes have private IP addresses only.
    /// It is invalid to specify both [PrivateClusterConfig.enablePrivateNodes][]
    /// and this field at the same time.
    /// To update the default setting, use
    /// [ClusterUpdate.desired_default_enable_private_nodes][google.container.v1.ClusterUpdate.desired_default_enable_private_nodes]
    #[prost(bool, optional, tag = "22")]
    pub default_enable_private_nodes: ::core::option::Option<bool>,
}
/// Nested message and enum types in `NetworkConfig`.
pub mod network_config {
    /// Configuration of network bandwidth tiers
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ClusterNetworkPerformanceConfig {
        /// Specifies the total network bandwidth tier for NodePools in the cluster.
        #[prost(
            enumeration = "cluster_network_performance_config::Tier",
            optional,
            tag = "1"
        )]
        pub total_egress_bandwidth_tier: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `ClusterNetworkPerformanceConfig`.
    pub mod cluster_network_performance_config {
        /// Node network tier
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Tier {
            /// Default value
            Unspecified = 0,
            /// Higher bandwidth, actual values based on VM size.
            Tier1 = 1,
        }
        impl Tier {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TIER_UNSPECIFIED",
                    Self::Tier1 => "TIER_1",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TIER_UNSPECIFIED" => Some(Self::Unspecified),
                    "TIER_1" => Some(Self::Tier1),
                    _ => None,
                }
            }
        }
    }
}
/// GatewayAPIConfig contains the desired config of Gateway API on this cluster.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GatewayApiConfig {
    /// The Gateway API release channel to use for Gateway API.
    #[prost(enumeration = "gateway_api_config::Channel", tag = "1")]
    pub channel: i32,
}
/// Nested message and enum types in `GatewayAPIConfig`.
pub mod gateway_api_config {
    /// Channel describes if/how Gateway API should be installed and implemented in
    /// a cluster.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Channel {
        /// Default value.
        Unspecified = 0,
        /// Gateway API support is disabled
        Disabled = 1,
        /// Deprecated: use CHANNEL_STANDARD instead.
        /// Gateway API support is enabled, experimental CRDs are installed
        Experimental = 3,
        /// Gateway API support is enabled, standard CRDs are installed
        Standard = 4,
    }
    impl Channel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CHANNEL_UNSPECIFIED",
                Self::Disabled => "CHANNEL_DISABLED",
                Self::Experimental => "CHANNEL_EXPERIMENTAL",
                Self::Standard => "CHANNEL_STANDARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHANNEL_UNSPECIFIED" => Some(Self::Unspecified),
                "CHANNEL_DISABLED" => Some(Self::Disabled),
                "CHANNEL_EXPERIMENTAL" => Some(Self::Experimental),
                "CHANNEL_STANDARD" => Some(Self::Standard),
                _ => None,
            }
        }
    }
}
/// Config to block services with externalIPs field.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServiceExternalIPsConfig {
    /// Whether Services with ExternalIPs field are allowed or not.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// GetOpenIDConfigRequest gets the OIDC discovery document for the
/// cluster. See the OpenID Connect Discovery 1.0 specification for details.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOpenIdConfigRequest {
    /// The cluster (project, location, cluster name) to get the discovery document
    /// for. Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// GetOpenIDConfigResponse is an OIDC discovery document for the cluster.
/// See the OpenID Connect Discovery 1.0 specification for details.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOpenIdConfigResponse {
    /// OIDC Issuer.
    #[prost(string, tag = "1")]
    pub issuer: ::prost::alloc::string::String,
    /// JSON Web Key uri.
    #[prost(string, tag = "2")]
    pub jwks_uri: ::prost::alloc::string::String,
    /// Supported response types.
    #[prost(string, repeated, tag = "3")]
    pub response_types_supported: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Supported subject types.
    #[prost(string, repeated, tag = "4")]
    pub subject_types_supported: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// supported ID Token signing Algorithms.
    #[prost(string, repeated, tag = "5")]
    pub id_token_signing_alg_values_supported: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Supported claims.
    #[prost(string, repeated, tag = "6")]
    pub claims_supported: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Supported grant types.
    #[prost(string, repeated, tag = "7")]
    pub grant_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// GetJSONWebKeysRequest gets the public component of the keys used by the
/// cluster to sign token requests. This will be the jwks_uri for the discover
/// document returned by getOpenIDConfig. See the OpenID Connect
/// Discovery 1.0 specification for details.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJsonWebKeysRequest {
    /// The cluster (project, location, cluster name) to get keys for. Specified in
    /// the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// Jwk is a JSON Web Key as specified in RFC 7517
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Jwk {
    /// Key Type.
    #[prost(string, tag = "1")]
    pub kty: ::prost::alloc::string::String,
    /// Algorithm.
    #[prost(string, tag = "2")]
    pub alg: ::prost::alloc::string::String,
    /// Permitted uses for the public keys.
    #[prost(string, tag = "3")]
    pub r#use: ::prost::alloc::string::String,
    /// Key ID.
    #[prost(string, tag = "4")]
    pub kid: ::prost::alloc::string::String,
    /// Used for RSA keys.
    #[prost(string, tag = "5")]
    pub n: ::prost::alloc::string::String,
    /// Used for RSA keys.
    #[prost(string, tag = "6")]
    pub e: ::prost::alloc::string::String,
    /// Used for ECDSA keys.
    #[prost(string, tag = "7")]
    pub x: ::prost::alloc::string::String,
    /// Used for ECDSA keys.
    #[prost(string, tag = "8")]
    pub y: ::prost::alloc::string::String,
    /// Used for ECDSA keys.
    #[prost(string, tag = "9")]
    pub crv: ::prost::alloc::string::String,
}
/// GetJSONWebKeysResponse is a valid JSON Web Key Set as specififed in rfc 7517
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJsonWebKeysResponse {
    /// The public component of the keys used by the cluster to sign token
    /// requests.
    #[prost(message, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<Jwk>,
}
/// CheckAutopilotCompatibilityRequest requests getting the blockers for the
/// given operation in the cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckAutopilotCompatibilityRequest {
    /// The name (project, location, cluster) of the cluster to retrieve.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// AutopilotCompatibilityIssue contains information about a specific
/// compatibility issue with Autopilot mode.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutopilotCompatibilityIssue {
    /// The last time when this issue was observed.
    #[prost(message, optional, tag = "1")]
    pub last_observation: ::core::option::Option<::prost_types::Timestamp>,
    /// The constraint type of the issue.
    #[prost(string, tag = "2")]
    pub constraint_type: ::prost::alloc::string::String,
    /// The incompatibility type of this issue.
    #[prost(enumeration = "autopilot_compatibility_issue::IssueType", tag = "3")]
    pub incompatibility_type: i32,
    /// The name of the resources which are subject to this issue.
    #[prost(string, repeated, tag = "4")]
    pub subjects: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A URL to a public documnetation, which addresses resolving this issue.
    #[prost(string, tag = "5")]
    pub documentation_url: ::prost::alloc::string::String,
    /// The description of the issue.
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AutopilotCompatibilityIssue`.
pub mod autopilot_compatibility_issue {
    /// The type of the reported issue.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IssueType {
        /// Default value, should not be used.
        Unspecified = 0,
        /// Indicates that the issue is a known incompatibility between the
        /// cluster and Autopilot mode.
        Incompatibility = 1,
        /// Indicates the issue is an incompatibility if customers take no further
        /// action to resolve.
        AdditionalConfigRequired = 2,
        /// Indicates the issue is not an incompatibility, but depending on the
        /// workloads business logic, there is a potential that they won't work on
        /// Autopilot.
        PassedWithOptionalConfig = 3,
    }
    impl IssueType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Incompatibility => "INCOMPATIBILITY",
                Self::AdditionalConfigRequired => "ADDITIONAL_CONFIG_REQUIRED",
                Self::PassedWithOptionalConfig => "PASSED_WITH_OPTIONAL_CONFIG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "INCOMPATIBILITY" => Some(Self::Incompatibility),
                "ADDITIONAL_CONFIG_REQUIRED" => Some(Self::AdditionalConfigRequired),
                "PASSED_WITH_OPTIONAL_CONFIG" => Some(Self::PassedWithOptionalConfig),
                _ => None,
            }
        }
    }
}
/// CheckAutopilotCompatibilityResponse has a list of compatibility issues.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckAutopilotCompatibilityResponse {
    /// The list of issues for the given operation.
    #[prost(message, repeated, tag = "1")]
    pub issues: ::prost::alloc::vec::Vec<AutopilotCompatibilityIssue>,
    /// The summary of the autopilot compatibility response.
    #[prost(string, tag = "2")]
    pub summary: ::prost::alloc::string::String,
}
/// ReleaseChannel indicates which release channel a cluster is
/// subscribed to. Release channels are arranged in order of risk.
///
/// When a cluster is subscribed to a release channel, Google maintains
/// both the master version and the node version. Node auto-upgrade
/// defaults to true and cannot be disabled.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReleaseChannel {
    /// channel specifies which release channel the cluster is subscribed to.
    #[prost(enumeration = "release_channel::Channel", tag = "1")]
    pub channel: i32,
}
/// Nested message and enum types in `ReleaseChannel`.
pub mod release_channel {
    /// Possible values for 'channel'.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Channel {
        /// No channel specified.
        Unspecified = 0,
        /// RAPID channel is offered on an early access basis for customers who want
        /// to test new releases.
        ///
        /// WARNING: Versions available in the RAPID Channel may be subject to
        /// unresolved issues with no known workaround and are not subject to any
        /// SLAs.
        Rapid = 1,
        /// Clusters subscribed to REGULAR receive versions that are considered GA
        /// quality. REGULAR is intended for production users who want to take
        /// advantage of new features.
        Regular = 2,
        /// Clusters subscribed to STABLE receive versions that are known to be
        /// stable and reliable in production.
        Stable = 3,
        /// Clusters subscribed to EXTENDED receive extended support and availability
        /// for versions which are known to be stable and reliable in production.
        Extended = 4,
    }
    impl Channel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Rapid => "RAPID",
                Self::Regular => "REGULAR",
                Self::Stable => "STABLE",
                Self::Extended => "EXTENDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "RAPID" => Some(Self::Rapid),
                "REGULAR" => Some(Self::Regular),
                "STABLE" => Some(Self::Stable),
                "EXTENDED" => Some(Self::Extended),
                _ => None,
            }
        }
    }
}
/// Configuration for fine-grained cost management feature.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CostManagementConfig {
    /// Whether the feature is enabled or not.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// IntraNodeVisibilityConfig contains the desired config of the intra-node
/// visibility on this cluster.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IntraNodeVisibilityConfig {
    /// Enables intra node visibility for this cluster.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// ILBSubsettingConfig contains the desired config of L4 Internal LoadBalancer
/// subsetting on this cluster.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IlbSubsettingConfig {
    /// Enables l4 ILB subsetting for this cluster.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// DNSConfig contains the desired set of options for configuring clusterDNS.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DnsConfig {
    /// cluster_dns indicates which in-cluster DNS provider should be used.
    #[prost(enumeration = "dns_config::Provider", tag = "1")]
    pub cluster_dns: i32,
    /// cluster_dns_scope indicates the scope of access to cluster DNS records.
    #[prost(enumeration = "dns_config::DnsScope", tag = "2")]
    pub cluster_dns_scope: i32,
    /// cluster_dns_domain is the suffix used for all cluster service records.
    #[prost(string, tag = "3")]
    pub cluster_dns_domain: ::prost::alloc::string::String,
    /// Optional. The domain used in Additive VPC scope.
    #[prost(string, tag = "5")]
    pub additive_vpc_scope_dns_domain: ::prost::alloc::string::String,
}
/// Nested message and enum types in `DNSConfig`.
pub mod dns_config {
    /// Provider lists the various in-cluster DNS providers.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Provider {
        /// Default value
        Unspecified = 0,
        /// Use GKE default DNS provider(kube-dns) for DNS resolution.
        PlatformDefault = 1,
        /// Use CloudDNS for DNS resolution.
        CloudDns = 2,
        /// Use KubeDNS for DNS resolution.
        KubeDns = 3,
    }
    impl Provider {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROVIDER_UNSPECIFIED",
                Self::PlatformDefault => "PLATFORM_DEFAULT",
                Self::CloudDns => "CLOUD_DNS",
                Self::KubeDns => "KUBE_DNS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROVIDER_UNSPECIFIED" => Some(Self::Unspecified),
                "PLATFORM_DEFAULT" => Some(Self::PlatformDefault),
                "CLOUD_DNS" => Some(Self::CloudDns),
                "KUBE_DNS" => Some(Self::KubeDns),
                _ => None,
            }
        }
    }
    /// DNSScope lists the various scopes of access to cluster DNS records.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DnsScope {
        /// Default value, will be inferred as cluster scope.
        Unspecified = 0,
        /// DNS records are accessible from within the cluster.
        ClusterScope = 1,
        /// DNS records are accessible from within the VPC.
        VpcScope = 2,
    }
    impl DnsScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DNS_SCOPE_UNSPECIFIED",
                Self::ClusterScope => "CLUSTER_SCOPE",
                Self::VpcScope => "VPC_SCOPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DNS_SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLUSTER_SCOPE" => Some(Self::ClusterScope),
                "VPC_SCOPE" => Some(Self::VpcScope),
                _ => None,
            }
        }
    }
}
/// Constraints applied to pods.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaxPodsConstraint {
    /// Constraint enforced on the max num of pods per node.
    #[prost(int64, tag = "1")]
    pub max_pods_per_node: i64,
}
/// Configuration for the use of Kubernetes Service Accounts in GCP IAM
/// policies.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkloadIdentityConfig {
    /// The workload pool to attach all Kubernetes service accounts to.
    #[prost(string, tag = "2")]
    pub workload_pool: ::prost::alloc::string::String,
}
/// IdentityServiceConfig is configuration for Identity Service which allows
/// customers to use external identity providers with the K8S API
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IdentityServiceConfig {
    /// Whether to enable the Identity Service component
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// Configuration for issuance of mTLS keys and certificates to Kubernetes pods.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MeshCertificates {
    /// enable_certificates controls issuance of workload mTLS certificates.
    ///
    /// If set, the GKE Workload Identity Certificates controller and node agent
    /// will be deployed in the cluster, which can then be configured by creating a
    /// WorkloadCertificateConfig Custom Resource.
    ///
    /// Requires Workload Identity
    /// ([workload_pool][google.container.v1.WorkloadIdentityConfig.workload_pool]
    /// must be non-empty).
    #[prost(message, optional, tag = "1")]
    pub enable_certificates: ::core::option::Option<bool>,
}
/// Configuration of etcd encryption.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseEncryption {
    /// Name of CloudKMS key to use for the encryption of secrets in etcd.
    /// Ex. projects/my-project/locations/global/keyRings/my-ring/cryptoKeys/my-key
    #[prost(string, tag = "1")]
    pub key_name: ::prost::alloc::string::String,
    /// The desired state of etcd encryption.
    #[prost(enumeration = "database_encryption::State", tag = "2")]
    pub state: i32,
    /// Output only. The current state of etcd encryption.
    #[prost(enumeration = "database_encryption::CurrentState", optional, tag = "3")]
    pub current_state: ::core::option::Option<i32>,
    /// Output only. Keys in use by the cluster for decrypting
    /// existing objects, in addition to the key in `key_name`.
    ///
    /// Each item is a CloudKMS key resource.
    #[prost(string, repeated, tag = "4")]
    pub decryption_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. Records errors seen during DatabaseEncryption update
    /// operations.
    #[prost(message, repeated, tag = "5")]
    pub last_operation_errors: ::prost::alloc::vec::Vec<
        database_encryption::OperationError,
    >,
}
/// Nested message and enum types in `DatabaseEncryption`.
pub mod database_encryption {
    /// OperationError records errors seen from CloudKMS keys
    /// encountered during updates to DatabaseEncryption configuration.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OperationError {
        /// CloudKMS key resource that had the error.
        #[prost(string, tag = "1")]
        pub key_name: ::prost::alloc::string::String,
        /// Description of the error seen during the operation.
        #[prost(string, tag = "2")]
        pub error_message: ::prost::alloc::string::String,
        /// Time when the CloudKMS error was seen.
        #[prost(message, optional, tag = "3")]
        pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// State of etcd encryption.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Should never be set
        Unknown = 0,
        /// Secrets in etcd are encrypted.
        Encrypted = 1,
        /// Secrets in etcd are stored in plain text (at etcd level) - this is
        /// unrelated to Compute Engine level full disk encryption.
        Decrypted = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Encrypted => "ENCRYPTED",
                Self::Decrypted => "DECRYPTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "ENCRYPTED" => Some(Self::Encrypted),
                "DECRYPTED" => Some(Self::Decrypted),
                _ => None,
            }
        }
    }
    /// Current State of etcd encryption.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CurrentState {
        /// Should never be set
        Unspecified = 0,
        /// Secrets in etcd are encrypted.
        Encrypted = 7,
        /// Secrets in etcd are stored in plain text (at etcd level) - this is
        /// unrelated to Compute Engine level full disk encryption.
        Decrypted = 2,
        /// Encryption (or re-encryption with a different CloudKMS key)
        /// of Secrets is in progress.
        EncryptionPending = 3,
        /// Encryption (or re-encryption with a different CloudKMS key) of Secrets in
        /// etcd encountered an error.
        EncryptionError = 4,
        /// De-crypting Secrets to plain text in etcd is in progress.
        DecryptionPending = 5,
        /// De-crypting Secrets to plain text in etcd encountered an error.
        DecryptionError = 6,
    }
    impl CurrentState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CURRENT_STATE_UNSPECIFIED",
                Self::Encrypted => "CURRENT_STATE_ENCRYPTED",
                Self::Decrypted => "CURRENT_STATE_DECRYPTED",
                Self::EncryptionPending => "CURRENT_STATE_ENCRYPTION_PENDING",
                Self::EncryptionError => "CURRENT_STATE_ENCRYPTION_ERROR",
                Self::DecryptionPending => "CURRENT_STATE_DECRYPTION_PENDING",
                Self::DecryptionError => "CURRENT_STATE_DECRYPTION_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CURRENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CURRENT_STATE_ENCRYPTED" => Some(Self::Encrypted),
                "CURRENT_STATE_DECRYPTED" => Some(Self::Decrypted),
                "CURRENT_STATE_ENCRYPTION_PENDING" => Some(Self::EncryptionPending),
                "CURRENT_STATE_ENCRYPTION_ERROR" => Some(Self::EncryptionError),
                "CURRENT_STATE_DECRYPTION_PENDING" => Some(Self::DecryptionPending),
                "CURRENT_STATE_DECRYPTION_ERROR" => Some(Self::DecryptionError),
                _ => None,
            }
        }
    }
}
/// ListUsableSubnetworksRequest requests the list of usable subnetworks
/// available to a user for creating clusters.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUsableSubnetworksRequest {
    /// The parent project where subnetworks are usable.
    /// Specified in the format `projects/*`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Filtering currently only supports equality on the networkProjectId and must
    /// be in the form: "networkProjectId=\[PROJECTID\]", where `networkProjectId`
    /// is the project which owns the listed subnetworks. This defaults to the
    /// parent project ID.
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// The max number of results per page that should be returned. If the number
    /// of available results is larger than `page_size`, a `next_page_token` is
    /// returned which can be used to get the next page of results in subsequent
    /// requests. Acceptable values are 0 to 500, inclusive. (Default: 500)
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Specifies a page token to use. Set this to the nextPageToken returned by
    /// previous list requests to get the next page of results.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// ListUsableSubnetworksResponse is the response of
/// ListUsableSubnetworksRequest.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUsableSubnetworksResponse {
    /// A list of usable subnetworks in the specified network project.
    #[prost(message, repeated, tag = "1")]
    pub subnetworks: ::prost::alloc::vec::Vec<UsableSubnetwork>,
    /// This token allows you to get the next page of results for list requests.
    /// If the number of results is larger than `page_size`, use the
    /// `next_page_token` as a value for the query parameter `page_token` in the
    /// next request. The value will become empty when there are no more pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Secondary IP range of a usable subnetwork.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsableSubnetworkSecondaryRange {
    /// The name associated with this subnetwork secondary range, used when adding
    /// an alias IP range to a VM instance.
    #[prost(string, tag = "1")]
    pub range_name: ::prost::alloc::string::String,
    /// The range of IP addresses belonging to this subnetwork secondary range.
    #[prost(string, tag = "2")]
    pub ip_cidr_range: ::prost::alloc::string::String,
    /// This field is to determine the status of the secondary range programmably.
    #[prost(enumeration = "usable_subnetwork_secondary_range::Status", tag = "3")]
    pub status: i32,
}
/// Nested message and enum types in `UsableSubnetworkSecondaryRange`.
pub mod usable_subnetwork_secondary_range {
    /// Status shows the current usage of a secondary IP range.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// UNKNOWN is the zero value of the Status enum. It's not a valid status.
        Unknown = 0,
        /// UNUSED denotes that this range is unclaimed by any cluster.
        Unused = 1,
        /// IN_USE_SERVICE denotes that this range is claimed by cluster(s) for
        /// services. User-managed services range can be shared between clusters
        /// within the same subnetwork.
        InUseService = 2,
        /// IN_USE_SHAREABLE_POD denotes this range was created by the network admin
        /// and is currently claimed by a cluster for pods. It can only be used by
        /// other clusters as a pod range.
        InUseShareablePod = 3,
        /// IN_USE_MANAGED_POD denotes this range was created by GKE and is claimed
        /// for pods. It cannot be used for other clusters.
        InUseManagedPod = 4,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Unused => "UNUSED",
                Self::InUseService => "IN_USE_SERVICE",
                Self::InUseShareablePod => "IN_USE_SHAREABLE_POD",
                Self::InUseManagedPod => "IN_USE_MANAGED_POD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "UNUSED" => Some(Self::Unused),
                "IN_USE_SERVICE" => Some(Self::InUseService),
                "IN_USE_SHAREABLE_POD" => Some(Self::InUseShareablePod),
                "IN_USE_MANAGED_POD" => Some(Self::InUseManagedPod),
                _ => None,
            }
        }
    }
}
/// UsableSubnetwork resource returns the subnetwork name, its associated network
/// and the primary CIDR range.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsableSubnetwork {
    /// Subnetwork Name.
    /// Example: projects/my-project/regions/us-central1/subnetworks/my-subnet
    #[prost(string, tag = "1")]
    pub subnetwork: ::prost::alloc::string::String,
    /// Network Name.
    /// Example: projects/my-project/global/networks/my-network
    #[prost(string, tag = "2")]
    pub network: ::prost::alloc::string::String,
    /// The range of internal addresses that are owned by this subnetwork.
    #[prost(string, tag = "3")]
    pub ip_cidr_range: ::prost::alloc::string::String,
    /// Secondary IP ranges.
    #[prost(message, repeated, tag = "4")]
    pub secondary_ip_ranges: ::prost::alloc::vec::Vec<UsableSubnetworkSecondaryRange>,
    /// A human readable status message representing the reasons for cases where
    /// the caller cannot use the secondary ranges under the subnet. For example if
    /// the secondary_ip_ranges is empty due to a permission issue, an insufficient
    /// permission message will be given by status_message.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
}
/// Configuration for exporting cluster resource usages.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceUsageExportConfig {
    /// Configuration to use BigQuery as usage export destination.
    #[prost(message, optional, tag = "1")]
    pub bigquery_destination: ::core::option::Option<
        resource_usage_export_config::BigQueryDestination,
    >,
    /// Whether to enable network egress metering for this cluster. If enabled, a
    /// daemonset will be created in the cluster to meter network egress traffic.
    #[prost(bool, tag = "2")]
    pub enable_network_egress_metering: bool,
    /// Configuration to enable resource consumption metering.
    #[prost(message, optional, tag = "3")]
    pub consumption_metering_config: ::core::option::Option<
        resource_usage_export_config::ConsumptionMeteringConfig,
    >,
}
/// Nested message and enum types in `ResourceUsageExportConfig`.
pub mod resource_usage_export_config {
    /// Parameters for using BigQuery as the destination of resource usage export.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BigQueryDestination {
        /// The ID of a BigQuery Dataset.
        #[prost(string, tag = "1")]
        pub dataset_id: ::prost::alloc::string::String,
    }
    /// Parameters for controlling consumption metering.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ConsumptionMeteringConfig {
        /// Whether to enable consumption metering for this cluster. If enabled, a
        /// second BigQuery table will be created to hold resource consumption
        /// records.
        #[prost(bool, tag = "1")]
        pub enabled: bool,
    }
}
/// VerticalPodAutoscaling contains global, per-cluster information
/// required by Vertical Pod Autoscaler to automatically adjust
/// the resources of pods controlled by it.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VerticalPodAutoscaling {
    /// Enables vertical pod autoscaling.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// DefaultSnatStatus contains the desired state of whether default sNAT should
/// be disabled on the cluster.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DefaultSnatStatus {
    /// Disables cluster default sNAT rules.
    #[prost(bool, tag = "1")]
    pub disabled: bool,
}
/// Configuration of Shielded Nodes feature.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShieldedNodes {
    /// Whether Shielded Nodes features are enabled on all nodes in this cluster.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// Configuration of gVNIC feature.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VirtualNic {
    /// Whether gVNIC features are enabled in the node pool.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// Configuration of Fast Socket feature.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FastSocket {
    /// Whether Fast Socket features are enabled in the node pool.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// NotificationConfig is the configuration of notifications.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationConfig {
    /// Notification config for Pub/Sub.
    #[prost(message, optional, tag = "1")]
    pub pubsub: ::core::option::Option<notification_config::PubSub>,
}
/// Nested message and enum types in `NotificationConfig`.
pub mod notification_config {
    /// Pub/Sub specific notification config.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PubSub {
        /// Enable notifications for Pub/Sub.
        #[prost(bool, tag = "1")]
        pub enabled: bool,
        /// The desired Pub/Sub topic to which notifications will be
        /// sent by GKE. Format is `projects/{project}/topics/{topic}`.
        #[prost(string, tag = "2")]
        pub topic: ::prost::alloc::string::String,
        /// Allows filtering to one or more specific event types. If no filter is
        /// specified, or if a filter is specified with no event types, all event
        /// types will be sent
        #[prost(message, optional, tag = "3")]
        pub filter: ::core::option::Option<Filter>,
    }
    /// Allows filtering to one or more specific event types. If event types are
    /// present, those and only those event types will be transmitted to the
    /// cluster. Other types will be skipped. If no filter is specified, or no
    /// event types are present, all event types will be sent
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Filter {
        /// Event types to allowlist.
        #[prost(enumeration = "EventType", repeated, tag = "1")]
        pub event_type: ::prost::alloc::vec::Vec<i32>,
    }
    /// Types of notifications currently supported. Can be used to filter what
    /// notifications are sent.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EventType {
        /// Not set, will be ignored.
        Unspecified = 0,
        /// Corresponds with UpgradeAvailableEvent.
        UpgradeAvailableEvent = 1,
        /// Corresponds with UpgradeEvent.
        UpgradeEvent = 2,
        /// Corresponds with SecurityBulletinEvent.
        SecurityBulletinEvent = 3,
    }
    impl EventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EVENT_TYPE_UNSPECIFIED",
                Self::UpgradeAvailableEvent => "UPGRADE_AVAILABLE_EVENT",
                Self::UpgradeEvent => "UPGRADE_EVENT",
                Self::SecurityBulletinEvent => "SECURITY_BULLETIN_EVENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "UPGRADE_AVAILABLE_EVENT" => Some(Self::UpgradeAvailableEvent),
                "UPGRADE_EVENT" => Some(Self::UpgradeEvent),
                "SECURITY_BULLETIN_EVENT" => Some(Self::SecurityBulletinEvent),
                _ => None,
            }
        }
    }
}
/// ConfidentialNodes is configuration for the confidential nodes feature, which
/// makes nodes run on confidential VMs.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConfidentialNodes {
    /// Whether Confidential Nodes feature is enabled.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// UpgradeEvent is a notification sent to customers by the cluster server when
/// a resource is upgrading.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeEvent {
    /// The resource type that is upgrading.
    #[prost(enumeration = "UpgradeResourceType", tag = "1")]
    pub resource_type: i32,
    /// The operation associated with this upgrade.
    #[prost(string, tag = "2")]
    pub operation: ::prost::alloc::string::String,
    /// The time when the operation was started.
    #[prost(message, optional, tag = "3")]
    pub operation_start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The current version before the upgrade.
    #[prost(string, tag = "4")]
    pub current_version: ::prost::alloc::string::String,
    /// The target version for the upgrade.
    #[prost(string, tag = "5")]
    pub target_version: ::prost::alloc::string::String,
    /// Optional relative path to the resource. For example in node pool upgrades,
    /// the relative path of the node pool.
    #[prost(string, tag = "6")]
    pub resource: ::prost::alloc::string::String,
}
/// UpgradeInfoEvent is a notification sent to customers about the upgrade
/// information of a resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeInfoEvent {
    /// The resource type associated with the upgrade.
    #[prost(enumeration = "UpgradeResourceType", tag = "1")]
    pub resource_type: i32,
    /// The operation associated with this upgrade.
    #[prost(string, tag = "2")]
    pub operation: ::prost::alloc::string::String,
    /// The time when the operation was started.
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time when the operation ended.
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The current version before the upgrade.
    #[prost(string, tag = "5")]
    pub current_version: ::prost::alloc::string::String,
    /// The target version for the upgrade.
    #[prost(string, tag = "6")]
    pub target_version: ::prost::alloc::string::String,
    /// Optional relative path to the resource. For example in node pool upgrades,
    /// the relative path of the node pool.
    #[prost(string, tag = "7")]
    pub resource: ::prost::alloc::string::String,
    /// Output only. The state of the upgrade.
    #[prost(enumeration = "upgrade_info_event::State", tag = "8")]
    pub state: i32,
    /// A brief description of the event.
    #[prost(string, tag = "11")]
    pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `UpgradeInfoEvent`.
pub mod upgrade_info_event {
    /// The state of the upgrade.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// STATE_UNSPECIFIED indicates the state is unspecified.
        Unspecified = 0,
        /// STARTED indicates the upgrade has started.
        Started = 3,
        /// SUCCEEDED indicates the upgrade has completed successfully.
        Succeeded = 4,
        /// FAILED indicates the upgrade has failed.
        Failed = 5,
        /// CANCELED indicates the upgrade has canceled.
        Canceled = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Started => "STARTED",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::Canceled => "CANCELED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "STARTED" => Some(Self::Started),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "CANCELED" => Some(Self::Canceled),
                _ => None,
            }
        }
    }
}
/// UpgradeAvailableEvent is a notification sent to customers when a new
/// available version is released.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeAvailableEvent {
    /// The release version available for upgrade.
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// The resource type of the release version.
    #[prost(enumeration = "UpgradeResourceType", tag = "2")]
    pub resource_type: i32,
    /// The release channel of the version. If empty, it means a non-channel
    /// release.
    #[prost(message, optional, tag = "3")]
    pub release_channel: ::core::option::Option<ReleaseChannel>,
    /// Optional relative path to the resource. For example, the relative path of
    /// the node pool.
    #[prost(string, tag = "4")]
    pub resource: ::prost::alloc::string::String,
}
/// SecurityBulletinEvent is a notification sent to customers when a security
/// bulletin has been posted that they are vulnerable to.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityBulletinEvent {
    /// The resource type (node/control plane) that has the vulnerability. Multiple
    /// notifications (1 notification per resource type) will be sent for a
    /// vulnerability that affects > 1 resource type.
    #[prost(string, tag = "1")]
    pub resource_type_affected: ::prost::alloc::string::String,
    /// The ID of the bulletin corresponding to the vulnerability.
    #[prost(string, tag = "2")]
    pub bulletin_id: ::prost::alloc::string::String,
    /// The CVEs associated with this bulletin.
    #[prost(string, repeated, tag = "3")]
    pub cve_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The severity of this bulletin as it relates to GKE.
    #[prost(string, tag = "4")]
    pub severity: ::prost::alloc::string::String,
    /// The URI link to the bulletin on the website for more information.
    #[prost(string, tag = "5")]
    pub bulletin_uri: ::prost::alloc::string::String,
    /// A brief description of the bulletin. See the bulletin pointed to by the
    /// bulletin_uri field for an expanded description.
    #[prost(string, tag = "6")]
    pub brief_description: ::prost::alloc::string::String,
    /// The GKE minor versions affected by this vulnerability.
    #[prost(string, repeated, tag = "7")]
    pub affected_supported_minors: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// The GKE versions where this vulnerability is patched.
    #[prost(string, repeated, tag = "8")]
    pub patched_versions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// This represents a version selected from the patched_versions field that
    /// the cluster receiving this notification should most likely want to upgrade
    /// to based on its current version. Note that if this notification is being
    /// received by a given cluster, it means that this version is currently
    /// available as an upgrade target in that cluster's location.
    #[prost(string, tag = "9")]
    pub suggested_upgrade_target: ::prost::alloc::string::String,
    /// If this field is specified, it means there are manual steps that the user
    /// must take to make their clusters safe.
    #[prost(bool, tag = "10")]
    pub manual_steps_required: bool,
}
/// Autopilot is the configuration for Autopilot settings on the cluster.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Autopilot {
    /// Enable Autopilot
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Workload policy configuration for Autopilot.
    #[prost(message, optional, tag = "2")]
    pub workload_policy_config: ::core::option::Option<WorkloadPolicyConfig>,
}
/// WorkloadPolicyConfig is the configuration of workload policy for autopilot
/// clusters.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorkloadPolicyConfig {
    /// If true, workloads can use NET_ADMIN capability.
    #[prost(bool, optional, tag = "1")]
    pub allow_net_admin: ::core::option::Option<bool>,
}
/// LoggingConfig is cluster logging configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggingConfig {
    /// Logging components configuration
    #[prost(message, optional, tag = "1")]
    pub component_config: ::core::option::Option<LoggingComponentConfig>,
}
/// LoggingComponentConfig is cluster logging component configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggingComponentConfig {
    /// Select components to collect logs. An empty set would disable all logging.
    #[prost(enumeration = "logging_component_config::Component", repeated, tag = "1")]
    pub enable_components: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `LoggingComponentConfig`.
pub mod logging_component_config {
    /// GKE components exposing logs
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Component {
        /// Default value. This shouldn't be used.
        Unspecified = 0,
        /// system components
        SystemComponents = 1,
        /// workloads
        Workloads = 2,
        /// kube-apiserver
        Apiserver = 3,
        /// kube-scheduler
        Scheduler = 4,
        /// kube-controller-manager
        ControllerManager = 5,
        /// kcp-sshd
        KcpSshd = 7,
        /// kcp connection logs
        KcpConnection = 8,
    }
    impl Component {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "COMPONENT_UNSPECIFIED",
                Self::SystemComponents => "SYSTEM_COMPONENTS",
                Self::Workloads => "WORKLOADS",
                Self::Apiserver => "APISERVER",
                Self::Scheduler => "SCHEDULER",
                Self::ControllerManager => "CONTROLLER_MANAGER",
                Self::KcpSshd => "KCP_SSHD",
                Self::KcpConnection => "KCP_CONNECTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPONENT_UNSPECIFIED" => Some(Self::Unspecified),
                "SYSTEM_COMPONENTS" => Some(Self::SystemComponents),
                "WORKLOADS" => Some(Self::Workloads),
                "APISERVER" => Some(Self::Apiserver),
                "SCHEDULER" => Some(Self::Scheduler),
                "CONTROLLER_MANAGER" => Some(Self::ControllerManager),
                "KCP_SSHD" => Some(Self::KcpSshd),
                "KCP_CONNECTION" => Some(Self::KcpConnection),
                _ => None,
            }
        }
    }
}
/// RayClusterLoggingConfig specifies configuration of Ray logging.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RayClusterLoggingConfig {
    /// Enable log collection for Ray clusters.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// MonitoringConfig is cluster monitoring configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MonitoringConfig {
    /// Monitoring components configuration
    #[prost(message, optional, tag = "1")]
    pub component_config: ::core::option::Option<MonitoringComponentConfig>,
    /// Enable Google Cloud Managed Service for Prometheus
    /// in the cluster.
    #[prost(message, optional, tag = "2")]
    pub managed_prometheus_config: ::core::option::Option<ManagedPrometheusConfig>,
    /// Configuration of Advanced Datapath Observability features.
    #[prost(message, optional, tag = "3")]
    pub advanced_datapath_observability_config: ::core::option::Option<
        AdvancedDatapathObservabilityConfig,
    >,
}
/// AdvancedDatapathObservabilityConfig specifies configuration of observability
/// features of advanced datapath.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdvancedDatapathObservabilityConfig {
    /// Expose flow metrics on nodes
    #[prost(bool, tag = "1")]
    pub enable_metrics: bool,
    /// Method used to make Relay available
    #[prost(
        enumeration = "advanced_datapath_observability_config::RelayMode",
        tag = "2"
    )]
    pub relay_mode: i32,
    /// Enable Relay component
    #[prost(bool, optional, tag = "3")]
    pub enable_relay: ::core::option::Option<bool>,
}
/// Nested message and enum types in `AdvancedDatapathObservabilityConfig`.
pub mod advanced_datapath_observability_config {
    /// Supported Relay modes
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RelayMode {
        /// Default value. This shouldn't be used.
        Unspecified = 0,
        /// disabled
        Disabled = 1,
        /// exposed via internal load balancer
        InternalVpcLb = 3,
        /// exposed via external load balancer
        ExternalLb = 4,
    }
    impl RelayMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RELAY_MODE_UNSPECIFIED",
                Self::Disabled => "DISABLED",
                Self::InternalVpcLb => "INTERNAL_VPC_LB",
                Self::ExternalLb => "EXTERNAL_LB",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RELAY_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "DISABLED" => Some(Self::Disabled),
                "INTERNAL_VPC_LB" => Some(Self::InternalVpcLb),
                "EXTERNAL_LB" => Some(Self::ExternalLb),
                _ => None,
            }
        }
    }
}
/// RayClusterMonitoringConfig specifies monitoring configuration for Ray
/// clusters.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RayClusterMonitoringConfig {
    /// Enable metrics collection for Ray clusters.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// NodePoolLoggingConfig specifies logging configuration for nodepools.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NodePoolLoggingConfig {
    /// Logging variant configuration.
    #[prost(message, optional, tag = "1")]
    pub variant_config: ::core::option::Option<LoggingVariantConfig>,
}
/// LoggingVariantConfig specifies the behaviour of the logging component.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LoggingVariantConfig {
    /// Logging variant deployed on nodes.
    #[prost(enumeration = "logging_variant_config::Variant", tag = "1")]
    pub variant: i32,
}
/// Nested message and enum types in `LoggingVariantConfig`.
pub mod logging_variant_config {
    /// Logging component variants.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Variant {
        /// Default value. This shouldn't be used.
        Unspecified = 0,
        /// default logging variant.
        Default = 1,
        /// maximum logging throughput variant.
        MaxThroughput = 2,
    }
    impl Variant {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "VARIANT_UNSPECIFIED",
                Self::Default => "DEFAULT",
                Self::MaxThroughput => "MAX_THROUGHPUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VARIANT_UNSPECIFIED" => Some(Self::Unspecified),
                "DEFAULT" => Some(Self::Default),
                "MAX_THROUGHPUT" => Some(Self::MaxThroughput),
                _ => None,
            }
        }
    }
}
/// MonitoringComponentConfig is cluster monitoring component configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MonitoringComponentConfig {
    /// Select components to collect metrics. An empty set would disable all
    /// monitoring.
    #[prost(enumeration = "monitoring_component_config::Component", repeated, tag = "1")]
    pub enable_components: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `MonitoringComponentConfig`.
pub mod monitoring_component_config {
    /// GKE components exposing metrics
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Component {
        /// Default value. This shouldn't be used.
        Unspecified = 0,
        /// system components
        SystemComponents = 1,
        /// kube-apiserver
        Apiserver = 3,
        /// kube-scheduler
        Scheduler = 4,
        /// kube-controller-manager
        ControllerManager = 5,
        /// Storage
        Storage = 7,
        /// Horizontal Pod Autoscaling
        Hpa = 8,
        /// Pod
        Pod = 9,
        /// DaemonSet
        Daemonset = 10,
        /// Deployment
        Deployment = 11,
        /// Statefulset
        Statefulset = 12,
        /// CADVISOR
        Cadvisor = 13,
        /// KUBELET
        Kubelet = 14,
        /// NVIDIA Data Center GPU Manager (DCGM)
        Dcgm = 15,
    }
    impl Component {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "COMPONENT_UNSPECIFIED",
                Self::SystemComponents => "SYSTEM_COMPONENTS",
                Self::Apiserver => "APISERVER",
                Self::Scheduler => "SCHEDULER",
                Self::ControllerManager => "CONTROLLER_MANAGER",
                Self::Storage => "STORAGE",
                Self::Hpa => "HPA",
                Self::Pod => "POD",
                Self::Daemonset => "DAEMONSET",
                Self::Deployment => "DEPLOYMENT",
                Self::Statefulset => "STATEFULSET",
                Self::Cadvisor => "CADVISOR",
                Self::Kubelet => "KUBELET",
                Self::Dcgm => "DCGM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPONENT_UNSPECIFIED" => Some(Self::Unspecified),
                "SYSTEM_COMPONENTS" => Some(Self::SystemComponents),
                "APISERVER" => Some(Self::Apiserver),
                "SCHEDULER" => Some(Self::Scheduler),
                "CONTROLLER_MANAGER" => Some(Self::ControllerManager),
                "STORAGE" => Some(Self::Storage),
                "HPA" => Some(Self::Hpa),
                "POD" => Some(Self::Pod),
                "DAEMONSET" => Some(Self::Daemonset),
                "DEPLOYMENT" => Some(Self::Deployment),
                "STATEFULSET" => Some(Self::Statefulset),
                "CADVISOR" => Some(Self::Cadvisor),
                "KUBELET" => Some(Self::Kubelet),
                "DCGM" => Some(Self::Dcgm),
                _ => None,
            }
        }
    }
}
/// ManagedPrometheusConfig defines the configuration for
/// Google Cloud Managed Service for Prometheus.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ManagedPrometheusConfig {
    /// Enable Managed Collection.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// Fleet is the fleet configuration for the cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fleet {
    /// The Fleet host project(project ID or project number) where this cluster
    /// will be registered to. This field cannot be changed after the cluster has
    /// been registered.
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    /// Output only. The full resource name of the registered fleet membership of
    /// the cluster, in the format
    /// `//gkehub.googleapis.com/projects/*/locations/*/memberships/*`.
    #[prost(string, tag = "2")]
    pub membership: ::prost::alloc::string::String,
    /// Output only. Whether the cluster has been registered through the fleet
    /// API.
    #[prost(bool, tag = "3")]
    pub pre_registered: bool,
}
/// Configuration for all of the cluster's control plane endpoints.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ControlPlaneEndpointsConfig {
    /// DNS endpoint configuration.
    #[prost(message, optional, tag = "1")]
    pub dns_endpoint_config: ::core::option::Option<
        control_plane_endpoints_config::DnsEndpointConfig,
    >,
    /// IP endpoints configuration.
    #[prost(message, optional, tag = "3")]
    pub ip_endpoints_config: ::core::option::Option<
        control_plane_endpoints_config::IpEndpointsConfig,
    >,
}
/// Nested message and enum types in `ControlPlaneEndpointsConfig`.
pub mod control_plane_endpoints_config {
    /// Describes the configuration of a DNS endpoint.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DnsEndpointConfig {
        /// Output only. The cluster's DNS endpoint configuration.
        /// A DNS format address. This is accessible from the public internet.
        /// Ex: uid.us-central1.gke.goog.
        /// Always present, but the behavior may change according to the value of
        /// [DNSEndpointConfig.allow_external_traffic][google.container.v1.ControlPlaneEndpointsConfig.DNSEndpointConfig.allow_external_traffic].
        #[prost(string, tag = "2")]
        pub endpoint: ::prost::alloc::string::String,
        /// Controls whether user traffic is allowed over this endpoint. Note that
        /// GCP-managed services may still use the endpoint even if this is false.
        #[prost(bool, optional, tag = "3")]
        pub allow_external_traffic: ::core::option::Option<bool>,
    }
    /// IP endpoints configuration.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IpEndpointsConfig {
        /// Controls whether to allow direct IP access.
        #[prost(bool, optional, tag = "1")]
        pub enabled: ::core::option::Option<bool>,
        /// Controls whether the control plane allows access through a public IP.
        /// It is invalid to specify both
        /// [PrivateClusterConfig.enablePrivateEndpoint][] and this field at the same
        /// time.
        #[prost(bool, optional, tag = "2")]
        pub enable_public_endpoint: ::core::option::Option<bool>,
        /// Controls whether the control plane's private endpoint is accessible from
        /// sources in other regions.
        /// It is invalid to specify both
        /// [PrivateClusterMasterGlobalAccessConfig.enabled][google.container.v1.PrivateClusterMasterGlobalAccessConfig.enabled]
        /// and this field at the same time.
        #[prost(bool, optional, tag = "3")]
        pub global_access: ::core::option::Option<bool>,
        /// Configuration of authorized networks. If enabled, restricts access to the
        /// control plane based on source IP.
        /// It is invalid to specify both
        /// [Cluster.masterAuthorizedNetworksConfig][] and this field at the same
        /// time.
        #[prost(message, optional, tag = "4")]
        pub authorized_networks_config: ::core::option::Option<
            super::MasterAuthorizedNetworksConfig,
        >,
        /// Output only. The external IP address of this cluster's control plane.
        /// Only populated if enabled.
        #[prost(string, tag = "5")]
        pub public_endpoint: ::prost::alloc::string::String,
        /// Output only. The internal IP address of this cluster's control plane.
        /// Only populated if enabled.
        #[prost(string, tag = "6")]
        pub private_endpoint: ::prost::alloc::string::String,
        /// Subnet to provision the master's private endpoint during cluster
        /// creation. Specified in projects/*/regions/*/subnetworks/* format. It is
        /// invalid to specify both
        /// [PrivateClusterConfig.privateEndpointSubnetwork][] and this field at the
        /// same time.
        #[prost(string, tag = "7")]
        pub private_endpoint_subnetwork: ::prost::alloc::string::String,
    }
}
/// LocalNvmeSsdBlockConfig contains configuration for using raw-block local
/// NVMe SSDs
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalNvmeSsdBlockConfig {
    /// Number of local NVMe SSDs to use.  The limit for this value is dependent
    /// upon the maximum number of disk available on a machine per zone. See:
    /// <https://cloud.google.com/compute/docs/disks/local-ssd>
    /// for more information.
    ///
    /// A zero (or unset) value has different meanings depending on machine type
    /// being used:
    /// 1. For pre-Gen3 machines, which support flexible numbers of local ssds,
    /// zero (or unset) means to disable using local SSDs as ephemeral storage.
    /// 2. For Gen3 machines which dictate a specific number of local ssds, zero
    /// (or unset) means to use the default number of local ssds that goes with
    /// that machine type. For example, for a c3-standard-8-lssd machine, 2 local
    /// ssds would be provisioned. For c3-standard-8 (which doesn't support local
    /// ssds), 0 will be provisioned. See
    /// <https://cloud.google.com/compute/docs/disks/local-ssd#choose_number_local_ssds>
    /// for more info.
    #[prost(int32, tag = "1")]
    pub local_ssd_count: i32,
}
/// EphemeralStorageLocalSsdConfig contains configuration for the node ephemeral
/// storage using Local SSDs.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EphemeralStorageLocalSsdConfig {
    /// Number of local SSDs to use to back ephemeral storage. Uses NVMe
    /// interfaces.
    ///
    /// A zero (or unset) value has different meanings depending on machine type
    /// being used:
    /// 1. For pre-Gen3 machines, which support flexible numbers of local ssds,
    /// zero (or unset) means to disable using local SSDs as ephemeral storage. The
    /// limit for this value is dependent upon the maximum number of disk
    /// available on a machine per zone. See:
    /// <https://cloud.google.com/compute/docs/disks/local-ssd>
    /// for more information.
    /// 2. For Gen3 machines which dictate a specific number of local ssds, zero
    /// (or unset) means to use the default number of local ssds that goes with
    /// that machine type. For example, for a c3-standard-8-lssd machine, 2 local
    /// ssds would be provisioned. For c3-standard-8 (which doesn't support local
    /// ssds), 0 will be provisioned. See
    /// <https://cloud.google.com/compute/docs/disks/local-ssd#choose_number_local_ssds>
    /// for more info.
    #[prost(int32, tag = "1")]
    pub local_ssd_count: i32,
}
/// A map of resource manager tag keys and values to be attached to the nodes
/// for managing Compute Engine firewalls using Network Firewall Policies.
/// Tags must be according to specifications in
/// <https://cloud.google.com/vpc/docs/tags-firewalls-overview#specifications.>
/// A maximum of 5 tag key-value pairs can be specified.
/// Existing tags will be replaced with new values.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceManagerTags {
    /// TagKeyValue must be in one of the following formats (\[KEY\]=[VALUE])
    /// 1. `tagKeys/{tag_key_id}=tagValues/{tag_value_id}`
    /// 2. `{org_id}/{tag_key_name}={tag_value_name}`
    /// 3. `{project_id}/{tag_key_name}={tag_value_name}`
    #[prost(map = "string, string", tag = "1")]
    pub tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// EnterpriseConfig is the cluster enterprise configuration.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnterpriseConfig {
    /// Output only. cluster_tier indicates the effective tier of the cluster.
    #[prost(enumeration = "enterprise_config::ClusterTier", tag = "1")]
    pub cluster_tier: i32,
    /// desired_tier specifies the desired tier of the cluster.
    #[prost(enumeration = "enterprise_config::ClusterTier", tag = "2")]
    pub desired_tier: i32,
}
/// Nested message and enum types in `EnterpriseConfig`.
pub mod enterprise_config {
    /// Premium tiers for GKE Cluster.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ClusterTier {
        /// CLUSTER_TIER_UNSPECIFIED is when cluster_tier is not set.
        Unspecified = 0,
        /// STANDARD indicates a standard GKE cluster.
        Standard = 1,
        /// ENTERPRISE indicates a GKE Enterprise cluster.
        Enterprise = 2,
    }
    impl ClusterTier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CLUSTER_TIER_UNSPECIFIED",
                Self::Standard => "STANDARD",
                Self::Enterprise => "ENTERPRISE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLUSTER_TIER_UNSPECIFIED" => Some(Self::Unspecified),
                "STANDARD" => Some(Self::Standard),
                "ENTERPRISE" => Some(Self::Enterprise),
                _ => None,
            }
        }
    }
}
/// SecretManagerConfig is config for secret manager enablement.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SecretManagerConfig {
    /// Enable/Disable Secret Manager Config.
    #[prost(bool, optional, tag = "1")]
    pub enabled: ::core::option::Option<bool>,
}
/// SecondaryBootDisk represents a persistent disk attached to a node
/// with special configurations based on its mode.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecondaryBootDisk {
    /// Disk mode (container image cache, etc.)
    #[prost(enumeration = "secondary_boot_disk::Mode", tag = "1")]
    pub mode: i32,
    /// Fully-qualified resource ID for an existing disk image.
    #[prost(string, tag = "2")]
    pub disk_image: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SecondaryBootDisk`.
pub mod secondary_boot_disk {
    /// Mode specifies how the secondary boot disk will be used.
    /// This triggers mode-specified logic in the control plane.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        /// MODE_UNSPECIFIED is when mode is not set.
        Unspecified = 0,
        /// CONTAINER_IMAGE_CACHE is for using the secondary boot disk as
        /// a container image cache.
        ContainerImageCache = 1,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODE_UNSPECIFIED",
                Self::ContainerImageCache => "CONTAINER_IMAGE_CACHE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "CONTAINER_IMAGE_CACHE" => Some(Self::ContainerImageCache),
                _ => None,
            }
        }
    }
}
/// SecondaryBootDiskUpdateStrategy is a placeholder which will be extended
/// in the future to define different options for updating secondary boot disks.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SecondaryBootDiskUpdateStrategy {}
/// PrivateIPv6GoogleAccess controls whether and how the pods can communicate
/// with Google Services through gRPC over IPv6.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PrivateIPv6GoogleAccess {
    /// Default value. Same as DISABLED
    PrivateIpv6GoogleAccessUnspecified = 0,
    /// No private access to or from Google Services
    PrivateIpv6GoogleAccessDisabled = 1,
    /// Enables private IPv6 access to Google Services from GKE
    PrivateIpv6GoogleAccessToGoogle = 2,
    /// Enables private IPv6 access to and from Google Services
    PrivateIpv6GoogleAccessBidirectional = 3,
}
impl PrivateIPv6GoogleAccess {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PrivateIpv6GoogleAccessUnspecified => {
                "PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED"
            }
            Self::PrivateIpv6GoogleAccessDisabled => {
                "PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED"
            }
            Self::PrivateIpv6GoogleAccessToGoogle => {
                "PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE"
            }
            Self::PrivateIpv6GoogleAccessBidirectional => {
                "PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED" => {
                Some(Self::PrivateIpv6GoogleAccessUnspecified)
            }
            "PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED" => {
                Some(Self::PrivateIpv6GoogleAccessDisabled)
            }
            "PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE" => {
                Some(Self::PrivateIpv6GoogleAccessToGoogle)
            }
            "PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL" => {
                Some(Self::PrivateIpv6GoogleAccessBidirectional)
            }
            _ => None,
        }
    }
}
/// UpgradeResourceType is the resource type that is upgrading. It is used
/// in upgrade notifications.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UpgradeResourceType {
    /// Default value. This shouldn't be used.
    Unspecified = 0,
    /// Master / control plane
    Master = 1,
    /// Node pool
    NodePool = 2,
}
impl UpgradeResourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "UPGRADE_RESOURCE_TYPE_UNSPECIFIED",
            Self::Master => "MASTER",
            Self::NodePool => "NODE_POOL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UPGRADE_RESOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "MASTER" => Some(Self::Master),
            "NODE_POOL" => Some(Self::NodePool),
            _ => None,
        }
    }
}
/// The datapath provider selects the implementation of the Kubernetes networking
/// model for service resolution and network policy enforcement.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DatapathProvider {
    /// Default value.
    Unspecified = 0,
    /// Use the IPTables implementation based on kube-proxy.
    LegacyDatapath = 1,
    /// Use the eBPF based GKE Dataplane V2 with additional features. See the [GKE
    /// Dataplane V2
    /// documentation](<https://cloud.google.com/kubernetes-engine/docs/how-to/dataplane-v2>)
    /// for more.
    AdvancedDatapath = 2,
}
impl DatapathProvider {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DATAPATH_PROVIDER_UNSPECIFIED",
            Self::LegacyDatapath => "LEGACY_DATAPATH",
            Self::AdvancedDatapath => "ADVANCED_DATAPATH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATAPATH_PROVIDER_UNSPECIFIED" => Some(Self::Unspecified),
            "LEGACY_DATAPATH" => Some(Self::LegacyDatapath),
            "ADVANCED_DATAPATH" => Some(Self::AdvancedDatapath),
            _ => None,
        }
    }
}
/// Strategy used for node pool update.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodePoolUpdateStrategy {
    /// Default value if unset. GKE internally defaults the update strategy to
    /// SURGE for unspecified strategies.
    Unspecified = 0,
    /// blue-green upgrade.
    BlueGreen = 2,
    /// SURGE is the traditional way of upgrade a node pool.
    /// max_surge and max_unavailable determines the level of upgrade parallelism.
    Surge = 3,
}
impl NodePoolUpdateStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED",
            Self::BlueGreen => "BLUE_GREEN",
            Self::Surge => "SURGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
            "BLUE_GREEN" => Some(Self::BlueGreen),
            "SURGE" => Some(Self::Surge),
            _ => None,
        }
    }
}
/// Possible values for IP stack type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StackType {
    /// Default value, will be defaulted as IPV4 only
    Unspecified = 0,
    /// Cluster is IPV4 only
    Ipv4 = 1,
    /// Cluster can use both IPv4 and IPv6
    Ipv4Ipv6 = 2,
}
impl StackType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STACK_TYPE_UNSPECIFIED",
            Self::Ipv4 => "IPV4",
            Self::Ipv4Ipv6 => "IPV4_IPV6",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STACK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "IPV4" => Some(Self::Ipv4),
            "IPV4_IPV6" => Some(Self::Ipv4Ipv6),
            _ => None,
        }
    }
}
/// Possible values for IPv6 access type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IPv6AccessType {
    /// Default value, will be defaulted as type external.
    Ipv6AccessTypeUnspecified = 0,
    /// Access type internal (all v6 addresses are internal IPs)
    Internal = 1,
    /// Access type external (all v6 addresses are external IPs)
    External = 2,
}
impl IPv6AccessType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ipv6AccessTypeUnspecified => "IPV6_ACCESS_TYPE_UNSPECIFIED",
            Self::Internal => "INTERNAL",
            Self::External => "EXTERNAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IPV6_ACCESS_TYPE_UNSPECIFIED" => Some(Self::Ipv6AccessTypeUnspecified),
            "INTERNAL" => Some(Self::Internal),
            "EXTERNAL" => Some(Self::External),
            _ => None,
        }
    }
}
/// Options for in-transit encryption.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InTransitEncryptionConfig {
    /// Unspecified, will be inferred as default -
    /// IN_TRANSIT_ENCRYPTION_UNSPECIFIED.
    Unspecified = 0,
    /// In-transit encryption is disabled.
    InTransitEncryptionDisabled = 1,
    /// Data in-transit is encrypted using inter-node transparent encryption.
    InTransitEncryptionInterNodeTransparent = 2,
}
impl InTransitEncryptionConfig {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED",
            Self::InTransitEncryptionDisabled => "IN_TRANSIT_ENCRYPTION_DISABLED",
            Self::InTransitEncryptionInterNodeTransparent => {
                "IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED" => Some(Self::Unspecified),
            "IN_TRANSIT_ENCRYPTION_DISABLED" => Some(Self::InTransitEncryptionDisabled),
            "IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT" => {
                Some(Self::InTransitEncryptionInterNodeTransparent)
            }
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod cluster_manager_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Google Kubernetes Engine Cluster Manager v1
    #[derive(Debug, Clone)]
    pub struct ClusterManagerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ClusterManagerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ClusterManagerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ClusterManagerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ClusterManagerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists all clusters owned by a project in either the specified zone or all
        /// zones.
        pub async fn list_clusters(
            &mut self,
            request: impl tonic::IntoRequest<super::ListClustersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListClustersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/ListClusters",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.container.v1.ClusterManager", "ListClusters"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the details of a specific cluster.
        pub async fn get_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::GetClusterRequest>,
        ) -> std::result::Result<tonic::Response<super::Cluster>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/GetCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.container.v1.ClusterManager", "GetCluster"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a cluster, consisting of the specified number and type of Google
        /// Compute Engine instances.
        ///
        /// By default, the cluster is created in the project's
        /// [default
        /// network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks).
        ///
        /// One firewall is added for the cluster. After cluster creation,
        /// the Kubelet creates routes for each node to allow the containers
        /// on that node to communicate with all other instances in the
        /// cluster.
        ///
        /// Finally, an entry is added to the project's global metadata indicating
        /// which CIDR range the cluster is using.
        pub async fn create_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateClusterRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/CreateCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "CreateCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the settings of a specific cluster.
        pub async fn update_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateClusterRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/UpdateCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "UpdateCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the version and/or image type for the specified node pool.
        pub async fn update_node_pool(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateNodePoolRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/UpdateNodePool",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "UpdateNodePool",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the autoscaling settings for the specified node pool.
        pub async fn set_node_pool_autoscaling(
            &mut self,
            request: impl tonic::IntoRequest<super::SetNodePoolAutoscalingRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/SetNodePoolAutoscaling",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "SetNodePoolAutoscaling",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the logging service for a specific cluster.
        pub async fn set_logging_service(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLoggingServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/SetLoggingService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "SetLoggingService",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the monitoring service for a specific cluster.
        pub async fn set_monitoring_service(
            &mut self,
            request: impl tonic::IntoRequest<super::SetMonitoringServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/SetMonitoringService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "SetMonitoringService",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the addons for a specific cluster.
        pub async fn set_addons_config(
            &mut self,
            request: impl tonic::IntoRequest<super::SetAddonsConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/SetAddonsConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "SetAddonsConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the locations for a specific cluster.
        /// Deprecated. Use
        /// [projects.locations.clusters.update](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters/update)
        /// instead.
        #[deprecated]
        pub async fn set_locations(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLocationsRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/SetLocations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.container.v1.ClusterManager", "SetLocations"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the master for a specific cluster.
        pub async fn update_master(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateMasterRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/UpdateMaster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.container.v1.ClusterManager", "UpdateMaster"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets master auth materials. Currently supports changing the admin password
        /// or a specific cluster, either via password generation or explicitly setting
        /// the password.
        pub async fn set_master_auth(
            &mut self,
            request: impl tonic::IntoRequest<super::SetMasterAuthRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/SetMasterAuth",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "SetMasterAuth",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the cluster, including the Kubernetes endpoint and all worker
        /// nodes.
        ///
        /// Firewalls and routes that were configured during cluster creation
        /// are also deleted.
        ///
        /// Other Google Compute Engine resources that might be in use by the cluster,
        /// such as load balancer resources, are not deleted if they weren't present
        /// when the cluster was initially created.
        pub async fn delete_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteClusterRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/DeleteCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "DeleteCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all operations in a project in a specific zone or all zones.
        pub async fn list_operations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOperationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOperationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/ListOperations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "ListOperations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the specified operation.
        pub async fn get_operation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOperationRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/GetOperation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.container.v1.ClusterManager", "GetOperation"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Cancels the specified operation.
        pub async fn cancel_operation(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelOperationRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/CancelOperation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "CancelOperation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns configuration info about the Google Kubernetes Engine service.
        pub async fn get_server_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetServerConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::ServerConfig>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/GetServerConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "GetServerConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the public component of the cluster signing keys in
        /// JSON Web Key format.
        pub async fn get_json_web_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::GetJsonWebKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetJsonWebKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/GetJSONWebKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "GetJSONWebKeys",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the node pools for a cluster.
        pub async fn list_node_pools(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNodePoolsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListNodePoolsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/ListNodePools",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "ListNodePools",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the requested node pool.
        pub async fn get_node_pool(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNodePoolRequest>,
        ) -> std::result::Result<tonic::Response<super::NodePool>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/GetNodePool",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.container.v1.ClusterManager", "GetNodePool"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a node pool for a cluster.
        pub async fn create_node_pool(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateNodePoolRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/CreateNodePool",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "CreateNodePool",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a node pool from a cluster.
        pub async fn delete_node_pool(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteNodePoolRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/DeleteNodePool",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "DeleteNodePool",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// CompleteNodePoolUpgrade will signal an on-going node pool upgrade to
        /// complete.
        pub async fn complete_node_pool_upgrade(
            &mut self,
            request: impl tonic::IntoRequest<super::CompleteNodePoolUpgradeRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/CompleteNodePoolUpgrade",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "CompleteNodePoolUpgrade",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Rolls back a previously Aborted or Failed NodePool upgrade.
        /// This makes no changes if the last upgrade successfully completed.
        pub async fn rollback_node_pool_upgrade(
            &mut self,
            request: impl tonic::IntoRequest<super::RollbackNodePoolUpgradeRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/RollbackNodePoolUpgrade",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "RollbackNodePoolUpgrade",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the NodeManagement options for a node pool.
        pub async fn set_node_pool_management(
            &mut self,
            request: impl tonic::IntoRequest<super::SetNodePoolManagementRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/SetNodePoolManagement",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "SetNodePoolManagement",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets labels on a cluster.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.container.v1.ClusterManager", "SetLabels"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Enables or disables the ABAC authorization mechanism on a cluster.
        pub async fn set_legacy_abac(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLegacyAbacRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/SetLegacyAbac",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "SetLegacyAbac",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Starts master IP rotation.
        pub async fn start_ip_rotation(
            &mut self,
            request: impl tonic::IntoRequest<super::StartIpRotationRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/StartIPRotation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "StartIPRotation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Completes master IP rotation.
        pub async fn complete_ip_rotation(
            &mut self,
            request: impl tonic::IntoRequest<super::CompleteIpRotationRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/CompleteIPRotation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "CompleteIPRotation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the size for a specific node pool. The new size will be used for all
        /// replicas, including future replicas created by modifying
        /// [NodePool.locations][google.container.v1.NodePool.locations].
        pub async fn set_node_pool_size(
            &mut self,
            request: impl tonic::IntoRequest<super::SetNodePoolSizeRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/SetNodePoolSize",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "SetNodePoolSize",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Enables or disables Network Policy for a cluster.
        pub async fn set_network_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetNetworkPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/SetNetworkPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "SetNetworkPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the maintenance policy for a cluster.
        pub async fn set_maintenance_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetMaintenancePolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/SetMaintenancePolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "SetMaintenancePolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists subnetworks that are usable for creating clusters in a project.
        pub async fn list_usable_subnetworks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUsableSubnetworksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUsableSubnetworksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/ListUsableSubnetworks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "ListUsableSubnetworks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Checks the cluster compatibility with Autopilot mode, and returns a list of
        /// compatibility issues.
        pub async fn check_autopilot_compatibility(
            &mut self,
            request: impl tonic::IntoRequest<super::CheckAutopilotCompatibilityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CheckAutopilotCompatibilityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.container.v1.ClusterManager/CheckAutopilotCompatibility",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.container.v1.ClusterManager",
                        "CheckAutopilotCompatibility",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
