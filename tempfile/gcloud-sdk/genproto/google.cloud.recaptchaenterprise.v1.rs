// This file is @generated by prost-build.
/// The create assessment request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAssessmentRequest {
    /// Required. The name of the project in which the assessment is created,
    /// in the format `projects/{project}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The assessment details.
    #[prost(message, optional, tag = "2")]
    pub assessment: ::core::option::Option<Assessment>,
}
/// Describes an event in the lifecycle of a payment transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEvent {
    /// Optional. The type of this transaction event.
    #[prost(enumeration = "transaction_event::TransactionEventType", tag = "1")]
    pub event_type: i32,
    /// Optional. The reason or standardized code that corresponds with this
    /// transaction event, if one exists. For example, a CHARGEBACK event with code
    /// 6005.
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    /// Optional. The value that corresponds with this transaction event, if one
    /// exists. For example, a refund event where $5.00 was refunded. Currency is
    /// obtained from the original transaction data.
    #[prost(double, tag = "3")]
    pub value: f64,
    /// Optional. Timestamp when this transaction event occurred; otherwise assumed
    /// to be the time of the API call.
    #[prost(message, optional, tag = "4")]
    pub event_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `TransactionEvent`.
pub mod transaction_event {
    /// Enum that represents an event in the payment transaction lifecycle.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransactionEventType {
        /// Default, unspecified event type.
        Unspecified = 0,
        /// Indicates that the transaction is approved by the merchant. The
        /// accompanying reasons can include terms such as 'INHOUSE', 'ACCERTIFY',
        /// 'CYBERSOURCE', or 'MANUAL_REVIEW'.
        MerchantApprove = 1,
        /// Indicates that the transaction is denied and concluded due to risks
        /// detected by the merchant. The accompanying reasons can include terms such
        /// as 'INHOUSE',  'ACCERTIFY',  'CYBERSOURCE', or 'MANUAL_REVIEW'.
        MerchantDeny = 2,
        /// Indicates that the transaction is being evaluated by a human, due to
        /// suspicion or risk.
        ManualReview = 3,
        /// Indicates that the authorization attempt with the card issuer succeeded.
        Authorization = 4,
        /// Indicates that the authorization attempt with the card issuer failed.
        /// The accompanying reasons can include Visa's '54' indicating that the card
        /// is expired, or '82' indicating that the CVV is incorrect.
        AuthorizationDecline = 5,
        /// Indicates that the transaction is completed because the funds were
        /// settled.
        PaymentCapture = 6,
        /// Indicates that the transaction could not be completed because the funds
        /// were not settled.
        PaymentCaptureDecline = 7,
        /// Indicates that the transaction has been canceled. Specify the reason
        /// for the cancellation. For example, 'INSUFFICIENT_INVENTORY'.
        Cancel = 8,
        /// Indicates that the merchant has received a chargeback inquiry due to
        /// fraud for the transaction, requesting additional information before a
        /// fraud chargeback is officially issued and a formal chargeback
        /// notification is sent.
        ChargebackInquiry = 9,
        /// Indicates that the merchant has received a chargeback alert due to fraud
        /// for the transaction. The process of resolving the dispute without
        /// involving the payment network is started.
        ChargebackAlert = 10,
        /// Indicates that a fraud notification is issued for the transaction, sent
        /// by the payment instrument's issuing bank because the transaction appears
        /// to be fraudulent. We recommend including TC40 or SAFE data in the
        /// `reason` field for this event type. For partial chargebacks, we recommend
        /// that you include an amount in the `value` field.
        FraudNotification = 11,
        /// Indicates that the merchant is informed by the payment network that the
        /// transaction has entered the chargeback process due to fraud. Reason code
        /// examples include Discover's '6005' and '6041'. For partial chargebacks,
        /// we recommend that you include an amount in the `value` field.
        Chargeback = 12,
        /// Indicates that the transaction has entered the chargeback process due to
        /// fraud, and that the merchant has chosen to enter representment. Reason
        /// examples include Discover's '6005' and '6041'. For partial chargebacks,
        /// we recommend that you include an amount in the `value` field.
        ChargebackRepresentment = 13,
        /// Indicates that the transaction has had a fraud chargeback which was
        /// illegitimate and was reversed as a result. For partial chargebacks, we
        /// recommend that you include an amount in the `value` field.
        ChargebackReverse = 14,
        /// Indicates that the merchant has received a refund for a completed
        /// transaction. For partial refunds, we recommend that you include an amount
        /// in the `value` field. Reason example: 'TAX_EXEMPT' (partial refund of
        /// exempt tax)
        RefundRequest = 15,
        /// Indicates that the merchant has received a refund request for this
        /// transaction, but that they have declined it. For partial refunds, we
        /// recommend that you include an amount in the `value` field. Reason
        /// example: 'TAX_EXEMPT' (partial refund of exempt tax)
        RefundDecline = 16,
        /// Indicates that the completed transaction was refunded by the merchant.
        /// For partial refunds, we recommend that you include an amount in the
        /// `value` field. Reason example: 'TAX_EXEMPT' (partial refund of exempt
        /// tax)
        Refund = 17,
        /// Indicates that the completed transaction was refunded by the merchant,
        /// and that this refund was reversed. For partial refunds, we recommend that
        /// you include an amount in the `value` field.
        RefundReverse = 18,
    }
    impl TransactionEventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TRANSACTION_EVENT_TYPE_UNSPECIFIED",
                Self::MerchantApprove => "MERCHANT_APPROVE",
                Self::MerchantDeny => "MERCHANT_DENY",
                Self::ManualReview => "MANUAL_REVIEW",
                Self::Authorization => "AUTHORIZATION",
                Self::AuthorizationDecline => "AUTHORIZATION_DECLINE",
                Self::PaymentCapture => "PAYMENT_CAPTURE",
                Self::PaymentCaptureDecline => "PAYMENT_CAPTURE_DECLINE",
                Self::Cancel => "CANCEL",
                Self::ChargebackInquiry => "CHARGEBACK_INQUIRY",
                Self::ChargebackAlert => "CHARGEBACK_ALERT",
                Self::FraudNotification => "FRAUD_NOTIFICATION",
                Self::Chargeback => "CHARGEBACK",
                Self::ChargebackRepresentment => "CHARGEBACK_REPRESENTMENT",
                Self::ChargebackReverse => "CHARGEBACK_REVERSE",
                Self::RefundRequest => "REFUND_REQUEST",
                Self::RefundDecline => "REFUND_DECLINE",
                Self::Refund => "REFUND",
                Self::RefundReverse => "REFUND_REVERSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRANSACTION_EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "MERCHANT_APPROVE" => Some(Self::MerchantApprove),
                "MERCHANT_DENY" => Some(Self::MerchantDeny),
                "MANUAL_REVIEW" => Some(Self::ManualReview),
                "AUTHORIZATION" => Some(Self::Authorization),
                "AUTHORIZATION_DECLINE" => Some(Self::AuthorizationDecline),
                "PAYMENT_CAPTURE" => Some(Self::PaymentCapture),
                "PAYMENT_CAPTURE_DECLINE" => Some(Self::PaymentCaptureDecline),
                "CANCEL" => Some(Self::Cancel),
                "CHARGEBACK_INQUIRY" => Some(Self::ChargebackInquiry),
                "CHARGEBACK_ALERT" => Some(Self::ChargebackAlert),
                "FRAUD_NOTIFICATION" => Some(Self::FraudNotification),
                "CHARGEBACK" => Some(Self::Chargeback),
                "CHARGEBACK_REPRESENTMENT" => Some(Self::ChargebackRepresentment),
                "CHARGEBACK_REVERSE" => Some(Self::ChargebackReverse),
                "REFUND_REQUEST" => Some(Self::RefundRequest),
                "REFUND_DECLINE" => Some(Self::RefundDecline),
                "REFUND" => Some(Self::Refund),
                "REFUND_REVERSE" => Some(Self::RefundReverse),
                _ => None,
            }
        }
    }
}
/// The request message to annotate an Assessment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotateAssessmentRequest {
    /// Required. The resource name of the Assessment, in the format
    /// `projects/{project}/assessments/{assessment}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The annotation that is assigned to the Event. This field can be
    /// left empty to provide reasons that apply to an event without concluding
    /// whether the event is legitimate or fraudulent.
    #[prost(enumeration = "annotate_assessment_request::Annotation", tag = "2")]
    pub annotation: i32,
    /// Optional. Reasons for the annotation that are assigned to the event.
    #[prost(
        enumeration = "annotate_assessment_request::Reason",
        repeated,
        packed = "false",
        tag = "3"
    )]
    pub reasons: ::prost::alloc::vec::Vec<i32>,
    /// Optional. A stable account identifier to apply to the assessment. This is
    /// an alternative to setting `account_id` in `CreateAssessment`, for example
    /// when a stable account identifier is not yet known in the initial request.
    #[prost(string, tag = "7")]
    pub account_id: ::prost::alloc::string::String,
    /// Optional. A stable hashed account identifier to apply to the assessment.
    /// This is an alternative to setting `hashed_account_id` in
    /// `CreateAssessment`, for example when a stable account identifier is not yet
    /// known in the initial request.
    #[prost(bytes = "vec", tag = "4")]
    pub hashed_account_id: ::prost::alloc::vec::Vec<u8>,
    /// Optional. If the assessment is part of a payment transaction, provide
    /// details on payment lifecycle events that occur in the transaction.
    #[prost(message, optional, tag = "5")]
    pub transaction_event: ::core::option::Option<TransactionEvent>,
}
/// Nested message and enum types in `AnnotateAssessmentRequest`.
pub mod annotate_assessment_request {
    /// Enum that represents the types of annotations.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Annotation {
        /// Default unspecified type.
        Unspecified = 0,
        /// Provides information that the event turned out to be legitimate.
        Legitimate = 1,
        /// Provides information that the event turned out to be fraudulent.
        Fraudulent = 2,
        /// Provides information that the event was related to a login event in which
        /// the user typed the correct password. Deprecated, prefer indicating
        /// CORRECT_PASSWORD through the reasons field instead.
        PasswordCorrect = 3,
        /// Provides information that the event was related to a login event in which
        /// the user typed the incorrect password. Deprecated, prefer indicating
        /// INCORRECT_PASSWORD through the reasons field instead.
        PasswordIncorrect = 4,
    }
    impl Annotation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ANNOTATION_UNSPECIFIED",
                Self::Legitimate => "LEGITIMATE",
                Self::Fraudulent => "FRAUDULENT",
                Self::PasswordCorrect => "PASSWORD_CORRECT",
                Self::PasswordIncorrect => "PASSWORD_INCORRECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ANNOTATION_UNSPECIFIED" => Some(Self::Unspecified),
                "LEGITIMATE" => Some(Self::Legitimate),
                "FRAUDULENT" => Some(Self::Fraudulent),
                "PASSWORD_CORRECT" => Some(Self::PasswordCorrect),
                "PASSWORD_INCORRECT" => Some(Self::PasswordIncorrect),
                _ => None,
            }
        }
    }
    /// Enum that represents potential reasons for annotating an assessment.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Reason {
        /// Default unspecified reason.
        Unspecified = 0,
        /// Indicates that the transaction had a chargeback issued with no other
        /// details. When possible, specify the type by using CHARGEBACK_FRAUD or
        /// CHARGEBACK_DISPUTE instead.
        Chargeback = 1,
        /// Indicates that the transaction had a chargeback issued related to an
        /// alleged unauthorized transaction from the cardholder's perspective (for
        /// example, the card number was stolen).
        ChargebackFraud = 8,
        /// Indicates that the transaction had a chargeback issued related to the
        /// cardholder having provided their card details but allegedly not being
        /// satisfied with the purchase (for example, misrepresentation, attempted
        /// cancellation).
        ChargebackDispute = 9,
        /// Indicates that the completed payment transaction was refunded by the
        /// seller.
        Refund = 10,
        /// Indicates that the completed payment transaction was determined to be
        /// fraudulent by the seller, and was cancelled and refunded as a result.
        RefundFraud = 11,
        /// Indicates that the payment transaction was accepted, and the user was
        /// charged.
        TransactionAccepted = 12,
        /// Indicates that the payment transaction was declined, for example due to
        /// invalid card details.
        TransactionDeclined = 13,
        /// Indicates the transaction associated with the assessment is suspected of
        /// being fraudulent based on the payment method, billing details, shipping
        /// address or other transaction information.
        PaymentHeuristics = 2,
        /// Indicates that the user was served a 2FA challenge. An old assessment
        /// with `ENUM_VALUES.INITIATED_TWO_FACTOR` reason that has not been
        /// overwritten with `PASSED_TWO_FACTOR` is treated as an abandoned 2FA flow.
        /// This is equivalent to `FAILED_TWO_FACTOR`.
        InitiatedTwoFactor = 7,
        /// Indicates that the user passed a 2FA challenge.
        PassedTwoFactor = 3,
        /// Indicates that the user failed a 2FA challenge.
        FailedTwoFactor = 4,
        /// Indicates the user provided the correct password.
        CorrectPassword = 5,
        /// Indicates the user provided an incorrect password.
        IncorrectPassword = 6,
        /// Indicates that the user sent unwanted and abusive messages to other users
        /// of the platform, such as spam, scams, phishing, or social engineering.
        SocialSpam = 14,
    }
    impl Reason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "REASON_UNSPECIFIED",
                Self::Chargeback => "CHARGEBACK",
                Self::ChargebackFraud => "CHARGEBACK_FRAUD",
                Self::ChargebackDispute => "CHARGEBACK_DISPUTE",
                Self::Refund => "REFUND",
                Self::RefundFraud => "REFUND_FRAUD",
                Self::TransactionAccepted => "TRANSACTION_ACCEPTED",
                Self::TransactionDeclined => "TRANSACTION_DECLINED",
                Self::PaymentHeuristics => "PAYMENT_HEURISTICS",
                Self::InitiatedTwoFactor => "INITIATED_TWO_FACTOR",
                Self::PassedTwoFactor => "PASSED_TWO_FACTOR",
                Self::FailedTwoFactor => "FAILED_TWO_FACTOR",
                Self::CorrectPassword => "CORRECT_PASSWORD",
                Self::IncorrectPassword => "INCORRECT_PASSWORD",
                Self::SocialSpam => "SOCIAL_SPAM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "CHARGEBACK" => Some(Self::Chargeback),
                "CHARGEBACK_FRAUD" => Some(Self::ChargebackFraud),
                "CHARGEBACK_DISPUTE" => Some(Self::ChargebackDispute),
                "REFUND" => Some(Self::Refund),
                "REFUND_FRAUD" => Some(Self::RefundFraud),
                "TRANSACTION_ACCEPTED" => Some(Self::TransactionAccepted),
                "TRANSACTION_DECLINED" => Some(Self::TransactionDeclined),
                "PAYMENT_HEURISTICS" => Some(Self::PaymentHeuristics),
                "INITIATED_TWO_FACTOR" => Some(Self::InitiatedTwoFactor),
                "PASSED_TWO_FACTOR" => Some(Self::PassedTwoFactor),
                "FAILED_TWO_FACTOR" => Some(Self::FailedTwoFactor),
                "CORRECT_PASSWORD" => Some(Self::CorrectPassword),
                "INCORRECT_PASSWORD" => Some(Self::IncorrectPassword),
                "SOCIAL_SPAM" => Some(Self::SocialSpam),
                _ => None,
            }
        }
    }
}
/// Empty response for AnnotateAssessment.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnnotateAssessmentResponse {}
/// Information about a verification endpoint that can be used for 2FA.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndpointVerificationInfo {
    /// Output only. Token to provide to the client to trigger endpoint
    /// verification. It must be used within 15 minutes.
    #[prost(string, tag = "3")]
    pub request_token: ::prost::alloc::string::String,
    /// Output only. Timestamp of the last successful verification for the
    /// endpoint, if any.
    #[prost(message, optional, tag = "4")]
    pub last_verification_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "endpoint_verification_info::Endpoint", tags = "1, 2")]
    pub endpoint: ::core::option::Option<endpoint_verification_info::Endpoint>,
}
/// Nested message and enum types in `EndpointVerificationInfo`.
pub mod endpoint_verification_info {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Endpoint {
        /// Email address for which to trigger a verification request.
        #[prost(string, tag = "1")]
        EmailAddress(::prost::alloc::string::String),
        /// Phone number for which to trigger a verification request. Should be given
        /// in E.164 format.
        #[prost(string, tag = "2")]
        PhoneNumber(::prost::alloc::string::String),
    }
}
/// Information about account verification, used for identity verification.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountVerificationInfo {
    /// Optional. Endpoints that can be used for identity verification.
    #[prost(message, repeated, tag = "1")]
    pub endpoints: ::prost::alloc::vec::Vec<EndpointVerificationInfo>,
    /// Optional. Language code preference for the verification message, set as a
    /// IETF BCP 47 language code.
    #[prost(string, tag = "3")]
    pub language_code: ::prost::alloc::string::String,
    /// Output only. Result of the latest account verification challenge.
    #[prost(enumeration = "account_verification_info::Result", tag = "7")]
    pub latest_verification_result: i32,
    /// Username of the account that is being verified. Deprecated. Customers
    /// should now provide the `account_id` field in `event.user_info`.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub username: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AccountVerificationInfo`.
pub mod account_verification_info {
    /// Result of the account verification as contained in the verdict token issued
    /// at the end of the verification flow.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Result {
        /// No information about the latest account verification.
        Unspecified = 0,
        /// The user was successfully verified. This means the account verification
        /// challenge was successfully completed.
        SuccessUserVerified = 1,
        /// The user failed the verification challenge.
        ErrorUserNotVerified = 2,
        /// The site is not properly onboarded to use the account verification
        /// feature.
        ErrorSiteOnboardingIncomplete = 3,
        /// The recipient is not allowed for account verification. This can occur
        /// during integration but should not occur in production.
        ErrorRecipientNotAllowed = 4,
        /// The recipient has already been sent too many verification codes in a
        /// short amount of time.
        ErrorRecipientAbuseLimitExhausted = 5,
        /// The verification flow could not be completed due to a critical internal
        /// error.
        ErrorCriticalInternal = 6,
        /// The client has exceeded their two factor request quota for this period of
        /// time.
        ErrorCustomerQuotaExhausted = 7,
        /// The request cannot be processed at the time because of an incident. This
        /// bypass can be restricted to a problematic destination email domain, a
        /// customer, or could affect the entire service.
        ErrorVerificationBypassed = 8,
        /// The request parameters do not match with the token provided and cannot be
        /// processed.
        ErrorVerdictMismatch = 9,
    }
    impl Result {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESULT_UNSPECIFIED",
                Self::SuccessUserVerified => "SUCCESS_USER_VERIFIED",
                Self::ErrorUserNotVerified => "ERROR_USER_NOT_VERIFIED",
                Self::ErrorSiteOnboardingIncomplete => "ERROR_SITE_ONBOARDING_INCOMPLETE",
                Self::ErrorRecipientNotAllowed => "ERROR_RECIPIENT_NOT_ALLOWED",
                Self::ErrorRecipientAbuseLimitExhausted => {
                    "ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED"
                }
                Self::ErrorCriticalInternal => "ERROR_CRITICAL_INTERNAL",
                Self::ErrorCustomerQuotaExhausted => "ERROR_CUSTOMER_QUOTA_EXHAUSTED",
                Self::ErrorVerificationBypassed => "ERROR_VERIFICATION_BYPASSED",
                Self::ErrorVerdictMismatch => "ERROR_VERDICT_MISMATCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESULT_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCESS_USER_VERIFIED" => Some(Self::SuccessUserVerified),
                "ERROR_USER_NOT_VERIFIED" => Some(Self::ErrorUserNotVerified),
                "ERROR_SITE_ONBOARDING_INCOMPLETE" => {
                    Some(Self::ErrorSiteOnboardingIncomplete)
                }
                "ERROR_RECIPIENT_NOT_ALLOWED" => Some(Self::ErrorRecipientNotAllowed),
                "ERROR_RECIPIENT_ABUSE_LIMIT_EXHAUSTED" => {
                    Some(Self::ErrorRecipientAbuseLimitExhausted)
                }
                "ERROR_CRITICAL_INTERNAL" => Some(Self::ErrorCriticalInternal),
                "ERROR_CUSTOMER_QUOTA_EXHAUSTED" => {
                    Some(Self::ErrorCustomerQuotaExhausted)
                }
                "ERROR_VERIFICATION_BYPASSED" => Some(Self::ErrorVerificationBypassed),
                "ERROR_VERDICT_MISMATCH" => Some(Self::ErrorVerdictMismatch),
                _ => None,
            }
        }
    }
}
/// Private password leak verification info.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivatePasswordLeakVerification {
    /// Required. Exactly 26-bit prefix of the SHA-256 hash of the canonicalized
    /// username. It is used to look up password leaks associated with that hash
    /// prefix.
    #[prost(bytes = "vec", tag = "1")]
    pub lookup_hash_prefix: ::prost::alloc::vec::Vec<u8>,
    /// Optional. Encrypted Scrypt hash of the canonicalized username+password. It
    /// is re-encrypted by the server and returned through
    /// `reencrypted_user_credentials_hash`.
    #[prost(bytes = "vec", tag = "2")]
    pub encrypted_user_credentials_hash: ::prost::alloc::vec::Vec<u8>,
    /// Output only. List of prefixes of the encrypted potential password leaks
    /// that matched the given parameters. They must be compared with the
    /// client-side decryption prefix of `reencrypted_user_credentials_hash`
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub encrypted_leak_match_prefixes: ::prost::alloc::vec::Vec<
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// Output only. Corresponds to the re-encryption of the
    /// `encrypted_user_credentials_hash` field. It is used to match potential
    /// password leaks within `encrypted_leak_match_prefixes`.
    #[prost(bytes = "vec", tag = "4")]
    pub reencrypted_user_credentials_hash: ::prost::alloc::vec::Vec<u8>,
}
/// A reCAPTCHA Enterprise assessment resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Assessment {
    /// Output only. Identifier. The resource name for the Assessment in the format
    /// `projects/{project}/assessments/{assessment}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The event being assessed.
    #[prost(message, optional, tag = "2")]
    pub event: ::core::option::Option<Event>,
    /// Output only. The risk analysis result for the event being assessed.
    #[prost(message, optional, tag = "3")]
    pub risk_analysis: ::core::option::Option<RiskAnalysis>,
    /// Output only. Properties of the provided event token.
    #[prost(message, optional, tag = "4")]
    pub token_properties: ::core::option::Option<TokenProperties>,
    /// Optional. Account verification information for identity verification. The
    /// assessment event must include a token and site key to use this feature.
    #[prost(message, optional, tag = "5")]
    pub account_verification: ::core::option::Option<AccountVerificationInfo>,
    /// Output only. Assessment returned by account defender when an account
    /// identifier is provided.
    #[prost(message, optional, tag = "6")]
    pub account_defender_assessment: ::core::option::Option<AccountDefenderAssessment>,
    /// Optional. The private password leak verification field contains the
    /// parameters that are used to to check for leaks privately without sharing
    /// user credentials.
    #[prost(message, optional, tag = "8")]
    pub private_password_leak_verification: ::core::option::Option<
        PrivatePasswordLeakVerification,
    >,
    /// Output only. Assessment returned when firewall policies belonging to the
    /// project are evaluated using the field firewall_policy_evaluation.
    #[prost(message, optional, tag = "10")]
    pub firewall_policy_assessment: ::core::option::Option<FirewallPolicyAssessment>,
    /// Output only. Assessment returned by Fraud Prevention when TransactionData
    /// is provided.
    #[prost(message, optional, tag = "11")]
    pub fraud_prevention_assessment: ::core::option::Option<FraudPreventionAssessment>,
    /// Output only. Fraud Signals specific to the users involved in a payment
    /// transaction.
    #[prost(message, optional, tag = "13")]
    pub fraud_signals: ::core::option::Option<FraudSignals>,
    /// Output only. Assessment returned when a site key, a token, and a phone
    /// number as `user_id` are provided. Account defender and SMS toll fraud
    /// protection need to be enabled.
    #[prost(message, optional, tag = "12")]
    pub phone_fraud_assessment: ::core::option::Option<PhoneFraudAssessment>,
    /// Optional. The environment creating the assessment. This describes your
    /// environment (the system invoking CreateAssessment), NOT the environment of
    /// your user.
    #[prost(message, optional, tag = "14")]
    pub assessment_environment: ::core::option::Option<AssessmentEnvironment>,
}
/// The event being assessed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    /// Optional. The user response token provided by the reCAPTCHA Enterprise
    /// client-side integration on your site.
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    /// Optional. The site key that was used to invoke reCAPTCHA Enterprise on your
    /// site and generate the token.
    #[prost(string, tag = "2")]
    pub site_key: ::prost::alloc::string::String,
    /// Optional. The user agent present in the request from the user's device
    /// related to this event.
    #[prost(string, tag = "3")]
    pub user_agent: ::prost::alloc::string::String,
    /// Optional. The IP address in the request from the user's device related to
    /// this event.
    #[prost(string, tag = "4")]
    pub user_ip_address: ::prost::alloc::string::String,
    /// Optional. The expected action for this type of event. This should be the
    /// same action provided at token generation time on client-side platforms
    /// already integrated with recaptcha enterprise.
    #[prost(string, tag = "5")]
    pub expected_action: ::prost::alloc::string::String,
    /// Optional. Deprecated: use `user_info.account_id` instead.
    /// Unique stable hashed user identifier for the request. The identifier must
    /// be hashed using hmac-sha256 with stable secret.
    #[deprecated]
    #[prost(bytes = "vec", tag = "6")]
    pub hashed_account_id: ::prost::alloc::vec::Vec<u8>,
    /// Optional. Flag for a reCAPTCHA express request for an assessment without a
    /// token. If enabled, `site_key` must reference an Express site key.
    #[prost(bool, tag = "14")]
    pub express: bool,
    /// Optional. The URI resource the user requested that triggered an assessment.
    #[prost(string, tag = "8")]
    pub requested_uri: ::prost::alloc::string::String,
    /// Optional. Flag for running WAF token assessment.
    /// If enabled, the token must be specified, and have been created by a
    /// WAF-enabled key.
    #[prost(bool, tag = "9")]
    pub waf_token_assessment: bool,
    /// Optional. JA3 fingerprint for SSL clients.
    #[prost(string, tag = "10")]
    pub ja3: ::prost::alloc::string::String,
    /// Optional. HTTP header information about the request.
    #[prost(string, repeated, tag = "11")]
    pub headers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Flag for enabling firewall policy config assessment.
    /// If this flag is enabled, the firewall policy is evaluated and a
    /// suggested firewall action is returned in the response.
    #[prost(bool, tag = "12")]
    pub firewall_policy_evaluation: bool,
    /// Optional. Data describing a payment transaction to be assessed. Sending
    /// this data enables reCAPTCHA Enterprise Fraud Prevention and the
    /// FraudPreventionAssessment component in the response.
    #[prost(message, optional, tag = "13")]
    pub transaction_data: ::core::option::Option<TransactionData>,
    /// Optional. Information about the user that generates this event, when they
    /// can be identified. They are often identified through the use of an account
    /// for logged-in requests or login/registration requests, or by providing user
    /// identifiers for guest actions like checkout.
    #[prost(message, optional, tag = "15")]
    pub user_info: ::core::option::Option<UserInfo>,
    /// Optional. The Fraud Prevention setting for this assessment.
    #[prost(enumeration = "event::FraudPrevention", tag = "17")]
    pub fraud_prevention: i32,
}
/// Nested message and enum types in `Event`.
pub mod event {
    /// Setting that controls Fraud Prevention assessments.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FraudPrevention {
        /// Default, unspecified setting. `fraud_prevention_assessment` is returned
        /// if `transaction_data` is present in `Event` and Fraud Prevention is
        /// enabled in the Google Cloud console.
        Unspecified = 0,
        /// Enable Fraud Prevention for this assessment, if Fraud Prevention is
        /// enabled in the Google Cloud console.
        Enabled = 1,
        /// Disable Fraud Prevention for this assessment, regardless of Google Cloud
        /// console settings.
        Disabled = 2,
    }
    impl FraudPrevention {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FRAUD_PREVENTION_UNSPECIFIED",
                Self::Enabled => "ENABLED",
                Self::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FRAUD_PREVENTION_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
/// Transaction data associated with a payment protected by reCAPTCHA Enterprise.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionData {
    /// Unique identifier for the transaction. This custom identifier can be used
    /// to reference this transaction in the future, for example, labeling a refund
    /// or chargeback event. Two attempts at the same transaction should use the
    /// same transaction id.
    #[prost(string, optional, tag = "11")]
    pub transaction_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The payment method for the transaction. The allowed values are:
    ///
    /// * credit-card
    /// * debit-card
    /// * gift-card
    /// * processor-{name} (If a third-party is used, for example,
    /// processor-paypal)
    /// * custom-{name} (If an alternative method is used, for example,
    /// custom-crypto)
    #[prost(string, tag = "1")]
    pub payment_method: ::prost::alloc::string::String,
    /// Optional. The Bank Identification Number - generally the first 6 or 8
    /// digits of the card.
    #[prost(string, tag = "2")]
    pub card_bin: ::prost::alloc::string::String,
    /// Optional. The last four digits of the card.
    #[prost(string, tag = "3")]
    pub card_last_four: ::prost::alloc::string::String,
    /// Optional. The currency code in ISO-4217 format.
    #[prost(string, tag = "4")]
    pub currency_code: ::prost::alloc::string::String,
    /// Optional. The decimal value of the transaction in the specified currency.
    #[prost(double, tag = "5")]
    pub value: f64,
    /// Optional. The value of shipping in the specified currency. 0 for free or no
    /// shipping.
    #[prost(double, tag = "12")]
    pub shipping_value: f64,
    /// Optional. Destination address if this transaction involves shipping a
    /// physical item.
    #[prost(message, optional, tag = "6")]
    pub shipping_address: ::core::option::Option<transaction_data::Address>,
    /// Optional. Address associated with the payment method when applicable.
    #[prost(message, optional, tag = "7")]
    pub billing_address: ::core::option::Option<transaction_data::Address>,
    /// Optional. Information about the user paying/initiating the transaction.
    #[prost(message, optional, tag = "8")]
    pub user: ::core::option::Option<transaction_data::User>,
    /// Optional. Information about the user or users fulfilling the transaction.
    #[prost(message, repeated, tag = "13")]
    pub merchants: ::prost::alloc::vec::Vec<transaction_data::User>,
    /// Optional. Items purchased in this transaction.
    #[prost(message, repeated, tag = "14")]
    pub items: ::prost::alloc::vec::Vec<transaction_data::Item>,
    /// Optional. Information about the payment gateway's response to the
    /// transaction.
    #[prost(message, optional, tag = "10")]
    pub gateway_info: ::core::option::Option<transaction_data::GatewayInfo>,
}
/// Nested message and enum types in `TransactionData`.
pub mod transaction_data {
    /// Structured address format for billing and shipping addresses.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Address {
        /// Optional. The recipient name, potentially including information such as
        /// "care of".
        #[prost(string, tag = "1")]
        pub recipient: ::prost::alloc::string::String,
        /// Optional. The first lines of the address. The first line generally
        /// contains the street name and number, and further lines may include
        /// information such as an apartment number.
        #[prost(string, repeated, tag = "2")]
        pub address: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. The town/city of the address.
        #[prost(string, tag = "3")]
        pub locality: ::prost::alloc::string::String,
        /// Optional. The state, province, or otherwise administrative area of the
        /// address.
        #[prost(string, tag = "4")]
        pub administrative_area: ::prost::alloc::string::String,
        /// Optional. The CLDR country/region of the address.
        #[prost(string, tag = "5")]
        pub region_code: ::prost::alloc::string::String,
        /// Optional. The postal or ZIP code of the address.
        #[prost(string, tag = "6")]
        pub postal_code: ::prost::alloc::string::String,
    }
    /// Details about a user's account involved in the transaction.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct User {
        /// Optional. Unique account identifier for this user. If using account
        /// defender, this should match the hashed_account_id field. Otherwise, a
        /// unique and persistent identifier for this account.
        #[prost(string, tag = "6")]
        pub account_id: ::prost::alloc::string::String,
        /// Optional. The epoch milliseconds of the user's account creation.
        #[prost(int64, tag = "1")]
        pub creation_ms: i64,
        /// Optional. The email address of the user.
        #[prost(string, tag = "2")]
        pub email: ::prost::alloc::string::String,
        /// Optional. Whether the email has been verified to be accessible by the
        /// user (OTP or similar).
        #[prost(bool, tag = "3")]
        pub email_verified: bool,
        /// Optional. The phone number of the user, with country code.
        #[prost(string, tag = "4")]
        pub phone_number: ::prost::alloc::string::String,
        /// Optional. Whether the phone number has been verified to be accessible by
        /// the user (OTP or similar).
        #[prost(bool, tag = "5")]
        pub phone_verified: bool,
    }
    /// Line items being purchased in this transaction.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Item {
        /// Optional. The full name of the item.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Optional. The value per item that the user is paying, in the transaction
        /// currency, after discounts.
        #[prost(double, tag = "2")]
        pub value: f64,
        /// Optional. The quantity of this item that is being purchased.
        #[prost(int64, tag = "3")]
        pub quantity: i64,
        /// Optional. When a merchant is specified, its corresponding account_id.
        /// Necessary to populate marketplace-style transactions.
        #[prost(string, tag = "4")]
        pub merchant_account_id: ::prost::alloc::string::String,
    }
    /// Details about the transaction from the gateway.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GatewayInfo {
        /// Optional. Name of the gateway service (for example, stripe, square,
        /// paypal).
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Optional. Gateway response code describing the state of the transaction.
        #[prost(string, tag = "2")]
        pub gateway_response_code: ::prost::alloc::string::String,
        /// Optional. AVS response code from the gateway
        /// (available only when reCAPTCHA Enterprise is called after authorization).
        #[prost(string, tag = "3")]
        pub avs_response_code: ::prost::alloc::string::String,
        /// Optional. CVV response code from the gateway
        /// (available only when reCAPTCHA Enterprise is called after authorization).
        #[prost(string, tag = "4")]
        pub cvv_response_code: ::prost::alloc::string::String,
    }
}
/// User information associated with a request protected by reCAPTCHA Enterprise.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserInfo {
    /// Optional. Creation time for this account associated with this user. Leave
    /// blank for non logged-in actions, guest checkout, or when there is no
    /// account associated with the current user.
    #[prost(message, optional, tag = "1")]
    pub create_account_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. For logged-in requests or login/registration requests, the unique
    /// account identifier associated with this user. You can use the username if
    /// it is stable (meaning it is the same for every request associated with the
    /// same user), or any stable user ID of your choice. Leave blank for non
    /// logged-in actions or guest checkout.
    #[prost(string, tag = "2")]
    pub account_id: ::prost::alloc::string::String,
    /// Optional. Identifiers associated with this user or request.
    #[prost(message, repeated, tag = "3")]
    pub user_ids: ::prost::alloc::vec::Vec<UserId>,
}
/// An identifier associated with a user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserId {
    #[prost(oneof = "user_id::IdOneof", tags = "1, 2, 3")]
    pub id_oneof: ::core::option::Option<user_id::IdOneof>,
}
/// Nested message and enum types in `UserId`.
pub mod user_id {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum IdOneof {
        /// Optional. An email address.
        #[prost(string, tag = "1")]
        Email(::prost::alloc::string::String),
        /// Optional. A phone number. Should use the E.164 format.
        #[prost(string, tag = "2")]
        PhoneNumber(::prost::alloc::string::String),
        /// Optional. A unique username, if different from all the other identifiers
        /// and `account_id` that are provided. Can be a unique login handle or
        /// display name for a user.
        #[prost(string, tag = "3")]
        Username(::prost::alloc::string::String),
    }
}
/// Risk analysis result for an event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RiskAnalysis {
    /// Output only. Legitimate event score from 0.0 to 1.0.
    /// (1.0 means very likely legitimate traffic while 0.0 means very likely
    /// non-legitimate traffic).
    #[prost(float, tag = "1")]
    pub score: f32,
    /// Output only. Reasons contributing to the risk analysis verdict.
    #[prost(
        enumeration = "risk_analysis::ClassificationReason",
        repeated,
        packed = "false",
        tag = "2"
    )]
    pub reasons: ::prost::alloc::vec::Vec<i32>,
    /// Output only. Extended verdict reasons to be used for experimentation only.
    /// The set of possible reasons is subject to change.
    #[prost(string, repeated, tag = "3")]
    pub extended_verdict_reasons: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Output only. Challenge information for SCORE_AND_CHALLENGE and INVISIBLE
    /// keys
    #[prost(enumeration = "risk_analysis::Challenge", tag = "4")]
    pub challenge: i32,
}
/// Nested message and enum types in `RiskAnalysis`.
pub mod risk_analysis {
    /// Reasons contributing to the risk analysis verdict.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ClassificationReason {
        /// Default unspecified type.
        Unspecified = 0,
        /// Interactions matched the behavior of an automated agent.
        Automation = 1,
        /// The event originated from an illegitimate environment.
        UnexpectedEnvironment = 2,
        /// Traffic volume from the event source is higher than normal.
        TooMuchTraffic = 3,
        /// Interactions with the site were significantly different than expected
        /// patterns.
        UnexpectedUsagePatterns = 4,
        /// Too little traffic has been received from this site thus far to generate
        /// quality risk analysis.
        LowConfidenceScore = 5,
        /// The request matches behavioral characteristics of a carding attack.
        SuspectedCarding = 6,
        /// The request matches behavioral characteristics of chargebacks for fraud.
        SuspectedChargeback = 7,
    }
    impl ClassificationReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CLASSIFICATION_REASON_UNSPECIFIED",
                Self::Automation => "AUTOMATION",
                Self::UnexpectedEnvironment => "UNEXPECTED_ENVIRONMENT",
                Self::TooMuchTraffic => "TOO_MUCH_TRAFFIC",
                Self::UnexpectedUsagePatterns => "UNEXPECTED_USAGE_PATTERNS",
                Self::LowConfidenceScore => "LOW_CONFIDENCE_SCORE",
                Self::SuspectedCarding => "SUSPECTED_CARDING",
                Self::SuspectedChargeback => "SUSPECTED_CHARGEBACK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLASSIFICATION_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "AUTOMATION" => Some(Self::Automation),
                "UNEXPECTED_ENVIRONMENT" => Some(Self::UnexpectedEnvironment),
                "TOO_MUCH_TRAFFIC" => Some(Self::TooMuchTraffic),
                "UNEXPECTED_USAGE_PATTERNS" => Some(Self::UnexpectedUsagePatterns),
                "LOW_CONFIDENCE_SCORE" => Some(Self::LowConfidenceScore),
                "SUSPECTED_CARDING" => Some(Self::SuspectedCarding),
                "SUSPECTED_CHARGEBACK" => Some(Self::SuspectedChargeback),
                _ => None,
            }
        }
    }
    /// Challenge information for SCORE_AND_CHALLENGE and INVISIBLE keys
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Challenge {
        /// Default unspecified type.
        Unspecified = 0,
        /// No challenge was presented for solving.
        Nocaptcha = 1,
        /// A solution was submitted that was correct.
        Passed = 2,
        /// A solution was submitted that was incorrect or otherwise
        /// deemed suspicious.
        Failed = 3,
    }
    impl Challenge {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CHALLENGE_UNSPECIFIED",
                Self::Nocaptcha => "NOCAPTCHA",
                Self::Passed => "PASSED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHALLENGE_UNSPECIFIED" => Some(Self::Unspecified),
                "NOCAPTCHA" => Some(Self::Nocaptcha),
                "PASSED" => Some(Self::Passed),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Properties of the provided event token.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenProperties {
    /// Output only. Whether the provided user response token is valid. When valid
    /// = false, the reason could be specified in invalid_reason or it could also
    /// be due to a user failing to solve a challenge or a sitekey mismatch (i.e
    /// the sitekey used to generate the token was different than the one specified
    /// in the assessment).
    #[prost(bool, tag = "1")]
    pub valid: bool,
    /// Output only. Reason associated with the response when valid = false.
    #[prost(enumeration = "token_properties::InvalidReason", tag = "2")]
    pub invalid_reason: i32,
    /// Output only. The timestamp corresponding to the generation of the token.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The hostname of the page on which the token was generated (Web
    /// keys only).
    #[prost(string, tag = "4")]
    pub hostname: ::prost::alloc::string::String,
    /// Output only. The name of the Android package with which the token was
    /// generated (Android keys only).
    #[prost(string, tag = "8")]
    pub android_package_name: ::prost::alloc::string::String,
    /// Output only. The ID of the iOS bundle with which the token was generated
    /// (iOS keys only).
    #[prost(string, tag = "9")]
    pub ios_bundle_id: ::prost::alloc::string::String,
    /// Output only. Action name provided at token generation.
    #[prost(string, tag = "5")]
    pub action: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TokenProperties`.
pub mod token_properties {
    /// Enum that represents the types of invalid token reasons.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InvalidReason {
        /// Default unspecified type.
        Unspecified = 0,
        /// If the failure reason was not accounted for.
        UnknownInvalidReason = 1,
        /// The provided user verification token was malformed.
        Malformed = 2,
        /// The user verification token had expired.
        Expired = 3,
        /// The user verification had already been seen.
        Dupe = 4,
        /// The user verification token was not present.
        Missing = 5,
        /// A retriable error (such as network failure) occurred on the browser.
        /// Could easily be simulated by an attacker.
        BrowserError = 6,
    }
    impl InvalidReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "INVALID_REASON_UNSPECIFIED",
                Self::UnknownInvalidReason => "UNKNOWN_INVALID_REASON",
                Self::Malformed => "MALFORMED",
                Self::Expired => "EXPIRED",
                Self::Dupe => "DUPE",
                Self::Missing => "MISSING",
                Self::BrowserError => "BROWSER_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INVALID_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN_INVALID_REASON" => Some(Self::UnknownInvalidReason),
                "MALFORMED" => Some(Self::Malformed),
                "EXPIRED" => Some(Self::Expired),
                "DUPE" => Some(Self::Dupe),
                "MISSING" => Some(Self::Missing),
                "BROWSER_ERROR" => Some(Self::BrowserError),
                _ => None,
            }
        }
    }
}
/// Assessment for Fraud Prevention.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FraudPreventionAssessment {
    /// Output only. Probability of this transaction being fraudulent. Summarizes
    /// the combined risk of attack vectors below. Values are from 0.0 (lowest)
    /// to 1.0 (highest).
    #[prost(float, tag = "1")]
    pub transaction_risk: f32,
    /// Output only. Assessment of this transaction for risk of a stolen
    /// instrument.
    #[prost(message, optional, tag = "2")]
    pub stolen_instrument_verdict: ::core::option::Option<
        fraud_prevention_assessment::StolenInstrumentVerdict,
    >,
    /// Output only. Assessment of this transaction for risk of being part of a
    /// card testing attack.
    #[prost(message, optional, tag = "3")]
    pub card_testing_verdict: ::core::option::Option<
        fraud_prevention_assessment::CardTestingVerdict,
    >,
    /// Output only. Assessment of this transaction for behavioral trust.
    #[prost(message, optional, tag = "4")]
    pub behavioral_trust_verdict: ::core::option::Option<
        fraud_prevention_assessment::BehavioralTrustVerdict,
    >,
}
/// Nested message and enum types in `FraudPreventionAssessment`.
pub mod fraud_prevention_assessment {
    /// Information about stolen instrument fraud, where the user is not the
    /// legitimate owner of the instrument being used for the purchase.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct StolenInstrumentVerdict {
        /// Output only. Probability of this transaction being executed with a stolen
        /// instrument. Values are from 0.0 (lowest) to 1.0 (highest).
        #[prost(float, tag = "1")]
        pub risk: f32,
    }
    /// Information about card testing fraud, where an adversary is testing
    /// fraudulently obtained cards or brute forcing their details.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CardTestingVerdict {
        /// Output only. Probability of this transaction attempt being part of a card
        /// testing attack. Values are from 0.0 (lowest) to 1.0 (highest).
        #[prost(float, tag = "1")]
        pub risk: f32,
    }
    /// Information about behavioral trust of the transaction.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BehavioralTrustVerdict {
        /// Output only. Probability of this transaction attempt being executed in a
        /// behaviorally trustworthy way. Values are from 0.0 (lowest) to 1.0
        /// (highest).
        #[prost(float, tag = "1")]
        pub trust: f32,
    }
}
/// Fraud signals describing users and cards involved in the transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FraudSignals {
    /// Output only. Signals describing the end user in this transaction.
    #[prost(message, optional, tag = "1")]
    pub user_signals: ::core::option::Option<fraud_signals::UserSignals>,
    /// Output only. Signals describing the payment card or cards used in this
    /// transaction.
    #[prost(message, optional, tag = "2")]
    pub card_signals: ::core::option::Option<fraud_signals::CardSignals>,
}
/// Nested message and enum types in `FraudSignals`.
pub mod fraud_signals {
    /// Signals describing the user involved in this transaction.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UserSignals {
        /// Output only. This user (based on email, phone, and other identifiers) has
        /// been seen on the internet for at least this number of days.
        #[prost(int32, tag = "1")]
        pub active_days_lower_bound: i32,
        /// Output only. Likelihood (from 0.0 to 1.0) this user includes synthetic
        /// components in their identity, such as a randomly generated email address,
        /// temporary phone number, or fake shipping address.
        #[prost(float, tag = "2")]
        pub synthetic_risk: f32,
    }
    /// Signals describing the payment card used in this transaction.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CardSignals {
        /// Output only. The labels for the payment card in this transaction.
        #[prost(
            enumeration = "card_signals::CardLabel",
            repeated,
            packed = "false",
            tag = "1"
        )]
        pub card_labels: ::prost::alloc::vec::Vec<i32>,
    }
    /// Nested message and enum types in `CardSignals`.
    pub mod card_signals {
        /// Risk labels describing the card being assessed, such as its funding
        /// mechanism.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum CardLabel {
            /// No label specified.
            Unspecified = 0,
            /// This card has been detected as prepaid.
            Prepaid = 1,
            /// This card has been detected as virtual, such as a card number generated
            /// for a single transaction or merchant.
            Virtual = 2,
            /// This card has been detected as being used in an unexpected geographic
            /// location.
            UnexpectedLocation = 3,
        }
        impl CardLabel {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "CARD_LABEL_UNSPECIFIED",
                    Self::Prepaid => "PREPAID",
                    Self::Virtual => "VIRTUAL",
                    Self::UnexpectedLocation => "UNEXPECTED_LOCATION",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CARD_LABEL_UNSPECIFIED" => Some(Self::Unspecified),
                    "PREPAID" => Some(Self::Prepaid),
                    "VIRTUAL" => Some(Self::Virtual),
                    "UNEXPECTED_LOCATION" => Some(Self::UnexpectedLocation),
                    _ => None,
                }
            }
        }
    }
}
/// Information about SMS toll fraud.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmsTollFraudVerdict {
    /// Output only. Probability of an SMS event being fraudulent.
    /// Values are from 0.0 (lowest) to 1.0 (highest).
    #[prost(float, tag = "1")]
    pub risk: f32,
    /// Output only. Reasons contributing to the SMS toll fraud verdict.
    #[prost(
        enumeration = "sms_toll_fraud_verdict::SmsTollFraudReason",
        repeated,
        packed = "false",
        tag = "2"
    )]
    pub reasons: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `SmsTollFraudVerdict`.
pub mod sms_toll_fraud_verdict {
    /// Reasons contributing to the SMS toll fraud verdict.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SmsTollFraudReason {
        /// Default unspecified reason
        Unspecified = 0,
        /// The provided phone number was invalid
        InvalidPhoneNumber = 1,
    }
    impl SmsTollFraudReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SMS_TOLL_FRAUD_REASON_UNSPECIFIED",
                Self::InvalidPhoneNumber => "INVALID_PHONE_NUMBER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SMS_TOLL_FRAUD_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "INVALID_PHONE_NUMBER" => Some(Self::InvalidPhoneNumber),
                _ => None,
            }
        }
    }
}
/// Assessment for Phone Fraud
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhoneFraudAssessment {
    /// Output only. Assessment of this phone event for risk of SMS toll fraud.
    #[prost(message, optional, tag = "1")]
    pub sms_toll_fraud_verdict: ::core::option::Option<SmsTollFraudVerdict>,
}
/// Account defender risk assessment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountDefenderAssessment {
    /// Output only. Labels for this request.
    #[prost(
        enumeration = "account_defender_assessment::AccountDefenderLabel",
        repeated,
        packed = "false",
        tag = "1"
    )]
    pub labels: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `AccountDefenderAssessment`.
pub mod account_defender_assessment {
    /// Labels returned by account defender for this request.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountDefenderLabel {
        /// Default unspecified type.
        Unspecified = 0,
        /// The request matches a known good profile for the user.
        ProfileMatch = 1,
        /// The request is potentially a suspicious login event and must be further
        /// verified either through multi-factor authentication or another system.
        SuspiciousLoginActivity = 2,
        /// The request matched a profile that previously had suspicious account
        /// creation behavior. This can mean that this is a fake account.
        SuspiciousAccountCreation = 3,
        /// The account in the request has a high number of related accounts. It does
        /// not necessarily imply that the account is bad but can require further
        /// investigation.
        RelatedAccountsNumberHigh = 4,
    }
    impl AccountDefenderLabel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ACCOUNT_DEFENDER_LABEL_UNSPECIFIED",
                Self::ProfileMatch => "PROFILE_MATCH",
                Self::SuspiciousLoginActivity => "SUSPICIOUS_LOGIN_ACTIVITY",
                Self::SuspiciousAccountCreation => "SUSPICIOUS_ACCOUNT_CREATION",
                Self::RelatedAccountsNumberHigh => "RELATED_ACCOUNTS_NUMBER_HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACCOUNT_DEFENDER_LABEL_UNSPECIFIED" => Some(Self::Unspecified),
                "PROFILE_MATCH" => Some(Self::ProfileMatch),
                "SUSPICIOUS_LOGIN_ACTIVITY" => Some(Self::SuspiciousLoginActivity),
                "SUSPICIOUS_ACCOUNT_CREATION" => Some(Self::SuspiciousAccountCreation),
                "RELATED_ACCOUNTS_NUMBER_HIGH" => Some(Self::RelatedAccountsNumberHigh),
                _ => None,
            }
        }
    }
}
/// The create key request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateKeyRequest {
    /// Required. The name of the project in which the key is created, in the
    /// format `projects/{project}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Information to create a reCAPTCHA Enterprise key.
    #[prost(message, optional, tag = "2")]
    pub key: ::core::option::Option<Key>,
}
/// The list keys request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKeysRequest {
    /// Required. The name of the project that contains the keys that is
    /// listed, in the format `projects/{project}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of keys to return. Default is 10. Max limit is
    /// 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The next_page_token value returned from a previous.
    /// ListKeysRequest, if any.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response to request to list keys in a project.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKeysResponse {
    /// Key details.
    #[prost(message, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<Key>,
    /// Token to retrieve the next page of results. It is set to empty if no keys
    /// remain in results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The retrieve legacy secret key request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveLegacySecretKeyRequest {
    /// Required. The public key name linked to the requested secret key in the
    /// format `projects/{project}/keys/{key}`.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
}
/// The get key request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetKeyRequest {
    /// Required. The name of the requested key, in the format
    /// `projects/{project}/keys/{key}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The update key request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateKeyRequest {
    /// Required. The key to update.
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<Key>,
    /// Optional. The mask to control which fields of the key get updated. If the
    /// mask is not present, all fields are updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The delete key request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteKeyRequest {
    /// Required. The name of the key to be deleted, in the format
    /// `projects/{project}/keys/{key}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The create firewall policy request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFirewallPolicyRequest {
    /// Required. The name of the project this policy applies to, in the format
    /// `projects/{project}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Information to create the policy.
    #[prost(message, optional, tag = "2")]
    pub firewall_policy: ::core::option::Option<FirewallPolicy>,
}
/// The list firewall policies request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFirewallPoliciesRequest {
    /// Required. The name of the project to list the policies for, in the format
    /// `projects/{project}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of policies to return. Default is 10. Max
    /// limit is 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The next_page_token value returned from a previous.
    /// ListFirewallPoliciesRequest, if any.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response to request to list firewall policies belonging to a project.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFirewallPoliciesResponse {
    /// Policy details.
    #[prost(message, repeated, tag = "1")]
    pub firewall_policies: ::prost::alloc::vec::Vec<FirewallPolicy>,
    /// Token to retrieve the next page of results. It is set to empty if no
    /// policies remain in results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The get firewall policy request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFirewallPolicyRequest {
    /// Required. The name of the requested policy, in the format
    /// `projects/{project}/firewallpolicies/{firewallpolicy}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The update firewall policy request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFirewallPolicyRequest {
    /// Required. The policy to update.
    #[prost(message, optional, tag = "1")]
    pub firewall_policy: ::core::option::Option<FirewallPolicy>,
    /// Optional. The mask to control which fields of the policy get updated. If
    /// the mask is not present, all fields are updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The delete firewall policy request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFirewallPolicyRequest {
    /// Required. The name of the policy to be deleted, in the format
    /// `projects/{project}/firewallpolicies/{firewallpolicy}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The reorder firewall policies request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReorderFirewallPoliciesRequest {
    /// Required. The name of the project to list the policies for, in the format
    /// `projects/{project}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. A list containing all policy names, in the new order. Each name
    /// is in the format `projects/{project}/firewallpolicies/{firewallpolicy}`.
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The reorder firewall policies response message.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReorderFirewallPoliciesResponse {}
/// The migrate key request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateKeyRequest {
    /// Required. The name of the key to be migrated, in the format
    /// `projects/{project}/keys/{key}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If true, skips the billing check.
    /// A reCAPTCHA Enterprise key or migrated key behaves differently than a
    /// reCAPTCHA (non-Enterprise version) key when you reach a quota limit (see
    /// <https://cloud.google.com/recaptcha/quotas#quota_limit>). To avoid
    /// any disruption of your usage, we check that a billing account is present.
    /// If your usage of reCAPTCHA is under the free quota, you can safely skip the
    /// billing check and proceed with the migration. See
    /// <https://cloud.google.com/recaptcha/docs/billing-information.>
    #[prost(bool, tag = "2")]
    pub skip_billing_check: bool,
}
/// The get metrics request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetricsRequest {
    /// Required. The name of the requested metrics, in the format
    /// `projects/{project}/keys/{key}/metrics`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Metrics for a single Key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metrics {
    /// Output only. Identifier. The name of the metrics, in the format
    /// `projects/{project}/keys/{key}/metrics`.
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    /// Inclusive start time aligned to a day (UTC).
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Metrics are continuous and in order by dates, and in the granularity
    /// of day. All Key types should have score-based data.
    #[prost(message, repeated, tag = "2")]
    pub score_metrics: ::prost::alloc::vec::Vec<ScoreMetrics>,
    /// Metrics are continuous and in order by dates, and in the granularity
    /// of day. Only challenge-based keys (CHECKBOX, INVISIBLE) have
    /// challenge-based data.
    #[prost(message, repeated, tag = "3")]
    pub challenge_metrics: ::prost::alloc::vec::Vec<ChallengeMetrics>,
}
/// Secret key is used only in legacy reCAPTCHA. It must be used in a 3rd party
/// integration with legacy reCAPTCHA.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveLegacySecretKeyResponse {
    /// The secret key (also known as shared secret) authorizes communication
    /// between your application backend and the reCAPTCHA Enterprise server to
    /// create an assessment.
    /// The secret key needs to be kept safe for security purposes.
    #[prost(string, tag = "1")]
    pub legacy_secret_key: ::prost::alloc::string::String,
}
/// A key used to identify and configure applications (web and/or mobile) that
/// use reCAPTCHA Enterprise.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Key {
    /// Identifier. The resource name for the Key in the format
    /// `projects/{project}/keys/{key}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Human-readable display name of this key. Modifiable by user.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. See \[Creating and managing labels\]
    /// (<https://cloud.google.com/recaptcha/docs/labels>).
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The timestamp corresponding to the creation of this key.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Options for user acceptance testing.
    #[prost(message, optional, tag = "9")]
    pub testing_options: ::core::option::Option<TestingOptions>,
    /// Optional. Settings for WAF
    #[prost(message, optional, tag = "10")]
    pub waf_settings: ::core::option::Option<WafSettings>,
    /// Platform-specific settings for this key. The key can only be used on a
    /// platform for which the settings are enabled.
    #[prost(oneof = "key::PlatformSettings", tags = "3, 4, 5, 11")]
    pub platform_settings: ::core::option::Option<key::PlatformSettings>,
}
/// Nested message and enum types in `Key`.
pub mod key {
    /// Platform-specific settings for this key. The key can only be used on a
    /// platform for which the settings are enabled.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PlatformSettings {
        /// Settings for keys that can be used by websites.
        #[prost(message, tag = "3")]
        WebSettings(super::WebKeySettings),
        /// Settings for keys that can be used by Android apps.
        #[prost(message, tag = "4")]
        AndroidSettings(super::AndroidKeySettings),
        /// Settings for keys that can be used by iOS apps.
        #[prost(message, tag = "5")]
        IosSettings(super::IosKeySettings),
        /// Settings for keys that can be used by reCAPTCHA Express.
        #[prost(message, tag = "11")]
        ExpressSettings(super::ExpressKeySettings),
    }
}
/// Options for user acceptance testing.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TestingOptions {
    /// Optional. All assessments for this Key return this score. Must be between 0
    /// (likely not legitimate) and 1 (likely legitimate) inclusive.
    #[prost(float, tag = "1")]
    pub testing_score: f32,
    /// Optional. For challenge-based keys only (CHECKBOX, INVISIBLE), all
    /// challenge requests for this site return nocaptcha if NOCAPTCHA, or an
    /// unsolvable challenge if CHALLENGE.
    #[prost(enumeration = "testing_options::TestingChallenge", tag = "2")]
    pub testing_challenge: i32,
}
/// Nested message and enum types in `TestingOptions`.
pub mod testing_options {
    /// Enum that represents the challenge option for challenge-based (CHECKBOX,
    /// INVISIBLE) testing keys.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TestingChallenge {
        /// Perform the normal risk analysis and return either nocaptcha or a
        /// challenge depending on risk and trust factors.
        Unspecified = 0,
        /// Challenge requests for this key always return a nocaptcha, which
        /// does not require a solution.
        Nocaptcha = 1,
        /// Challenge requests for this key always return an unsolvable
        /// challenge.
        UnsolvableChallenge = 2,
    }
    impl TestingChallenge {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TESTING_CHALLENGE_UNSPECIFIED",
                Self::Nocaptcha => "NOCAPTCHA",
                Self::UnsolvableChallenge => "UNSOLVABLE_CHALLENGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TESTING_CHALLENGE_UNSPECIFIED" => Some(Self::Unspecified),
                "NOCAPTCHA" => Some(Self::Nocaptcha),
                "UNSOLVABLE_CHALLENGE" => Some(Self::UnsolvableChallenge),
                _ => None,
            }
        }
    }
}
/// Settings specific to keys that can be used by websites.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebKeySettings {
    /// Optional. If set to true, it means allowed_domains are not enforced.
    #[prost(bool, tag = "3")]
    pub allow_all_domains: bool,
    /// Optional. Domains or subdomains of websites allowed to use the key. All
    /// subdomains of an allowed domain are automatically allowed. A valid domain
    /// requires a host and must not include any path, port, query or fragment.
    /// Examples: 'example.com' or 'subdomain.example.com'
    #[prost(string, repeated, tag = "1")]
    pub allowed_domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. If set to true, the key can be used on AMP (Accelerated Mobile
    /// Pages) websites. This is supported only for the SCORE integration type.
    #[prost(bool, tag = "2")]
    pub allow_amp_traffic: bool,
    /// Required. Describes how this key is integrated with the website.
    #[prost(enumeration = "web_key_settings::IntegrationType", tag = "4")]
    pub integration_type: i32,
    /// Optional. Settings for the frequency and difficulty at which this key
    /// triggers captcha challenges. This should only be specified for
    /// IntegrationTypes CHECKBOX and INVISIBLE and SCORE_AND_CHALLENGE.
    #[prost(enumeration = "web_key_settings::ChallengeSecurityPreference", tag = "5")]
    pub challenge_security_preference: i32,
}
/// Nested message and enum types in `WebKeySettings`.
pub mod web_key_settings {
    /// Enum that represents the integration types for web keys.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IntegrationType {
        /// Default type that indicates this enum hasn't been specified. This is not
        /// a valid IntegrationType, one of the other types must be specified
        /// instead.
        Unspecified = 0,
        /// Only used to produce scores. It doesn't display the "I'm not a robot"
        /// checkbox and never shows captcha challenges.
        Score = 1,
        /// Displays the "I'm not a robot" checkbox and may show captcha challenges
        /// after it is checked.
        Checkbox = 2,
        /// Doesn't display the "I'm not a robot" checkbox, but may show captcha
        /// challenges after risk analysis.
        Invisible = 3,
    }
    impl IntegrationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "INTEGRATION_TYPE_UNSPECIFIED",
                Self::Score => "SCORE",
                Self::Checkbox => "CHECKBOX",
                Self::Invisible => "INVISIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INTEGRATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SCORE" => Some(Self::Score),
                "CHECKBOX" => Some(Self::Checkbox),
                "INVISIBLE" => Some(Self::Invisible),
                _ => None,
            }
        }
    }
    /// Enum that represents the possible challenge frequency and difficulty
    /// configurations for a web key.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChallengeSecurityPreference {
        /// Default type that indicates this enum hasn't been specified.
        Unspecified = 0,
        /// Key tends to show fewer and easier challenges.
        Usability = 1,
        /// Key tends to show balanced (in amount and difficulty) challenges.
        Balance = 2,
        /// Key tends to show more and harder challenges.
        Security = 3,
    }
    impl ChallengeSecurityPreference {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED",
                Self::Usability => "USABILITY",
                Self::Balance => "BALANCE",
                Self::Security => "SECURITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED" => Some(Self::Unspecified),
                "USABILITY" => Some(Self::Usability),
                "BALANCE" => Some(Self::Balance),
                "SECURITY" => Some(Self::Security),
                _ => None,
            }
        }
    }
}
/// Settings specific to keys that can be used by Android apps.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndroidKeySettings {
    /// Optional. If set to true, allowed_package_names are not enforced.
    #[prost(bool, tag = "2")]
    pub allow_all_package_names: bool,
    /// Optional. Android package names of apps allowed to use the key.
    /// Example: 'com.companyname.appname'
    #[prost(string, repeated, tag = "1")]
    pub allowed_package_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Set to true for keys that are used in an Android application that
    /// is available for download in app stores in addition to the Google Play
    /// Store.
    #[prost(bool, tag = "3")]
    pub support_non_google_app_store_distribution: bool,
}
/// Settings specific to keys that can be used by iOS apps.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IosKeySettings {
    /// Optional. If set to true, allowed_bundle_ids are not enforced.
    #[prost(bool, tag = "2")]
    pub allow_all_bundle_ids: bool,
    /// Optional. iOS bundle ids of apps allowed to use the key.
    /// Example: 'com.companyname.productname.appname'
    #[prost(string, repeated, tag = "1")]
    pub allowed_bundle_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Apple Developer account details for the app that is protected by
    /// the reCAPTCHA Key. reCAPTCHA leverages platform-specific checks like Apple
    /// App Attest and Apple DeviceCheck to protect your app from abuse. Providing
    /// these fields allows reCAPTCHA to get a better assessment of the integrity
    /// of your app.
    #[prost(message, optional, tag = "3")]
    pub apple_developer_id: ::core::option::Option<AppleDeveloperId>,
}
/// Settings specific to keys that can be used for reCAPTCHA Express.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExpressKeySettings {}
/// Contains fields that are required to perform Apple-specific integrity checks.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppleDeveloperId {
    /// Required. Input only. A private key (downloaded as a text file with a .p8
    /// file extension) generated for your Apple Developer account. Ensure that
    /// Apple DeviceCheck is enabled for the private key.
    #[prost(string, tag = "1")]
    pub private_key: ::prost::alloc::string::String,
    /// Required. The Apple developer key ID (10-character string).
    #[prost(string, tag = "2")]
    pub key_id: ::prost::alloc::string::String,
    /// Required. The Apple team ID (10-character string) owning the provisioning
    /// profile used to build your application.
    #[prost(string, tag = "3")]
    pub team_id: ::prost::alloc::string::String,
}
/// Score distribution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScoreDistribution {
    /// Map key is score value multiplied by 100. The scores are discrete values
    /// between \[0, 1\]. The maximum number of buckets is on order of a few dozen,
    /// but typically much lower (ie. 10).
    #[prost(map = "int32, int64", tag = "1")]
    pub score_buckets: ::std::collections::HashMap<i32, i64>,
}
/// Metrics related to scoring.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScoreMetrics {
    /// Aggregated score metrics for all traffic.
    #[prost(message, optional, tag = "1")]
    pub overall_metrics: ::core::option::Option<ScoreDistribution>,
    /// Action-based metrics. The map key is the action name which specified by the
    /// site owners at time of the "execute" client-side call.
    #[prost(map = "string, message", tag = "2")]
    pub action_metrics: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ScoreDistribution,
    >,
}
/// Metrics related to challenges.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChallengeMetrics {
    /// Count of reCAPTCHA checkboxes or badges rendered. This is mostly equivalent
    /// to a count of pageloads for pages that include reCAPTCHA.
    #[prost(int64, tag = "1")]
    pub pageload_count: i64,
    /// Count of nocaptchas (successful verification without a challenge) issued.
    #[prost(int64, tag = "2")]
    pub nocaptcha_count: i64,
    /// Count of submitted challenge solutions that were incorrect or otherwise
    /// deemed suspicious such that a subsequent challenge was triggered.
    #[prost(int64, tag = "3")]
    pub failed_count: i64,
    /// Count of nocaptchas (successful verification without a challenge) plus
    /// submitted challenge solutions that were correct and resulted in
    /// verification.
    #[prost(int64, tag = "4")]
    pub passed_count: i64,
}
/// Policy config assessment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallPolicyAssessment {
    /// Output only. If the processing of a policy config fails, an error is
    /// populated and the firewall_policy is left empty.
    #[prost(message, optional, tag = "5")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    /// Output only. The policy that matched the request. If more than one policy
    /// may match, this is the first match. If no policy matches the incoming
    /// request, the policy field is left empty.
    #[prost(message, optional, tag = "8")]
    pub firewall_policy: ::core::option::Option<FirewallPolicy>,
}
/// An individual action. Each action represents what to do if a policy
/// matches.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallAction {
    #[prost(oneof = "firewall_action::FirewallActionOneof", tags = "1, 2, 6, 5, 3, 4")]
    pub firewall_action_oneof: ::core::option::Option<
        firewall_action::FirewallActionOneof,
    >,
}
/// Nested message and enum types in `FirewallAction`.
pub mod firewall_action {
    /// An allow action continues processing a request unimpeded.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AllowAction {}
    /// A block action serves an HTTP error code a prevents the request from
    /// hitting the backend.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BlockAction {}
    /// An include reCAPTCHA script action involves injecting reCAPTCHA JavaScript
    /// code into the HTML returned by the site backend. This reCAPTCHA
    /// script is tasked with collecting user signals on the requested web page,
    /// issuing tokens as a cookie within the site domain, and enabling their
    /// utilization in subsequent page requests.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct IncludeRecaptchaScriptAction {}
    /// A redirect action returns a 307 (temporary redirect) response, pointing
    /// the user to a reCAPTCHA interstitial page to attach a token.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RedirectAction {}
    /// A substitute action transparently serves a different page than the one
    /// requested.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubstituteAction {
        /// Optional. The address to redirect to. The target is a relative path in
        /// the current host. Example: "/blog/404.html".
        #[prost(string, tag = "1")]
        pub path: ::prost::alloc::string::String,
    }
    /// A set header action sets a header and forwards the request to the
    /// backend. This can be used to trigger custom protection implemented on the
    /// backend.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetHeaderAction {
        /// Optional. The header key to set in the request to the backend server.
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        /// Optional. The header value to set in the request to the backend server.
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum FirewallActionOneof {
        /// The user request did not match any policy and should be allowed
        /// access to the requested resource.
        #[prost(message, tag = "1")]
        Allow(AllowAction),
        /// This action denies access to a given page. The user gets an HTTP
        /// error code.
        #[prost(message, tag = "2")]
        Block(BlockAction),
        /// This action injects reCAPTCHA JavaScript code into the HTML page
        /// returned by the site backend.
        #[prost(message, tag = "6")]
        IncludeRecaptchaScript(IncludeRecaptchaScriptAction),
        /// This action redirects the request to a reCAPTCHA interstitial to
        /// attach a token.
        #[prost(message, tag = "5")]
        Redirect(RedirectAction),
        /// This action transparently serves a different page to an offending
        /// user.
        #[prost(message, tag = "3")]
        Substitute(SubstituteAction),
        /// This action sets a custom header but allow the request to continue
        /// to the customer backend.
        #[prost(message, tag = "4")]
        SetHeader(SetHeaderAction),
    }
}
/// A FirewallPolicy represents a single matching pattern and resulting actions
/// to take.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallPolicy {
    /// Identifier. The resource name for the FirewallPolicy in the format
    /// `projects/{project}/firewallpolicies/{firewallpolicy}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. A description of what this policy aims to achieve, for
    /// convenience purposes. The description can at most include 256 UTF-8
    /// characters.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Optional. The path for which this policy applies, specified as a glob
    /// pattern. For more information on glob, see the [manual
    /// page](<https://man7.org/linux/man-pages/man7/glob.7.html>).
    /// A path has a max length of 200 characters.
    #[prost(string, tag = "4")]
    pub path: ::prost::alloc::string::String,
    /// Optional. A CEL (Common Expression Language) conditional expression that
    /// specifies if this policy applies to an incoming user request. If this
    /// condition evaluates to true and the requested path matched the path
    /// pattern, the associated actions should be executed by the caller. The
    /// condition string is checked for CEL syntax correctness on creation. For
    /// more information, see the [CEL spec](<https://github.com/google/cel-spec>)
    /// and its [language
    /// definition](<https://github.com/google/cel-spec/blob/master/doc/langdef.md>).
    /// A condition has a max length of 500 characters.
    #[prost(string, tag = "5")]
    pub condition: ::prost::alloc::string::String,
    /// Optional. The actions that the caller should take regarding user access.
    /// There should be at most one terminal action. A terminal action is any
    /// action that forces a response, such as `AllowAction`,
    /// `BlockAction` or `SubstituteAction`.
    /// Zero or more non-terminal actions such as `SetHeader` might be
    /// specified. A single policy can contain up to 16 actions.
    #[prost(message, repeated, tag = "6")]
    pub actions: ::prost::alloc::vec::Vec<FirewallAction>,
}
/// The request message to list memberships in a related account group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRelatedAccountGroupMembershipsRequest {
    /// Required. The resource name for the related account group in the format
    /// `projects/{project}/relatedaccountgroups/{relatedaccountgroup}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of accounts to return. The service might
    /// return fewer than this value. If unspecified, at most 50 accounts are
    /// returned. The maximum value is 1000; values above 1000 are coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// `ListRelatedAccountGroupMemberships` call.
    ///
    /// When paginating, all other parameters provided to
    /// `ListRelatedAccountGroupMemberships` must match the call that provided the
    /// page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response to a `ListRelatedAccountGroupMemberships` call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRelatedAccountGroupMembershipsResponse {
    /// The memberships listed by the query.
    #[prost(message, repeated, tag = "1")]
    pub related_account_group_memberships: ::prost::alloc::vec::Vec<
        RelatedAccountGroupMembership,
    >,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request message to list related account groups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRelatedAccountGroupsRequest {
    /// Required. The name of the project to list related account groups from, in
    /// the format `projects/{project}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of groups to return. The service might return
    /// fewer than this value. If unspecified, at most 50 groups are returned. The
    /// maximum value is 1000; values above 1000 are coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListRelatedAccountGroups`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListRelatedAccountGroups` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response to a `ListRelatedAccountGroups` call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRelatedAccountGroupsResponse {
    /// The groups of related accounts listed by the query.
    #[prost(message, repeated, tag = "1")]
    pub related_account_groups: ::prost::alloc::vec::Vec<RelatedAccountGroup>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request message to search related account group memberships.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchRelatedAccountGroupMembershipsRequest {
    /// Required. The name of the project to search related account group
    /// memberships from. Specify the project name in the following format:
    /// `projects/{project}`.
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    /// Optional. The unique stable account identifier used to search connections.
    /// The identifier should correspond to an `account_id` provided in a previous
    /// `CreateAssessment` or `AnnotateAssessment` call. Either hashed_account_id
    /// or account_id must be set, but not both.
    #[prost(string, tag = "5")]
    pub account_id: ::prost::alloc::string::String,
    /// Optional. Deprecated: use `account_id` instead.
    /// The unique stable hashed account identifier used to search connections. The
    /// identifier should correspond to a `hashed_account_id` provided in a
    /// previous `CreateAssessment` or `AnnotateAssessment` call. Either
    /// hashed_account_id or account_id must be set, but not both.
    #[deprecated]
    #[prost(bytes = "vec", tag = "2")]
    pub hashed_account_id: ::prost::alloc::vec::Vec<u8>,
    /// Optional. The maximum number of groups to return. The service might return
    /// fewer than this value. If unspecified, at most 50 groups are returned. The
    /// maximum value is 1000; values above 1000 are coerced to 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// `SearchRelatedAccountGroupMemberships` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `SearchRelatedAccountGroupMemberships` must match the call that provided
    /// the page token.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response to a `SearchRelatedAccountGroupMemberships` call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchRelatedAccountGroupMembershipsResponse {
    /// The queried memberships.
    #[prost(message, repeated, tag = "1")]
    pub related_account_group_memberships: ::prost::alloc::vec::Vec<
        RelatedAccountGroupMembership,
    >,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The AddIpOverride request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddIpOverrideRequest {
    /// Required. The name of the key to which the IP override is added, in the
    /// format `projects/{project}/keys/{key}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. IP override added to the key.
    #[prost(message, optional, tag = "2")]
    pub ip_override_data: ::core::option::Option<IpOverrideData>,
}
/// Response for AddIpOverride.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddIpOverrideResponse {}
/// The RemoveIpOverride request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveIpOverrideRequest {
    /// Required. The name of the key from which the IP override is removed, in the
    /// format `projects/{project}/keys/{key}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. IP override to be removed from the key.
    #[prost(message, optional, tag = "2")]
    pub ip_override_data: ::core::option::Option<IpOverrideData>,
}
/// Response for RemoveIpOverride.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveIpOverrideResponse {}
/// The ListIpOverrides request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIpOverridesRequest {
    /// Required. The parent key for which the IP overrides are listed, in the
    /// format `projects/{project}/keys/{key}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of overrides to return. Default is 10. Max
    /// limit is 100. If the number of overrides is less than the page_size, all
    /// overrides are returned. If the page size is more than 100, it is coerced to
    /// 100.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The next_page_token value returned from a previous
    /// ListIpOverridesRequest, if any.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response for ListIpOverrides.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIpOverridesResponse {
    /// IP Overrides details.
    #[prost(message, repeated, tag = "1")]
    pub ip_overrides: ::prost::alloc::vec::Vec<IpOverrideData>,
    /// Token to retrieve the next page of results. If this field is empty, no keys
    /// remain in the results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// A membership in a group of related accounts.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelatedAccountGroupMembership {
    /// Required. Identifier. The resource name for this membership in the format
    /// `projects/{project}/relatedaccountgroups/{relatedaccountgroup}/memberships/{membership}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The unique stable account identifier of the member. The identifier
    /// corresponds to an `account_id` provided in a previous `CreateAssessment` or
    /// `AnnotateAssessment` call.
    #[prost(string, tag = "4")]
    pub account_id: ::prost::alloc::string::String,
    /// Deprecated: use `account_id` instead.
    /// The unique stable hashed account identifier of the member. The identifier
    /// corresponds to a `hashed_account_id` provided in a previous
    /// `CreateAssessment` or `AnnotateAssessment` call.
    #[deprecated]
    #[prost(bytes = "vec", tag = "2")]
    pub hashed_account_id: ::prost::alloc::vec::Vec<u8>,
}
/// A group of related accounts.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelatedAccountGroup {
    /// Required. Identifier. The resource name for the related account group in
    /// the format
    /// `projects/{project}/relatedaccountgroups/{related_account_group}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Settings specific to keys that can be used for WAF (Web Application
/// Firewall).
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WafSettings {
    /// Required. The WAF service that uses this key.
    #[prost(enumeration = "waf_settings::WafService", tag = "1")]
    pub waf_service: i32,
    /// Required. The WAF feature for which this key is enabled.
    #[prost(enumeration = "waf_settings::WafFeature", tag = "2")]
    pub waf_feature: i32,
}
/// Nested message and enum types in `WafSettings`.
pub mod waf_settings {
    /// Supported WAF features. For more information, see
    /// <https://cloud.google.com/recaptcha/docs/usecase#comparison_of_features.>
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WafFeature {
        /// Undefined feature.
        Unspecified = 0,
        /// Redirects suspicious traffic to reCAPTCHA.
        ChallengePage = 1,
        /// Use reCAPTCHA session-tokens to protect the whole user session on the
        /// site's domain.
        SessionToken = 2,
        /// Use reCAPTCHA action-tokens to protect user actions.
        ActionToken = 3,
        /// Use reCAPTCHA WAF express protection to protect any content other than
        /// web pages, like APIs and IoT devices.
        Express = 5,
    }
    impl WafFeature {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "WAF_FEATURE_UNSPECIFIED",
                Self::ChallengePage => "CHALLENGE_PAGE",
                Self::SessionToken => "SESSION_TOKEN",
                Self::ActionToken => "ACTION_TOKEN",
                Self::Express => "EXPRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WAF_FEATURE_UNSPECIFIED" => Some(Self::Unspecified),
                "CHALLENGE_PAGE" => Some(Self::ChallengePage),
                "SESSION_TOKEN" => Some(Self::SessionToken),
                "ACTION_TOKEN" => Some(Self::ActionToken),
                "EXPRESS" => Some(Self::Express),
                _ => None,
            }
        }
    }
    /// Web Application Firewalls supported by reCAPTCHA.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WafService {
        /// Undefined WAF
        Unspecified = 0,
        /// Cloud Armor
        Ca = 1,
        /// Fastly
        Fastly = 3,
        /// Cloudflare
        Cloudflare = 4,
        /// Akamai
        Akamai = 5,
    }
    impl WafService {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "WAF_SERVICE_UNSPECIFIED",
                Self::Ca => "CA",
                Self::Fastly => "FASTLY",
                Self::Cloudflare => "CLOUDFLARE",
                Self::Akamai => "AKAMAI",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WAF_SERVICE_UNSPECIFIED" => Some(Self::Unspecified),
                "CA" => Some(Self::Ca),
                "FASTLY" => Some(Self::Fastly),
                "CLOUDFLARE" => Some(Self::Cloudflare),
                "AKAMAI" => Some(Self::Akamai),
                _ => None,
            }
        }
    }
}
/// The environment creating the assessment. This describes your environment
/// (the system invoking CreateAssessment), NOT the environment of your user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssessmentEnvironment {
    /// Optional. Identifies the client module initiating the CreateAssessment
    /// request. This can be the link to the client module's project. Examples
    /// include:
    /// - "github.com/GoogleCloudPlatform/recaptcha-enterprise-google-tag-manager"
    /// - "cloud.google.com/recaptcha/docs/implement-waf-akamai"
    /// - "cloud.google.com/recaptcha/docs/implement-waf-cloudflare"
    /// - "wordpress.org/plugins/recaptcha-something"
    #[prost(string, tag = "1")]
    pub client: ::prost::alloc::string::String,
    /// Optional. The version of the client module. For example, "1.0.0".
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
/// Information about the IP or IP range override.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpOverrideData {
    /// Required. The IP address to override (can be IPv4, IPv6 or CIDR).
    /// The IP override must be a valid IPv4 or IPv6 address, or a CIDR range.
    /// The IP override must be a public IP address.
    /// Example of IPv4: 168.192.5.6
    /// Example of IPv6: 2001:0000:130F:0000:0000:09C0:876A:130B
    /// Example of IPv4 with CIDR: 168.192.5.0/24
    /// Example of IPv6 with CIDR: 2001:0DB8:1234::/48
    #[prost(string, tag = "1")]
    pub ip: ::prost::alloc::string::String,
    /// Required. Describes the type of IP override.
    #[prost(enumeration = "ip_override_data::OverrideType", tag = "3")]
    pub override_type: i32,
}
/// Nested message and enum types in `IpOverrideData`.
pub mod ip_override_data {
    /// Enum that represents the type of IP override.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OverrideType {
        /// Default override type that indicates this enum hasn't been specified.
        Unspecified = 0,
        /// Allowlist the IP address; i.e. give a `risk_analysis.score` of 0.9 for
        /// all valid assessments.
        Allow = 1,
    }
    impl OverrideType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OVERRIDE_TYPE_UNSPECIFIED",
                Self::Allow => "ALLOW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OVERRIDE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ALLOW" => Some(Self::Allow),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod recaptcha_enterprise_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to determine the likelihood an event is legitimate.
    #[derive(Debug, Clone)]
    pub struct RecaptchaEnterpriseServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RecaptchaEnterpriseServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RecaptchaEnterpriseServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RecaptchaEnterpriseServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            RecaptchaEnterpriseServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates an Assessment of the likelihood an event is legitimate.
        pub async fn create_assessment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAssessmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Assessment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/CreateAssessment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "CreateAssessment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Annotates a previously created Assessment to provide additional information
        /// on whether the event turned out to be authentic or fraudulent.
        pub async fn annotate_assessment(
            &mut self,
            request: impl tonic::IntoRequest<super::AnnotateAssessmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AnnotateAssessmentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/AnnotateAssessment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "AnnotateAssessment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new reCAPTCHA Enterprise key.
        pub async fn create_key(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateKeyRequest>,
        ) -> std::result::Result<tonic::Response<super::Key>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/CreateKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "CreateKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the list of all keys that belong to a project.
        pub async fn list_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::ListKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/ListKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "ListKeys",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the secret key related to the specified public key.
        /// You must use the legacy secret key only in a 3rd party integration with
        /// legacy reCAPTCHA.
        pub async fn retrieve_legacy_secret_key(
            &mut self,
            request: impl tonic::IntoRequest<super::RetrieveLegacySecretKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RetrieveLegacySecretKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/RetrieveLegacySecretKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "RetrieveLegacySecretKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified key.
        pub async fn get_key(
            &mut self,
            request: impl tonic::IntoRequest<super::GetKeyRequest>,
        ) -> std::result::Result<tonic::Response<super::Key>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/GetKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "GetKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified key.
        pub async fn update_key(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateKeyRequest>,
        ) -> std::result::Result<tonic::Response<super::Key>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/UpdateKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "UpdateKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified key.
        pub async fn delete_key(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteKeyRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/DeleteKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "DeleteKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Migrates an existing key from reCAPTCHA to reCAPTCHA Enterprise.
        /// Once a key is migrated, it can be used from either product. SiteVerify
        /// requests are billed as CreateAssessment calls. You must be
        /// authenticated as one of the current owners of the reCAPTCHA Key, and
        /// your user must have the reCAPTCHA Enterprise Admin IAM role in the
        /// destination project.
        pub async fn migrate_key(
            &mut self,
            request: impl tonic::IntoRequest<super::MigrateKeyRequest>,
        ) -> std::result::Result<tonic::Response<super::Key>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/MigrateKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "MigrateKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Adds an IP override to a key. The following restrictions hold:
        /// * The maximum number of IP overrides per key is 100.
        /// * For any conflict (such as IP already exists or IP part of an existing
        ///   IP range), an error is returned.
        pub async fn add_ip_override(
            &mut self,
            request: impl tonic::IntoRequest<super::AddIpOverrideRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddIpOverrideResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/AddIpOverride",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "AddIpOverride",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Removes an IP override from a key. The following restrictions hold:
        /// * If the IP isn't found in an existing IP override, a `NOT_FOUND` error
        /// is returned.
        /// * If the IP is found in an existing IP override, but the
        /// override type does not match, a `NOT_FOUND` error is returned.
        pub async fn remove_ip_override(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveIpOverrideRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveIpOverrideResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/RemoveIpOverride",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "RemoveIpOverride",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all IP overrides for a key.
        pub async fn list_ip_overrides(
            &mut self,
            request: impl tonic::IntoRequest<super::ListIpOverridesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListIpOverridesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/ListIpOverrides",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "ListIpOverrides",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get some aggregated metrics for a Key. This data can be used to build
        /// dashboards.
        pub async fn get_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMetricsRequest>,
        ) -> std::result::Result<tonic::Response<super::Metrics>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/GetMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "GetMetrics",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new FirewallPolicy, specifying conditions at which reCAPTCHA
        /// Enterprise actions can be executed.
        /// A project may have a maximum of 1000 policies.
        pub async fn create_firewall_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::FirewallPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/CreateFirewallPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "CreateFirewallPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the list of all firewall policies that belong to a project.
        pub async fn list_firewall_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFirewallPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFirewallPoliciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/ListFirewallPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "ListFirewallPolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified firewall policy.
        pub async fn get_firewall_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::FirewallPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/GetFirewallPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "GetFirewallPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified firewall policy.
        pub async fn update_firewall_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::FirewallPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/UpdateFirewallPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "UpdateFirewallPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified firewall policy.
        pub async fn delete_firewall_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/DeleteFirewallPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "DeleteFirewallPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Reorders all firewall policies.
        pub async fn reorder_firewall_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ReorderFirewallPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReorderFirewallPoliciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/ReorderFirewallPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "ReorderFirewallPolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List groups of related accounts.
        pub async fn list_related_account_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRelatedAccountGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRelatedAccountGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/ListRelatedAccountGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "ListRelatedAccountGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get memberships in a group of related accounts.
        pub async fn list_related_account_group_memberships(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListRelatedAccountGroupMembershipsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListRelatedAccountGroupMembershipsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/ListRelatedAccountGroupMemberships",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "ListRelatedAccountGroupMemberships",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Search group memberships related to a given account.
        pub async fn search_related_account_group_memberships(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SearchRelatedAccountGroupMembershipsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SearchRelatedAccountGroupMembershipsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService/SearchRelatedAccountGroupMemberships",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.recaptchaenterprise.v1.RecaptchaEnterpriseService",
                        "SearchRelatedAccountGroupMemberships",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
