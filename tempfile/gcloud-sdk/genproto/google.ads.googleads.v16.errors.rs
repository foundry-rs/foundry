// This file is @generated by prost-build.
/// Container for enum describing possible AccessInvitation errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccessInvitationErrorEnum {}
/// Nested message and enum types in `AccessInvitationErrorEnum`.
pub mod access_invitation_error_enum {
    /// Enum describing possible AccessInvitation errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccessInvitationError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The email address is invalid for sending an invitation.
        InvalidEmailAddress = 2,
        /// Email address already has access to this customer.
        EmailAddressAlreadyHasAccess = 3,
        /// Invalid invitation status for the operation.
        InvalidInvitationStatus = 4,
        /// Email address cannot be like abc+foo@google.com.
        GoogleConsumerAccountNotAllowed = 5,
        /// Invalid invitation ID.
        InvalidInvitationId = 6,
        /// Email address already has a pending invitation.
        EmailAddressAlreadyHasPendingInvitation = 7,
        /// Pending invitation limit exceeded for the customer.
        PendingInvitationsLimitExceeded = 8,
        /// Email address doesn't conform to the email domain policy. See
        /// <https://support.google.com/google-ads/answer/2375456>
        EmailDomainPolicyViolated = 9,
    }
    impl AccessInvitationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidEmailAddress => "INVALID_EMAIL_ADDRESS",
                Self::EmailAddressAlreadyHasAccess => "EMAIL_ADDRESS_ALREADY_HAS_ACCESS",
                Self::InvalidInvitationStatus => "INVALID_INVITATION_STATUS",
                Self::GoogleConsumerAccountNotAllowed => {
                    "GOOGLE_CONSUMER_ACCOUNT_NOT_ALLOWED"
                }
                Self::InvalidInvitationId => "INVALID_INVITATION_ID",
                Self::EmailAddressAlreadyHasPendingInvitation => {
                    "EMAIL_ADDRESS_ALREADY_HAS_PENDING_INVITATION"
                }
                Self::PendingInvitationsLimitExceeded => {
                    "PENDING_INVITATIONS_LIMIT_EXCEEDED"
                }
                Self::EmailDomainPolicyViolated => "EMAIL_DOMAIN_POLICY_VIOLATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_EMAIL_ADDRESS" => Some(Self::InvalidEmailAddress),
                "EMAIL_ADDRESS_ALREADY_HAS_ACCESS" => {
                    Some(Self::EmailAddressAlreadyHasAccess)
                }
                "INVALID_INVITATION_STATUS" => Some(Self::InvalidInvitationStatus),
                "GOOGLE_CONSUMER_ACCOUNT_NOT_ALLOWED" => {
                    Some(Self::GoogleConsumerAccountNotAllowed)
                }
                "INVALID_INVITATION_ID" => Some(Self::InvalidInvitationId),
                "EMAIL_ADDRESS_ALREADY_HAS_PENDING_INVITATION" => {
                    Some(Self::EmailAddressAlreadyHasPendingInvitation)
                }
                "PENDING_INVITATIONS_LIMIT_EXCEEDED" => {
                    Some(Self::PendingInvitationsLimitExceeded)
                }
                "EMAIL_DOMAIN_POLICY_VIOLATED" => Some(Self::EmailDomainPolicyViolated),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible account budget proposal errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccountBudgetProposalErrorEnum {}
/// Nested message and enum types in `AccountBudgetProposalErrorEnum`.
pub mod account_budget_proposal_error_enum {
    /// Enum describing possible account budget proposal errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountBudgetProposalError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The field mask must be empty for create/end/remove proposals.
        FieldMaskNotAllowed = 2,
        /// The field cannot be set because of the proposal type.
        ImmutableField = 3,
        /// The field is required because of the proposal type.
        RequiredFieldMissing = 4,
        /// Proposals that have been approved cannot be cancelled.
        CannotCancelApprovedProposal = 5,
        /// Budgets that haven't been approved cannot be removed.
        CannotRemoveUnapprovedBudget = 6,
        /// Budgets that are currently running cannot be removed.
        CannotRemoveRunningBudget = 7,
        /// Budgets that haven't been approved cannot be truncated.
        CannotEndUnapprovedBudget = 8,
        /// Only budgets that are currently running can be truncated.
        CannotEndInactiveBudget = 9,
        /// All budgets must have names.
        BudgetNameRequired = 10,
        /// Expired budgets cannot be edited after a sufficient amount of time has
        /// passed.
        CannotUpdateOldBudget = 11,
        /// It is not permissible a propose a new budget that ends in the past.
        CannotEndInPast = 12,
        /// An expired budget cannot be extended to overlap with the running budget.
        CannotExtendEndTime = 13,
        /// A purchase order number is required.
        PurchaseOrderNumberRequired = 14,
        /// Budgets that have a pending update cannot be updated.
        PendingUpdateProposalExists = 15,
        /// Cannot propose more than one budget when the corresponding billing setup
        /// hasn't been approved.
        MultipleBudgetsNotAllowedForUnapprovedBillingSetup = 16,
        /// Cannot update the start time of a budget that has already started.
        CannotUpdateStartTimeForStartedBudget = 17,
        /// Cannot update the spending limit of a budget with an amount lower than
        /// what has already been spent.
        SpendingLimitLowerThanAccruedCostNotAllowed = 18,
        /// Cannot propose a budget update without actually changing any fields.
        UpdateIsNoOp = 19,
        /// The end time must come after the start time.
        EndTimeMustFollowStartTime = 20,
        /// The budget's date range must fall within the date range of its billing
        /// setup.
        BudgetDateRangeIncompatibleWithBillingSetup = 21,
        /// The user is not authorized to mutate budgets for the given billing setup.
        NotAuthorized = 22,
        /// Mutates are not allowed for the given billing setup.
        InvalidBillingSetup = 23,
        /// Budget creation failed as it overlaps with a pending budget proposal
        /// or an approved budget.
        OverlapsExistingBudget = 24,
        /// The control setting in user's payments profile doesn't allow budget
        /// creation through API. Log in to Google Ads to create budget.
        CannotCreateBudgetThroughApi = 25,
        /// Master service agreement has not been signed yet for the Payments
        /// Profile.
        InvalidMasterServiceAgreement = 26,
        /// Budget mutates are not allowed because the given billing setup is
        /// canceled.
        CanceledBillingSetup = 27,
    }
    impl AccountBudgetProposalError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::FieldMaskNotAllowed => "FIELD_MASK_NOT_ALLOWED",
                Self::ImmutableField => "IMMUTABLE_FIELD",
                Self::RequiredFieldMissing => "REQUIRED_FIELD_MISSING",
                Self::CannotCancelApprovedProposal => "CANNOT_CANCEL_APPROVED_PROPOSAL",
                Self::CannotRemoveUnapprovedBudget => "CANNOT_REMOVE_UNAPPROVED_BUDGET",
                Self::CannotRemoveRunningBudget => "CANNOT_REMOVE_RUNNING_BUDGET",
                Self::CannotEndUnapprovedBudget => "CANNOT_END_UNAPPROVED_BUDGET",
                Self::CannotEndInactiveBudget => "CANNOT_END_INACTIVE_BUDGET",
                Self::BudgetNameRequired => "BUDGET_NAME_REQUIRED",
                Self::CannotUpdateOldBudget => "CANNOT_UPDATE_OLD_BUDGET",
                Self::CannotEndInPast => "CANNOT_END_IN_PAST",
                Self::CannotExtendEndTime => "CANNOT_EXTEND_END_TIME",
                Self::PurchaseOrderNumberRequired => "PURCHASE_ORDER_NUMBER_REQUIRED",
                Self::PendingUpdateProposalExists => "PENDING_UPDATE_PROPOSAL_EXISTS",
                Self::MultipleBudgetsNotAllowedForUnapprovedBillingSetup => {
                    "MULTIPLE_BUDGETS_NOT_ALLOWED_FOR_UNAPPROVED_BILLING_SETUP"
                }
                Self::CannotUpdateStartTimeForStartedBudget => {
                    "CANNOT_UPDATE_START_TIME_FOR_STARTED_BUDGET"
                }
                Self::SpendingLimitLowerThanAccruedCostNotAllowed => {
                    "SPENDING_LIMIT_LOWER_THAN_ACCRUED_COST_NOT_ALLOWED"
                }
                Self::UpdateIsNoOp => "UPDATE_IS_NO_OP",
                Self::EndTimeMustFollowStartTime => "END_TIME_MUST_FOLLOW_START_TIME",
                Self::BudgetDateRangeIncompatibleWithBillingSetup => {
                    "BUDGET_DATE_RANGE_INCOMPATIBLE_WITH_BILLING_SETUP"
                }
                Self::NotAuthorized => "NOT_AUTHORIZED",
                Self::InvalidBillingSetup => "INVALID_BILLING_SETUP",
                Self::OverlapsExistingBudget => "OVERLAPS_EXISTING_BUDGET",
                Self::CannotCreateBudgetThroughApi => "CANNOT_CREATE_BUDGET_THROUGH_API",
                Self::InvalidMasterServiceAgreement => "INVALID_MASTER_SERVICE_AGREEMENT",
                Self::CanceledBillingSetup => "CANCELED_BILLING_SETUP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FIELD_MASK_NOT_ALLOWED" => Some(Self::FieldMaskNotAllowed),
                "IMMUTABLE_FIELD" => Some(Self::ImmutableField),
                "REQUIRED_FIELD_MISSING" => Some(Self::RequiredFieldMissing),
                "CANNOT_CANCEL_APPROVED_PROPOSAL" => {
                    Some(Self::CannotCancelApprovedProposal)
                }
                "CANNOT_REMOVE_UNAPPROVED_BUDGET" => {
                    Some(Self::CannotRemoveUnapprovedBudget)
                }
                "CANNOT_REMOVE_RUNNING_BUDGET" => Some(Self::CannotRemoveRunningBudget),
                "CANNOT_END_UNAPPROVED_BUDGET" => Some(Self::CannotEndUnapprovedBudget),
                "CANNOT_END_INACTIVE_BUDGET" => Some(Self::CannotEndInactiveBudget),
                "BUDGET_NAME_REQUIRED" => Some(Self::BudgetNameRequired),
                "CANNOT_UPDATE_OLD_BUDGET" => Some(Self::CannotUpdateOldBudget),
                "CANNOT_END_IN_PAST" => Some(Self::CannotEndInPast),
                "CANNOT_EXTEND_END_TIME" => Some(Self::CannotExtendEndTime),
                "PURCHASE_ORDER_NUMBER_REQUIRED" => {
                    Some(Self::PurchaseOrderNumberRequired)
                }
                "PENDING_UPDATE_PROPOSAL_EXISTS" => {
                    Some(Self::PendingUpdateProposalExists)
                }
                "MULTIPLE_BUDGETS_NOT_ALLOWED_FOR_UNAPPROVED_BILLING_SETUP" => {
                    Some(Self::MultipleBudgetsNotAllowedForUnapprovedBillingSetup)
                }
                "CANNOT_UPDATE_START_TIME_FOR_STARTED_BUDGET" => {
                    Some(Self::CannotUpdateStartTimeForStartedBudget)
                }
                "SPENDING_LIMIT_LOWER_THAN_ACCRUED_COST_NOT_ALLOWED" => {
                    Some(Self::SpendingLimitLowerThanAccruedCostNotAllowed)
                }
                "UPDATE_IS_NO_OP" => Some(Self::UpdateIsNoOp),
                "END_TIME_MUST_FOLLOW_START_TIME" => {
                    Some(Self::EndTimeMustFollowStartTime)
                }
                "BUDGET_DATE_RANGE_INCOMPATIBLE_WITH_BILLING_SETUP" => {
                    Some(Self::BudgetDateRangeIncompatibleWithBillingSetup)
                }
                "NOT_AUTHORIZED" => Some(Self::NotAuthorized),
                "INVALID_BILLING_SETUP" => Some(Self::InvalidBillingSetup),
                "OVERLAPS_EXISTING_BUDGET" => Some(Self::OverlapsExistingBudget),
                "CANNOT_CREATE_BUDGET_THROUGH_API" => {
                    Some(Self::CannotCreateBudgetThroughApi)
                }
                "INVALID_MASTER_SERVICE_AGREEMENT" => {
                    Some(Self::InvalidMasterServiceAgreement)
                }
                "CANCELED_BILLING_SETUP" => Some(Self::CanceledBillingSetup),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible account link errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccountLinkErrorEnum {}
/// Nested message and enum types in `AccountLinkErrorEnum`.
pub mod account_link_error_enum {
    /// Enum describing possible account link errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountLinkError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The new link status is invalid.
        InvalidStatus = 2,
        /// The authenticated user doesn't have the permission to do the change.
        PermissionDenied = 3,
    }
    impl AccountLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidStatus => "INVALID_STATUS",
                Self::PermissionDenied => "PERMISSION_DENIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_STATUS" => Some(Self::InvalidStatus),
                "PERMISSION_DENIED" => Some(Self::PermissionDenied),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible ad customizer errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdCustomizerErrorEnum {}
/// Nested message and enum types in `AdCustomizerErrorEnum`.
pub mod ad_customizer_error_enum {
    /// Enum describing possible ad customizer errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdCustomizerError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Invalid date argument in countdown function.
        CountdownInvalidDateFormat = 2,
        /// Countdown end date is in the past.
        CountdownDateInPast = 3,
        /// Invalid locale string in countdown function.
        CountdownInvalidLocale = 4,
        /// Days-before argument to countdown function is not positive.
        CountdownInvalidStartDaysBefore = 5,
        /// A user list referenced in an IF function does not exist.
        UnknownUserList = 6,
    }
    impl AdCustomizerError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CountdownInvalidDateFormat => "COUNTDOWN_INVALID_DATE_FORMAT",
                Self::CountdownDateInPast => "COUNTDOWN_DATE_IN_PAST",
                Self::CountdownInvalidLocale => "COUNTDOWN_INVALID_LOCALE",
                Self::CountdownInvalidStartDaysBefore => {
                    "COUNTDOWN_INVALID_START_DAYS_BEFORE"
                }
                Self::UnknownUserList => "UNKNOWN_USER_LIST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "COUNTDOWN_INVALID_DATE_FORMAT" => Some(Self::CountdownInvalidDateFormat),
                "COUNTDOWN_DATE_IN_PAST" => Some(Self::CountdownDateInPast),
                "COUNTDOWN_INVALID_LOCALE" => Some(Self::CountdownInvalidLocale),
                "COUNTDOWN_INVALID_START_DAYS_BEFORE" => {
                    Some(Self::CountdownInvalidStartDaysBefore)
                }
                "UNKNOWN_USER_LIST" => Some(Self::UnknownUserList),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible ad errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdErrorEnum {}
/// Nested message and enum types in `AdErrorEnum`.
pub mod ad_error_enum {
    /// Enum describing possible ad errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Ad customizers are not supported for ad type.
        AdCustomizersNotSupportedForAdType = 2,
        /// Estimating character sizes the string is too long.
        ApproximatelyTooLong = 3,
        /// Estimating character sizes the string is too short.
        ApproximatelyTooShort = 4,
        /// There is a problem with the snippet.
        BadSnippet = 5,
        /// Cannot modify an ad.
        CannotModifyAd = 6,
        /// business name and url cannot be set at the same time
        CannotSetBusinessNameIfUrlSet = 7,
        /// The specified field is incompatible with this ad's type or settings.
        CannotSetField = 8,
        /// Cannot set field when originAdId is set.
        CannotSetFieldWithOriginAdIdSet = 9,
        /// Cannot set field when an existing ad id is set for sharing.
        CannotSetFieldWithAdIdSetForSharing = 10,
        /// Cannot set allowFlexibleColor false if no color is provided by user.
        CannotSetAllowFlexibleColorFalse = 11,
        /// When user select native, no color control is allowed because we will
        /// always respect publisher color for native format serving.
        CannotSetColorControlWhenNativeFormatSetting = 12,
        /// Cannot specify a url for the ad type
        CannotSetUrl = 13,
        /// Cannot specify a tracking or mobile url without also setting final urls
        CannotSetWithoutFinalUrls = 14,
        /// Cannot specify a legacy url and a final url simultaneously
        CannotSetWithFinalUrls = 15,
        /// Cannot specify a urls in UrlData and in template fields simultaneously.
        CannotSetWithUrlData = 17,
        /// This operator cannot be used with a subclass of Ad.
        CannotUseAdSubclassForOperator = 18,
        /// Customer is not approved for mobile ads.
        CustomerNotApprovedMobileads = 19,
        /// Customer is not approved for 3PAS richmedia ads.
        CustomerNotApprovedThirdpartyAds = 20,
        /// Customer is not approved for 3PAS redirect richmedia (Ad Exchange) ads.
        CustomerNotApprovedThirdpartyRedirectAds = 21,
        /// Not an eligible customer
        CustomerNotEligible = 22,
        /// Customer is not eligible for updating beacon url
        CustomerNotEligibleForUpdatingBeaconUrl = 23,
        /// There already exists an ad with the same dimensions in the union.
        DimensionAlreadyInUnion = 24,
        /// Ad's dimension must be set before setting union dimension.
        DimensionMustBeSet = 25,
        /// Ad's dimension must be included in the union dimensions.
        DimensionNotInUnion = 26,
        /// Display Url cannot be specified (applies to Ad Exchange Ads)
        DisplayUrlCannotBeSpecified = 27,
        /// Telephone number contains invalid characters or invalid format.
        /// Re-enter your number using digits (0-9), dashes (-), and parentheses
        /// only.
        DomesticPhoneNumberFormat = 28,
        /// Emergency telephone numbers are not allowed. Enter a valid
        /// domestic phone number to connect customers to your business.
        EmergencyPhoneNumber = 29,
        /// A required field was not specified or is an empty string.
        EmptyField = 30,
        /// A feed attribute referenced in an ad customizer tag is not in the ad
        /// customizer mapping for the feed.
        FeedAttributeMustHaveMappingForTypeId = 31,
        /// The ad customizer field mapping for the feed attribute does not match the
        /// expected field type.
        FeedAttributeMappingTypeMismatch = 32,
        /// The use of ad customizer tags in the ad text is disallowed. Details in
        /// trigger.
        IllegalAdCustomizerTagUse = 33,
        /// Tags of the form {PH_x}, where x is a number, are disallowed in ad text.
        IllegalTagUse = 34,
        /// The dimensions of the ad are specified or derived in multiple ways and
        /// are not consistent.
        InconsistentDimensions = 35,
        /// The status cannot differ among template ads of the same union.
        InconsistentStatusInTemplateUnion = 36,
        /// The length of the string is not valid.
        IncorrectLength = 37,
        /// The ad is ineligible for upgrade.
        IneligibleForUpgrade = 38,
        /// User cannot create mobile ad for countries targeted in specified
        /// campaign.
        InvalidAdAddressCampaignTarget = 39,
        /// Invalid Ad type. A specific type of Ad is required.
        InvalidAdType = 40,
        /// Headline, description or phone cannot be present when creating mobile
        /// image ad.
        InvalidAttributesForMobileImage = 41,
        /// Image cannot be present when creating mobile text ad.
        InvalidAttributesForMobileText = 42,
        /// Invalid call to action text.
        InvalidCallToActionText = 43,
        /// Invalid character in URL.
        InvalidCharacterForUrl = 44,
        /// Creative's country code is not valid.
        InvalidCountryCode = 45,
        /// Invalid use of Expanded Dynamic Search Ads tags ({lpurl} etc.)
        InvalidExpandedDynamicSearchAdTag = 47,
        /// An input error whose real reason was not properly mapped (should not
        /// happen).
        InvalidInput = 48,
        /// An invalid markup language was entered.
        InvalidMarkupLanguage = 49,
        /// An invalid mobile carrier was entered.
        InvalidMobileCarrier = 50,
        /// Specified mobile carriers target a country not targeted by the campaign.
        InvalidMobileCarrierTarget = 51,
        /// Wrong number of elements for given element type
        InvalidNumberOfElements = 52,
        /// The format of the telephone number is incorrect. Re-enter the
        /// number using the correct format.
        InvalidPhoneNumberFormat = 53,
        /// The certified vendor format id is incorrect.
        InvalidRichMediaCertifiedVendorFormatId = 54,
        /// The template ad data contains validation errors.
        InvalidTemplateData = 55,
        /// The template field doesn't have have the correct type.
        InvalidTemplateElementFieldType = 56,
        /// Invalid template id.
        InvalidTemplateId = 57,
        /// After substituting replacement strings, the line is too wide.
        LineTooWide = 58,
        /// The feed referenced must have ad customizer mapping to be used in a
        /// customizer tag.
        MissingAdCustomizerMapping = 59,
        /// Missing address component in template element address field.
        MissingAddressComponent = 60,
        /// An ad name must be entered.
        MissingAdvertisementName = 61,
        /// Business name must be entered.
        MissingBusinessName = 62,
        /// Description (line 2) must be entered.
        MissingDescription1 = 63,
        /// Description (line 3) must be entered.
        MissingDescription2 = 64,
        /// The destination url must contain at least one tag (for example, {lpurl})
        MissingDestinationUrlTag = 65,
        /// The tracking url template of ExpandedDynamicSearchAd must contain at
        /// least one tag. (for example, {lpurl})
        MissingLandingPageUrlTag = 66,
        /// A valid dimension must be specified for this ad.
        MissingDimension = 67,
        /// A display URL must be entered.
        MissingDisplayUrl = 68,
        /// Headline must be entered.
        MissingHeadline = 69,
        /// A height must be entered.
        MissingHeight = 70,
        /// An image must be entered.
        MissingImage = 71,
        /// Marketing image or product videos are required.
        MissingMarketingImageOrProductVideos = 72,
        /// The markup language in which your site is written must be entered.
        MissingMarkupLanguages = 73,
        /// A mobile carrier must be entered.
        MissingMobileCarrier = 74,
        /// Phone number must be entered.
        MissingPhone = 75,
        /// Missing required template fields
        MissingRequiredTemplateFields = 76,
        /// Missing a required field value
        MissingTemplateFieldValue = 77,
        /// The ad must have text.
        MissingText = 78,
        /// A visible URL must be entered.
        MissingVisibleUrl = 79,
        /// A width must be entered.
        MissingWidth = 80,
        /// Only 1 feed can be used as the source of ad customizer substitutions in a
        /// single ad.
        MultipleDistinctFeedsUnsupported = 81,
        /// TempAdUnionId must be use when adding template ads.
        MustUseTempAdUnionIdOnAdd = 82,
        /// The string has too many characters.
        TooLong = 83,
        /// The string has too few characters.
        TooShort = 84,
        /// Ad union dimensions cannot change for saved ads.
        UnionDimensionsCannotChange = 85,
        /// Address component is not {country, lat, lng}.
        UnknownAddressComponent = 86,
        /// Unknown unique field name
        UnknownFieldName = 87,
        /// Unknown unique name (template element type specifier)
        UnknownUniqueName = 88,
        /// Unsupported ad dimension
        UnsupportedDimensions = 89,
        /// URL starts with an invalid scheme.
        UrlInvalidScheme = 90,
        /// URL ends with an invalid top-level domain name.
        UrlInvalidTopLevelDomain = 91,
        /// URL contains illegal characters.
        UrlMalformed = 92,
        /// URL must contain a host name.
        UrlNoHost = 93,
        /// URL not equivalent during upgrade.
        UrlNotEquivalent = 94,
        /// URL host name too long to be stored as visible URL (applies to Ad
        /// Exchange ads)
        UrlHostNameTooLong = 95,
        /// URL must start with a scheme.
        UrlNoScheme = 96,
        /// URL should end in a valid domain extension, such as .com or .net.
        UrlNoTopLevelDomain = 97,
        /// URL must not end with a path.
        UrlPathNotAllowed = 98,
        /// URL must not specify a port.
        UrlPortNotAllowed = 99,
        /// URL must not contain a query.
        UrlQueryNotAllowed = 100,
        /// A url scheme is not allowed in front of tag in tracking url template
        /// (for example, <http://{lpurl}>)
        UrlSchemeBeforeExpandedDynamicSearchAdTag = 102,
        /// The user does not have permissions to create a template ad for the given
        /// template.
        UserDoesNotHaveAccessToTemplate = 103,
        /// Expandable setting is inconsistent/wrong. For example, an AdX ad is
        /// invalid if it has a expandable vendor format but no expanding directions
        /// specified, or expanding directions is specified, but the vendor format is
        /// not expandable.
        InconsistentExpandableSettings = 104,
        /// Format is invalid
        InvalidFormat = 105,
        /// The text of this field did not match a pattern of allowed values.
        InvalidFieldText = 106,
        /// Template element is mising
        ElementNotPresent = 107,
        /// Error occurred during image processing
        ImageError = 108,
        /// The value is not within the valid range
        ValueNotInRange = 109,
        /// Template element field is not present
        FieldNotPresent = 110,
        /// Address is incomplete
        AddressNotComplete = 111,
        /// Invalid address
        AddressInvalid = 112,
        /// Error retrieving specified video
        VideoRetrievalError = 113,
        /// Error processing audio
        AudioError = 114,
        /// Display URL is incorrect for YouTube PYV ads
        InvalidYoutubeDisplayUrl = 115,
        /// Too many product Images in GmailAd
        TooManyProductImages = 116,
        /// Too many product Videos in GmailAd
        TooManyProductVideos = 117,
        /// The device preference is not compatible with the ad type
        IncompatibleAdTypeAndDevicePreference = 118,
        /// Call tracking is not supported for specified country.
        CalltrackingNotSupportedForCountry = 119,
        /// Carrier specific short number is not allowed.
        CarrierSpecificShortNumberNotAllowed = 120,
        /// Specified phone number type is disallowed.
        DisallowedNumberType = 121,
        /// Phone number not supported for country.
        PhoneNumberNotSupportedForCountry = 122,
        /// Phone number not supported with call tracking enabled for country.
        PhoneNumberNotSupportedWithCalltrackingForCountry = 123,
        /// Premium rate phone number is not allowed.
        PremiumRateNumberNotAllowed = 124,
        /// Vanity phone number is not allowed.
        VanityPhoneNumberNotAllowed = 125,
        /// Invalid call conversion type id.
        InvalidCallConversionTypeId = 126,
        /// Cannot disable call conversion and set conversion type id.
        CannotDisableCallConversionAndSetConversionTypeId = 127,
        /// Cannot set path2 without path1.
        CannotSetPath2WithoutPath1 = 128,
        /// Missing domain name in campaign setting when adding expanded dynamic
        /// search ad.
        MissingDynamicSearchAdsSettingDomainName = 129,
        /// The associated ad is not compatible with restriction type.
        IncompatibleWithRestrictionType = 130,
        /// Consent for call recording is required for creating/updating call only
        /// ads. See <https://support.google.com/google-ads/answer/7412639.>
        CustomerConsentForCallRecordingRequired = 131,
        /// Either an image or a media bundle is required in a display upload ad.
        MissingImageOrMediaBundle = 132,
        /// The display upload product type is not supported in this campaign.
        ProductTypeNotSupportedInThisCampaign = 133,
        /// The default value of an ad placeholder can not be the empty string.
        PlaceholderCannotHaveEmptyDefaultValue = 134,
        /// Ad placeholders with countdown functions must not have a default value.
        PlaceholderCountdownFunctionCannotHaveDefaultValue = 135,
        /// A previous ad placeholder that had a default value was found which means
        /// that all (non-countdown) placeholders must have a default value. This
        /// ad placeholder does not have a default value.
        PlaceholderDefaultValueMissing = 136,
        /// A previous ad placeholder that did not have a default value was found
        /// which means that no placeholders may have a default value. This
        /// ad placeholder does have a default value.
        UnexpectedPlaceholderDefaultValue = 137,
        /// Two ad customizers may not be directly adjacent in an ad text. They must
        /// be separated by at least one character.
        AdCustomizersMayNotBeAdjacent = 138,
        /// The ad is not associated with any enabled AdGroupAd, and cannot be
        /// updated.
        UpdatingAdWithNoEnabledAssociation = 139,
        /// Call Ad verification url and final url don't have same domain.
        CallAdVerificationUrlFinalUrlDoesNotHaveSameDomain = 140,
        /// Final url and verification url cannot both be empty for call ads.
        CallAdFinalUrlAndVerificationUrlCannotBothBeEmpty = 154,
        /// Too many ad customizers in one asset.
        TooManyAdCustomizers = 141,
        /// The ad customizer tag is recognized, but the format is invalid.
        InvalidAdCustomizerFormat = 142,
        /// Customizer tags cannot be nested.
        NestedAdCustomizerSyntax = 143,
        /// The ad customizer syntax used in the ad is not supported.
        UnsupportedAdCustomizerSyntax = 144,
        /// There exists unpaired brace in the ad customizer tag.
        UnpairedBraceInAdCustomizerTag = 145,
        /// More than one type of countdown tag exists among all text lines.
        MoreThanOneCountdownTagTypeExists = 146,
        /// Date time in the countdown tag is invalid.
        DateTimeInCountdownTagIsInvalid = 147,
        /// Date time in the countdown tag is in the past.
        DateTimeInCountdownTagIsPast = 148,
        /// Cannot recognize the ad customizer tag.
        UnrecognizedAdCustomizerTagFound = 149,
        /// Customizer type forbidden for this field.
        CustomizerTypeForbiddenForField = 150,
        /// Customizer attribute name is invalid.
        InvalidCustomizerAttributeName = 151,
        /// App store value does not match the value of the app store in the app
        /// specified in the campaign.
        StoreMismatch = 152,
        /// Missing required image aspect ratio.
        MissingRequiredImageAspectRatio = 153,
        /// Aspect ratios mismatch between different assets.
        MismatchedAspectRatios = 155,
        /// Images must be unique between different carousel card assets.
        DuplicateImageAcrossCarouselCards = 156,
    }
    impl AdError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AdCustomizersNotSupportedForAdType => {
                    "AD_CUSTOMIZERS_NOT_SUPPORTED_FOR_AD_TYPE"
                }
                Self::ApproximatelyTooLong => "APPROXIMATELY_TOO_LONG",
                Self::ApproximatelyTooShort => "APPROXIMATELY_TOO_SHORT",
                Self::BadSnippet => "BAD_SNIPPET",
                Self::CannotModifyAd => "CANNOT_MODIFY_AD",
                Self::CannotSetBusinessNameIfUrlSet => {
                    "CANNOT_SET_BUSINESS_NAME_IF_URL_SET"
                }
                Self::CannotSetField => "CANNOT_SET_FIELD",
                Self::CannotSetFieldWithOriginAdIdSet => {
                    "CANNOT_SET_FIELD_WITH_ORIGIN_AD_ID_SET"
                }
                Self::CannotSetFieldWithAdIdSetForSharing => {
                    "CANNOT_SET_FIELD_WITH_AD_ID_SET_FOR_SHARING"
                }
                Self::CannotSetAllowFlexibleColorFalse => {
                    "CANNOT_SET_ALLOW_FLEXIBLE_COLOR_FALSE"
                }
                Self::CannotSetColorControlWhenNativeFormatSetting => {
                    "CANNOT_SET_COLOR_CONTROL_WHEN_NATIVE_FORMAT_SETTING"
                }
                Self::CannotSetUrl => "CANNOT_SET_URL",
                Self::CannotSetWithoutFinalUrls => "CANNOT_SET_WITHOUT_FINAL_URLS",
                Self::CannotSetWithFinalUrls => "CANNOT_SET_WITH_FINAL_URLS",
                Self::CannotSetWithUrlData => "CANNOT_SET_WITH_URL_DATA",
                Self::CannotUseAdSubclassForOperator => {
                    "CANNOT_USE_AD_SUBCLASS_FOR_OPERATOR"
                }
                Self::CustomerNotApprovedMobileads => "CUSTOMER_NOT_APPROVED_MOBILEADS",
                Self::CustomerNotApprovedThirdpartyAds => {
                    "CUSTOMER_NOT_APPROVED_THIRDPARTY_ADS"
                }
                Self::CustomerNotApprovedThirdpartyRedirectAds => {
                    "CUSTOMER_NOT_APPROVED_THIRDPARTY_REDIRECT_ADS"
                }
                Self::CustomerNotEligible => "CUSTOMER_NOT_ELIGIBLE",
                Self::CustomerNotEligibleForUpdatingBeaconUrl => {
                    "CUSTOMER_NOT_ELIGIBLE_FOR_UPDATING_BEACON_URL"
                }
                Self::DimensionAlreadyInUnion => "DIMENSION_ALREADY_IN_UNION",
                Self::DimensionMustBeSet => "DIMENSION_MUST_BE_SET",
                Self::DimensionNotInUnion => "DIMENSION_NOT_IN_UNION",
                Self::DisplayUrlCannotBeSpecified => "DISPLAY_URL_CANNOT_BE_SPECIFIED",
                Self::DomesticPhoneNumberFormat => "DOMESTIC_PHONE_NUMBER_FORMAT",
                Self::EmergencyPhoneNumber => "EMERGENCY_PHONE_NUMBER",
                Self::EmptyField => "EMPTY_FIELD",
                Self::FeedAttributeMustHaveMappingForTypeId => {
                    "FEED_ATTRIBUTE_MUST_HAVE_MAPPING_FOR_TYPE_ID"
                }
                Self::FeedAttributeMappingTypeMismatch => {
                    "FEED_ATTRIBUTE_MAPPING_TYPE_MISMATCH"
                }
                Self::IllegalAdCustomizerTagUse => "ILLEGAL_AD_CUSTOMIZER_TAG_USE",
                Self::IllegalTagUse => "ILLEGAL_TAG_USE",
                Self::InconsistentDimensions => "INCONSISTENT_DIMENSIONS",
                Self::InconsistentStatusInTemplateUnion => {
                    "INCONSISTENT_STATUS_IN_TEMPLATE_UNION"
                }
                Self::IncorrectLength => "INCORRECT_LENGTH",
                Self::IneligibleForUpgrade => "INELIGIBLE_FOR_UPGRADE",
                Self::InvalidAdAddressCampaignTarget => {
                    "INVALID_AD_ADDRESS_CAMPAIGN_TARGET"
                }
                Self::InvalidAdType => "INVALID_AD_TYPE",
                Self::InvalidAttributesForMobileImage => {
                    "INVALID_ATTRIBUTES_FOR_MOBILE_IMAGE"
                }
                Self::InvalidAttributesForMobileText => {
                    "INVALID_ATTRIBUTES_FOR_MOBILE_TEXT"
                }
                Self::InvalidCallToActionText => "INVALID_CALL_TO_ACTION_TEXT",
                Self::InvalidCharacterForUrl => "INVALID_CHARACTER_FOR_URL",
                Self::InvalidCountryCode => "INVALID_COUNTRY_CODE",
                Self::InvalidExpandedDynamicSearchAdTag => {
                    "INVALID_EXPANDED_DYNAMIC_SEARCH_AD_TAG"
                }
                Self::InvalidInput => "INVALID_INPUT",
                Self::InvalidMarkupLanguage => "INVALID_MARKUP_LANGUAGE",
                Self::InvalidMobileCarrier => "INVALID_MOBILE_CARRIER",
                Self::InvalidMobileCarrierTarget => "INVALID_MOBILE_CARRIER_TARGET",
                Self::InvalidNumberOfElements => "INVALID_NUMBER_OF_ELEMENTS",
                Self::InvalidPhoneNumberFormat => "INVALID_PHONE_NUMBER_FORMAT",
                Self::InvalidRichMediaCertifiedVendorFormatId => {
                    "INVALID_RICH_MEDIA_CERTIFIED_VENDOR_FORMAT_ID"
                }
                Self::InvalidTemplateData => "INVALID_TEMPLATE_DATA",
                Self::InvalidTemplateElementFieldType => {
                    "INVALID_TEMPLATE_ELEMENT_FIELD_TYPE"
                }
                Self::InvalidTemplateId => "INVALID_TEMPLATE_ID",
                Self::LineTooWide => "LINE_TOO_WIDE",
                Self::MissingAdCustomizerMapping => "MISSING_AD_CUSTOMIZER_MAPPING",
                Self::MissingAddressComponent => "MISSING_ADDRESS_COMPONENT",
                Self::MissingAdvertisementName => "MISSING_ADVERTISEMENT_NAME",
                Self::MissingBusinessName => "MISSING_BUSINESS_NAME",
                Self::MissingDescription1 => "MISSING_DESCRIPTION1",
                Self::MissingDescription2 => "MISSING_DESCRIPTION2",
                Self::MissingDestinationUrlTag => "MISSING_DESTINATION_URL_TAG",
                Self::MissingLandingPageUrlTag => "MISSING_LANDING_PAGE_URL_TAG",
                Self::MissingDimension => "MISSING_DIMENSION",
                Self::MissingDisplayUrl => "MISSING_DISPLAY_URL",
                Self::MissingHeadline => "MISSING_HEADLINE",
                Self::MissingHeight => "MISSING_HEIGHT",
                Self::MissingImage => "MISSING_IMAGE",
                Self::MissingMarketingImageOrProductVideos => {
                    "MISSING_MARKETING_IMAGE_OR_PRODUCT_VIDEOS"
                }
                Self::MissingMarkupLanguages => "MISSING_MARKUP_LANGUAGES",
                Self::MissingMobileCarrier => "MISSING_MOBILE_CARRIER",
                Self::MissingPhone => "MISSING_PHONE",
                Self::MissingRequiredTemplateFields => "MISSING_REQUIRED_TEMPLATE_FIELDS",
                Self::MissingTemplateFieldValue => "MISSING_TEMPLATE_FIELD_VALUE",
                Self::MissingText => "MISSING_TEXT",
                Self::MissingVisibleUrl => "MISSING_VISIBLE_URL",
                Self::MissingWidth => "MISSING_WIDTH",
                Self::MultipleDistinctFeedsUnsupported => {
                    "MULTIPLE_DISTINCT_FEEDS_UNSUPPORTED"
                }
                Self::MustUseTempAdUnionIdOnAdd => "MUST_USE_TEMP_AD_UNION_ID_ON_ADD",
                Self::TooLong => "TOO_LONG",
                Self::TooShort => "TOO_SHORT",
                Self::UnionDimensionsCannotChange => "UNION_DIMENSIONS_CANNOT_CHANGE",
                Self::UnknownAddressComponent => "UNKNOWN_ADDRESS_COMPONENT",
                Self::UnknownFieldName => "UNKNOWN_FIELD_NAME",
                Self::UnknownUniqueName => "UNKNOWN_UNIQUE_NAME",
                Self::UnsupportedDimensions => "UNSUPPORTED_DIMENSIONS",
                Self::UrlInvalidScheme => "URL_INVALID_SCHEME",
                Self::UrlInvalidTopLevelDomain => "URL_INVALID_TOP_LEVEL_DOMAIN",
                Self::UrlMalformed => "URL_MALFORMED",
                Self::UrlNoHost => "URL_NO_HOST",
                Self::UrlNotEquivalent => "URL_NOT_EQUIVALENT",
                Self::UrlHostNameTooLong => "URL_HOST_NAME_TOO_LONG",
                Self::UrlNoScheme => "URL_NO_SCHEME",
                Self::UrlNoTopLevelDomain => "URL_NO_TOP_LEVEL_DOMAIN",
                Self::UrlPathNotAllowed => "URL_PATH_NOT_ALLOWED",
                Self::UrlPortNotAllowed => "URL_PORT_NOT_ALLOWED",
                Self::UrlQueryNotAllowed => "URL_QUERY_NOT_ALLOWED",
                Self::UrlSchemeBeforeExpandedDynamicSearchAdTag => {
                    "URL_SCHEME_BEFORE_EXPANDED_DYNAMIC_SEARCH_AD_TAG"
                }
                Self::UserDoesNotHaveAccessToTemplate => {
                    "USER_DOES_NOT_HAVE_ACCESS_TO_TEMPLATE"
                }
                Self::InconsistentExpandableSettings => {
                    "INCONSISTENT_EXPANDABLE_SETTINGS"
                }
                Self::InvalidFormat => "INVALID_FORMAT",
                Self::InvalidFieldText => "INVALID_FIELD_TEXT",
                Self::ElementNotPresent => "ELEMENT_NOT_PRESENT",
                Self::ImageError => "IMAGE_ERROR",
                Self::ValueNotInRange => "VALUE_NOT_IN_RANGE",
                Self::FieldNotPresent => "FIELD_NOT_PRESENT",
                Self::AddressNotComplete => "ADDRESS_NOT_COMPLETE",
                Self::AddressInvalid => "ADDRESS_INVALID",
                Self::VideoRetrievalError => "VIDEO_RETRIEVAL_ERROR",
                Self::AudioError => "AUDIO_ERROR",
                Self::InvalidYoutubeDisplayUrl => "INVALID_YOUTUBE_DISPLAY_URL",
                Self::TooManyProductImages => "TOO_MANY_PRODUCT_IMAGES",
                Self::TooManyProductVideos => "TOO_MANY_PRODUCT_VIDEOS",
                Self::IncompatibleAdTypeAndDevicePreference => {
                    "INCOMPATIBLE_AD_TYPE_AND_DEVICE_PREFERENCE"
                }
                Self::CalltrackingNotSupportedForCountry => {
                    "CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY"
                }
                Self::CarrierSpecificShortNumberNotAllowed => {
                    "CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED"
                }
                Self::DisallowedNumberType => "DISALLOWED_NUMBER_TYPE",
                Self::PhoneNumberNotSupportedForCountry => {
                    "PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY"
                }
                Self::PhoneNumberNotSupportedWithCalltrackingForCountry => {
                    "PHONE_NUMBER_NOT_SUPPORTED_WITH_CALLTRACKING_FOR_COUNTRY"
                }
                Self::PremiumRateNumberNotAllowed => "PREMIUM_RATE_NUMBER_NOT_ALLOWED",
                Self::VanityPhoneNumberNotAllowed => "VANITY_PHONE_NUMBER_NOT_ALLOWED",
                Self::InvalidCallConversionTypeId => "INVALID_CALL_CONVERSION_TYPE_ID",
                Self::CannotDisableCallConversionAndSetConversionTypeId => {
                    "CANNOT_DISABLE_CALL_CONVERSION_AND_SET_CONVERSION_TYPE_ID"
                }
                Self::CannotSetPath2WithoutPath1 => "CANNOT_SET_PATH2_WITHOUT_PATH1",
                Self::MissingDynamicSearchAdsSettingDomainName => {
                    "MISSING_DYNAMIC_SEARCH_ADS_SETTING_DOMAIN_NAME"
                }
                Self::IncompatibleWithRestrictionType => {
                    "INCOMPATIBLE_WITH_RESTRICTION_TYPE"
                }
                Self::CustomerConsentForCallRecordingRequired => {
                    "CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED"
                }
                Self::MissingImageOrMediaBundle => "MISSING_IMAGE_OR_MEDIA_BUNDLE",
                Self::ProductTypeNotSupportedInThisCampaign => {
                    "PRODUCT_TYPE_NOT_SUPPORTED_IN_THIS_CAMPAIGN"
                }
                Self::PlaceholderCannotHaveEmptyDefaultValue => {
                    "PLACEHOLDER_CANNOT_HAVE_EMPTY_DEFAULT_VALUE"
                }
                Self::PlaceholderCountdownFunctionCannotHaveDefaultValue => {
                    "PLACEHOLDER_COUNTDOWN_FUNCTION_CANNOT_HAVE_DEFAULT_VALUE"
                }
                Self::PlaceholderDefaultValueMissing => {
                    "PLACEHOLDER_DEFAULT_VALUE_MISSING"
                }
                Self::UnexpectedPlaceholderDefaultValue => {
                    "UNEXPECTED_PLACEHOLDER_DEFAULT_VALUE"
                }
                Self::AdCustomizersMayNotBeAdjacent => {
                    "AD_CUSTOMIZERS_MAY_NOT_BE_ADJACENT"
                }
                Self::UpdatingAdWithNoEnabledAssociation => {
                    "UPDATING_AD_WITH_NO_ENABLED_ASSOCIATION"
                }
                Self::CallAdVerificationUrlFinalUrlDoesNotHaveSameDomain => {
                    "CALL_AD_VERIFICATION_URL_FINAL_URL_DOES_NOT_HAVE_SAME_DOMAIN"
                }
                Self::CallAdFinalUrlAndVerificationUrlCannotBothBeEmpty => {
                    "CALL_AD_FINAL_URL_AND_VERIFICATION_URL_CANNOT_BOTH_BE_EMPTY"
                }
                Self::TooManyAdCustomizers => "TOO_MANY_AD_CUSTOMIZERS",
                Self::InvalidAdCustomizerFormat => "INVALID_AD_CUSTOMIZER_FORMAT",
                Self::NestedAdCustomizerSyntax => "NESTED_AD_CUSTOMIZER_SYNTAX",
                Self::UnsupportedAdCustomizerSyntax => "UNSUPPORTED_AD_CUSTOMIZER_SYNTAX",
                Self::UnpairedBraceInAdCustomizerTag => {
                    "UNPAIRED_BRACE_IN_AD_CUSTOMIZER_TAG"
                }
                Self::MoreThanOneCountdownTagTypeExists => {
                    "MORE_THAN_ONE_COUNTDOWN_TAG_TYPE_EXISTS"
                }
                Self::DateTimeInCountdownTagIsInvalid => {
                    "DATE_TIME_IN_COUNTDOWN_TAG_IS_INVALID"
                }
                Self::DateTimeInCountdownTagIsPast => {
                    "DATE_TIME_IN_COUNTDOWN_TAG_IS_PAST"
                }
                Self::UnrecognizedAdCustomizerTagFound => {
                    "UNRECOGNIZED_AD_CUSTOMIZER_TAG_FOUND"
                }
                Self::CustomizerTypeForbiddenForField => {
                    "CUSTOMIZER_TYPE_FORBIDDEN_FOR_FIELD"
                }
                Self::InvalidCustomizerAttributeName => {
                    "INVALID_CUSTOMIZER_ATTRIBUTE_NAME"
                }
                Self::StoreMismatch => "STORE_MISMATCH",
                Self::MissingRequiredImageAspectRatio => {
                    "MISSING_REQUIRED_IMAGE_ASPECT_RATIO"
                }
                Self::MismatchedAspectRatios => "MISMATCHED_ASPECT_RATIOS",
                Self::DuplicateImageAcrossCarouselCards => {
                    "DUPLICATE_IMAGE_ACROSS_CAROUSEL_CARDS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_CUSTOMIZERS_NOT_SUPPORTED_FOR_AD_TYPE" => {
                    Some(Self::AdCustomizersNotSupportedForAdType)
                }
                "APPROXIMATELY_TOO_LONG" => Some(Self::ApproximatelyTooLong),
                "APPROXIMATELY_TOO_SHORT" => Some(Self::ApproximatelyTooShort),
                "BAD_SNIPPET" => Some(Self::BadSnippet),
                "CANNOT_MODIFY_AD" => Some(Self::CannotModifyAd),
                "CANNOT_SET_BUSINESS_NAME_IF_URL_SET" => {
                    Some(Self::CannotSetBusinessNameIfUrlSet)
                }
                "CANNOT_SET_FIELD" => Some(Self::CannotSetField),
                "CANNOT_SET_FIELD_WITH_ORIGIN_AD_ID_SET" => {
                    Some(Self::CannotSetFieldWithOriginAdIdSet)
                }
                "CANNOT_SET_FIELD_WITH_AD_ID_SET_FOR_SHARING" => {
                    Some(Self::CannotSetFieldWithAdIdSetForSharing)
                }
                "CANNOT_SET_ALLOW_FLEXIBLE_COLOR_FALSE" => {
                    Some(Self::CannotSetAllowFlexibleColorFalse)
                }
                "CANNOT_SET_COLOR_CONTROL_WHEN_NATIVE_FORMAT_SETTING" => {
                    Some(Self::CannotSetColorControlWhenNativeFormatSetting)
                }
                "CANNOT_SET_URL" => Some(Self::CannotSetUrl),
                "CANNOT_SET_WITHOUT_FINAL_URLS" => Some(Self::CannotSetWithoutFinalUrls),
                "CANNOT_SET_WITH_FINAL_URLS" => Some(Self::CannotSetWithFinalUrls),
                "CANNOT_SET_WITH_URL_DATA" => Some(Self::CannotSetWithUrlData),
                "CANNOT_USE_AD_SUBCLASS_FOR_OPERATOR" => {
                    Some(Self::CannotUseAdSubclassForOperator)
                }
                "CUSTOMER_NOT_APPROVED_MOBILEADS" => {
                    Some(Self::CustomerNotApprovedMobileads)
                }
                "CUSTOMER_NOT_APPROVED_THIRDPARTY_ADS" => {
                    Some(Self::CustomerNotApprovedThirdpartyAds)
                }
                "CUSTOMER_NOT_APPROVED_THIRDPARTY_REDIRECT_ADS" => {
                    Some(Self::CustomerNotApprovedThirdpartyRedirectAds)
                }
                "CUSTOMER_NOT_ELIGIBLE" => Some(Self::CustomerNotEligible),
                "CUSTOMER_NOT_ELIGIBLE_FOR_UPDATING_BEACON_URL" => {
                    Some(Self::CustomerNotEligibleForUpdatingBeaconUrl)
                }
                "DIMENSION_ALREADY_IN_UNION" => Some(Self::DimensionAlreadyInUnion),
                "DIMENSION_MUST_BE_SET" => Some(Self::DimensionMustBeSet),
                "DIMENSION_NOT_IN_UNION" => Some(Self::DimensionNotInUnion),
                "DISPLAY_URL_CANNOT_BE_SPECIFIED" => {
                    Some(Self::DisplayUrlCannotBeSpecified)
                }
                "DOMESTIC_PHONE_NUMBER_FORMAT" => Some(Self::DomesticPhoneNumberFormat),
                "EMERGENCY_PHONE_NUMBER" => Some(Self::EmergencyPhoneNumber),
                "EMPTY_FIELD" => Some(Self::EmptyField),
                "FEED_ATTRIBUTE_MUST_HAVE_MAPPING_FOR_TYPE_ID" => {
                    Some(Self::FeedAttributeMustHaveMappingForTypeId)
                }
                "FEED_ATTRIBUTE_MAPPING_TYPE_MISMATCH" => {
                    Some(Self::FeedAttributeMappingTypeMismatch)
                }
                "ILLEGAL_AD_CUSTOMIZER_TAG_USE" => Some(Self::IllegalAdCustomizerTagUse),
                "ILLEGAL_TAG_USE" => Some(Self::IllegalTagUse),
                "INCONSISTENT_DIMENSIONS" => Some(Self::InconsistentDimensions),
                "INCONSISTENT_STATUS_IN_TEMPLATE_UNION" => {
                    Some(Self::InconsistentStatusInTemplateUnion)
                }
                "INCORRECT_LENGTH" => Some(Self::IncorrectLength),
                "INELIGIBLE_FOR_UPGRADE" => Some(Self::IneligibleForUpgrade),
                "INVALID_AD_ADDRESS_CAMPAIGN_TARGET" => {
                    Some(Self::InvalidAdAddressCampaignTarget)
                }
                "INVALID_AD_TYPE" => Some(Self::InvalidAdType),
                "INVALID_ATTRIBUTES_FOR_MOBILE_IMAGE" => {
                    Some(Self::InvalidAttributesForMobileImage)
                }
                "INVALID_ATTRIBUTES_FOR_MOBILE_TEXT" => {
                    Some(Self::InvalidAttributesForMobileText)
                }
                "INVALID_CALL_TO_ACTION_TEXT" => Some(Self::InvalidCallToActionText),
                "INVALID_CHARACTER_FOR_URL" => Some(Self::InvalidCharacterForUrl),
                "INVALID_COUNTRY_CODE" => Some(Self::InvalidCountryCode),
                "INVALID_EXPANDED_DYNAMIC_SEARCH_AD_TAG" => {
                    Some(Self::InvalidExpandedDynamicSearchAdTag)
                }
                "INVALID_INPUT" => Some(Self::InvalidInput),
                "INVALID_MARKUP_LANGUAGE" => Some(Self::InvalidMarkupLanguage),
                "INVALID_MOBILE_CARRIER" => Some(Self::InvalidMobileCarrier),
                "INVALID_MOBILE_CARRIER_TARGET" => Some(Self::InvalidMobileCarrierTarget),
                "INVALID_NUMBER_OF_ELEMENTS" => Some(Self::InvalidNumberOfElements),
                "INVALID_PHONE_NUMBER_FORMAT" => Some(Self::InvalidPhoneNumberFormat),
                "INVALID_RICH_MEDIA_CERTIFIED_VENDOR_FORMAT_ID" => {
                    Some(Self::InvalidRichMediaCertifiedVendorFormatId)
                }
                "INVALID_TEMPLATE_DATA" => Some(Self::InvalidTemplateData),
                "INVALID_TEMPLATE_ELEMENT_FIELD_TYPE" => {
                    Some(Self::InvalidTemplateElementFieldType)
                }
                "INVALID_TEMPLATE_ID" => Some(Self::InvalidTemplateId),
                "LINE_TOO_WIDE" => Some(Self::LineTooWide),
                "MISSING_AD_CUSTOMIZER_MAPPING" => Some(Self::MissingAdCustomizerMapping),
                "MISSING_ADDRESS_COMPONENT" => Some(Self::MissingAddressComponent),
                "MISSING_ADVERTISEMENT_NAME" => Some(Self::MissingAdvertisementName),
                "MISSING_BUSINESS_NAME" => Some(Self::MissingBusinessName),
                "MISSING_DESCRIPTION1" => Some(Self::MissingDescription1),
                "MISSING_DESCRIPTION2" => Some(Self::MissingDescription2),
                "MISSING_DESTINATION_URL_TAG" => Some(Self::MissingDestinationUrlTag),
                "MISSING_LANDING_PAGE_URL_TAG" => Some(Self::MissingLandingPageUrlTag),
                "MISSING_DIMENSION" => Some(Self::MissingDimension),
                "MISSING_DISPLAY_URL" => Some(Self::MissingDisplayUrl),
                "MISSING_HEADLINE" => Some(Self::MissingHeadline),
                "MISSING_HEIGHT" => Some(Self::MissingHeight),
                "MISSING_IMAGE" => Some(Self::MissingImage),
                "MISSING_MARKETING_IMAGE_OR_PRODUCT_VIDEOS" => {
                    Some(Self::MissingMarketingImageOrProductVideos)
                }
                "MISSING_MARKUP_LANGUAGES" => Some(Self::MissingMarkupLanguages),
                "MISSING_MOBILE_CARRIER" => Some(Self::MissingMobileCarrier),
                "MISSING_PHONE" => Some(Self::MissingPhone),
                "MISSING_REQUIRED_TEMPLATE_FIELDS" => {
                    Some(Self::MissingRequiredTemplateFields)
                }
                "MISSING_TEMPLATE_FIELD_VALUE" => Some(Self::MissingTemplateFieldValue),
                "MISSING_TEXT" => Some(Self::MissingText),
                "MISSING_VISIBLE_URL" => Some(Self::MissingVisibleUrl),
                "MISSING_WIDTH" => Some(Self::MissingWidth),
                "MULTIPLE_DISTINCT_FEEDS_UNSUPPORTED" => {
                    Some(Self::MultipleDistinctFeedsUnsupported)
                }
                "MUST_USE_TEMP_AD_UNION_ID_ON_ADD" => {
                    Some(Self::MustUseTempAdUnionIdOnAdd)
                }
                "TOO_LONG" => Some(Self::TooLong),
                "TOO_SHORT" => Some(Self::TooShort),
                "UNION_DIMENSIONS_CANNOT_CHANGE" => {
                    Some(Self::UnionDimensionsCannotChange)
                }
                "UNKNOWN_ADDRESS_COMPONENT" => Some(Self::UnknownAddressComponent),
                "UNKNOWN_FIELD_NAME" => Some(Self::UnknownFieldName),
                "UNKNOWN_UNIQUE_NAME" => Some(Self::UnknownUniqueName),
                "UNSUPPORTED_DIMENSIONS" => Some(Self::UnsupportedDimensions),
                "URL_INVALID_SCHEME" => Some(Self::UrlInvalidScheme),
                "URL_INVALID_TOP_LEVEL_DOMAIN" => Some(Self::UrlInvalidTopLevelDomain),
                "URL_MALFORMED" => Some(Self::UrlMalformed),
                "URL_NO_HOST" => Some(Self::UrlNoHost),
                "URL_NOT_EQUIVALENT" => Some(Self::UrlNotEquivalent),
                "URL_HOST_NAME_TOO_LONG" => Some(Self::UrlHostNameTooLong),
                "URL_NO_SCHEME" => Some(Self::UrlNoScheme),
                "URL_NO_TOP_LEVEL_DOMAIN" => Some(Self::UrlNoTopLevelDomain),
                "URL_PATH_NOT_ALLOWED" => Some(Self::UrlPathNotAllowed),
                "URL_PORT_NOT_ALLOWED" => Some(Self::UrlPortNotAllowed),
                "URL_QUERY_NOT_ALLOWED" => Some(Self::UrlQueryNotAllowed),
                "URL_SCHEME_BEFORE_EXPANDED_DYNAMIC_SEARCH_AD_TAG" => {
                    Some(Self::UrlSchemeBeforeExpandedDynamicSearchAdTag)
                }
                "USER_DOES_NOT_HAVE_ACCESS_TO_TEMPLATE" => {
                    Some(Self::UserDoesNotHaveAccessToTemplate)
                }
                "INCONSISTENT_EXPANDABLE_SETTINGS" => {
                    Some(Self::InconsistentExpandableSettings)
                }
                "INVALID_FORMAT" => Some(Self::InvalidFormat),
                "INVALID_FIELD_TEXT" => Some(Self::InvalidFieldText),
                "ELEMENT_NOT_PRESENT" => Some(Self::ElementNotPresent),
                "IMAGE_ERROR" => Some(Self::ImageError),
                "VALUE_NOT_IN_RANGE" => Some(Self::ValueNotInRange),
                "FIELD_NOT_PRESENT" => Some(Self::FieldNotPresent),
                "ADDRESS_NOT_COMPLETE" => Some(Self::AddressNotComplete),
                "ADDRESS_INVALID" => Some(Self::AddressInvalid),
                "VIDEO_RETRIEVAL_ERROR" => Some(Self::VideoRetrievalError),
                "AUDIO_ERROR" => Some(Self::AudioError),
                "INVALID_YOUTUBE_DISPLAY_URL" => Some(Self::InvalidYoutubeDisplayUrl),
                "TOO_MANY_PRODUCT_IMAGES" => Some(Self::TooManyProductImages),
                "TOO_MANY_PRODUCT_VIDEOS" => Some(Self::TooManyProductVideos),
                "INCOMPATIBLE_AD_TYPE_AND_DEVICE_PREFERENCE" => {
                    Some(Self::IncompatibleAdTypeAndDevicePreference)
                }
                "CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::CalltrackingNotSupportedForCountry)
                }
                "CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED" => {
                    Some(Self::CarrierSpecificShortNumberNotAllowed)
                }
                "DISALLOWED_NUMBER_TYPE" => Some(Self::DisallowedNumberType),
                "PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::PhoneNumberNotSupportedForCountry)
                }
                "PHONE_NUMBER_NOT_SUPPORTED_WITH_CALLTRACKING_FOR_COUNTRY" => {
                    Some(Self::PhoneNumberNotSupportedWithCalltrackingForCountry)
                }
                "PREMIUM_RATE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::PremiumRateNumberNotAllowed)
                }
                "VANITY_PHONE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::VanityPhoneNumberNotAllowed)
                }
                "INVALID_CALL_CONVERSION_TYPE_ID" => {
                    Some(Self::InvalidCallConversionTypeId)
                }
                "CANNOT_DISABLE_CALL_CONVERSION_AND_SET_CONVERSION_TYPE_ID" => {
                    Some(Self::CannotDisableCallConversionAndSetConversionTypeId)
                }
                "CANNOT_SET_PATH2_WITHOUT_PATH1" => {
                    Some(Self::CannotSetPath2WithoutPath1)
                }
                "MISSING_DYNAMIC_SEARCH_ADS_SETTING_DOMAIN_NAME" => {
                    Some(Self::MissingDynamicSearchAdsSettingDomainName)
                }
                "INCOMPATIBLE_WITH_RESTRICTION_TYPE" => {
                    Some(Self::IncompatibleWithRestrictionType)
                }
                "CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED" => {
                    Some(Self::CustomerConsentForCallRecordingRequired)
                }
                "MISSING_IMAGE_OR_MEDIA_BUNDLE" => Some(Self::MissingImageOrMediaBundle),
                "PRODUCT_TYPE_NOT_SUPPORTED_IN_THIS_CAMPAIGN" => {
                    Some(Self::ProductTypeNotSupportedInThisCampaign)
                }
                "PLACEHOLDER_CANNOT_HAVE_EMPTY_DEFAULT_VALUE" => {
                    Some(Self::PlaceholderCannotHaveEmptyDefaultValue)
                }
                "PLACEHOLDER_COUNTDOWN_FUNCTION_CANNOT_HAVE_DEFAULT_VALUE" => {
                    Some(Self::PlaceholderCountdownFunctionCannotHaveDefaultValue)
                }
                "PLACEHOLDER_DEFAULT_VALUE_MISSING" => {
                    Some(Self::PlaceholderDefaultValueMissing)
                }
                "UNEXPECTED_PLACEHOLDER_DEFAULT_VALUE" => {
                    Some(Self::UnexpectedPlaceholderDefaultValue)
                }
                "AD_CUSTOMIZERS_MAY_NOT_BE_ADJACENT" => {
                    Some(Self::AdCustomizersMayNotBeAdjacent)
                }
                "UPDATING_AD_WITH_NO_ENABLED_ASSOCIATION" => {
                    Some(Self::UpdatingAdWithNoEnabledAssociation)
                }
                "CALL_AD_VERIFICATION_URL_FINAL_URL_DOES_NOT_HAVE_SAME_DOMAIN" => {
                    Some(Self::CallAdVerificationUrlFinalUrlDoesNotHaveSameDomain)
                }
                "CALL_AD_FINAL_URL_AND_VERIFICATION_URL_CANNOT_BOTH_BE_EMPTY" => {
                    Some(Self::CallAdFinalUrlAndVerificationUrlCannotBothBeEmpty)
                }
                "TOO_MANY_AD_CUSTOMIZERS" => Some(Self::TooManyAdCustomizers),
                "INVALID_AD_CUSTOMIZER_FORMAT" => Some(Self::InvalidAdCustomizerFormat),
                "NESTED_AD_CUSTOMIZER_SYNTAX" => Some(Self::NestedAdCustomizerSyntax),
                "UNSUPPORTED_AD_CUSTOMIZER_SYNTAX" => {
                    Some(Self::UnsupportedAdCustomizerSyntax)
                }
                "UNPAIRED_BRACE_IN_AD_CUSTOMIZER_TAG" => {
                    Some(Self::UnpairedBraceInAdCustomizerTag)
                }
                "MORE_THAN_ONE_COUNTDOWN_TAG_TYPE_EXISTS" => {
                    Some(Self::MoreThanOneCountdownTagTypeExists)
                }
                "DATE_TIME_IN_COUNTDOWN_TAG_IS_INVALID" => {
                    Some(Self::DateTimeInCountdownTagIsInvalid)
                }
                "DATE_TIME_IN_COUNTDOWN_TAG_IS_PAST" => {
                    Some(Self::DateTimeInCountdownTagIsPast)
                }
                "UNRECOGNIZED_AD_CUSTOMIZER_TAG_FOUND" => {
                    Some(Self::UnrecognizedAdCustomizerTagFound)
                }
                "CUSTOMIZER_TYPE_FORBIDDEN_FOR_FIELD" => {
                    Some(Self::CustomizerTypeForbiddenForField)
                }
                "INVALID_CUSTOMIZER_ATTRIBUTE_NAME" => {
                    Some(Self::InvalidCustomizerAttributeName)
                }
                "STORE_MISMATCH" => Some(Self::StoreMismatch),
                "MISSING_REQUIRED_IMAGE_ASPECT_RATIO" => {
                    Some(Self::MissingRequiredImageAspectRatio)
                }
                "MISMATCHED_ASPECT_RATIOS" => Some(Self::MismatchedAspectRatios),
                "DUPLICATE_IMAGE_ACROSS_CAROUSEL_CARDS" => {
                    Some(Self::DuplicateImageAcrossCarouselCards)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible ad group ad errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupAdErrorEnum {}
/// Nested message and enum types in `AdGroupAdErrorEnum`.
pub mod ad_group_ad_error_enum {
    /// Enum describing possible ad group ad errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupAdError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// No link found between the adgroup ad and the label.
        AdGroupAdLabelDoesNotExist = 2,
        /// The label has already been attached to the adgroup ad.
        AdGroupAdLabelAlreadyExists = 3,
        /// The specified ad was not found in the adgroup
        AdNotUnderAdgroup = 4,
        /// Removed ads may not be modified
        CannotOperateOnRemovedAdgroupad = 5,
        /// An ad of this type is deprecated and cannot be created. Only deletions
        /// are permitted.
        CannotCreateDeprecatedAds = 6,
        /// Text ads are deprecated and cannot be created. Use expanded text ads
        /// instead.
        CannotCreateTextAds = 7,
        /// A required field was not specified or is an empty string.
        EmptyField = 8,
        /// An ad may only be modified once per call
        ResourceReferencedInMultipleOps = 9,
        /// AdGroupAds with the given ad type cannot be paused.
        AdTypeCannotBePaused = 10,
        /// AdGroupAds with the given ad type cannot be removed.
        AdTypeCannotBeRemoved = 11,
        /// An ad of this type is deprecated and cannot be updated. Only removals
        /// are permitted.
        CannotUpdateDeprecatedAds = 12,
    }
    impl AdGroupAdError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AdGroupAdLabelDoesNotExist => "AD_GROUP_AD_LABEL_DOES_NOT_EXIST",
                Self::AdGroupAdLabelAlreadyExists => "AD_GROUP_AD_LABEL_ALREADY_EXISTS",
                Self::AdNotUnderAdgroup => "AD_NOT_UNDER_ADGROUP",
                Self::CannotOperateOnRemovedAdgroupad => {
                    "CANNOT_OPERATE_ON_REMOVED_ADGROUPAD"
                }
                Self::CannotCreateDeprecatedAds => "CANNOT_CREATE_DEPRECATED_ADS",
                Self::CannotCreateTextAds => "CANNOT_CREATE_TEXT_ADS",
                Self::EmptyField => "EMPTY_FIELD",
                Self::ResourceReferencedInMultipleOps => {
                    "RESOURCE_REFERENCED_IN_MULTIPLE_OPS"
                }
                Self::AdTypeCannotBePaused => "AD_TYPE_CANNOT_BE_PAUSED",
                Self::AdTypeCannotBeRemoved => "AD_TYPE_CANNOT_BE_REMOVED",
                Self::CannotUpdateDeprecatedAds => "CANNOT_UPDATE_DEPRECATED_ADS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_GROUP_AD_LABEL_DOES_NOT_EXIST" => {
                    Some(Self::AdGroupAdLabelDoesNotExist)
                }
                "AD_GROUP_AD_LABEL_ALREADY_EXISTS" => {
                    Some(Self::AdGroupAdLabelAlreadyExists)
                }
                "AD_NOT_UNDER_ADGROUP" => Some(Self::AdNotUnderAdgroup),
                "CANNOT_OPERATE_ON_REMOVED_ADGROUPAD" => {
                    Some(Self::CannotOperateOnRemovedAdgroupad)
                }
                "CANNOT_CREATE_DEPRECATED_ADS" => Some(Self::CannotCreateDeprecatedAds),
                "CANNOT_CREATE_TEXT_ADS" => Some(Self::CannotCreateTextAds),
                "EMPTY_FIELD" => Some(Self::EmptyField),
                "RESOURCE_REFERENCED_IN_MULTIPLE_OPS" => {
                    Some(Self::ResourceReferencedInMultipleOps)
                }
                "AD_TYPE_CANNOT_BE_PAUSED" => Some(Self::AdTypeCannotBePaused),
                "AD_TYPE_CANNOT_BE_REMOVED" => Some(Self::AdTypeCannotBeRemoved),
                "CANNOT_UPDATE_DEPRECATED_ADS" => Some(Self::CannotUpdateDeprecatedAds),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible ad group bid modifier errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupBidModifierErrorEnum {}
/// Nested message and enum types in `AdGroupBidModifierErrorEnum`.
pub mod ad_group_bid_modifier_error_enum {
    /// Enum describing possible ad group bid modifier errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupBidModifierError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The criterion ID does not support bid modification.
        CriterionIdNotSupported = 2,
        /// Cannot override the bid modifier for the given criterion ID if the parent
        /// campaign is opted out of the same criterion.
        CannotOverrideOptedOutCampaignCriterionBidModifier = 3,
    }
    impl AdGroupBidModifierError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CriterionIdNotSupported => "CRITERION_ID_NOT_SUPPORTED",
                Self::CannotOverrideOptedOutCampaignCriterionBidModifier => {
                    "CANNOT_OVERRIDE_OPTED_OUT_CAMPAIGN_CRITERION_BID_MODIFIER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CRITERION_ID_NOT_SUPPORTED" => Some(Self::CriterionIdNotSupported),
                "CANNOT_OVERRIDE_OPTED_OUT_CAMPAIGN_CRITERION_BID_MODIFIER" => {
                    Some(Self::CannotOverrideOptedOutCampaignCriterionBidModifier)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible ad group criterion customizer errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionCustomizerErrorEnum {}
/// Nested message and enum types in `AdGroupCriterionCustomizerErrorEnum`.
pub mod ad_group_criterion_customizer_error_enum {
    /// Enum describing possible ad group criterion customizer errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupCriterionCustomizerError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Only keyword type criterion is allowed to link customizer attribute.
        CriterionIsNotKeyword = 2,
    }
    impl AdGroupCriterionCustomizerError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CriterionIsNotKeyword => "CRITERION_IS_NOT_KEYWORD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CRITERION_IS_NOT_KEYWORD" => Some(Self::CriterionIsNotKeyword),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible ad group criterion errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionErrorEnum {}
/// Nested message and enum types in `AdGroupCriterionErrorEnum`.
pub mod ad_group_criterion_error_enum {
    /// Enum describing possible ad group criterion errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupCriterionError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// No link found between the AdGroupCriterion and the label.
        AdGroupCriterionLabelDoesNotExist = 2,
        /// The label has already been attached to the AdGroupCriterion.
        AdGroupCriterionLabelAlreadyExists = 3,
        /// Negative AdGroupCriterion cannot have labels.
        CannotAddLabelToNegativeCriterion = 4,
        /// Too many operations for a single call.
        TooManyOperations = 5,
        /// Negative ad group criteria are not updateable.
        CantUpdateNegative = 6,
        /// Concrete type of criterion (keyword v.s. placement) is required for ADD
        /// and SET operations.
        ConcreteTypeRequired = 7,
        /// Bid is incompatible with ad group's bidding settings.
        BidIncompatibleWithAdgroup = 8,
        /// Cannot target and exclude the same criterion at once.
        CannotTargetAndExclude = 9,
        /// The URL of a placement is invalid.
        IllegalUrl = 10,
        /// Keyword text was invalid.
        InvalidKeywordText = 11,
        /// Destination URL was invalid.
        InvalidDestinationUrl = 12,
        /// The destination url must contain at least one tag (for example, {lpurl})
        MissingDestinationUrlTag = 13,
        /// Keyword-level cpm bid is not supported
        KeywordLevelBidNotSupportedForManualcpm = 14,
        /// For example, cannot add a biddable ad group criterion that had been
        /// removed.
        InvalidUserStatus = 15,
        /// Criteria type cannot be targeted for the ad group. Either the account is
        /// restricted to keywords only, the criteria type is incompatible with the
        /// campaign's bidding strategy, or the criteria type can only be applied to
        /// campaigns.
        CannotAddCriteriaType = 16,
        /// Criteria type cannot be excluded for the ad group. Refer to the
        /// documentation for a specific criterion to check if it is excludable.
        CannotExcludeCriteriaType = 17,
        /// Partial failure is not supported for shopping campaign mutate operations.
        CampaignTypeNotCompatibleWithPartialFailure = 27,
        /// Operations in the mutate request changes too many shopping ad groups.
        /// Split requests for multiple shopping ad groups across multiple
        /// requests.
        OperationsForTooManyShoppingAdgroups = 28,
        /// Not allowed to modify url fields of an ad group criterion if there are
        /// duplicate elements for that ad group criterion in the request.
        CannotModifyUrlFieldsWithDuplicateElements = 29,
        /// Cannot set url fields without also setting final urls.
        CannotSetWithoutFinalUrls = 30,
        /// Cannot clear final urls if final mobile urls exist.
        CannotClearFinalUrlsIfFinalMobileUrlsExist = 31,
        /// Cannot clear final urls if final app urls exist.
        CannotClearFinalUrlsIfFinalAppUrlsExist = 32,
        /// Cannot clear final urls if tracking url template exists.
        CannotClearFinalUrlsIfTrackingUrlTemplateExists = 33,
        /// Cannot clear final urls if url custom parameters exist.
        CannotClearFinalUrlsIfUrlCustomParametersExist = 34,
        /// Cannot set both destination url and final urls.
        CannotSetBothDestinationUrlAndFinalUrls = 35,
        /// Cannot set both destination url and tracking url template.
        CannotSetBothDestinationUrlAndTrackingUrlTemplate = 36,
        /// Final urls are not supported for this criterion type.
        FinalUrlsNotSupportedForCriterionType = 37,
        /// Final mobile urls are not supported for this criterion type.
        FinalMobileUrlsNotSupportedForCriterionType = 38,
    }
    impl AdGroupCriterionError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AdGroupCriterionLabelDoesNotExist => {
                    "AD_GROUP_CRITERION_LABEL_DOES_NOT_EXIST"
                }
                Self::AdGroupCriterionLabelAlreadyExists => {
                    "AD_GROUP_CRITERION_LABEL_ALREADY_EXISTS"
                }
                Self::CannotAddLabelToNegativeCriterion => {
                    "CANNOT_ADD_LABEL_TO_NEGATIVE_CRITERION"
                }
                Self::TooManyOperations => "TOO_MANY_OPERATIONS",
                Self::CantUpdateNegative => "CANT_UPDATE_NEGATIVE",
                Self::ConcreteTypeRequired => "CONCRETE_TYPE_REQUIRED",
                Self::BidIncompatibleWithAdgroup => "BID_INCOMPATIBLE_WITH_ADGROUP",
                Self::CannotTargetAndExclude => "CANNOT_TARGET_AND_EXCLUDE",
                Self::IllegalUrl => "ILLEGAL_URL",
                Self::InvalidKeywordText => "INVALID_KEYWORD_TEXT",
                Self::InvalidDestinationUrl => "INVALID_DESTINATION_URL",
                Self::MissingDestinationUrlTag => "MISSING_DESTINATION_URL_TAG",
                Self::KeywordLevelBidNotSupportedForManualcpm => {
                    "KEYWORD_LEVEL_BID_NOT_SUPPORTED_FOR_MANUALCPM"
                }
                Self::InvalidUserStatus => "INVALID_USER_STATUS",
                Self::CannotAddCriteriaType => "CANNOT_ADD_CRITERIA_TYPE",
                Self::CannotExcludeCriteriaType => "CANNOT_EXCLUDE_CRITERIA_TYPE",
                Self::CampaignTypeNotCompatibleWithPartialFailure => {
                    "CAMPAIGN_TYPE_NOT_COMPATIBLE_WITH_PARTIAL_FAILURE"
                }
                Self::OperationsForTooManyShoppingAdgroups => {
                    "OPERATIONS_FOR_TOO_MANY_SHOPPING_ADGROUPS"
                }
                Self::CannotModifyUrlFieldsWithDuplicateElements => {
                    "CANNOT_MODIFY_URL_FIELDS_WITH_DUPLICATE_ELEMENTS"
                }
                Self::CannotSetWithoutFinalUrls => "CANNOT_SET_WITHOUT_FINAL_URLS",
                Self::CannotClearFinalUrlsIfFinalMobileUrlsExist => {
                    "CANNOT_CLEAR_FINAL_URLS_IF_FINAL_MOBILE_URLS_EXIST"
                }
                Self::CannotClearFinalUrlsIfFinalAppUrlsExist => {
                    "CANNOT_CLEAR_FINAL_URLS_IF_FINAL_APP_URLS_EXIST"
                }
                Self::CannotClearFinalUrlsIfTrackingUrlTemplateExists => {
                    "CANNOT_CLEAR_FINAL_URLS_IF_TRACKING_URL_TEMPLATE_EXISTS"
                }
                Self::CannotClearFinalUrlsIfUrlCustomParametersExist => {
                    "CANNOT_CLEAR_FINAL_URLS_IF_URL_CUSTOM_PARAMETERS_EXIST"
                }
                Self::CannotSetBothDestinationUrlAndFinalUrls => {
                    "CANNOT_SET_BOTH_DESTINATION_URL_AND_FINAL_URLS"
                }
                Self::CannotSetBothDestinationUrlAndTrackingUrlTemplate => {
                    "CANNOT_SET_BOTH_DESTINATION_URL_AND_TRACKING_URL_TEMPLATE"
                }
                Self::FinalUrlsNotSupportedForCriterionType => {
                    "FINAL_URLS_NOT_SUPPORTED_FOR_CRITERION_TYPE"
                }
                Self::FinalMobileUrlsNotSupportedForCriterionType => {
                    "FINAL_MOBILE_URLS_NOT_SUPPORTED_FOR_CRITERION_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_GROUP_CRITERION_LABEL_DOES_NOT_EXIST" => {
                    Some(Self::AdGroupCriterionLabelDoesNotExist)
                }
                "AD_GROUP_CRITERION_LABEL_ALREADY_EXISTS" => {
                    Some(Self::AdGroupCriterionLabelAlreadyExists)
                }
                "CANNOT_ADD_LABEL_TO_NEGATIVE_CRITERION" => {
                    Some(Self::CannotAddLabelToNegativeCriterion)
                }
                "TOO_MANY_OPERATIONS" => Some(Self::TooManyOperations),
                "CANT_UPDATE_NEGATIVE" => Some(Self::CantUpdateNegative),
                "CONCRETE_TYPE_REQUIRED" => Some(Self::ConcreteTypeRequired),
                "BID_INCOMPATIBLE_WITH_ADGROUP" => Some(Self::BidIncompatibleWithAdgroup),
                "CANNOT_TARGET_AND_EXCLUDE" => Some(Self::CannotTargetAndExclude),
                "ILLEGAL_URL" => Some(Self::IllegalUrl),
                "INVALID_KEYWORD_TEXT" => Some(Self::InvalidKeywordText),
                "INVALID_DESTINATION_URL" => Some(Self::InvalidDestinationUrl),
                "MISSING_DESTINATION_URL_TAG" => Some(Self::MissingDestinationUrlTag),
                "KEYWORD_LEVEL_BID_NOT_SUPPORTED_FOR_MANUALCPM" => {
                    Some(Self::KeywordLevelBidNotSupportedForManualcpm)
                }
                "INVALID_USER_STATUS" => Some(Self::InvalidUserStatus),
                "CANNOT_ADD_CRITERIA_TYPE" => Some(Self::CannotAddCriteriaType),
                "CANNOT_EXCLUDE_CRITERIA_TYPE" => Some(Self::CannotExcludeCriteriaType),
                "CAMPAIGN_TYPE_NOT_COMPATIBLE_WITH_PARTIAL_FAILURE" => {
                    Some(Self::CampaignTypeNotCompatibleWithPartialFailure)
                }
                "OPERATIONS_FOR_TOO_MANY_SHOPPING_ADGROUPS" => {
                    Some(Self::OperationsForTooManyShoppingAdgroups)
                }
                "CANNOT_MODIFY_URL_FIELDS_WITH_DUPLICATE_ELEMENTS" => {
                    Some(Self::CannotModifyUrlFieldsWithDuplicateElements)
                }
                "CANNOT_SET_WITHOUT_FINAL_URLS" => Some(Self::CannotSetWithoutFinalUrls),
                "CANNOT_CLEAR_FINAL_URLS_IF_FINAL_MOBILE_URLS_EXIST" => {
                    Some(Self::CannotClearFinalUrlsIfFinalMobileUrlsExist)
                }
                "CANNOT_CLEAR_FINAL_URLS_IF_FINAL_APP_URLS_EXIST" => {
                    Some(Self::CannotClearFinalUrlsIfFinalAppUrlsExist)
                }
                "CANNOT_CLEAR_FINAL_URLS_IF_TRACKING_URL_TEMPLATE_EXISTS" => {
                    Some(Self::CannotClearFinalUrlsIfTrackingUrlTemplateExists)
                }
                "CANNOT_CLEAR_FINAL_URLS_IF_URL_CUSTOM_PARAMETERS_EXIST" => {
                    Some(Self::CannotClearFinalUrlsIfUrlCustomParametersExist)
                }
                "CANNOT_SET_BOTH_DESTINATION_URL_AND_FINAL_URLS" => {
                    Some(Self::CannotSetBothDestinationUrlAndFinalUrls)
                }
                "CANNOT_SET_BOTH_DESTINATION_URL_AND_TRACKING_URL_TEMPLATE" => {
                    Some(Self::CannotSetBothDestinationUrlAndTrackingUrlTemplate)
                }
                "FINAL_URLS_NOT_SUPPORTED_FOR_CRITERION_TYPE" => {
                    Some(Self::FinalUrlsNotSupportedForCriterionType)
                }
                "FINAL_MOBILE_URLS_NOT_SUPPORTED_FOR_CRITERION_TYPE" => {
                    Some(Self::FinalMobileUrlsNotSupportedForCriterionType)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible ad group customizer errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupCustomizerErrorEnum {}
/// Nested message and enum types in `AdGroupCustomizerErrorEnum`.
pub mod ad_group_customizer_error_enum {
    /// Enum describing possible ad group customizer errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupCustomizerError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
    }
    impl AdGroupCustomizerError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible ad group errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupErrorEnum {}
/// Nested message and enum types in `AdGroupErrorEnum`.
pub mod ad_group_error_enum {
    /// Enum describing possible ad group errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// AdGroup with the same name already exists for the campaign.
        DuplicateAdgroupName = 2,
        /// AdGroup name is not valid.
        InvalidAdgroupName = 3,
        /// Advertiser is not allowed to target sites or set site bids that are not
        /// on the Google Search Network.
        AdvertiserNotOnContentNetwork = 5,
        /// Bid amount is too big.
        BidTooBig = 6,
        /// AdGroup bid does not match the campaign's bidding strategy.
        BidTypeAndBiddingStrategyMismatch = 7,
        /// AdGroup name is required for Add.
        MissingAdgroupName = 8,
        /// No link found between the ad group and the label.
        AdgroupLabelDoesNotExist = 9,
        /// The label has already been attached to the ad group.
        AdgroupLabelAlreadyExists = 10,
        /// The CriterionTypeGroup is not supported for the content bid dimension.
        InvalidContentBidCriterionTypeGroup = 11,
        /// The ad group type is not compatible with the campaign channel type.
        AdGroupTypeNotValidForAdvertisingChannelType = 12,
        /// The ad group type is not supported in the country of sale of the
        /// campaign.
        AdgroupTypeNotSupportedForCampaignSalesCountry = 13,
        /// Ad groups of AdGroupType.SEARCH_DYNAMIC_ADS can only be added to
        /// campaigns that have DynamicSearchAdsSetting attached.
        CannotAddAdgroupOfTypeDsaToCampaignWithoutDsaSetting = 14,
        /// Promoted hotels ad groups are only available to customers on the
        /// allow-list.
        PromotedHotelAdGroupsNotAvailableForCustomer = 15,
        /// The field type cannot be excluded because an active ad group-asset link
        /// of this type exists.
        InvalidExcludedParentAssetFieldType = 16,
        /// The asset set type is invalid for setting the
        /// excluded_parent_asset_set_types field.
        InvalidExcludedParentAssetSetType = 17,
        /// Cannot add ad groups for the campaign type.
        CannotAddAdGroupForCampaignType = 18,
        /// Invalid status for the ad group.
        InvalidStatus = 19,
    }
    impl AdGroupError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DuplicateAdgroupName => "DUPLICATE_ADGROUP_NAME",
                Self::InvalidAdgroupName => "INVALID_ADGROUP_NAME",
                Self::AdvertiserNotOnContentNetwork => {
                    "ADVERTISER_NOT_ON_CONTENT_NETWORK"
                }
                Self::BidTooBig => "BID_TOO_BIG",
                Self::BidTypeAndBiddingStrategyMismatch => {
                    "BID_TYPE_AND_BIDDING_STRATEGY_MISMATCH"
                }
                Self::MissingAdgroupName => "MISSING_ADGROUP_NAME",
                Self::AdgroupLabelDoesNotExist => "ADGROUP_LABEL_DOES_NOT_EXIST",
                Self::AdgroupLabelAlreadyExists => "ADGROUP_LABEL_ALREADY_EXISTS",
                Self::InvalidContentBidCriterionTypeGroup => {
                    "INVALID_CONTENT_BID_CRITERION_TYPE_GROUP"
                }
                Self::AdGroupTypeNotValidForAdvertisingChannelType => {
                    "AD_GROUP_TYPE_NOT_VALID_FOR_ADVERTISING_CHANNEL_TYPE"
                }
                Self::AdgroupTypeNotSupportedForCampaignSalesCountry => {
                    "ADGROUP_TYPE_NOT_SUPPORTED_FOR_CAMPAIGN_SALES_COUNTRY"
                }
                Self::CannotAddAdgroupOfTypeDsaToCampaignWithoutDsaSetting => {
                    "CANNOT_ADD_ADGROUP_OF_TYPE_DSA_TO_CAMPAIGN_WITHOUT_DSA_SETTING"
                }
                Self::PromotedHotelAdGroupsNotAvailableForCustomer => {
                    "PROMOTED_HOTEL_AD_GROUPS_NOT_AVAILABLE_FOR_CUSTOMER"
                }
                Self::InvalidExcludedParentAssetFieldType => {
                    "INVALID_EXCLUDED_PARENT_ASSET_FIELD_TYPE"
                }
                Self::InvalidExcludedParentAssetSetType => {
                    "INVALID_EXCLUDED_PARENT_ASSET_SET_TYPE"
                }
                Self::CannotAddAdGroupForCampaignType => {
                    "CANNOT_ADD_AD_GROUP_FOR_CAMPAIGN_TYPE"
                }
                Self::InvalidStatus => "INVALID_STATUS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_ADGROUP_NAME" => Some(Self::DuplicateAdgroupName),
                "INVALID_ADGROUP_NAME" => Some(Self::InvalidAdgroupName),
                "ADVERTISER_NOT_ON_CONTENT_NETWORK" => {
                    Some(Self::AdvertiserNotOnContentNetwork)
                }
                "BID_TOO_BIG" => Some(Self::BidTooBig),
                "BID_TYPE_AND_BIDDING_STRATEGY_MISMATCH" => {
                    Some(Self::BidTypeAndBiddingStrategyMismatch)
                }
                "MISSING_ADGROUP_NAME" => Some(Self::MissingAdgroupName),
                "ADGROUP_LABEL_DOES_NOT_EXIST" => Some(Self::AdgroupLabelDoesNotExist),
                "ADGROUP_LABEL_ALREADY_EXISTS" => Some(Self::AdgroupLabelAlreadyExists),
                "INVALID_CONTENT_BID_CRITERION_TYPE_GROUP" => {
                    Some(Self::InvalidContentBidCriterionTypeGroup)
                }
                "AD_GROUP_TYPE_NOT_VALID_FOR_ADVERTISING_CHANNEL_TYPE" => {
                    Some(Self::AdGroupTypeNotValidForAdvertisingChannelType)
                }
                "ADGROUP_TYPE_NOT_SUPPORTED_FOR_CAMPAIGN_SALES_COUNTRY" => {
                    Some(Self::AdgroupTypeNotSupportedForCampaignSalesCountry)
                }
                "CANNOT_ADD_ADGROUP_OF_TYPE_DSA_TO_CAMPAIGN_WITHOUT_DSA_SETTING" => {
                    Some(Self::CannotAddAdgroupOfTypeDsaToCampaignWithoutDsaSetting)
                }
                "PROMOTED_HOTEL_AD_GROUPS_NOT_AVAILABLE_FOR_CUSTOMER" => {
                    Some(Self::PromotedHotelAdGroupsNotAvailableForCustomer)
                }
                "INVALID_EXCLUDED_PARENT_ASSET_FIELD_TYPE" => {
                    Some(Self::InvalidExcludedParentAssetFieldType)
                }
                "INVALID_EXCLUDED_PARENT_ASSET_SET_TYPE" => {
                    Some(Self::InvalidExcludedParentAssetSetType)
                }
                "CANNOT_ADD_AD_GROUP_FOR_CAMPAIGN_TYPE" => {
                    Some(Self::CannotAddAdGroupForCampaignType)
                }
                "INVALID_STATUS" => Some(Self::InvalidStatus),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible ad group feed errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupFeedErrorEnum {}
/// Nested message and enum types in `AdGroupFeedErrorEnum`.
pub mod ad_group_feed_error_enum {
    /// Enum describing possible ad group feed errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupFeedError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// An active feed already exists for this ad group and place holder type.
        FeedAlreadyExistsForPlaceholderType = 2,
        /// The specified feed is removed.
        CannotCreateForRemovedFeed = 3,
        /// The AdGroupFeed already exists. UPDATE operation should be used to modify
        /// the existing AdGroupFeed.
        AdgroupFeedAlreadyExists = 4,
        /// Cannot operate on removed AdGroupFeed.
        CannotOperateOnRemovedAdgroupFeed = 5,
        /// Invalid placeholder type.
        InvalidPlaceholderType = 6,
        /// Feed mapping for this placeholder type does not exist.
        MissingFeedmappingForPlaceholderType = 7,
        /// Location AdGroupFeeds cannot be created unless there is a location
        /// CustomerFeed for the specified feed.
        NoExistingLocationCustomerFeed = 8,
    }
    impl AdGroupFeedError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::FeedAlreadyExistsForPlaceholderType => {
                    "FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE"
                }
                Self::CannotCreateForRemovedFeed => "CANNOT_CREATE_FOR_REMOVED_FEED",
                Self::AdgroupFeedAlreadyExists => "ADGROUP_FEED_ALREADY_EXISTS",
                Self::CannotOperateOnRemovedAdgroupFeed => {
                    "CANNOT_OPERATE_ON_REMOVED_ADGROUP_FEED"
                }
                Self::InvalidPlaceholderType => "INVALID_PLACEHOLDER_TYPE",
                Self::MissingFeedmappingForPlaceholderType => {
                    "MISSING_FEEDMAPPING_FOR_PLACEHOLDER_TYPE"
                }
                Self::NoExistingLocationCustomerFeed => {
                    "NO_EXISTING_LOCATION_CUSTOMER_FEED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::FeedAlreadyExistsForPlaceholderType)
                }
                "CANNOT_CREATE_FOR_REMOVED_FEED" => {
                    Some(Self::CannotCreateForRemovedFeed)
                }
                "ADGROUP_FEED_ALREADY_EXISTS" => Some(Self::AdgroupFeedAlreadyExists),
                "CANNOT_OPERATE_ON_REMOVED_ADGROUP_FEED" => {
                    Some(Self::CannotOperateOnRemovedAdgroupFeed)
                }
                "INVALID_PLACEHOLDER_TYPE" => Some(Self::InvalidPlaceholderType),
                "MISSING_FEEDMAPPING_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::MissingFeedmappingForPlaceholderType)
                }
                "NO_EXISTING_LOCATION_CUSTOMER_FEED" => {
                    Some(Self::NoExistingLocationCustomerFeed)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible ad parameter errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdParameterErrorEnum {}
/// Nested message and enum types in `AdParameterErrorEnum`.
pub mod ad_parameter_error_enum {
    /// Enum describing possible ad parameter errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdParameterError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The ad group criterion must be a keyword criterion.
        AdGroupCriterionMustBeKeyword = 2,
        /// The insertion text is invalid.
        InvalidInsertionTextFormat = 3,
    }
    impl AdParameterError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AdGroupCriterionMustBeKeyword => {
                    "AD_GROUP_CRITERION_MUST_BE_KEYWORD"
                }
                Self::InvalidInsertionTextFormat => "INVALID_INSERTION_TEXT_FORMAT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_GROUP_CRITERION_MUST_BE_KEYWORD" => {
                    Some(Self::AdGroupCriterionMustBeKeyword)
                }
                "INVALID_INSERTION_TEXT_FORMAT" => Some(Self::InvalidInsertionTextFormat),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible ad sharing errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdSharingErrorEnum {}
/// Nested message and enum types in `AdSharingErrorEnum`.
pub mod ad_sharing_error_enum {
    /// Enum describing possible ad sharing errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdSharingError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Error resulting in attempting to add an Ad to an AdGroup that already
        /// contains the Ad.
        AdGroupAlreadyContainsAd = 2,
        /// Ad is not compatible with the AdGroup it is being shared with.
        IncompatibleAdUnderAdGroup = 3,
        /// Cannot add AdGroupAd on inactive Ad.
        CannotShareInactiveAd = 4,
    }
    impl AdSharingError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AdGroupAlreadyContainsAd => "AD_GROUP_ALREADY_CONTAINS_AD",
                Self::IncompatibleAdUnderAdGroup => "INCOMPATIBLE_AD_UNDER_AD_GROUP",
                Self::CannotShareInactiveAd => "CANNOT_SHARE_INACTIVE_AD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_GROUP_ALREADY_CONTAINS_AD" => Some(Self::AdGroupAlreadyContainsAd),
                "INCOMPATIBLE_AD_UNDER_AD_GROUP" => {
                    Some(Self::IncompatibleAdUnderAdGroup)
                }
                "CANNOT_SHARE_INACTIVE_AD" => Some(Self::CannotShareInactiveAd),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible adx errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdxErrorEnum {}
/// Nested message and enum types in `AdxErrorEnum`.
pub mod adx_error_enum {
    /// Enum describing possible adx errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdxError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Attempt to use non-AdX feature by AdX customer.
        UnsupportedFeature = 2,
    }
    impl AdxError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::UnsupportedFeature => "UNSUPPORTED_FEATURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNSUPPORTED_FEATURE" => Some(Self::UnsupportedFeature),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible asset errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetErrorEnum {}
/// Nested message and enum types in `AssetErrorEnum`.
pub mod asset_error_enum {
    /// Enum describing possible asset errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The customer is not is not on the allow-list for this asset type.
        CustomerNotOnAllowlistForAssetType = 13,
        /// Assets are duplicated across operations.
        DuplicateAsset = 3,
        /// The asset name is duplicated, either across operations or with an
        /// existing asset.
        DuplicateAssetName = 4,
        /// The Asset.asset_data oneof is empty.
        AssetDataIsMissing = 5,
        /// The asset has a name which is different from an existing duplicate that
        /// represents the same content.
        CannotModifyAssetName = 6,
        /// The field cannot be set for this asset type.
        FieldIncompatibleWithAssetType = 7,
        /// Call to action must come from the list of supported values.
        InvalidCallToActionText = 8,
        /// A lead form asset is created with an invalid combination of input fields.
        LeadFormInvalidFieldsCombination = 9,
        /// Lead forms require that the Terms of Service have been agreed to before
        /// mutates can be executed.
        LeadFormMissingAgreement = 10,
        /// Asset status is invalid in this operation.
        InvalidAssetStatus = 11,
        /// The field cannot be modified by this asset type.
        FieldCannotBeModifiedForAssetType = 12,
        /// Ad schedules for the same asset cannot overlap.
        SchedulesCannotOverlap = 14,
        /// Cannot set both percent off and money amount off fields of promotion
        /// asset.
        PromotionCannotSetPercentOffAndMoneyAmountOff = 15,
        /// Cannot set both promotion code and orders over amount fields of promotion
        /// asset.
        PromotionCannotSetPromotionCodeAndOrdersOverAmount = 16,
        /// The field has too many decimal places specified.
        TooManyDecimalPlacesSpecified = 17,
        /// Duplicate assets across operations, which have identical Asset.asset_data
        /// oneof, cannot have different asset level fields for asset types which are
        /// deduped.
        DuplicateAssetsWithDifferentFieldValue = 18,
        /// Carrier specific short number is not allowed.
        CallCarrierSpecificShortNumberNotAllowed = 19,
        /// Customer consent required for call recording Terms of Service.
        CallCustomerConsentForCallRecordingRequired = 20,
        /// The type of the specified phone number is not allowed.
        CallDisallowedNumberType = 21,
        /// If the default call_conversion_action is not used, the customer must have
        /// a ConversionAction with the same id and the ConversionAction must be call
        /// conversion type.
        CallInvalidConversionAction = 22,
        /// The country code of the phone number is invalid.
        CallInvalidCountryCode = 23,
        /// The format of the phone number is incorrect.
        CallInvalidDomesticPhoneNumberFormat = 24,
        /// The input phone number is not a valid phone number.
        CallInvalidPhoneNumber = 25,
        /// The phone number is not supported for country.
        CallPhoneNumberNotSupportedForCountry = 26,
        /// Premium rate phone number is not allowed.
        CallPremiumRateNumberNotAllowed = 27,
        /// Vanity phone number is not allowed.
        CallVanityPhoneNumberNotAllowed = 28,
        /// PriceOffering cannot have the same value for header and description.
        PriceHeaderSameAsDescription = 29,
        /// AppId is invalid.
        MobileAppInvalidAppId = 30,
        /// Invalid App download URL in final URLs.
        MobileAppInvalidFinalUrlForAppDownloadUrl = 31,
        /// Asset name is required for the asset type.
        NameRequiredForAssetType = 32,
        /// Legacy qualifying questions cannot be in the same Lead Form as
        /// custom questions.
        LeadFormLegacyQualifyingQuestionsDisallowed = 33,
        /// Unique name is required for this asset type.
        NameConflictForAssetType = 34,
        /// Cannot modify asset source.
        CannotModifyAssetSource = 35,
        /// User can not modify the automatically created asset.
        CannotModifyAutomaticallyCreatedAsset = 36,
        /// Lead Form is disallowed to use "LOCATION" answer type.
        LeadFormLocationAnswerTypeDisallowed = 37,
        /// Page Feed label text contains invalid characters.
        PageFeedInvalidLabelText = 38,
    }
    impl AssetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CustomerNotOnAllowlistForAssetType => {
                    "CUSTOMER_NOT_ON_ALLOWLIST_FOR_ASSET_TYPE"
                }
                Self::DuplicateAsset => "DUPLICATE_ASSET",
                Self::DuplicateAssetName => "DUPLICATE_ASSET_NAME",
                Self::AssetDataIsMissing => "ASSET_DATA_IS_MISSING",
                Self::CannotModifyAssetName => "CANNOT_MODIFY_ASSET_NAME",
                Self::FieldIncompatibleWithAssetType => {
                    "FIELD_INCOMPATIBLE_WITH_ASSET_TYPE"
                }
                Self::InvalidCallToActionText => "INVALID_CALL_TO_ACTION_TEXT",
                Self::LeadFormInvalidFieldsCombination => {
                    "LEAD_FORM_INVALID_FIELDS_COMBINATION"
                }
                Self::LeadFormMissingAgreement => "LEAD_FORM_MISSING_AGREEMENT",
                Self::InvalidAssetStatus => "INVALID_ASSET_STATUS",
                Self::FieldCannotBeModifiedForAssetType => {
                    "FIELD_CANNOT_BE_MODIFIED_FOR_ASSET_TYPE"
                }
                Self::SchedulesCannotOverlap => "SCHEDULES_CANNOT_OVERLAP",
                Self::PromotionCannotSetPercentOffAndMoneyAmountOff => {
                    "PROMOTION_CANNOT_SET_PERCENT_OFF_AND_MONEY_AMOUNT_OFF"
                }
                Self::PromotionCannotSetPromotionCodeAndOrdersOverAmount => {
                    "PROMOTION_CANNOT_SET_PROMOTION_CODE_AND_ORDERS_OVER_AMOUNT"
                }
                Self::TooManyDecimalPlacesSpecified => {
                    "TOO_MANY_DECIMAL_PLACES_SPECIFIED"
                }
                Self::DuplicateAssetsWithDifferentFieldValue => {
                    "DUPLICATE_ASSETS_WITH_DIFFERENT_FIELD_VALUE"
                }
                Self::CallCarrierSpecificShortNumberNotAllowed => {
                    "CALL_CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED"
                }
                Self::CallCustomerConsentForCallRecordingRequired => {
                    "CALL_CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED"
                }
                Self::CallDisallowedNumberType => "CALL_DISALLOWED_NUMBER_TYPE",
                Self::CallInvalidConversionAction => "CALL_INVALID_CONVERSION_ACTION",
                Self::CallInvalidCountryCode => "CALL_INVALID_COUNTRY_CODE",
                Self::CallInvalidDomesticPhoneNumberFormat => {
                    "CALL_INVALID_DOMESTIC_PHONE_NUMBER_FORMAT"
                }
                Self::CallInvalidPhoneNumber => "CALL_INVALID_PHONE_NUMBER",
                Self::CallPhoneNumberNotSupportedForCountry => {
                    "CALL_PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY"
                }
                Self::CallPremiumRateNumberNotAllowed => {
                    "CALL_PREMIUM_RATE_NUMBER_NOT_ALLOWED"
                }
                Self::CallVanityPhoneNumberNotAllowed => {
                    "CALL_VANITY_PHONE_NUMBER_NOT_ALLOWED"
                }
                Self::PriceHeaderSameAsDescription => "PRICE_HEADER_SAME_AS_DESCRIPTION",
                Self::MobileAppInvalidAppId => "MOBILE_APP_INVALID_APP_ID",
                Self::MobileAppInvalidFinalUrlForAppDownloadUrl => {
                    "MOBILE_APP_INVALID_FINAL_URL_FOR_APP_DOWNLOAD_URL"
                }
                Self::NameRequiredForAssetType => "NAME_REQUIRED_FOR_ASSET_TYPE",
                Self::LeadFormLegacyQualifyingQuestionsDisallowed => {
                    "LEAD_FORM_LEGACY_QUALIFYING_QUESTIONS_DISALLOWED"
                }
                Self::NameConflictForAssetType => "NAME_CONFLICT_FOR_ASSET_TYPE",
                Self::CannotModifyAssetSource => "CANNOT_MODIFY_ASSET_SOURCE",
                Self::CannotModifyAutomaticallyCreatedAsset => {
                    "CANNOT_MODIFY_AUTOMATICALLY_CREATED_ASSET"
                }
                Self::LeadFormLocationAnswerTypeDisallowed => {
                    "LEAD_FORM_LOCATION_ANSWER_TYPE_DISALLOWED"
                }
                Self::PageFeedInvalidLabelText => "PAGE_FEED_INVALID_LABEL_TEXT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOMER_NOT_ON_ALLOWLIST_FOR_ASSET_TYPE" => {
                    Some(Self::CustomerNotOnAllowlistForAssetType)
                }
                "DUPLICATE_ASSET" => Some(Self::DuplicateAsset),
                "DUPLICATE_ASSET_NAME" => Some(Self::DuplicateAssetName),
                "ASSET_DATA_IS_MISSING" => Some(Self::AssetDataIsMissing),
                "CANNOT_MODIFY_ASSET_NAME" => Some(Self::CannotModifyAssetName),
                "FIELD_INCOMPATIBLE_WITH_ASSET_TYPE" => {
                    Some(Self::FieldIncompatibleWithAssetType)
                }
                "INVALID_CALL_TO_ACTION_TEXT" => Some(Self::InvalidCallToActionText),
                "LEAD_FORM_INVALID_FIELDS_COMBINATION" => {
                    Some(Self::LeadFormInvalidFieldsCombination)
                }
                "LEAD_FORM_MISSING_AGREEMENT" => Some(Self::LeadFormMissingAgreement),
                "INVALID_ASSET_STATUS" => Some(Self::InvalidAssetStatus),
                "FIELD_CANNOT_BE_MODIFIED_FOR_ASSET_TYPE" => {
                    Some(Self::FieldCannotBeModifiedForAssetType)
                }
                "SCHEDULES_CANNOT_OVERLAP" => Some(Self::SchedulesCannotOverlap),
                "PROMOTION_CANNOT_SET_PERCENT_OFF_AND_MONEY_AMOUNT_OFF" => {
                    Some(Self::PromotionCannotSetPercentOffAndMoneyAmountOff)
                }
                "PROMOTION_CANNOT_SET_PROMOTION_CODE_AND_ORDERS_OVER_AMOUNT" => {
                    Some(Self::PromotionCannotSetPromotionCodeAndOrdersOverAmount)
                }
                "TOO_MANY_DECIMAL_PLACES_SPECIFIED" => {
                    Some(Self::TooManyDecimalPlacesSpecified)
                }
                "DUPLICATE_ASSETS_WITH_DIFFERENT_FIELD_VALUE" => {
                    Some(Self::DuplicateAssetsWithDifferentFieldValue)
                }
                "CALL_CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED" => {
                    Some(Self::CallCarrierSpecificShortNumberNotAllowed)
                }
                "CALL_CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED" => {
                    Some(Self::CallCustomerConsentForCallRecordingRequired)
                }
                "CALL_DISALLOWED_NUMBER_TYPE" => Some(Self::CallDisallowedNumberType),
                "CALL_INVALID_CONVERSION_ACTION" => {
                    Some(Self::CallInvalidConversionAction)
                }
                "CALL_INVALID_COUNTRY_CODE" => Some(Self::CallInvalidCountryCode),
                "CALL_INVALID_DOMESTIC_PHONE_NUMBER_FORMAT" => {
                    Some(Self::CallInvalidDomesticPhoneNumberFormat)
                }
                "CALL_INVALID_PHONE_NUMBER" => Some(Self::CallInvalidPhoneNumber),
                "CALL_PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::CallPhoneNumberNotSupportedForCountry)
                }
                "CALL_PREMIUM_RATE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::CallPremiumRateNumberNotAllowed)
                }
                "CALL_VANITY_PHONE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::CallVanityPhoneNumberNotAllowed)
                }
                "PRICE_HEADER_SAME_AS_DESCRIPTION" => {
                    Some(Self::PriceHeaderSameAsDescription)
                }
                "MOBILE_APP_INVALID_APP_ID" => Some(Self::MobileAppInvalidAppId),
                "MOBILE_APP_INVALID_FINAL_URL_FOR_APP_DOWNLOAD_URL" => {
                    Some(Self::MobileAppInvalidFinalUrlForAppDownloadUrl)
                }
                "NAME_REQUIRED_FOR_ASSET_TYPE" => Some(Self::NameRequiredForAssetType),
                "LEAD_FORM_LEGACY_QUALIFYING_QUESTIONS_DISALLOWED" => {
                    Some(Self::LeadFormLegacyQualifyingQuestionsDisallowed)
                }
                "NAME_CONFLICT_FOR_ASSET_TYPE" => Some(Self::NameConflictForAssetType),
                "CANNOT_MODIFY_ASSET_SOURCE" => Some(Self::CannotModifyAssetSource),
                "CANNOT_MODIFY_AUTOMATICALLY_CREATED_ASSET" => {
                    Some(Self::CannotModifyAutomaticallyCreatedAsset)
                }
                "LEAD_FORM_LOCATION_ANSWER_TYPE_DISALLOWED" => {
                    Some(Self::LeadFormLocationAnswerTypeDisallowed)
                }
                "PAGE_FEED_INVALID_LABEL_TEXT" => Some(Self::PageFeedInvalidLabelText),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible asset group asset errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupAssetErrorEnum {}
/// Nested message and enum types in `AssetGroupAssetErrorEnum`.
pub mod asset_group_asset_error_enum {
    /// Enum describing possible asset group asset errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupAssetError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Cannot add duplicated asset group asset.
        DuplicateResource = 2,
        /// Expandable tags are not allowed in description assets.
        ExpandableTagsNotAllowedInDescription = 3,
        /// Ad customizers are not supported in assetgroup's text assets.
        AdCustomizerNotSupported = 4,
        /// Cannot add a HotelPropertyAsset to an AssetGroup that isn't linked
        /// to the parent campaign's hotel_property_asset_set field.
        HotelPropertyAssetNotLinkedToCampaign = 5,
    }
    impl AssetGroupAssetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DuplicateResource => "DUPLICATE_RESOURCE",
                Self::ExpandableTagsNotAllowedInDescription => {
                    "EXPANDABLE_TAGS_NOT_ALLOWED_IN_DESCRIPTION"
                }
                Self::AdCustomizerNotSupported => "AD_CUSTOMIZER_NOT_SUPPORTED",
                Self::HotelPropertyAssetNotLinkedToCampaign => {
                    "HOTEL_PROPERTY_ASSET_NOT_LINKED_TO_CAMPAIGN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_RESOURCE" => Some(Self::DuplicateResource),
                "EXPANDABLE_TAGS_NOT_ALLOWED_IN_DESCRIPTION" => {
                    Some(Self::ExpandableTagsNotAllowedInDescription)
                }
                "AD_CUSTOMIZER_NOT_SUPPORTED" => Some(Self::AdCustomizerNotSupported),
                "HOTEL_PROPERTY_ASSET_NOT_LINKED_TO_CAMPAIGN" => {
                    Some(Self::HotelPropertyAssetNotLinkedToCampaign)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible asset group errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupErrorEnum {}
/// Nested message and enum types in `AssetGroupErrorEnum`.
pub mod asset_group_error_enum {
    /// Enum describing possible asset group errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Each asset group in a single campaign must have a unique name.
        DuplicateName = 2,
        /// Cannot add asset group for the campaign type.
        CannotAddAssetGroupForCampaignType = 3,
        /// Not enough headline asset for a valid asset group.
        NotEnoughHeadlineAsset = 4,
        /// Not enough long headline asset for a valid asset group.
        NotEnoughLongHeadlineAsset = 5,
        /// Not enough description headline asset for a valid asset group.
        NotEnoughDescriptionAsset = 6,
        /// Not enough business name asset for a valid asset group.
        NotEnoughBusinessNameAsset = 7,
        /// Not enough marketing image asset for a valid asset group.
        NotEnoughMarketingImageAsset = 8,
        /// Not enough square marketing image asset for a valid asset group.
        NotEnoughSquareMarketingImageAsset = 9,
        /// Not enough logo asset for a valid asset group.
        NotEnoughLogoAsset = 10,
        /// Final url and shopping merchant url does not have the same domain.
        FinalUrlShoppingMerchantHomePageUrlDomainsDiffer = 11,
        /// Path1 required when path2 is set.
        Path1RequiredWhenPath2IsSet = 12,
        /// At least one short description asset is required for a valid asset group.
        ShortDescriptionRequired = 13,
        /// Final url field is required for asset group.
        FinalUrlRequired = 14,
        /// Final url contains invalid domain name.
        FinalUrlContainsInvalidDomainName = 15,
        /// Ad customizers are not supported in asset group's text field.
        AdCustomizerNotSupported = 16,
        /// Cannot mutate asset group for campaign with removed status.
        CannotMutateAssetGroupForRemovedCampaign = 17,
    }
    impl AssetGroupError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DuplicateName => "DUPLICATE_NAME",
                Self::CannotAddAssetGroupForCampaignType => {
                    "CANNOT_ADD_ASSET_GROUP_FOR_CAMPAIGN_TYPE"
                }
                Self::NotEnoughHeadlineAsset => "NOT_ENOUGH_HEADLINE_ASSET",
                Self::NotEnoughLongHeadlineAsset => "NOT_ENOUGH_LONG_HEADLINE_ASSET",
                Self::NotEnoughDescriptionAsset => "NOT_ENOUGH_DESCRIPTION_ASSET",
                Self::NotEnoughBusinessNameAsset => "NOT_ENOUGH_BUSINESS_NAME_ASSET",
                Self::NotEnoughMarketingImageAsset => "NOT_ENOUGH_MARKETING_IMAGE_ASSET",
                Self::NotEnoughSquareMarketingImageAsset => {
                    "NOT_ENOUGH_SQUARE_MARKETING_IMAGE_ASSET"
                }
                Self::NotEnoughLogoAsset => "NOT_ENOUGH_LOGO_ASSET",
                Self::FinalUrlShoppingMerchantHomePageUrlDomainsDiffer => {
                    "FINAL_URL_SHOPPING_MERCHANT_HOME_PAGE_URL_DOMAINS_DIFFER"
                }
                Self::Path1RequiredWhenPath2IsSet => "PATH1_REQUIRED_WHEN_PATH2_IS_SET",
                Self::ShortDescriptionRequired => "SHORT_DESCRIPTION_REQUIRED",
                Self::FinalUrlRequired => "FINAL_URL_REQUIRED",
                Self::FinalUrlContainsInvalidDomainName => {
                    "FINAL_URL_CONTAINS_INVALID_DOMAIN_NAME"
                }
                Self::AdCustomizerNotSupported => "AD_CUSTOMIZER_NOT_SUPPORTED",
                Self::CannotMutateAssetGroupForRemovedCampaign => {
                    "CANNOT_MUTATE_ASSET_GROUP_FOR_REMOVED_CAMPAIGN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "CANNOT_ADD_ASSET_GROUP_FOR_CAMPAIGN_TYPE" => {
                    Some(Self::CannotAddAssetGroupForCampaignType)
                }
                "NOT_ENOUGH_HEADLINE_ASSET" => Some(Self::NotEnoughHeadlineAsset),
                "NOT_ENOUGH_LONG_HEADLINE_ASSET" => {
                    Some(Self::NotEnoughLongHeadlineAsset)
                }
                "NOT_ENOUGH_DESCRIPTION_ASSET" => Some(Self::NotEnoughDescriptionAsset),
                "NOT_ENOUGH_BUSINESS_NAME_ASSET" => {
                    Some(Self::NotEnoughBusinessNameAsset)
                }
                "NOT_ENOUGH_MARKETING_IMAGE_ASSET" => {
                    Some(Self::NotEnoughMarketingImageAsset)
                }
                "NOT_ENOUGH_SQUARE_MARKETING_IMAGE_ASSET" => {
                    Some(Self::NotEnoughSquareMarketingImageAsset)
                }
                "NOT_ENOUGH_LOGO_ASSET" => Some(Self::NotEnoughLogoAsset),
                "FINAL_URL_SHOPPING_MERCHANT_HOME_PAGE_URL_DOMAINS_DIFFER" => {
                    Some(Self::FinalUrlShoppingMerchantHomePageUrlDomainsDiffer)
                }
                "PATH1_REQUIRED_WHEN_PATH2_IS_SET" => {
                    Some(Self::Path1RequiredWhenPath2IsSet)
                }
                "SHORT_DESCRIPTION_REQUIRED" => Some(Self::ShortDescriptionRequired),
                "FINAL_URL_REQUIRED" => Some(Self::FinalUrlRequired),
                "FINAL_URL_CONTAINS_INVALID_DOMAIN_NAME" => {
                    Some(Self::FinalUrlContainsInvalidDomainName)
                }
                "AD_CUSTOMIZER_NOT_SUPPORTED" => Some(Self::AdCustomizerNotSupported),
                "CANNOT_MUTATE_ASSET_GROUP_FOR_REMOVED_CAMPAIGN" => {
                    Some(Self::CannotMutateAssetGroupForRemovedCampaign)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible asset group listing group filter
/// errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupListingGroupFilterErrorEnum {}
/// Nested message and enum types in `AssetGroupListingGroupFilterErrorEnum`.
pub mod asset_group_listing_group_filter_error_enum {
    /// Enum describing possible asset group listing group filter errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupListingGroupFilterError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Listing group tree is too deep.
        TreeTooDeep = 2,
        /// Listing Group UNIT node cannot have children.
        UnitCannotHaveChildren = 3,
        /// Listing Group SUBDIVISION node must have everything else child.
        SubdivisionMustHaveEverythingElseChild = 4,
        /// Dimension type of Listing Group must be the same as that of its siblings.
        DifferentDimensionTypeBetweenSiblings = 5,
        /// The sibling Listing Groups target exactly the same dimension value.
        SameDimensionValueBetweenSiblings = 6,
        /// The dimension type is the same as one of the ancestor Listing Groups.
        SameDimensionTypeBetweenAncestors = 7,
        /// Each Listing Group tree must have a single root.
        MultipleRoots = 8,
        /// Invalid Listing Group dimension value.
        InvalidDimensionValue = 9,
        /// Hierarchical dimension must refine a dimension of the same type.
        MustRefineHierarchicalParentType = 10,
        /// Invalid Product Bidding Category.
        InvalidProductBiddingCategory = 11,
        /// Modifying case value is allowed only while updating the entire subtree at
        /// the same time.
        ChangingCaseValueWithChildren = 12,
        /// Subdivision node has children which must be removed first.
        SubdivisionHasChildren = 13,
        /// Dimension can't subdivide everything-else node in its own hierarchy.
        CannotRefineHierarchicalEverythingElse = 14,
        /// This dimension type is not allowed in this context.
        DimensionTypeNotAllowed = 15,
        /// All the webpage filters under an AssetGroup should be distinct.
        DuplicateWebpageFilterUnderAssetGroup = 16,
        /// Filter of the listing source type is not allowed in the context.
        ListingSourceNotAllowed = 17,
        /// Exclusion filters are not allowed in the context.
        FilterExclusionNotAllowed = 18,
        /// All the filters under an AssetGroup should have the same listing source.
        MultipleListingSources = 19,
        /// All the conditions in a webpage needs to be of same type.
        MultipleWebpageConditionTypesNotAllowed = 20,
        /// All the webpage types of the filters under an AssetGroup should be of
        /// same type. Example: All the webpage types can be of type custom_label or
        /// url_contains but not both.
        MultipleWebpageTypesPerAssetGroup = 21,
        /// All page feed filter nodes are root nodes and they can't have a parent.
        PageFeedFilterHasParent = 22,
        /// There cannot be more than one mutate operation per request that targets a
        /// single asset group listing group filter.
        MultipleOperationsOnOneNode = 23,
    }
    impl AssetGroupListingGroupFilterError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::TreeTooDeep => "TREE_TOO_DEEP",
                Self::UnitCannotHaveChildren => "UNIT_CANNOT_HAVE_CHILDREN",
                Self::SubdivisionMustHaveEverythingElseChild => {
                    "SUBDIVISION_MUST_HAVE_EVERYTHING_ELSE_CHILD"
                }
                Self::DifferentDimensionTypeBetweenSiblings => {
                    "DIFFERENT_DIMENSION_TYPE_BETWEEN_SIBLINGS"
                }
                Self::SameDimensionValueBetweenSiblings => {
                    "SAME_DIMENSION_VALUE_BETWEEN_SIBLINGS"
                }
                Self::SameDimensionTypeBetweenAncestors => {
                    "SAME_DIMENSION_TYPE_BETWEEN_ANCESTORS"
                }
                Self::MultipleRoots => "MULTIPLE_ROOTS",
                Self::InvalidDimensionValue => "INVALID_DIMENSION_VALUE",
                Self::MustRefineHierarchicalParentType => {
                    "MUST_REFINE_HIERARCHICAL_PARENT_TYPE"
                }
                Self::InvalidProductBiddingCategory => "INVALID_PRODUCT_BIDDING_CATEGORY",
                Self::ChangingCaseValueWithChildren => {
                    "CHANGING_CASE_VALUE_WITH_CHILDREN"
                }
                Self::SubdivisionHasChildren => "SUBDIVISION_HAS_CHILDREN",
                Self::CannotRefineHierarchicalEverythingElse => {
                    "CANNOT_REFINE_HIERARCHICAL_EVERYTHING_ELSE"
                }
                Self::DimensionTypeNotAllowed => "DIMENSION_TYPE_NOT_ALLOWED",
                Self::DuplicateWebpageFilterUnderAssetGroup => {
                    "DUPLICATE_WEBPAGE_FILTER_UNDER_ASSET_GROUP"
                }
                Self::ListingSourceNotAllowed => "LISTING_SOURCE_NOT_ALLOWED",
                Self::FilterExclusionNotAllowed => "FILTER_EXCLUSION_NOT_ALLOWED",
                Self::MultipleListingSources => "MULTIPLE_LISTING_SOURCES",
                Self::MultipleWebpageConditionTypesNotAllowed => {
                    "MULTIPLE_WEBPAGE_CONDITION_TYPES_NOT_ALLOWED"
                }
                Self::MultipleWebpageTypesPerAssetGroup => {
                    "MULTIPLE_WEBPAGE_TYPES_PER_ASSET_GROUP"
                }
                Self::PageFeedFilterHasParent => "PAGE_FEED_FILTER_HAS_PARENT",
                Self::MultipleOperationsOnOneNode => "MULTIPLE_OPERATIONS_ON_ONE_NODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TREE_TOO_DEEP" => Some(Self::TreeTooDeep),
                "UNIT_CANNOT_HAVE_CHILDREN" => Some(Self::UnitCannotHaveChildren),
                "SUBDIVISION_MUST_HAVE_EVERYTHING_ELSE_CHILD" => {
                    Some(Self::SubdivisionMustHaveEverythingElseChild)
                }
                "DIFFERENT_DIMENSION_TYPE_BETWEEN_SIBLINGS" => {
                    Some(Self::DifferentDimensionTypeBetweenSiblings)
                }
                "SAME_DIMENSION_VALUE_BETWEEN_SIBLINGS" => {
                    Some(Self::SameDimensionValueBetweenSiblings)
                }
                "SAME_DIMENSION_TYPE_BETWEEN_ANCESTORS" => {
                    Some(Self::SameDimensionTypeBetweenAncestors)
                }
                "MULTIPLE_ROOTS" => Some(Self::MultipleRoots),
                "INVALID_DIMENSION_VALUE" => Some(Self::InvalidDimensionValue),
                "MUST_REFINE_HIERARCHICAL_PARENT_TYPE" => {
                    Some(Self::MustRefineHierarchicalParentType)
                }
                "INVALID_PRODUCT_BIDDING_CATEGORY" => {
                    Some(Self::InvalidProductBiddingCategory)
                }
                "CHANGING_CASE_VALUE_WITH_CHILDREN" => {
                    Some(Self::ChangingCaseValueWithChildren)
                }
                "SUBDIVISION_HAS_CHILDREN" => Some(Self::SubdivisionHasChildren),
                "CANNOT_REFINE_HIERARCHICAL_EVERYTHING_ELSE" => {
                    Some(Self::CannotRefineHierarchicalEverythingElse)
                }
                "DIMENSION_TYPE_NOT_ALLOWED" => Some(Self::DimensionTypeNotAllowed),
                "DUPLICATE_WEBPAGE_FILTER_UNDER_ASSET_GROUP" => {
                    Some(Self::DuplicateWebpageFilterUnderAssetGroup)
                }
                "LISTING_SOURCE_NOT_ALLOWED" => Some(Self::ListingSourceNotAllowed),
                "FILTER_EXCLUSION_NOT_ALLOWED" => Some(Self::FilterExclusionNotAllowed),
                "MULTIPLE_LISTING_SOURCES" => Some(Self::MultipleListingSources),
                "MULTIPLE_WEBPAGE_CONDITION_TYPES_NOT_ALLOWED" => {
                    Some(Self::MultipleWebpageConditionTypesNotAllowed)
                }
                "MULTIPLE_WEBPAGE_TYPES_PER_ASSET_GROUP" => {
                    Some(Self::MultipleWebpageTypesPerAssetGroup)
                }
                "PAGE_FEED_FILTER_HAS_PARENT" => Some(Self::PageFeedFilterHasParent),
                "MULTIPLE_OPERATIONS_ON_ONE_NODE" => {
                    Some(Self::MultipleOperationsOnOneNode)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible asset group signal errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupSignalErrorEnum {}
/// Nested message and enum types in `AssetGroupSignalErrorEnum`.
pub mod asset_group_signal_error_enum {
    /// Enum describing possible asset group signal errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupSignalError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The number of words in the Search Theme signal exceed the allowed
        /// maximum. You can add up to 10 words in a keyword. See
        /// <https://support.google.com/google-ads/answer/7476658> for details.
        TooManyWords = 2,
        /// The search theme requested to be added violates certain policy.
        /// See <https://support.google.com/adspolicy/answer/6008942.>
        SearchThemePolicyViolation = 3,
        /// The asset group referenced by the asset group signal does not match the
        /// asset group referenced by the audience being used in the asset group
        /// signal.
        AudienceWithWrongAssetGroupId = 4,
    }
    impl AssetGroupSignalError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::TooManyWords => "TOO_MANY_WORDS",
                Self::SearchThemePolicyViolation => "SEARCH_THEME_POLICY_VIOLATION",
                Self::AudienceWithWrongAssetGroupId => {
                    "AUDIENCE_WITH_WRONG_ASSET_GROUP_ID"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TOO_MANY_WORDS" => Some(Self::TooManyWords),
                "SEARCH_THEME_POLICY_VIOLATION" => Some(Self::SearchThemePolicyViolation),
                "AUDIENCE_WITH_WRONG_ASSET_GROUP_ID" => {
                    Some(Self::AudienceWithWrongAssetGroupId)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible asset link errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetLinkErrorEnum {}
/// Nested message and enum types in `AssetLinkErrorEnum`.
pub mod asset_link_error_enum {
    /// Enum describing possible asset link errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetLinkError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Pinning is not supported for the given asset link field.
        PinningUnsupported = 2,
        /// The given field type is not supported to be added directly through asset
        /// links.
        UnsupportedFieldType = 3,
        /// The given asset's type and the specified field type are incompatible.
        FieldTypeIncompatibleWithAssetType = 4,
        /// The specified field type is incompatible with the given campaign type.
        FieldTypeIncompatibleWithCampaignType = 5,
        /// The campaign advertising channel type cannot be associated with the given
        /// asset due to channel-based restrictions on the asset's fields.
        IncompatibleAdvertisingChannelType = 6,
        /// The image asset provided is not within the dimension constraints
        /// specified for the submitted asset field.
        ImageNotWithinSpecifiedDimensionRange = 7,
        /// The pinned field is not valid for the submitted asset field.
        InvalidPinnedField = 8,
        /// The media bundle asset provided is too large for the submitted asset
        /// field.
        MediaBundleAssetFileSizeTooLarge = 9,
        /// Not enough assets are available for use with other fields since other
        /// assets are pinned to specific fields.
        NotEnoughAvailableAssetLinksForValidCombination = 10,
        /// Not enough assets with fallback are available. When validating the
        /// minimum number of assets, assets without fallback (for example, assets
        /// that contain location tag without default value "{LOCATION(City)}") will
        /// not be counted.
        NotEnoughAvailableAssetLinksWithFallback = 11,
        /// This is a combination of the
        /// NOT_ENOUGH_AVAILABLE_ASSET_LINKS_FOR_VALID_COMBINATION and
        /// NOT_ENOUGH_AVAILABLE_ASSET_LINKS_WITH_FALLBACK errors. Not enough assets
        /// with fallback are available since some assets are pinned.
        NotEnoughAvailableAssetLinksWithFallbackForValidCombination = 12,
        /// The YouTube video referenced in the provided asset has been removed.
        YoutubeVideoRemoved = 13,
        /// The YouTube video referenced in the provided asset is too long for the
        /// field submitted.
        YoutubeVideoTooLong = 14,
        /// The YouTube video referenced in the provided asset is too short for the
        /// field submitted.
        YoutubeVideoTooShort = 15,
        /// The specified field type is excluded for given campaign or ad group.
        ExcludedParentFieldType = 16,
        /// The status is invalid for the operation specified.
        InvalidStatus = 17,
        /// The YouTube video referenced in the provided asset has unknown duration.
        /// This might be the case for a livestream video or a video being currently
        /// uploaded to YouTube. In both cases, the video duration should eventually
        /// get resolved.
        YoutubeVideoDurationNotDefined = 18,
        /// User cannot create automatically created links.
        CannotCreateAutomaticallyCreatedLinks = 19,
        /// Advertiser links cannot link to automatically created asset.
        CannotLinkToAutomaticallyCreatedAsset = 20,
        /// Automatically created links cannot be changed into advertiser links or
        /// the reverse.
        CannotModifyAssetLinkSource = 21,
        /// Lead Form asset with Location answer type can't be linked to the
        /// Customer/Campaign because there are no Location assets.
        CannotLinkLocationLeadFormWithoutLocationAsset = 22,
        /// Customer is not verified.
        CustomerNotVerified = 23,
        /// Call to action value is not supported.
        UnsupportedCallToAction = 24,
    }
    impl AssetLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::PinningUnsupported => "PINNING_UNSUPPORTED",
                Self::UnsupportedFieldType => "UNSUPPORTED_FIELD_TYPE",
                Self::FieldTypeIncompatibleWithAssetType => {
                    "FIELD_TYPE_INCOMPATIBLE_WITH_ASSET_TYPE"
                }
                Self::FieldTypeIncompatibleWithCampaignType => {
                    "FIELD_TYPE_INCOMPATIBLE_WITH_CAMPAIGN_TYPE"
                }
                Self::IncompatibleAdvertisingChannelType => {
                    "INCOMPATIBLE_ADVERTISING_CHANNEL_TYPE"
                }
                Self::ImageNotWithinSpecifiedDimensionRange => {
                    "IMAGE_NOT_WITHIN_SPECIFIED_DIMENSION_RANGE"
                }
                Self::InvalidPinnedField => "INVALID_PINNED_FIELD",
                Self::MediaBundleAssetFileSizeTooLarge => {
                    "MEDIA_BUNDLE_ASSET_FILE_SIZE_TOO_LARGE"
                }
                Self::NotEnoughAvailableAssetLinksForValidCombination => {
                    "NOT_ENOUGH_AVAILABLE_ASSET_LINKS_FOR_VALID_COMBINATION"
                }
                Self::NotEnoughAvailableAssetLinksWithFallback => {
                    "NOT_ENOUGH_AVAILABLE_ASSET_LINKS_WITH_FALLBACK"
                }
                Self::NotEnoughAvailableAssetLinksWithFallbackForValidCombination => {
                    "NOT_ENOUGH_AVAILABLE_ASSET_LINKS_WITH_FALLBACK_FOR_VALID_COMBINATION"
                }
                Self::YoutubeVideoRemoved => "YOUTUBE_VIDEO_REMOVED",
                Self::YoutubeVideoTooLong => "YOUTUBE_VIDEO_TOO_LONG",
                Self::YoutubeVideoTooShort => "YOUTUBE_VIDEO_TOO_SHORT",
                Self::ExcludedParentFieldType => "EXCLUDED_PARENT_FIELD_TYPE",
                Self::InvalidStatus => "INVALID_STATUS",
                Self::YoutubeVideoDurationNotDefined => {
                    "YOUTUBE_VIDEO_DURATION_NOT_DEFINED"
                }
                Self::CannotCreateAutomaticallyCreatedLinks => {
                    "CANNOT_CREATE_AUTOMATICALLY_CREATED_LINKS"
                }
                Self::CannotLinkToAutomaticallyCreatedAsset => {
                    "CANNOT_LINK_TO_AUTOMATICALLY_CREATED_ASSET"
                }
                Self::CannotModifyAssetLinkSource => "CANNOT_MODIFY_ASSET_LINK_SOURCE",
                Self::CannotLinkLocationLeadFormWithoutLocationAsset => {
                    "CANNOT_LINK_LOCATION_LEAD_FORM_WITHOUT_LOCATION_ASSET"
                }
                Self::CustomerNotVerified => "CUSTOMER_NOT_VERIFIED",
                Self::UnsupportedCallToAction => "UNSUPPORTED_CALL_TO_ACTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PINNING_UNSUPPORTED" => Some(Self::PinningUnsupported),
                "UNSUPPORTED_FIELD_TYPE" => Some(Self::UnsupportedFieldType),
                "FIELD_TYPE_INCOMPATIBLE_WITH_ASSET_TYPE" => {
                    Some(Self::FieldTypeIncompatibleWithAssetType)
                }
                "FIELD_TYPE_INCOMPATIBLE_WITH_CAMPAIGN_TYPE" => {
                    Some(Self::FieldTypeIncompatibleWithCampaignType)
                }
                "INCOMPATIBLE_ADVERTISING_CHANNEL_TYPE" => {
                    Some(Self::IncompatibleAdvertisingChannelType)
                }
                "IMAGE_NOT_WITHIN_SPECIFIED_DIMENSION_RANGE" => {
                    Some(Self::ImageNotWithinSpecifiedDimensionRange)
                }
                "INVALID_PINNED_FIELD" => Some(Self::InvalidPinnedField),
                "MEDIA_BUNDLE_ASSET_FILE_SIZE_TOO_LARGE" => {
                    Some(Self::MediaBundleAssetFileSizeTooLarge)
                }
                "NOT_ENOUGH_AVAILABLE_ASSET_LINKS_FOR_VALID_COMBINATION" => {
                    Some(Self::NotEnoughAvailableAssetLinksForValidCombination)
                }
                "NOT_ENOUGH_AVAILABLE_ASSET_LINKS_WITH_FALLBACK" => {
                    Some(Self::NotEnoughAvailableAssetLinksWithFallback)
                }
                "NOT_ENOUGH_AVAILABLE_ASSET_LINKS_WITH_FALLBACK_FOR_VALID_COMBINATION" => {
                    Some(
                        Self::NotEnoughAvailableAssetLinksWithFallbackForValidCombination,
                    )
                }
                "YOUTUBE_VIDEO_REMOVED" => Some(Self::YoutubeVideoRemoved),
                "YOUTUBE_VIDEO_TOO_LONG" => Some(Self::YoutubeVideoTooLong),
                "YOUTUBE_VIDEO_TOO_SHORT" => Some(Self::YoutubeVideoTooShort),
                "EXCLUDED_PARENT_FIELD_TYPE" => Some(Self::ExcludedParentFieldType),
                "INVALID_STATUS" => Some(Self::InvalidStatus),
                "YOUTUBE_VIDEO_DURATION_NOT_DEFINED" => {
                    Some(Self::YoutubeVideoDurationNotDefined)
                }
                "CANNOT_CREATE_AUTOMATICALLY_CREATED_LINKS" => {
                    Some(Self::CannotCreateAutomaticallyCreatedLinks)
                }
                "CANNOT_LINK_TO_AUTOMATICALLY_CREATED_ASSET" => {
                    Some(Self::CannotLinkToAutomaticallyCreatedAsset)
                }
                "CANNOT_MODIFY_ASSET_LINK_SOURCE" => {
                    Some(Self::CannotModifyAssetLinkSource)
                }
                "CANNOT_LINK_LOCATION_LEAD_FORM_WITHOUT_LOCATION_ASSET" => {
                    Some(Self::CannotLinkLocationLeadFormWithoutLocationAsset)
                }
                "CUSTOMER_NOT_VERIFIED" => Some(Self::CustomerNotVerified),
                "UNSUPPORTED_CALL_TO_ACTION" => Some(Self::UnsupportedCallToAction),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible asset set asset errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSetAssetErrorEnum {}
/// Nested message and enum types in `AssetSetAssetErrorEnum`.
pub mod asset_set_asset_error_enum {
    /// Enum describing possible asset set asset errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSetAssetError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The asset type is not eligible to be linked to the specific type of asset
        /// set.
        InvalidAssetType = 2,
        /// The asset set type is not eligible to contain the specified type of
        /// assets.
        InvalidAssetSetType = 3,
        /// The asset contains duplicate external key with another asset in the asset
        /// set.
        DuplicateExternalKey = 4,
        /// When attaching a Location typed Asset to a LocationGroup typed AssetSet,
        /// the AssetSetAsset linkage between the parent LocationSync AssetSet and
        /// the Asset doesn't exist.
        ParentLinkageDoesNotExist = 5,
    }
    impl AssetSetAssetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidAssetType => "INVALID_ASSET_TYPE",
                Self::InvalidAssetSetType => "INVALID_ASSET_SET_TYPE",
                Self::DuplicateExternalKey => "DUPLICATE_EXTERNAL_KEY",
                Self::ParentLinkageDoesNotExist => "PARENT_LINKAGE_DOES_NOT_EXIST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_ASSET_TYPE" => Some(Self::InvalidAssetType),
                "INVALID_ASSET_SET_TYPE" => Some(Self::InvalidAssetSetType),
                "DUPLICATE_EXTERNAL_KEY" => Some(Self::DuplicateExternalKey),
                "PARENT_LINKAGE_DOES_NOT_EXIST" => Some(Self::ParentLinkageDoesNotExist),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible asset set errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSetErrorEnum {}
/// Nested message and enum types in `AssetSetErrorEnum`.
pub mod asset_set_error_enum {
    /// Enum describing possible asset set errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSetError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The asset set name matches that of another enabled asset set.
        DuplicateAssetSetName = 2,
        /// The type of AssetSet.asset_set_source does not match the type of
        /// AssetSet.location_set.source in its parent AssetSet.
        InvalidParentAssetSetType = 3,
        /// The asset set source doesn't match its parent AssetSet's data.
        AssetSetSourceIncompatibleWithParentAssetSet = 4,
        /// This AssetSet type cannot be linked to CustomerAssetSet.
        AssetSetTypeCannotBeLinkedToCustomer = 5,
        /// The chain id(s) in ChainSet of a LOCATION_SYNC typed AssetSet is invalid.
        InvalidChainIds = 6,
        /// The relationship type in ChainSet of a LOCATION_SYNC typed AssetSet is
        /// not supported.
        LocationSyncAssetSetDoesNotSupportRelationshipType = 7,
        /// There is more than one enabled LocationSync typed AssetSet under one
        /// customer.
        NotUniqueEnabledLocationSyncTypedAssetSet = 8,
        /// The place id(s) in a LocationSync typed AssetSet is invalid and can't be
        /// decoded.
        InvalidPlaceIds = 9,
        /// The Google Business Profile OAuth info is invalid.
        OauthInfoInvalid = 11,
        /// The Google Business Profile OAuth info is missing.
        OauthInfoMissing = 12,
        /// Can't delete an AssetSet if it has any enabled linkages (e.g.
        /// CustomerAssetSet), or AssetSet is a parent AssetSet and has enabled child
        /// AssetSet associated.
        CannotDeleteAsEnabledLinkagesExist = 10,
    }
    impl AssetSetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DuplicateAssetSetName => "DUPLICATE_ASSET_SET_NAME",
                Self::InvalidParentAssetSetType => "INVALID_PARENT_ASSET_SET_TYPE",
                Self::AssetSetSourceIncompatibleWithParentAssetSet => {
                    "ASSET_SET_SOURCE_INCOMPATIBLE_WITH_PARENT_ASSET_SET"
                }
                Self::AssetSetTypeCannotBeLinkedToCustomer => {
                    "ASSET_SET_TYPE_CANNOT_BE_LINKED_TO_CUSTOMER"
                }
                Self::InvalidChainIds => "INVALID_CHAIN_IDS",
                Self::LocationSyncAssetSetDoesNotSupportRelationshipType => {
                    "LOCATION_SYNC_ASSET_SET_DOES_NOT_SUPPORT_RELATIONSHIP_TYPE"
                }
                Self::NotUniqueEnabledLocationSyncTypedAssetSet => {
                    "NOT_UNIQUE_ENABLED_LOCATION_SYNC_TYPED_ASSET_SET"
                }
                Self::InvalidPlaceIds => "INVALID_PLACE_IDS",
                Self::OauthInfoInvalid => "OAUTH_INFO_INVALID",
                Self::OauthInfoMissing => "OAUTH_INFO_MISSING",
                Self::CannotDeleteAsEnabledLinkagesExist => {
                    "CANNOT_DELETE_AS_ENABLED_LINKAGES_EXIST"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_ASSET_SET_NAME" => Some(Self::DuplicateAssetSetName),
                "INVALID_PARENT_ASSET_SET_TYPE" => Some(Self::InvalidParentAssetSetType),
                "ASSET_SET_SOURCE_INCOMPATIBLE_WITH_PARENT_ASSET_SET" => {
                    Some(Self::AssetSetSourceIncompatibleWithParentAssetSet)
                }
                "ASSET_SET_TYPE_CANNOT_BE_LINKED_TO_CUSTOMER" => {
                    Some(Self::AssetSetTypeCannotBeLinkedToCustomer)
                }
                "INVALID_CHAIN_IDS" => Some(Self::InvalidChainIds),
                "LOCATION_SYNC_ASSET_SET_DOES_NOT_SUPPORT_RELATIONSHIP_TYPE" => {
                    Some(Self::LocationSyncAssetSetDoesNotSupportRelationshipType)
                }
                "NOT_UNIQUE_ENABLED_LOCATION_SYNC_TYPED_ASSET_SET" => {
                    Some(Self::NotUniqueEnabledLocationSyncTypedAssetSet)
                }
                "INVALID_PLACE_IDS" => Some(Self::InvalidPlaceIds),
                "OAUTH_INFO_INVALID" => Some(Self::OauthInfoInvalid),
                "OAUTH_INFO_MISSING" => Some(Self::OauthInfoMissing),
                "CANNOT_DELETE_AS_ENABLED_LINKAGES_EXIST" => {
                    Some(Self::CannotDeleteAsEnabledLinkagesExist)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible asset set link errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSetLinkErrorEnum {}
/// Nested message and enum types in `AssetSetLinkErrorEnum`.
pub mod asset_set_link_error_enum {
    /// Enum describing possible asset set link errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSetLinkError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Advertising channel type cannot be attached to the asset set due to
        /// channel-based restrictions.
        IncompatibleAdvertisingChannelType = 2,
        /// For this asset set type, only one campaign to feed linkage is allowed.
        DuplicateFeedLink = 3,
        /// The asset set type and campaign type are incompatible.
        IncompatibleAssetSetTypeWithCampaignType = 4,
        /// Cannot link duplicate asset sets to the same campaign.
        DuplicateAssetSetLink = 5,
        /// Cannot remove the asset set link. If a campaign is linked with only one
        /// asset set and you attempt to unlink them, this error will be triggered.
        AssetSetLinkCannotBeRemoved = 6,
    }
    impl AssetSetLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::IncompatibleAdvertisingChannelType => {
                    "INCOMPATIBLE_ADVERTISING_CHANNEL_TYPE"
                }
                Self::DuplicateFeedLink => "DUPLICATE_FEED_LINK",
                Self::IncompatibleAssetSetTypeWithCampaignType => {
                    "INCOMPATIBLE_ASSET_SET_TYPE_WITH_CAMPAIGN_TYPE"
                }
                Self::DuplicateAssetSetLink => "DUPLICATE_ASSET_SET_LINK",
                Self::AssetSetLinkCannotBeRemoved => "ASSET_SET_LINK_CANNOT_BE_REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INCOMPATIBLE_ADVERTISING_CHANNEL_TYPE" => {
                    Some(Self::IncompatibleAdvertisingChannelType)
                }
                "DUPLICATE_FEED_LINK" => Some(Self::DuplicateFeedLink),
                "INCOMPATIBLE_ASSET_SET_TYPE_WITH_CAMPAIGN_TYPE" => {
                    Some(Self::IncompatibleAssetSetTypeWithCampaignType)
                }
                "DUPLICATE_ASSET_SET_LINK" => Some(Self::DuplicateAssetSetLink),
                "ASSET_SET_LINK_CANNOT_BE_REMOVED" => {
                    Some(Self::AssetSetLinkCannotBeRemoved)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible audience errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudienceErrorEnum {}
/// Nested message and enum types in `AudienceErrorEnum`.
pub mod audience_error_enum {
    /// Enum describing possible audience errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AudienceError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// An audience with this name already exists.
        NameAlreadyInUse = 2,
        /// A dimension within the audience definition is not valid.
        DimensionInvalid = 3,
        /// One of the audience segment added is not found.
        AudienceSegmentNotFound = 4,
        /// One of the audience segment type is not supported.
        AudienceSegmentTypeNotSupported = 5,
        /// The same segment already exists in this audience.
        DuplicateAudienceSegment = 6,
        /// Audience can't have more than allowed number segments.
        TooManySegments = 7,
        /// Audience can't have multiple dimensions of same type.
        TooManyDimensionsOfSameType = 8,
        /// The audience cannot be removed, because it is currently used in an
        /// ad group criterion or asset group signal in an (enabled or paused)
        /// ad group or campaign.
        InUse = 9,
        /// Asset Group scoped audience requires an asset group ID.
        MissingAssetGroupId = 10,
        /// Audience scope may not be changed from Customer to AssetGroup.
        CannotChangeFromCustomerToAssetGroupScope = 11,
    }
    impl AudienceError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NameAlreadyInUse => "NAME_ALREADY_IN_USE",
                Self::DimensionInvalid => "DIMENSION_INVALID",
                Self::AudienceSegmentNotFound => "AUDIENCE_SEGMENT_NOT_FOUND",
                Self::AudienceSegmentTypeNotSupported => {
                    "AUDIENCE_SEGMENT_TYPE_NOT_SUPPORTED"
                }
                Self::DuplicateAudienceSegment => "DUPLICATE_AUDIENCE_SEGMENT",
                Self::TooManySegments => "TOO_MANY_SEGMENTS",
                Self::TooManyDimensionsOfSameType => "TOO_MANY_DIMENSIONS_OF_SAME_TYPE",
                Self::InUse => "IN_USE",
                Self::MissingAssetGroupId => "MISSING_ASSET_GROUP_ID",
                Self::CannotChangeFromCustomerToAssetGroupScope => {
                    "CANNOT_CHANGE_FROM_CUSTOMER_TO_ASSET_GROUP_SCOPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NAME_ALREADY_IN_USE" => Some(Self::NameAlreadyInUse),
                "DIMENSION_INVALID" => Some(Self::DimensionInvalid),
                "AUDIENCE_SEGMENT_NOT_FOUND" => Some(Self::AudienceSegmentNotFound),
                "AUDIENCE_SEGMENT_TYPE_NOT_SUPPORTED" => {
                    Some(Self::AudienceSegmentTypeNotSupported)
                }
                "DUPLICATE_AUDIENCE_SEGMENT" => Some(Self::DuplicateAudienceSegment),
                "TOO_MANY_SEGMENTS" => Some(Self::TooManySegments),
                "TOO_MANY_DIMENSIONS_OF_SAME_TYPE" => {
                    Some(Self::TooManyDimensionsOfSameType)
                }
                "IN_USE" => Some(Self::InUse),
                "MISSING_ASSET_GROUP_ID" => Some(Self::MissingAssetGroupId),
                "CANNOT_CHANGE_FROM_CUSTOMER_TO_ASSET_GROUP_SCOPE" => {
                    Some(Self::CannotChangeFromCustomerToAssetGroupScope)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible errors returned from
/// the AudienceInsightsService.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudienceInsightsErrorEnum {}
/// Nested message and enum types in `AudienceInsightsErrorEnum`.
pub mod audience_insights_error_enum {
    /// Enum describing possible errors from AudienceInsightsService.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AudienceInsightsError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The dimensions cannot be used with topic audience combinations.
        DimensionIncompatibleWithTopicAudienceCombinations = 2,
    }
    impl AudienceInsightsError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DimensionIncompatibleWithTopicAudienceCombinations => {
                    "DIMENSION_INCOMPATIBLE_WITH_TOPIC_AUDIENCE_COMBINATIONS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DIMENSION_INCOMPATIBLE_WITH_TOPIC_AUDIENCE_COMBINATIONS" => {
                    Some(Self::DimensionIncompatibleWithTopicAudienceCombinations)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible authentication errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AuthenticationErrorEnum {}
/// Nested message and enum types in `AuthenticationErrorEnum`.
pub mod authentication_error_enum {
    /// Enum describing possible authentication errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AuthenticationError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Authentication of the request failed.
        AuthenticationError = 2,
        /// Client customer ID is not a number.
        ClientCustomerIdInvalid = 5,
        /// No customer found for the provided customer ID.
        CustomerNotFound = 8,
        /// Client's Google account is deleted.
        GoogleAccountDeleted = 9,
        /// Google account login token in the cookie is invalid.
        GoogleAccountCookieInvalid = 10,
        /// A problem occurred during Google account authentication.
        GoogleAccountAuthenticationFailed = 25,
        /// The user in the Google account login token does not match the user ID in
        /// the cookie.
        GoogleAccountUserAndAdsUserMismatch = 12,
        /// Login cookie is required for authentication.
        LoginCookieRequired = 13,
        /// The Google account that generated the OAuth access
        /// token is not associated with a Google Ads account. Create a new
        /// account, or add the Google account to an existing Google Ads account.
        NotAdsUser = 14,
        /// OAuth token in the header is not valid.
        OauthTokenInvalid = 15,
        /// OAuth token in the header has expired.
        OauthTokenExpired = 16,
        /// OAuth token in the header has been disabled.
        OauthTokenDisabled = 17,
        /// OAuth token in the header has been revoked.
        OauthTokenRevoked = 18,
        /// OAuth token HTTP header is malformed.
        OauthTokenHeaderInvalid = 19,
        /// Login cookie is not valid.
        LoginCookieInvalid = 20,
        /// User ID in the header is not a valid ID.
        UserIdInvalid = 22,
        /// An account administrator changed this account's authentication settings.
        /// To access this Google Ads account, enable 2-Step Verification in your
        /// Google account at <https://www.google.com/landing/2step.>
        TwoStepVerificationNotEnrolled = 23,
        /// An account administrator changed this account's authentication settings.
        /// To access this Google Ads account, enable Advanced Protection in your
        /// Google account at <https://landing.google.com/advancedprotection.>
        AdvancedProtectionNotEnrolled = 24,
        /// The Cloud organization associated with the project is not recognized.
        OrganizationNotRecognized = 26,
        /// The Cloud organization associated with the project is not approved for
        /// prod access.
        OrganizationNotApproved = 27,
        /// The Cloud organization associated with the project is not associated with
        /// the developer token.
        OrganizationNotAssociatedWithDeveloperToken = 28,
    }
    impl AuthenticationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AuthenticationError => "AUTHENTICATION_ERROR",
                Self::ClientCustomerIdInvalid => "CLIENT_CUSTOMER_ID_INVALID",
                Self::CustomerNotFound => "CUSTOMER_NOT_FOUND",
                Self::GoogleAccountDeleted => "GOOGLE_ACCOUNT_DELETED",
                Self::GoogleAccountCookieInvalid => "GOOGLE_ACCOUNT_COOKIE_INVALID",
                Self::GoogleAccountAuthenticationFailed => {
                    "GOOGLE_ACCOUNT_AUTHENTICATION_FAILED"
                }
                Self::GoogleAccountUserAndAdsUserMismatch => {
                    "GOOGLE_ACCOUNT_USER_AND_ADS_USER_MISMATCH"
                }
                Self::LoginCookieRequired => "LOGIN_COOKIE_REQUIRED",
                Self::NotAdsUser => "NOT_ADS_USER",
                Self::OauthTokenInvalid => "OAUTH_TOKEN_INVALID",
                Self::OauthTokenExpired => "OAUTH_TOKEN_EXPIRED",
                Self::OauthTokenDisabled => "OAUTH_TOKEN_DISABLED",
                Self::OauthTokenRevoked => "OAUTH_TOKEN_REVOKED",
                Self::OauthTokenHeaderInvalid => "OAUTH_TOKEN_HEADER_INVALID",
                Self::LoginCookieInvalid => "LOGIN_COOKIE_INVALID",
                Self::UserIdInvalid => "USER_ID_INVALID",
                Self::TwoStepVerificationNotEnrolled => {
                    "TWO_STEP_VERIFICATION_NOT_ENROLLED"
                }
                Self::AdvancedProtectionNotEnrolled => "ADVANCED_PROTECTION_NOT_ENROLLED",
                Self::OrganizationNotRecognized => "ORGANIZATION_NOT_RECOGNIZED",
                Self::OrganizationNotApproved => "ORGANIZATION_NOT_APPROVED",
                Self::OrganizationNotAssociatedWithDeveloperToken => {
                    "ORGANIZATION_NOT_ASSOCIATED_WITH_DEVELOPER_TOKEN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AUTHENTICATION_ERROR" => Some(Self::AuthenticationError),
                "CLIENT_CUSTOMER_ID_INVALID" => Some(Self::ClientCustomerIdInvalid),
                "CUSTOMER_NOT_FOUND" => Some(Self::CustomerNotFound),
                "GOOGLE_ACCOUNT_DELETED" => Some(Self::GoogleAccountDeleted),
                "GOOGLE_ACCOUNT_COOKIE_INVALID" => Some(Self::GoogleAccountCookieInvalid),
                "GOOGLE_ACCOUNT_AUTHENTICATION_FAILED" => {
                    Some(Self::GoogleAccountAuthenticationFailed)
                }
                "GOOGLE_ACCOUNT_USER_AND_ADS_USER_MISMATCH" => {
                    Some(Self::GoogleAccountUserAndAdsUserMismatch)
                }
                "LOGIN_COOKIE_REQUIRED" => Some(Self::LoginCookieRequired),
                "NOT_ADS_USER" => Some(Self::NotAdsUser),
                "OAUTH_TOKEN_INVALID" => Some(Self::OauthTokenInvalid),
                "OAUTH_TOKEN_EXPIRED" => Some(Self::OauthTokenExpired),
                "OAUTH_TOKEN_DISABLED" => Some(Self::OauthTokenDisabled),
                "OAUTH_TOKEN_REVOKED" => Some(Self::OauthTokenRevoked),
                "OAUTH_TOKEN_HEADER_INVALID" => Some(Self::OauthTokenHeaderInvalid),
                "LOGIN_COOKIE_INVALID" => Some(Self::LoginCookieInvalid),
                "USER_ID_INVALID" => Some(Self::UserIdInvalid),
                "TWO_STEP_VERIFICATION_NOT_ENROLLED" => {
                    Some(Self::TwoStepVerificationNotEnrolled)
                }
                "ADVANCED_PROTECTION_NOT_ENROLLED" => {
                    Some(Self::AdvancedProtectionNotEnrolled)
                }
                "ORGANIZATION_NOT_RECOGNIZED" => Some(Self::OrganizationNotRecognized),
                "ORGANIZATION_NOT_APPROVED" => Some(Self::OrganizationNotApproved),
                "ORGANIZATION_NOT_ASSOCIATED_WITH_DEVELOPER_TOKEN" => {
                    Some(Self::OrganizationNotAssociatedWithDeveloperToken)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible authorization errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AuthorizationErrorEnum {}
/// Nested message and enum types in `AuthorizationErrorEnum`.
pub mod authorization_error_enum {
    /// Enum describing possible authorization errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AuthorizationError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// User doesn't have permission to access customer. Note: If you're
        /// accessing a client customer, the manager's customer ID must be set in the
        /// `login-customer-id` header. Learn more at
        /// <https://developers.google.com/google-ads/api/docs/concepts/call-structure#cid>
        UserPermissionDenied = 2,
        /// The developer token is not on the allow-list.
        DeveloperTokenNotOnAllowlist = 13,
        /// The developer token is not allowed with the project sent in the request.
        DeveloperTokenProhibited = 4,
        /// The Google Cloud project sent in the request does not have permission to
        /// access the api.
        ProjectDisabled = 5,
        /// Authorization of the client failed.
        AuthorizationError = 6,
        /// The user does not have permission to perform this action
        /// (for example, ADD, UPDATE, REMOVE) on the resource or call a method.
        ActionNotPermitted = 7,
        /// Signup not complete.
        IncompleteSignup = 8,
        /// The customer account can't be accessed because it is not yet enabled or
        /// has been deactivated.
        CustomerNotEnabled = 24,
        /// The developer must sign the terms of service. They can be found here:
        /// ads.google.com/aw/apicenter
        MissingTos = 9,
        /// The developer token is only approved for use with test accounts. To
        /// access non-test accounts, apply for Basic or Standard access.
        DeveloperTokenNotApproved = 10,
        /// The login customer specified does not have access to the account
        /// specified, so the request is invalid.
        InvalidLoginCustomerIdServingCustomerIdCombination = 11,
        /// The developer specified does not have access to the service.
        ServiceAccessDenied = 12,
        /// The customer (or login customer) isn't in Google Ads. It belongs to
        /// another ads system.
        AccessDeniedForAccountType = 25,
        /// The developer does not have access to the metrics queried.
        MetricAccessDenied = 26,
        /// The Google Cloud project is not under the required organization.
        CloudProjectNotUnderOrganization = 27,
        /// The user does not have permission to perform this action on the resource
        /// or method because the Google Ads account is suspended.
        ActionNotPermittedForSuspendedAccount = 28,
    }
    impl AuthorizationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::UserPermissionDenied => "USER_PERMISSION_DENIED",
                Self::DeveloperTokenNotOnAllowlist => "DEVELOPER_TOKEN_NOT_ON_ALLOWLIST",
                Self::DeveloperTokenProhibited => "DEVELOPER_TOKEN_PROHIBITED",
                Self::ProjectDisabled => "PROJECT_DISABLED",
                Self::AuthorizationError => "AUTHORIZATION_ERROR",
                Self::ActionNotPermitted => "ACTION_NOT_PERMITTED",
                Self::IncompleteSignup => "INCOMPLETE_SIGNUP",
                Self::CustomerNotEnabled => "CUSTOMER_NOT_ENABLED",
                Self::MissingTos => "MISSING_TOS",
                Self::DeveloperTokenNotApproved => "DEVELOPER_TOKEN_NOT_APPROVED",
                Self::InvalidLoginCustomerIdServingCustomerIdCombination => {
                    "INVALID_LOGIN_CUSTOMER_ID_SERVING_CUSTOMER_ID_COMBINATION"
                }
                Self::ServiceAccessDenied => "SERVICE_ACCESS_DENIED",
                Self::AccessDeniedForAccountType => "ACCESS_DENIED_FOR_ACCOUNT_TYPE",
                Self::MetricAccessDenied => "METRIC_ACCESS_DENIED",
                Self::CloudProjectNotUnderOrganization => {
                    "CLOUD_PROJECT_NOT_UNDER_ORGANIZATION"
                }
                Self::ActionNotPermittedForSuspendedAccount => {
                    "ACTION_NOT_PERMITTED_FOR_SUSPENDED_ACCOUNT"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "USER_PERMISSION_DENIED" => Some(Self::UserPermissionDenied),
                "DEVELOPER_TOKEN_NOT_ON_ALLOWLIST" => {
                    Some(Self::DeveloperTokenNotOnAllowlist)
                }
                "DEVELOPER_TOKEN_PROHIBITED" => Some(Self::DeveloperTokenProhibited),
                "PROJECT_DISABLED" => Some(Self::ProjectDisabled),
                "AUTHORIZATION_ERROR" => Some(Self::AuthorizationError),
                "ACTION_NOT_PERMITTED" => Some(Self::ActionNotPermitted),
                "INCOMPLETE_SIGNUP" => Some(Self::IncompleteSignup),
                "CUSTOMER_NOT_ENABLED" => Some(Self::CustomerNotEnabled),
                "MISSING_TOS" => Some(Self::MissingTos),
                "DEVELOPER_TOKEN_NOT_APPROVED" => Some(Self::DeveloperTokenNotApproved),
                "INVALID_LOGIN_CUSTOMER_ID_SERVING_CUSTOMER_ID_COMBINATION" => {
                    Some(Self::InvalidLoginCustomerIdServingCustomerIdCombination)
                }
                "SERVICE_ACCESS_DENIED" => Some(Self::ServiceAccessDenied),
                "ACCESS_DENIED_FOR_ACCOUNT_TYPE" => {
                    Some(Self::AccessDeniedForAccountType)
                }
                "METRIC_ACCESS_DENIED" => Some(Self::MetricAccessDenied),
                "CLOUD_PROJECT_NOT_UNDER_ORGANIZATION" => {
                    Some(Self::CloudProjectNotUnderOrganization)
                }
                "ACTION_NOT_PERMITTED_FOR_SUSPENDED_ACCOUNT" => {
                    Some(Self::ActionNotPermittedForSuspendedAccount)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible batch job errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchJobErrorEnum {}
/// Nested message and enum types in `BatchJobErrorEnum`.
pub mod batch_job_error_enum {
    /// Enum describing possible request errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BatchJobError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The batch job cannot add more operations or run after it has started
        /// running.
        CannotModifyJobAfterJobStartsRunning = 2,
        /// The operations for an AddBatchJobOperations request were empty.
        EmptyOperations = 3,
        /// The sequence token for an AddBatchJobOperations request was invalid.
        InvalidSequenceToken = 4,
        /// Batch job results can only be retrieved once the job is finished.
        ResultsNotReady = 5,
        /// The page size for ListBatchJobResults was invalid.
        InvalidPageSize = 6,
        /// The batch job cannot be removed because it has started running.
        CanOnlyRemovePendingJob = 7,
        /// The batch job cannot be listed due to unexpected errors such as duplicate
        /// checkpoints.
        CannotListResults = 8,
    }
    impl BatchJobError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CannotModifyJobAfterJobStartsRunning => {
                    "CANNOT_MODIFY_JOB_AFTER_JOB_STARTS_RUNNING"
                }
                Self::EmptyOperations => "EMPTY_OPERATIONS",
                Self::InvalidSequenceToken => "INVALID_SEQUENCE_TOKEN",
                Self::ResultsNotReady => "RESULTS_NOT_READY",
                Self::InvalidPageSize => "INVALID_PAGE_SIZE",
                Self::CanOnlyRemovePendingJob => "CAN_ONLY_REMOVE_PENDING_JOB",
                Self::CannotListResults => "CANNOT_LIST_RESULTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_MODIFY_JOB_AFTER_JOB_STARTS_RUNNING" => {
                    Some(Self::CannotModifyJobAfterJobStartsRunning)
                }
                "EMPTY_OPERATIONS" => Some(Self::EmptyOperations),
                "INVALID_SEQUENCE_TOKEN" => Some(Self::InvalidSequenceToken),
                "RESULTS_NOT_READY" => Some(Self::ResultsNotReady),
                "INVALID_PAGE_SIZE" => Some(Self::InvalidPageSize),
                "CAN_ONLY_REMOVE_PENDING_JOB" => Some(Self::CanOnlyRemovePendingJob),
                "CANNOT_LIST_RESULTS" => Some(Self::CannotListResults),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible bidding errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BiddingErrorEnum {}
/// Nested message and enum types in `BiddingErrorEnum`.
pub mod bidding_error_enum {
    /// Enum describing possible bidding errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BiddingError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Cannot transition to new bidding strategy.
        BiddingStrategyTransitionNotAllowed = 2,
        /// Cannot attach bidding strategy to campaign.
        CannotAttachBiddingStrategyToCampaign = 7,
        /// Bidding strategy is not supported or cannot be used as anonymous.
        InvalidAnonymousBiddingStrategyType = 10,
        /// The type does not match the named strategy's type.
        InvalidBiddingStrategyType = 14,
        /// The bid is invalid.
        InvalidBid = 17,
        /// Bidding strategy is not available for the account type.
        BiddingStrategyNotAvailableForAccountType = 18,
        /// Campaign can not be created with given bidding strategy. It can be
        /// transitioned to the strategy, once eligible.
        CannotCreateCampaignWithBiddingStrategy = 21,
        /// Cannot target content network only as campaign uses Page One Promoted
        /// bidding strategy.
        CannotTargetContentNetworkOnlyWithCampaignLevelPopBiddingStrategy = 23,
        /// Budget Optimizer and Target Spend bidding strategies are not supported
        /// for campaigns with AdSchedule targeting.
        BiddingStrategyNotSupportedWithAdSchedule = 24,
        /// Pay per conversion is not available to all the customer, only few
        /// customers on the allow-list can use this.
        PayPerConversionNotAvailableForCustomer = 25,
        /// Pay per conversion is not allowed with Target CPA.
        PayPerConversionNotAllowedWithTargetCpa = 26,
        /// Cannot set bidding strategy to Manual CPM for search network only
        /// campaigns.
        BiddingStrategyNotAllowedForSearchOnlyCampaigns = 27,
        /// The bidding strategy is not supported for use in drafts or experiments.
        BiddingStrategyNotSupportedInDraftsOrExperiments = 28,
        /// Bidding strategy type does not support product type ad group criterion.
        BiddingStrategyTypeDoesNotSupportProductTypeAdgroupCriterion = 29,
        /// Bid amount is too small.
        BidTooSmall = 30,
        /// Bid amount is too big.
        BidTooBig = 31,
        /// Bid has too many fractional digit precision.
        BidTooManyFractionalDigits = 32,
        /// Invalid domain name specified.
        InvalidDomainName = 33,
        /// The field is not compatible with the payment mode.
        NotCompatibleWithPaymentMode = 34,
        /// Bidding strategy type is incompatible with shared budget.
        BiddingStrategyTypeIncompatibleWithSharedBudget = 37,
        /// The attached bidding strategy and budget must be aligned with each other
        /// if alignment is specified on either entity.
        BiddingStrategyAndBudgetMustBeAligned = 38,
        /// The attached bidding strategy and budget must be attached to the same
        /// campaigns to become aligned.
        BiddingStrategyAndBudgetMustBeAttachedToTheSameCampaignsToAlign = 39,
        /// The aligned bidding strategy and budget must be removed at the same time.
        BiddingStrategyAndBudgetMustBeRemovedTogether = 40,
        /// cpc_bid_floor_micros is greater than cpc_bid_ceiling_micros.
        CpcBidFloorMicrosGreaterThanCpcBidCeilingMicros = 41,
    }
    impl BiddingError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::BiddingStrategyTransitionNotAllowed => {
                    "BIDDING_STRATEGY_TRANSITION_NOT_ALLOWED"
                }
                Self::CannotAttachBiddingStrategyToCampaign => {
                    "CANNOT_ATTACH_BIDDING_STRATEGY_TO_CAMPAIGN"
                }
                Self::InvalidAnonymousBiddingStrategyType => {
                    "INVALID_ANONYMOUS_BIDDING_STRATEGY_TYPE"
                }
                Self::InvalidBiddingStrategyType => "INVALID_BIDDING_STRATEGY_TYPE",
                Self::InvalidBid => "INVALID_BID",
                Self::BiddingStrategyNotAvailableForAccountType => {
                    "BIDDING_STRATEGY_NOT_AVAILABLE_FOR_ACCOUNT_TYPE"
                }
                Self::CannotCreateCampaignWithBiddingStrategy => {
                    "CANNOT_CREATE_CAMPAIGN_WITH_BIDDING_STRATEGY"
                }
                Self::CannotTargetContentNetworkOnlyWithCampaignLevelPopBiddingStrategy => {
                    "CANNOT_TARGET_CONTENT_NETWORK_ONLY_WITH_CAMPAIGN_LEVEL_POP_BIDDING_STRATEGY"
                }
                Self::BiddingStrategyNotSupportedWithAdSchedule => {
                    "BIDDING_STRATEGY_NOT_SUPPORTED_WITH_AD_SCHEDULE"
                }
                Self::PayPerConversionNotAvailableForCustomer => {
                    "PAY_PER_CONVERSION_NOT_AVAILABLE_FOR_CUSTOMER"
                }
                Self::PayPerConversionNotAllowedWithTargetCpa => {
                    "PAY_PER_CONVERSION_NOT_ALLOWED_WITH_TARGET_CPA"
                }
                Self::BiddingStrategyNotAllowedForSearchOnlyCampaigns => {
                    "BIDDING_STRATEGY_NOT_ALLOWED_FOR_SEARCH_ONLY_CAMPAIGNS"
                }
                Self::BiddingStrategyNotSupportedInDraftsOrExperiments => {
                    "BIDDING_STRATEGY_NOT_SUPPORTED_IN_DRAFTS_OR_EXPERIMENTS"
                }
                Self::BiddingStrategyTypeDoesNotSupportProductTypeAdgroupCriterion => {
                    "BIDDING_STRATEGY_TYPE_DOES_NOT_SUPPORT_PRODUCT_TYPE_ADGROUP_CRITERION"
                }
                Self::BidTooSmall => "BID_TOO_SMALL",
                Self::BidTooBig => "BID_TOO_BIG",
                Self::BidTooManyFractionalDigits => "BID_TOO_MANY_FRACTIONAL_DIGITS",
                Self::InvalidDomainName => "INVALID_DOMAIN_NAME",
                Self::NotCompatibleWithPaymentMode => "NOT_COMPATIBLE_WITH_PAYMENT_MODE",
                Self::BiddingStrategyTypeIncompatibleWithSharedBudget => {
                    "BIDDING_STRATEGY_TYPE_INCOMPATIBLE_WITH_SHARED_BUDGET"
                }
                Self::BiddingStrategyAndBudgetMustBeAligned => {
                    "BIDDING_STRATEGY_AND_BUDGET_MUST_BE_ALIGNED"
                }
                Self::BiddingStrategyAndBudgetMustBeAttachedToTheSameCampaignsToAlign => {
                    "BIDDING_STRATEGY_AND_BUDGET_MUST_BE_ATTACHED_TO_THE_SAME_CAMPAIGNS_TO_ALIGN"
                }
                Self::BiddingStrategyAndBudgetMustBeRemovedTogether => {
                    "BIDDING_STRATEGY_AND_BUDGET_MUST_BE_REMOVED_TOGETHER"
                }
                Self::CpcBidFloorMicrosGreaterThanCpcBidCeilingMicros => {
                    "CPC_BID_FLOOR_MICROS_GREATER_THAN_CPC_BID_CEILING_MICROS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BIDDING_STRATEGY_TRANSITION_NOT_ALLOWED" => {
                    Some(Self::BiddingStrategyTransitionNotAllowed)
                }
                "CANNOT_ATTACH_BIDDING_STRATEGY_TO_CAMPAIGN" => {
                    Some(Self::CannotAttachBiddingStrategyToCampaign)
                }
                "INVALID_ANONYMOUS_BIDDING_STRATEGY_TYPE" => {
                    Some(Self::InvalidAnonymousBiddingStrategyType)
                }
                "INVALID_BIDDING_STRATEGY_TYPE" => Some(Self::InvalidBiddingStrategyType),
                "INVALID_BID" => Some(Self::InvalidBid),
                "BIDDING_STRATEGY_NOT_AVAILABLE_FOR_ACCOUNT_TYPE" => {
                    Some(Self::BiddingStrategyNotAvailableForAccountType)
                }
                "CANNOT_CREATE_CAMPAIGN_WITH_BIDDING_STRATEGY" => {
                    Some(Self::CannotCreateCampaignWithBiddingStrategy)
                }
                "CANNOT_TARGET_CONTENT_NETWORK_ONLY_WITH_CAMPAIGN_LEVEL_POP_BIDDING_STRATEGY" => {
                    Some(
                        Self::CannotTargetContentNetworkOnlyWithCampaignLevelPopBiddingStrategy,
                    )
                }
                "BIDDING_STRATEGY_NOT_SUPPORTED_WITH_AD_SCHEDULE" => {
                    Some(Self::BiddingStrategyNotSupportedWithAdSchedule)
                }
                "PAY_PER_CONVERSION_NOT_AVAILABLE_FOR_CUSTOMER" => {
                    Some(Self::PayPerConversionNotAvailableForCustomer)
                }
                "PAY_PER_CONVERSION_NOT_ALLOWED_WITH_TARGET_CPA" => {
                    Some(Self::PayPerConversionNotAllowedWithTargetCpa)
                }
                "BIDDING_STRATEGY_NOT_ALLOWED_FOR_SEARCH_ONLY_CAMPAIGNS" => {
                    Some(Self::BiddingStrategyNotAllowedForSearchOnlyCampaigns)
                }
                "BIDDING_STRATEGY_NOT_SUPPORTED_IN_DRAFTS_OR_EXPERIMENTS" => {
                    Some(Self::BiddingStrategyNotSupportedInDraftsOrExperiments)
                }
                "BIDDING_STRATEGY_TYPE_DOES_NOT_SUPPORT_PRODUCT_TYPE_ADGROUP_CRITERION" => {
                    Some(
                        Self::BiddingStrategyTypeDoesNotSupportProductTypeAdgroupCriterion,
                    )
                }
                "BID_TOO_SMALL" => Some(Self::BidTooSmall),
                "BID_TOO_BIG" => Some(Self::BidTooBig),
                "BID_TOO_MANY_FRACTIONAL_DIGITS" => {
                    Some(Self::BidTooManyFractionalDigits)
                }
                "INVALID_DOMAIN_NAME" => Some(Self::InvalidDomainName),
                "NOT_COMPATIBLE_WITH_PAYMENT_MODE" => {
                    Some(Self::NotCompatibleWithPaymentMode)
                }
                "BIDDING_STRATEGY_TYPE_INCOMPATIBLE_WITH_SHARED_BUDGET" => {
                    Some(Self::BiddingStrategyTypeIncompatibleWithSharedBudget)
                }
                "BIDDING_STRATEGY_AND_BUDGET_MUST_BE_ALIGNED" => {
                    Some(Self::BiddingStrategyAndBudgetMustBeAligned)
                }
                "BIDDING_STRATEGY_AND_BUDGET_MUST_BE_ATTACHED_TO_THE_SAME_CAMPAIGNS_TO_ALIGN" => {
                    Some(
                        Self::BiddingStrategyAndBudgetMustBeAttachedToTheSameCampaignsToAlign,
                    )
                }
                "BIDDING_STRATEGY_AND_BUDGET_MUST_BE_REMOVED_TOGETHER" => {
                    Some(Self::BiddingStrategyAndBudgetMustBeRemovedTogether)
                }
                "CPC_BID_FLOOR_MICROS_GREATER_THAN_CPC_BID_CEILING_MICROS" => {
                    Some(Self::CpcBidFloorMicrosGreaterThanCpcBidCeilingMicros)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible bidding strategy errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BiddingStrategyErrorEnum {}
/// Nested message and enum types in `BiddingStrategyErrorEnum`.
pub mod bidding_strategy_error_enum {
    /// Enum describing possible bidding strategy errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BiddingStrategyError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Each bidding strategy must have a unique name.
        DuplicateName = 2,
        /// Bidding strategy type is immutable.
        CannotChangeBiddingStrategyType = 3,
        /// Only bidding strategies not linked to campaigns, adgroups or adgroup
        /// criteria can be removed.
        CannotRemoveAssociatedStrategy = 4,
        /// The specified bidding strategy is not supported.
        BiddingStrategyNotSupported = 5,
        /// The bidding strategy is incompatible with the campaign's bidding
        /// strategy goal type.
        IncompatibleBiddingStrategyAndBiddingStrategyGoalType = 6,
    }
    impl BiddingStrategyError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DuplicateName => "DUPLICATE_NAME",
                Self::CannotChangeBiddingStrategyType => {
                    "CANNOT_CHANGE_BIDDING_STRATEGY_TYPE"
                }
                Self::CannotRemoveAssociatedStrategy => {
                    "CANNOT_REMOVE_ASSOCIATED_STRATEGY"
                }
                Self::BiddingStrategyNotSupported => "BIDDING_STRATEGY_NOT_SUPPORTED",
                Self::IncompatibleBiddingStrategyAndBiddingStrategyGoalType => {
                    "INCOMPATIBLE_BIDDING_STRATEGY_AND_BIDDING_STRATEGY_GOAL_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "CANNOT_CHANGE_BIDDING_STRATEGY_TYPE" => {
                    Some(Self::CannotChangeBiddingStrategyType)
                }
                "CANNOT_REMOVE_ASSOCIATED_STRATEGY" => {
                    Some(Self::CannotRemoveAssociatedStrategy)
                }
                "BIDDING_STRATEGY_NOT_SUPPORTED" => {
                    Some(Self::BiddingStrategyNotSupported)
                }
                "INCOMPATIBLE_BIDDING_STRATEGY_AND_BIDDING_STRATEGY_GOAL_TYPE" => {
                    Some(Self::IncompatibleBiddingStrategyAndBiddingStrategyGoalType)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible billing setup errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BillingSetupErrorEnum {}
/// Nested message and enum types in `BillingSetupErrorEnum`.
pub mod billing_setup_error_enum {
    /// Enum describing possible billing setup errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BillingSetupError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Cannot specify both an existing payments account and a new payments
        /// account when setting up billing.
        CannotUseExistingAndNewAccount = 2,
        /// Cannot cancel an approved billing setup whose start time has passed.
        CannotRemoveStartedBillingSetup = 3,
        /// Cannot perform a Change of Bill-To (CBT) to the same payments account.
        CannotChangeBillingToSamePaymentsAccount = 4,
        /// Billing setups can only be used by customers with ENABLED or DRAFT
        /// status.
        BillingSetupNotPermittedForCustomerStatus = 5,
        /// Billing setups must either include a correctly formatted existing
        /// payments account id, or a non-empty new payments account name.
        InvalidPaymentsAccount = 6,
        /// Only billable and third-party customers can create billing setups.
        BillingSetupNotPermittedForCustomerCategory = 7,
        /// Billing setup creations can only use NOW for start time type.
        InvalidStartTimeType = 8,
        /// Billing setups can only be created for a third-party customer if they do
        /// not already have a setup.
        ThirdPartyAlreadyHasBilling = 9,
        /// Billing setups cannot be created if there is already a pending billing in
        /// progress.
        BillingSetupInProgress = 10,
        /// Billing setups can only be created by customers who have permission to
        /// setup billings. Users can contact a representative for help setting up
        /// permissions.
        NoSignupPermission = 11,
        /// Billing setups cannot be created if there is already a future-approved
        /// billing.
        ChangeOfBillToInProgress = 12,
        /// Requested payments profile not found.
        PaymentsProfileNotFound = 13,
        /// Requested payments account not found.
        PaymentsAccountNotFound = 14,
        /// Billing setup creation failed because the payments profile is ineligible.
        PaymentsProfileIneligible = 15,
        /// Billing setup creation failed because the payments account is ineligible.
        PaymentsAccountIneligible = 16,
        /// Billing setup creation failed because the payments profile needs internal
        /// approval.
        CustomerNeedsInternalApproval = 17,
        /// Billing setup creation failed because the user needs to accept master
        /// service agreement on the payments profile.
        PaymentsProfileNeedsServiceAgreementAcceptance = 18,
        /// Payments account has different currency code than the current customer
        /// and hence cannot be used to setup billing.
        PaymentsAccountIneligibleCurrencyCodeMismatch = 19,
        /// A start time in the future cannot be used because there is currently no
        /// active billing setup for this customer.
        FutureStartTimeProhibited = 20,
        /// The payments account has maximum number of billing setups.
        TooManyBillingSetupsForPaymentsAccount = 21,
    }
    impl BillingSetupError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CannotUseExistingAndNewAccount => {
                    "CANNOT_USE_EXISTING_AND_NEW_ACCOUNT"
                }
                Self::CannotRemoveStartedBillingSetup => {
                    "CANNOT_REMOVE_STARTED_BILLING_SETUP"
                }
                Self::CannotChangeBillingToSamePaymentsAccount => {
                    "CANNOT_CHANGE_BILLING_TO_SAME_PAYMENTS_ACCOUNT"
                }
                Self::BillingSetupNotPermittedForCustomerStatus => {
                    "BILLING_SETUP_NOT_PERMITTED_FOR_CUSTOMER_STATUS"
                }
                Self::InvalidPaymentsAccount => "INVALID_PAYMENTS_ACCOUNT",
                Self::BillingSetupNotPermittedForCustomerCategory => {
                    "BILLING_SETUP_NOT_PERMITTED_FOR_CUSTOMER_CATEGORY"
                }
                Self::InvalidStartTimeType => "INVALID_START_TIME_TYPE",
                Self::ThirdPartyAlreadyHasBilling => "THIRD_PARTY_ALREADY_HAS_BILLING",
                Self::BillingSetupInProgress => "BILLING_SETUP_IN_PROGRESS",
                Self::NoSignupPermission => "NO_SIGNUP_PERMISSION",
                Self::ChangeOfBillToInProgress => "CHANGE_OF_BILL_TO_IN_PROGRESS",
                Self::PaymentsProfileNotFound => "PAYMENTS_PROFILE_NOT_FOUND",
                Self::PaymentsAccountNotFound => "PAYMENTS_ACCOUNT_NOT_FOUND",
                Self::PaymentsProfileIneligible => "PAYMENTS_PROFILE_INELIGIBLE",
                Self::PaymentsAccountIneligible => "PAYMENTS_ACCOUNT_INELIGIBLE",
                Self::CustomerNeedsInternalApproval => "CUSTOMER_NEEDS_INTERNAL_APPROVAL",
                Self::PaymentsProfileNeedsServiceAgreementAcceptance => {
                    "PAYMENTS_PROFILE_NEEDS_SERVICE_AGREEMENT_ACCEPTANCE"
                }
                Self::PaymentsAccountIneligibleCurrencyCodeMismatch => {
                    "PAYMENTS_ACCOUNT_INELIGIBLE_CURRENCY_CODE_MISMATCH"
                }
                Self::FutureStartTimeProhibited => "FUTURE_START_TIME_PROHIBITED",
                Self::TooManyBillingSetupsForPaymentsAccount => {
                    "TOO_MANY_BILLING_SETUPS_FOR_PAYMENTS_ACCOUNT"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_USE_EXISTING_AND_NEW_ACCOUNT" => {
                    Some(Self::CannotUseExistingAndNewAccount)
                }
                "CANNOT_REMOVE_STARTED_BILLING_SETUP" => {
                    Some(Self::CannotRemoveStartedBillingSetup)
                }
                "CANNOT_CHANGE_BILLING_TO_SAME_PAYMENTS_ACCOUNT" => {
                    Some(Self::CannotChangeBillingToSamePaymentsAccount)
                }
                "BILLING_SETUP_NOT_PERMITTED_FOR_CUSTOMER_STATUS" => {
                    Some(Self::BillingSetupNotPermittedForCustomerStatus)
                }
                "INVALID_PAYMENTS_ACCOUNT" => Some(Self::InvalidPaymentsAccount),
                "BILLING_SETUP_NOT_PERMITTED_FOR_CUSTOMER_CATEGORY" => {
                    Some(Self::BillingSetupNotPermittedForCustomerCategory)
                }
                "INVALID_START_TIME_TYPE" => Some(Self::InvalidStartTimeType),
                "THIRD_PARTY_ALREADY_HAS_BILLING" => {
                    Some(Self::ThirdPartyAlreadyHasBilling)
                }
                "BILLING_SETUP_IN_PROGRESS" => Some(Self::BillingSetupInProgress),
                "NO_SIGNUP_PERMISSION" => Some(Self::NoSignupPermission),
                "CHANGE_OF_BILL_TO_IN_PROGRESS" => Some(Self::ChangeOfBillToInProgress),
                "PAYMENTS_PROFILE_NOT_FOUND" => Some(Self::PaymentsProfileNotFound),
                "PAYMENTS_ACCOUNT_NOT_FOUND" => Some(Self::PaymentsAccountNotFound),
                "PAYMENTS_PROFILE_INELIGIBLE" => Some(Self::PaymentsProfileIneligible),
                "PAYMENTS_ACCOUNT_INELIGIBLE" => Some(Self::PaymentsAccountIneligible),
                "CUSTOMER_NEEDS_INTERNAL_APPROVAL" => {
                    Some(Self::CustomerNeedsInternalApproval)
                }
                "PAYMENTS_PROFILE_NEEDS_SERVICE_AGREEMENT_ACCEPTANCE" => {
                    Some(Self::PaymentsProfileNeedsServiceAgreementAcceptance)
                }
                "PAYMENTS_ACCOUNT_INELIGIBLE_CURRENCY_CODE_MISMATCH" => {
                    Some(Self::PaymentsAccountIneligibleCurrencyCodeMismatch)
                }
                "FUTURE_START_TIME_PROHIBITED" => Some(Self::FutureStartTimeProhibited),
                "TOO_MANY_BILLING_SETUPS_FOR_PAYMENTS_ACCOUNT" => {
                    Some(Self::TooManyBillingSetupsForPaymentsAccount)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible campaign budget errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignBudgetErrorEnum {}
/// Nested message and enum types in `CampaignBudgetErrorEnum`.
pub mod campaign_budget_error_enum {
    /// Enum describing possible campaign budget errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignBudgetError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The campaign budget cannot be shared.
        CampaignBudgetCannotBeShared = 17,
        /// The requested campaign budget no longer exists.
        CampaignBudgetRemoved = 2,
        /// The campaign budget is associated with at least one campaign, and so the
        /// campaign budget cannot be removed.
        CampaignBudgetInUse = 3,
        /// Customer is not on the allow-list for this campaign budget period.
        CampaignBudgetPeriodNotAvailable = 4,
        /// This field is not mutable on implicitly shared campaign budgets
        CannotModifyFieldOfImplicitlySharedCampaignBudget = 6,
        /// Cannot change explicitly shared campaign budgets back to implicitly
        /// shared ones.
        CannotUpdateCampaignBudgetToImplicitlyShared = 7,
        /// An implicit campaign budget without a name cannot be changed to
        /// explicitly shared campaign budget.
        CannotUpdateCampaignBudgetToExplicitlySharedWithoutName = 8,
        /// Cannot change an implicitly shared campaign budget to an explicitly
        /// shared one.
        CannotUpdateCampaignBudgetToExplicitlyShared = 9,
        /// Only explicitly shared campaign budgets can be used with multiple
        /// campaigns.
        CannotUseImplicitlySharedCampaignBudgetWithMultipleCampaigns = 10,
        /// A campaign budget with this name already exists.
        DuplicateName = 11,
        /// A money amount was not in the expected currency.
        MoneyAmountInWrongCurrency = 12,
        /// A money amount was less than the minimum CPC for currency.
        MoneyAmountLessThanCurrencyMinimumCpc = 13,
        /// A money amount was greater than the maximum allowed.
        MoneyAmountTooLarge = 14,
        /// A money amount was negative.
        NegativeMoneyAmount = 15,
        /// A money amount was not a multiple of a minimum unit.
        NonMultipleOfMinimumCurrencyUnit = 16,
        /// Total budget amount must be unset when BudgetPeriod is DAILY.
        TotalBudgetAmountMustBeUnsetForBudgetPeriodDaily = 18,
        /// The period of the budget is not allowed.
        InvalidPeriod = 19,
        /// Cannot use accelerated delivery method on this budget.
        CannotUseAcceleratedDeliveryMode = 20,
        /// Budget amount must be unset when BudgetPeriod is CUSTOM.
        BudgetAmountMustBeUnsetForCustomBudgetPeriod = 21,
    }
    impl CampaignBudgetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CampaignBudgetCannotBeShared => "CAMPAIGN_BUDGET_CANNOT_BE_SHARED",
                Self::CampaignBudgetRemoved => "CAMPAIGN_BUDGET_REMOVED",
                Self::CampaignBudgetInUse => "CAMPAIGN_BUDGET_IN_USE",
                Self::CampaignBudgetPeriodNotAvailable => {
                    "CAMPAIGN_BUDGET_PERIOD_NOT_AVAILABLE"
                }
                Self::CannotModifyFieldOfImplicitlySharedCampaignBudget => {
                    "CANNOT_MODIFY_FIELD_OF_IMPLICITLY_SHARED_CAMPAIGN_BUDGET"
                }
                Self::CannotUpdateCampaignBudgetToImplicitlyShared => {
                    "CANNOT_UPDATE_CAMPAIGN_BUDGET_TO_IMPLICITLY_SHARED"
                }
                Self::CannotUpdateCampaignBudgetToExplicitlySharedWithoutName => {
                    "CANNOT_UPDATE_CAMPAIGN_BUDGET_TO_EXPLICITLY_SHARED_WITHOUT_NAME"
                }
                Self::CannotUpdateCampaignBudgetToExplicitlyShared => {
                    "CANNOT_UPDATE_CAMPAIGN_BUDGET_TO_EXPLICITLY_SHARED"
                }
                Self::CannotUseImplicitlySharedCampaignBudgetWithMultipleCampaigns => {
                    "CANNOT_USE_IMPLICITLY_SHARED_CAMPAIGN_BUDGET_WITH_MULTIPLE_CAMPAIGNS"
                }
                Self::DuplicateName => "DUPLICATE_NAME",
                Self::MoneyAmountInWrongCurrency => "MONEY_AMOUNT_IN_WRONG_CURRENCY",
                Self::MoneyAmountLessThanCurrencyMinimumCpc => {
                    "MONEY_AMOUNT_LESS_THAN_CURRENCY_MINIMUM_CPC"
                }
                Self::MoneyAmountTooLarge => "MONEY_AMOUNT_TOO_LARGE",
                Self::NegativeMoneyAmount => "NEGATIVE_MONEY_AMOUNT",
                Self::NonMultipleOfMinimumCurrencyUnit => {
                    "NON_MULTIPLE_OF_MINIMUM_CURRENCY_UNIT"
                }
                Self::TotalBudgetAmountMustBeUnsetForBudgetPeriodDaily => {
                    "TOTAL_BUDGET_AMOUNT_MUST_BE_UNSET_FOR_BUDGET_PERIOD_DAILY"
                }
                Self::InvalidPeriod => "INVALID_PERIOD",
                Self::CannotUseAcceleratedDeliveryMode => {
                    "CANNOT_USE_ACCELERATED_DELIVERY_MODE"
                }
                Self::BudgetAmountMustBeUnsetForCustomBudgetPeriod => {
                    "BUDGET_AMOUNT_MUST_BE_UNSET_FOR_CUSTOM_BUDGET_PERIOD"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_BUDGET_CANNOT_BE_SHARED" => {
                    Some(Self::CampaignBudgetCannotBeShared)
                }
                "CAMPAIGN_BUDGET_REMOVED" => Some(Self::CampaignBudgetRemoved),
                "CAMPAIGN_BUDGET_IN_USE" => Some(Self::CampaignBudgetInUse),
                "CAMPAIGN_BUDGET_PERIOD_NOT_AVAILABLE" => {
                    Some(Self::CampaignBudgetPeriodNotAvailable)
                }
                "CANNOT_MODIFY_FIELD_OF_IMPLICITLY_SHARED_CAMPAIGN_BUDGET" => {
                    Some(Self::CannotModifyFieldOfImplicitlySharedCampaignBudget)
                }
                "CANNOT_UPDATE_CAMPAIGN_BUDGET_TO_IMPLICITLY_SHARED" => {
                    Some(Self::CannotUpdateCampaignBudgetToImplicitlyShared)
                }
                "CANNOT_UPDATE_CAMPAIGN_BUDGET_TO_EXPLICITLY_SHARED_WITHOUT_NAME" => {
                    Some(Self::CannotUpdateCampaignBudgetToExplicitlySharedWithoutName)
                }
                "CANNOT_UPDATE_CAMPAIGN_BUDGET_TO_EXPLICITLY_SHARED" => {
                    Some(Self::CannotUpdateCampaignBudgetToExplicitlyShared)
                }
                "CANNOT_USE_IMPLICITLY_SHARED_CAMPAIGN_BUDGET_WITH_MULTIPLE_CAMPAIGNS" => {
                    Some(
                        Self::CannotUseImplicitlySharedCampaignBudgetWithMultipleCampaigns,
                    )
                }
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "MONEY_AMOUNT_IN_WRONG_CURRENCY" => {
                    Some(Self::MoneyAmountInWrongCurrency)
                }
                "MONEY_AMOUNT_LESS_THAN_CURRENCY_MINIMUM_CPC" => {
                    Some(Self::MoneyAmountLessThanCurrencyMinimumCpc)
                }
                "MONEY_AMOUNT_TOO_LARGE" => Some(Self::MoneyAmountTooLarge),
                "NEGATIVE_MONEY_AMOUNT" => Some(Self::NegativeMoneyAmount),
                "NON_MULTIPLE_OF_MINIMUM_CURRENCY_UNIT" => {
                    Some(Self::NonMultipleOfMinimumCurrencyUnit)
                }
                "TOTAL_BUDGET_AMOUNT_MUST_BE_UNSET_FOR_BUDGET_PERIOD_DAILY" => {
                    Some(Self::TotalBudgetAmountMustBeUnsetForBudgetPeriodDaily)
                }
                "INVALID_PERIOD" => Some(Self::InvalidPeriod),
                "CANNOT_USE_ACCELERATED_DELIVERY_MODE" => {
                    Some(Self::CannotUseAcceleratedDeliveryMode)
                }
                "BUDGET_AMOUNT_MUST_BE_UNSET_FOR_CUSTOM_BUDGET_PERIOD" => {
                    Some(Self::BudgetAmountMustBeUnsetForCustomBudgetPeriod)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible campaign conversion goal errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignConversionGoalErrorEnum {}
/// Nested message and enum types in `CampaignConversionGoalErrorEnum`.
pub mod campaign_conversion_goal_error_enum {
    /// Enum describing possible campaign conversion goal errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignConversionGoalError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Campaign is managed by Search Ads 360 but uses Unified Goal.
        CannotUseCampaignGoalForSearchAds360ManagedCampaign = 2,
        /// Performance Max campaign cannot use an included store sale campaign goal.
        CannotUseStoreSaleGoalForPerformanceMaxCampaign = 3,
    }
    impl CampaignConversionGoalError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CannotUseCampaignGoalForSearchAds360ManagedCampaign => {
                    "CANNOT_USE_CAMPAIGN_GOAL_FOR_SEARCH_ADS_360_MANAGED_CAMPAIGN"
                }
                Self::CannotUseStoreSaleGoalForPerformanceMaxCampaign => {
                    "CANNOT_USE_STORE_SALE_GOAL_FOR_PERFORMANCE_MAX_CAMPAIGN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_USE_CAMPAIGN_GOAL_FOR_SEARCH_ADS_360_MANAGED_CAMPAIGN" => {
                    Some(Self::CannotUseCampaignGoalForSearchAds360ManagedCampaign)
                }
                "CANNOT_USE_STORE_SALE_GOAL_FOR_PERFORMANCE_MAX_CAMPAIGN" => {
                    Some(Self::CannotUseStoreSaleGoalForPerformanceMaxCampaign)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible campaign criterion errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignCriterionErrorEnum {}
/// Nested message and enum types in `CampaignCriterionErrorEnum`.
pub mod campaign_criterion_error_enum {
    /// Enum describing possible campaign criterion errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignCriterionError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Concrete type of criterion (keyword v.s. placement) is required for
        /// CREATE and UPDATE operations.
        ConcreteTypeRequired = 2,
        /// Invalid placement URL.
        InvalidPlacementUrl = 3,
        /// Criteria type can not be excluded for the campaign by the customer. like
        /// AOL account type cannot target site type criteria
        CannotExcludeCriteriaType = 4,
        /// Cannot set the campaign criterion status for this criteria type.
        CannotSetStatusForCriteriaType = 5,
        /// Cannot set the campaign criterion status for an excluded criteria.
        CannotSetStatusForExcludedCriteria = 6,
        /// Cannot target and exclude the same criterion.
        CannotTargetAndExclude = 7,
        /// The mutate contained too many operations.
        TooManyOperations = 8,
        /// This operator cannot be applied to a criterion of this type.
        OperatorNotSupportedForCriterionType = 9,
        /// The Shopping campaign sales country is not supported for
        /// ProductSalesChannel targeting.
        ShoppingCampaignSalesCountryNotSupportedForSalesChannel = 10,
        /// The existing field can't be updated with CREATE operation. It can be
        /// updated with UPDATE operation only.
        CannotAddExistingField = 11,
        /// Negative criteria are immutable, so updates are not allowed.
        CannotUpdateNegativeCriterion = 12,
        /// Only free form names are allowed for negative Smart campaign keyword
        /// theme.
        CannotSetNegativeKeywordThemeConstantCriterion = 13,
        /// Invalid Smart campaign keyword theme constant criterion.
        InvalidKeywordThemeConstant = 14,
        /// A Smart campaign keyword theme constant or free-form Smart campaign
        /// keyword theme is required.
        MissingKeywordThemeConstantOrFreeFormKeywordTheme = 15,
        /// A Smart campaign may not target proximity and location criteria
        /// simultaneously.
        CannotTargetBothProximityAndLocationCriteriaForSmartCampaign = 16,
        /// A Smart campaign may not target multiple proximity criteria.
        CannotTargetMultipleProximityCriteriaForSmartCampaign = 17,
        /// Location is not launched for Local Services Campaigns.
        LocationNotLaunchedForLocalServicesCampaign = 18,
        /// A Local Services campaign may not target certain criteria types.
        LocationInvalidForLocalServicesCampaign = 19,
        /// Country locations are not supported for Local Services campaign.
        CannotTargetCountryForLocalServicesCampaign = 20,
        /// Location is not within the home country of Local Services campaign.
        LocationNotInHomeCountryForLocalServicesCampaign = 21,
        /// Local Services profile does not exist for a particular Local Services
        /// campaign.
        CannotAddOrRemoveLocationForLocalServicesCampaign = 22,
        /// Local Services campaign must have at least one target location.
        AtLeastOnePositiveLocationRequiredForLocalServicesCampaign = 23,
        /// At least one positive local service ID criterion is required for a Local
        /// Services campaign.
        AtLeastOneLocalServiceIdCriterionRequiredForLocalServicesCampaign = 24,
        /// Local service ID is not found under selected categories in local
        /// services campaign setting.
        LocalServiceIdNotFoundForCategory = 25,
        /// For search advertising channel, brand lists can only be applied to
        /// exclusive targeting, broad match campaigns for inclusive targeting or
        /// PMax generated campaigns.
        CannotAttachBrandListToNonQualifiedSearchCampaign = 26,
        /// Campaigns that target all countries and territories are limited to a
        /// certain number of top-level location exclusions. If removing a criterion
        /// causes the campaign to target all countries and territories and the
        /// campaign has more top-level location exclusions than the limit allows,
        /// then this error is returned.
        CannotRemoveAllLocationsDueToTooManyCountryExclusions = 27,
    }
    impl CampaignCriterionError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ConcreteTypeRequired => "CONCRETE_TYPE_REQUIRED",
                Self::InvalidPlacementUrl => "INVALID_PLACEMENT_URL",
                Self::CannotExcludeCriteriaType => "CANNOT_EXCLUDE_CRITERIA_TYPE",
                Self::CannotSetStatusForCriteriaType => {
                    "CANNOT_SET_STATUS_FOR_CRITERIA_TYPE"
                }
                Self::CannotSetStatusForExcludedCriteria => {
                    "CANNOT_SET_STATUS_FOR_EXCLUDED_CRITERIA"
                }
                Self::CannotTargetAndExclude => "CANNOT_TARGET_AND_EXCLUDE",
                Self::TooManyOperations => "TOO_MANY_OPERATIONS",
                Self::OperatorNotSupportedForCriterionType => {
                    "OPERATOR_NOT_SUPPORTED_FOR_CRITERION_TYPE"
                }
                Self::ShoppingCampaignSalesCountryNotSupportedForSalesChannel => {
                    "SHOPPING_CAMPAIGN_SALES_COUNTRY_NOT_SUPPORTED_FOR_SALES_CHANNEL"
                }
                Self::CannotAddExistingField => "CANNOT_ADD_EXISTING_FIELD",
                Self::CannotUpdateNegativeCriterion => "CANNOT_UPDATE_NEGATIVE_CRITERION",
                Self::CannotSetNegativeKeywordThemeConstantCriterion => {
                    "CANNOT_SET_NEGATIVE_KEYWORD_THEME_CONSTANT_CRITERION"
                }
                Self::InvalidKeywordThemeConstant => "INVALID_KEYWORD_THEME_CONSTANT",
                Self::MissingKeywordThemeConstantOrFreeFormKeywordTheme => {
                    "MISSING_KEYWORD_THEME_CONSTANT_OR_FREE_FORM_KEYWORD_THEME"
                }
                Self::CannotTargetBothProximityAndLocationCriteriaForSmartCampaign => {
                    "CANNOT_TARGET_BOTH_PROXIMITY_AND_LOCATION_CRITERIA_FOR_SMART_CAMPAIGN"
                }
                Self::CannotTargetMultipleProximityCriteriaForSmartCampaign => {
                    "CANNOT_TARGET_MULTIPLE_PROXIMITY_CRITERIA_FOR_SMART_CAMPAIGN"
                }
                Self::LocationNotLaunchedForLocalServicesCampaign => {
                    "LOCATION_NOT_LAUNCHED_FOR_LOCAL_SERVICES_CAMPAIGN"
                }
                Self::LocationInvalidForLocalServicesCampaign => {
                    "LOCATION_INVALID_FOR_LOCAL_SERVICES_CAMPAIGN"
                }
                Self::CannotTargetCountryForLocalServicesCampaign => {
                    "CANNOT_TARGET_COUNTRY_FOR_LOCAL_SERVICES_CAMPAIGN"
                }
                Self::LocationNotInHomeCountryForLocalServicesCampaign => {
                    "LOCATION_NOT_IN_HOME_COUNTRY_FOR_LOCAL_SERVICES_CAMPAIGN"
                }
                Self::CannotAddOrRemoveLocationForLocalServicesCampaign => {
                    "CANNOT_ADD_OR_REMOVE_LOCATION_FOR_LOCAL_SERVICES_CAMPAIGN"
                }
                Self::AtLeastOnePositiveLocationRequiredForLocalServicesCampaign => {
                    "AT_LEAST_ONE_POSITIVE_LOCATION_REQUIRED_FOR_LOCAL_SERVICES_CAMPAIGN"
                }
                Self::AtLeastOneLocalServiceIdCriterionRequiredForLocalServicesCampaign => {
                    "AT_LEAST_ONE_LOCAL_SERVICE_ID_CRITERION_REQUIRED_FOR_LOCAL_SERVICES_CAMPAIGN"
                }
                Self::LocalServiceIdNotFoundForCategory => {
                    "LOCAL_SERVICE_ID_NOT_FOUND_FOR_CATEGORY"
                }
                Self::CannotAttachBrandListToNonQualifiedSearchCampaign => {
                    "CANNOT_ATTACH_BRAND_LIST_TO_NON_QUALIFIED_SEARCH_CAMPAIGN"
                }
                Self::CannotRemoveAllLocationsDueToTooManyCountryExclusions => {
                    "CANNOT_REMOVE_ALL_LOCATIONS_DUE_TO_TOO_MANY_COUNTRY_EXCLUSIONS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CONCRETE_TYPE_REQUIRED" => Some(Self::ConcreteTypeRequired),
                "INVALID_PLACEMENT_URL" => Some(Self::InvalidPlacementUrl),
                "CANNOT_EXCLUDE_CRITERIA_TYPE" => Some(Self::CannotExcludeCriteriaType),
                "CANNOT_SET_STATUS_FOR_CRITERIA_TYPE" => {
                    Some(Self::CannotSetStatusForCriteriaType)
                }
                "CANNOT_SET_STATUS_FOR_EXCLUDED_CRITERIA" => {
                    Some(Self::CannotSetStatusForExcludedCriteria)
                }
                "CANNOT_TARGET_AND_EXCLUDE" => Some(Self::CannotTargetAndExclude),
                "TOO_MANY_OPERATIONS" => Some(Self::TooManyOperations),
                "OPERATOR_NOT_SUPPORTED_FOR_CRITERION_TYPE" => {
                    Some(Self::OperatorNotSupportedForCriterionType)
                }
                "SHOPPING_CAMPAIGN_SALES_COUNTRY_NOT_SUPPORTED_FOR_SALES_CHANNEL" => {
                    Some(Self::ShoppingCampaignSalesCountryNotSupportedForSalesChannel)
                }
                "CANNOT_ADD_EXISTING_FIELD" => Some(Self::CannotAddExistingField),
                "CANNOT_UPDATE_NEGATIVE_CRITERION" => {
                    Some(Self::CannotUpdateNegativeCriterion)
                }
                "CANNOT_SET_NEGATIVE_KEYWORD_THEME_CONSTANT_CRITERION" => {
                    Some(Self::CannotSetNegativeKeywordThemeConstantCriterion)
                }
                "INVALID_KEYWORD_THEME_CONSTANT" => {
                    Some(Self::InvalidKeywordThemeConstant)
                }
                "MISSING_KEYWORD_THEME_CONSTANT_OR_FREE_FORM_KEYWORD_THEME" => {
                    Some(Self::MissingKeywordThemeConstantOrFreeFormKeywordTheme)
                }
                "CANNOT_TARGET_BOTH_PROXIMITY_AND_LOCATION_CRITERIA_FOR_SMART_CAMPAIGN" => {
                    Some(
                        Self::CannotTargetBothProximityAndLocationCriteriaForSmartCampaign,
                    )
                }
                "CANNOT_TARGET_MULTIPLE_PROXIMITY_CRITERIA_FOR_SMART_CAMPAIGN" => {
                    Some(Self::CannotTargetMultipleProximityCriteriaForSmartCampaign)
                }
                "LOCATION_NOT_LAUNCHED_FOR_LOCAL_SERVICES_CAMPAIGN" => {
                    Some(Self::LocationNotLaunchedForLocalServicesCampaign)
                }
                "LOCATION_INVALID_FOR_LOCAL_SERVICES_CAMPAIGN" => {
                    Some(Self::LocationInvalidForLocalServicesCampaign)
                }
                "CANNOT_TARGET_COUNTRY_FOR_LOCAL_SERVICES_CAMPAIGN" => {
                    Some(Self::CannotTargetCountryForLocalServicesCampaign)
                }
                "LOCATION_NOT_IN_HOME_COUNTRY_FOR_LOCAL_SERVICES_CAMPAIGN" => {
                    Some(Self::LocationNotInHomeCountryForLocalServicesCampaign)
                }
                "CANNOT_ADD_OR_REMOVE_LOCATION_FOR_LOCAL_SERVICES_CAMPAIGN" => {
                    Some(Self::CannotAddOrRemoveLocationForLocalServicesCampaign)
                }
                "AT_LEAST_ONE_POSITIVE_LOCATION_REQUIRED_FOR_LOCAL_SERVICES_CAMPAIGN" => {
                    Some(
                        Self::AtLeastOnePositiveLocationRequiredForLocalServicesCampaign,
                    )
                }
                "AT_LEAST_ONE_LOCAL_SERVICE_ID_CRITERION_REQUIRED_FOR_LOCAL_SERVICES_CAMPAIGN" => {
                    Some(
                        Self::AtLeastOneLocalServiceIdCriterionRequiredForLocalServicesCampaign,
                    )
                }
                "LOCAL_SERVICE_ID_NOT_FOUND_FOR_CATEGORY" => {
                    Some(Self::LocalServiceIdNotFoundForCategory)
                }
                "CANNOT_ATTACH_BRAND_LIST_TO_NON_QUALIFIED_SEARCH_CAMPAIGN" => {
                    Some(Self::CannotAttachBrandListToNonQualifiedSearchCampaign)
                }
                "CANNOT_REMOVE_ALL_LOCATIONS_DUE_TO_TOO_MANY_COUNTRY_EXCLUSIONS" => {
                    Some(Self::CannotRemoveAllLocationsDueToTooManyCountryExclusions)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible campaign customizer errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignCustomizerErrorEnum {}
/// Nested message and enum types in `CampaignCustomizerErrorEnum`.
pub mod campaign_customizer_error_enum {
    /// Enum describing possible campaign customizer errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignCustomizerError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
    }
    impl CampaignCustomizerError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible campaign draft errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignDraftErrorEnum {}
/// Nested message and enum types in `CampaignDraftErrorEnum`.
pub mod campaign_draft_error_enum {
    /// Enum describing possible campaign draft errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignDraftError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// A draft with this name already exists for this campaign.
        DuplicateDraftName = 2,
        /// The draft is removed and cannot be transitioned to another status.
        InvalidStatusTransitionFromRemoved = 3,
        /// The draft has been promoted and cannot be transitioned to the specified
        /// status.
        InvalidStatusTransitionFromPromoted = 4,
        /// The draft has failed to be promoted and cannot be transitioned to the
        /// specified status.
        InvalidStatusTransitionFromPromoteFailed = 5,
        /// This customer is not allowed to create drafts.
        CustomerCannotCreateDraft = 6,
        /// This campaign is not allowed to create drafts.
        CampaignCannotCreateDraft = 7,
        /// This modification cannot be made on a draft.
        InvalidDraftChange = 8,
        /// The draft cannot be transitioned to the specified status from its
        /// current status.
        InvalidStatusTransition = 9,
        /// The campaign has reached the maximum number of drafts that can be created
        /// for a campaign throughout its lifetime. No additional drafts can be
        /// created for this campaign. Removed drafts also count towards this limit.
        MaxNumberOfDraftsPerCampaignReached = 10,
        /// ListAsyncErrors was called without first promoting the draft.
        ListErrorsForPromotedDraftOnly = 11,
    }
    impl CampaignDraftError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DuplicateDraftName => "DUPLICATE_DRAFT_NAME",
                Self::InvalidStatusTransitionFromRemoved => {
                    "INVALID_STATUS_TRANSITION_FROM_REMOVED"
                }
                Self::InvalidStatusTransitionFromPromoted => {
                    "INVALID_STATUS_TRANSITION_FROM_PROMOTED"
                }
                Self::InvalidStatusTransitionFromPromoteFailed => {
                    "INVALID_STATUS_TRANSITION_FROM_PROMOTE_FAILED"
                }
                Self::CustomerCannotCreateDraft => "CUSTOMER_CANNOT_CREATE_DRAFT",
                Self::CampaignCannotCreateDraft => "CAMPAIGN_CANNOT_CREATE_DRAFT",
                Self::InvalidDraftChange => "INVALID_DRAFT_CHANGE",
                Self::InvalidStatusTransition => "INVALID_STATUS_TRANSITION",
                Self::MaxNumberOfDraftsPerCampaignReached => {
                    "MAX_NUMBER_OF_DRAFTS_PER_CAMPAIGN_REACHED"
                }
                Self::ListErrorsForPromotedDraftOnly => {
                    "LIST_ERRORS_FOR_PROMOTED_DRAFT_ONLY"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_DRAFT_NAME" => Some(Self::DuplicateDraftName),
                "INVALID_STATUS_TRANSITION_FROM_REMOVED" => {
                    Some(Self::InvalidStatusTransitionFromRemoved)
                }
                "INVALID_STATUS_TRANSITION_FROM_PROMOTED" => {
                    Some(Self::InvalidStatusTransitionFromPromoted)
                }
                "INVALID_STATUS_TRANSITION_FROM_PROMOTE_FAILED" => {
                    Some(Self::InvalidStatusTransitionFromPromoteFailed)
                }
                "CUSTOMER_CANNOT_CREATE_DRAFT" => Some(Self::CustomerCannotCreateDraft),
                "CAMPAIGN_CANNOT_CREATE_DRAFT" => Some(Self::CampaignCannotCreateDraft),
                "INVALID_DRAFT_CHANGE" => Some(Self::InvalidDraftChange),
                "INVALID_STATUS_TRANSITION" => Some(Self::InvalidStatusTransition),
                "MAX_NUMBER_OF_DRAFTS_PER_CAMPAIGN_REACHED" => {
                    Some(Self::MaxNumberOfDraftsPerCampaignReached)
                }
                "LIST_ERRORS_FOR_PROMOTED_DRAFT_ONLY" => {
                    Some(Self::ListErrorsForPromotedDraftOnly)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible campaign errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignErrorEnum {}
/// Nested message and enum types in `CampaignErrorEnum`.
pub mod campaign_error_enum {
    /// Enum describing possible campaign errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Cannot target content network.
        CannotTargetContentNetwork = 3,
        /// Cannot target search network.
        CannotTargetSearchNetwork = 4,
        /// Cannot cover search network without google search network.
        CannotTargetSearchNetworkWithoutGoogleSearch = 5,
        /// Cannot target Google Search network for a CPM campaign.
        CannotTargetGoogleSearchForCpmCampaign = 6,
        /// Must target at least one network.
        CampaignMustTargetAtLeastOneNetwork = 7,
        /// Only some Google partners are allowed to target partner search network.
        CannotTargetPartnerSearchNetwork = 8,
        /// Cannot target content network only as campaign has criteria-level bidding
        /// strategy.
        CannotTargetContentNetworkOnlyWithCriteriaLevelBiddingStrategy = 9,
        /// Cannot modify the start or end date such that the campaign duration would
        /// not contain the durations of all runnable trials.
        CampaignDurationMustContainAllRunnableTrials = 10,
        /// Cannot modify dates, budget or status of a trial campaign.
        CannotModifyForTrialCampaign = 11,
        /// Trying to modify the name of an active or paused campaign, where the name
        /// is already assigned to another active or paused campaign.
        DuplicateCampaignName = 12,
        /// Two fields are in conflicting modes.
        IncompatibleCampaignField = 13,
        /// Campaign name cannot be used.
        InvalidCampaignName = 14,
        /// Given status is invalid.
        InvalidAdServingOptimizationStatus = 15,
        /// Error in the campaign level tracking URL.
        InvalidTrackingUrl = 16,
        /// Cannot set both tracking URL template and tracking setting. A user has
        /// to clear legacy tracking setting in order to add tracking URL template.
        CannotSetBothTrackingUrlTemplateAndTrackingSetting = 17,
        /// The maximum number of impressions for Frequency Cap should be an integer
        /// greater than 0.
        MaxImpressionsNotInRange = 18,
        /// Only the Day, Week and Month time units are supported.
        TimeUnitNotSupported = 19,
        /// Operation not allowed on a campaign whose serving status has ended
        InvalidOperationIfServingStatusHasEnded = 20,
        /// This budget is exclusively linked to a Campaign that is using experiments
        /// so it cannot be shared.
        BudgetCannotBeShared = 21,
        /// Campaigns using experiments cannot use a shared budget.
        CampaignCannotUseSharedBudget = 22,
        /// A different budget cannot be assigned to a campaign when there are
        /// running or scheduled trials.
        CannotChangeBudgetOnCampaignWithTrials = 23,
        /// No link found between the campaign and the label.
        CampaignLabelDoesNotExist = 24,
        /// The label has already been attached to the campaign.
        CampaignLabelAlreadyExists = 25,
        /// A ShoppingSetting was not found when creating a shopping campaign.
        MissingShoppingSetting = 26,
        /// The country in shopping setting is not an allowed country.
        InvalidShoppingSalesCountry = 27,
        /// The requested channel type is not available according to the customer's
        /// account setting.
        AdvertisingChannelTypeNotAvailableForAccountType = 31,
        /// The AdvertisingChannelSubType is not a valid subtype of the primary
        /// channel type.
        InvalidAdvertisingChannelSubType = 32,
        /// At least one conversion must be selected.
        AtLeastOneConversionMustBeSelected = 33,
        /// Setting ad rotation mode for a campaign is not allowed. Ad rotation mode
        /// at campaign is deprecated.
        CannotSetAdRotationMode = 34,
        /// Trying to change start date on a campaign that has started.
        CannotModifyStartDateIfAlreadyStarted = 35,
        /// Trying to modify a date into the past.
        CannotSetDateToPast = 36,
        /// Hotel center id in the hotel setting does not match any customer links.
        MissingHotelCustomerLink = 37,
        /// Hotel center id in the hotel setting must match an active customer link.
        InvalidHotelCustomerLink = 38,
        /// Hotel setting was not found when creating a hotel ads campaign.
        MissingHotelSetting = 39,
        /// A Campaign cannot use shared campaign budgets and be part of a campaign
        /// group.
        CannotUseSharedCampaignBudgetWhilePartOfCampaignGroup = 40,
        /// The app ID was not found.
        AppNotFound = 41,
        /// Campaign.shopping_setting.enable_local is not supported for the specified
        /// campaign type.
        ShoppingEnableLocalNotSupportedForCampaignType = 42,
        /// The merchant does not support the creation of campaigns for Shopping
        /// Comparison Listing Ads.
        MerchantNotAllowedForComparisonListingAds = 43,
        /// The App campaign for engagement cannot be created because there aren't
        /// enough installs.
        InsufficientAppInstallsCount = 44,
        /// The App campaign for engagement cannot be created because the app is
        /// sensitive.
        SensitiveCategoryApp = 45,
        /// Customers with Housing, Employment, or Credit ads must accept updated
        /// personalized ads policy to continue creating campaigns.
        HecAgreementRequired = 46,
        /// The field is not compatible with view through conversion optimization.
        NotCompatibleWithViewThroughConversionOptimization = 49,
        /// The field type cannot be excluded because an active campaign-asset link
        /// of this type exists.
        InvalidExcludedParentAssetFieldType = 48,
        /// The app pre-registration campaign cannot be created for non-Android
        /// applications.
        CannotCreateAppPreRegistrationForNonAndroidApp = 50,
        /// The campaign cannot be created since the app is not available for
        /// pre-registration in any country.
        AppNotAvailableToCreateAppPreRegistrationCampaign = 51,
        /// The type of the Budget is not compatible with this Campaign.
        IncompatibleBudgetType = 52,
        /// Category bid list in the local services campaign setting contains
        /// multiple bids for the same category ID.
        LocalServicesDuplicateCategoryBid = 53,
        /// Category bid list in the local services campaign setting contains
        /// a bid for an invalid category ID.
        LocalServicesInvalidCategoryBid = 54,
        /// Category bid list in the local services campaign setting is missing a
        /// bid for a category ID that must be present.
        LocalServicesMissingCategoryBid = 55,
        /// The requested change in status is not supported.
        InvalidStatusChange = 57,
        /// Travel Campaign's travel_account_id does not match any customer links.
        MissingTravelCustomerLink = 58,
        /// Travel Campaign's travel_account_id matches an existing customer link
        /// but the customer link is not active.
        InvalidTravelCustomerLink = 59,
        /// The asset set type is invalid to be set in
        /// excluded_parent_asset_set_types field.
        InvalidExcludedParentAssetSetType = 62,
        /// Campaign.hotel_property_asset_set must point to an asset set of type
        /// HOTEL_PROPERTY.
        AssetSetNotAHotelPropertyAssetSet = 63,
        /// The hotel property asset set can only be set on Performance Max for
        /// travel goals campaigns.
        HotelPropertyAssetSetOnlyForPerformanceMaxForTravelGoals = 64,
        /// Customer's average daily spend is too high to enable this feature.
        AverageDailySpendTooHigh = 65,
        /// Cannot attach the campaign to a deleted campaign group.
        CannotAttachToRemovedCampaignGroup = 66,
        /// Cannot attach the campaign to this bidding strategy.
        CannotAttachToBiddingStrategy = 67,
        /// A budget with a different period cannot be assigned to the campaign.
        CannotChangeBudgetPeriod = 68,
        /// Customer does not have enough conversions to enable this feature.
        NotEnoughConversions = 71,
        /// This campaign type can only have one conversion action.
        CannotSetMoreThanOneConversionAction = 72,
        /// The field is not compatible with the budget type.
        NotCompatibleWithBudgetType = 73,
        /// The feature is incompatible with ConversionActionType.UPLOAD_CLICKS.
        NotCompatibleWithUploadClicksConversion = 74,
        /// App campaign setting app ID must match selective optimization conversion
        /// action app ID.
        AppIdMustMatchConversionActionAppId = 76,
        /// Selective optimization conversion action with Download category is not
        /// allowed.
        ConversionActionWithDownloadCategoryNotAllowed = 77,
        /// One software download for selective optimization conversion action is
        /// required for this campaign conversion action.
        ConversionActionWithDownloadCategoryRequired = 78,
        /// Conversion tracking is not enabled and is required for this feature.
        ConversionTrackingNotEnabled = 79,
        /// The field is not compatible with the bidding strategy type.
        NotCompatibleWithBiddingStrategyType = 80,
        /// Campaign is not compatible with a conversion tracker that has Google
        /// attribution enabled.
        NotCompatibleWithGoogleAttributionConversions = 81,
        /// Customer level conversion lag is too high.
        ConversionLagTooHigh = 82,
        /// The advertiser set as an advertising partner is not an actively linked
        /// advertiser to this customer.
        NotLinkedAdvertisingPartner = 83,
        /// Invalid number of advertising partner IDs.
        InvalidNumberOfAdvertisingPartnerIds = 84,
        /// Cannot target the display network without also targeting YouTube.
        CannotTargetDisplayNetworkWithoutYoutube = 85,
        /// This campaign type cannot be linked to a Comparison Shopping Service
        /// account.
        CannotLinkToComparisonShoppingServiceAccount = 86,
        /// Standard Shopping campaigns that are linked to a Comparison Shopping
        /// Service account cannot target this network.
        CannotTargetNetworkForComparisonShoppingServiceLinkedAccounts = 87,
        /// Text asset automation settings can not be modified when there is an
        /// active Performance Max optimization automatically created assets
        /// experiment. End the experiment to modify these settings.
        CannotModifyTextAssetAutomationWithEnabledTrial = 88,
        /// Dynamic text asset cannot be opted out when final URL expansion is opted
        /// in.
        DynamicTextAssetCannotOptOutWithFinalUrlExpansionOptIn = 89,
    }
    impl CampaignError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CannotTargetContentNetwork => "CANNOT_TARGET_CONTENT_NETWORK",
                Self::CannotTargetSearchNetwork => "CANNOT_TARGET_SEARCH_NETWORK",
                Self::CannotTargetSearchNetworkWithoutGoogleSearch => {
                    "CANNOT_TARGET_SEARCH_NETWORK_WITHOUT_GOOGLE_SEARCH"
                }
                Self::CannotTargetGoogleSearchForCpmCampaign => {
                    "CANNOT_TARGET_GOOGLE_SEARCH_FOR_CPM_CAMPAIGN"
                }
                Self::CampaignMustTargetAtLeastOneNetwork => {
                    "CAMPAIGN_MUST_TARGET_AT_LEAST_ONE_NETWORK"
                }
                Self::CannotTargetPartnerSearchNetwork => {
                    "CANNOT_TARGET_PARTNER_SEARCH_NETWORK"
                }
                Self::CannotTargetContentNetworkOnlyWithCriteriaLevelBiddingStrategy => {
                    "CANNOT_TARGET_CONTENT_NETWORK_ONLY_WITH_CRITERIA_LEVEL_BIDDING_STRATEGY"
                }
                Self::CampaignDurationMustContainAllRunnableTrials => {
                    "CAMPAIGN_DURATION_MUST_CONTAIN_ALL_RUNNABLE_TRIALS"
                }
                Self::CannotModifyForTrialCampaign => "CANNOT_MODIFY_FOR_TRIAL_CAMPAIGN",
                Self::DuplicateCampaignName => "DUPLICATE_CAMPAIGN_NAME",
                Self::IncompatibleCampaignField => "INCOMPATIBLE_CAMPAIGN_FIELD",
                Self::InvalidCampaignName => "INVALID_CAMPAIGN_NAME",
                Self::InvalidAdServingOptimizationStatus => {
                    "INVALID_AD_SERVING_OPTIMIZATION_STATUS"
                }
                Self::InvalidTrackingUrl => "INVALID_TRACKING_URL",
                Self::CannotSetBothTrackingUrlTemplateAndTrackingSetting => {
                    "CANNOT_SET_BOTH_TRACKING_URL_TEMPLATE_AND_TRACKING_SETTING"
                }
                Self::MaxImpressionsNotInRange => "MAX_IMPRESSIONS_NOT_IN_RANGE",
                Self::TimeUnitNotSupported => "TIME_UNIT_NOT_SUPPORTED",
                Self::InvalidOperationIfServingStatusHasEnded => {
                    "INVALID_OPERATION_IF_SERVING_STATUS_HAS_ENDED"
                }
                Self::BudgetCannotBeShared => "BUDGET_CANNOT_BE_SHARED",
                Self::CampaignCannotUseSharedBudget => {
                    "CAMPAIGN_CANNOT_USE_SHARED_BUDGET"
                }
                Self::CannotChangeBudgetOnCampaignWithTrials => {
                    "CANNOT_CHANGE_BUDGET_ON_CAMPAIGN_WITH_TRIALS"
                }
                Self::CampaignLabelDoesNotExist => "CAMPAIGN_LABEL_DOES_NOT_EXIST",
                Self::CampaignLabelAlreadyExists => "CAMPAIGN_LABEL_ALREADY_EXISTS",
                Self::MissingShoppingSetting => "MISSING_SHOPPING_SETTING",
                Self::InvalidShoppingSalesCountry => "INVALID_SHOPPING_SALES_COUNTRY",
                Self::AdvertisingChannelTypeNotAvailableForAccountType => {
                    "ADVERTISING_CHANNEL_TYPE_NOT_AVAILABLE_FOR_ACCOUNT_TYPE"
                }
                Self::InvalidAdvertisingChannelSubType => {
                    "INVALID_ADVERTISING_CHANNEL_SUB_TYPE"
                }
                Self::AtLeastOneConversionMustBeSelected => {
                    "AT_LEAST_ONE_CONVERSION_MUST_BE_SELECTED"
                }
                Self::CannotSetAdRotationMode => "CANNOT_SET_AD_ROTATION_MODE",
                Self::CannotModifyStartDateIfAlreadyStarted => {
                    "CANNOT_MODIFY_START_DATE_IF_ALREADY_STARTED"
                }
                Self::CannotSetDateToPast => "CANNOT_SET_DATE_TO_PAST",
                Self::MissingHotelCustomerLink => "MISSING_HOTEL_CUSTOMER_LINK",
                Self::InvalidHotelCustomerLink => "INVALID_HOTEL_CUSTOMER_LINK",
                Self::MissingHotelSetting => "MISSING_HOTEL_SETTING",
                Self::CannotUseSharedCampaignBudgetWhilePartOfCampaignGroup => {
                    "CANNOT_USE_SHARED_CAMPAIGN_BUDGET_WHILE_PART_OF_CAMPAIGN_GROUP"
                }
                Self::AppNotFound => "APP_NOT_FOUND",
                Self::ShoppingEnableLocalNotSupportedForCampaignType => {
                    "SHOPPING_ENABLE_LOCAL_NOT_SUPPORTED_FOR_CAMPAIGN_TYPE"
                }
                Self::MerchantNotAllowedForComparisonListingAds => {
                    "MERCHANT_NOT_ALLOWED_FOR_COMPARISON_LISTING_ADS"
                }
                Self::InsufficientAppInstallsCount => "INSUFFICIENT_APP_INSTALLS_COUNT",
                Self::SensitiveCategoryApp => "SENSITIVE_CATEGORY_APP",
                Self::HecAgreementRequired => "HEC_AGREEMENT_REQUIRED",
                Self::NotCompatibleWithViewThroughConversionOptimization => {
                    "NOT_COMPATIBLE_WITH_VIEW_THROUGH_CONVERSION_OPTIMIZATION"
                }
                Self::InvalidExcludedParentAssetFieldType => {
                    "INVALID_EXCLUDED_PARENT_ASSET_FIELD_TYPE"
                }
                Self::CannotCreateAppPreRegistrationForNonAndroidApp => {
                    "CANNOT_CREATE_APP_PRE_REGISTRATION_FOR_NON_ANDROID_APP"
                }
                Self::AppNotAvailableToCreateAppPreRegistrationCampaign => {
                    "APP_NOT_AVAILABLE_TO_CREATE_APP_PRE_REGISTRATION_CAMPAIGN"
                }
                Self::IncompatibleBudgetType => "INCOMPATIBLE_BUDGET_TYPE",
                Self::LocalServicesDuplicateCategoryBid => {
                    "LOCAL_SERVICES_DUPLICATE_CATEGORY_BID"
                }
                Self::LocalServicesInvalidCategoryBid => {
                    "LOCAL_SERVICES_INVALID_CATEGORY_BID"
                }
                Self::LocalServicesMissingCategoryBid => {
                    "LOCAL_SERVICES_MISSING_CATEGORY_BID"
                }
                Self::InvalidStatusChange => "INVALID_STATUS_CHANGE",
                Self::MissingTravelCustomerLink => "MISSING_TRAVEL_CUSTOMER_LINK",
                Self::InvalidTravelCustomerLink => "INVALID_TRAVEL_CUSTOMER_LINK",
                Self::InvalidExcludedParentAssetSetType => {
                    "INVALID_EXCLUDED_PARENT_ASSET_SET_TYPE"
                }
                Self::AssetSetNotAHotelPropertyAssetSet => {
                    "ASSET_SET_NOT_A_HOTEL_PROPERTY_ASSET_SET"
                }
                Self::HotelPropertyAssetSetOnlyForPerformanceMaxForTravelGoals => {
                    "HOTEL_PROPERTY_ASSET_SET_ONLY_FOR_PERFORMANCE_MAX_FOR_TRAVEL_GOALS"
                }
                Self::AverageDailySpendTooHigh => "AVERAGE_DAILY_SPEND_TOO_HIGH",
                Self::CannotAttachToRemovedCampaignGroup => {
                    "CANNOT_ATTACH_TO_REMOVED_CAMPAIGN_GROUP"
                }
                Self::CannotAttachToBiddingStrategy => {
                    "CANNOT_ATTACH_TO_BIDDING_STRATEGY"
                }
                Self::CannotChangeBudgetPeriod => "CANNOT_CHANGE_BUDGET_PERIOD",
                Self::NotEnoughConversions => "NOT_ENOUGH_CONVERSIONS",
                Self::CannotSetMoreThanOneConversionAction => {
                    "CANNOT_SET_MORE_THAN_ONE_CONVERSION_ACTION"
                }
                Self::NotCompatibleWithBudgetType => "NOT_COMPATIBLE_WITH_BUDGET_TYPE",
                Self::NotCompatibleWithUploadClicksConversion => {
                    "NOT_COMPATIBLE_WITH_UPLOAD_CLICKS_CONVERSION"
                }
                Self::AppIdMustMatchConversionActionAppId => {
                    "APP_ID_MUST_MATCH_CONVERSION_ACTION_APP_ID"
                }
                Self::ConversionActionWithDownloadCategoryNotAllowed => {
                    "CONVERSION_ACTION_WITH_DOWNLOAD_CATEGORY_NOT_ALLOWED"
                }
                Self::ConversionActionWithDownloadCategoryRequired => {
                    "CONVERSION_ACTION_WITH_DOWNLOAD_CATEGORY_REQUIRED"
                }
                Self::ConversionTrackingNotEnabled => "CONVERSION_TRACKING_NOT_ENABLED",
                Self::NotCompatibleWithBiddingStrategyType => {
                    "NOT_COMPATIBLE_WITH_BIDDING_STRATEGY_TYPE"
                }
                Self::NotCompatibleWithGoogleAttributionConversions => {
                    "NOT_COMPATIBLE_WITH_GOOGLE_ATTRIBUTION_CONVERSIONS"
                }
                Self::ConversionLagTooHigh => "CONVERSION_LAG_TOO_HIGH",
                Self::NotLinkedAdvertisingPartner => "NOT_LINKED_ADVERTISING_PARTNER",
                Self::InvalidNumberOfAdvertisingPartnerIds => {
                    "INVALID_NUMBER_OF_ADVERTISING_PARTNER_IDS"
                }
                Self::CannotTargetDisplayNetworkWithoutYoutube => {
                    "CANNOT_TARGET_DISPLAY_NETWORK_WITHOUT_YOUTUBE"
                }
                Self::CannotLinkToComparisonShoppingServiceAccount => {
                    "CANNOT_LINK_TO_COMPARISON_SHOPPING_SERVICE_ACCOUNT"
                }
                Self::CannotTargetNetworkForComparisonShoppingServiceLinkedAccounts => {
                    "CANNOT_TARGET_NETWORK_FOR_COMPARISON_SHOPPING_SERVICE_LINKED_ACCOUNTS"
                }
                Self::CannotModifyTextAssetAutomationWithEnabledTrial => {
                    "CANNOT_MODIFY_TEXT_ASSET_AUTOMATION_WITH_ENABLED_TRIAL"
                }
                Self::DynamicTextAssetCannotOptOutWithFinalUrlExpansionOptIn => {
                    "DYNAMIC_TEXT_ASSET_CANNOT_OPT_OUT_WITH_FINAL_URL_EXPANSION_OPT_IN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_TARGET_CONTENT_NETWORK" => Some(Self::CannotTargetContentNetwork),
                "CANNOT_TARGET_SEARCH_NETWORK" => Some(Self::CannotTargetSearchNetwork),
                "CANNOT_TARGET_SEARCH_NETWORK_WITHOUT_GOOGLE_SEARCH" => {
                    Some(Self::CannotTargetSearchNetworkWithoutGoogleSearch)
                }
                "CANNOT_TARGET_GOOGLE_SEARCH_FOR_CPM_CAMPAIGN" => {
                    Some(Self::CannotTargetGoogleSearchForCpmCampaign)
                }
                "CAMPAIGN_MUST_TARGET_AT_LEAST_ONE_NETWORK" => {
                    Some(Self::CampaignMustTargetAtLeastOneNetwork)
                }
                "CANNOT_TARGET_PARTNER_SEARCH_NETWORK" => {
                    Some(Self::CannotTargetPartnerSearchNetwork)
                }
                "CANNOT_TARGET_CONTENT_NETWORK_ONLY_WITH_CRITERIA_LEVEL_BIDDING_STRATEGY" => {
                    Some(
                        Self::CannotTargetContentNetworkOnlyWithCriteriaLevelBiddingStrategy,
                    )
                }
                "CAMPAIGN_DURATION_MUST_CONTAIN_ALL_RUNNABLE_TRIALS" => {
                    Some(Self::CampaignDurationMustContainAllRunnableTrials)
                }
                "CANNOT_MODIFY_FOR_TRIAL_CAMPAIGN" => {
                    Some(Self::CannotModifyForTrialCampaign)
                }
                "DUPLICATE_CAMPAIGN_NAME" => Some(Self::DuplicateCampaignName),
                "INCOMPATIBLE_CAMPAIGN_FIELD" => Some(Self::IncompatibleCampaignField),
                "INVALID_CAMPAIGN_NAME" => Some(Self::InvalidCampaignName),
                "INVALID_AD_SERVING_OPTIMIZATION_STATUS" => {
                    Some(Self::InvalidAdServingOptimizationStatus)
                }
                "INVALID_TRACKING_URL" => Some(Self::InvalidTrackingUrl),
                "CANNOT_SET_BOTH_TRACKING_URL_TEMPLATE_AND_TRACKING_SETTING" => {
                    Some(Self::CannotSetBothTrackingUrlTemplateAndTrackingSetting)
                }
                "MAX_IMPRESSIONS_NOT_IN_RANGE" => Some(Self::MaxImpressionsNotInRange),
                "TIME_UNIT_NOT_SUPPORTED" => Some(Self::TimeUnitNotSupported),
                "INVALID_OPERATION_IF_SERVING_STATUS_HAS_ENDED" => {
                    Some(Self::InvalidOperationIfServingStatusHasEnded)
                }
                "BUDGET_CANNOT_BE_SHARED" => Some(Self::BudgetCannotBeShared),
                "CAMPAIGN_CANNOT_USE_SHARED_BUDGET" => {
                    Some(Self::CampaignCannotUseSharedBudget)
                }
                "CANNOT_CHANGE_BUDGET_ON_CAMPAIGN_WITH_TRIALS" => {
                    Some(Self::CannotChangeBudgetOnCampaignWithTrials)
                }
                "CAMPAIGN_LABEL_DOES_NOT_EXIST" => Some(Self::CampaignLabelDoesNotExist),
                "CAMPAIGN_LABEL_ALREADY_EXISTS" => Some(Self::CampaignLabelAlreadyExists),
                "MISSING_SHOPPING_SETTING" => Some(Self::MissingShoppingSetting),
                "INVALID_SHOPPING_SALES_COUNTRY" => {
                    Some(Self::InvalidShoppingSalesCountry)
                }
                "ADVERTISING_CHANNEL_TYPE_NOT_AVAILABLE_FOR_ACCOUNT_TYPE" => {
                    Some(Self::AdvertisingChannelTypeNotAvailableForAccountType)
                }
                "INVALID_ADVERTISING_CHANNEL_SUB_TYPE" => {
                    Some(Self::InvalidAdvertisingChannelSubType)
                }
                "AT_LEAST_ONE_CONVERSION_MUST_BE_SELECTED" => {
                    Some(Self::AtLeastOneConversionMustBeSelected)
                }
                "CANNOT_SET_AD_ROTATION_MODE" => Some(Self::CannotSetAdRotationMode),
                "CANNOT_MODIFY_START_DATE_IF_ALREADY_STARTED" => {
                    Some(Self::CannotModifyStartDateIfAlreadyStarted)
                }
                "CANNOT_SET_DATE_TO_PAST" => Some(Self::CannotSetDateToPast),
                "MISSING_HOTEL_CUSTOMER_LINK" => Some(Self::MissingHotelCustomerLink),
                "INVALID_HOTEL_CUSTOMER_LINK" => Some(Self::InvalidHotelCustomerLink),
                "MISSING_HOTEL_SETTING" => Some(Self::MissingHotelSetting),
                "CANNOT_USE_SHARED_CAMPAIGN_BUDGET_WHILE_PART_OF_CAMPAIGN_GROUP" => {
                    Some(Self::CannotUseSharedCampaignBudgetWhilePartOfCampaignGroup)
                }
                "APP_NOT_FOUND" => Some(Self::AppNotFound),
                "SHOPPING_ENABLE_LOCAL_NOT_SUPPORTED_FOR_CAMPAIGN_TYPE" => {
                    Some(Self::ShoppingEnableLocalNotSupportedForCampaignType)
                }
                "MERCHANT_NOT_ALLOWED_FOR_COMPARISON_LISTING_ADS" => {
                    Some(Self::MerchantNotAllowedForComparisonListingAds)
                }
                "INSUFFICIENT_APP_INSTALLS_COUNT" => {
                    Some(Self::InsufficientAppInstallsCount)
                }
                "SENSITIVE_CATEGORY_APP" => Some(Self::SensitiveCategoryApp),
                "HEC_AGREEMENT_REQUIRED" => Some(Self::HecAgreementRequired),
                "NOT_COMPATIBLE_WITH_VIEW_THROUGH_CONVERSION_OPTIMIZATION" => {
                    Some(Self::NotCompatibleWithViewThroughConversionOptimization)
                }
                "INVALID_EXCLUDED_PARENT_ASSET_FIELD_TYPE" => {
                    Some(Self::InvalidExcludedParentAssetFieldType)
                }
                "CANNOT_CREATE_APP_PRE_REGISTRATION_FOR_NON_ANDROID_APP" => {
                    Some(Self::CannotCreateAppPreRegistrationForNonAndroidApp)
                }
                "APP_NOT_AVAILABLE_TO_CREATE_APP_PRE_REGISTRATION_CAMPAIGN" => {
                    Some(Self::AppNotAvailableToCreateAppPreRegistrationCampaign)
                }
                "INCOMPATIBLE_BUDGET_TYPE" => Some(Self::IncompatibleBudgetType),
                "LOCAL_SERVICES_DUPLICATE_CATEGORY_BID" => {
                    Some(Self::LocalServicesDuplicateCategoryBid)
                }
                "LOCAL_SERVICES_INVALID_CATEGORY_BID" => {
                    Some(Self::LocalServicesInvalidCategoryBid)
                }
                "LOCAL_SERVICES_MISSING_CATEGORY_BID" => {
                    Some(Self::LocalServicesMissingCategoryBid)
                }
                "INVALID_STATUS_CHANGE" => Some(Self::InvalidStatusChange),
                "MISSING_TRAVEL_CUSTOMER_LINK" => Some(Self::MissingTravelCustomerLink),
                "INVALID_TRAVEL_CUSTOMER_LINK" => Some(Self::InvalidTravelCustomerLink),
                "INVALID_EXCLUDED_PARENT_ASSET_SET_TYPE" => {
                    Some(Self::InvalidExcludedParentAssetSetType)
                }
                "ASSET_SET_NOT_A_HOTEL_PROPERTY_ASSET_SET" => {
                    Some(Self::AssetSetNotAHotelPropertyAssetSet)
                }
                "HOTEL_PROPERTY_ASSET_SET_ONLY_FOR_PERFORMANCE_MAX_FOR_TRAVEL_GOALS" => {
                    Some(Self::HotelPropertyAssetSetOnlyForPerformanceMaxForTravelGoals)
                }
                "AVERAGE_DAILY_SPEND_TOO_HIGH" => Some(Self::AverageDailySpendTooHigh),
                "CANNOT_ATTACH_TO_REMOVED_CAMPAIGN_GROUP" => {
                    Some(Self::CannotAttachToRemovedCampaignGroup)
                }
                "CANNOT_ATTACH_TO_BIDDING_STRATEGY" => {
                    Some(Self::CannotAttachToBiddingStrategy)
                }
                "CANNOT_CHANGE_BUDGET_PERIOD" => Some(Self::CannotChangeBudgetPeriod),
                "NOT_ENOUGH_CONVERSIONS" => Some(Self::NotEnoughConversions),
                "CANNOT_SET_MORE_THAN_ONE_CONVERSION_ACTION" => {
                    Some(Self::CannotSetMoreThanOneConversionAction)
                }
                "NOT_COMPATIBLE_WITH_BUDGET_TYPE" => {
                    Some(Self::NotCompatibleWithBudgetType)
                }
                "NOT_COMPATIBLE_WITH_UPLOAD_CLICKS_CONVERSION" => {
                    Some(Self::NotCompatibleWithUploadClicksConversion)
                }
                "APP_ID_MUST_MATCH_CONVERSION_ACTION_APP_ID" => {
                    Some(Self::AppIdMustMatchConversionActionAppId)
                }
                "CONVERSION_ACTION_WITH_DOWNLOAD_CATEGORY_NOT_ALLOWED" => {
                    Some(Self::ConversionActionWithDownloadCategoryNotAllowed)
                }
                "CONVERSION_ACTION_WITH_DOWNLOAD_CATEGORY_REQUIRED" => {
                    Some(Self::ConversionActionWithDownloadCategoryRequired)
                }
                "CONVERSION_TRACKING_NOT_ENABLED" => {
                    Some(Self::ConversionTrackingNotEnabled)
                }
                "NOT_COMPATIBLE_WITH_BIDDING_STRATEGY_TYPE" => {
                    Some(Self::NotCompatibleWithBiddingStrategyType)
                }
                "NOT_COMPATIBLE_WITH_GOOGLE_ATTRIBUTION_CONVERSIONS" => {
                    Some(Self::NotCompatibleWithGoogleAttributionConversions)
                }
                "CONVERSION_LAG_TOO_HIGH" => Some(Self::ConversionLagTooHigh),
                "NOT_LINKED_ADVERTISING_PARTNER" => {
                    Some(Self::NotLinkedAdvertisingPartner)
                }
                "INVALID_NUMBER_OF_ADVERTISING_PARTNER_IDS" => {
                    Some(Self::InvalidNumberOfAdvertisingPartnerIds)
                }
                "CANNOT_TARGET_DISPLAY_NETWORK_WITHOUT_YOUTUBE" => {
                    Some(Self::CannotTargetDisplayNetworkWithoutYoutube)
                }
                "CANNOT_LINK_TO_COMPARISON_SHOPPING_SERVICE_ACCOUNT" => {
                    Some(Self::CannotLinkToComparisonShoppingServiceAccount)
                }
                "CANNOT_TARGET_NETWORK_FOR_COMPARISON_SHOPPING_SERVICE_LINKED_ACCOUNTS" => {
                    Some(
                        Self::CannotTargetNetworkForComparisonShoppingServiceLinkedAccounts,
                    )
                }
                "CANNOT_MODIFY_TEXT_ASSET_AUTOMATION_WITH_ENABLED_TRIAL" => {
                    Some(Self::CannotModifyTextAssetAutomationWithEnabledTrial)
                }
                "DYNAMIC_TEXT_ASSET_CANNOT_OPT_OUT_WITH_FINAL_URL_EXPANSION_OPT_IN" => {
                    Some(Self::DynamicTextAssetCannotOptOutWithFinalUrlExpansionOptIn)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible campaign experiment errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignExperimentErrorEnum {}
/// Nested message and enum types in `CampaignExperimentErrorEnum`.
pub mod campaign_experiment_error_enum {
    /// Enum describing possible campaign experiment errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignExperimentError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// An active campaign or experiment with this name already exists.
        DuplicateName = 2,
        /// Experiment cannot be updated from the current state to the
        /// requested target state. For example, an experiment can only graduate
        /// if its status is ENABLED.
        InvalidTransition = 3,
        /// Cannot create an experiment from a campaign using an explicitly shared
        /// budget.
        CannotCreateExperimentWithSharedBudget = 4,
        /// Cannot create an experiment for a removed base campaign.
        CannotCreateExperimentForRemovedBaseCampaign = 5,
        /// Cannot create an experiment from a draft, which has a status other than
        /// proposed.
        CannotCreateExperimentForNonProposedDraft = 6,
        /// This customer is not allowed to create an experiment.
        CustomerCannotCreateExperiment = 7,
        /// This campaign is not allowed to create an experiment.
        CampaignCannotCreateExperiment = 8,
        /// Trying to set an experiment duration which overlaps with another
        /// experiment.
        ExperimentDurationsMustNotOverlap = 9,
        /// All non-removed experiments must start and end within their campaign's
        /// duration.
        ExperimentDurationMustBeWithinCampaignDuration = 10,
        /// The experiment cannot be modified because its status is in a terminal
        /// state, such as REMOVED.
        CannotMutateExperimentDueToStatus = 11,
    }
    impl CampaignExperimentError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DuplicateName => "DUPLICATE_NAME",
                Self::InvalidTransition => "INVALID_TRANSITION",
                Self::CannotCreateExperimentWithSharedBudget => {
                    "CANNOT_CREATE_EXPERIMENT_WITH_SHARED_BUDGET"
                }
                Self::CannotCreateExperimentForRemovedBaseCampaign => {
                    "CANNOT_CREATE_EXPERIMENT_FOR_REMOVED_BASE_CAMPAIGN"
                }
                Self::CannotCreateExperimentForNonProposedDraft => {
                    "CANNOT_CREATE_EXPERIMENT_FOR_NON_PROPOSED_DRAFT"
                }
                Self::CustomerCannotCreateExperiment => {
                    "CUSTOMER_CANNOT_CREATE_EXPERIMENT"
                }
                Self::CampaignCannotCreateExperiment => {
                    "CAMPAIGN_CANNOT_CREATE_EXPERIMENT"
                }
                Self::ExperimentDurationsMustNotOverlap => {
                    "EXPERIMENT_DURATIONS_MUST_NOT_OVERLAP"
                }
                Self::ExperimentDurationMustBeWithinCampaignDuration => {
                    "EXPERIMENT_DURATION_MUST_BE_WITHIN_CAMPAIGN_DURATION"
                }
                Self::CannotMutateExperimentDueToStatus => {
                    "CANNOT_MUTATE_EXPERIMENT_DUE_TO_STATUS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "INVALID_TRANSITION" => Some(Self::InvalidTransition),
                "CANNOT_CREATE_EXPERIMENT_WITH_SHARED_BUDGET" => {
                    Some(Self::CannotCreateExperimentWithSharedBudget)
                }
                "CANNOT_CREATE_EXPERIMENT_FOR_REMOVED_BASE_CAMPAIGN" => {
                    Some(Self::CannotCreateExperimentForRemovedBaseCampaign)
                }
                "CANNOT_CREATE_EXPERIMENT_FOR_NON_PROPOSED_DRAFT" => {
                    Some(Self::CannotCreateExperimentForNonProposedDraft)
                }
                "CUSTOMER_CANNOT_CREATE_EXPERIMENT" => {
                    Some(Self::CustomerCannotCreateExperiment)
                }
                "CAMPAIGN_CANNOT_CREATE_EXPERIMENT" => {
                    Some(Self::CampaignCannotCreateExperiment)
                }
                "EXPERIMENT_DURATIONS_MUST_NOT_OVERLAP" => {
                    Some(Self::ExperimentDurationsMustNotOverlap)
                }
                "EXPERIMENT_DURATION_MUST_BE_WITHIN_CAMPAIGN_DURATION" => {
                    Some(Self::ExperimentDurationMustBeWithinCampaignDuration)
                }
                "CANNOT_MUTATE_EXPERIMENT_DUE_TO_STATUS" => {
                    Some(Self::CannotMutateExperimentDueToStatus)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible campaign feed errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignFeedErrorEnum {}
/// Nested message and enum types in `CampaignFeedErrorEnum`.
pub mod campaign_feed_error_enum {
    /// Enum describing possible campaign feed errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignFeedError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// An active feed already exists for this campaign and placeholder type.
        FeedAlreadyExistsForPlaceholderType = 2,
        /// The specified feed is removed.
        CannotCreateForRemovedFeed = 4,
        /// The CampaignFeed already exists. UPDATE should be used to modify the
        /// existing CampaignFeed.
        CannotCreateAlreadyExistingCampaignFeed = 5,
        /// Cannot update removed campaign feed.
        CannotModifyRemovedCampaignFeed = 6,
        /// Invalid placeholder type.
        InvalidPlaceholderType = 7,
        /// Feed mapping for this placeholder type does not exist.
        MissingFeedmappingForPlaceholderType = 8,
        /// Location CampaignFeeds cannot be created unless there is a location
        /// CustomerFeed for the specified feed.
        NoExistingLocationCustomerFeed = 9,
        /// Feed is read only.
        LegacyFeedTypeReadOnly = 10,
    }
    impl CampaignFeedError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::FeedAlreadyExistsForPlaceholderType => {
                    "FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE"
                }
                Self::CannotCreateForRemovedFeed => "CANNOT_CREATE_FOR_REMOVED_FEED",
                Self::CannotCreateAlreadyExistingCampaignFeed => {
                    "CANNOT_CREATE_ALREADY_EXISTING_CAMPAIGN_FEED"
                }
                Self::CannotModifyRemovedCampaignFeed => {
                    "CANNOT_MODIFY_REMOVED_CAMPAIGN_FEED"
                }
                Self::InvalidPlaceholderType => "INVALID_PLACEHOLDER_TYPE",
                Self::MissingFeedmappingForPlaceholderType => {
                    "MISSING_FEEDMAPPING_FOR_PLACEHOLDER_TYPE"
                }
                Self::NoExistingLocationCustomerFeed => {
                    "NO_EXISTING_LOCATION_CUSTOMER_FEED"
                }
                Self::LegacyFeedTypeReadOnly => "LEGACY_FEED_TYPE_READ_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::FeedAlreadyExistsForPlaceholderType)
                }
                "CANNOT_CREATE_FOR_REMOVED_FEED" => {
                    Some(Self::CannotCreateForRemovedFeed)
                }
                "CANNOT_CREATE_ALREADY_EXISTING_CAMPAIGN_FEED" => {
                    Some(Self::CannotCreateAlreadyExistingCampaignFeed)
                }
                "CANNOT_MODIFY_REMOVED_CAMPAIGN_FEED" => {
                    Some(Self::CannotModifyRemovedCampaignFeed)
                }
                "INVALID_PLACEHOLDER_TYPE" => Some(Self::InvalidPlaceholderType),
                "MISSING_FEEDMAPPING_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::MissingFeedmappingForPlaceholderType)
                }
                "NO_EXISTING_LOCATION_CUSTOMER_FEED" => {
                    Some(Self::NoExistingLocationCustomerFeed)
                }
                "LEGACY_FEED_TYPE_READ_ONLY" => Some(Self::LegacyFeedTypeReadOnly),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible campaign lifecycle goal errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignLifecycleGoalErrorEnum {}
/// Nested message and enum types in `CampaignLifecycleGoalErrorEnum`.
pub mod campaign_lifecycle_goal_error_enum {
    /// Enum describing possible campaign lifecycle goal errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignLifecycleGoalError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Campaign is not specified.
        CampaignMissing = 2,
        /// Cannot find the specified campaign.
        InvalidCampaign = 3,
        /// Optimization mode is unspecified or invalid.
        CustomerAcquisitionInvalidOptimizationMode = 4,
        /// The configured lifecycle goal setting is not compatible with the bidding
        /// strategy the campaign is using. Specifically, BID_HIGHER_FOR_NEW_CUSTOMER
        /// requires conversion-value based bidding strategy type such as
        /// MAXIMIZE_CONVERSION_VALUE.
        IncompatibleBiddingStrategy = 5,
        /// Lifecycle goals require the campaign to optimize towards purchase
        /// conversion goal.
        MissingPurchaseGoal = 6,
        /// CampaignLifecycleGoal.customer_acquisition_goal_settings.value_settings.high_lifetime_value
        /// is invalid or not allowed, such as when the specified value is smaller
        /// than 0.01, when the optimization mode is not BID_HIGHER_FOR_NEW_CUSTOMER,
        /// or when
        /// CampaignLifecycleGoal.customer_acquisition_goal_settings.value_settings.high_lifetime_value
        /// is specified smaller than/without
        /// CampaignLifecycleGoal.customer_acquisition_goal_settings.value_settings.value.
        CustomerAcquisitionInvalidHighLifetimeValue = 7,
        /// Customer acquisition goal is not supported on this campaign type.
        CustomerAcquisitionUnsupportedCampaignType = 8,
        /// CampaignLifecycleGoal.customer_acquisition_goal_settings.value_settings.value
        /// is invalid or not allowed, such as when the specified value is smaller
        /// than 0.01, or when the optimization mode is not
        /// BID_HIGHER_FOR_NEW_CUSTOMER.
        CustomerAcquisitionInvalidValue = 9,
        /// To use BID_HIGHER_FOR_NEW_CUSTOMER mode, either
        /// CampaignLifecycleGoal.customer_acquisition_goal_settings.value_settings.value
        /// or CustomerLifecycleGoal.customer_acquisition_goal_value_settings.value
        /// must have been specified. If a manager account is managing your account's
        /// conversion tracking, then only the CustomerLifecycleGoal of that manager
        /// account is used.
        CustomerAcquisitionValueMissing = 10,
        /// In order for a campaign to adopt the customer acquisition goal,
        /// CustomerLifecycleGoal.lifecycle_goal_customer_definition_settings.existing_user_lists
        /// must include active and accessible userlist with more than 1000 members
        /// in the Search/Youtube network. If a manager account is managing your
        /// account's conversion tracking, then only the CustomerLifecycleGoal of
        /// that manager account is used. Also make sure that the manager account
        /// shares audience segments with sub-accounts with continuous audience
        /// sharing.
        CustomerAcquisitionMissingExistingCustomerDefinition = 11,
        /// In order for a campaign to adopt the customer acquisition goal with high
        /// lifetime value optimization,
        /// CustomerLifecycleGoal.lifecycle_goal_customer_definition_settings.high_lifetime_value_user_lists
        /// must include active and accessible userlist with more than 1000 members
        /// in the Search/Youtube network. If a manager account is managing your
        /// account's conversion tracking, then only the CustomerLifecycleGoal of
        /// that manager account is used. Also make sure that the manager account
        /// shares audience segments with sub-accounts using continuous audience
        /// sharing.
        CustomerAcquisitionMissingHighValueCustomerDefinition = 12,
    }
    impl CampaignLifecycleGoalError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CampaignMissing => "CAMPAIGN_MISSING",
                Self::InvalidCampaign => "INVALID_CAMPAIGN",
                Self::CustomerAcquisitionInvalidOptimizationMode => {
                    "CUSTOMER_ACQUISITION_INVALID_OPTIMIZATION_MODE"
                }
                Self::IncompatibleBiddingStrategy => "INCOMPATIBLE_BIDDING_STRATEGY",
                Self::MissingPurchaseGoal => "MISSING_PURCHASE_GOAL",
                Self::CustomerAcquisitionInvalidHighLifetimeValue => {
                    "CUSTOMER_ACQUISITION_INVALID_HIGH_LIFETIME_VALUE"
                }
                Self::CustomerAcquisitionUnsupportedCampaignType => {
                    "CUSTOMER_ACQUISITION_UNSUPPORTED_CAMPAIGN_TYPE"
                }
                Self::CustomerAcquisitionInvalidValue => {
                    "CUSTOMER_ACQUISITION_INVALID_VALUE"
                }
                Self::CustomerAcquisitionValueMissing => {
                    "CUSTOMER_ACQUISITION_VALUE_MISSING"
                }
                Self::CustomerAcquisitionMissingExistingCustomerDefinition => {
                    "CUSTOMER_ACQUISITION_MISSING_EXISTING_CUSTOMER_DEFINITION"
                }
                Self::CustomerAcquisitionMissingHighValueCustomerDefinition => {
                    "CUSTOMER_ACQUISITION_MISSING_HIGH_VALUE_CUSTOMER_DEFINITION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_MISSING" => Some(Self::CampaignMissing),
                "INVALID_CAMPAIGN" => Some(Self::InvalidCampaign),
                "CUSTOMER_ACQUISITION_INVALID_OPTIMIZATION_MODE" => {
                    Some(Self::CustomerAcquisitionInvalidOptimizationMode)
                }
                "INCOMPATIBLE_BIDDING_STRATEGY" => {
                    Some(Self::IncompatibleBiddingStrategy)
                }
                "MISSING_PURCHASE_GOAL" => Some(Self::MissingPurchaseGoal),
                "CUSTOMER_ACQUISITION_INVALID_HIGH_LIFETIME_VALUE" => {
                    Some(Self::CustomerAcquisitionInvalidHighLifetimeValue)
                }
                "CUSTOMER_ACQUISITION_UNSUPPORTED_CAMPAIGN_TYPE" => {
                    Some(Self::CustomerAcquisitionUnsupportedCampaignType)
                }
                "CUSTOMER_ACQUISITION_INVALID_VALUE" => {
                    Some(Self::CustomerAcquisitionInvalidValue)
                }
                "CUSTOMER_ACQUISITION_VALUE_MISSING" => {
                    Some(Self::CustomerAcquisitionValueMissing)
                }
                "CUSTOMER_ACQUISITION_MISSING_EXISTING_CUSTOMER_DEFINITION" => {
                    Some(Self::CustomerAcquisitionMissingExistingCustomerDefinition)
                }
                "CUSTOMER_ACQUISITION_MISSING_HIGH_VALUE_CUSTOMER_DEFINITION" => {
                    Some(Self::CustomerAcquisitionMissingHighValueCustomerDefinition)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible campaign shared set errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignSharedSetErrorEnum {}
/// Nested message and enum types in `CampaignSharedSetErrorEnum`.
pub mod campaign_shared_set_error_enum {
    /// Enum describing possible campaign shared set errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignSharedSetError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The shared set belongs to another customer and permission isn't granted.
        SharedSetAccessDenied = 2,
    }
    impl CampaignSharedSetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::SharedSetAccessDenied => "SHARED_SET_ACCESS_DENIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SHARED_SET_ACCESS_DENIED" => Some(Self::SharedSetAccessDenied),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible change event errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeEventErrorEnum {}
/// Nested message and enum types in `ChangeEventErrorEnum`.
pub mod change_event_error_enum {
    /// Enum describing possible change event errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChangeEventError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The requested start date is too old. It cannot be older than 30 days.
        StartDateTooOld = 2,
        /// The change_event search request must specify a finite range filter
        /// on change_date_time.
        ChangeDateRangeInfinite = 3,
        /// The change event search request has specified invalid date time filters
        /// that can never logically produce any valid results (for example, start
        /// time after end time).
        ChangeDateRangeNegative = 4,
        /// The change_event search request must specify a LIMIT.
        LimitNotSpecified = 5,
        /// The LIMIT specified by change_event request should be less than or equal
        /// to 10K.
        InvalidLimitClause = 6,
    }
    impl ChangeEventError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::StartDateTooOld => "START_DATE_TOO_OLD",
                Self::ChangeDateRangeInfinite => "CHANGE_DATE_RANGE_INFINITE",
                Self::ChangeDateRangeNegative => "CHANGE_DATE_RANGE_NEGATIVE",
                Self::LimitNotSpecified => "LIMIT_NOT_SPECIFIED",
                Self::InvalidLimitClause => "INVALID_LIMIT_CLAUSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "START_DATE_TOO_OLD" => Some(Self::StartDateTooOld),
                "CHANGE_DATE_RANGE_INFINITE" => Some(Self::ChangeDateRangeInfinite),
                "CHANGE_DATE_RANGE_NEGATIVE" => Some(Self::ChangeDateRangeNegative),
                "LIMIT_NOT_SPECIFIED" => Some(Self::LimitNotSpecified),
                "INVALID_LIMIT_CLAUSE" => Some(Self::InvalidLimitClause),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible change status errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeStatusErrorEnum {}
/// Nested message and enum types in `ChangeStatusErrorEnum`.
pub mod change_status_error_enum {
    /// Enum describing possible change status errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChangeStatusError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The requested start date is too old.
        StartDateTooOld = 3,
        /// The change_status search request must specify a finite range filter
        /// on last_change_date_time.
        ChangeDateRangeInfinite = 4,
        /// The change status search request has specified invalid date time filters
        /// that can never logically produce any valid results (for example, start
        /// time after end time).
        ChangeDateRangeNegative = 5,
        /// The change_status search request must specify a LIMIT.
        LimitNotSpecified = 6,
        /// The LIMIT specified by change_status request should be less than or equal
        /// to 10K.
        InvalidLimitClause = 7,
    }
    impl ChangeStatusError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::StartDateTooOld => "START_DATE_TOO_OLD",
                Self::ChangeDateRangeInfinite => "CHANGE_DATE_RANGE_INFINITE",
                Self::ChangeDateRangeNegative => "CHANGE_DATE_RANGE_NEGATIVE",
                Self::LimitNotSpecified => "LIMIT_NOT_SPECIFIED",
                Self::InvalidLimitClause => "INVALID_LIMIT_CLAUSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "START_DATE_TOO_OLD" => Some(Self::StartDateTooOld),
                "CHANGE_DATE_RANGE_INFINITE" => Some(Self::ChangeDateRangeInfinite),
                "CHANGE_DATE_RANGE_NEGATIVE" => Some(Self::ChangeDateRangeNegative),
                "LIMIT_NOT_SPECIFIED" => Some(Self::LimitNotSpecified),
                "INVALID_LIMIT_CLAUSE" => Some(Self::InvalidLimitClause),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible collection size errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CollectionSizeErrorEnum {}
/// Nested message and enum types in `CollectionSizeErrorEnum`.
pub mod collection_size_error_enum {
    /// Enum describing possible collection size errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CollectionSizeError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Too few.
        TooFew = 2,
        /// Too many.
        TooMany = 3,
    }
    impl CollectionSizeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::TooFew => "TOO_FEW",
                Self::TooMany => "TOO_MANY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TOO_FEW" => Some(Self::TooFew),
                "TOO_MANY" => Some(Self::TooMany),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible context errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ContextErrorEnum {}
/// Nested message and enum types in `ContextErrorEnum`.
pub mod context_error_enum {
    /// Enum describing possible context errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContextError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The operation is not allowed for the given context.
        OperationNotPermittedForContext = 2,
        /// The operation is not allowed for removed resources.
        OperationNotPermittedForRemovedResource = 3,
    }
    impl ContextError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::OperationNotPermittedForContext => {
                    "OPERATION_NOT_PERMITTED_FOR_CONTEXT"
                }
                Self::OperationNotPermittedForRemovedResource => {
                    "OPERATION_NOT_PERMITTED_FOR_REMOVED_RESOURCE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPERATION_NOT_PERMITTED_FOR_CONTEXT" => {
                    Some(Self::OperationNotPermittedForContext)
                }
                "OPERATION_NOT_PERMITTED_FOR_REMOVED_RESOURCE" => {
                    Some(Self::OperationNotPermittedForRemovedResource)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible conversion action errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionActionErrorEnum {}
/// Nested message and enum types in `ConversionActionErrorEnum`.
pub mod conversion_action_error_enum {
    /// Enum describing possible conversion action errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionActionError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The specified conversion action name already exists.
        DuplicateName = 2,
        /// Another conversion action with the specified app id already exists.
        DuplicateAppId = 3,
        /// Android first open action conflicts with Google play codeless download
        /// action tracking the same app.
        TwoConversionActionsBiddingOnSameAppDownload = 4,
        /// Android first open action conflicts with Google play codeless download
        /// action tracking the same app.
        BiddingOnSameAppDownloadAsGlobalAction = 5,
        /// The attribution model cannot be set to DATA_DRIVEN because a data-driven
        /// model has never been generated.
        DataDrivenModelWasNeverGenerated = 6,
        /// The attribution model cannot be set to DATA_DRIVEN because the
        /// data-driven model is expired.
        DataDrivenModelExpired = 7,
        /// The attribution model cannot be set to DATA_DRIVEN because the
        /// data-driven model is stale.
        DataDrivenModelStale = 8,
        /// The attribution model cannot be set to DATA_DRIVEN because the
        /// data-driven model is unavailable or the conversion action was newly
        /// added.
        DataDrivenModelUnknown = 9,
        /// Creation of this conversion action type isn't supported by Google
        /// Ads API.
        CreationNotSupported = 10,
        /// Update of this conversion action isn't supported by Google Ads API.
        UpdateNotSupported = 11,
        /// Rule-based attribution models are deprecated and not allowed to be set
        /// by conversion action.
        CannotSetRuleBasedAttributionModels = 12,
    }
    impl ConversionActionError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DuplicateName => "DUPLICATE_NAME",
                Self::DuplicateAppId => "DUPLICATE_APP_ID",
                Self::TwoConversionActionsBiddingOnSameAppDownload => {
                    "TWO_CONVERSION_ACTIONS_BIDDING_ON_SAME_APP_DOWNLOAD"
                }
                Self::BiddingOnSameAppDownloadAsGlobalAction => {
                    "BIDDING_ON_SAME_APP_DOWNLOAD_AS_GLOBAL_ACTION"
                }
                Self::DataDrivenModelWasNeverGenerated => {
                    "DATA_DRIVEN_MODEL_WAS_NEVER_GENERATED"
                }
                Self::DataDrivenModelExpired => "DATA_DRIVEN_MODEL_EXPIRED",
                Self::DataDrivenModelStale => "DATA_DRIVEN_MODEL_STALE",
                Self::DataDrivenModelUnknown => "DATA_DRIVEN_MODEL_UNKNOWN",
                Self::CreationNotSupported => "CREATION_NOT_SUPPORTED",
                Self::UpdateNotSupported => "UPDATE_NOT_SUPPORTED",
                Self::CannotSetRuleBasedAttributionModels => {
                    "CANNOT_SET_RULE_BASED_ATTRIBUTION_MODELS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "DUPLICATE_APP_ID" => Some(Self::DuplicateAppId),
                "TWO_CONVERSION_ACTIONS_BIDDING_ON_SAME_APP_DOWNLOAD" => {
                    Some(Self::TwoConversionActionsBiddingOnSameAppDownload)
                }
                "BIDDING_ON_SAME_APP_DOWNLOAD_AS_GLOBAL_ACTION" => {
                    Some(Self::BiddingOnSameAppDownloadAsGlobalAction)
                }
                "DATA_DRIVEN_MODEL_WAS_NEVER_GENERATED" => {
                    Some(Self::DataDrivenModelWasNeverGenerated)
                }
                "DATA_DRIVEN_MODEL_EXPIRED" => Some(Self::DataDrivenModelExpired),
                "DATA_DRIVEN_MODEL_STALE" => Some(Self::DataDrivenModelStale),
                "DATA_DRIVEN_MODEL_UNKNOWN" => Some(Self::DataDrivenModelUnknown),
                "CREATION_NOT_SUPPORTED" => Some(Self::CreationNotSupported),
                "UPDATE_NOT_SUPPORTED" => Some(Self::UpdateNotSupported),
                "CANNOT_SET_RULE_BASED_ATTRIBUTION_MODELS" => {
                    Some(Self::CannotSetRuleBasedAttributionModels)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible conversion adjustment upload errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionAdjustmentUploadErrorEnum {}
/// Nested message and enum types in `ConversionAdjustmentUploadErrorEnum`.
pub mod conversion_adjustment_upload_error_enum {
    /// Enum describing possible conversion adjustment upload errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionAdjustmentUploadError {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Can't import events to a conversion action that was just created. Try
        /// importing again in 6 hours.
        TooRecentConversionAction = 2,
        /// The conversion was already retracted. This adjustment was not processed.
        ConversionAlreadyRetracted = 4,
        /// The conversion for this conversion action and conversion identifier can't
        /// be found. Make sure your conversion identifiers are associated with the
        /// correct conversion action and try again.
        ConversionNotFound = 5,
        /// Adjustment can't be made to a conversion that occurred more than 54 days
        /// ago.
        ConversionExpired = 6,
        /// Adjustment has an `adjustment_date_time` that occurred before the
        /// associated conversion. Make sure your `adjustment_date_time` is correct
        /// and try again.
        AdjustmentPrecedesConversion = 7,
        /// More recent adjustment `adjustment_date_time` has already been reported
        /// for the associated conversion.  Make sure your adjustment
        /// `adjustment_date_time` is correct and try again.
        MoreRecentRestatementFound = 8,
        /// Adjustment can't be recorded because the conversion occurred too
        /// recently. Try adjusting a conversion that occurred at least 24 hours ago.
        TooRecentConversion = 9,
        /// Can't make an adjustment to a conversion that is set up to use the
        /// default value. Check your conversion action value setting and try again.
        CannotRestateConversionActionThatAlwaysUsesDefaultConversionValue = 10,
        /// Try uploading fewer than 2001 adjustments in a single API request.
        TooManyAdjustmentsInRequest = 11,
        /// The conversion has already been adjusted the maximum number of times.
        /// Make sure you're only making necessary adjustment to existing conversion.
        TooManyAdjustments = 12,
        /// The conversion has prior a restatement with the same
        /// `adjustment_date_time`. Make sure your adjustment has the correct and
        /// unique `adjustment_date_time` and try again.
        RestatementAlreadyExists = 13,
        /// Imported adjustment has a duplicate conversion adjustment with same
        /// `adjustment_date_time`. Make sure your adjustment has the correct
        /// `adjustment_date_time` and try again.
        DuplicateAdjustmentInRequest = 14,
        /// Make sure you agree to the customer data processing terms in conversion
        /// settings and try again.
        CustomerNotAcceptedCustomerDataTerms = 15,
        /// Can't use enhanced conversions with the specified conversion action.
        ConversionActionNotEligibleForEnhancement = 16,
        /// Make sure you hash user provided data using SHA-256 and ensure you are
        /// normalizing according to the guidelines.
        InvalidUserIdentifier = 17,
        /// Use user provided data such as emails or phone numbers hashed using
        /// SHA-256 and try again.
        UnsupportedUserIdentifier = 18,
        /// Cannot set both gclid_date_time_pair and order_id. Use only 1 type and
        /// try again.
        GclidDateTimePairAndOrderIdBothSet = 20,
        /// Conversion already has enhancements with the same Order ID and conversion
        /// action. Make sure your data is correctly configured and try again.
        ConversionAlreadyEnhanced = 21,
        /// Multiple enhancements have the same conversion action and Order ID.  Make
        /// sure your data is correctly configured and try again.
        DuplicateEnhancementInRequest = 22,
        /// Enhanced conversions can't be used for this account because of Google
        /// customer data policies. Contact your Google representative.
        CustomerDataPolicyProhibitsEnhancement = 23,
        /// Adjustment for website conversion requires Order ID (ie, transaction ID).
        /// Make sure your website tags capture Order IDs and you send the same Order
        /// IDs with your adjustment.
        MissingOrderIdForWebpage = 24,
        /// Can't use adjustment with Order IDs containing personally-identifiable
        /// information (PII).
        OrderIdContainsPii = 25,
        /// The provided job id in the request is not within the allowed range. A job
        /// ID must be a positive integer in the range [1, 2^31).
        InvalidJobId = 26,
        /// The conversion action specified in the adjustment request cannot be
        /// found. Make sure it's available in this account.
        NoConversionActionFound = 27,
        /// The type of the conversion action specified in the adjustment request
        /// isn't supported for uploading adjustments. A conversion adjustment of
        /// type `RETRACTION` or `RESTATEMENT` is only permitted for conversion
        /// actions of type `SALESFORCE`, `UPLOAD_CLICK` or `WEBPAGE`. A conversion
        /// adjustment of type `ENHANCEMENT` is only permitted for conversion
        /// actions of type `WEBPAGE`.
        InvalidConversionActionType = 28,
    }
    impl ConversionAdjustmentUploadError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::TooRecentConversionAction => "TOO_RECENT_CONVERSION_ACTION",
                Self::ConversionAlreadyRetracted => "CONVERSION_ALREADY_RETRACTED",
                Self::ConversionNotFound => "CONVERSION_NOT_FOUND",
                Self::ConversionExpired => "CONVERSION_EXPIRED",
                Self::AdjustmentPrecedesConversion => "ADJUSTMENT_PRECEDES_CONVERSION",
                Self::MoreRecentRestatementFound => "MORE_RECENT_RESTATEMENT_FOUND",
                Self::TooRecentConversion => "TOO_RECENT_CONVERSION",
                Self::CannotRestateConversionActionThatAlwaysUsesDefaultConversionValue => {
                    "CANNOT_RESTATE_CONVERSION_ACTION_THAT_ALWAYS_USES_DEFAULT_CONVERSION_VALUE"
                }
                Self::TooManyAdjustmentsInRequest => "TOO_MANY_ADJUSTMENTS_IN_REQUEST",
                Self::TooManyAdjustments => "TOO_MANY_ADJUSTMENTS",
                Self::RestatementAlreadyExists => "RESTATEMENT_ALREADY_EXISTS",
                Self::DuplicateAdjustmentInRequest => "DUPLICATE_ADJUSTMENT_IN_REQUEST",
                Self::CustomerNotAcceptedCustomerDataTerms => {
                    "CUSTOMER_NOT_ACCEPTED_CUSTOMER_DATA_TERMS"
                }
                Self::ConversionActionNotEligibleForEnhancement => {
                    "CONVERSION_ACTION_NOT_ELIGIBLE_FOR_ENHANCEMENT"
                }
                Self::InvalidUserIdentifier => "INVALID_USER_IDENTIFIER",
                Self::UnsupportedUserIdentifier => "UNSUPPORTED_USER_IDENTIFIER",
                Self::GclidDateTimePairAndOrderIdBothSet => {
                    "GCLID_DATE_TIME_PAIR_AND_ORDER_ID_BOTH_SET"
                }
                Self::ConversionAlreadyEnhanced => "CONVERSION_ALREADY_ENHANCED",
                Self::DuplicateEnhancementInRequest => "DUPLICATE_ENHANCEMENT_IN_REQUEST",
                Self::CustomerDataPolicyProhibitsEnhancement => {
                    "CUSTOMER_DATA_POLICY_PROHIBITS_ENHANCEMENT"
                }
                Self::MissingOrderIdForWebpage => "MISSING_ORDER_ID_FOR_WEBPAGE",
                Self::OrderIdContainsPii => "ORDER_ID_CONTAINS_PII",
                Self::InvalidJobId => "INVALID_JOB_ID",
                Self::NoConversionActionFound => "NO_CONVERSION_ACTION_FOUND",
                Self::InvalidConversionActionType => "INVALID_CONVERSION_ACTION_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TOO_RECENT_CONVERSION_ACTION" => Some(Self::TooRecentConversionAction),
                "CONVERSION_ALREADY_RETRACTED" => Some(Self::ConversionAlreadyRetracted),
                "CONVERSION_NOT_FOUND" => Some(Self::ConversionNotFound),
                "CONVERSION_EXPIRED" => Some(Self::ConversionExpired),
                "ADJUSTMENT_PRECEDES_CONVERSION" => {
                    Some(Self::AdjustmentPrecedesConversion)
                }
                "MORE_RECENT_RESTATEMENT_FOUND" => Some(Self::MoreRecentRestatementFound),
                "TOO_RECENT_CONVERSION" => Some(Self::TooRecentConversion),
                "CANNOT_RESTATE_CONVERSION_ACTION_THAT_ALWAYS_USES_DEFAULT_CONVERSION_VALUE" => {
                    Some(
                        Self::CannotRestateConversionActionThatAlwaysUsesDefaultConversionValue,
                    )
                }
                "TOO_MANY_ADJUSTMENTS_IN_REQUEST" => {
                    Some(Self::TooManyAdjustmentsInRequest)
                }
                "TOO_MANY_ADJUSTMENTS" => Some(Self::TooManyAdjustments),
                "RESTATEMENT_ALREADY_EXISTS" => Some(Self::RestatementAlreadyExists),
                "DUPLICATE_ADJUSTMENT_IN_REQUEST" => {
                    Some(Self::DuplicateAdjustmentInRequest)
                }
                "CUSTOMER_NOT_ACCEPTED_CUSTOMER_DATA_TERMS" => {
                    Some(Self::CustomerNotAcceptedCustomerDataTerms)
                }
                "CONVERSION_ACTION_NOT_ELIGIBLE_FOR_ENHANCEMENT" => {
                    Some(Self::ConversionActionNotEligibleForEnhancement)
                }
                "INVALID_USER_IDENTIFIER" => Some(Self::InvalidUserIdentifier),
                "UNSUPPORTED_USER_IDENTIFIER" => Some(Self::UnsupportedUserIdentifier),
                "GCLID_DATE_TIME_PAIR_AND_ORDER_ID_BOTH_SET" => {
                    Some(Self::GclidDateTimePairAndOrderIdBothSet)
                }
                "CONVERSION_ALREADY_ENHANCED" => Some(Self::ConversionAlreadyEnhanced),
                "DUPLICATE_ENHANCEMENT_IN_REQUEST" => {
                    Some(Self::DuplicateEnhancementInRequest)
                }
                "CUSTOMER_DATA_POLICY_PROHIBITS_ENHANCEMENT" => {
                    Some(Self::CustomerDataPolicyProhibitsEnhancement)
                }
                "MISSING_ORDER_ID_FOR_WEBPAGE" => Some(Self::MissingOrderIdForWebpage),
                "ORDER_ID_CONTAINS_PII" => Some(Self::OrderIdContainsPii),
                "INVALID_JOB_ID" => Some(Self::InvalidJobId),
                "NO_CONVERSION_ACTION_FOUND" => Some(Self::NoConversionActionFound),
                "INVALID_CONVERSION_ACTION_TYPE" => {
                    Some(Self::InvalidConversionActionType)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible conversion custom variable errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionCustomVariableErrorEnum {}
/// Nested message and enum types in `ConversionCustomVariableErrorEnum`.
pub mod conversion_custom_variable_error_enum {
    /// Enum describing possible conversion custom variable errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionCustomVariableError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// A conversion custom variable with the specified name already exists.
        DuplicateName = 2,
        /// A conversion custom variable with the specified tag already exists.
        DuplicateTag = 3,
        /// A conversion custom variable with the specified tag is reserved for other
        /// uses.
        ReservedTag = 4,
    }
    impl ConversionCustomVariableError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DuplicateName => "DUPLICATE_NAME",
                Self::DuplicateTag => "DUPLICATE_TAG",
                Self::ReservedTag => "RESERVED_TAG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "DUPLICATE_TAG" => Some(Self::DuplicateTag),
                "RESERVED_TAG" => Some(Self::ReservedTag),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible conversion goal campaign config
/// errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionGoalCampaignConfigErrorEnum {}
/// Nested message and enum types in `ConversionGoalCampaignConfigErrorEnum`.
pub mod conversion_goal_campaign_config_error_enum {
    /// Enum describing possible conversion goal campaign config errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionGoalCampaignConfigError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Campaign is managed by Search Ads 360 but uses Unified Goal.
        CannotUseCampaignGoalForSearchAds360ManagedCampaign = 2,
        /// The campaign is using a custom goal that does not belong to its Google
        /// Ads conversion customer (conversion tracking customer).
        CustomGoalDoesNotBelongToGoogleAdsConversionCustomer = 3,
        /// The campaign is not allowed to use unified goals.
        CampaignCannotUseUnifiedGoals = 4,
        /// The campaign is using campaign override goals but has no goals
        /// configured.
        EmptyConversionGoals = 5,
        /// STORE_SALE and STORE_VISIT conversion types cannot be both included in
        /// campaign level goal.
        StoreSaleStoreVisitCannotBeBothIncluded = 6,
        /// Performance Max campaign is not allowed to use custom goal with store
        /// sales conversion type.
        PerformanceMaxCampaignCannotUseCustomGoalWithStoreSales = 7,
    }
    impl ConversionGoalCampaignConfigError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CannotUseCampaignGoalForSearchAds360ManagedCampaign => {
                    "CANNOT_USE_CAMPAIGN_GOAL_FOR_SEARCH_ADS_360_MANAGED_CAMPAIGN"
                }
                Self::CustomGoalDoesNotBelongToGoogleAdsConversionCustomer => {
                    "CUSTOM_GOAL_DOES_NOT_BELONG_TO_GOOGLE_ADS_CONVERSION_CUSTOMER"
                }
                Self::CampaignCannotUseUnifiedGoals => {
                    "CAMPAIGN_CANNOT_USE_UNIFIED_GOALS"
                }
                Self::EmptyConversionGoals => "EMPTY_CONVERSION_GOALS",
                Self::StoreSaleStoreVisitCannotBeBothIncluded => {
                    "STORE_SALE_STORE_VISIT_CANNOT_BE_BOTH_INCLUDED"
                }
                Self::PerformanceMaxCampaignCannotUseCustomGoalWithStoreSales => {
                    "PERFORMANCE_MAX_CAMPAIGN_CANNOT_USE_CUSTOM_GOAL_WITH_STORE_SALES"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_USE_CAMPAIGN_GOAL_FOR_SEARCH_ADS_360_MANAGED_CAMPAIGN" => {
                    Some(Self::CannotUseCampaignGoalForSearchAds360ManagedCampaign)
                }
                "CUSTOM_GOAL_DOES_NOT_BELONG_TO_GOOGLE_ADS_CONVERSION_CUSTOMER" => {
                    Some(Self::CustomGoalDoesNotBelongToGoogleAdsConversionCustomer)
                }
                "CAMPAIGN_CANNOT_USE_UNIFIED_GOALS" => {
                    Some(Self::CampaignCannotUseUnifiedGoals)
                }
                "EMPTY_CONVERSION_GOALS" => Some(Self::EmptyConversionGoals),
                "STORE_SALE_STORE_VISIT_CANNOT_BE_BOTH_INCLUDED" => {
                    Some(Self::StoreSaleStoreVisitCannotBeBothIncluded)
                }
                "PERFORMANCE_MAX_CAMPAIGN_CANNOT_USE_CUSTOM_GOAL_WITH_STORE_SALES" => {
                    Some(Self::PerformanceMaxCampaignCannotUseCustomGoalWithStoreSales)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible conversion upload errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionUploadErrorEnum {}
/// Nested message and enum types in `ConversionUploadErrorEnum`.
pub mod conversion_upload_error_enum {
    /// Enum describing possible conversion upload errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionUploadError {
        /// Enum unspecified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Upload fewer than 2001 events in a single request.
        TooManyConversionsInRequest = 2,
        /// The imported gclid could not be decoded. Make sure you have not modified
        /// the click IDs.
        UnparseableGclid = 3,
        /// The imported event has a `conversion_date_time` that precedes the click.
        /// Make sure your `conversion_date_time` is correct and try again.
        ConversionPrecedesEvent = 42,
        /// The imported event can't be recorded because its click occurred before
        /// this conversion's click-through window. Make sure you import the most
        /// recent data.
        ExpiredEvent = 43,
        /// The click associated with the given identifier or iOS URL parameter
        /// occurred less than 6 hours ago. Retry after 6 hours have passed.
        TooRecentEvent = 44,
        /// The imported event could not be attributed to a click. This may be
        /// because the event did not come from a Google Ads campaign.
        EventNotFound = 45,
        /// The click ID or call is associated with an Ads account you don't have
        /// access to. Make sure you import conversions for accounts managed by your
        /// manager account.
        UnauthorizedCustomer = 8,
        /// Can't import events to a conversion action that was just created. Try
        /// importing again in 6 hours.
        TooRecentConversionAction = 10,
        /// At the time of the click, conversion tracking was not enabled in the
        /// effective conversion account of the click's Google Ads account.
        ConversionTrackingNotEnabledAtImpressionTime = 11,
        /// The imported event includes external attribution data, but the conversion
        /// action isn't set up to use an external attribution model. Make sure the
        /// conversion action is correctly configured and try again.
        ExternalAttributionDataSetForNonExternallyAttributedConversionAction = 12,
        /// The conversion action is set up to use an external attribution model, but
        /// the imported event is missing data. Make sure imported events include the
        /// external attribution credit and all necessary fields.
        ExternalAttributionDataNotSetForExternallyAttributedConversionAction = 13,
        /// Order IDs can't be used for a conversion measured with an external
        /// attribution model. Make sure the conversion is correctly configured and
        /// imported events include only necessary data and try again.
        OrderIdNotPermittedForExternallyAttributedConversionAction = 14,
        /// The imported event includes an order ID that was previously recorded, so
        /// the event was not processed.
        OrderIdAlreadyInUse = 15,
        /// Imported events include multiple conversions with the same order ID and
        /// were not processed.  Make sure order IDs are unique and try again.
        DuplicateOrderId = 16,
        /// Can't import calls that occurred less than 6 hours ago. Try uploading
        /// again in 6 hours.
        TooRecentCall = 17,
        /// The call can't be recorded because it occurred before this conversion
        /// action's lookback window. Make sure your import is configured to get the
        /// most recent data.
        ExpiredCall = 18,
        /// The call or click leading to the imported event can't be found. Make sure
        /// your data source is set up to include correct identifiers.
        CallNotFound = 19,
        /// The call has a `conversion_date_time` that precedes the associated click.
        /// Make sure your `conversion_date_time` is correct.
        ConversionPrecedesCall = 20,
        /// At the time of the imported call, conversion tracking was not enabled in
        /// the effective conversion account of the click's Google Ads account.
        ConversionTrackingNotEnabledAtCallTime = 21,
        /// Make sure phone numbers are formatted as E.164 (+16502531234),
        /// International (+64 3-331 6005), or US national number (6502531234).
        UnparseableCallersPhoneNumber = 22,
        /// The imported event has the same click and `conversion_date_time` as an
        /// existing conversion. Use a unique `conversion_date_time` or order ID for
        /// each unique event and try again.
        ClickConversionAlreadyExists = 23,
        /// The imported call has the same `conversion_date_time` as an existing
        /// conversion. Make sure your `conversion_date_time` correctly configured
        /// and try again.
        CallConversionAlreadyExists = 24,
        /// Multiple events have the same click and `conversion_date_time`. Make sure
        /// your `conversion_date_time` is correctly configured and try again.
        DuplicateClickConversionInRequest = 25,
        /// Multiple events have the same call and `conversion_date_time`. Make sure
        /// your `conversion_date_time` is correctly configured and try again.
        DuplicateCallConversionInRequest = 26,
        /// Enable the custom variable in your conversion settings and try again.
        CustomVariableNotEnabled = 28,
        /// Can't import events with custom variables containing
        /// personally-identifiable information (PII). Remove these variables and try
        /// again.
        CustomVariableValueContainsPii = 29,
        /// The click from the imported event is associated with a different Google
        /// Ads account. Make sure you're importing to the correct account.
        InvalidCustomerForClick = 30,
        /// The click from the call is associated with a different Google Ads
        /// account. Make sure you're importing to the correct account. Query
        /// conversion_tracking_setting.google_ads_conversion_customer on Customer to
        /// identify the correct account.
        InvalidCustomerForCall = 31,
        /// The connversion can't be imported because the conversion source didn't
        /// comply with Apple App Transparency Tracking (ATT) policies or because the
        /// customer didn't consent to tracking.
        ConversionNotCompliantWithAttPolicy = 32,
        /// The email address or phone number for this event can't be matched to a
        /// click. This may be because it didn't come from a Google Ads campaign, and
        /// you can safely ignore this warning. If this includes more imported events
        /// than is expected, you may need to check your setup.
        ClickNotFound = 33,
        /// Make sure you hash user provided data using SHA-256 and ensure you are
        /// normalizing according to the guidelines.
        InvalidUserIdentifier = 34,
        /// User provided data can't be used with external attribution models. Use a
        /// different attribution model or omit user identifiers and try again.
        ExternallyAttributedConversionActionNotPermittedWithUserIdentifier = 35,
        /// The provided user identifiers are not supported. Use only hashed email
        /// or phone number and try again.
        UnsupportedUserIdentifier = 36,
        /// Can't use both gbraid and wbraid parameters. Use only 1 and try again.
        GbraidWbraidBothSet = 38,
        /// Can't parse event import data. Check if your wbraid parameter was
        /// not modified and try again.
        UnparseableWbraid = 39,
        /// Can't parse event import data. Check if your gbraid parameter was
        /// not modified and try again.
        UnparseableGbraid = 40,
        /// Conversion actions that use one-per-click counting can't be used with
        /// gbraid or wbraid parameters.
        OnePerClickConversionActionNotPermittedWithBraid = 46,
        /// Enhanced conversions can't be used for this account because of Google
        /// customer data policies. Contact your Google representative.
        CustomerDataPolicyProhibitsEnhancedConversions = 47,
        /// Make sure you agree to the customer data processing terms in conversion
        /// settings and try again. You can check your setting by querying
        /// conversion_tracking_setting.accepted_customer_data_terms on Customer.
        CustomerNotAcceptedCustomerDataTerms = 48,
        /// Can't import events with order IDs containing personally-identifiable
        /// information (PII).
        OrderIdContainsPii = 49,
        /// Make sure you've turned on enhanced conversions for leads in conversion
        /// settings and try again. You can check your setting by querying
        /// conversion_tracking_setting.enhanced_conversions_for_leads_enabled on
        /// Customer.
        CustomerNotEnabledEnhancedConversionsForLeads = 50,
        /// The provided job id in the request is not within the allowed range. A job
        /// ID must be a positive integer in the range [1, 2^31).
        InvalidJobId = 52,
        /// The conversion action specified in the upload request cannot be found.
        /// Make sure it's available in this account.
        NoConversionActionFound = 53,
        /// The conversion action specified in the upload request isn't set up for
        /// uploading conversions.
        InvalidConversionActionType = 54,
    }
    impl ConversionUploadError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::TooManyConversionsInRequest => "TOO_MANY_CONVERSIONS_IN_REQUEST",
                Self::UnparseableGclid => "UNPARSEABLE_GCLID",
                Self::ConversionPrecedesEvent => "CONVERSION_PRECEDES_EVENT",
                Self::ExpiredEvent => "EXPIRED_EVENT",
                Self::TooRecentEvent => "TOO_RECENT_EVENT",
                Self::EventNotFound => "EVENT_NOT_FOUND",
                Self::UnauthorizedCustomer => "UNAUTHORIZED_CUSTOMER",
                Self::TooRecentConversionAction => "TOO_RECENT_CONVERSION_ACTION",
                Self::ConversionTrackingNotEnabledAtImpressionTime => {
                    "CONVERSION_TRACKING_NOT_ENABLED_AT_IMPRESSION_TIME"
                }
                Self::ExternalAttributionDataSetForNonExternallyAttributedConversionAction => {
                    "EXTERNAL_ATTRIBUTION_DATA_SET_FOR_NON_EXTERNALLY_ATTRIBUTED_CONVERSION_ACTION"
                }
                Self::ExternalAttributionDataNotSetForExternallyAttributedConversionAction => {
                    "EXTERNAL_ATTRIBUTION_DATA_NOT_SET_FOR_EXTERNALLY_ATTRIBUTED_CONVERSION_ACTION"
                }
                Self::OrderIdNotPermittedForExternallyAttributedConversionAction => {
                    "ORDER_ID_NOT_PERMITTED_FOR_EXTERNALLY_ATTRIBUTED_CONVERSION_ACTION"
                }
                Self::OrderIdAlreadyInUse => "ORDER_ID_ALREADY_IN_USE",
                Self::DuplicateOrderId => "DUPLICATE_ORDER_ID",
                Self::TooRecentCall => "TOO_RECENT_CALL",
                Self::ExpiredCall => "EXPIRED_CALL",
                Self::CallNotFound => "CALL_NOT_FOUND",
                Self::ConversionPrecedesCall => "CONVERSION_PRECEDES_CALL",
                Self::ConversionTrackingNotEnabledAtCallTime => {
                    "CONVERSION_TRACKING_NOT_ENABLED_AT_CALL_TIME"
                }
                Self::UnparseableCallersPhoneNumber => "UNPARSEABLE_CALLERS_PHONE_NUMBER",
                Self::ClickConversionAlreadyExists => "CLICK_CONVERSION_ALREADY_EXISTS",
                Self::CallConversionAlreadyExists => "CALL_CONVERSION_ALREADY_EXISTS",
                Self::DuplicateClickConversionInRequest => {
                    "DUPLICATE_CLICK_CONVERSION_IN_REQUEST"
                }
                Self::DuplicateCallConversionInRequest => {
                    "DUPLICATE_CALL_CONVERSION_IN_REQUEST"
                }
                Self::CustomVariableNotEnabled => "CUSTOM_VARIABLE_NOT_ENABLED",
                Self::CustomVariableValueContainsPii => {
                    "CUSTOM_VARIABLE_VALUE_CONTAINS_PII"
                }
                Self::InvalidCustomerForClick => "INVALID_CUSTOMER_FOR_CLICK",
                Self::InvalidCustomerForCall => "INVALID_CUSTOMER_FOR_CALL",
                Self::ConversionNotCompliantWithAttPolicy => {
                    "CONVERSION_NOT_COMPLIANT_WITH_ATT_POLICY"
                }
                Self::ClickNotFound => "CLICK_NOT_FOUND",
                Self::InvalidUserIdentifier => "INVALID_USER_IDENTIFIER",
                Self::ExternallyAttributedConversionActionNotPermittedWithUserIdentifier => {
                    "EXTERNALLY_ATTRIBUTED_CONVERSION_ACTION_NOT_PERMITTED_WITH_USER_IDENTIFIER"
                }
                Self::UnsupportedUserIdentifier => "UNSUPPORTED_USER_IDENTIFIER",
                Self::GbraidWbraidBothSet => "GBRAID_WBRAID_BOTH_SET",
                Self::UnparseableWbraid => "UNPARSEABLE_WBRAID",
                Self::UnparseableGbraid => "UNPARSEABLE_GBRAID",
                Self::OnePerClickConversionActionNotPermittedWithBraid => {
                    "ONE_PER_CLICK_CONVERSION_ACTION_NOT_PERMITTED_WITH_BRAID"
                }
                Self::CustomerDataPolicyProhibitsEnhancedConversions => {
                    "CUSTOMER_DATA_POLICY_PROHIBITS_ENHANCED_CONVERSIONS"
                }
                Self::CustomerNotAcceptedCustomerDataTerms => {
                    "CUSTOMER_NOT_ACCEPTED_CUSTOMER_DATA_TERMS"
                }
                Self::OrderIdContainsPii => "ORDER_ID_CONTAINS_PII",
                Self::CustomerNotEnabledEnhancedConversionsForLeads => {
                    "CUSTOMER_NOT_ENABLED_ENHANCED_CONVERSIONS_FOR_LEADS"
                }
                Self::InvalidJobId => "INVALID_JOB_ID",
                Self::NoConversionActionFound => "NO_CONVERSION_ACTION_FOUND",
                Self::InvalidConversionActionType => "INVALID_CONVERSION_ACTION_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TOO_MANY_CONVERSIONS_IN_REQUEST" => {
                    Some(Self::TooManyConversionsInRequest)
                }
                "UNPARSEABLE_GCLID" => Some(Self::UnparseableGclid),
                "CONVERSION_PRECEDES_EVENT" => Some(Self::ConversionPrecedesEvent),
                "EXPIRED_EVENT" => Some(Self::ExpiredEvent),
                "TOO_RECENT_EVENT" => Some(Self::TooRecentEvent),
                "EVENT_NOT_FOUND" => Some(Self::EventNotFound),
                "UNAUTHORIZED_CUSTOMER" => Some(Self::UnauthorizedCustomer),
                "TOO_RECENT_CONVERSION_ACTION" => Some(Self::TooRecentConversionAction),
                "CONVERSION_TRACKING_NOT_ENABLED_AT_IMPRESSION_TIME" => {
                    Some(Self::ConversionTrackingNotEnabledAtImpressionTime)
                }
                "EXTERNAL_ATTRIBUTION_DATA_SET_FOR_NON_EXTERNALLY_ATTRIBUTED_CONVERSION_ACTION" => {
                    Some(
                        Self::ExternalAttributionDataSetForNonExternallyAttributedConversionAction,
                    )
                }
                "EXTERNAL_ATTRIBUTION_DATA_NOT_SET_FOR_EXTERNALLY_ATTRIBUTED_CONVERSION_ACTION" => {
                    Some(
                        Self::ExternalAttributionDataNotSetForExternallyAttributedConversionAction,
                    )
                }
                "ORDER_ID_NOT_PERMITTED_FOR_EXTERNALLY_ATTRIBUTED_CONVERSION_ACTION" => {
                    Some(
                        Self::OrderIdNotPermittedForExternallyAttributedConversionAction,
                    )
                }
                "ORDER_ID_ALREADY_IN_USE" => Some(Self::OrderIdAlreadyInUse),
                "DUPLICATE_ORDER_ID" => Some(Self::DuplicateOrderId),
                "TOO_RECENT_CALL" => Some(Self::TooRecentCall),
                "EXPIRED_CALL" => Some(Self::ExpiredCall),
                "CALL_NOT_FOUND" => Some(Self::CallNotFound),
                "CONVERSION_PRECEDES_CALL" => Some(Self::ConversionPrecedesCall),
                "CONVERSION_TRACKING_NOT_ENABLED_AT_CALL_TIME" => {
                    Some(Self::ConversionTrackingNotEnabledAtCallTime)
                }
                "UNPARSEABLE_CALLERS_PHONE_NUMBER" => {
                    Some(Self::UnparseableCallersPhoneNumber)
                }
                "CLICK_CONVERSION_ALREADY_EXISTS" => {
                    Some(Self::ClickConversionAlreadyExists)
                }
                "CALL_CONVERSION_ALREADY_EXISTS" => {
                    Some(Self::CallConversionAlreadyExists)
                }
                "DUPLICATE_CLICK_CONVERSION_IN_REQUEST" => {
                    Some(Self::DuplicateClickConversionInRequest)
                }
                "DUPLICATE_CALL_CONVERSION_IN_REQUEST" => {
                    Some(Self::DuplicateCallConversionInRequest)
                }
                "CUSTOM_VARIABLE_NOT_ENABLED" => Some(Self::CustomVariableNotEnabled),
                "CUSTOM_VARIABLE_VALUE_CONTAINS_PII" => {
                    Some(Self::CustomVariableValueContainsPii)
                }
                "INVALID_CUSTOMER_FOR_CLICK" => Some(Self::InvalidCustomerForClick),
                "INVALID_CUSTOMER_FOR_CALL" => Some(Self::InvalidCustomerForCall),
                "CONVERSION_NOT_COMPLIANT_WITH_ATT_POLICY" => {
                    Some(Self::ConversionNotCompliantWithAttPolicy)
                }
                "CLICK_NOT_FOUND" => Some(Self::ClickNotFound),
                "INVALID_USER_IDENTIFIER" => Some(Self::InvalidUserIdentifier),
                "EXTERNALLY_ATTRIBUTED_CONVERSION_ACTION_NOT_PERMITTED_WITH_USER_IDENTIFIER" => {
                    Some(
                        Self::ExternallyAttributedConversionActionNotPermittedWithUserIdentifier,
                    )
                }
                "UNSUPPORTED_USER_IDENTIFIER" => Some(Self::UnsupportedUserIdentifier),
                "GBRAID_WBRAID_BOTH_SET" => Some(Self::GbraidWbraidBothSet),
                "UNPARSEABLE_WBRAID" => Some(Self::UnparseableWbraid),
                "UNPARSEABLE_GBRAID" => Some(Self::UnparseableGbraid),
                "ONE_PER_CLICK_CONVERSION_ACTION_NOT_PERMITTED_WITH_BRAID" => {
                    Some(Self::OnePerClickConversionActionNotPermittedWithBraid)
                }
                "CUSTOMER_DATA_POLICY_PROHIBITS_ENHANCED_CONVERSIONS" => {
                    Some(Self::CustomerDataPolicyProhibitsEnhancedConversions)
                }
                "CUSTOMER_NOT_ACCEPTED_CUSTOMER_DATA_TERMS" => {
                    Some(Self::CustomerNotAcceptedCustomerDataTerms)
                }
                "ORDER_ID_CONTAINS_PII" => Some(Self::OrderIdContainsPii),
                "CUSTOMER_NOT_ENABLED_ENHANCED_CONVERSIONS_FOR_LEADS" => {
                    Some(Self::CustomerNotEnabledEnhancedConversionsForLeads)
                }
                "INVALID_JOB_ID" => Some(Self::InvalidJobId),
                "NO_CONVERSION_ACTION_FOUND" => Some(Self::NoConversionActionFound),
                "INVALID_CONVERSION_ACTION_TYPE" => {
                    Some(Self::InvalidConversionActionType)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible conversion value rule errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionValueRuleErrorEnum {}
/// Nested message and enum types in `ConversionValueRuleErrorEnum`.
pub mod conversion_value_rule_error_enum {
    /// Enum describing possible conversion value rule errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionValueRuleError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The value rule's geo location condition contains invalid geo target
        /// constant(s), for example, there's no matching geo target.
        InvalidGeoTargetConstant = 2,
        /// The value rule's geo location condition contains conflicting included and
        /// excluded geo targets. Specifically, some of the excluded geo target(s)
        /// are the same as or contain some of the included geo target(s). For
        /// example, the geo location condition includes California but excludes U.S.
        ConflictingIncludedAndExcludedGeoTarget = 3,
        /// User specified conflicting conditions for two value rules in the same
        /// value rule set.
        ConflictingConditions = 4,
        /// The value rule cannot be removed because it's still included in some
        /// value rule set.
        CannotRemoveIfIncludedInValueRuleSet = 5,
        /// The value rule contains a condition that's not allowed by the value rule
        /// set including this value rule.
        ConditionNotAllowed = 6,
        /// The value rule contains a field that should be unset.
        FieldMustBeUnset = 7,
        /// Pausing the value rule requires pausing the value rule set because the
        /// value rule is (one of) the last enabled in the value rule set.
        CannotPauseUnlessValueRuleSetIsPaused = 8,
        /// The value rule's geo location condition contains untargetable geo target
        /// constant(s).
        UntargetableGeoTarget = 9,
        /// The value rule's audience condition contains invalid user list(s). In
        /// another word, there's no matching user list.
        InvalidAudienceUserList = 10,
        /// The value rule's audience condition contains inaccessible user list(s).
        InaccessibleUserList = 11,
        /// The value rule's audience condition contains invalid user_interest(s).
        /// This might be because there is no matching user interest, or the user
        /// interest is not visible.
        InvalidAudienceUserInterest = 12,
        /// When a value rule is created, it shouldn't have REMOVED status.
        CannotAddRuleWithStatusRemoved = 13,
    }
    impl ConversionValueRuleError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidGeoTargetConstant => "INVALID_GEO_TARGET_CONSTANT",
                Self::ConflictingIncludedAndExcludedGeoTarget => {
                    "CONFLICTING_INCLUDED_AND_EXCLUDED_GEO_TARGET"
                }
                Self::ConflictingConditions => "CONFLICTING_CONDITIONS",
                Self::CannotRemoveIfIncludedInValueRuleSet => {
                    "CANNOT_REMOVE_IF_INCLUDED_IN_VALUE_RULE_SET"
                }
                Self::ConditionNotAllowed => "CONDITION_NOT_ALLOWED",
                Self::FieldMustBeUnset => "FIELD_MUST_BE_UNSET",
                Self::CannotPauseUnlessValueRuleSetIsPaused => {
                    "CANNOT_PAUSE_UNLESS_VALUE_RULE_SET_IS_PAUSED"
                }
                Self::UntargetableGeoTarget => "UNTARGETABLE_GEO_TARGET",
                Self::InvalidAudienceUserList => "INVALID_AUDIENCE_USER_LIST",
                Self::InaccessibleUserList => "INACCESSIBLE_USER_LIST",
                Self::InvalidAudienceUserInterest => "INVALID_AUDIENCE_USER_INTEREST",
                Self::CannotAddRuleWithStatusRemoved => {
                    "CANNOT_ADD_RULE_WITH_STATUS_REMOVED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_GEO_TARGET_CONSTANT" => Some(Self::InvalidGeoTargetConstant),
                "CONFLICTING_INCLUDED_AND_EXCLUDED_GEO_TARGET" => {
                    Some(Self::ConflictingIncludedAndExcludedGeoTarget)
                }
                "CONFLICTING_CONDITIONS" => Some(Self::ConflictingConditions),
                "CANNOT_REMOVE_IF_INCLUDED_IN_VALUE_RULE_SET" => {
                    Some(Self::CannotRemoveIfIncludedInValueRuleSet)
                }
                "CONDITION_NOT_ALLOWED" => Some(Self::ConditionNotAllowed),
                "FIELD_MUST_BE_UNSET" => Some(Self::FieldMustBeUnset),
                "CANNOT_PAUSE_UNLESS_VALUE_RULE_SET_IS_PAUSED" => {
                    Some(Self::CannotPauseUnlessValueRuleSetIsPaused)
                }
                "UNTARGETABLE_GEO_TARGET" => Some(Self::UntargetableGeoTarget),
                "INVALID_AUDIENCE_USER_LIST" => Some(Self::InvalidAudienceUserList),
                "INACCESSIBLE_USER_LIST" => Some(Self::InaccessibleUserList),
                "INVALID_AUDIENCE_USER_INTEREST" => {
                    Some(Self::InvalidAudienceUserInterest)
                }
                "CANNOT_ADD_RULE_WITH_STATUS_REMOVED" => {
                    Some(Self::CannotAddRuleWithStatusRemoved)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible conversion value rule set errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionValueRuleSetErrorEnum {}
/// Nested message and enum types in `ConversionValueRuleSetErrorEnum`.
pub mod conversion_value_rule_set_error_enum {
    /// Enum describing possible conversion value rule set errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionValueRuleSetError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Two value rules in this value rule set contain conflicting conditions.
        ConflictingValueRuleConditions = 2,
        /// This value rule set includes a value rule that cannot be found, has been
        /// permanently removed or belongs to a different customer.
        InvalidValueRule = 3,
        /// An error that's thrown when a mutate operation is trying to
        /// replace/remove some existing elements in the dimensions field. In other
        /// words, ADD op is always fine and UPDATE op is fine if it's only appending
        /// new elements into dimensions list.
        DimensionsUpdateOnlyAllowAppend = 4,
        /// An error that's thrown when a mutate is adding new value rule(s) into a
        /// value rule set and the added value rule(s) include conditions that are
        /// not specified in the dimensions of the value rule set.
        ConditionTypeNotAllowed = 5,
        /// The dimensions field contains duplicate elements.
        DuplicateDimensions = 6,
        /// This value rule set is attached to an invalid campaign id. Either a
        /// campaign with this campaign id doesn't exist or it belongs to a different
        /// customer.
        InvalidCampaignId = 7,
        /// When a mutate request tries to pause a value rule set, the enabled
        /// value rules in this set must be paused in the same command, or this error
        /// will be thrown.
        CannotPauseUnlessAllValueRulesArePaused = 8,
        /// When a mutate request tries to pause all the value rules in a value rule
        /// set, the value rule set must be paused, or this error will be thrown.
        ShouldPauseWhenAllValueRulesArePaused = 9,
        /// This value rule set is attached to a campaign that does not support value
        /// rules. Currently, campaign level value rule sets can only be created on
        /// Search, or Display campaigns.
        ValueRulesNotSupportedForCampaignType = 10,
        /// To add a value rule set that applies on Store Visits/Store Sales
        /// conversion action categories, the customer must have valid Store Visits/
        /// Store Sales conversion actions.
        IneligibleConversionActionCategories = 11,
        /// If NO_CONDITION is used as a dimension of a value rule set, it must be
        /// the only dimension.
        DimensionNoConditionUsedWithOtherDimensions = 12,
        /// Dimension NO_CONDITION can only be used by Store Visits/Store Sales value
        /// rule set.
        DimensionNoConditionNotAllowed = 13,
        /// Value rule sets defined on the specified conversion action categories are
        /// not supported. The list of conversion action categories must be an empty
        /// list, only STORE_VISIT, or only STORE_SALE.
        UnsupportedConversionActionCategories = 14,
    }
    impl ConversionValueRuleSetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ConflictingValueRuleConditions => {
                    "CONFLICTING_VALUE_RULE_CONDITIONS"
                }
                Self::InvalidValueRule => "INVALID_VALUE_RULE",
                Self::DimensionsUpdateOnlyAllowAppend => {
                    "DIMENSIONS_UPDATE_ONLY_ALLOW_APPEND"
                }
                Self::ConditionTypeNotAllowed => "CONDITION_TYPE_NOT_ALLOWED",
                Self::DuplicateDimensions => "DUPLICATE_DIMENSIONS",
                Self::InvalidCampaignId => "INVALID_CAMPAIGN_ID",
                Self::CannotPauseUnlessAllValueRulesArePaused => {
                    "CANNOT_PAUSE_UNLESS_ALL_VALUE_RULES_ARE_PAUSED"
                }
                Self::ShouldPauseWhenAllValueRulesArePaused => {
                    "SHOULD_PAUSE_WHEN_ALL_VALUE_RULES_ARE_PAUSED"
                }
                Self::ValueRulesNotSupportedForCampaignType => {
                    "VALUE_RULES_NOT_SUPPORTED_FOR_CAMPAIGN_TYPE"
                }
                Self::IneligibleConversionActionCategories => {
                    "INELIGIBLE_CONVERSION_ACTION_CATEGORIES"
                }
                Self::DimensionNoConditionUsedWithOtherDimensions => {
                    "DIMENSION_NO_CONDITION_USED_WITH_OTHER_DIMENSIONS"
                }
                Self::DimensionNoConditionNotAllowed => {
                    "DIMENSION_NO_CONDITION_NOT_ALLOWED"
                }
                Self::UnsupportedConversionActionCategories => {
                    "UNSUPPORTED_CONVERSION_ACTION_CATEGORIES"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CONFLICTING_VALUE_RULE_CONDITIONS" => {
                    Some(Self::ConflictingValueRuleConditions)
                }
                "INVALID_VALUE_RULE" => Some(Self::InvalidValueRule),
                "DIMENSIONS_UPDATE_ONLY_ALLOW_APPEND" => {
                    Some(Self::DimensionsUpdateOnlyAllowAppend)
                }
                "CONDITION_TYPE_NOT_ALLOWED" => Some(Self::ConditionTypeNotAllowed),
                "DUPLICATE_DIMENSIONS" => Some(Self::DuplicateDimensions),
                "INVALID_CAMPAIGN_ID" => Some(Self::InvalidCampaignId),
                "CANNOT_PAUSE_UNLESS_ALL_VALUE_RULES_ARE_PAUSED" => {
                    Some(Self::CannotPauseUnlessAllValueRulesArePaused)
                }
                "SHOULD_PAUSE_WHEN_ALL_VALUE_RULES_ARE_PAUSED" => {
                    Some(Self::ShouldPauseWhenAllValueRulesArePaused)
                }
                "VALUE_RULES_NOT_SUPPORTED_FOR_CAMPAIGN_TYPE" => {
                    Some(Self::ValueRulesNotSupportedForCampaignType)
                }
                "INELIGIBLE_CONVERSION_ACTION_CATEGORIES" => {
                    Some(Self::IneligibleConversionActionCategories)
                }
                "DIMENSION_NO_CONDITION_USED_WITH_OTHER_DIMENSIONS" => {
                    Some(Self::DimensionNoConditionUsedWithOtherDimensions)
                }
                "DIMENSION_NO_CONDITION_NOT_ALLOWED" => {
                    Some(Self::DimensionNoConditionNotAllowed)
                }
                "UNSUPPORTED_CONVERSION_ACTION_CATEGORIES" => {
                    Some(Self::UnsupportedConversionActionCategories)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing country code errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CountryCodeErrorEnum {}
/// Nested message and enum types in `CountryCodeErrorEnum`.
pub mod country_code_error_enum {
    /// Enum describing country code errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CountryCodeError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The country code is invalid.
        InvalidCountryCode = 2,
    }
    impl CountryCodeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidCountryCode => "INVALID_COUNTRY_CODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_COUNTRY_CODE" => Some(Self::InvalidCountryCode),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible criterion errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CriterionErrorEnum {}
/// Nested message and enum types in `CriterionErrorEnum`.
pub mod criterion_error_enum {
    /// Enum describing possible criterion errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CriterionError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Concrete type of criterion is required for CREATE and UPDATE operations.
        ConcreteTypeRequired = 2,
        /// The category requested for exclusion is invalid.
        InvalidExcludedCategory = 3,
        /// Invalid keyword criteria text.
        InvalidKeywordText = 4,
        /// Keyword text should be less than 80 chars.
        KeywordTextTooLong = 5,
        /// Keyword text has too many words.
        KeywordHasTooManyWords = 6,
        /// Keyword text has invalid characters or symbols.
        KeywordHasInvalidChars = 7,
        /// Invalid placement URL.
        InvalidPlacementUrl = 8,
        /// Invalid user list criterion.
        InvalidUserList = 9,
        /// Invalid user interest criterion.
        InvalidUserInterest = 10,
        /// Placement URL has wrong format.
        InvalidFormatForPlacementUrl = 11,
        /// Placement URL is too long.
        PlacementUrlIsTooLong = 12,
        /// Indicates the URL contains an illegal character.
        PlacementUrlHasIllegalChar = 13,
        /// Indicates the URL contains multiple comma separated URLs.
        PlacementUrlHasMultipleSitesInLine = 14,
        /// Indicates the domain is blocked.
        PlacementIsNotAvailableForTargetingOrExclusion = 15,
        /// Invalid topic path.
        InvalidTopicPath = 16,
        /// The YouTube Channel Id is invalid.
        InvalidYoutubeChannelId = 17,
        /// The YouTube Video Id is invalid.
        InvalidYoutubeVideoId = 18,
        /// Indicates the placement is a YouTube vertical channel, which is no longer
        /// supported.
        YoutubeVerticalChannelDeprecated = 19,
        /// Indicates the placement is a YouTube demographic channel, which is no
        /// longer supported.
        YoutubeDemographicChannelDeprecated = 20,
        /// YouTube urls are not supported in Placement criterion. Use YouTubeChannel
        /// and YouTubeVideo criterion instead.
        YoutubeUrlUnsupported = 21,
        /// Criteria type can not be excluded by the customer, like AOL account type
        /// cannot target site type criteria.
        CannotExcludeCriteriaType = 22,
        /// Criteria type can not be targeted.
        CannotAddCriteriaType = 23,
        /// Not allowed to exclude similar user list.
        CannotExcludeSimilarUserList = 26,
        /// Not allowed to target a closed user list.
        CannotAddClosedUserList = 27,
        /// Not allowed to add display only UserLists to search only campaigns.
        CannotAddDisplayOnlyListsToSearchOnlyCampaigns = 28,
        /// Not allowed to add display only UserLists to search plus campaigns.
        CannotAddDisplayOnlyListsToSearchCampaigns = 29,
        /// Not allowed to add display only UserLists to shopping campaigns.
        CannotAddDisplayOnlyListsToShoppingCampaigns = 30,
        /// Not allowed to add User interests to search only campaigns.
        CannotAddUserInterestsToSearchCampaigns = 31,
        /// Not allowed to set bids for this criterion type in search campaigns
        CannotSetBidsOnCriterionTypeInSearchCampaigns = 32,
        /// Final URLs, URL Templates and CustomParameters cannot be set for the
        /// criterion types of Gender, AgeRange, UserList, Placement, MobileApp, and
        /// MobileAppCategory in search campaigns and shopping campaigns.
        CannotAddUrlsToCriterionTypeForCampaignType = 33,
        /// Invalid combined audience criterion.
        InvalidCombinedAudience = 122,
        /// Invalid custom affinity criterion.
        InvalidCustomAffinity = 96,
        /// Invalid custom intent criterion.
        InvalidCustomIntent = 97,
        /// Invalid custom audience criterion.
        InvalidCustomAudience = 121,
        /// IP address is not valid.
        InvalidIpAddress = 34,
        /// IP format is not valid.
        InvalidIpFormat = 35,
        /// Mobile application is not valid.
        InvalidMobileApp = 36,
        /// Mobile application category is not valid.
        InvalidMobileAppCategory = 37,
        /// The CriterionId does not exist or is of the incorrect type.
        InvalidCriterionId = 38,
        /// The Criterion is not allowed to be targeted.
        CannotTargetCriterion = 39,
        /// The criterion is not allowed to be targeted as it is deprecated.
        CannotTargetObsoleteCriterion = 40,
        /// The CriterionId is not valid for the type.
        CriterionIdAndTypeMismatch = 41,
        /// Distance for the radius for the proximity criterion is invalid.
        InvalidProximityRadius = 42,
        /// Units for the distance for the radius for the proximity criterion is
        /// invalid.
        InvalidProximityRadiusUnits = 43,
        /// Street address in the address is not valid.
        InvalidStreetaddressLength = 44,
        /// City name in the address is not valid.
        InvalidCitynameLength = 45,
        /// Region code in the address is not valid.
        InvalidRegioncodeLength = 46,
        /// Region name in the address is not valid.
        InvalidRegionnameLength = 47,
        /// Postal code in the address is not valid.
        InvalidPostalcodeLength = 48,
        /// Country code in the address is not valid.
        InvalidCountryCode = 49,
        /// Latitude for the GeoPoint is not valid.
        InvalidLatitude = 50,
        /// Longitude for the GeoPoint is not valid.
        InvalidLongitude = 51,
        /// The Proximity input is not valid. Both address and geoPoint cannot be
        /// null.
        ProximityGeopointAndAddressBothCannotBeNull = 52,
        /// The Proximity address cannot be geocoded to a valid lat/long.
        InvalidProximityAddress = 53,
        /// User domain name is not valid.
        InvalidUserDomainName = 54,
        /// Length of serialized criterion parameter exceeded size limit.
        CriterionParameterTooLong = 55,
        /// Time interval in the AdSchedule overlaps with another AdSchedule.
        AdScheduleTimeIntervalsOverlap = 56,
        /// AdSchedule time interval cannot span multiple days.
        AdScheduleIntervalCannotSpanMultipleDays = 57,
        /// AdSchedule time interval specified is invalid, endTime cannot be earlier
        /// than startTime.
        AdScheduleInvalidTimeInterval = 58,
        /// The number of AdSchedule entries in a day exceeds the limit.
        AdScheduleExceededIntervalsPerDayLimit = 59,
        /// CriteriaId does not match the interval of the AdSchedule specified.
        AdScheduleCriterionIdMismatchingFields = 60,
        /// Cannot set bid modifier for this criterion type.
        CannotBidModifyCriterionType = 61,
        /// Cannot bid modify criterion, since it is opted out of the campaign.
        CannotBidModifyCriterionCampaignOptedOut = 62,
        /// Cannot set bid modifier for a negative criterion.
        CannotBidModifyNegativeCriterion = 63,
        /// Bid Modifier already exists. Use SET operation to update.
        BidModifierAlreadyExists = 64,
        /// Feed Id is not allowed in these Location Groups.
        FeedIdNotAllowed = 65,
        /// The account may not use the requested criteria type. For example, some
        /// accounts are restricted to keywords only.
        AccountIneligibleForCriteriaType = 66,
        /// The requested criteria type cannot be used with campaign or ad group
        /// bidding strategy.
        CriteriaTypeInvalidForBiddingStrategy = 67,
        /// The Criterion is not allowed to be excluded.
        CannotExcludeCriterion = 68,
        /// The criterion is not allowed to be removed. For example, we cannot remove
        /// any of the device criterion.
        CannotRemoveCriterion = 69,
        /// Bidding categories do not form a valid path in the Shopping bidding
        /// category taxonomy.
        InvalidProductBiddingCategory = 76,
        /// ShoppingSetting must be added to the campaign before ProductScope
        /// criteria can be added.
        MissingShoppingSetting = 77,
        /// Matching function is invalid.
        InvalidMatchingFunction = 78,
        /// Filter parameters not allowed for location groups targeting.
        LocationFilterNotAllowed = 79,
        /// Feed not found, or the feed is not an enabled location feed.
        InvalidFeedForLocationFilter = 98,
        /// Given location filter parameter is invalid for location groups targeting.
        LocationFilterInvalid = 80,
        /// Cannot set geo target constants and feed item sets at the same time.
        CannotSetGeoTargetConstantsWithFeedItemSets = 123,
        /// Cannot set both assetset and feed at the same time.
        CannotSetBothAssetSetAndFeed = 140,
        /// Cannot set feed or feed item sets for Customer.
        CannotSetFeedOrFeedItemSetsForCustomer = 142,
        /// Cannot set AssetSet criteria for customer.
        CannotSetAssetSetFieldForCustomer = 150,
        /// Cannot set geo target constants and asset sets at the same time.
        CannotSetGeoTargetConstantsWithAssetSets = 143,
        /// Cannot set asset sets and feed item sets at the same time.
        CannotSetAssetSetsWithFeedItemSets = 144,
        /// The location group asset set id is invalid
        InvalidLocationGroupAssetSet = 141,
        /// The location group radius is in the range but not at the valid increment.
        InvalidLocationGroupRadius = 124,
        /// The location group radius unit is invalid.
        InvalidLocationGroupRadiusUnit = 125,
        /// Criteria type cannot be associated with a campaign and its ad group(s)
        /// simultaneously.
        CannotAttachCriteriaAtCampaignAndAdgroup = 81,
        /// Range represented by hotel length of stay's min nights and max nights
        /// overlaps with an existing criterion.
        HotelLengthOfStayOverlapsWithExistingCriterion = 82,
        /// Range represented by hotel advance booking window's min days and max days
        /// overlaps with an existing criterion.
        HotelAdvanceBookingWindowOverlapsWithExistingCriterion = 83,
        /// The field is not allowed to be set when the negative field is set to
        /// true, for example, we don't allow bids in negative ad group or campaign
        /// criteria.
        FieldIncompatibleWithNegativeTargeting = 84,
        /// The combination of operand and operator in webpage condition is invalid.
        InvalidWebpageCondition = 85,
        /// The URL of webpage condition is invalid.
        InvalidWebpageConditionUrl = 86,
        /// The URL of webpage condition cannot be empty or contain white space.
        WebpageConditionUrlCannotBeEmpty = 87,
        /// The URL of webpage condition contains an unsupported protocol.
        WebpageConditionUrlUnsupportedProtocol = 88,
        /// The URL of webpage condition cannot be an IP address.
        WebpageConditionUrlCannotBeIpAddress = 89,
        /// The domain of the URL is not consistent with the domain in campaign
        /// setting.
        WebpageConditionUrlDomainNotConsistentWithCampaignSetting = 90,
        /// The URL of webpage condition cannot be a public suffix itself.
        WebpageConditionUrlCannotBePublicSuffix = 91,
        /// The URL of webpage condition has an invalid public suffix.
        WebpageConditionUrlInvalidPublicSuffix = 92,
        /// Value track parameter is not supported in webpage condition URL.
        WebpageConditionUrlValueTrackValueNotSupported = 93,
        /// Only one URL-EQUALS webpage condition is allowed in a webpage
        /// criterion and it cannot be combined with other conditions.
        WebpageCriterionUrlEqualsCanHaveOnlyOneCondition = 94,
        /// A webpage criterion cannot be added to a non-DSA ad group.
        WebpageCriterionNotSupportedOnNonDsaAdGroup = 95,
        /// Cannot add positive user list criteria in Smart Display campaigns.
        CannotTargetUserListForSmartDisplayCampaigns = 99,
        /// Cannot add positive placement criterion types in search campaigns.
        CannotTargetPlacementsForSearchCampaigns = 126,
        /// Listing scope contains too many dimension types.
        ListingScopeTooManyDimensionTypes = 100,
        /// Listing scope has too many IN operators.
        ListingScopeTooManyInOperators = 101,
        /// Listing scope contains IN operator on an unsupported dimension type.
        ListingScopeInOperatorNotSupported = 102,
        /// There are dimensions with duplicate dimension type.
        DuplicateListingDimensionType = 103,
        /// There are dimensions with duplicate dimension value.
        DuplicateListingDimensionValue = 104,
        /// Listing group SUBDIVISION nodes cannot have bids.
        CannotSetBidsOnListingGroupSubdivision = 105,
        /// Ad group is invalid due to the listing groups it contains.
        InvalidListingGroupHierarchy = 106,
        /// Listing group unit cannot have children.
        ListingGroupUnitCannotHaveChildren = 107,
        /// Subdivided listing groups must have an "others" case.
        ListingGroupSubdivisionRequiresOthersCase = 108,
        /// Dimension type of listing group must be the same as that of its siblings.
        ListingGroupRequiresSameDimensionTypeAsSiblings = 109,
        /// Listing group cannot be added to the ad group because it already exists.
        ListingGroupAlreadyExists = 110,
        /// Listing group referenced in the operation was not found in the ad group.
        ListingGroupDoesNotExist = 111,
        /// Recursive removal failed because listing group subdivision is being
        /// created or modified in this request.
        ListingGroupCannotBeRemoved = 112,
        /// Listing group type is not allowed for specified ad group criterion type.
        InvalidListingGroupType = 113,
        /// Listing group in an ADD operation specifies a non temporary criterion id.
        ListingGroupAddMayOnlyUseTempId = 114,
        /// The combined length of dimension values of the Listing scope criterion
        /// is too long.
        ListingScopeTooLong = 115,
        /// Listing scope contains too many dimensions.
        ListingScopeTooManyDimensions = 116,
        /// The combined length of dimension values of the Listing group criterion is
        /// too long.
        ListingGroupTooLong = 117,
        /// Listing group tree is too deep.
        ListingGroupTreeTooDeep = 118,
        /// Listing dimension is invalid (for example, dimension contains illegal
        /// value, dimension type is represented with wrong class, etc). Listing
        /// dimension value can not contain "==" or "&+".
        InvalidListingDimension = 119,
        /// Listing dimension type is either invalid for campaigns of this type or
        /// cannot be used in the current context. BIDDING_CATEGORY_Lx and
        /// PRODUCT_TYPE_Lx dimensions must be used in ascending order of their
        /// levels: L1, L2, L3, L4, L5... The levels must be specified sequentially
        /// and start from L1. Furthermore, an "others" Listing group cannot be
        /// subdivided with a dimension of the same type but of a higher level
        /// ("others" BIDDING_CATEGORY_L3 can be subdivided with BRAND but not with
        /// BIDDING_CATEGORY_L4).
        InvalidListingDimensionType = 120,
        /// Customer is not on allowlist for composite audience in display campaigns.
        AdvertiserNotOnAllowlistForCombinedAudienceOnDisplay = 127,
        /// Cannot target on a removed combined audience.
        CannotTargetRemovedCombinedAudience = 128,
        /// Combined audience ID is invalid.
        InvalidCombinedAudienceId = 129,
        /// Can not target removed combined audience.
        CannotTargetRemovedCustomAudience = 130,
        /// Range represented by hotel check-in date's start date and end date
        /// overlaps with an existing criterion.
        HotelCheckInDateRangeOverlapsWithExistingCriterion = 131,
        /// Start date is earlier than earliest allowed value of yesterday UTC.
        HotelCheckInDateRangeStartDateTooEarly = 132,
        /// End date later is than latest allowed day of 330 days in the future UTC.
        HotelCheckInDateRangeEndDateTooLate = 133,
        /// Start date is after end date.
        HotelCheckInDateRangeReversed = 134,
        /// Broad match modifier (BMM) keywords can no longer be created. See
        /// <https://ads-developers.googleblog.com/2021/06/broad-match-modifier-upcoming-changes.html.>
        BroadMatchModifierKeywordNotAllowed = 135,
        /// Only one audience is allowed in an asset group.
        OneAudienceAllowedPerAssetGroup = 136,
        /// Audience is not supported for the specified campaign type.
        AudienceNotEligibleForCampaignType = 137,
        /// Audience is not allowed to attach when use_audience_grouped bit is set to
        /// false.
        AudienceNotAllowedToAttachWhenAudienceGroupedSetToFalse = 138,
        /// Targeting is not allowed for Customer Match lists as per Customer Match
        /// policy. See
        /// <https://support.google.com/google-ads/answer/6299717.>
        CannotTargetCustomerMatchUserList = 139,
        /// Cannot create a negative keyword list criterion with a shared set that
        /// does not exist.
        NegativeKeywordSharedSetDoesNotExist = 145,
        /// Cannot create a negative keyword list with deleted shared set.
        CannotAddRemovedNegativeKeywordSharedSet = 146,
        /// Can only have one Negative Keyword List per account.
        CannotHaveMultipleNegativeKeywordListPerAccount = 147,
        /// Only allowlisted customers can add criteria of this type.
        CustomerCannotAddCriterionOfThisType = 149,
        /// Targeting for Similar audiences is not supported, since this feature has
        /// been deprecated. See
        /// <https://support.google.com/google-ads/answer/12463119> to learn more.
        CannotTargetSimilarUserList = 151,
        /// Audience segment criteria cannot be added when use_audience_grouped bit
        /// is set.
        CannotAddAudienceSegmentCriterionWhenAudienceGroupedIsSet = 152,
        /// Only one audience is allowed in an ad group.
        OneAudienceAllowedPerAdGroup = 153,
        /// Invalid detailed demographics criterion.
        InvalidDetailedDemographic = 154,
        /// The brand criteria has a brand input that is not recognized as a
        /// valid brand.
        CannotRecognizeBrand = 155,
        /// The brand_list.shared_set_id references a shared set that does not
        /// exist.
        BrandSharedSetDoesNotExist = 156,
        /// Cannot create a brand list with deleted shared set.
        CannotAddRemovedBrandSharedSet = 157,
        /// Brand list can only be negatively targeted for the campaign type.
        OnlyExclusionBrandListAllowedForCampaignType = 158,
    }
    impl CriterionError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ConcreteTypeRequired => "CONCRETE_TYPE_REQUIRED",
                Self::InvalidExcludedCategory => "INVALID_EXCLUDED_CATEGORY",
                Self::InvalidKeywordText => "INVALID_KEYWORD_TEXT",
                Self::KeywordTextTooLong => "KEYWORD_TEXT_TOO_LONG",
                Self::KeywordHasTooManyWords => "KEYWORD_HAS_TOO_MANY_WORDS",
                Self::KeywordHasInvalidChars => "KEYWORD_HAS_INVALID_CHARS",
                Self::InvalidPlacementUrl => "INVALID_PLACEMENT_URL",
                Self::InvalidUserList => "INVALID_USER_LIST",
                Self::InvalidUserInterest => "INVALID_USER_INTEREST",
                Self::InvalidFormatForPlacementUrl => "INVALID_FORMAT_FOR_PLACEMENT_URL",
                Self::PlacementUrlIsTooLong => "PLACEMENT_URL_IS_TOO_LONG",
                Self::PlacementUrlHasIllegalChar => "PLACEMENT_URL_HAS_ILLEGAL_CHAR",
                Self::PlacementUrlHasMultipleSitesInLine => {
                    "PLACEMENT_URL_HAS_MULTIPLE_SITES_IN_LINE"
                }
                Self::PlacementIsNotAvailableForTargetingOrExclusion => {
                    "PLACEMENT_IS_NOT_AVAILABLE_FOR_TARGETING_OR_EXCLUSION"
                }
                Self::InvalidTopicPath => "INVALID_TOPIC_PATH",
                Self::InvalidYoutubeChannelId => "INVALID_YOUTUBE_CHANNEL_ID",
                Self::InvalidYoutubeVideoId => "INVALID_YOUTUBE_VIDEO_ID",
                Self::YoutubeVerticalChannelDeprecated => {
                    "YOUTUBE_VERTICAL_CHANNEL_DEPRECATED"
                }
                Self::YoutubeDemographicChannelDeprecated => {
                    "YOUTUBE_DEMOGRAPHIC_CHANNEL_DEPRECATED"
                }
                Self::YoutubeUrlUnsupported => "YOUTUBE_URL_UNSUPPORTED",
                Self::CannotExcludeCriteriaType => "CANNOT_EXCLUDE_CRITERIA_TYPE",
                Self::CannotAddCriteriaType => "CANNOT_ADD_CRITERIA_TYPE",
                Self::CannotExcludeSimilarUserList => "CANNOT_EXCLUDE_SIMILAR_USER_LIST",
                Self::CannotAddClosedUserList => "CANNOT_ADD_CLOSED_USER_LIST",
                Self::CannotAddDisplayOnlyListsToSearchOnlyCampaigns => {
                    "CANNOT_ADD_DISPLAY_ONLY_LISTS_TO_SEARCH_ONLY_CAMPAIGNS"
                }
                Self::CannotAddDisplayOnlyListsToSearchCampaigns => {
                    "CANNOT_ADD_DISPLAY_ONLY_LISTS_TO_SEARCH_CAMPAIGNS"
                }
                Self::CannotAddDisplayOnlyListsToShoppingCampaigns => {
                    "CANNOT_ADD_DISPLAY_ONLY_LISTS_TO_SHOPPING_CAMPAIGNS"
                }
                Self::CannotAddUserInterestsToSearchCampaigns => {
                    "CANNOT_ADD_USER_INTERESTS_TO_SEARCH_CAMPAIGNS"
                }
                Self::CannotSetBidsOnCriterionTypeInSearchCampaigns => {
                    "CANNOT_SET_BIDS_ON_CRITERION_TYPE_IN_SEARCH_CAMPAIGNS"
                }
                Self::CannotAddUrlsToCriterionTypeForCampaignType => {
                    "CANNOT_ADD_URLS_TO_CRITERION_TYPE_FOR_CAMPAIGN_TYPE"
                }
                Self::InvalidCombinedAudience => "INVALID_COMBINED_AUDIENCE",
                Self::InvalidCustomAffinity => "INVALID_CUSTOM_AFFINITY",
                Self::InvalidCustomIntent => "INVALID_CUSTOM_INTENT",
                Self::InvalidCustomAudience => "INVALID_CUSTOM_AUDIENCE",
                Self::InvalidIpAddress => "INVALID_IP_ADDRESS",
                Self::InvalidIpFormat => "INVALID_IP_FORMAT",
                Self::InvalidMobileApp => "INVALID_MOBILE_APP",
                Self::InvalidMobileAppCategory => "INVALID_MOBILE_APP_CATEGORY",
                Self::InvalidCriterionId => "INVALID_CRITERION_ID",
                Self::CannotTargetCriterion => "CANNOT_TARGET_CRITERION",
                Self::CannotTargetObsoleteCriterion => "CANNOT_TARGET_OBSOLETE_CRITERION",
                Self::CriterionIdAndTypeMismatch => "CRITERION_ID_AND_TYPE_MISMATCH",
                Self::InvalidProximityRadius => "INVALID_PROXIMITY_RADIUS",
                Self::InvalidProximityRadiusUnits => "INVALID_PROXIMITY_RADIUS_UNITS",
                Self::InvalidStreetaddressLength => "INVALID_STREETADDRESS_LENGTH",
                Self::InvalidCitynameLength => "INVALID_CITYNAME_LENGTH",
                Self::InvalidRegioncodeLength => "INVALID_REGIONCODE_LENGTH",
                Self::InvalidRegionnameLength => "INVALID_REGIONNAME_LENGTH",
                Self::InvalidPostalcodeLength => "INVALID_POSTALCODE_LENGTH",
                Self::InvalidCountryCode => "INVALID_COUNTRY_CODE",
                Self::InvalidLatitude => "INVALID_LATITUDE",
                Self::InvalidLongitude => "INVALID_LONGITUDE",
                Self::ProximityGeopointAndAddressBothCannotBeNull => {
                    "PROXIMITY_GEOPOINT_AND_ADDRESS_BOTH_CANNOT_BE_NULL"
                }
                Self::InvalidProximityAddress => "INVALID_PROXIMITY_ADDRESS",
                Self::InvalidUserDomainName => "INVALID_USER_DOMAIN_NAME",
                Self::CriterionParameterTooLong => "CRITERION_PARAMETER_TOO_LONG",
                Self::AdScheduleTimeIntervalsOverlap => {
                    "AD_SCHEDULE_TIME_INTERVALS_OVERLAP"
                }
                Self::AdScheduleIntervalCannotSpanMultipleDays => {
                    "AD_SCHEDULE_INTERVAL_CANNOT_SPAN_MULTIPLE_DAYS"
                }
                Self::AdScheduleInvalidTimeInterval => {
                    "AD_SCHEDULE_INVALID_TIME_INTERVAL"
                }
                Self::AdScheduleExceededIntervalsPerDayLimit => {
                    "AD_SCHEDULE_EXCEEDED_INTERVALS_PER_DAY_LIMIT"
                }
                Self::AdScheduleCriterionIdMismatchingFields => {
                    "AD_SCHEDULE_CRITERION_ID_MISMATCHING_FIELDS"
                }
                Self::CannotBidModifyCriterionType => "CANNOT_BID_MODIFY_CRITERION_TYPE",
                Self::CannotBidModifyCriterionCampaignOptedOut => {
                    "CANNOT_BID_MODIFY_CRITERION_CAMPAIGN_OPTED_OUT"
                }
                Self::CannotBidModifyNegativeCriterion => {
                    "CANNOT_BID_MODIFY_NEGATIVE_CRITERION"
                }
                Self::BidModifierAlreadyExists => "BID_MODIFIER_ALREADY_EXISTS",
                Self::FeedIdNotAllowed => "FEED_ID_NOT_ALLOWED",
                Self::AccountIneligibleForCriteriaType => {
                    "ACCOUNT_INELIGIBLE_FOR_CRITERIA_TYPE"
                }
                Self::CriteriaTypeInvalidForBiddingStrategy => {
                    "CRITERIA_TYPE_INVALID_FOR_BIDDING_STRATEGY"
                }
                Self::CannotExcludeCriterion => "CANNOT_EXCLUDE_CRITERION",
                Self::CannotRemoveCriterion => "CANNOT_REMOVE_CRITERION",
                Self::InvalidProductBiddingCategory => "INVALID_PRODUCT_BIDDING_CATEGORY",
                Self::MissingShoppingSetting => "MISSING_SHOPPING_SETTING",
                Self::InvalidMatchingFunction => "INVALID_MATCHING_FUNCTION",
                Self::LocationFilterNotAllowed => "LOCATION_FILTER_NOT_ALLOWED",
                Self::InvalidFeedForLocationFilter => "INVALID_FEED_FOR_LOCATION_FILTER",
                Self::LocationFilterInvalid => "LOCATION_FILTER_INVALID",
                Self::CannotSetGeoTargetConstantsWithFeedItemSets => {
                    "CANNOT_SET_GEO_TARGET_CONSTANTS_WITH_FEED_ITEM_SETS"
                }
                Self::CannotSetBothAssetSetAndFeed => {
                    "CANNOT_SET_BOTH_ASSET_SET_AND_FEED"
                }
                Self::CannotSetFeedOrFeedItemSetsForCustomer => {
                    "CANNOT_SET_FEED_OR_FEED_ITEM_SETS_FOR_CUSTOMER"
                }
                Self::CannotSetAssetSetFieldForCustomer => {
                    "CANNOT_SET_ASSET_SET_FIELD_FOR_CUSTOMER"
                }
                Self::CannotSetGeoTargetConstantsWithAssetSets => {
                    "CANNOT_SET_GEO_TARGET_CONSTANTS_WITH_ASSET_SETS"
                }
                Self::CannotSetAssetSetsWithFeedItemSets => {
                    "CANNOT_SET_ASSET_SETS_WITH_FEED_ITEM_SETS"
                }
                Self::InvalidLocationGroupAssetSet => "INVALID_LOCATION_GROUP_ASSET_SET",
                Self::InvalidLocationGroupRadius => "INVALID_LOCATION_GROUP_RADIUS",
                Self::InvalidLocationGroupRadiusUnit => {
                    "INVALID_LOCATION_GROUP_RADIUS_UNIT"
                }
                Self::CannotAttachCriteriaAtCampaignAndAdgroup => {
                    "CANNOT_ATTACH_CRITERIA_AT_CAMPAIGN_AND_ADGROUP"
                }
                Self::HotelLengthOfStayOverlapsWithExistingCriterion => {
                    "HOTEL_LENGTH_OF_STAY_OVERLAPS_WITH_EXISTING_CRITERION"
                }
                Self::HotelAdvanceBookingWindowOverlapsWithExistingCriterion => {
                    "HOTEL_ADVANCE_BOOKING_WINDOW_OVERLAPS_WITH_EXISTING_CRITERION"
                }
                Self::FieldIncompatibleWithNegativeTargeting => {
                    "FIELD_INCOMPATIBLE_WITH_NEGATIVE_TARGETING"
                }
                Self::InvalidWebpageCondition => "INVALID_WEBPAGE_CONDITION",
                Self::InvalidWebpageConditionUrl => "INVALID_WEBPAGE_CONDITION_URL",
                Self::WebpageConditionUrlCannotBeEmpty => {
                    "WEBPAGE_CONDITION_URL_CANNOT_BE_EMPTY"
                }
                Self::WebpageConditionUrlUnsupportedProtocol => {
                    "WEBPAGE_CONDITION_URL_UNSUPPORTED_PROTOCOL"
                }
                Self::WebpageConditionUrlCannotBeIpAddress => {
                    "WEBPAGE_CONDITION_URL_CANNOT_BE_IP_ADDRESS"
                }
                Self::WebpageConditionUrlDomainNotConsistentWithCampaignSetting => {
                    "WEBPAGE_CONDITION_URL_DOMAIN_NOT_CONSISTENT_WITH_CAMPAIGN_SETTING"
                }
                Self::WebpageConditionUrlCannotBePublicSuffix => {
                    "WEBPAGE_CONDITION_URL_CANNOT_BE_PUBLIC_SUFFIX"
                }
                Self::WebpageConditionUrlInvalidPublicSuffix => {
                    "WEBPAGE_CONDITION_URL_INVALID_PUBLIC_SUFFIX"
                }
                Self::WebpageConditionUrlValueTrackValueNotSupported => {
                    "WEBPAGE_CONDITION_URL_VALUE_TRACK_VALUE_NOT_SUPPORTED"
                }
                Self::WebpageCriterionUrlEqualsCanHaveOnlyOneCondition => {
                    "WEBPAGE_CRITERION_URL_EQUALS_CAN_HAVE_ONLY_ONE_CONDITION"
                }
                Self::WebpageCriterionNotSupportedOnNonDsaAdGroup => {
                    "WEBPAGE_CRITERION_NOT_SUPPORTED_ON_NON_DSA_AD_GROUP"
                }
                Self::CannotTargetUserListForSmartDisplayCampaigns => {
                    "CANNOT_TARGET_USER_LIST_FOR_SMART_DISPLAY_CAMPAIGNS"
                }
                Self::CannotTargetPlacementsForSearchCampaigns => {
                    "CANNOT_TARGET_PLACEMENTS_FOR_SEARCH_CAMPAIGNS"
                }
                Self::ListingScopeTooManyDimensionTypes => {
                    "LISTING_SCOPE_TOO_MANY_DIMENSION_TYPES"
                }
                Self::ListingScopeTooManyInOperators => {
                    "LISTING_SCOPE_TOO_MANY_IN_OPERATORS"
                }
                Self::ListingScopeInOperatorNotSupported => {
                    "LISTING_SCOPE_IN_OPERATOR_NOT_SUPPORTED"
                }
                Self::DuplicateListingDimensionType => "DUPLICATE_LISTING_DIMENSION_TYPE",
                Self::DuplicateListingDimensionValue => {
                    "DUPLICATE_LISTING_DIMENSION_VALUE"
                }
                Self::CannotSetBidsOnListingGroupSubdivision => {
                    "CANNOT_SET_BIDS_ON_LISTING_GROUP_SUBDIVISION"
                }
                Self::InvalidListingGroupHierarchy => "INVALID_LISTING_GROUP_HIERARCHY",
                Self::ListingGroupUnitCannotHaveChildren => {
                    "LISTING_GROUP_UNIT_CANNOT_HAVE_CHILDREN"
                }
                Self::ListingGroupSubdivisionRequiresOthersCase => {
                    "LISTING_GROUP_SUBDIVISION_REQUIRES_OTHERS_CASE"
                }
                Self::ListingGroupRequiresSameDimensionTypeAsSiblings => {
                    "LISTING_GROUP_REQUIRES_SAME_DIMENSION_TYPE_AS_SIBLINGS"
                }
                Self::ListingGroupAlreadyExists => "LISTING_GROUP_ALREADY_EXISTS",
                Self::ListingGroupDoesNotExist => "LISTING_GROUP_DOES_NOT_EXIST",
                Self::ListingGroupCannotBeRemoved => "LISTING_GROUP_CANNOT_BE_REMOVED",
                Self::InvalidListingGroupType => "INVALID_LISTING_GROUP_TYPE",
                Self::ListingGroupAddMayOnlyUseTempId => {
                    "LISTING_GROUP_ADD_MAY_ONLY_USE_TEMP_ID"
                }
                Self::ListingScopeTooLong => "LISTING_SCOPE_TOO_LONG",
                Self::ListingScopeTooManyDimensions => {
                    "LISTING_SCOPE_TOO_MANY_DIMENSIONS"
                }
                Self::ListingGroupTooLong => "LISTING_GROUP_TOO_LONG",
                Self::ListingGroupTreeTooDeep => "LISTING_GROUP_TREE_TOO_DEEP",
                Self::InvalidListingDimension => "INVALID_LISTING_DIMENSION",
                Self::InvalidListingDimensionType => "INVALID_LISTING_DIMENSION_TYPE",
                Self::AdvertiserNotOnAllowlistForCombinedAudienceOnDisplay => {
                    "ADVERTISER_NOT_ON_ALLOWLIST_FOR_COMBINED_AUDIENCE_ON_DISPLAY"
                }
                Self::CannotTargetRemovedCombinedAudience => {
                    "CANNOT_TARGET_REMOVED_COMBINED_AUDIENCE"
                }
                Self::InvalidCombinedAudienceId => "INVALID_COMBINED_AUDIENCE_ID",
                Self::CannotTargetRemovedCustomAudience => {
                    "CANNOT_TARGET_REMOVED_CUSTOM_AUDIENCE"
                }
                Self::HotelCheckInDateRangeOverlapsWithExistingCriterion => {
                    "HOTEL_CHECK_IN_DATE_RANGE_OVERLAPS_WITH_EXISTING_CRITERION"
                }
                Self::HotelCheckInDateRangeStartDateTooEarly => {
                    "HOTEL_CHECK_IN_DATE_RANGE_START_DATE_TOO_EARLY"
                }
                Self::HotelCheckInDateRangeEndDateTooLate => {
                    "HOTEL_CHECK_IN_DATE_RANGE_END_DATE_TOO_LATE"
                }
                Self::HotelCheckInDateRangeReversed => {
                    "HOTEL_CHECK_IN_DATE_RANGE_REVERSED"
                }
                Self::BroadMatchModifierKeywordNotAllowed => {
                    "BROAD_MATCH_MODIFIER_KEYWORD_NOT_ALLOWED"
                }
                Self::OneAudienceAllowedPerAssetGroup => {
                    "ONE_AUDIENCE_ALLOWED_PER_ASSET_GROUP"
                }
                Self::AudienceNotEligibleForCampaignType => {
                    "AUDIENCE_NOT_ELIGIBLE_FOR_CAMPAIGN_TYPE"
                }
                Self::AudienceNotAllowedToAttachWhenAudienceGroupedSetToFalse => {
                    "AUDIENCE_NOT_ALLOWED_TO_ATTACH_WHEN_AUDIENCE_GROUPED_SET_TO_FALSE"
                }
                Self::CannotTargetCustomerMatchUserList => {
                    "CANNOT_TARGET_CUSTOMER_MATCH_USER_LIST"
                }
                Self::NegativeKeywordSharedSetDoesNotExist => {
                    "NEGATIVE_KEYWORD_SHARED_SET_DOES_NOT_EXIST"
                }
                Self::CannotAddRemovedNegativeKeywordSharedSet => {
                    "CANNOT_ADD_REMOVED_NEGATIVE_KEYWORD_SHARED_SET"
                }
                Self::CannotHaveMultipleNegativeKeywordListPerAccount => {
                    "CANNOT_HAVE_MULTIPLE_NEGATIVE_KEYWORD_LIST_PER_ACCOUNT"
                }
                Self::CustomerCannotAddCriterionOfThisType => {
                    "CUSTOMER_CANNOT_ADD_CRITERION_OF_THIS_TYPE"
                }
                Self::CannotTargetSimilarUserList => "CANNOT_TARGET_SIMILAR_USER_LIST",
                Self::CannotAddAudienceSegmentCriterionWhenAudienceGroupedIsSet => {
                    "CANNOT_ADD_AUDIENCE_SEGMENT_CRITERION_WHEN_AUDIENCE_GROUPED_IS_SET"
                }
                Self::OneAudienceAllowedPerAdGroup => "ONE_AUDIENCE_ALLOWED_PER_AD_GROUP",
                Self::InvalidDetailedDemographic => "INVALID_DETAILED_DEMOGRAPHIC",
                Self::CannotRecognizeBrand => "CANNOT_RECOGNIZE_BRAND",
                Self::BrandSharedSetDoesNotExist => "BRAND_SHARED_SET_DOES_NOT_EXIST",
                Self::CannotAddRemovedBrandSharedSet => {
                    "CANNOT_ADD_REMOVED_BRAND_SHARED_SET"
                }
                Self::OnlyExclusionBrandListAllowedForCampaignType => {
                    "ONLY_EXCLUSION_BRAND_LIST_ALLOWED_FOR_CAMPAIGN_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CONCRETE_TYPE_REQUIRED" => Some(Self::ConcreteTypeRequired),
                "INVALID_EXCLUDED_CATEGORY" => Some(Self::InvalidExcludedCategory),
                "INVALID_KEYWORD_TEXT" => Some(Self::InvalidKeywordText),
                "KEYWORD_TEXT_TOO_LONG" => Some(Self::KeywordTextTooLong),
                "KEYWORD_HAS_TOO_MANY_WORDS" => Some(Self::KeywordHasTooManyWords),
                "KEYWORD_HAS_INVALID_CHARS" => Some(Self::KeywordHasInvalidChars),
                "INVALID_PLACEMENT_URL" => Some(Self::InvalidPlacementUrl),
                "INVALID_USER_LIST" => Some(Self::InvalidUserList),
                "INVALID_USER_INTEREST" => Some(Self::InvalidUserInterest),
                "INVALID_FORMAT_FOR_PLACEMENT_URL" => {
                    Some(Self::InvalidFormatForPlacementUrl)
                }
                "PLACEMENT_URL_IS_TOO_LONG" => Some(Self::PlacementUrlIsTooLong),
                "PLACEMENT_URL_HAS_ILLEGAL_CHAR" => {
                    Some(Self::PlacementUrlHasIllegalChar)
                }
                "PLACEMENT_URL_HAS_MULTIPLE_SITES_IN_LINE" => {
                    Some(Self::PlacementUrlHasMultipleSitesInLine)
                }
                "PLACEMENT_IS_NOT_AVAILABLE_FOR_TARGETING_OR_EXCLUSION" => {
                    Some(Self::PlacementIsNotAvailableForTargetingOrExclusion)
                }
                "INVALID_TOPIC_PATH" => Some(Self::InvalidTopicPath),
                "INVALID_YOUTUBE_CHANNEL_ID" => Some(Self::InvalidYoutubeChannelId),
                "INVALID_YOUTUBE_VIDEO_ID" => Some(Self::InvalidYoutubeVideoId),
                "YOUTUBE_VERTICAL_CHANNEL_DEPRECATED" => {
                    Some(Self::YoutubeVerticalChannelDeprecated)
                }
                "YOUTUBE_DEMOGRAPHIC_CHANNEL_DEPRECATED" => {
                    Some(Self::YoutubeDemographicChannelDeprecated)
                }
                "YOUTUBE_URL_UNSUPPORTED" => Some(Self::YoutubeUrlUnsupported),
                "CANNOT_EXCLUDE_CRITERIA_TYPE" => Some(Self::CannotExcludeCriteriaType),
                "CANNOT_ADD_CRITERIA_TYPE" => Some(Self::CannotAddCriteriaType),
                "CANNOT_EXCLUDE_SIMILAR_USER_LIST" => {
                    Some(Self::CannotExcludeSimilarUserList)
                }
                "CANNOT_ADD_CLOSED_USER_LIST" => Some(Self::CannotAddClosedUserList),
                "CANNOT_ADD_DISPLAY_ONLY_LISTS_TO_SEARCH_ONLY_CAMPAIGNS" => {
                    Some(Self::CannotAddDisplayOnlyListsToSearchOnlyCampaigns)
                }
                "CANNOT_ADD_DISPLAY_ONLY_LISTS_TO_SEARCH_CAMPAIGNS" => {
                    Some(Self::CannotAddDisplayOnlyListsToSearchCampaigns)
                }
                "CANNOT_ADD_DISPLAY_ONLY_LISTS_TO_SHOPPING_CAMPAIGNS" => {
                    Some(Self::CannotAddDisplayOnlyListsToShoppingCampaigns)
                }
                "CANNOT_ADD_USER_INTERESTS_TO_SEARCH_CAMPAIGNS" => {
                    Some(Self::CannotAddUserInterestsToSearchCampaigns)
                }
                "CANNOT_SET_BIDS_ON_CRITERION_TYPE_IN_SEARCH_CAMPAIGNS" => {
                    Some(Self::CannotSetBidsOnCriterionTypeInSearchCampaigns)
                }
                "CANNOT_ADD_URLS_TO_CRITERION_TYPE_FOR_CAMPAIGN_TYPE" => {
                    Some(Self::CannotAddUrlsToCriterionTypeForCampaignType)
                }
                "INVALID_COMBINED_AUDIENCE" => Some(Self::InvalidCombinedAudience),
                "INVALID_CUSTOM_AFFINITY" => Some(Self::InvalidCustomAffinity),
                "INVALID_CUSTOM_INTENT" => Some(Self::InvalidCustomIntent),
                "INVALID_CUSTOM_AUDIENCE" => Some(Self::InvalidCustomAudience),
                "INVALID_IP_ADDRESS" => Some(Self::InvalidIpAddress),
                "INVALID_IP_FORMAT" => Some(Self::InvalidIpFormat),
                "INVALID_MOBILE_APP" => Some(Self::InvalidMobileApp),
                "INVALID_MOBILE_APP_CATEGORY" => Some(Self::InvalidMobileAppCategory),
                "INVALID_CRITERION_ID" => Some(Self::InvalidCriterionId),
                "CANNOT_TARGET_CRITERION" => Some(Self::CannotTargetCriterion),
                "CANNOT_TARGET_OBSOLETE_CRITERION" => {
                    Some(Self::CannotTargetObsoleteCriterion)
                }
                "CRITERION_ID_AND_TYPE_MISMATCH" => {
                    Some(Self::CriterionIdAndTypeMismatch)
                }
                "INVALID_PROXIMITY_RADIUS" => Some(Self::InvalidProximityRadius),
                "INVALID_PROXIMITY_RADIUS_UNITS" => {
                    Some(Self::InvalidProximityRadiusUnits)
                }
                "INVALID_STREETADDRESS_LENGTH" => Some(Self::InvalidStreetaddressLength),
                "INVALID_CITYNAME_LENGTH" => Some(Self::InvalidCitynameLength),
                "INVALID_REGIONCODE_LENGTH" => Some(Self::InvalidRegioncodeLength),
                "INVALID_REGIONNAME_LENGTH" => Some(Self::InvalidRegionnameLength),
                "INVALID_POSTALCODE_LENGTH" => Some(Self::InvalidPostalcodeLength),
                "INVALID_COUNTRY_CODE" => Some(Self::InvalidCountryCode),
                "INVALID_LATITUDE" => Some(Self::InvalidLatitude),
                "INVALID_LONGITUDE" => Some(Self::InvalidLongitude),
                "PROXIMITY_GEOPOINT_AND_ADDRESS_BOTH_CANNOT_BE_NULL" => {
                    Some(Self::ProximityGeopointAndAddressBothCannotBeNull)
                }
                "INVALID_PROXIMITY_ADDRESS" => Some(Self::InvalidProximityAddress),
                "INVALID_USER_DOMAIN_NAME" => Some(Self::InvalidUserDomainName),
                "CRITERION_PARAMETER_TOO_LONG" => Some(Self::CriterionParameterTooLong),
                "AD_SCHEDULE_TIME_INTERVALS_OVERLAP" => {
                    Some(Self::AdScheduleTimeIntervalsOverlap)
                }
                "AD_SCHEDULE_INTERVAL_CANNOT_SPAN_MULTIPLE_DAYS" => {
                    Some(Self::AdScheduleIntervalCannotSpanMultipleDays)
                }
                "AD_SCHEDULE_INVALID_TIME_INTERVAL" => {
                    Some(Self::AdScheduleInvalidTimeInterval)
                }
                "AD_SCHEDULE_EXCEEDED_INTERVALS_PER_DAY_LIMIT" => {
                    Some(Self::AdScheduleExceededIntervalsPerDayLimit)
                }
                "AD_SCHEDULE_CRITERION_ID_MISMATCHING_FIELDS" => {
                    Some(Self::AdScheduleCriterionIdMismatchingFields)
                }
                "CANNOT_BID_MODIFY_CRITERION_TYPE" => {
                    Some(Self::CannotBidModifyCriterionType)
                }
                "CANNOT_BID_MODIFY_CRITERION_CAMPAIGN_OPTED_OUT" => {
                    Some(Self::CannotBidModifyCriterionCampaignOptedOut)
                }
                "CANNOT_BID_MODIFY_NEGATIVE_CRITERION" => {
                    Some(Self::CannotBidModifyNegativeCriterion)
                }
                "BID_MODIFIER_ALREADY_EXISTS" => Some(Self::BidModifierAlreadyExists),
                "FEED_ID_NOT_ALLOWED" => Some(Self::FeedIdNotAllowed),
                "ACCOUNT_INELIGIBLE_FOR_CRITERIA_TYPE" => {
                    Some(Self::AccountIneligibleForCriteriaType)
                }
                "CRITERIA_TYPE_INVALID_FOR_BIDDING_STRATEGY" => {
                    Some(Self::CriteriaTypeInvalidForBiddingStrategy)
                }
                "CANNOT_EXCLUDE_CRITERION" => Some(Self::CannotExcludeCriterion),
                "CANNOT_REMOVE_CRITERION" => Some(Self::CannotRemoveCriterion),
                "INVALID_PRODUCT_BIDDING_CATEGORY" => {
                    Some(Self::InvalidProductBiddingCategory)
                }
                "MISSING_SHOPPING_SETTING" => Some(Self::MissingShoppingSetting),
                "INVALID_MATCHING_FUNCTION" => Some(Self::InvalidMatchingFunction),
                "LOCATION_FILTER_NOT_ALLOWED" => Some(Self::LocationFilterNotAllowed),
                "INVALID_FEED_FOR_LOCATION_FILTER" => {
                    Some(Self::InvalidFeedForLocationFilter)
                }
                "LOCATION_FILTER_INVALID" => Some(Self::LocationFilterInvalid),
                "CANNOT_SET_GEO_TARGET_CONSTANTS_WITH_FEED_ITEM_SETS" => {
                    Some(Self::CannotSetGeoTargetConstantsWithFeedItemSets)
                }
                "CANNOT_SET_BOTH_ASSET_SET_AND_FEED" => {
                    Some(Self::CannotSetBothAssetSetAndFeed)
                }
                "CANNOT_SET_FEED_OR_FEED_ITEM_SETS_FOR_CUSTOMER" => {
                    Some(Self::CannotSetFeedOrFeedItemSetsForCustomer)
                }
                "CANNOT_SET_ASSET_SET_FIELD_FOR_CUSTOMER" => {
                    Some(Self::CannotSetAssetSetFieldForCustomer)
                }
                "CANNOT_SET_GEO_TARGET_CONSTANTS_WITH_ASSET_SETS" => {
                    Some(Self::CannotSetGeoTargetConstantsWithAssetSets)
                }
                "CANNOT_SET_ASSET_SETS_WITH_FEED_ITEM_SETS" => {
                    Some(Self::CannotSetAssetSetsWithFeedItemSets)
                }
                "INVALID_LOCATION_GROUP_ASSET_SET" => {
                    Some(Self::InvalidLocationGroupAssetSet)
                }
                "INVALID_LOCATION_GROUP_RADIUS" => Some(Self::InvalidLocationGroupRadius),
                "INVALID_LOCATION_GROUP_RADIUS_UNIT" => {
                    Some(Self::InvalidLocationGroupRadiusUnit)
                }
                "CANNOT_ATTACH_CRITERIA_AT_CAMPAIGN_AND_ADGROUP" => {
                    Some(Self::CannotAttachCriteriaAtCampaignAndAdgroup)
                }
                "HOTEL_LENGTH_OF_STAY_OVERLAPS_WITH_EXISTING_CRITERION" => {
                    Some(Self::HotelLengthOfStayOverlapsWithExistingCriterion)
                }
                "HOTEL_ADVANCE_BOOKING_WINDOW_OVERLAPS_WITH_EXISTING_CRITERION" => {
                    Some(Self::HotelAdvanceBookingWindowOverlapsWithExistingCriterion)
                }
                "FIELD_INCOMPATIBLE_WITH_NEGATIVE_TARGETING" => {
                    Some(Self::FieldIncompatibleWithNegativeTargeting)
                }
                "INVALID_WEBPAGE_CONDITION" => Some(Self::InvalidWebpageCondition),
                "INVALID_WEBPAGE_CONDITION_URL" => Some(Self::InvalidWebpageConditionUrl),
                "WEBPAGE_CONDITION_URL_CANNOT_BE_EMPTY" => {
                    Some(Self::WebpageConditionUrlCannotBeEmpty)
                }
                "WEBPAGE_CONDITION_URL_UNSUPPORTED_PROTOCOL" => {
                    Some(Self::WebpageConditionUrlUnsupportedProtocol)
                }
                "WEBPAGE_CONDITION_URL_CANNOT_BE_IP_ADDRESS" => {
                    Some(Self::WebpageConditionUrlCannotBeIpAddress)
                }
                "WEBPAGE_CONDITION_URL_DOMAIN_NOT_CONSISTENT_WITH_CAMPAIGN_SETTING" => {
                    Some(Self::WebpageConditionUrlDomainNotConsistentWithCampaignSetting)
                }
                "WEBPAGE_CONDITION_URL_CANNOT_BE_PUBLIC_SUFFIX" => {
                    Some(Self::WebpageConditionUrlCannotBePublicSuffix)
                }
                "WEBPAGE_CONDITION_URL_INVALID_PUBLIC_SUFFIX" => {
                    Some(Self::WebpageConditionUrlInvalidPublicSuffix)
                }
                "WEBPAGE_CONDITION_URL_VALUE_TRACK_VALUE_NOT_SUPPORTED" => {
                    Some(Self::WebpageConditionUrlValueTrackValueNotSupported)
                }
                "WEBPAGE_CRITERION_URL_EQUALS_CAN_HAVE_ONLY_ONE_CONDITION" => {
                    Some(Self::WebpageCriterionUrlEqualsCanHaveOnlyOneCondition)
                }
                "WEBPAGE_CRITERION_NOT_SUPPORTED_ON_NON_DSA_AD_GROUP" => {
                    Some(Self::WebpageCriterionNotSupportedOnNonDsaAdGroup)
                }
                "CANNOT_TARGET_USER_LIST_FOR_SMART_DISPLAY_CAMPAIGNS" => {
                    Some(Self::CannotTargetUserListForSmartDisplayCampaigns)
                }
                "CANNOT_TARGET_PLACEMENTS_FOR_SEARCH_CAMPAIGNS" => {
                    Some(Self::CannotTargetPlacementsForSearchCampaigns)
                }
                "LISTING_SCOPE_TOO_MANY_DIMENSION_TYPES" => {
                    Some(Self::ListingScopeTooManyDimensionTypes)
                }
                "LISTING_SCOPE_TOO_MANY_IN_OPERATORS" => {
                    Some(Self::ListingScopeTooManyInOperators)
                }
                "LISTING_SCOPE_IN_OPERATOR_NOT_SUPPORTED" => {
                    Some(Self::ListingScopeInOperatorNotSupported)
                }
                "DUPLICATE_LISTING_DIMENSION_TYPE" => {
                    Some(Self::DuplicateListingDimensionType)
                }
                "DUPLICATE_LISTING_DIMENSION_VALUE" => {
                    Some(Self::DuplicateListingDimensionValue)
                }
                "CANNOT_SET_BIDS_ON_LISTING_GROUP_SUBDIVISION" => {
                    Some(Self::CannotSetBidsOnListingGroupSubdivision)
                }
                "INVALID_LISTING_GROUP_HIERARCHY" => {
                    Some(Self::InvalidListingGroupHierarchy)
                }
                "LISTING_GROUP_UNIT_CANNOT_HAVE_CHILDREN" => {
                    Some(Self::ListingGroupUnitCannotHaveChildren)
                }
                "LISTING_GROUP_SUBDIVISION_REQUIRES_OTHERS_CASE" => {
                    Some(Self::ListingGroupSubdivisionRequiresOthersCase)
                }
                "LISTING_GROUP_REQUIRES_SAME_DIMENSION_TYPE_AS_SIBLINGS" => {
                    Some(Self::ListingGroupRequiresSameDimensionTypeAsSiblings)
                }
                "LISTING_GROUP_ALREADY_EXISTS" => Some(Self::ListingGroupAlreadyExists),
                "LISTING_GROUP_DOES_NOT_EXIST" => Some(Self::ListingGroupDoesNotExist),
                "LISTING_GROUP_CANNOT_BE_REMOVED" => {
                    Some(Self::ListingGroupCannotBeRemoved)
                }
                "INVALID_LISTING_GROUP_TYPE" => Some(Self::InvalidListingGroupType),
                "LISTING_GROUP_ADD_MAY_ONLY_USE_TEMP_ID" => {
                    Some(Self::ListingGroupAddMayOnlyUseTempId)
                }
                "LISTING_SCOPE_TOO_LONG" => Some(Self::ListingScopeTooLong),
                "LISTING_SCOPE_TOO_MANY_DIMENSIONS" => {
                    Some(Self::ListingScopeTooManyDimensions)
                }
                "LISTING_GROUP_TOO_LONG" => Some(Self::ListingGroupTooLong),
                "LISTING_GROUP_TREE_TOO_DEEP" => Some(Self::ListingGroupTreeTooDeep),
                "INVALID_LISTING_DIMENSION" => Some(Self::InvalidListingDimension),
                "INVALID_LISTING_DIMENSION_TYPE" => {
                    Some(Self::InvalidListingDimensionType)
                }
                "ADVERTISER_NOT_ON_ALLOWLIST_FOR_COMBINED_AUDIENCE_ON_DISPLAY" => {
                    Some(Self::AdvertiserNotOnAllowlistForCombinedAudienceOnDisplay)
                }
                "CANNOT_TARGET_REMOVED_COMBINED_AUDIENCE" => {
                    Some(Self::CannotTargetRemovedCombinedAudience)
                }
                "INVALID_COMBINED_AUDIENCE_ID" => Some(Self::InvalidCombinedAudienceId),
                "CANNOT_TARGET_REMOVED_CUSTOM_AUDIENCE" => {
                    Some(Self::CannotTargetRemovedCustomAudience)
                }
                "HOTEL_CHECK_IN_DATE_RANGE_OVERLAPS_WITH_EXISTING_CRITERION" => {
                    Some(Self::HotelCheckInDateRangeOverlapsWithExistingCriterion)
                }
                "HOTEL_CHECK_IN_DATE_RANGE_START_DATE_TOO_EARLY" => {
                    Some(Self::HotelCheckInDateRangeStartDateTooEarly)
                }
                "HOTEL_CHECK_IN_DATE_RANGE_END_DATE_TOO_LATE" => {
                    Some(Self::HotelCheckInDateRangeEndDateTooLate)
                }
                "HOTEL_CHECK_IN_DATE_RANGE_REVERSED" => {
                    Some(Self::HotelCheckInDateRangeReversed)
                }
                "BROAD_MATCH_MODIFIER_KEYWORD_NOT_ALLOWED" => {
                    Some(Self::BroadMatchModifierKeywordNotAllowed)
                }
                "ONE_AUDIENCE_ALLOWED_PER_ASSET_GROUP" => {
                    Some(Self::OneAudienceAllowedPerAssetGroup)
                }
                "AUDIENCE_NOT_ELIGIBLE_FOR_CAMPAIGN_TYPE" => {
                    Some(Self::AudienceNotEligibleForCampaignType)
                }
                "AUDIENCE_NOT_ALLOWED_TO_ATTACH_WHEN_AUDIENCE_GROUPED_SET_TO_FALSE" => {
                    Some(Self::AudienceNotAllowedToAttachWhenAudienceGroupedSetToFalse)
                }
                "CANNOT_TARGET_CUSTOMER_MATCH_USER_LIST" => {
                    Some(Self::CannotTargetCustomerMatchUserList)
                }
                "NEGATIVE_KEYWORD_SHARED_SET_DOES_NOT_EXIST" => {
                    Some(Self::NegativeKeywordSharedSetDoesNotExist)
                }
                "CANNOT_ADD_REMOVED_NEGATIVE_KEYWORD_SHARED_SET" => {
                    Some(Self::CannotAddRemovedNegativeKeywordSharedSet)
                }
                "CANNOT_HAVE_MULTIPLE_NEGATIVE_KEYWORD_LIST_PER_ACCOUNT" => {
                    Some(Self::CannotHaveMultipleNegativeKeywordListPerAccount)
                }
                "CUSTOMER_CANNOT_ADD_CRITERION_OF_THIS_TYPE" => {
                    Some(Self::CustomerCannotAddCriterionOfThisType)
                }
                "CANNOT_TARGET_SIMILAR_USER_LIST" => {
                    Some(Self::CannotTargetSimilarUserList)
                }
                "CANNOT_ADD_AUDIENCE_SEGMENT_CRITERION_WHEN_AUDIENCE_GROUPED_IS_SET" => {
                    Some(Self::CannotAddAudienceSegmentCriterionWhenAudienceGroupedIsSet)
                }
                "ONE_AUDIENCE_ALLOWED_PER_AD_GROUP" => {
                    Some(Self::OneAudienceAllowedPerAdGroup)
                }
                "INVALID_DETAILED_DEMOGRAPHIC" => Some(Self::InvalidDetailedDemographic),
                "CANNOT_RECOGNIZE_BRAND" => Some(Self::CannotRecognizeBrand),
                "BRAND_SHARED_SET_DOES_NOT_EXIST" => {
                    Some(Self::BrandSharedSetDoesNotExist)
                }
                "CANNOT_ADD_REMOVED_BRAND_SHARED_SET" => {
                    Some(Self::CannotAddRemovedBrandSharedSet)
                }
                "ONLY_EXCLUSION_BRAND_LIST_ALLOWED_FOR_CAMPAIGN_TYPE" => {
                    Some(Self::OnlyExclusionBrandListAllowedForCampaignType)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible currency code errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CurrencyCodeErrorEnum {}
/// Nested message and enum types in `CurrencyCodeErrorEnum`.
pub mod currency_code_error_enum {
    /// Enum describing possible currency code errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CurrencyCodeError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The currency code is not supported.
        Unsupported = 2,
    }
    impl CurrencyCodeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Unsupported => "UNSUPPORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNSUPPORTED" => Some(Self::Unsupported),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible currency errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CurrencyErrorEnum {}
/// Nested message and enum types in `CurrencyErrorEnum`.
pub mod currency_error_enum {
    /// Enum describing possible currency errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CurrencyError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Bid must be a multiple of billable unit.
        ValueNotMultipleOfBillableUnit = 2,
    }
    impl CurrencyError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ValueNotMultipleOfBillableUnit => {
                    "VALUE_NOT_MULTIPLE_OF_BILLABLE_UNIT"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "VALUE_NOT_MULTIPLE_OF_BILLABLE_UNIT" => {
                    Some(Self::ValueNotMultipleOfBillableUnit)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible custom audience errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomAudienceErrorEnum {}
/// Nested message and enum types in `CustomAudienceErrorEnum`.
pub mod custom_audience_error_enum {
    /// Enum describing possible custom audience errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomAudienceError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// New name in the custom audience is duplicated ignoring cases.
        NameAlreadyUsed = 2,
        /// Cannot remove a custom audience while it's still being used as targeting.
        CannotRemoveWhileInUse = 3,
        /// Cannot update or remove a custom audience that is already removed.
        ResourceAlreadyRemoved = 4,
        /// The pair of \[type, value\] already exists in members.
        MemberTypeAndParameterAlreadyExisted = 5,
        /// Member type is invalid.
        InvalidMemberType = 6,
        /// Member type does not have associated value.
        MemberTypeAndValueDoesNotMatch = 7,
        /// Custom audience contains a member that violates policy.
        PolicyViolation = 8,
        /// Change in custom audience type is not allowed.
        InvalidTypeChange = 9,
    }
    impl CustomAudienceError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NameAlreadyUsed => "NAME_ALREADY_USED",
                Self::CannotRemoveWhileInUse => "CANNOT_REMOVE_WHILE_IN_USE",
                Self::ResourceAlreadyRemoved => "RESOURCE_ALREADY_REMOVED",
                Self::MemberTypeAndParameterAlreadyExisted => {
                    "MEMBER_TYPE_AND_PARAMETER_ALREADY_EXISTED"
                }
                Self::InvalidMemberType => "INVALID_MEMBER_TYPE",
                Self::MemberTypeAndValueDoesNotMatch => {
                    "MEMBER_TYPE_AND_VALUE_DOES_NOT_MATCH"
                }
                Self::PolicyViolation => "POLICY_VIOLATION",
                Self::InvalidTypeChange => "INVALID_TYPE_CHANGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NAME_ALREADY_USED" => Some(Self::NameAlreadyUsed),
                "CANNOT_REMOVE_WHILE_IN_USE" => Some(Self::CannotRemoveWhileInUse),
                "RESOURCE_ALREADY_REMOVED" => Some(Self::ResourceAlreadyRemoved),
                "MEMBER_TYPE_AND_PARAMETER_ALREADY_EXISTED" => {
                    Some(Self::MemberTypeAndParameterAlreadyExisted)
                }
                "INVALID_MEMBER_TYPE" => Some(Self::InvalidMemberType),
                "MEMBER_TYPE_AND_VALUE_DOES_NOT_MATCH" => {
                    Some(Self::MemberTypeAndValueDoesNotMatch)
                }
                "POLICY_VIOLATION" => Some(Self::PolicyViolation),
                "INVALID_TYPE_CHANGE" => Some(Self::InvalidTypeChange),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible custom conversion goal errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomConversionGoalErrorEnum {}
/// Nested message and enum types in `CustomConversionGoalErrorEnum`.
pub mod custom_conversion_goal_error_enum {
    /// Enum describing possible custom conversion goal errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomConversionGoalError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Cannot find a conversion action with the specified id.
        InvalidConversionAction = 2,
        /// The conversion action is not enabled so it cannot be included in a custom
        /// conversion goal.
        ConversionActionNotEnabled = 3,
        /// The custom conversion goal cannot be removed because it's linked to a
        /// campaign.
        CannotRemoveLinkedCustomConversionGoal = 4,
        /// Custom goal with the same name already exists.
        CustomGoalDuplicateName = 5,
        /// Custom goal with the same conversion action list already exists.
        DuplicateConversionActionList = 6,
        /// Conversion types that cannot be biddable should not be included in custom
        /// goal.
        NonBiddableConversionActionNotEligibleForCustomGoal = 7,
    }
    impl CustomConversionGoalError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidConversionAction => "INVALID_CONVERSION_ACTION",
                Self::ConversionActionNotEnabled => "CONVERSION_ACTION_NOT_ENABLED",
                Self::CannotRemoveLinkedCustomConversionGoal => {
                    "CANNOT_REMOVE_LINKED_CUSTOM_CONVERSION_GOAL"
                }
                Self::CustomGoalDuplicateName => "CUSTOM_GOAL_DUPLICATE_NAME",
                Self::DuplicateConversionActionList => "DUPLICATE_CONVERSION_ACTION_LIST",
                Self::NonBiddableConversionActionNotEligibleForCustomGoal => {
                    "NON_BIDDABLE_CONVERSION_ACTION_NOT_ELIGIBLE_FOR_CUSTOM_GOAL"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_CONVERSION_ACTION" => Some(Self::InvalidConversionAction),
                "CONVERSION_ACTION_NOT_ENABLED" => Some(Self::ConversionActionNotEnabled),
                "CANNOT_REMOVE_LINKED_CUSTOM_CONVERSION_GOAL" => {
                    Some(Self::CannotRemoveLinkedCustomConversionGoal)
                }
                "CUSTOM_GOAL_DUPLICATE_NAME" => Some(Self::CustomGoalDuplicateName),
                "DUPLICATE_CONVERSION_ACTION_LIST" => {
                    Some(Self::DuplicateConversionActionList)
                }
                "NON_BIDDABLE_CONVERSION_ACTION_NOT_ELIGIBLE_FOR_CUSTOM_GOAL" => {
                    Some(Self::NonBiddableConversionActionNotEligibleForCustomGoal)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible custom interest errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomInterestErrorEnum {}
/// Nested message and enum types in `CustomInterestErrorEnum`.
pub mod custom_interest_error_enum {
    /// Enum describing possible custom interest errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomInterestError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Duplicate custom interest name ignoring case.
        NameAlreadyUsed = 2,
        /// In the remove custom interest member operation, both member ID and
        /// pair \[type, parameter\] are not present.
        CustomInterestMemberIdAndTypeParameterNotPresentInRemove = 3,
        /// The pair of \[type, parameter\] does not exist.
        TypeAndParameterNotFound = 4,
        /// The pair of \[type, parameter\] already exists.
        TypeAndParameterAlreadyExisted = 5,
        /// Unsupported custom interest member type.
        InvalidCustomInterestMemberType = 6,
        /// Cannot remove a custom interest while it's still being targeted.
        CannotRemoveWhileInUse = 7,
        /// Cannot mutate custom interest type.
        CannotChangeType = 8,
    }
    impl CustomInterestError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NameAlreadyUsed => "NAME_ALREADY_USED",
                Self::CustomInterestMemberIdAndTypeParameterNotPresentInRemove => {
                    "CUSTOM_INTEREST_MEMBER_ID_AND_TYPE_PARAMETER_NOT_PRESENT_IN_REMOVE"
                }
                Self::TypeAndParameterNotFound => "TYPE_AND_PARAMETER_NOT_FOUND",
                Self::TypeAndParameterAlreadyExisted => {
                    "TYPE_AND_PARAMETER_ALREADY_EXISTED"
                }
                Self::InvalidCustomInterestMemberType => {
                    "INVALID_CUSTOM_INTEREST_MEMBER_TYPE"
                }
                Self::CannotRemoveWhileInUse => "CANNOT_REMOVE_WHILE_IN_USE",
                Self::CannotChangeType => "CANNOT_CHANGE_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NAME_ALREADY_USED" => Some(Self::NameAlreadyUsed),
                "CUSTOM_INTEREST_MEMBER_ID_AND_TYPE_PARAMETER_NOT_PRESENT_IN_REMOVE" => {
                    Some(Self::CustomInterestMemberIdAndTypeParameterNotPresentInRemove)
                }
                "TYPE_AND_PARAMETER_NOT_FOUND" => Some(Self::TypeAndParameterNotFound),
                "TYPE_AND_PARAMETER_ALREADY_EXISTED" => {
                    Some(Self::TypeAndParameterAlreadyExisted)
                }
                "INVALID_CUSTOM_INTEREST_MEMBER_TYPE" => {
                    Some(Self::InvalidCustomInterestMemberType)
                }
                "CANNOT_REMOVE_WHILE_IN_USE" => Some(Self::CannotRemoveWhileInUse),
                "CANNOT_CHANGE_TYPE" => Some(Self::CannotChangeType),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible CustomeClientLink errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerClientLinkErrorEnum {}
/// Nested message and enum types in `CustomerClientLinkErrorEnum`.
pub mod customer_client_link_error_enum {
    /// Enum describing possible CustomerClientLink errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerClientLinkError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Trying to manage a client that already in being managed by customer.
        ClientAlreadyInvitedByThisManager = 2,
        /// Already managed by some other manager in the hierarchy.
        ClientAlreadyManagedInHierarchy = 3,
        /// Attempt to create a cycle in the hierarchy.
        CyclicLinkNotAllowed = 4,
        /// Managed accounts has the maximum number of linked accounts.
        CustomerHasTooManyAccounts = 5,
        /// Invitor has the maximum pending invitations.
        ClientHasTooManyInvitations = 6,
        /// Attempt to change hidden status of a link that is not active.
        CannotHideOrUnhideManagerAccounts = 7,
        /// Parent manager account has the maximum number of linked accounts.
        CustomerHasTooManyAccountsAtManager = 8,
        /// Client has too many managers.
        ClientHasTooManyManagers = 9,
    }
    impl CustomerClientLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ClientAlreadyInvitedByThisManager => {
                    "CLIENT_ALREADY_INVITED_BY_THIS_MANAGER"
                }
                Self::ClientAlreadyManagedInHierarchy => {
                    "CLIENT_ALREADY_MANAGED_IN_HIERARCHY"
                }
                Self::CyclicLinkNotAllowed => "CYCLIC_LINK_NOT_ALLOWED",
                Self::CustomerHasTooManyAccounts => "CUSTOMER_HAS_TOO_MANY_ACCOUNTS",
                Self::ClientHasTooManyInvitations => "CLIENT_HAS_TOO_MANY_INVITATIONS",
                Self::CannotHideOrUnhideManagerAccounts => {
                    "CANNOT_HIDE_OR_UNHIDE_MANAGER_ACCOUNTS"
                }
                Self::CustomerHasTooManyAccountsAtManager => {
                    "CUSTOMER_HAS_TOO_MANY_ACCOUNTS_AT_MANAGER"
                }
                Self::ClientHasTooManyManagers => "CLIENT_HAS_TOO_MANY_MANAGERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CLIENT_ALREADY_INVITED_BY_THIS_MANAGER" => {
                    Some(Self::ClientAlreadyInvitedByThisManager)
                }
                "CLIENT_ALREADY_MANAGED_IN_HIERARCHY" => {
                    Some(Self::ClientAlreadyManagedInHierarchy)
                }
                "CYCLIC_LINK_NOT_ALLOWED" => Some(Self::CyclicLinkNotAllowed),
                "CUSTOMER_HAS_TOO_MANY_ACCOUNTS" => {
                    Some(Self::CustomerHasTooManyAccounts)
                }
                "CLIENT_HAS_TOO_MANY_INVITATIONS" => {
                    Some(Self::ClientHasTooManyInvitations)
                }
                "CANNOT_HIDE_OR_UNHIDE_MANAGER_ACCOUNTS" => {
                    Some(Self::CannotHideOrUnhideManagerAccounts)
                }
                "CUSTOMER_HAS_TOO_MANY_ACCOUNTS_AT_MANAGER" => {
                    Some(Self::CustomerHasTooManyAccountsAtManager)
                }
                "CLIENT_HAS_TOO_MANY_MANAGERS" => Some(Self::ClientHasTooManyManagers),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible customer customizer errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerCustomizerErrorEnum {}
/// Nested message and enum types in `CustomerCustomizerErrorEnum`.
pub mod customer_customizer_error_enum {
    /// Enum describing possible customer customizer errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerCustomizerError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
    }
    impl CustomerCustomizerError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible customer errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerErrorEnum {}
/// Nested message and enum types in `CustomerErrorEnum`.
pub mod customer_error_enum {
    /// Set of errors that are related to requests dealing with Customer.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Customer status is not allowed to be changed from DRAFT and CLOSED.
        /// Currency code and at least one of country code and time zone needs to be
        /// set when status is changed to ENABLED.
        StatusChangeDisallowed = 2,
        /// CustomerService cannot get a customer that has not been fully set up.
        AccountNotSetUp = 3,
    }
    impl CustomerError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::StatusChangeDisallowed => "STATUS_CHANGE_DISALLOWED",
                Self::AccountNotSetUp => "ACCOUNT_NOT_SET_UP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "STATUS_CHANGE_DISALLOWED" => Some(Self::StatusChangeDisallowed),
                "ACCOUNT_NOT_SET_UP" => Some(Self::AccountNotSetUp),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible customer feed errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerFeedErrorEnum {}
/// Nested message and enum types in `CustomerFeedErrorEnum`.
pub mod customer_feed_error_enum {
    /// Enum describing possible customer feed errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerFeedError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// An active feed already exists for this customer and place holder type.
        FeedAlreadyExistsForPlaceholderType = 2,
        /// The specified feed is removed.
        CannotCreateForRemovedFeed = 3,
        /// The CustomerFeed already exists. Update should be used to modify the
        /// existing CustomerFeed.
        CannotCreateAlreadyExistingCustomerFeed = 4,
        /// Cannot update removed customer feed.
        CannotModifyRemovedCustomerFeed = 5,
        /// Invalid placeholder type.
        InvalidPlaceholderType = 6,
        /// Feed mapping for this placeholder type does not exist.
        MissingFeedmappingForPlaceholderType = 7,
        /// Placeholder not allowed at the account level.
        PlaceholderTypeNotAllowedOnCustomerFeed = 8,
    }
    impl CustomerFeedError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::FeedAlreadyExistsForPlaceholderType => {
                    "FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE"
                }
                Self::CannotCreateForRemovedFeed => "CANNOT_CREATE_FOR_REMOVED_FEED",
                Self::CannotCreateAlreadyExistingCustomerFeed => {
                    "CANNOT_CREATE_ALREADY_EXISTING_CUSTOMER_FEED"
                }
                Self::CannotModifyRemovedCustomerFeed => {
                    "CANNOT_MODIFY_REMOVED_CUSTOMER_FEED"
                }
                Self::InvalidPlaceholderType => "INVALID_PLACEHOLDER_TYPE",
                Self::MissingFeedmappingForPlaceholderType => {
                    "MISSING_FEEDMAPPING_FOR_PLACEHOLDER_TYPE"
                }
                Self::PlaceholderTypeNotAllowedOnCustomerFeed => {
                    "PLACEHOLDER_TYPE_NOT_ALLOWED_ON_CUSTOMER_FEED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::FeedAlreadyExistsForPlaceholderType)
                }
                "CANNOT_CREATE_FOR_REMOVED_FEED" => {
                    Some(Self::CannotCreateForRemovedFeed)
                }
                "CANNOT_CREATE_ALREADY_EXISTING_CUSTOMER_FEED" => {
                    Some(Self::CannotCreateAlreadyExistingCustomerFeed)
                }
                "CANNOT_MODIFY_REMOVED_CUSTOMER_FEED" => {
                    Some(Self::CannotModifyRemovedCustomerFeed)
                }
                "INVALID_PLACEHOLDER_TYPE" => Some(Self::InvalidPlaceholderType),
                "MISSING_FEEDMAPPING_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::MissingFeedmappingForPlaceholderType)
                }
                "PLACEHOLDER_TYPE_NOT_ALLOWED_ON_CUSTOMER_FEED" => {
                    Some(Self::PlaceholderTypeNotAllowedOnCustomerFeed)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible customer lifecycle goal errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerLifecycleGoalErrorEnum {}
/// Nested message and enum types in `CustomerLifecycleGoalErrorEnum`.
pub mod customer_lifecycle_goal_error_enum {
    /// Enum describing possible customer lifecycle goal errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerLifecycleGoalError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// CustomerLifecycleGoal.customer_acquisition_goal_value_settings.value must
        /// be set.
        CustomerAcquisitionValueMissing = 2,
        /// CustomerLifecycleGoal.customer_acquisition_goal_value_settings.value must
        /// be no less than 0.01.
        CustomerAcquisitionInvalidValue = 3,
        /// CustomerLifecycleGoal.customer_acquisition_goal_value_settings.high_lifetime_value
        /// must be no less than 0.01. Also, to set this field,
        /// CustomerLifecycleGoal.customer_acquisition_goal_value_settings.value must
        /// also be present, and high_lifetime_value must be greater than value.
        CustomerAcquisitionInvalidHighLifetimeValue = 4,
        /// CustomerLifecycleGoal.customer_acquisition_goal_value_settings.value
        /// cannot be cleared. This value would have no effect as long as none of
        /// your campaigns adopt the customer acquisitiong goal.
        CustomerAcquisitionValueCannotBeCleared = 5,
        /// CustomerLifecycleGoal.customer_acquisition_goal_value_settings.high_lifetime_value
        /// cannot be cleared. This value would have no effect as long as none of
        /// your campaigns adopt the high value optimization of customer acquisitiong
        /// goal.
        CustomerAcquisitionHighLifetimeValueCannotBeCleared = 6,
        /// Found invalid value in
        /// CustomerLifecycleGoal.lifecycle_goal_customer_definition_settings.existing_user_lists.
        /// The userlist must be accessible, active and belong to one of the
        /// following types: CRM_BASED, RULE_BASED, REMARKETING.
        InvalidExistingUserList = 7,
        /// Found invalid value in
        /// CustomerLifecycleGoal.lifecycle_goal_customer_definition_settings.high_lifetime_value_user_lists.
        /// The userlist must be accessible, active and belong to one of the
        /// following types: CRM_BASED, RULE_BASED, REMARKETING.
        InvalidHighLifetimeValueUserList = 8,
    }
    impl CustomerLifecycleGoalError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CustomerAcquisitionValueMissing => {
                    "CUSTOMER_ACQUISITION_VALUE_MISSING"
                }
                Self::CustomerAcquisitionInvalidValue => {
                    "CUSTOMER_ACQUISITION_INVALID_VALUE"
                }
                Self::CustomerAcquisitionInvalidHighLifetimeValue => {
                    "CUSTOMER_ACQUISITION_INVALID_HIGH_LIFETIME_VALUE"
                }
                Self::CustomerAcquisitionValueCannotBeCleared => {
                    "CUSTOMER_ACQUISITION_VALUE_CANNOT_BE_CLEARED"
                }
                Self::CustomerAcquisitionHighLifetimeValueCannotBeCleared => {
                    "CUSTOMER_ACQUISITION_HIGH_LIFETIME_VALUE_CANNOT_BE_CLEARED"
                }
                Self::InvalidExistingUserList => "INVALID_EXISTING_USER_LIST",
                Self::InvalidHighLifetimeValueUserList => {
                    "INVALID_HIGH_LIFETIME_VALUE_USER_LIST"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOMER_ACQUISITION_VALUE_MISSING" => {
                    Some(Self::CustomerAcquisitionValueMissing)
                }
                "CUSTOMER_ACQUISITION_INVALID_VALUE" => {
                    Some(Self::CustomerAcquisitionInvalidValue)
                }
                "CUSTOMER_ACQUISITION_INVALID_HIGH_LIFETIME_VALUE" => {
                    Some(Self::CustomerAcquisitionInvalidHighLifetimeValue)
                }
                "CUSTOMER_ACQUISITION_VALUE_CANNOT_BE_CLEARED" => {
                    Some(Self::CustomerAcquisitionValueCannotBeCleared)
                }
                "CUSTOMER_ACQUISITION_HIGH_LIFETIME_VALUE_CANNOT_BE_CLEARED" => {
                    Some(Self::CustomerAcquisitionHighLifetimeValueCannotBeCleared)
                }
                "INVALID_EXISTING_USER_LIST" => Some(Self::InvalidExistingUserList),
                "INVALID_HIGH_LIFETIME_VALUE_USER_LIST" => {
                    Some(Self::InvalidHighLifetimeValueUserList)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible CustomerManagerLink errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerManagerLinkErrorEnum {}
/// Nested message and enum types in `CustomerManagerLinkErrorEnum`.
pub mod customer_manager_link_error_enum {
    /// Enum describing possible CustomerManagerLink errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerManagerLinkError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// No pending invitation.
        NoPendingInvite = 2,
        /// Attempt to operate on the same client more than once in the same call.
        SameClientMoreThanOncePerCall = 3,
        /// Manager account has the maximum number of linked accounts.
        ManagerHasMaxNumberOfLinkedAccounts = 4,
        /// If no active user on account it cannot be unlinked from its manager.
        CannotUnlinkAccountWithoutActiveUser = 5,
        /// Account should have at least one active owner on it before being
        /// unlinked.
        CannotRemoveLastClientAccountOwner = 6,
        /// Only account owners may change their permission role.
        CannotChangeRoleByNonAccountOwner = 7,
        /// When a client's link to its manager is not active, the link role cannot
        /// be changed.
        CannotChangeRoleForNonActiveLinkAccount = 8,
        /// Attempt to link a child to a parent that contains or will contain
        /// duplicate children.
        DuplicateChildFound = 9,
        /// The authorized customer is a test account. It can add no more than the
        /// allowed number of accounts
        TestAccountLinksTooManyChildAccounts = 10,
    }
    impl CustomerManagerLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NoPendingInvite => "NO_PENDING_INVITE",
                Self::SameClientMoreThanOncePerCall => {
                    "SAME_CLIENT_MORE_THAN_ONCE_PER_CALL"
                }
                Self::ManagerHasMaxNumberOfLinkedAccounts => {
                    "MANAGER_HAS_MAX_NUMBER_OF_LINKED_ACCOUNTS"
                }
                Self::CannotUnlinkAccountWithoutActiveUser => {
                    "CANNOT_UNLINK_ACCOUNT_WITHOUT_ACTIVE_USER"
                }
                Self::CannotRemoveLastClientAccountOwner => {
                    "CANNOT_REMOVE_LAST_CLIENT_ACCOUNT_OWNER"
                }
                Self::CannotChangeRoleByNonAccountOwner => {
                    "CANNOT_CHANGE_ROLE_BY_NON_ACCOUNT_OWNER"
                }
                Self::CannotChangeRoleForNonActiveLinkAccount => {
                    "CANNOT_CHANGE_ROLE_FOR_NON_ACTIVE_LINK_ACCOUNT"
                }
                Self::DuplicateChildFound => "DUPLICATE_CHILD_FOUND",
                Self::TestAccountLinksTooManyChildAccounts => {
                    "TEST_ACCOUNT_LINKS_TOO_MANY_CHILD_ACCOUNTS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NO_PENDING_INVITE" => Some(Self::NoPendingInvite),
                "SAME_CLIENT_MORE_THAN_ONCE_PER_CALL" => {
                    Some(Self::SameClientMoreThanOncePerCall)
                }
                "MANAGER_HAS_MAX_NUMBER_OF_LINKED_ACCOUNTS" => {
                    Some(Self::ManagerHasMaxNumberOfLinkedAccounts)
                }
                "CANNOT_UNLINK_ACCOUNT_WITHOUT_ACTIVE_USER" => {
                    Some(Self::CannotUnlinkAccountWithoutActiveUser)
                }
                "CANNOT_REMOVE_LAST_CLIENT_ACCOUNT_OWNER" => {
                    Some(Self::CannotRemoveLastClientAccountOwner)
                }
                "CANNOT_CHANGE_ROLE_BY_NON_ACCOUNT_OWNER" => {
                    Some(Self::CannotChangeRoleByNonAccountOwner)
                }
                "CANNOT_CHANGE_ROLE_FOR_NON_ACTIVE_LINK_ACCOUNT" => {
                    Some(Self::CannotChangeRoleForNonActiveLinkAccount)
                }
                "DUPLICATE_CHILD_FOUND" => Some(Self::DuplicateChildFound),
                "TEST_ACCOUNT_LINKS_TOO_MANY_CHILD_ACCOUNTS" => {
                    Some(Self::TestAccountLinksTooManyChildAccounts)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible
/// CustomerSkAdNetworkConversionValueSchema errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerSkAdNetworkConversionValueSchemaErrorEnum {}
/// Nested message and enum types in `CustomerSkAdNetworkConversionValueSchemaErrorEnum`.
pub mod customer_sk_ad_network_conversion_value_schema_error_enum {
    /// Enum describing possible CustomerSkAdNetworkConversionValueSchema errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerSkAdNetworkConversionValueSchemaError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The customer link ID provided is invalid.
        InvalidLinkId = 2,
        /// The app ID provided is invalid.
        InvalidAppId = 3,
        /// The conversion value schema provided is invalid.
        InvalidSchema = 4,
        /// The customer link id provided could not be found.
        LinkCodeNotFound = 5,
        /// The SkAdNetwork event counter provided is invalid.
        InvalidEventCounter = 7,
        /// The SkAdNetwork event name provided is invalid.
        InvalidEventName = 8,
    }
    impl CustomerSkAdNetworkConversionValueSchemaError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidLinkId => "INVALID_LINK_ID",
                Self::InvalidAppId => "INVALID_APP_ID",
                Self::InvalidSchema => "INVALID_SCHEMA",
                Self::LinkCodeNotFound => "LINK_CODE_NOT_FOUND",
                Self::InvalidEventCounter => "INVALID_EVENT_COUNTER",
                Self::InvalidEventName => "INVALID_EVENT_NAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_LINK_ID" => Some(Self::InvalidLinkId),
                "INVALID_APP_ID" => Some(Self::InvalidAppId),
                "INVALID_SCHEMA" => Some(Self::InvalidSchema),
                "LINK_CODE_NOT_FOUND" => Some(Self::LinkCodeNotFound),
                "INVALID_EVENT_COUNTER" => Some(Self::InvalidEventCounter),
                "INVALID_EVENT_NAME" => Some(Self::InvalidEventName),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible CustomerUserAccess errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerUserAccessErrorEnum {}
/// Nested message and enum types in `CustomerUserAccessErrorEnum`.
pub mod customer_user_access_error_enum {
    /// Enum describing possible customer user access errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerUserAccessError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// There is no user associated with the user id specified.
        InvalidUserId = 2,
        /// Unable to remove the access between the user and customer.
        RemovalDisallowed = 3,
        /// Unable to add or update the access role as specified.
        DisallowedAccessRole = 4,
        /// The user can't remove itself from an active serving customer if it's the
        /// last admin user and the customer doesn't have any owner manager
        LastAdminUserOfServingCustomer = 5,
        /// Last admin user cannot be removed from a manager.
        LastAdminUserOfManager = 6,
    }
    impl CustomerUserAccessError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidUserId => "INVALID_USER_ID",
                Self::RemovalDisallowed => "REMOVAL_DISALLOWED",
                Self::DisallowedAccessRole => "DISALLOWED_ACCESS_ROLE",
                Self::LastAdminUserOfServingCustomer => {
                    "LAST_ADMIN_USER_OF_SERVING_CUSTOMER"
                }
                Self::LastAdminUserOfManager => "LAST_ADMIN_USER_OF_MANAGER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_USER_ID" => Some(Self::InvalidUserId),
                "REMOVAL_DISALLOWED" => Some(Self::RemovalDisallowed),
                "DISALLOWED_ACCESS_ROLE" => Some(Self::DisallowedAccessRole),
                "LAST_ADMIN_USER_OF_SERVING_CUSTOMER" => {
                    Some(Self::LastAdminUserOfServingCustomer)
                }
                "LAST_ADMIN_USER_OF_MANAGER" => Some(Self::LastAdminUserOfManager),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible customizer attribute errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomizerAttributeErrorEnum {}
/// Nested message and enum types in `CustomizerAttributeErrorEnum`.
pub mod customizer_attribute_error_enum {
    /// Enum describing possible customizer attribute errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomizerAttributeError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// CustomizerAttribute name matches that of another active
        /// CustomizerAttribute.
        DuplicateCustomizerAttributeName = 2,
    }
    impl CustomizerAttributeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DuplicateCustomizerAttributeName => {
                    "DUPLICATE_CUSTOMIZER_ATTRIBUTE_NAME"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_CUSTOMIZER_ATTRIBUTE_NAME" => {
                    Some(Self::DuplicateCustomizerAttributeName)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible database errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DatabaseErrorEnum {}
/// Nested message and enum types in `DatabaseErrorEnum`.
pub mod database_error_enum {
    /// Enum describing possible database errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DatabaseError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Multiple requests were attempting to modify the same resource at once.
        /// Retry the request.
        ConcurrentModification = 2,
        /// The request conflicted with existing data. This error will usually be
        /// replaced with a more specific error if the request is retried.
        DataConstraintViolation = 3,
        /// The data written is too large. Split the request into smaller
        /// requests.
        RequestTooLarge = 4,
    }
    impl DatabaseError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ConcurrentModification => "CONCURRENT_MODIFICATION",
                Self::DataConstraintViolation => "DATA_CONSTRAINT_VIOLATION",
                Self::RequestTooLarge => "REQUEST_TOO_LARGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CONCURRENT_MODIFICATION" => Some(Self::ConcurrentModification),
                "DATA_CONSTRAINT_VIOLATION" => Some(Self::DataConstraintViolation),
                "REQUEST_TOO_LARGE" => Some(Self::RequestTooLarge),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible date errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DateErrorEnum {}
/// Nested message and enum types in `DateErrorEnum`.
pub mod date_error_enum {
    /// Enum describing possible date errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DateError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Given field values do not correspond to a valid date.
        InvalidFieldValuesInDate = 2,
        /// Given field values do not correspond to a valid date time.
        InvalidFieldValuesInDateTime = 3,
        /// The string date's format should be yyyy-mm-dd.
        InvalidStringDate = 4,
        /// The string date time's format should be yyyy-mm-dd hh:mm:ss.ssssss.
        InvalidStringDateTimeMicros = 6,
        /// The string date time's format should be yyyy-mm-dd hh:mm:ss.
        InvalidStringDateTimeSeconds = 11,
        /// The string date time's format should be yyyy-mm-dd hh:mm:ss+|-hh:mm.
        InvalidStringDateTimeSecondsWithOffset = 12,
        /// Date is before allowed minimum.
        EarlierThanMinimumDate = 7,
        /// Date is after allowed maximum.
        LaterThanMaximumDate = 8,
        /// Date range bounds are not in order.
        DateRangeMinimumDateLaterThanMaximumDate = 9,
        /// Both dates in range are null.
        DateRangeMinimumAndMaximumDatesBothNull = 10,
    }
    impl DateError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidFieldValuesInDate => "INVALID_FIELD_VALUES_IN_DATE",
                Self::InvalidFieldValuesInDateTime => "INVALID_FIELD_VALUES_IN_DATE_TIME",
                Self::InvalidStringDate => "INVALID_STRING_DATE",
                Self::InvalidStringDateTimeMicros => "INVALID_STRING_DATE_TIME_MICROS",
                Self::InvalidStringDateTimeSeconds => "INVALID_STRING_DATE_TIME_SECONDS",
                Self::InvalidStringDateTimeSecondsWithOffset => {
                    "INVALID_STRING_DATE_TIME_SECONDS_WITH_OFFSET"
                }
                Self::EarlierThanMinimumDate => "EARLIER_THAN_MINIMUM_DATE",
                Self::LaterThanMaximumDate => "LATER_THAN_MAXIMUM_DATE",
                Self::DateRangeMinimumDateLaterThanMaximumDate => {
                    "DATE_RANGE_MINIMUM_DATE_LATER_THAN_MAXIMUM_DATE"
                }
                Self::DateRangeMinimumAndMaximumDatesBothNull => {
                    "DATE_RANGE_MINIMUM_AND_MAXIMUM_DATES_BOTH_NULL"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_FIELD_VALUES_IN_DATE" => Some(Self::InvalidFieldValuesInDate),
                "INVALID_FIELD_VALUES_IN_DATE_TIME" => {
                    Some(Self::InvalidFieldValuesInDateTime)
                }
                "INVALID_STRING_DATE" => Some(Self::InvalidStringDate),
                "INVALID_STRING_DATE_TIME_MICROS" => {
                    Some(Self::InvalidStringDateTimeMicros)
                }
                "INVALID_STRING_DATE_TIME_SECONDS" => {
                    Some(Self::InvalidStringDateTimeSeconds)
                }
                "INVALID_STRING_DATE_TIME_SECONDS_WITH_OFFSET" => {
                    Some(Self::InvalidStringDateTimeSecondsWithOffset)
                }
                "EARLIER_THAN_MINIMUM_DATE" => Some(Self::EarlierThanMinimumDate),
                "LATER_THAN_MAXIMUM_DATE" => Some(Self::LaterThanMaximumDate),
                "DATE_RANGE_MINIMUM_DATE_LATER_THAN_MAXIMUM_DATE" => {
                    Some(Self::DateRangeMinimumDateLaterThanMaximumDate)
                }
                "DATE_RANGE_MINIMUM_AND_MAXIMUM_DATES_BOTH_NULL" => {
                    Some(Self::DateRangeMinimumAndMaximumDatesBothNull)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible date range errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DateRangeErrorEnum {}
/// Nested message and enum types in `DateRangeErrorEnum`.
pub mod date_range_error_enum {
    /// Enum describing possible date range errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DateRangeError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Invalid date.
        InvalidDate = 2,
        /// The start date was after the end date.
        StartDateAfterEndDate = 3,
        /// Cannot set date to past time
        CannotSetDateToPast = 4,
        /// A date was used that is past the system "last" date.
        AfterMaximumAllowableDate = 5,
        /// Trying to change start date on a resource that has started.
        CannotModifyStartDateIfAlreadyStarted = 6,
    }
    impl DateRangeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidDate => "INVALID_DATE",
                Self::StartDateAfterEndDate => "START_DATE_AFTER_END_DATE",
                Self::CannotSetDateToPast => "CANNOT_SET_DATE_TO_PAST",
                Self::AfterMaximumAllowableDate => "AFTER_MAXIMUM_ALLOWABLE_DATE",
                Self::CannotModifyStartDateIfAlreadyStarted => {
                    "CANNOT_MODIFY_START_DATE_IF_ALREADY_STARTED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_DATE" => Some(Self::InvalidDate),
                "START_DATE_AFTER_END_DATE" => Some(Self::StartDateAfterEndDate),
                "CANNOT_SET_DATE_TO_PAST" => Some(Self::CannotSetDateToPast),
                "AFTER_MAXIMUM_ALLOWABLE_DATE" => Some(Self::AfterMaximumAllowableDate),
                "CANNOT_MODIFY_START_DATE_IF_ALREADY_STARTED" => {
                    Some(Self::CannotModifyStartDateIfAlreadyStarted)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible distinct errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DistinctErrorEnum {}
/// Nested message and enum types in `DistinctErrorEnum`.
pub mod distinct_error_enum {
    /// Enum describing possible distinct errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DistinctError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Duplicate element.
        DuplicateElement = 2,
        /// Duplicate type.
        DuplicateType = 3,
    }
    impl DistinctError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DuplicateElement => "DUPLICATE_ELEMENT",
                Self::DuplicateType => "DUPLICATE_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_ELEMENT" => Some(Self::DuplicateElement),
                "DUPLICATE_TYPE" => Some(Self::DuplicateType),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible enum errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnumErrorEnum {}
/// Nested message and enum types in `EnumErrorEnum`.
pub mod enum_error_enum {
    /// Enum describing possible enum errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnumError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The enum value is not permitted.
        EnumValueNotPermitted = 3,
    }
    impl EnumError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::EnumValueNotPermitted => "ENUM_VALUE_NOT_PERMITTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENUM_VALUE_NOT_PERMITTED" => Some(Self::EnumValueNotPermitted),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible experiment arm error.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExperimentArmErrorEnum {}
/// Nested message and enum types in `ExperimentArmErrorEnum`.
pub mod experiment_arm_error_enum {
    /// Enum describing possible experiment arm errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExperimentArmError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Number of experiment arms is above limit.
        ExperimentArmCountLimitExceeded = 2,
        /// Cannot add campaign with invalid status to the experiment arm.
        InvalidCampaignStatus = 3,
        /// Cannot add duplicate experiment arm name in one experiment.
        DuplicateExperimentArmName = 4,
        /// Cannot set campaigns of treatment experiment arm.
        CannotSetTreatmentArmCampaign = 5,
        /// Cannot edit campaign ids in trial arms in non SETUP experiment.
        CannotModifyCampaignIds = 6,
        /// Cannot modify the campaigns in the control arm
        /// if there is not a suffix set in the trial.
        CannotModifyCampaignWithoutSuffixSet = 7,
        /// Traffic split related settings (like traffic share bounds) can't be
        /// modified after the trial has started.
        CannotMutateTrafficSplitAfterStart = 8,
        /// Cannot use shared budget on experiment's control campaign.
        CannotAddCampaignWithSharedBudget = 9,
        /// Cannot use custom budget on experiment's control campaigns.
        CannotAddCampaignWithCustomBudget = 10,
        /// Cannot have enable_dynamic_assets turned on in experiment's campaigns.
        CannotAddCampaignsWithDynamicAssetsEnabled = 11,
        /// Cannot use campaign's advertising channel sub type in experiment.
        UnsupportedCampaignAdvertisingChannelSubType = 12,
        /// Experiment date range must be within base campaign's date range.
        CannotAddBaseCampaignWithDateRange = 13,
        /// Bidding strategy is not supported in experiments.
        BiddingStrategyNotSupportedInExperiments = 14,
        /// Traffic split is not supported for some channel types.
        TrafficSplitNotSupportedForChannelType = 15,
    }
    impl ExperimentArmError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ExperimentArmCountLimitExceeded => {
                    "EXPERIMENT_ARM_COUNT_LIMIT_EXCEEDED"
                }
                Self::InvalidCampaignStatus => "INVALID_CAMPAIGN_STATUS",
                Self::DuplicateExperimentArmName => "DUPLICATE_EXPERIMENT_ARM_NAME",
                Self::CannotSetTreatmentArmCampaign => {
                    "CANNOT_SET_TREATMENT_ARM_CAMPAIGN"
                }
                Self::CannotModifyCampaignIds => "CANNOT_MODIFY_CAMPAIGN_IDS",
                Self::CannotModifyCampaignWithoutSuffixSet => {
                    "CANNOT_MODIFY_CAMPAIGN_WITHOUT_SUFFIX_SET"
                }
                Self::CannotMutateTrafficSplitAfterStart => {
                    "CANNOT_MUTATE_TRAFFIC_SPLIT_AFTER_START"
                }
                Self::CannotAddCampaignWithSharedBudget => {
                    "CANNOT_ADD_CAMPAIGN_WITH_SHARED_BUDGET"
                }
                Self::CannotAddCampaignWithCustomBudget => {
                    "CANNOT_ADD_CAMPAIGN_WITH_CUSTOM_BUDGET"
                }
                Self::CannotAddCampaignsWithDynamicAssetsEnabled => {
                    "CANNOT_ADD_CAMPAIGNS_WITH_DYNAMIC_ASSETS_ENABLED"
                }
                Self::UnsupportedCampaignAdvertisingChannelSubType => {
                    "UNSUPPORTED_CAMPAIGN_ADVERTISING_CHANNEL_SUB_TYPE"
                }
                Self::CannotAddBaseCampaignWithDateRange => {
                    "CANNOT_ADD_BASE_CAMPAIGN_WITH_DATE_RANGE"
                }
                Self::BiddingStrategyNotSupportedInExperiments => {
                    "BIDDING_STRATEGY_NOT_SUPPORTED_IN_EXPERIMENTS"
                }
                Self::TrafficSplitNotSupportedForChannelType => {
                    "TRAFFIC_SPLIT_NOT_SUPPORTED_FOR_CHANNEL_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXPERIMENT_ARM_COUNT_LIMIT_EXCEEDED" => {
                    Some(Self::ExperimentArmCountLimitExceeded)
                }
                "INVALID_CAMPAIGN_STATUS" => Some(Self::InvalidCampaignStatus),
                "DUPLICATE_EXPERIMENT_ARM_NAME" => Some(Self::DuplicateExperimentArmName),
                "CANNOT_SET_TREATMENT_ARM_CAMPAIGN" => {
                    Some(Self::CannotSetTreatmentArmCampaign)
                }
                "CANNOT_MODIFY_CAMPAIGN_IDS" => Some(Self::CannotModifyCampaignIds),
                "CANNOT_MODIFY_CAMPAIGN_WITHOUT_SUFFIX_SET" => {
                    Some(Self::CannotModifyCampaignWithoutSuffixSet)
                }
                "CANNOT_MUTATE_TRAFFIC_SPLIT_AFTER_START" => {
                    Some(Self::CannotMutateTrafficSplitAfterStart)
                }
                "CANNOT_ADD_CAMPAIGN_WITH_SHARED_BUDGET" => {
                    Some(Self::CannotAddCampaignWithSharedBudget)
                }
                "CANNOT_ADD_CAMPAIGN_WITH_CUSTOM_BUDGET" => {
                    Some(Self::CannotAddCampaignWithCustomBudget)
                }
                "CANNOT_ADD_CAMPAIGNS_WITH_DYNAMIC_ASSETS_ENABLED" => {
                    Some(Self::CannotAddCampaignsWithDynamicAssetsEnabled)
                }
                "UNSUPPORTED_CAMPAIGN_ADVERTISING_CHANNEL_SUB_TYPE" => {
                    Some(Self::UnsupportedCampaignAdvertisingChannelSubType)
                }
                "CANNOT_ADD_BASE_CAMPAIGN_WITH_DATE_RANGE" => {
                    Some(Self::CannotAddBaseCampaignWithDateRange)
                }
                "BIDDING_STRATEGY_NOT_SUPPORTED_IN_EXPERIMENTS" => {
                    Some(Self::BiddingStrategyNotSupportedInExperiments)
                }
                "TRAFFIC_SPLIT_NOT_SUPPORTED_FOR_CHANNEL_TYPE" => {
                    Some(Self::TrafficSplitNotSupportedForChannelType)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible experiment error.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExperimentErrorEnum {}
/// Nested message and enum types in `ExperimentErrorEnum`.
pub mod experiment_error_enum {
    /// Enum describing possible experiment errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExperimentError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The start date of an experiment cannot be set in the past.
        /// Use a start date in the future.
        CannotSetStartDateInPast = 2,
        /// The end date of an experiment is before its start date.
        /// Use an end date after the start date.
        EndDateBeforeStartDate = 3,
        /// The start date of an experiment is too far in the future.
        /// Use a start date no more than 1 year in the future.
        StartDateTooFarInFuture = 4,
        /// The experiment has the same name as an existing active experiment.
        DuplicateExperimentName = 5,
        /// Experiments can only be modified when they are ENABLED.
        CannotModifyRemovedExperiment = 6,
        /// The start date of an experiment cannot be modified if the existing start
        /// date has already passed.
        StartDateAlreadyPassed = 7,
        /// The end date of an experiment cannot be set in the past.
        CannotSetEndDateInPast = 8,
        /// The status of an experiment cannot be set to REMOVED.
        CannotSetStatusToRemoved = 9,
        /// The end date of an expired experiment cannot be modified.
        CannotModifyPastEndDate = 10,
        /// The status is invalid.
        InvalidStatus = 11,
        /// Experiment arm contains campaigns with invalid advertising channel type.
        InvalidCampaignChannelType = 12,
        /// A pair of trials share members and have overlapping date ranges.
        OverlappingMembersAndDateRange = 13,
        /// Experiment arm contains invalid traffic split.
        InvalidTrialArmTrafficSplit = 14,
        /// Experiment contains trial arms with overlapping traffic split.
        TrafficSplitOverlapping = 15,
        /// The total traffic split of trial arms is not equal to 100.
        SumTrialArmTrafficUnequalsToTrialTrafficSplitDenominator = 16,
        /// Traffic split related settings (like traffic share bounds) can't be
        /// modified after the experiment has started.
        CannotModifyTrafficSplitAfterStart = 17,
        /// The experiment could not be found.
        ExperimentNotFound = 18,
        /// Experiment has not begun.
        ExperimentNotYetStarted = 19,
        /// The experiment cannot have more than one control arm.
        CannotHaveMultipleControlArms = 20,
        /// The experiment doesn't set in-design campaigns.
        InDesignCampaignsNotSet = 21,
        /// Clients must use the graduate action to graduate experiments and cannot
        /// set the status to GRADUATED directly.
        CannotSetStatusToGraduated = 22,
        /// Cannot use shared budget on base campaign when scheduling an experiment.
        CannotCreateExperimentCampaignWithSharedBudget = 23,
        /// Cannot use custom budget on base campaign when scheduling an experiment.
        CannotCreateExperimentCampaignWithCustomBudget = 24,
        /// Invalid status transition.
        StatusTransitionInvalid = 25,
        /// The experiment campaign name conflicts with a pre-existing campaign.
        DuplicateExperimentCampaignName = 26,
        /// Cannot remove in creation experiments.
        CannotRemoveInCreationExperiment = 27,
        /// Cannot add campaign with deprecated ad types. Deprecated ad types:
        /// ENHANCED_DISPLAY, GALLERY, GMAIL, KEYWORDLESS, TEXT.
        CannotAddCampaignWithDeprecatedAdTypes = 28,
        /// Sync can only be enabled for supported experiment types. Supported
        /// experiment types: SEARCH_CUSTOM, DISPLAY_CUSTOM,
        /// DISPLAY_AUTOMATED_BIDDING_STRATEGY, SEARCH_AUTOMATED_BIDDING_STRATEGY.
        CannotEnableSyncForUnsupportedExperimentType = 29,
        /// Experiment length cannot be longer than max length.
        InvalidDurationForAnExperiment = 30,
    }
    impl ExperimentError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CannotSetStartDateInPast => "CANNOT_SET_START_DATE_IN_PAST",
                Self::EndDateBeforeStartDate => "END_DATE_BEFORE_START_DATE",
                Self::StartDateTooFarInFuture => "START_DATE_TOO_FAR_IN_FUTURE",
                Self::DuplicateExperimentName => "DUPLICATE_EXPERIMENT_NAME",
                Self::CannotModifyRemovedExperiment => "CANNOT_MODIFY_REMOVED_EXPERIMENT",
                Self::StartDateAlreadyPassed => "START_DATE_ALREADY_PASSED",
                Self::CannotSetEndDateInPast => "CANNOT_SET_END_DATE_IN_PAST",
                Self::CannotSetStatusToRemoved => "CANNOT_SET_STATUS_TO_REMOVED",
                Self::CannotModifyPastEndDate => "CANNOT_MODIFY_PAST_END_DATE",
                Self::InvalidStatus => "INVALID_STATUS",
                Self::InvalidCampaignChannelType => "INVALID_CAMPAIGN_CHANNEL_TYPE",
                Self::OverlappingMembersAndDateRange => {
                    "OVERLAPPING_MEMBERS_AND_DATE_RANGE"
                }
                Self::InvalidTrialArmTrafficSplit => "INVALID_TRIAL_ARM_TRAFFIC_SPLIT",
                Self::TrafficSplitOverlapping => "TRAFFIC_SPLIT_OVERLAPPING",
                Self::SumTrialArmTrafficUnequalsToTrialTrafficSplitDenominator => {
                    "SUM_TRIAL_ARM_TRAFFIC_UNEQUALS_TO_TRIAL_TRAFFIC_SPLIT_DENOMINATOR"
                }
                Self::CannotModifyTrafficSplitAfterStart => {
                    "CANNOT_MODIFY_TRAFFIC_SPLIT_AFTER_START"
                }
                Self::ExperimentNotFound => "EXPERIMENT_NOT_FOUND",
                Self::ExperimentNotYetStarted => "EXPERIMENT_NOT_YET_STARTED",
                Self::CannotHaveMultipleControlArms => {
                    "CANNOT_HAVE_MULTIPLE_CONTROL_ARMS"
                }
                Self::InDesignCampaignsNotSet => "IN_DESIGN_CAMPAIGNS_NOT_SET",
                Self::CannotSetStatusToGraduated => "CANNOT_SET_STATUS_TO_GRADUATED",
                Self::CannotCreateExperimentCampaignWithSharedBudget => {
                    "CANNOT_CREATE_EXPERIMENT_CAMPAIGN_WITH_SHARED_BUDGET"
                }
                Self::CannotCreateExperimentCampaignWithCustomBudget => {
                    "CANNOT_CREATE_EXPERIMENT_CAMPAIGN_WITH_CUSTOM_BUDGET"
                }
                Self::StatusTransitionInvalid => "STATUS_TRANSITION_INVALID",
                Self::DuplicateExperimentCampaignName => {
                    "DUPLICATE_EXPERIMENT_CAMPAIGN_NAME"
                }
                Self::CannotRemoveInCreationExperiment => {
                    "CANNOT_REMOVE_IN_CREATION_EXPERIMENT"
                }
                Self::CannotAddCampaignWithDeprecatedAdTypes => {
                    "CANNOT_ADD_CAMPAIGN_WITH_DEPRECATED_AD_TYPES"
                }
                Self::CannotEnableSyncForUnsupportedExperimentType => {
                    "CANNOT_ENABLE_SYNC_FOR_UNSUPPORTED_EXPERIMENT_TYPE"
                }
                Self::InvalidDurationForAnExperiment => {
                    "INVALID_DURATION_FOR_AN_EXPERIMENT"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_SET_START_DATE_IN_PAST" => Some(Self::CannotSetStartDateInPast),
                "END_DATE_BEFORE_START_DATE" => Some(Self::EndDateBeforeStartDate),
                "START_DATE_TOO_FAR_IN_FUTURE" => Some(Self::StartDateTooFarInFuture),
                "DUPLICATE_EXPERIMENT_NAME" => Some(Self::DuplicateExperimentName),
                "CANNOT_MODIFY_REMOVED_EXPERIMENT" => {
                    Some(Self::CannotModifyRemovedExperiment)
                }
                "START_DATE_ALREADY_PASSED" => Some(Self::StartDateAlreadyPassed),
                "CANNOT_SET_END_DATE_IN_PAST" => Some(Self::CannotSetEndDateInPast),
                "CANNOT_SET_STATUS_TO_REMOVED" => Some(Self::CannotSetStatusToRemoved),
                "CANNOT_MODIFY_PAST_END_DATE" => Some(Self::CannotModifyPastEndDate),
                "INVALID_STATUS" => Some(Self::InvalidStatus),
                "INVALID_CAMPAIGN_CHANNEL_TYPE" => Some(Self::InvalidCampaignChannelType),
                "OVERLAPPING_MEMBERS_AND_DATE_RANGE" => {
                    Some(Self::OverlappingMembersAndDateRange)
                }
                "INVALID_TRIAL_ARM_TRAFFIC_SPLIT" => {
                    Some(Self::InvalidTrialArmTrafficSplit)
                }
                "TRAFFIC_SPLIT_OVERLAPPING" => Some(Self::TrafficSplitOverlapping),
                "SUM_TRIAL_ARM_TRAFFIC_UNEQUALS_TO_TRIAL_TRAFFIC_SPLIT_DENOMINATOR" => {
                    Some(Self::SumTrialArmTrafficUnequalsToTrialTrafficSplitDenominator)
                }
                "CANNOT_MODIFY_TRAFFIC_SPLIT_AFTER_START" => {
                    Some(Self::CannotModifyTrafficSplitAfterStart)
                }
                "EXPERIMENT_NOT_FOUND" => Some(Self::ExperimentNotFound),
                "EXPERIMENT_NOT_YET_STARTED" => Some(Self::ExperimentNotYetStarted),
                "CANNOT_HAVE_MULTIPLE_CONTROL_ARMS" => {
                    Some(Self::CannotHaveMultipleControlArms)
                }
                "IN_DESIGN_CAMPAIGNS_NOT_SET" => Some(Self::InDesignCampaignsNotSet),
                "CANNOT_SET_STATUS_TO_GRADUATED" => {
                    Some(Self::CannotSetStatusToGraduated)
                }
                "CANNOT_CREATE_EXPERIMENT_CAMPAIGN_WITH_SHARED_BUDGET" => {
                    Some(Self::CannotCreateExperimentCampaignWithSharedBudget)
                }
                "CANNOT_CREATE_EXPERIMENT_CAMPAIGN_WITH_CUSTOM_BUDGET" => {
                    Some(Self::CannotCreateExperimentCampaignWithCustomBudget)
                }
                "STATUS_TRANSITION_INVALID" => Some(Self::StatusTransitionInvalid),
                "DUPLICATE_EXPERIMENT_CAMPAIGN_NAME" => {
                    Some(Self::DuplicateExperimentCampaignName)
                }
                "CANNOT_REMOVE_IN_CREATION_EXPERIMENT" => {
                    Some(Self::CannotRemoveInCreationExperiment)
                }
                "CANNOT_ADD_CAMPAIGN_WITH_DEPRECATED_AD_TYPES" => {
                    Some(Self::CannotAddCampaignWithDeprecatedAdTypes)
                }
                "CANNOT_ENABLE_SYNC_FOR_UNSUPPORTED_EXPERIMENT_TYPE" => {
                    Some(Self::CannotEnableSyncForUnsupportedExperimentType)
                }
                "INVALID_DURATION_FOR_AN_EXPERIMENT" => {
                    Some(Self::InvalidDurationForAnExperiment)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible extension feed item error.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExtensionFeedItemErrorEnum {}
/// Nested message and enum types in `ExtensionFeedItemErrorEnum`.
pub mod extension_feed_item_error_enum {
    /// Enum describing possible extension feed item errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExtensionFeedItemError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Value is not within the accepted range.
        ValueOutOfRange = 2,
        /// Url list is too long.
        UrlListTooLong = 3,
        /// Cannot have a geo targeting restriction without having geo targeting.
        CannotHaveRestrictionOnEmptyGeoTargeting = 4,
        /// Cannot simultaneously set sitelink field with final urls.
        CannotSetWithFinalUrls = 5,
        /// Must set field with final urls.
        CannotSetWithoutFinalUrls = 6,
        /// Phone number for a call extension is invalid.
        InvalidPhoneNumber = 7,
        /// Phone number for a call extension is not supported for the given country
        /// code.
        PhoneNumberNotSupportedForCountry = 8,
        /// A carrier specific number in short format is not allowed for call
        /// extensions.
        CarrierSpecificShortNumberNotAllowed = 9,
        /// Premium rate numbers are not allowed for call extensions.
        PremiumRateNumberNotAllowed = 10,
        /// Phone number type for a call extension is not allowed.
        /// For example, personal number is not allowed for a call extension in
        /// most regions.
        DisallowedNumberType = 11,
        /// Phone number for a call extension does not meet domestic format
        /// requirements.
        InvalidDomesticPhoneNumberFormat = 12,
        /// Vanity phone numbers (for example, those including letters) are not
        /// allowed for call extensions.
        VanityPhoneNumberNotAllowed = 13,
        /// Call conversion action provided for a call extension is invalid.
        InvalidCallConversionAction = 14,
        /// For a call extension, the customer is not on the allow-list for call
        /// tracking.
        CustomerNotOnAllowlistForCalltracking = 47,
        /// Call tracking is not supported for the given country for a call
        /// extension.
        CalltrackingNotSupportedForCountry = 16,
        /// Customer hasn't consented for call recording, which is required for
        /// creating/updating call feed items. See
        /// <https://support.google.com/google-ads/answer/7412639.>
        CustomerConsentForCallRecordingRequired = 17,
        /// App id provided for an app extension is invalid.
        InvalidAppId = 18,
        /// Quotation marks present in the review text for a review extension.
        QuotesInReviewExtensionSnippet = 19,
        /// Hyphen character present in the review text for a review extension.
        HyphensInReviewExtensionSnippet = 20,
        /// A denylisted review source name or url was provided for a review
        /// extension.
        ReviewExtensionSourceIneligible = 21,
        /// Review source name should not be found in the review text.
        SourceNameInReviewExtensionText = 22,
        /// Inconsistent currency codes.
        InconsistentCurrencyCodes = 23,
        /// Price extension cannot have duplicated headers.
        PriceExtensionHasDuplicatedHeaders = 24,
        /// Price item cannot have duplicated header and description.
        PriceItemHasDuplicatedHeaderAndDescription = 25,
        /// Price extension has too few items.
        PriceExtensionHasTooFewItems = 26,
        /// Price extension has too many items.
        PriceExtensionHasTooManyItems = 27,
        /// The input value is not currently supported.
        UnsupportedValue = 28,
        /// The input value is not currently supported in the selected language of an
        /// extension.
        UnsupportedValueInSelectedLanguage = 29,
        /// Unknown or unsupported device preference.
        InvalidDevicePreference = 30,
        /// Invalid feed item schedule end time (for example, endHour = 24 and
        /// endMinute != 0).
        InvalidScheduleEnd = 31,
        /// Date time zone does not match the account's time zone.
        DateTimeMustBeInAccountTimeZone = 32,
        /// Invalid structured snippet header.
        InvalidSnippetsHeader = 33,
        /// Cannot operate on removed feed item.
        CannotOperateOnRemovedFeedItem = 34,
        /// Phone number not supported when call tracking enabled for country.
        PhoneNumberNotSupportedWithCalltrackingForCountry = 35,
        /// Cannot set call_conversion_action while call_conversion_tracking_enabled
        /// is set to true.
        ConflictingCallConversionSettings = 36,
        /// The type of the input extension feed item doesn't match the existing
        /// extension feed item.
        ExtensionTypeMismatch = 37,
        /// The oneof field extension for example, subtype of extension feed item is
        /// required.
        ExtensionSubtypeRequired = 38,
        /// The referenced feed item is not mapped to a supported extension type.
        ExtensionTypeUnsupported = 39,
        /// Cannot operate on a Feed with more than one active FeedMapping.
        CannotOperateOnFeedWithMultipleMappings = 40,
        /// Cannot operate on a Feed that has key attributes.
        CannotOperateOnFeedWithKeyAttributes = 41,
        /// Input price is not in a valid format.
        InvalidPriceFormat = 42,
        /// The promotion time is invalid.
        PromotionInvalidTime = 43,
        /// This field has too many decimal places specified.
        TooManyDecimalPlacesSpecified = 44,
        /// Concrete sub type of ExtensionFeedItem is required for this operation.
        ConcreteExtensionTypeRequired = 45,
        /// Feed item schedule end time must be after start time.
        ScheduleEndNotAfterStart = 46,
    }
    impl ExtensionFeedItemError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ValueOutOfRange => "VALUE_OUT_OF_RANGE",
                Self::UrlListTooLong => "URL_LIST_TOO_LONG",
                Self::CannotHaveRestrictionOnEmptyGeoTargeting => {
                    "CANNOT_HAVE_RESTRICTION_ON_EMPTY_GEO_TARGETING"
                }
                Self::CannotSetWithFinalUrls => "CANNOT_SET_WITH_FINAL_URLS",
                Self::CannotSetWithoutFinalUrls => "CANNOT_SET_WITHOUT_FINAL_URLS",
                Self::InvalidPhoneNumber => "INVALID_PHONE_NUMBER",
                Self::PhoneNumberNotSupportedForCountry => {
                    "PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY"
                }
                Self::CarrierSpecificShortNumberNotAllowed => {
                    "CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED"
                }
                Self::PremiumRateNumberNotAllowed => "PREMIUM_RATE_NUMBER_NOT_ALLOWED",
                Self::DisallowedNumberType => "DISALLOWED_NUMBER_TYPE",
                Self::InvalidDomesticPhoneNumberFormat => {
                    "INVALID_DOMESTIC_PHONE_NUMBER_FORMAT"
                }
                Self::VanityPhoneNumberNotAllowed => "VANITY_PHONE_NUMBER_NOT_ALLOWED",
                Self::InvalidCallConversionAction => "INVALID_CALL_CONVERSION_ACTION",
                Self::CustomerNotOnAllowlistForCalltracking => {
                    "CUSTOMER_NOT_ON_ALLOWLIST_FOR_CALLTRACKING"
                }
                Self::CalltrackingNotSupportedForCountry => {
                    "CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY"
                }
                Self::CustomerConsentForCallRecordingRequired => {
                    "CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED"
                }
                Self::InvalidAppId => "INVALID_APP_ID",
                Self::QuotesInReviewExtensionSnippet => {
                    "QUOTES_IN_REVIEW_EXTENSION_SNIPPET"
                }
                Self::HyphensInReviewExtensionSnippet => {
                    "HYPHENS_IN_REVIEW_EXTENSION_SNIPPET"
                }
                Self::ReviewExtensionSourceIneligible => {
                    "REVIEW_EXTENSION_SOURCE_INELIGIBLE"
                }
                Self::SourceNameInReviewExtensionText => {
                    "SOURCE_NAME_IN_REVIEW_EXTENSION_TEXT"
                }
                Self::InconsistentCurrencyCodes => "INCONSISTENT_CURRENCY_CODES",
                Self::PriceExtensionHasDuplicatedHeaders => {
                    "PRICE_EXTENSION_HAS_DUPLICATED_HEADERS"
                }
                Self::PriceItemHasDuplicatedHeaderAndDescription => {
                    "PRICE_ITEM_HAS_DUPLICATED_HEADER_AND_DESCRIPTION"
                }
                Self::PriceExtensionHasTooFewItems => "PRICE_EXTENSION_HAS_TOO_FEW_ITEMS",
                Self::PriceExtensionHasTooManyItems => {
                    "PRICE_EXTENSION_HAS_TOO_MANY_ITEMS"
                }
                Self::UnsupportedValue => "UNSUPPORTED_VALUE",
                Self::UnsupportedValueInSelectedLanguage => {
                    "UNSUPPORTED_VALUE_IN_SELECTED_LANGUAGE"
                }
                Self::InvalidDevicePreference => "INVALID_DEVICE_PREFERENCE",
                Self::InvalidScheduleEnd => "INVALID_SCHEDULE_END",
                Self::DateTimeMustBeInAccountTimeZone => {
                    "DATE_TIME_MUST_BE_IN_ACCOUNT_TIME_ZONE"
                }
                Self::InvalidSnippetsHeader => "INVALID_SNIPPETS_HEADER",
                Self::CannotOperateOnRemovedFeedItem => {
                    "CANNOT_OPERATE_ON_REMOVED_FEED_ITEM"
                }
                Self::PhoneNumberNotSupportedWithCalltrackingForCountry => {
                    "PHONE_NUMBER_NOT_SUPPORTED_WITH_CALLTRACKING_FOR_COUNTRY"
                }
                Self::ConflictingCallConversionSettings => {
                    "CONFLICTING_CALL_CONVERSION_SETTINGS"
                }
                Self::ExtensionTypeMismatch => "EXTENSION_TYPE_MISMATCH",
                Self::ExtensionSubtypeRequired => "EXTENSION_SUBTYPE_REQUIRED",
                Self::ExtensionTypeUnsupported => "EXTENSION_TYPE_UNSUPPORTED",
                Self::CannotOperateOnFeedWithMultipleMappings => {
                    "CANNOT_OPERATE_ON_FEED_WITH_MULTIPLE_MAPPINGS"
                }
                Self::CannotOperateOnFeedWithKeyAttributes => {
                    "CANNOT_OPERATE_ON_FEED_WITH_KEY_ATTRIBUTES"
                }
                Self::InvalidPriceFormat => "INVALID_PRICE_FORMAT",
                Self::PromotionInvalidTime => "PROMOTION_INVALID_TIME",
                Self::TooManyDecimalPlacesSpecified => {
                    "TOO_MANY_DECIMAL_PLACES_SPECIFIED"
                }
                Self::ConcreteExtensionTypeRequired => "CONCRETE_EXTENSION_TYPE_REQUIRED",
                Self::ScheduleEndNotAfterStart => "SCHEDULE_END_NOT_AFTER_START",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "VALUE_OUT_OF_RANGE" => Some(Self::ValueOutOfRange),
                "URL_LIST_TOO_LONG" => Some(Self::UrlListTooLong),
                "CANNOT_HAVE_RESTRICTION_ON_EMPTY_GEO_TARGETING" => {
                    Some(Self::CannotHaveRestrictionOnEmptyGeoTargeting)
                }
                "CANNOT_SET_WITH_FINAL_URLS" => Some(Self::CannotSetWithFinalUrls),
                "CANNOT_SET_WITHOUT_FINAL_URLS" => Some(Self::CannotSetWithoutFinalUrls),
                "INVALID_PHONE_NUMBER" => Some(Self::InvalidPhoneNumber),
                "PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::PhoneNumberNotSupportedForCountry)
                }
                "CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED" => {
                    Some(Self::CarrierSpecificShortNumberNotAllowed)
                }
                "PREMIUM_RATE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::PremiumRateNumberNotAllowed)
                }
                "DISALLOWED_NUMBER_TYPE" => Some(Self::DisallowedNumberType),
                "INVALID_DOMESTIC_PHONE_NUMBER_FORMAT" => {
                    Some(Self::InvalidDomesticPhoneNumberFormat)
                }
                "VANITY_PHONE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::VanityPhoneNumberNotAllowed)
                }
                "INVALID_CALL_CONVERSION_ACTION" => {
                    Some(Self::InvalidCallConversionAction)
                }
                "CUSTOMER_NOT_ON_ALLOWLIST_FOR_CALLTRACKING" => {
                    Some(Self::CustomerNotOnAllowlistForCalltracking)
                }
                "CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::CalltrackingNotSupportedForCountry)
                }
                "CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED" => {
                    Some(Self::CustomerConsentForCallRecordingRequired)
                }
                "INVALID_APP_ID" => Some(Self::InvalidAppId),
                "QUOTES_IN_REVIEW_EXTENSION_SNIPPET" => {
                    Some(Self::QuotesInReviewExtensionSnippet)
                }
                "HYPHENS_IN_REVIEW_EXTENSION_SNIPPET" => {
                    Some(Self::HyphensInReviewExtensionSnippet)
                }
                "REVIEW_EXTENSION_SOURCE_INELIGIBLE" => {
                    Some(Self::ReviewExtensionSourceIneligible)
                }
                "SOURCE_NAME_IN_REVIEW_EXTENSION_TEXT" => {
                    Some(Self::SourceNameInReviewExtensionText)
                }
                "INCONSISTENT_CURRENCY_CODES" => Some(Self::InconsistentCurrencyCodes),
                "PRICE_EXTENSION_HAS_DUPLICATED_HEADERS" => {
                    Some(Self::PriceExtensionHasDuplicatedHeaders)
                }
                "PRICE_ITEM_HAS_DUPLICATED_HEADER_AND_DESCRIPTION" => {
                    Some(Self::PriceItemHasDuplicatedHeaderAndDescription)
                }
                "PRICE_EXTENSION_HAS_TOO_FEW_ITEMS" => {
                    Some(Self::PriceExtensionHasTooFewItems)
                }
                "PRICE_EXTENSION_HAS_TOO_MANY_ITEMS" => {
                    Some(Self::PriceExtensionHasTooManyItems)
                }
                "UNSUPPORTED_VALUE" => Some(Self::UnsupportedValue),
                "UNSUPPORTED_VALUE_IN_SELECTED_LANGUAGE" => {
                    Some(Self::UnsupportedValueInSelectedLanguage)
                }
                "INVALID_DEVICE_PREFERENCE" => Some(Self::InvalidDevicePreference),
                "INVALID_SCHEDULE_END" => Some(Self::InvalidScheduleEnd),
                "DATE_TIME_MUST_BE_IN_ACCOUNT_TIME_ZONE" => {
                    Some(Self::DateTimeMustBeInAccountTimeZone)
                }
                "INVALID_SNIPPETS_HEADER" => Some(Self::InvalidSnippetsHeader),
                "CANNOT_OPERATE_ON_REMOVED_FEED_ITEM" => {
                    Some(Self::CannotOperateOnRemovedFeedItem)
                }
                "PHONE_NUMBER_NOT_SUPPORTED_WITH_CALLTRACKING_FOR_COUNTRY" => {
                    Some(Self::PhoneNumberNotSupportedWithCalltrackingForCountry)
                }
                "CONFLICTING_CALL_CONVERSION_SETTINGS" => {
                    Some(Self::ConflictingCallConversionSettings)
                }
                "EXTENSION_TYPE_MISMATCH" => Some(Self::ExtensionTypeMismatch),
                "EXTENSION_SUBTYPE_REQUIRED" => Some(Self::ExtensionSubtypeRequired),
                "EXTENSION_TYPE_UNSUPPORTED" => Some(Self::ExtensionTypeUnsupported),
                "CANNOT_OPERATE_ON_FEED_WITH_MULTIPLE_MAPPINGS" => {
                    Some(Self::CannotOperateOnFeedWithMultipleMappings)
                }
                "CANNOT_OPERATE_ON_FEED_WITH_KEY_ATTRIBUTES" => {
                    Some(Self::CannotOperateOnFeedWithKeyAttributes)
                }
                "INVALID_PRICE_FORMAT" => Some(Self::InvalidPriceFormat),
                "PROMOTION_INVALID_TIME" => Some(Self::PromotionInvalidTime),
                "TOO_MANY_DECIMAL_PLACES_SPECIFIED" => {
                    Some(Self::TooManyDecimalPlacesSpecified)
                }
                "CONCRETE_EXTENSION_TYPE_REQUIRED" => {
                    Some(Self::ConcreteExtensionTypeRequired)
                }
                "SCHEDULE_END_NOT_AFTER_START" => Some(Self::ScheduleEndNotAfterStart),
                _ => None,
            }
        }
    }
}
/// Container for enum describing validation errors of extension settings.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExtensionSettingErrorEnum {}
/// Nested message and enum types in `ExtensionSettingErrorEnum`.
pub mod extension_setting_error_enum {
    /// Enum describing possible extension setting errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExtensionSettingError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// A platform restriction was provided without input extensions or existing
        /// extensions.
        ExtensionsRequired = 2,
        /// The provided feed type does not correspond to the provided extensions.
        FeedTypeExtensionTypeMismatch = 3,
        /// The provided feed type cannot be used.
        InvalidFeedType = 4,
        /// The provided feed type cannot be used at the customer level.
        InvalidFeedTypeForCustomerExtensionSetting = 5,
        /// Cannot change a feed item field on a CREATE operation.
        CannotChangeFeedItemOnCreate = 6,
        /// Cannot update an extension that is not already in this setting.
        CannotUpdateNewlyCreatedExtension = 7,
        /// There is no existing AdGroupExtensionSetting for this type.
        NoExistingAdGroupExtensionSettingForType = 8,
        /// There is no existing CampaignExtensionSetting for this type.
        NoExistingCampaignExtensionSettingForType = 9,
        /// There is no existing CustomerExtensionSetting for this type.
        NoExistingCustomerExtensionSettingForType = 10,
        /// The AdGroupExtensionSetting already exists. UPDATE should be used to
        /// modify the existing AdGroupExtensionSetting.
        AdGroupExtensionSettingAlreadyExists = 11,
        /// The CampaignExtensionSetting already exists. UPDATE should be used to
        /// modify the existing CampaignExtensionSetting.
        CampaignExtensionSettingAlreadyExists = 12,
        /// The CustomerExtensionSetting already exists. UPDATE should be used to
        /// modify the existing CustomerExtensionSetting.
        CustomerExtensionSettingAlreadyExists = 13,
        /// An active ad group feed already exists for this place holder type.
        AdGroupFeedAlreadyExistsForPlaceholderType = 14,
        /// An active campaign feed already exists for this place holder type.
        CampaignFeedAlreadyExistsForPlaceholderType = 15,
        /// An active customer feed already exists for this place holder type.
        CustomerFeedAlreadyExistsForPlaceholderType = 16,
        /// Value is not within the accepted range.
        ValueOutOfRange = 17,
        /// Cannot simultaneously set specified field with final urls.
        CannotSetFieldWithFinalUrls = 18,
        /// Must set field with final urls.
        FinalUrlsNotSet = 19,
        /// Phone number for a call extension is invalid.
        InvalidPhoneNumber = 20,
        /// Phone number for a call extension is not supported for the given country
        /// code.
        PhoneNumberNotSupportedForCountry = 21,
        /// A carrier specific number in short format is not allowed for call
        /// extensions.
        CarrierSpecificShortNumberNotAllowed = 22,
        /// Premium rate numbers are not allowed for call extensions.
        PremiumRateNumberNotAllowed = 23,
        /// Phone number type for a call extension is not allowed.
        DisallowedNumberType = 24,
        /// Phone number for a call extension does not meet domestic format
        /// requirements.
        InvalidDomesticPhoneNumberFormat = 25,
        /// Vanity phone numbers (for example, those including letters) are not
        /// allowed for call extensions.
        VanityPhoneNumberNotAllowed = 26,
        /// Country code provided for a call extension is invalid.
        InvalidCountryCode = 27,
        /// Call conversion type id provided for a call extension is invalid.
        InvalidCallConversionTypeId = 28,
        /// For a call extension, the customer is not on the allow-list for call
        /// tracking.
        CustomerNotInAllowlistForCalltracking = 69,
        /// Call tracking is not supported for the given country for a call
        /// extension.
        CalltrackingNotSupportedForCountry = 30,
        /// App id provided for an app extension is invalid.
        InvalidAppId = 31,
        /// Quotation marks present in the review text for a review extension.
        QuotesInReviewExtensionSnippet = 32,
        /// Hyphen character present in the review text for a review extension.
        HyphensInReviewExtensionSnippet = 33,
        /// A blocked review source name or url was provided for a review
        /// extension.
        ReviewExtensionSourceNotEligible = 34,
        /// Review source name should not be found in the review text.
        SourceNameInReviewExtensionText = 35,
        /// Field must be set.
        MissingField = 36,
        /// Inconsistent currency codes.
        InconsistentCurrencyCodes = 37,
        /// Price extension cannot have duplicated headers.
        PriceExtensionHasDuplicatedHeaders = 38,
        /// Price item cannot have duplicated header and description.
        PriceItemHasDuplicatedHeaderAndDescription = 39,
        /// Price extension has too few items
        PriceExtensionHasTooFewItems = 40,
        /// Price extension has too many items
        PriceExtensionHasTooManyItems = 41,
        /// The input value is not currently supported.
        UnsupportedValue = 42,
        /// Unknown or unsupported device preference.
        InvalidDevicePreference = 43,
        /// Invalid feed item schedule end time (for example, endHour = 24 and
        /// endMinute != 0).
        InvalidScheduleEnd = 45,
        /// Date time zone does not match the account's time zone.
        DateTimeMustBeInAccountTimeZone = 47,
        /// Overlapping feed item schedule times (for example, 7-10AM and 8-11AM) are
        /// not allowed.
        OverlappingSchedulesNotAllowed = 48,
        /// Feed item schedule end time must be after start time.
        ScheduleEndNotAfterStart = 49,
        /// There are too many feed item schedules per day.
        TooManySchedulesPerDay = 50,
        /// Cannot edit the same extension feed item more than once in the same
        /// request.
        DuplicateExtensionFeedItemEdit = 51,
        /// Invalid structured snippet header.
        InvalidSnippetsHeader = 52,
        /// Phone number with call tracking enabled is not supported for the
        /// specified country.
        PhoneNumberNotSupportedWithCalltrackingForCountry = 53,
        /// The targeted adgroup must belong to the targeted campaign.
        CampaignTargetingMismatch = 54,
        /// The feed used by the ExtensionSetting is removed and cannot be operated
        /// on. Remove the ExtensionSetting to allow a new one to be created using
        /// an active feed.
        CannotOperateOnRemovedFeed = 55,
        /// The ExtensionFeedItem type is required for this operation.
        ExtensionTypeRequired = 56,
        /// The matching function that links the extension feed to the customer,
        /// campaign, or ad group is not compatible with the ExtensionSetting
        /// services.
        IncompatibleUnderlyingMatchingFunction = 57,
        /// Start date must be before end date.
        StartDateAfterEndDate = 58,
        /// Input price is not in a valid format.
        InvalidPriceFormat = 59,
        /// The promotion time is invalid.
        PromotionInvalidTime = 60,
        /// Cannot set both percent discount and money discount fields.
        PromotionCannotSetPercentDiscountAndMoneyDiscount = 61,
        /// Cannot set both promotion code and orders over amount fields.
        PromotionCannotSetPromotionCodeAndOrdersOverAmount = 62,
        /// This field has too many decimal places specified.
        TooManyDecimalPlacesSpecified = 63,
        /// The language code is not valid.
        InvalidLanguageCode = 64,
        /// The language is not supported.
        UnsupportedLanguage = 65,
        /// Customer hasn't consented for call recording, which is required for
        /// adding/updating call extensions. See
        /// <https://support.google.com/google-ads/answer/7412639.>
        CustomerConsentForCallRecordingRequired = 66,
        /// The UPDATE operation does not specify any fields other than the resource
        /// name in the update mask.
        ExtensionSettingUpdateIsANoop = 67,
        /// The extension contains text which has been prohibited on policy grounds.
        DisallowedText = 68,
    }
    impl ExtensionSettingError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ExtensionsRequired => "EXTENSIONS_REQUIRED",
                Self::FeedTypeExtensionTypeMismatch => {
                    "FEED_TYPE_EXTENSION_TYPE_MISMATCH"
                }
                Self::InvalidFeedType => "INVALID_FEED_TYPE",
                Self::InvalidFeedTypeForCustomerExtensionSetting => {
                    "INVALID_FEED_TYPE_FOR_CUSTOMER_EXTENSION_SETTING"
                }
                Self::CannotChangeFeedItemOnCreate => "CANNOT_CHANGE_FEED_ITEM_ON_CREATE",
                Self::CannotUpdateNewlyCreatedExtension => {
                    "CANNOT_UPDATE_NEWLY_CREATED_EXTENSION"
                }
                Self::NoExistingAdGroupExtensionSettingForType => {
                    "NO_EXISTING_AD_GROUP_EXTENSION_SETTING_FOR_TYPE"
                }
                Self::NoExistingCampaignExtensionSettingForType => {
                    "NO_EXISTING_CAMPAIGN_EXTENSION_SETTING_FOR_TYPE"
                }
                Self::NoExistingCustomerExtensionSettingForType => {
                    "NO_EXISTING_CUSTOMER_EXTENSION_SETTING_FOR_TYPE"
                }
                Self::AdGroupExtensionSettingAlreadyExists => {
                    "AD_GROUP_EXTENSION_SETTING_ALREADY_EXISTS"
                }
                Self::CampaignExtensionSettingAlreadyExists => {
                    "CAMPAIGN_EXTENSION_SETTING_ALREADY_EXISTS"
                }
                Self::CustomerExtensionSettingAlreadyExists => {
                    "CUSTOMER_EXTENSION_SETTING_ALREADY_EXISTS"
                }
                Self::AdGroupFeedAlreadyExistsForPlaceholderType => {
                    "AD_GROUP_FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE"
                }
                Self::CampaignFeedAlreadyExistsForPlaceholderType => {
                    "CAMPAIGN_FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE"
                }
                Self::CustomerFeedAlreadyExistsForPlaceholderType => {
                    "CUSTOMER_FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE"
                }
                Self::ValueOutOfRange => "VALUE_OUT_OF_RANGE",
                Self::CannotSetFieldWithFinalUrls => "CANNOT_SET_FIELD_WITH_FINAL_URLS",
                Self::FinalUrlsNotSet => "FINAL_URLS_NOT_SET",
                Self::InvalidPhoneNumber => "INVALID_PHONE_NUMBER",
                Self::PhoneNumberNotSupportedForCountry => {
                    "PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY"
                }
                Self::CarrierSpecificShortNumberNotAllowed => {
                    "CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED"
                }
                Self::PremiumRateNumberNotAllowed => "PREMIUM_RATE_NUMBER_NOT_ALLOWED",
                Self::DisallowedNumberType => "DISALLOWED_NUMBER_TYPE",
                Self::InvalidDomesticPhoneNumberFormat => {
                    "INVALID_DOMESTIC_PHONE_NUMBER_FORMAT"
                }
                Self::VanityPhoneNumberNotAllowed => "VANITY_PHONE_NUMBER_NOT_ALLOWED",
                Self::InvalidCountryCode => "INVALID_COUNTRY_CODE",
                Self::InvalidCallConversionTypeId => "INVALID_CALL_CONVERSION_TYPE_ID",
                Self::CustomerNotInAllowlistForCalltracking => {
                    "CUSTOMER_NOT_IN_ALLOWLIST_FOR_CALLTRACKING"
                }
                Self::CalltrackingNotSupportedForCountry => {
                    "CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY"
                }
                Self::InvalidAppId => "INVALID_APP_ID",
                Self::QuotesInReviewExtensionSnippet => {
                    "QUOTES_IN_REVIEW_EXTENSION_SNIPPET"
                }
                Self::HyphensInReviewExtensionSnippet => {
                    "HYPHENS_IN_REVIEW_EXTENSION_SNIPPET"
                }
                Self::ReviewExtensionSourceNotEligible => {
                    "REVIEW_EXTENSION_SOURCE_NOT_ELIGIBLE"
                }
                Self::SourceNameInReviewExtensionText => {
                    "SOURCE_NAME_IN_REVIEW_EXTENSION_TEXT"
                }
                Self::MissingField => "MISSING_FIELD",
                Self::InconsistentCurrencyCodes => "INCONSISTENT_CURRENCY_CODES",
                Self::PriceExtensionHasDuplicatedHeaders => {
                    "PRICE_EXTENSION_HAS_DUPLICATED_HEADERS"
                }
                Self::PriceItemHasDuplicatedHeaderAndDescription => {
                    "PRICE_ITEM_HAS_DUPLICATED_HEADER_AND_DESCRIPTION"
                }
                Self::PriceExtensionHasTooFewItems => "PRICE_EXTENSION_HAS_TOO_FEW_ITEMS",
                Self::PriceExtensionHasTooManyItems => {
                    "PRICE_EXTENSION_HAS_TOO_MANY_ITEMS"
                }
                Self::UnsupportedValue => "UNSUPPORTED_VALUE",
                Self::InvalidDevicePreference => "INVALID_DEVICE_PREFERENCE",
                Self::InvalidScheduleEnd => "INVALID_SCHEDULE_END",
                Self::DateTimeMustBeInAccountTimeZone => {
                    "DATE_TIME_MUST_BE_IN_ACCOUNT_TIME_ZONE"
                }
                Self::OverlappingSchedulesNotAllowed => {
                    "OVERLAPPING_SCHEDULES_NOT_ALLOWED"
                }
                Self::ScheduleEndNotAfterStart => "SCHEDULE_END_NOT_AFTER_START",
                Self::TooManySchedulesPerDay => "TOO_MANY_SCHEDULES_PER_DAY",
                Self::DuplicateExtensionFeedItemEdit => {
                    "DUPLICATE_EXTENSION_FEED_ITEM_EDIT"
                }
                Self::InvalidSnippetsHeader => "INVALID_SNIPPETS_HEADER",
                Self::PhoneNumberNotSupportedWithCalltrackingForCountry => {
                    "PHONE_NUMBER_NOT_SUPPORTED_WITH_CALLTRACKING_FOR_COUNTRY"
                }
                Self::CampaignTargetingMismatch => "CAMPAIGN_TARGETING_MISMATCH",
                Self::CannotOperateOnRemovedFeed => "CANNOT_OPERATE_ON_REMOVED_FEED",
                Self::ExtensionTypeRequired => "EXTENSION_TYPE_REQUIRED",
                Self::IncompatibleUnderlyingMatchingFunction => {
                    "INCOMPATIBLE_UNDERLYING_MATCHING_FUNCTION"
                }
                Self::StartDateAfterEndDate => "START_DATE_AFTER_END_DATE",
                Self::InvalidPriceFormat => "INVALID_PRICE_FORMAT",
                Self::PromotionInvalidTime => "PROMOTION_INVALID_TIME",
                Self::PromotionCannotSetPercentDiscountAndMoneyDiscount => {
                    "PROMOTION_CANNOT_SET_PERCENT_DISCOUNT_AND_MONEY_DISCOUNT"
                }
                Self::PromotionCannotSetPromotionCodeAndOrdersOverAmount => {
                    "PROMOTION_CANNOT_SET_PROMOTION_CODE_AND_ORDERS_OVER_AMOUNT"
                }
                Self::TooManyDecimalPlacesSpecified => {
                    "TOO_MANY_DECIMAL_PLACES_SPECIFIED"
                }
                Self::InvalidLanguageCode => "INVALID_LANGUAGE_CODE",
                Self::UnsupportedLanguage => "UNSUPPORTED_LANGUAGE",
                Self::CustomerConsentForCallRecordingRequired => {
                    "CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED"
                }
                Self::ExtensionSettingUpdateIsANoop => {
                    "EXTENSION_SETTING_UPDATE_IS_A_NOOP"
                }
                Self::DisallowedText => "DISALLOWED_TEXT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXTENSIONS_REQUIRED" => Some(Self::ExtensionsRequired),
                "FEED_TYPE_EXTENSION_TYPE_MISMATCH" => {
                    Some(Self::FeedTypeExtensionTypeMismatch)
                }
                "INVALID_FEED_TYPE" => Some(Self::InvalidFeedType),
                "INVALID_FEED_TYPE_FOR_CUSTOMER_EXTENSION_SETTING" => {
                    Some(Self::InvalidFeedTypeForCustomerExtensionSetting)
                }
                "CANNOT_CHANGE_FEED_ITEM_ON_CREATE" => {
                    Some(Self::CannotChangeFeedItemOnCreate)
                }
                "CANNOT_UPDATE_NEWLY_CREATED_EXTENSION" => {
                    Some(Self::CannotUpdateNewlyCreatedExtension)
                }
                "NO_EXISTING_AD_GROUP_EXTENSION_SETTING_FOR_TYPE" => {
                    Some(Self::NoExistingAdGroupExtensionSettingForType)
                }
                "NO_EXISTING_CAMPAIGN_EXTENSION_SETTING_FOR_TYPE" => {
                    Some(Self::NoExistingCampaignExtensionSettingForType)
                }
                "NO_EXISTING_CUSTOMER_EXTENSION_SETTING_FOR_TYPE" => {
                    Some(Self::NoExistingCustomerExtensionSettingForType)
                }
                "AD_GROUP_EXTENSION_SETTING_ALREADY_EXISTS" => {
                    Some(Self::AdGroupExtensionSettingAlreadyExists)
                }
                "CAMPAIGN_EXTENSION_SETTING_ALREADY_EXISTS" => {
                    Some(Self::CampaignExtensionSettingAlreadyExists)
                }
                "CUSTOMER_EXTENSION_SETTING_ALREADY_EXISTS" => {
                    Some(Self::CustomerExtensionSettingAlreadyExists)
                }
                "AD_GROUP_FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::AdGroupFeedAlreadyExistsForPlaceholderType)
                }
                "CAMPAIGN_FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::CampaignFeedAlreadyExistsForPlaceholderType)
                }
                "CUSTOMER_FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::CustomerFeedAlreadyExistsForPlaceholderType)
                }
                "VALUE_OUT_OF_RANGE" => Some(Self::ValueOutOfRange),
                "CANNOT_SET_FIELD_WITH_FINAL_URLS" => {
                    Some(Self::CannotSetFieldWithFinalUrls)
                }
                "FINAL_URLS_NOT_SET" => Some(Self::FinalUrlsNotSet),
                "INVALID_PHONE_NUMBER" => Some(Self::InvalidPhoneNumber),
                "PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::PhoneNumberNotSupportedForCountry)
                }
                "CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED" => {
                    Some(Self::CarrierSpecificShortNumberNotAllowed)
                }
                "PREMIUM_RATE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::PremiumRateNumberNotAllowed)
                }
                "DISALLOWED_NUMBER_TYPE" => Some(Self::DisallowedNumberType),
                "INVALID_DOMESTIC_PHONE_NUMBER_FORMAT" => {
                    Some(Self::InvalidDomesticPhoneNumberFormat)
                }
                "VANITY_PHONE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::VanityPhoneNumberNotAllowed)
                }
                "INVALID_COUNTRY_CODE" => Some(Self::InvalidCountryCode),
                "INVALID_CALL_CONVERSION_TYPE_ID" => {
                    Some(Self::InvalidCallConversionTypeId)
                }
                "CUSTOMER_NOT_IN_ALLOWLIST_FOR_CALLTRACKING" => {
                    Some(Self::CustomerNotInAllowlistForCalltracking)
                }
                "CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::CalltrackingNotSupportedForCountry)
                }
                "INVALID_APP_ID" => Some(Self::InvalidAppId),
                "QUOTES_IN_REVIEW_EXTENSION_SNIPPET" => {
                    Some(Self::QuotesInReviewExtensionSnippet)
                }
                "HYPHENS_IN_REVIEW_EXTENSION_SNIPPET" => {
                    Some(Self::HyphensInReviewExtensionSnippet)
                }
                "REVIEW_EXTENSION_SOURCE_NOT_ELIGIBLE" => {
                    Some(Self::ReviewExtensionSourceNotEligible)
                }
                "SOURCE_NAME_IN_REVIEW_EXTENSION_TEXT" => {
                    Some(Self::SourceNameInReviewExtensionText)
                }
                "MISSING_FIELD" => Some(Self::MissingField),
                "INCONSISTENT_CURRENCY_CODES" => Some(Self::InconsistentCurrencyCodes),
                "PRICE_EXTENSION_HAS_DUPLICATED_HEADERS" => {
                    Some(Self::PriceExtensionHasDuplicatedHeaders)
                }
                "PRICE_ITEM_HAS_DUPLICATED_HEADER_AND_DESCRIPTION" => {
                    Some(Self::PriceItemHasDuplicatedHeaderAndDescription)
                }
                "PRICE_EXTENSION_HAS_TOO_FEW_ITEMS" => {
                    Some(Self::PriceExtensionHasTooFewItems)
                }
                "PRICE_EXTENSION_HAS_TOO_MANY_ITEMS" => {
                    Some(Self::PriceExtensionHasTooManyItems)
                }
                "UNSUPPORTED_VALUE" => Some(Self::UnsupportedValue),
                "INVALID_DEVICE_PREFERENCE" => Some(Self::InvalidDevicePreference),
                "INVALID_SCHEDULE_END" => Some(Self::InvalidScheduleEnd),
                "DATE_TIME_MUST_BE_IN_ACCOUNT_TIME_ZONE" => {
                    Some(Self::DateTimeMustBeInAccountTimeZone)
                }
                "OVERLAPPING_SCHEDULES_NOT_ALLOWED" => {
                    Some(Self::OverlappingSchedulesNotAllowed)
                }
                "SCHEDULE_END_NOT_AFTER_START" => Some(Self::ScheduleEndNotAfterStart),
                "TOO_MANY_SCHEDULES_PER_DAY" => Some(Self::TooManySchedulesPerDay),
                "DUPLICATE_EXTENSION_FEED_ITEM_EDIT" => {
                    Some(Self::DuplicateExtensionFeedItemEdit)
                }
                "INVALID_SNIPPETS_HEADER" => Some(Self::InvalidSnippetsHeader),
                "PHONE_NUMBER_NOT_SUPPORTED_WITH_CALLTRACKING_FOR_COUNTRY" => {
                    Some(Self::PhoneNumberNotSupportedWithCalltrackingForCountry)
                }
                "CAMPAIGN_TARGETING_MISMATCH" => Some(Self::CampaignTargetingMismatch),
                "CANNOT_OPERATE_ON_REMOVED_FEED" => {
                    Some(Self::CannotOperateOnRemovedFeed)
                }
                "EXTENSION_TYPE_REQUIRED" => Some(Self::ExtensionTypeRequired),
                "INCOMPATIBLE_UNDERLYING_MATCHING_FUNCTION" => {
                    Some(Self::IncompatibleUnderlyingMatchingFunction)
                }
                "START_DATE_AFTER_END_DATE" => Some(Self::StartDateAfterEndDate),
                "INVALID_PRICE_FORMAT" => Some(Self::InvalidPriceFormat),
                "PROMOTION_INVALID_TIME" => Some(Self::PromotionInvalidTime),
                "PROMOTION_CANNOT_SET_PERCENT_DISCOUNT_AND_MONEY_DISCOUNT" => {
                    Some(Self::PromotionCannotSetPercentDiscountAndMoneyDiscount)
                }
                "PROMOTION_CANNOT_SET_PROMOTION_CODE_AND_ORDERS_OVER_AMOUNT" => {
                    Some(Self::PromotionCannotSetPromotionCodeAndOrdersOverAmount)
                }
                "TOO_MANY_DECIMAL_PLACES_SPECIFIED" => {
                    Some(Self::TooManyDecimalPlacesSpecified)
                }
                "INVALID_LANGUAGE_CODE" => Some(Self::InvalidLanguageCode),
                "UNSUPPORTED_LANGUAGE" => Some(Self::UnsupportedLanguage),
                "CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED" => {
                    Some(Self::CustomerConsentForCallRecordingRequired)
                }
                "EXTENSION_SETTING_UPDATE_IS_A_NOOP" => {
                    Some(Self::ExtensionSettingUpdateIsANoop)
                }
                "DISALLOWED_TEXT" => Some(Self::DisallowedText),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible feed attribute reference errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedAttributeReferenceErrorEnum {}
/// Nested message and enum types in `FeedAttributeReferenceErrorEnum`.
pub mod feed_attribute_reference_error_enum {
    /// Enum describing possible feed attribute reference errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedAttributeReferenceError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// A feed referenced by ID has been removed.
        CannotReferenceRemovedFeed = 2,
        /// There is no enabled feed with the given name.
        InvalidFeedName = 3,
        /// There is no feed attribute in an enabled feed with the given name.
        InvalidFeedAttributeName = 4,
    }
    impl FeedAttributeReferenceError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CannotReferenceRemovedFeed => "CANNOT_REFERENCE_REMOVED_FEED",
                Self::InvalidFeedName => "INVALID_FEED_NAME",
                Self::InvalidFeedAttributeName => "INVALID_FEED_ATTRIBUTE_NAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_REFERENCE_REMOVED_FEED" => Some(Self::CannotReferenceRemovedFeed),
                "INVALID_FEED_NAME" => Some(Self::InvalidFeedName),
                "INVALID_FEED_ATTRIBUTE_NAME" => Some(Self::InvalidFeedAttributeName),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible feed errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedErrorEnum {}
/// Nested message and enum types in `FeedErrorEnum`.
pub mod feed_error_enum {
    /// Enum describing possible feed errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The names of the FeedAttributes must be unique.
        AttributeNamesNotUnique = 2,
        /// The attribute list must be an exact copy of the existing list if the
        /// attribute ID's are present.
        AttributesDoNotMatchExistingAttributes = 3,
        /// Cannot specify USER origin for a system generated feed.
        CannotSpecifyUserOriginForSystemFeed = 4,
        /// Cannot specify GOOGLE origin for a non-system generated feed.
        CannotSpecifyGoogleOriginForNonSystemFeed = 5,
        /// Cannot specify feed attributes for system feed.
        CannotSpecifyFeedAttributesForSystemFeed = 6,
        /// Cannot update FeedAttributes on feed with origin GOOGLE.
        CannotUpdateFeedAttributesWithOriginGoogle = 7,
        /// The given ID refers to a removed Feed. Removed Feeds are immutable.
        FeedRemoved = 8,
        /// The origin of the feed is not valid for the client.
        InvalidOriginValue = 9,
        /// A user can only create and modify feeds with USER origin.
        FeedOriginIsNotUser = 10,
        /// Invalid auth token for the given email.
        InvalidAuthTokenForEmail = 11,
        /// Invalid email specified.
        InvalidEmail = 12,
        /// Feed name matches that of another active Feed.
        DuplicateFeedName = 13,
        /// Name of feed is not allowed.
        InvalidFeedName = 14,
        /// Missing OAuthInfo.
        MissingOauthInfo = 15,
        /// New FeedAttributes must not affect the unique key.
        NewAttributeCannotBePartOfUniqueKey = 16,
        /// Too many FeedAttributes for a Feed.
        TooManyAttributes = 17,
        /// The business account is not valid.
        InvalidBusinessAccount = 18,
        /// Business account cannot access Business Profile.
        BusinessAccountCannotAccessLocationAccount = 19,
        /// Invalid chain ID provided for affiliate location feed.
        InvalidAffiliateChainId = 20,
        /// There is already a feed with the given system feed generation data.
        DuplicateSystemFeed = 21,
        /// An error occurred accessing Business Profile.
        GmbAccessError = 22,
        /// A customer cannot have both LOCATION and AFFILIATE_LOCATION feeds.
        CannotHaveLocationAndAffiliateLocationFeeds = 23,
        /// Feed-based extension is read-only for this extension type.
        LegacyExtensionTypeReadOnly = 24,
    }
    impl FeedError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AttributeNamesNotUnique => "ATTRIBUTE_NAMES_NOT_UNIQUE",
                Self::AttributesDoNotMatchExistingAttributes => {
                    "ATTRIBUTES_DO_NOT_MATCH_EXISTING_ATTRIBUTES"
                }
                Self::CannotSpecifyUserOriginForSystemFeed => {
                    "CANNOT_SPECIFY_USER_ORIGIN_FOR_SYSTEM_FEED"
                }
                Self::CannotSpecifyGoogleOriginForNonSystemFeed => {
                    "CANNOT_SPECIFY_GOOGLE_ORIGIN_FOR_NON_SYSTEM_FEED"
                }
                Self::CannotSpecifyFeedAttributesForSystemFeed => {
                    "CANNOT_SPECIFY_FEED_ATTRIBUTES_FOR_SYSTEM_FEED"
                }
                Self::CannotUpdateFeedAttributesWithOriginGoogle => {
                    "CANNOT_UPDATE_FEED_ATTRIBUTES_WITH_ORIGIN_GOOGLE"
                }
                Self::FeedRemoved => "FEED_REMOVED",
                Self::InvalidOriginValue => "INVALID_ORIGIN_VALUE",
                Self::FeedOriginIsNotUser => "FEED_ORIGIN_IS_NOT_USER",
                Self::InvalidAuthTokenForEmail => "INVALID_AUTH_TOKEN_FOR_EMAIL",
                Self::InvalidEmail => "INVALID_EMAIL",
                Self::DuplicateFeedName => "DUPLICATE_FEED_NAME",
                Self::InvalidFeedName => "INVALID_FEED_NAME",
                Self::MissingOauthInfo => "MISSING_OAUTH_INFO",
                Self::NewAttributeCannotBePartOfUniqueKey => {
                    "NEW_ATTRIBUTE_CANNOT_BE_PART_OF_UNIQUE_KEY"
                }
                Self::TooManyAttributes => "TOO_MANY_ATTRIBUTES",
                Self::InvalidBusinessAccount => "INVALID_BUSINESS_ACCOUNT",
                Self::BusinessAccountCannotAccessLocationAccount => {
                    "BUSINESS_ACCOUNT_CANNOT_ACCESS_LOCATION_ACCOUNT"
                }
                Self::InvalidAffiliateChainId => "INVALID_AFFILIATE_CHAIN_ID",
                Self::DuplicateSystemFeed => "DUPLICATE_SYSTEM_FEED",
                Self::GmbAccessError => "GMB_ACCESS_ERROR",
                Self::CannotHaveLocationAndAffiliateLocationFeeds => {
                    "CANNOT_HAVE_LOCATION_AND_AFFILIATE_LOCATION_FEEDS"
                }
                Self::LegacyExtensionTypeReadOnly => "LEGACY_EXTENSION_TYPE_READ_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ATTRIBUTE_NAMES_NOT_UNIQUE" => Some(Self::AttributeNamesNotUnique),
                "ATTRIBUTES_DO_NOT_MATCH_EXISTING_ATTRIBUTES" => {
                    Some(Self::AttributesDoNotMatchExistingAttributes)
                }
                "CANNOT_SPECIFY_USER_ORIGIN_FOR_SYSTEM_FEED" => {
                    Some(Self::CannotSpecifyUserOriginForSystemFeed)
                }
                "CANNOT_SPECIFY_GOOGLE_ORIGIN_FOR_NON_SYSTEM_FEED" => {
                    Some(Self::CannotSpecifyGoogleOriginForNonSystemFeed)
                }
                "CANNOT_SPECIFY_FEED_ATTRIBUTES_FOR_SYSTEM_FEED" => {
                    Some(Self::CannotSpecifyFeedAttributesForSystemFeed)
                }
                "CANNOT_UPDATE_FEED_ATTRIBUTES_WITH_ORIGIN_GOOGLE" => {
                    Some(Self::CannotUpdateFeedAttributesWithOriginGoogle)
                }
                "FEED_REMOVED" => Some(Self::FeedRemoved),
                "INVALID_ORIGIN_VALUE" => Some(Self::InvalidOriginValue),
                "FEED_ORIGIN_IS_NOT_USER" => Some(Self::FeedOriginIsNotUser),
                "INVALID_AUTH_TOKEN_FOR_EMAIL" => Some(Self::InvalidAuthTokenForEmail),
                "INVALID_EMAIL" => Some(Self::InvalidEmail),
                "DUPLICATE_FEED_NAME" => Some(Self::DuplicateFeedName),
                "INVALID_FEED_NAME" => Some(Self::InvalidFeedName),
                "MISSING_OAUTH_INFO" => Some(Self::MissingOauthInfo),
                "NEW_ATTRIBUTE_CANNOT_BE_PART_OF_UNIQUE_KEY" => {
                    Some(Self::NewAttributeCannotBePartOfUniqueKey)
                }
                "TOO_MANY_ATTRIBUTES" => Some(Self::TooManyAttributes),
                "INVALID_BUSINESS_ACCOUNT" => Some(Self::InvalidBusinessAccount),
                "BUSINESS_ACCOUNT_CANNOT_ACCESS_LOCATION_ACCOUNT" => {
                    Some(Self::BusinessAccountCannotAccessLocationAccount)
                }
                "INVALID_AFFILIATE_CHAIN_ID" => Some(Self::InvalidAffiliateChainId),
                "DUPLICATE_SYSTEM_FEED" => Some(Self::DuplicateSystemFeed),
                "GMB_ACCESS_ERROR" => Some(Self::GmbAccessError),
                "CANNOT_HAVE_LOCATION_AND_AFFILIATE_LOCATION_FEEDS" => {
                    Some(Self::CannotHaveLocationAndAffiliateLocationFeeds)
                }
                "LEGACY_EXTENSION_TYPE_READ_ONLY" => {
                    Some(Self::LegacyExtensionTypeReadOnly)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible feed item errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemErrorEnum {}
/// Nested message and enum types in `FeedItemErrorEnum`.
pub mod feed_item_error_enum {
    /// Enum describing possible feed item errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Cannot convert the feed attribute value from string to its real type.
        CannotConvertAttributeValueFromString = 2,
        /// Cannot operate on removed feed item.
        CannotOperateOnRemovedFeedItem = 3,
        /// Date time zone does not match the account's time zone.
        DateTimeMustBeInAccountTimeZone = 4,
        /// Feed item with the key attributes could not be found.
        KeyAttributesNotFound = 5,
        /// Url feed attribute value is not valid.
        InvalidUrl = 6,
        /// Some key attributes are missing.
        MissingKeyAttributes = 7,
        /// Feed item has same key attributes as another feed item.
        KeyAttributesNotUnique = 8,
        /// Cannot modify key attributes on an existing feed item.
        CannotModifyKeyAttributeValue = 9,
        /// The feed attribute value is too large.
        SizeTooLargeForMultiValueAttribute = 10,
        /// Feed is read only.
        LegacyFeedTypeReadOnly = 11,
    }
    impl FeedItemError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CannotConvertAttributeValueFromString => {
                    "CANNOT_CONVERT_ATTRIBUTE_VALUE_FROM_STRING"
                }
                Self::CannotOperateOnRemovedFeedItem => {
                    "CANNOT_OPERATE_ON_REMOVED_FEED_ITEM"
                }
                Self::DateTimeMustBeInAccountTimeZone => {
                    "DATE_TIME_MUST_BE_IN_ACCOUNT_TIME_ZONE"
                }
                Self::KeyAttributesNotFound => "KEY_ATTRIBUTES_NOT_FOUND",
                Self::InvalidUrl => "INVALID_URL",
                Self::MissingKeyAttributes => "MISSING_KEY_ATTRIBUTES",
                Self::KeyAttributesNotUnique => "KEY_ATTRIBUTES_NOT_UNIQUE",
                Self::CannotModifyKeyAttributeValue => {
                    "CANNOT_MODIFY_KEY_ATTRIBUTE_VALUE"
                }
                Self::SizeTooLargeForMultiValueAttribute => {
                    "SIZE_TOO_LARGE_FOR_MULTI_VALUE_ATTRIBUTE"
                }
                Self::LegacyFeedTypeReadOnly => "LEGACY_FEED_TYPE_READ_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_CONVERT_ATTRIBUTE_VALUE_FROM_STRING" => {
                    Some(Self::CannotConvertAttributeValueFromString)
                }
                "CANNOT_OPERATE_ON_REMOVED_FEED_ITEM" => {
                    Some(Self::CannotOperateOnRemovedFeedItem)
                }
                "DATE_TIME_MUST_BE_IN_ACCOUNT_TIME_ZONE" => {
                    Some(Self::DateTimeMustBeInAccountTimeZone)
                }
                "KEY_ATTRIBUTES_NOT_FOUND" => Some(Self::KeyAttributesNotFound),
                "INVALID_URL" => Some(Self::InvalidUrl),
                "MISSING_KEY_ATTRIBUTES" => Some(Self::MissingKeyAttributes),
                "KEY_ATTRIBUTES_NOT_UNIQUE" => Some(Self::KeyAttributesNotUnique),
                "CANNOT_MODIFY_KEY_ATTRIBUTE_VALUE" => {
                    Some(Self::CannotModifyKeyAttributeValue)
                }
                "SIZE_TOO_LARGE_FOR_MULTI_VALUE_ATTRIBUTE" => {
                    Some(Self::SizeTooLargeForMultiValueAttribute)
                }
                "LEGACY_FEED_TYPE_READ_ONLY" => Some(Self::LegacyFeedTypeReadOnly),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible feed item set errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemSetErrorEnum {}
/// Nested message and enum types in `FeedItemSetErrorEnum`.
pub mod feed_item_set_error_enum {
    /// Enum describing possible feed item set errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemSetError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The given ID refers to a removed FeedItemSet.
        FeedItemSetRemoved = 2,
        /// The dynamic filter of a feed item set cannot be cleared on UPDATE if it
        /// exists. A set is either static or dynamic once added, and that cannot
        /// change.
        CannotClearDynamicFilter = 3,
        /// The dynamic filter of a feed item set cannot be created on UPDATE if it
        /// does not exist. A set is either static or dynamic once added, and that
        /// cannot change.
        CannotCreateDynamicFilter = 4,
        /// FeedItemSets can only be made for location or affiliate location feeds.
        InvalidFeedType = 5,
        /// FeedItemSets duplicate name. Name should be unique within an account.
        DuplicateName = 6,
        /// The feed type of the parent Feed is not compatible with the type of
        /// dynamic filter being set. For example, you can only set
        /// dynamic_location_set_filter for LOCATION feed item sets.
        WrongDynamicFilterForFeedType = 7,
        /// Chain ID specified for AffiliateLocationFeedData is invalid.
        DynamicFilterInvalidChainIds = 8,
    }
    impl FeedItemSetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::FeedItemSetRemoved => "FEED_ITEM_SET_REMOVED",
                Self::CannotClearDynamicFilter => "CANNOT_CLEAR_DYNAMIC_FILTER",
                Self::CannotCreateDynamicFilter => "CANNOT_CREATE_DYNAMIC_FILTER",
                Self::InvalidFeedType => "INVALID_FEED_TYPE",
                Self::DuplicateName => "DUPLICATE_NAME",
                Self::WrongDynamicFilterForFeedType => {
                    "WRONG_DYNAMIC_FILTER_FOR_FEED_TYPE"
                }
                Self::DynamicFilterInvalidChainIds => "DYNAMIC_FILTER_INVALID_CHAIN_IDS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FEED_ITEM_SET_REMOVED" => Some(Self::FeedItemSetRemoved),
                "CANNOT_CLEAR_DYNAMIC_FILTER" => Some(Self::CannotClearDynamicFilter),
                "CANNOT_CREATE_DYNAMIC_FILTER" => Some(Self::CannotCreateDynamicFilter),
                "INVALID_FEED_TYPE" => Some(Self::InvalidFeedType),
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "WRONG_DYNAMIC_FILTER_FOR_FEED_TYPE" => {
                    Some(Self::WrongDynamicFilterForFeedType)
                }
                "DYNAMIC_FILTER_INVALID_CHAIN_IDS" => {
                    Some(Self::DynamicFilterInvalidChainIds)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible feed item set link errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemSetLinkErrorEnum {}
/// Nested message and enum types in `FeedItemSetLinkErrorEnum`.
pub mod feed_item_set_link_error_enum {
    /// Enum describing possible feed item set link errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemSetLinkError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The feed IDs of the FeedItemSet and FeedItem do not match. Only FeedItems
        /// in a given Feed can be linked to a FeedItemSet in that Feed.
        FeedIdMismatch = 2,
        /// Cannot add or remove links to a dynamic set.
        NoMutateAllowedForDynamicSet = 3,
    }
    impl FeedItemSetLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::FeedIdMismatch => "FEED_ID_MISMATCH",
                Self::NoMutateAllowedForDynamicSet => "NO_MUTATE_ALLOWED_FOR_DYNAMIC_SET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FEED_ID_MISMATCH" => Some(Self::FeedIdMismatch),
                "NO_MUTATE_ALLOWED_FOR_DYNAMIC_SET" => {
                    Some(Self::NoMutateAllowedForDynamicSet)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible feed item target errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemTargetErrorEnum {}
/// Nested message and enum types in `FeedItemTargetErrorEnum`.
pub mod feed_item_target_error_enum {
    /// Enum describing possible feed item target errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemTargetError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// On CREATE, the FeedItemTarget must have a populated field in the oneof
        /// target.
        MustSetTargetOneofOnCreate = 2,
        /// The specified feed item target already exists, so it cannot be added.
        FeedItemTargetAlreadyExists = 3,
        /// The schedules for a given feed item cannot overlap.
        FeedItemSchedulesCannotOverlap = 4,
        /// Too many targets of a given type were added for a single feed item.
        TargetLimitExceededForGivenType = 5,
        /// Too many AdSchedules are enabled for the feed item for the given day.
        TooManySchedulesPerDay = 6,
        /// A feed item may either have an enabled campaign target or an enabled ad
        /// group target.
        CannotHaveEnabledCampaignAndEnabledAdGroupTargets = 7,
        /// Duplicate ad schedules aren't allowed.
        DuplicateAdSchedule = 8,
        /// Duplicate keywords aren't allowed.
        DuplicateKeyword = 9,
    }
    impl FeedItemTargetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::MustSetTargetOneofOnCreate => "MUST_SET_TARGET_ONEOF_ON_CREATE",
                Self::FeedItemTargetAlreadyExists => "FEED_ITEM_TARGET_ALREADY_EXISTS",
                Self::FeedItemSchedulesCannotOverlap => {
                    "FEED_ITEM_SCHEDULES_CANNOT_OVERLAP"
                }
                Self::TargetLimitExceededForGivenType => {
                    "TARGET_LIMIT_EXCEEDED_FOR_GIVEN_TYPE"
                }
                Self::TooManySchedulesPerDay => "TOO_MANY_SCHEDULES_PER_DAY",
                Self::CannotHaveEnabledCampaignAndEnabledAdGroupTargets => {
                    "CANNOT_HAVE_ENABLED_CAMPAIGN_AND_ENABLED_AD_GROUP_TARGETS"
                }
                Self::DuplicateAdSchedule => "DUPLICATE_AD_SCHEDULE",
                Self::DuplicateKeyword => "DUPLICATE_KEYWORD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MUST_SET_TARGET_ONEOF_ON_CREATE" => {
                    Some(Self::MustSetTargetOneofOnCreate)
                }
                "FEED_ITEM_TARGET_ALREADY_EXISTS" => {
                    Some(Self::FeedItemTargetAlreadyExists)
                }
                "FEED_ITEM_SCHEDULES_CANNOT_OVERLAP" => {
                    Some(Self::FeedItemSchedulesCannotOverlap)
                }
                "TARGET_LIMIT_EXCEEDED_FOR_GIVEN_TYPE" => {
                    Some(Self::TargetLimitExceededForGivenType)
                }
                "TOO_MANY_SCHEDULES_PER_DAY" => Some(Self::TooManySchedulesPerDay),
                "CANNOT_HAVE_ENABLED_CAMPAIGN_AND_ENABLED_AD_GROUP_TARGETS" => {
                    Some(Self::CannotHaveEnabledCampaignAndEnabledAdGroupTargets)
                }
                "DUPLICATE_AD_SCHEDULE" => Some(Self::DuplicateAdSchedule),
                "DUPLICATE_KEYWORD" => Some(Self::DuplicateKeyword),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible validation errors of a feed item.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemValidationErrorEnum {}
/// Nested message and enum types in `FeedItemValidationErrorEnum`.
pub mod feed_item_validation_error_enum {
    /// The possible validation errors of a feed item.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemValidationError {
        /// No value has been specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// String is too short.
        StringTooShort = 2,
        /// String is too long.
        StringTooLong = 3,
        /// Value is not provided.
        ValueNotSpecified = 4,
        /// Phone number format is invalid for region.
        InvalidDomesticPhoneNumberFormat = 5,
        /// String does not represent a phone number.
        InvalidPhoneNumber = 6,
        /// Phone number format is not compatible with country code.
        PhoneNumberNotSupportedForCountry = 7,
        /// Premium rate number is not allowed.
        PremiumRateNumberNotAllowed = 8,
        /// Phone number type is not allowed.
        DisallowedNumberType = 9,
        /// Specified value is outside of the valid range.
        ValueOutOfRange = 10,
        /// Call tracking is not supported in the selected country.
        CalltrackingNotSupportedForCountry = 11,
        /// Customer is not on the allow-list for call tracking.
        CustomerNotInAllowlistForCalltracking = 99,
        /// Country code is invalid.
        InvalidCountryCode = 13,
        /// The specified mobile app id is invalid.
        InvalidAppId = 14,
        /// Some required field attributes are missing.
        MissingAttributesForFields = 15,
        /// Invalid email button type for email extension.
        InvalidTypeId = 16,
        /// Email address is invalid.
        InvalidEmailAddress = 17,
        /// The HTTPS URL in email extension is invalid.
        InvalidHttpsUrl = 18,
        /// Delivery address is missing from email extension.
        MissingDeliveryAddress = 19,
        /// FeedItem scheduling start date comes after end date.
        StartDateAfterEndDate = 20,
        /// FeedItem scheduling start time is missing.
        MissingFeedItemStartTime = 21,
        /// FeedItem scheduling end time is missing.
        MissingFeedItemEndTime = 22,
        /// Cannot compute system attributes on a FeedItem that has no FeedItemId.
        MissingFeedItemId = 23,
        /// Call extension vanity phone numbers are not supported.
        VanityPhoneNumberNotAllowed = 24,
        /// Invalid review text.
        InvalidReviewExtensionSnippet = 25,
        /// Invalid format for numeric value in ad parameter.
        InvalidNumberFormat = 26,
        /// Invalid format for date value in ad parameter.
        InvalidDateFormat = 27,
        /// Invalid format for price value in ad parameter.
        InvalidPriceFormat = 28,
        /// Unrecognized type given for value in ad parameter.
        UnknownPlaceholderField = 29,
        /// Enhanced sitelinks must have both description lines specified.
        MissingEnhancedSitelinkDescriptionLine = 30,
        /// Review source is ineligible.
        ReviewExtensionSourceIneligible = 31,
        /// Review text cannot contain hyphens or dashes.
        HyphensInReviewExtensionSnippet = 32,
        /// Review text cannot contain double quote characters.
        DoubleQuotesInReviewExtensionSnippet = 33,
        /// Review text cannot contain quote characters.
        QuotesInReviewExtensionSnippet = 34,
        /// Parameters are encoded in the wrong format.
        InvalidFormEncodedParams = 35,
        /// URL parameter name must contain only letters, numbers, underscores, and
        /// dashes.
        InvalidUrlParameterName = 36,
        /// Cannot find address location.
        NoGeocodingResult = 37,
        /// Review extension text has source name.
        SourceNameInReviewExtensionText = 38,
        /// Some phone numbers can be shorter than usual. Some of these short numbers
        /// are carrier-specific, and we disallow those in ad extensions because they
        /// will not be available to all users.
        CarrierSpecificShortNumberNotAllowed = 39,
        /// Triggered when a request references a placeholder field id that does not
        /// exist.
        InvalidPlaceholderFieldId = 40,
        /// URL contains invalid ValueTrack tags or format.
        InvalidUrlTag = 41,
        /// Provided list exceeds acceptable size.
        ListTooLong = 42,
        /// Certain combinations of attributes aren't allowed to be specified in the
        /// same feed item.
        InvalidAttributesCombination = 43,
        /// An attribute has the same value repeatedly.
        DuplicateValues = 44,
        /// Advertisers can link a conversion action with a phone number to indicate
        /// that sufficiently long calls forwarded to that phone number should be
        /// counted as conversions of the specified type.  This is an error message
        /// indicating that the conversion action specified is invalid (for example,
        /// the conversion action does not exist within the appropriate Google Ads
        /// account, or it is a type of conversion not appropriate to phone call
        /// conversions).
        InvalidCallConversionActionId = 45,
        /// Tracking template requires final url to be set.
        CannotSetWithoutFinalUrls = 46,
        /// An app id was provided that doesn't exist in the given app store.
        AppIdDoesntExistInAppStore = 47,
        /// Invalid U2 final url.
        InvalidFinalUrl = 48,
        /// Invalid U2 tracking url.
        InvalidTrackingUrl = 49,
        /// Final URL should start from App download URL.
        InvalidFinalUrlForAppDownloadUrl = 50,
        /// List provided is too short.
        ListTooShort = 51,
        /// User Action field has invalid value.
        InvalidUserAction = 52,
        /// Type field has invalid value.
        InvalidTypeName = 53,
        /// Change status for event is invalid.
        InvalidEventChangeStatus = 54,
        /// The header of a structured snippets extension is not one of the valid
        /// headers.
        InvalidSnippetsHeader = 55,
        /// Android app link is not formatted correctly
        InvalidAndroidAppLink = 56,
        /// Phone number incompatible with call tracking for country.
        NumberTypeWithCalltrackingNotSupportedForCountry = 57,
        /// The input is identical to a reserved keyword
        ReservedKeywordOther = 58,
        /// Each option label in the message extension must be unique.
        DuplicateOptionLabels = 59,
        /// Each option prefill in the message extension must be unique.
        DuplicateOptionPrefills = 60,
        /// In message extensions, the number of optional labels and optional
        /// prefills must be the same.
        UnequalListLengths = 61,
        /// All currency codes in an ad extension must be the same.
        InconsistentCurrencyCodes = 62,
        /// Headers in price extension are not unique.
        PriceExtensionHasDuplicatedHeaders = 63,
        /// Header and description in an item are the same.
        ItemHasDuplicatedHeaderAndDescription = 64,
        /// Price extension has too few items.
        PriceExtensionHasTooFewItems = 65,
        /// The given value is not supported.
        UnsupportedValue = 66,
        /// Invalid final mobile url.
        InvalidFinalMobileUrl = 67,
        /// The given string value of Label contains invalid characters
        InvalidKeywordlessAdRuleLabel = 68,
        /// The given URL contains value track parameters.
        ValueTrackParameterNotSupported = 69,
        /// The given value is not supported in the selected language of an
        /// extension.
        UnsupportedValueInSelectedLanguage = 70,
        /// The iOS app link is not formatted correctly.
        InvalidIosAppLink = 71,
        /// iOS app link or iOS app store id is missing.
        MissingIosAppLinkOrIosAppStoreId = 72,
        /// Promotion time is invalid.
        PromotionInvalidTime = 73,
        /// Both the percent off and money amount off fields are set.
        PromotionCannotSetPercentOffAndMoneyAmountOff = 74,
        /// Both the promotion code and orders over amount fields are set.
        PromotionCannotSetPromotionCodeAndOrdersOverAmount = 75,
        /// Too many decimal places are specified.
        TooManyDecimalPlacesSpecified = 76,
        /// Ad Customizers are present and not allowed.
        AdCustomizersNotAllowed = 77,
        /// Language code is not valid.
        InvalidLanguageCode = 78,
        /// Language is not supported.
        UnsupportedLanguage = 79,
        /// IF Function is present and not allowed.
        IfFunctionNotAllowed = 80,
        /// Final url suffix is not valid.
        InvalidFinalUrlSuffix = 81,
        /// Final url suffix contains an invalid tag.
        InvalidTagInFinalUrlSuffix = 82,
        /// Final url suffix is formatted incorrectly.
        InvalidFinalUrlSuffixFormat = 83,
        /// Consent for call recording, which is required for the use of call
        /// extensions, was not provided by the advertiser. See
        /// <https://support.google.com/google-ads/answer/7412639.>
        CustomerConsentForCallRecordingRequired = 84,
        /// Multiple message delivery options are set.
        OnlyOneDeliveryOptionIsAllowed = 85,
        /// No message delivery option is set.
        NoDeliveryOptionIsSet = 86,
        /// String value of conversion reporting state field is not valid.
        InvalidConversionReportingState = 87,
        /// Image size is not right.
        ImageSizeWrong = 88,
        /// Email delivery is not supported in the country specified in the country
        /// code field.
        EmailDeliveryNotAvailableInCountry = 89,
        /// Auto reply is not supported in the country specified in the country code
        /// field.
        AutoReplyNotAvailableInCountry = 90,
        /// Invalid value specified for latitude.
        InvalidLatitudeValue = 91,
        /// Invalid value specified for longitude.
        InvalidLongitudeValue = 92,
        /// Too many label fields provided.
        TooManyLabels = 93,
        /// Invalid image url.
        InvalidImageUrl = 94,
        /// Latitude value is missing.
        MissingLatitudeValue = 95,
        /// Longitude value is missing.
        MissingLongitudeValue = 96,
        /// Unable to find address.
        AddressNotFound = 97,
        /// Cannot target provided address.
        AddressNotTargetable = 98,
        /// The specified asset ID does not exist.
        InvalidAssetId = 100,
        /// The asset type cannot be set for the field.
        IncompatibleAssetType = 101,
        /// The image has unexpected size.
        ImageErrorUnexpectedSize = 102,
        /// The image aspect ratio is not allowed.
        ImageErrorAspectRatioNotAllowed = 103,
        /// The image file is too large.
        ImageErrorFileTooLarge = 104,
        /// The image format is unsupported.
        ImageErrorFormatNotAllowed = 105,
        /// Image violates constraints without more details.
        ImageErrorConstraintsViolated = 106,
        /// An error occurred when validating image.
        ImageErrorServerError = 107,
    }
    impl FeedItemValidationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::StringTooShort => "STRING_TOO_SHORT",
                Self::StringTooLong => "STRING_TOO_LONG",
                Self::ValueNotSpecified => "VALUE_NOT_SPECIFIED",
                Self::InvalidDomesticPhoneNumberFormat => {
                    "INVALID_DOMESTIC_PHONE_NUMBER_FORMAT"
                }
                Self::InvalidPhoneNumber => "INVALID_PHONE_NUMBER",
                Self::PhoneNumberNotSupportedForCountry => {
                    "PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY"
                }
                Self::PremiumRateNumberNotAllowed => "PREMIUM_RATE_NUMBER_NOT_ALLOWED",
                Self::DisallowedNumberType => "DISALLOWED_NUMBER_TYPE",
                Self::ValueOutOfRange => "VALUE_OUT_OF_RANGE",
                Self::CalltrackingNotSupportedForCountry => {
                    "CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY"
                }
                Self::CustomerNotInAllowlistForCalltracking => {
                    "CUSTOMER_NOT_IN_ALLOWLIST_FOR_CALLTRACKING"
                }
                Self::InvalidCountryCode => "INVALID_COUNTRY_CODE",
                Self::InvalidAppId => "INVALID_APP_ID",
                Self::MissingAttributesForFields => "MISSING_ATTRIBUTES_FOR_FIELDS",
                Self::InvalidTypeId => "INVALID_TYPE_ID",
                Self::InvalidEmailAddress => "INVALID_EMAIL_ADDRESS",
                Self::InvalidHttpsUrl => "INVALID_HTTPS_URL",
                Self::MissingDeliveryAddress => "MISSING_DELIVERY_ADDRESS",
                Self::StartDateAfterEndDate => "START_DATE_AFTER_END_DATE",
                Self::MissingFeedItemStartTime => "MISSING_FEED_ITEM_START_TIME",
                Self::MissingFeedItemEndTime => "MISSING_FEED_ITEM_END_TIME",
                Self::MissingFeedItemId => "MISSING_FEED_ITEM_ID",
                Self::VanityPhoneNumberNotAllowed => "VANITY_PHONE_NUMBER_NOT_ALLOWED",
                Self::InvalidReviewExtensionSnippet => "INVALID_REVIEW_EXTENSION_SNIPPET",
                Self::InvalidNumberFormat => "INVALID_NUMBER_FORMAT",
                Self::InvalidDateFormat => "INVALID_DATE_FORMAT",
                Self::InvalidPriceFormat => "INVALID_PRICE_FORMAT",
                Self::UnknownPlaceholderField => "UNKNOWN_PLACEHOLDER_FIELD",
                Self::MissingEnhancedSitelinkDescriptionLine => {
                    "MISSING_ENHANCED_SITELINK_DESCRIPTION_LINE"
                }
                Self::ReviewExtensionSourceIneligible => {
                    "REVIEW_EXTENSION_SOURCE_INELIGIBLE"
                }
                Self::HyphensInReviewExtensionSnippet => {
                    "HYPHENS_IN_REVIEW_EXTENSION_SNIPPET"
                }
                Self::DoubleQuotesInReviewExtensionSnippet => {
                    "DOUBLE_QUOTES_IN_REVIEW_EXTENSION_SNIPPET"
                }
                Self::QuotesInReviewExtensionSnippet => {
                    "QUOTES_IN_REVIEW_EXTENSION_SNIPPET"
                }
                Self::InvalidFormEncodedParams => "INVALID_FORM_ENCODED_PARAMS",
                Self::InvalidUrlParameterName => "INVALID_URL_PARAMETER_NAME",
                Self::NoGeocodingResult => "NO_GEOCODING_RESULT",
                Self::SourceNameInReviewExtensionText => {
                    "SOURCE_NAME_IN_REVIEW_EXTENSION_TEXT"
                }
                Self::CarrierSpecificShortNumberNotAllowed => {
                    "CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED"
                }
                Self::InvalidPlaceholderFieldId => "INVALID_PLACEHOLDER_FIELD_ID",
                Self::InvalidUrlTag => "INVALID_URL_TAG",
                Self::ListTooLong => "LIST_TOO_LONG",
                Self::InvalidAttributesCombination => "INVALID_ATTRIBUTES_COMBINATION",
                Self::DuplicateValues => "DUPLICATE_VALUES",
                Self::InvalidCallConversionActionId => {
                    "INVALID_CALL_CONVERSION_ACTION_ID"
                }
                Self::CannotSetWithoutFinalUrls => "CANNOT_SET_WITHOUT_FINAL_URLS",
                Self::AppIdDoesntExistInAppStore => "APP_ID_DOESNT_EXIST_IN_APP_STORE",
                Self::InvalidFinalUrl => "INVALID_FINAL_URL",
                Self::InvalidTrackingUrl => "INVALID_TRACKING_URL",
                Self::InvalidFinalUrlForAppDownloadUrl => {
                    "INVALID_FINAL_URL_FOR_APP_DOWNLOAD_URL"
                }
                Self::ListTooShort => "LIST_TOO_SHORT",
                Self::InvalidUserAction => "INVALID_USER_ACTION",
                Self::InvalidTypeName => "INVALID_TYPE_NAME",
                Self::InvalidEventChangeStatus => "INVALID_EVENT_CHANGE_STATUS",
                Self::InvalidSnippetsHeader => "INVALID_SNIPPETS_HEADER",
                Self::InvalidAndroidAppLink => "INVALID_ANDROID_APP_LINK",
                Self::NumberTypeWithCalltrackingNotSupportedForCountry => {
                    "NUMBER_TYPE_WITH_CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY"
                }
                Self::ReservedKeywordOther => "RESERVED_KEYWORD_OTHER",
                Self::DuplicateOptionLabels => "DUPLICATE_OPTION_LABELS",
                Self::DuplicateOptionPrefills => "DUPLICATE_OPTION_PREFILLS",
                Self::UnequalListLengths => "UNEQUAL_LIST_LENGTHS",
                Self::InconsistentCurrencyCodes => "INCONSISTENT_CURRENCY_CODES",
                Self::PriceExtensionHasDuplicatedHeaders => {
                    "PRICE_EXTENSION_HAS_DUPLICATED_HEADERS"
                }
                Self::ItemHasDuplicatedHeaderAndDescription => {
                    "ITEM_HAS_DUPLICATED_HEADER_AND_DESCRIPTION"
                }
                Self::PriceExtensionHasTooFewItems => "PRICE_EXTENSION_HAS_TOO_FEW_ITEMS",
                Self::UnsupportedValue => "UNSUPPORTED_VALUE",
                Self::InvalidFinalMobileUrl => "INVALID_FINAL_MOBILE_URL",
                Self::InvalidKeywordlessAdRuleLabel => {
                    "INVALID_KEYWORDLESS_AD_RULE_LABEL"
                }
                Self::ValueTrackParameterNotSupported => {
                    "VALUE_TRACK_PARAMETER_NOT_SUPPORTED"
                }
                Self::UnsupportedValueInSelectedLanguage => {
                    "UNSUPPORTED_VALUE_IN_SELECTED_LANGUAGE"
                }
                Self::InvalidIosAppLink => "INVALID_IOS_APP_LINK",
                Self::MissingIosAppLinkOrIosAppStoreId => {
                    "MISSING_IOS_APP_LINK_OR_IOS_APP_STORE_ID"
                }
                Self::PromotionInvalidTime => "PROMOTION_INVALID_TIME",
                Self::PromotionCannotSetPercentOffAndMoneyAmountOff => {
                    "PROMOTION_CANNOT_SET_PERCENT_OFF_AND_MONEY_AMOUNT_OFF"
                }
                Self::PromotionCannotSetPromotionCodeAndOrdersOverAmount => {
                    "PROMOTION_CANNOT_SET_PROMOTION_CODE_AND_ORDERS_OVER_AMOUNT"
                }
                Self::TooManyDecimalPlacesSpecified => {
                    "TOO_MANY_DECIMAL_PLACES_SPECIFIED"
                }
                Self::AdCustomizersNotAllowed => "AD_CUSTOMIZERS_NOT_ALLOWED",
                Self::InvalidLanguageCode => "INVALID_LANGUAGE_CODE",
                Self::UnsupportedLanguage => "UNSUPPORTED_LANGUAGE",
                Self::IfFunctionNotAllowed => "IF_FUNCTION_NOT_ALLOWED",
                Self::InvalidFinalUrlSuffix => "INVALID_FINAL_URL_SUFFIX",
                Self::InvalidTagInFinalUrlSuffix => "INVALID_TAG_IN_FINAL_URL_SUFFIX",
                Self::InvalidFinalUrlSuffixFormat => "INVALID_FINAL_URL_SUFFIX_FORMAT",
                Self::CustomerConsentForCallRecordingRequired => {
                    "CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED"
                }
                Self::OnlyOneDeliveryOptionIsAllowed => {
                    "ONLY_ONE_DELIVERY_OPTION_IS_ALLOWED"
                }
                Self::NoDeliveryOptionIsSet => "NO_DELIVERY_OPTION_IS_SET",
                Self::InvalidConversionReportingState => {
                    "INVALID_CONVERSION_REPORTING_STATE"
                }
                Self::ImageSizeWrong => "IMAGE_SIZE_WRONG",
                Self::EmailDeliveryNotAvailableInCountry => {
                    "EMAIL_DELIVERY_NOT_AVAILABLE_IN_COUNTRY"
                }
                Self::AutoReplyNotAvailableInCountry => {
                    "AUTO_REPLY_NOT_AVAILABLE_IN_COUNTRY"
                }
                Self::InvalidLatitudeValue => "INVALID_LATITUDE_VALUE",
                Self::InvalidLongitudeValue => "INVALID_LONGITUDE_VALUE",
                Self::TooManyLabels => "TOO_MANY_LABELS",
                Self::InvalidImageUrl => "INVALID_IMAGE_URL",
                Self::MissingLatitudeValue => "MISSING_LATITUDE_VALUE",
                Self::MissingLongitudeValue => "MISSING_LONGITUDE_VALUE",
                Self::AddressNotFound => "ADDRESS_NOT_FOUND",
                Self::AddressNotTargetable => "ADDRESS_NOT_TARGETABLE",
                Self::InvalidAssetId => "INVALID_ASSET_ID",
                Self::IncompatibleAssetType => "INCOMPATIBLE_ASSET_TYPE",
                Self::ImageErrorUnexpectedSize => "IMAGE_ERROR_UNEXPECTED_SIZE",
                Self::ImageErrorAspectRatioNotAllowed => {
                    "IMAGE_ERROR_ASPECT_RATIO_NOT_ALLOWED"
                }
                Self::ImageErrorFileTooLarge => "IMAGE_ERROR_FILE_TOO_LARGE",
                Self::ImageErrorFormatNotAllowed => "IMAGE_ERROR_FORMAT_NOT_ALLOWED",
                Self::ImageErrorConstraintsViolated => "IMAGE_ERROR_CONSTRAINTS_VIOLATED",
                Self::ImageErrorServerError => "IMAGE_ERROR_SERVER_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "STRING_TOO_SHORT" => Some(Self::StringTooShort),
                "STRING_TOO_LONG" => Some(Self::StringTooLong),
                "VALUE_NOT_SPECIFIED" => Some(Self::ValueNotSpecified),
                "INVALID_DOMESTIC_PHONE_NUMBER_FORMAT" => {
                    Some(Self::InvalidDomesticPhoneNumberFormat)
                }
                "INVALID_PHONE_NUMBER" => Some(Self::InvalidPhoneNumber),
                "PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::PhoneNumberNotSupportedForCountry)
                }
                "PREMIUM_RATE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::PremiumRateNumberNotAllowed)
                }
                "DISALLOWED_NUMBER_TYPE" => Some(Self::DisallowedNumberType),
                "VALUE_OUT_OF_RANGE" => Some(Self::ValueOutOfRange),
                "CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::CalltrackingNotSupportedForCountry)
                }
                "CUSTOMER_NOT_IN_ALLOWLIST_FOR_CALLTRACKING" => {
                    Some(Self::CustomerNotInAllowlistForCalltracking)
                }
                "INVALID_COUNTRY_CODE" => Some(Self::InvalidCountryCode),
                "INVALID_APP_ID" => Some(Self::InvalidAppId),
                "MISSING_ATTRIBUTES_FOR_FIELDS" => Some(Self::MissingAttributesForFields),
                "INVALID_TYPE_ID" => Some(Self::InvalidTypeId),
                "INVALID_EMAIL_ADDRESS" => Some(Self::InvalidEmailAddress),
                "INVALID_HTTPS_URL" => Some(Self::InvalidHttpsUrl),
                "MISSING_DELIVERY_ADDRESS" => Some(Self::MissingDeliveryAddress),
                "START_DATE_AFTER_END_DATE" => Some(Self::StartDateAfterEndDate),
                "MISSING_FEED_ITEM_START_TIME" => Some(Self::MissingFeedItemStartTime),
                "MISSING_FEED_ITEM_END_TIME" => Some(Self::MissingFeedItemEndTime),
                "MISSING_FEED_ITEM_ID" => Some(Self::MissingFeedItemId),
                "VANITY_PHONE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::VanityPhoneNumberNotAllowed)
                }
                "INVALID_REVIEW_EXTENSION_SNIPPET" => {
                    Some(Self::InvalidReviewExtensionSnippet)
                }
                "INVALID_NUMBER_FORMAT" => Some(Self::InvalidNumberFormat),
                "INVALID_DATE_FORMAT" => Some(Self::InvalidDateFormat),
                "INVALID_PRICE_FORMAT" => Some(Self::InvalidPriceFormat),
                "UNKNOWN_PLACEHOLDER_FIELD" => Some(Self::UnknownPlaceholderField),
                "MISSING_ENHANCED_SITELINK_DESCRIPTION_LINE" => {
                    Some(Self::MissingEnhancedSitelinkDescriptionLine)
                }
                "REVIEW_EXTENSION_SOURCE_INELIGIBLE" => {
                    Some(Self::ReviewExtensionSourceIneligible)
                }
                "HYPHENS_IN_REVIEW_EXTENSION_SNIPPET" => {
                    Some(Self::HyphensInReviewExtensionSnippet)
                }
                "DOUBLE_QUOTES_IN_REVIEW_EXTENSION_SNIPPET" => {
                    Some(Self::DoubleQuotesInReviewExtensionSnippet)
                }
                "QUOTES_IN_REVIEW_EXTENSION_SNIPPET" => {
                    Some(Self::QuotesInReviewExtensionSnippet)
                }
                "INVALID_FORM_ENCODED_PARAMS" => Some(Self::InvalidFormEncodedParams),
                "INVALID_URL_PARAMETER_NAME" => Some(Self::InvalidUrlParameterName),
                "NO_GEOCODING_RESULT" => Some(Self::NoGeocodingResult),
                "SOURCE_NAME_IN_REVIEW_EXTENSION_TEXT" => {
                    Some(Self::SourceNameInReviewExtensionText)
                }
                "CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED" => {
                    Some(Self::CarrierSpecificShortNumberNotAllowed)
                }
                "INVALID_PLACEHOLDER_FIELD_ID" => Some(Self::InvalidPlaceholderFieldId),
                "INVALID_URL_TAG" => Some(Self::InvalidUrlTag),
                "LIST_TOO_LONG" => Some(Self::ListTooLong),
                "INVALID_ATTRIBUTES_COMBINATION" => {
                    Some(Self::InvalidAttributesCombination)
                }
                "DUPLICATE_VALUES" => Some(Self::DuplicateValues),
                "INVALID_CALL_CONVERSION_ACTION_ID" => {
                    Some(Self::InvalidCallConversionActionId)
                }
                "CANNOT_SET_WITHOUT_FINAL_URLS" => Some(Self::CannotSetWithoutFinalUrls),
                "APP_ID_DOESNT_EXIST_IN_APP_STORE" => {
                    Some(Self::AppIdDoesntExistInAppStore)
                }
                "INVALID_FINAL_URL" => Some(Self::InvalidFinalUrl),
                "INVALID_TRACKING_URL" => Some(Self::InvalidTrackingUrl),
                "INVALID_FINAL_URL_FOR_APP_DOWNLOAD_URL" => {
                    Some(Self::InvalidFinalUrlForAppDownloadUrl)
                }
                "LIST_TOO_SHORT" => Some(Self::ListTooShort),
                "INVALID_USER_ACTION" => Some(Self::InvalidUserAction),
                "INVALID_TYPE_NAME" => Some(Self::InvalidTypeName),
                "INVALID_EVENT_CHANGE_STATUS" => Some(Self::InvalidEventChangeStatus),
                "INVALID_SNIPPETS_HEADER" => Some(Self::InvalidSnippetsHeader),
                "INVALID_ANDROID_APP_LINK" => Some(Self::InvalidAndroidAppLink),
                "NUMBER_TYPE_WITH_CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::NumberTypeWithCalltrackingNotSupportedForCountry)
                }
                "RESERVED_KEYWORD_OTHER" => Some(Self::ReservedKeywordOther),
                "DUPLICATE_OPTION_LABELS" => Some(Self::DuplicateOptionLabels),
                "DUPLICATE_OPTION_PREFILLS" => Some(Self::DuplicateOptionPrefills),
                "UNEQUAL_LIST_LENGTHS" => Some(Self::UnequalListLengths),
                "INCONSISTENT_CURRENCY_CODES" => Some(Self::InconsistentCurrencyCodes),
                "PRICE_EXTENSION_HAS_DUPLICATED_HEADERS" => {
                    Some(Self::PriceExtensionHasDuplicatedHeaders)
                }
                "ITEM_HAS_DUPLICATED_HEADER_AND_DESCRIPTION" => {
                    Some(Self::ItemHasDuplicatedHeaderAndDescription)
                }
                "PRICE_EXTENSION_HAS_TOO_FEW_ITEMS" => {
                    Some(Self::PriceExtensionHasTooFewItems)
                }
                "UNSUPPORTED_VALUE" => Some(Self::UnsupportedValue),
                "INVALID_FINAL_MOBILE_URL" => Some(Self::InvalidFinalMobileUrl),
                "INVALID_KEYWORDLESS_AD_RULE_LABEL" => {
                    Some(Self::InvalidKeywordlessAdRuleLabel)
                }
                "VALUE_TRACK_PARAMETER_NOT_SUPPORTED" => {
                    Some(Self::ValueTrackParameterNotSupported)
                }
                "UNSUPPORTED_VALUE_IN_SELECTED_LANGUAGE" => {
                    Some(Self::UnsupportedValueInSelectedLanguage)
                }
                "INVALID_IOS_APP_LINK" => Some(Self::InvalidIosAppLink),
                "MISSING_IOS_APP_LINK_OR_IOS_APP_STORE_ID" => {
                    Some(Self::MissingIosAppLinkOrIosAppStoreId)
                }
                "PROMOTION_INVALID_TIME" => Some(Self::PromotionInvalidTime),
                "PROMOTION_CANNOT_SET_PERCENT_OFF_AND_MONEY_AMOUNT_OFF" => {
                    Some(Self::PromotionCannotSetPercentOffAndMoneyAmountOff)
                }
                "PROMOTION_CANNOT_SET_PROMOTION_CODE_AND_ORDERS_OVER_AMOUNT" => {
                    Some(Self::PromotionCannotSetPromotionCodeAndOrdersOverAmount)
                }
                "TOO_MANY_DECIMAL_PLACES_SPECIFIED" => {
                    Some(Self::TooManyDecimalPlacesSpecified)
                }
                "AD_CUSTOMIZERS_NOT_ALLOWED" => Some(Self::AdCustomizersNotAllowed),
                "INVALID_LANGUAGE_CODE" => Some(Self::InvalidLanguageCode),
                "UNSUPPORTED_LANGUAGE" => Some(Self::UnsupportedLanguage),
                "IF_FUNCTION_NOT_ALLOWED" => Some(Self::IfFunctionNotAllowed),
                "INVALID_FINAL_URL_SUFFIX" => Some(Self::InvalidFinalUrlSuffix),
                "INVALID_TAG_IN_FINAL_URL_SUFFIX" => {
                    Some(Self::InvalidTagInFinalUrlSuffix)
                }
                "INVALID_FINAL_URL_SUFFIX_FORMAT" => {
                    Some(Self::InvalidFinalUrlSuffixFormat)
                }
                "CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED" => {
                    Some(Self::CustomerConsentForCallRecordingRequired)
                }
                "ONLY_ONE_DELIVERY_OPTION_IS_ALLOWED" => {
                    Some(Self::OnlyOneDeliveryOptionIsAllowed)
                }
                "NO_DELIVERY_OPTION_IS_SET" => Some(Self::NoDeliveryOptionIsSet),
                "INVALID_CONVERSION_REPORTING_STATE" => {
                    Some(Self::InvalidConversionReportingState)
                }
                "IMAGE_SIZE_WRONG" => Some(Self::ImageSizeWrong),
                "EMAIL_DELIVERY_NOT_AVAILABLE_IN_COUNTRY" => {
                    Some(Self::EmailDeliveryNotAvailableInCountry)
                }
                "AUTO_REPLY_NOT_AVAILABLE_IN_COUNTRY" => {
                    Some(Self::AutoReplyNotAvailableInCountry)
                }
                "INVALID_LATITUDE_VALUE" => Some(Self::InvalidLatitudeValue),
                "INVALID_LONGITUDE_VALUE" => Some(Self::InvalidLongitudeValue),
                "TOO_MANY_LABELS" => Some(Self::TooManyLabels),
                "INVALID_IMAGE_URL" => Some(Self::InvalidImageUrl),
                "MISSING_LATITUDE_VALUE" => Some(Self::MissingLatitudeValue),
                "MISSING_LONGITUDE_VALUE" => Some(Self::MissingLongitudeValue),
                "ADDRESS_NOT_FOUND" => Some(Self::AddressNotFound),
                "ADDRESS_NOT_TARGETABLE" => Some(Self::AddressNotTargetable),
                "INVALID_ASSET_ID" => Some(Self::InvalidAssetId),
                "INCOMPATIBLE_ASSET_TYPE" => Some(Self::IncompatibleAssetType),
                "IMAGE_ERROR_UNEXPECTED_SIZE" => Some(Self::ImageErrorUnexpectedSize),
                "IMAGE_ERROR_ASPECT_RATIO_NOT_ALLOWED" => {
                    Some(Self::ImageErrorAspectRatioNotAllowed)
                }
                "IMAGE_ERROR_FILE_TOO_LARGE" => Some(Self::ImageErrorFileTooLarge),
                "IMAGE_ERROR_FORMAT_NOT_ALLOWED" => {
                    Some(Self::ImageErrorFormatNotAllowed)
                }
                "IMAGE_ERROR_CONSTRAINTS_VIOLATED" => {
                    Some(Self::ImageErrorConstraintsViolated)
                }
                "IMAGE_ERROR_SERVER_ERROR" => Some(Self::ImageErrorServerError),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible feed item errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedMappingErrorEnum {}
/// Nested message and enum types in `FeedMappingErrorEnum`.
pub mod feed_mapping_error_enum {
    /// Enum describing possible feed item errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedMappingError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The given placeholder field does not exist.
        InvalidPlaceholderField = 2,
        /// The given criterion field does not exist.
        InvalidCriterionField = 3,
        /// The given placeholder type does not exist.
        InvalidPlaceholderType = 4,
        /// The given criterion type does not exist.
        InvalidCriterionType = 5,
        /// A feed mapping must contain at least one attribute field mapping.
        NoAttributeFieldMappings = 7,
        /// The type of the feed attribute referenced in the attribute field mapping
        /// must match the type of the placeholder field.
        FeedAttributeTypeMismatch = 8,
        /// A feed mapping for a system generated feed cannot be operated on.
        CannotOperateOnMappingsForSystemGeneratedFeed = 9,
        /// Only one feed mapping for a placeholder type is allowed per feed or
        /// customer (depending on the placeholder type).
        MultipleMappingsForPlaceholderType = 10,
        /// Only one feed mapping for a criterion type is allowed per customer.
        MultipleMappingsForCriterionType = 11,
        /// Only one feed attribute mapping for a placeholder field is allowed
        /// (depending on the placeholder type).
        MultipleMappingsForPlaceholderField = 12,
        /// Only one feed attribute mapping for a criterion field is allowed
        /// (depending on the criterion type).
        MultipleMappingsForCriterionField = 13,
        /// This feed mapping may not contain any explicit attribute field mappings.
        UnexpectedAttributeFieldMappings = 14,
        /// Location placeholder feed mappings can only be created for Places feeds.
        LocationPlaceholderOnlyForPlacesFeeds = 15,
        /// Mappings for typed feeds cannot be modified.
        CannotModifyMappingsForTypedFeed = 16,
        /// The given placeholder type can only be mapped to system generated feeds.
        InvalidPlaceholderTypeForNonSystemGeneratedFeed = 17,
        /// The given placeholder type cannot be mapped to a system generated feed
        /// with the given type.
        InvalidPlaceholderTypeForSystemGeneratedFeedType = 18,
        /// The "field" oneof was not set in an AttributeFieldMapping.
        AttributeFieldMappingMissingField = 19,
        /// Feed is read only.
        LegacyFeedTypeReadOnly = 20,
    }
    impl FeedMappingError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidPlaceholderField => "INVALID_PLACEHOLDER_FIELD",
                Self::InvalidCriterionField => "INVALID_CRITERION_FIELD",
                Self::InvalidPlaceholderType => "INVALID_PLACEHOLDER_TYPE",
                Self::InvalidCriterionType => "INVALID_CRITERION_TYPE",
                Self::NoAttributeFieldMappings => "NO_ATTRIBUTE_FIELD_MAPPINGS",
                Self::FeedAttributeTypeMismatch => "FEED_ATTRIBUTE_TYPE_MISMATCH",
                Self::CannotOperateOnMappingsForSystemGeneratedFeed => {
                    "CANNOT_OPERATE_ON_MAPPINGS_FOR_SYSTEM_GENERATED_FEED"
                }
                Self::MultipleMappingsForPlaceholderType => {
                    "MULTIPLE_MAPPINGS_FOR_PLACEHOLDER_TYPE"
                }
                Self::MultipleMappingsForCriterionType => {
                    "MULTIPLE_MAPPINGS_FOR_CRITERION_TYPE"
                }
                Self::MultipleMappingsForPlaceholderField => {
                    "MULTIPLE_MAPPINGS_FOR_PLACEHOLDER_FIELD"
                }
                Self::MultipleMappingsForCriterionField => {
                    "MULTIPLE_MAPPINGS_FOR_CRITERION_FIELD"
                }
                Self::UnexpectedAttributeFieldMappings => {
                    "UNEXPECTED_ATTRIBUTE_FIELD_MAPPINGS"
                }
                Self::LocationPlaceholderOnlyForPlacesFeeds => {
                    "LOCATION_PLACEHOLDER_ONLY_FOR_PLACES_FEEDS"
                }
                Self::CannotModifyMappingsForTypedFeed => {
                    "CANNOT_MODIFY_MAPPINGS_FOR_TYPED_FEED"
                }
                Self::InvalidPlaceholderTypeForNonSystemGeneratedFeed => {
                    "INVALID_PLACEHOLDER_TYPE_FOR_NON_SYSTEM_GENERATED_FEED"
                }
                Self::InvalidPlaceholderTypeForSystemGeneratedFeedType => {
                    "INVALID_PLACEHOLDER_TYPE_FOR_SYSTEM_GENERATED_FEED_TYPE"
                }
                Self::AttributeFieldMappingMissingField => {
                    "ATTRIBUTE_FIELD_MAPPING_MISSING_FIELD"
                }
                Self::LegacyFeedTypeReadOnly => "LEGACY_FEED_TYPE_READ_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_PLACEHOLDER_FIELD" => Some(Self::InvalidPlaceholderField),
                "INVALID_CRITERION_FIELD" => Some(Self::InvalidCriterionField),
                "INVALID_PLACEHOLDER_TYPE" => Some(Self::InvalidPlaceholderType),
                "INVALID_CRITERION_TYPE" => Some(Self::InvalidCriterionType),
                "NO_ATTRIBUTE_FIELD_MAPPINGS" => Some(Self::NoAttributeFieldMappings),
                "FEED_ATTRIBUTE_TYPE_MISMATCH" => Some(Self::FeedAttributeTypeMismatch),
                "CANNOT_OPERATE_ON_MAPPINGS_FOR_SYSTEM_GENERATED_FEED" => {
                    Some(Self::CannotOperateOnMappingsForSystemGeneratedFeed)
                }
                "MULTIPLE_MAPPINGS_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::MultipleMappingsForPlaceholderType)
                }
                "MULTIPLE_MAPPINGS_FOR_CRITERION_TYPE" => {
                    Some(Self::MultipleMappingsForCriterionType)
                }
                "MULTIPLE_MAPPINGS_FOR_PLACEHOLDER_FIELD" => {
                    Some(Self::MultipleMappingsForPlaceholderField)
                }
                "MULTIPLE_MAPPINGS_FOR_CRITERION_FIELD" => {
                    Some(Self::MultipleMappingsForCriterionField)
                }
                "UNEXPECTED_ATTRIBUTE_FIELD_MAPPINGS" => {
                    Some(Self::UnexpectedAttributeFieldMappings)
                }
                "LOCATION_PLACEHOLDER_ONLY_FOR_PLACES_FEEDS" => {
                    Some(Self::LocationPlaceholderOnlyForPlacesFeeds)
                }
                "CANNOT_MODIFY_MAPPINGS_FOR_TYPED_FEED" => {
                    Some(Self::CannotModifyMappingsForTypedFeed)
                }
                "INVALID_PLACEHOLDER_TYPE_FOR_NON_SYSTEM_GENERATED_FEED" => {
                    Some(Self::InvalidPlaceholderTypeForNonSystemGeneratedFeed)
                }
                "INVALID_PLACEHOLDER_TYPE_FOR_SYSTEM_GENERATED_FEED_TYPE" => {
                    Some(Self::InvalidPlaceholderTypeForSystemGeneratedFeedType)
                }
                "ATTRIBUTE_FIELD_MAPPING_MISSING_FIELD" => {
                    Some(Self::AttributeFieldMappingMissingField)
                }
                "LEGACY_FEED_TYPE_READ_ONLY" => Some(Self::LegacyFeedTypeReadOnly),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible field errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FieldErrorEnum {}
/// Nested message and enum types in `FieldErrorEnum`.
pub mod field_error_enum {
    /// Enum describing possible field errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FieldError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The required field was not present.
        Required = 2,
        /// The field attempted to be mutated is immutable.
        ImmutableField = 3,
        /// The field's value is invalid.
        InvalidValue = 4,
        /// The field cannot be set.
        ValueMustBeUnset = 5,
        /// The required repeated field was empty.
        RequiredNonemptyList = 6,
        /// The field cannot be cleared.
        FieldCannotBeCleared = 7,
        /// The field's value is on a deny-list for this field.
        BlockedValue = 9,
        /// The field's value cannot be modified, except for clearing.
        FieldCanOnlyBeCleared = 10,
    }
    impl FieldError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Required => "REQUIRED",
                Self::ImmutableField => "IMMUTABLE_FIELD",
                Self::InvalidValue => "INVALID_VALUE",
                Self::ValueMustBeUnset => "VALUE_MUST_BE_UNSET",
                Self::RequiredNonemptyList => "REQUIRED_NONEMPTY_LIST",
                Self::FieldCannotBeCleared => "FIELD_CANNOT_BE_CLEARED",
                Self::BlockedValue => "BLOCKED_VALUE",
                Self::FieldCanOnlyBeCleared => "FIELD_CAN_ONLY_BE_CLEARED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "REQUIRED" => Some(Self::Required),
                "IMMUTABLE_FIELD" => Some(Self::ImmutableField),
                "INVALID_VALUE" => Some(Self::InvalidValue),
                "VALUE_MUST_BE_UNSET" => Some(Self::ValueMustBeUnset),
                "REQUIRED_NONEMPTY_LIST" => Some(Self::RequiredNonemptyList),
                "FIELD_CANNOT_BE_CLEARED" => Some(Self::FieldCannotBeCleared),
                "BLOCKED_VALUE" => Some(Self::BlockedValue),
                "FIELD_CAN_ONLY_BE_CLEARED" => Some(Self::FieldCanOnlyBeCleared),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible field mask errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FieldMaskErrorEnum {}
/// Nested message and enum types in `FieldMaskErrorEnum`.
pub mod field_mask_error_enum {
    /// Enum describing possible field mask errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FieldMaskError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The field mask must be provided for update operations.
        FieldMaskMissing = 5,
        /// The field mask must be empty for create and remove operations.
        FieldMaskNotAllowed = 4,
        /// The field mask contained an invalid field.
        FieldNotFound = 2,
        /// The field mask updated a field with subfields. Fields with subfields may
        /// be cleared, but not updated. To fix this, the field mask should select
        /// all the subfields of the invalid field.
        FieldHasSubfields = 3,
    }
    impl FieldMaskError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::FieldMaskMissing => "FIELD_MASK_MISSING",
                Self::FieldMaskNotAllowed => "FIELD_MASK_NOT_ALLOWED",
                Self::FieldNotFound => "FIELD_NOT_FOUND",
                Self::FieldHasSubfields => "FIELD_HAS_SUBFIELDS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FIELD_MASK_MISSING" => Some(Self::FieldMaskMissing),
                "FIELD_MASK_NOT_ALLOWED" => Some(Self::FieldMaskNotAllowed),
                "FIELD_NOT_FOUND" => Some(Self::FieldNotFound),
                "FIELD_HAS_SUBFIELDS" => Some(Self::FieldHasSubfields),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible function errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FunctionErrorEnum {}
/// Nested message and enum types in `FunctionErrorEnum`.
pub mod function_error_enum {
    /// Enum describing possible function errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FunctionError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The format of the function is not recognized as a supported function
        /// format.
        InvalidFunctionFormat = 2,
        /// Operand data types do not match.
        DataTypeMismatch = 3,
        /// The operands cannot be used together in a conjunction.
        InvalidConjunctionOperands = 4,
        /// Invalid numer of Operands.
        InvalidNumberOfOperands = 5,
        /// Operand Type not supported.
        InvalidOperandType = 6,
        /// Operator not supported.
        InvalidOperator = 7,
        /// Request context type not supported.
        InvalidRequestContextType = 8,
        /// The matching function is not allowed for call placeholders
        InvalidFunctionForCallPlaceholder = 9,
        /// The matching function is not allowed for the specified placeholder
        InvalidFunctionForPlaceholder = 10,
        /// Invalid operand.
        InvalidOperand = 11,
        /// Missing value for the constant operand.
        MissingConstantOperandValue = 12,
        /// The value of the constant operand is invalid.
        InvalidConstantOperandValue = 13,
        /// Invalid function nesting.
        InvalidNesting = 14,
        /// The Feed ID was different from another Feed ID in the same function.
        MultipleFeedIdsNotSupported = 15,
        /// The matching function is invalid for use with a feed with a fixed schema.
        InvalidFunctionForFeedWithFixedSchema = 16,
        /// Invalid attribute name.
        InvalidAttributeName = 17,
    }
    impl FunctionError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidFunctionFormat => "INVALID_FUNCTION_FORMAT",
                Self::DataTypeMismatch => "DATA_TYPE_MISMATCH",
                Self::InvalidConjunctionOperands => "INVALID_CONJUNCTION_OPERANDS",
                Self::InvalidNumberOfOperands => "INVALID_NUMBER_OF_OPERANDS",
                Self::InvalidOperandType => "INVALID_OPERAND_TYPE",
                Self::InvalidOperator => "INVALID_OPERATOR",
                Self::InvalidRequestContextType => "INVALID_REQUEST_CONTEXT_TYPE",
                Self::InvalidFunctionForCallPlaceholder => {
                    "INVALID_FUNCTION_FOR_CALL_PLACEHOLDER"
                }
                Self::InvalidFunctionForPlaceholder => "INVALID_FUNCTION_FOR_PLACEHOLDER",
                Self::InvalidOperand => "INVALID_OPERAND",
                Self::MissingConstantOperandValue => "MISSING_CONSTANT_OPERAND_VALUE",
                Self::InvalidConstantOperandValue => "INVALID_CONSTANT_OPERAND_VALUE",
                Self::InvalidNesting => "INVALID_NESTING",
                Self::MultipleFeedIdsNotSupported => "MULTIPLE_FEED_IDS_NOT_SUPPORTED",
                Self::InvalidFunctionForFeedWithFixedSchema => {
                    "INVALID_FUNCTION_FOR_FEED_WITH_FIXED_SCHEMA"
                }
                Self::InvalidAttributeName => "INVALID_ATTRIBUTE_NAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_FUNCTION_FORMAT" => Some(Self::InvalidFunctionFormat),
                "DATA_TYPE_MISMATCH" => Some(Self::DataTypeMismatch),
                "INVALID_CONJUNCTION_OPERANDS" => Some(Self::InvalidConjunctionOperands),
                "INVALID_NUMBER_OF_OPERANDS" => Some(Self::InvalidNumberOfOperands),
                "INVALID_OPERAND_TYPE" => Some(Self::InvalidOperandType),
                "INVALID_OPERATOR" => Some(Self::InvalidOperator),
                "INVALID_REQUEST_CONTEXT_TYPE" => Some(Self::InvalidRequestContextType),
                "INVALID_FUNCTION_FOR_CALL_PLACEHOLDER" => {
                    Some(Self::InvalidFunctionForCallPlaceholder)
                }
                "INVALID_FUNCTION_FOR_PLACEHOLDER" => {
                    Some(Self::InvalidFunctionForPlaceholder)
                }
                "INVALID_OPERAND" => Some(Self::InvalidOperand),
                "MISSING_CONSTANT_OPERAND_VALUE" => {
                    Some(Self::MissingConstantOperandValue)
                }
                "INVALID_CONSTANT_OPERAND_VALUE" => {
                    Some(Self::InvalidConstantOperandValue)
                }
                "INVALID_NESTING" => Some(Self::InvalidNesting),
                "MULTIPLE_FEED_IDS_NOT_SUPPORTED" => {
                    Some(Self::MultipleFeedIdsNotSupported)
                }
                "INVALID_FUNCTION_FOR_FEED_WITH_FIXED_SCHEMA" => {
                    Some(Self::InvalidFunctionForFeedWithFixedSchema)
                }
                "INVALID_ATTRIBUTE_NAME" => Some(Self::InvalidAttributeName),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible function parsing errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FunctionParsingErrorEnum {}
/// Nested message and enum types in `FunctionParsingErrorEnum`.
pub mod function_parsing_error_enum {
    /// Enum describing possible function parsing errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FunctionParsingError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Unexpected end of function string.
        NoMoreInput = 2,
        /// Could not find an expected character.
        ExpectedCharacter = 3,
        /// Unexpected separator character.
        UnexpectedSeparator = 4,
        /// Unmatched left bracket or parenthesis.
        UnmatchedLeftBracket = 5,
        /// Unmatched right bracket or parenthesis.
        UnmatchedRightBracket = 6,
        /// Functions are nested too deeply.
        TooManyNestedFunctions = 7,
        /// Missing right-hand-side operand.
        MissingRightHandOperand = 8,
        /// Invalid operator/function name.
        InvalidOperatorName = 9,
        /// Feed attribute operand's argument is not an integer.
        FeedAttributeOperandArgumentNotInteger = 10,
        /// Missing function operands.
        NoOperands = 11,
        /// Function had too many operands.
        TooManyOperands = 12,
    }
    impl FunctionParsingError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NoMoreInput => "NO_MORE_INPUT",
                Self::ExpectedCharacter => "EXPECTED_CHARACTER",
                Self::UnexpectedSeparator => "UNEXPECTED_SEPARATOR",
                Self::UnmatchedLeftBracket => "UNMATCHED_LEFT_BRACKET",
                Self::UnmatchedRightBracket => "UNMATCHED_RIGHT_BRACKET",
                Self::TooManyNestedFunctions => "TOO_MANY_NESTED_FUNCTIONS",
                Self::MissingRightHandOperand => "MISSING_RIGHT_HAND_OPERAND",
                Self::InvalidOperatorName => "INVALID_OPERATOR_NAME",
                Self::FeedAttributeOperandArgumentNotInteger => {
                    "FEED_ATTRIBUTE_OPERAND_ARGUMENT_NOT_INTEGER"
                }
                Self::NoOperands => "NO_OPERANDS",
                Self::TooManyOperands => "TOO_MANY_OPERANDS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NO_MORE_INPUT" => Some(Self::NoMoreInput),
                "EXPECTED_CHARACTER" => Some(Self::ExpectedCharacter),
                "UNEXPECTED_SEPARATOR" => Some(Self::UnexpectedSeparator),
                "UNMATCHED_LEFT_BRACKET" => Some(Self::UnmatchedLeftBracket),
                "UNMATCHED_RIGHT_BRACKET" => Some(Self::UnmatchedRightBracket),
                "TOO_MANY_NESTED_FUNCTIONS" => Some(Self::TooManyNestedFunctions),
                "MISSING_RIGHT_HAND_OPERAND" => Some(Self::MissingRightHandOperand),
                "INVALID_OPERATOR_NAME" => Some(Self::InvalidOperatorName),
                "FEED_ATTRIBUTE_OPERAND_ARGUMENT_NOT_INTEGER" => {
                    Some(Self::FeedAttributeOperandArgumentNotInteger)
                }
                "NO_OPERANDS" => Some(Self::NoOperands),
                "TOO_MANY_OPERANDS" => Some(Self::TooManyOperands),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible geo target constant suggestion errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GeoTargetConstantSuggestionErrorEnum {}
/// Nested message and enum types in `GeoTargetConstantSuggestionErrorEnum`.
pub mod geo_target_constant_suggestion_error_enum {
    /// Enum describing possible geo target constant suggestion errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GeoTargetConstantSuggestionError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// A location name cannot be greater than 300 characters.
        LocationNameSizeLimit = 2,
        /// At most 25 location names can be specified in a SuggestGeoTargetConstants
        /// method.
        LocationNameLimit = 3,
        /// The country code is invalid.
        InvalidCountryCode = 4,
        /// Geo target constant resource names or location names must be provided in
        /// the request.
        RequestParametersUnset = 5,
    }
    impl GeoTargetConstantSuggestionError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::LocationNameSizeLimit => "LOCATION_NAME_SIZE_LIMIT",
                Self::LocationNameLimit => "LOCATION_NAME_LIMIT",
                Self::InvalidCountryCode => "INVALID_COUNTRY_CODE",
                Self::RequestParametersUnset => "REQUEST_PARAMETERS_UNSET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LOCATION_NAME_SIZE_LIMIT" => Some(Self::LocationNameSizeLimit),
                "LOCATION_NAME_LIMIT" => Some(Self::LocationNameLimit),
                "INVALID_COUNTRY_CODE" => Some(Self::InvalidCountryCode),
                "REQUEST_PARAMETERS_UNSET" => Some(Self::RequestParametersUnset),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible header errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HeaderErrorEnum {}
/// Nested message and enum types in `HeaderErrorEnum`.
pub mod header_error_enum {
    /// Enum describing possible header errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HeaderError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The login customer ID could not be validated.
        InvalidLoginCustomerId = 3,
        /// The linked customer ID could not be validated.
        InvalidLinkedCustomerId = 7,
    }
    impl HeaderError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidLoginCustomerId => "INVALID_LOGIN_CUSTOMER_ID",
                Self::InvalidLinkedCustomerId => "INVALID_LINKED_CUSTOMER_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_LOGIN_CUSTOMER_ID" => Some(Self::InvalidLoginCustomerId),
                "INVALID_LINKED_CUSTOMER_ID" => Some(Self::InvalidLinkedCustomerId),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible ID errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IdErrorEnum {}
/// Nested message and enum types in `IdErrorEnum`.
pub mod id_error_enum {
    /// Enum describing possible ID errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IdError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// ID not found
        NotFound = 2,
    }
    impl IdError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NotFound => "NOT_FOUND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOT_FOUND" => Some(Self::NotFound),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible identity verification errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IdentityVerificationErrorEnum {}
/// Nested message and enum types in `IdentityVerificationErrorEnum`.
pub mod identity_verification_error_enum {
    /// Enum describing possible identity verification errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IdentityVerificationError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// No effective billing linked to this customer.
        NoEffectiveBilling = 2,
        /// Customer is not on monthly invoicing.
        BillingNotOnMonthlyInvoicing = 3,
        /// Verification for this program type was already started.
        VerificationAlreadyStarted = 4,
    }
    impl IdentityVerificationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NoEffectiveBilling => "NO_EFFECTIVE_BILLING",
                Self::BillingNotOnMonthlyInvoicing => "BILLING_NOT_ON_MONTHLY_INVOICING",
                Self::VerificationAlreadyStarted => "VERIFICATION_ALREADY_STARTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NO_EFFECTIVE_BILLING" => Some(Self::NoEffectiveBilling),
                "BILLING_NOT_ON_MONTHLY_INVOICING" => {
                    Some(Self::BillingNotOnMonthlyInvoicing)
                }
                "VERIFICATION_ALREADY_STARTED" => Some(Self::VerificationAlreadyStarted),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible image errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImageErrorEnum {}
/// Nested message and enum types in `ImageErrorEnum`.
pub mod image_error_enum {
    /// Enum describing possible image errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ImageError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The image is not valid.
        InvalidImage = 2,
        /// The image could not be stored.
        StorageError = 3,
        /// There was a problem with the request.
        BadRequest = 4,
        /// The image is not of legal dimensions.
        UnexpectedSize = 5,
        /// Animated image are not permitted.
        AnimatedNotAllowed = 6,
        /// Animation is too long.
        AnimationTooLong = 7,
        /// There was an error on the server.
        ServerError = 8,
        /// Image cannot be in CMYK color format.
        CmykJpegNotAllowed = 9,
        /// Flash images are not permitted.
        FlashNotAllowed = 10,
        /// Flash images must support clickTag.
        FlashWithoutClicktag = 11,
        /// A flash error has occurred after fixing the click tag.
        FlashErrorAfterFixingClickTag = 12,
        /// Unacceptable visual effects.
        AnimatedVisualEffect = 13,
        /// There was a problem with the flash image.
        FlashError = 14,
        /// Incorrect image layout.
        LayoutProblem = 15,
        /// There was a problem reading the image file.
        ProblemReadingImageFile = 16,
        /// There was an error storing the image.
        ErrorStoringImage = 17,
        /// The aspect ratio of the image is not allowed.
        AspectRatioNotAllowed = 18,
        /// Flash cannot have network objects.
        FlashHasNetworkObjects = 19,
        /// Flash cannot have network methods.
        FlashHasNetworkMethods = 20,
        /// Flash cannot have a Url.
        FlashHasUrl = 21,
        /// Flash cannot use mouse tracking.
        FlashHasMouseTracking = 22,
        /// Flash cannot have a random number.
        FlashHasRandomNum = 23,
        /// Ad click target cannot be '_self'.
        FlashSelfTargets = 24,
        /// GetUrl method should only use '_blank'.
        FlashBadGeturlTarget = 25,
        /// Flash version is not supported.
        FlashVersionNotSupported = 26,
        /// Flash movies need to have hard coded click URL or clickTAG
        FlashWithoutHardCodedClickUrl = 27,
        /// Uploaded flash file is corrupted.
        InvalidFlashFile = 28,
        /// Uploaded flash file can be parsed, but the click tag can not be fixed
        /// properly.
        FailedToFixClickTagInFlash = 29,
        /// Flash movie accesses network resources
        FlashAccessesNetworkResources = 30,
        /// Flash movie attempts to call external javascript code
        FlashExternalJsCall = 31,
        /// Flash movie attempts to call flash system commands
        FlashExternalFsCall = 32,
        /// Image file is too large.
        FileTooLarge = 33,
        /// Image data is too large.
        ImageDataTooLarge = 34,
        /// Error while processing the image.
        ImageProcessingError = 35,
        /// Image is too small.
        ImageTooSmall = 36,
        /// Input was invalid.
        InvalidInput = 37,
        /// There was a problem reading the image file.
        ProblemReadingFile = 38,
        /// Image constraints are violated, but details like ASPECT_RATIO_NOT_ALLOWED
        /// can't be provided. This happens when asset spec contains more than one
        /// constraint and different criteria of different constraints are violated.
        ImageConstraintsViolated = 39,
        /// Image format is not allowed.
        FormatNotAllowed = 40,
    }
    impl ImageError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidImage => "INVALID_IMAGE",
                Self::StorageError => "STORAGE_ERROR",
                Self::BadRequest => "BAD_REQUEST",
                Self::UnexpectedSize => "UNEXPECTED_SIZE",
                Self::AnimatedNotAllowed => "ANIMATED_NOT_ALLOWED",
                Self::AnimationTooLong => "ANIMATION_TOO_LONG",
                Self::ServerError => "SERVER_ERROR",
                Self::CmykJpegNotAllowed => "CMYK_JPEG_NOT_ALLOWED",
                Self::FlashNotAllowed => "FLASH_NOT_ALLOWED",
                Self::FlashWithoutClicktag => "FLASH_WITHOUT_CLICKTAG",
                Self::FlashErrorAfterFixingClickTag => {
                    "FLASH_ERROR_AFTER_FIXING_CLICK_TAG"
                }
                Self::AnimatedVisualEffect => "ANIMATED_VISUAL_EFFECT",
                Self::FlashError => "FLASH_ERROR",
                Self::LayoutProblem => "LAYOUT_PROBLEM",
                Self::ProblemReadingImageFile => "PROBLEM_READING_IMAGE_FILE",
                Self::ErrorStoringImage => "ERROR_STORING_IMAGE",
                Self::AspectRatioNotAllowed => "ASPECT_RATIO_NOT_ALLOWED",
                Self::FlashHasNetworkObjects => "FLASH_HAS_NETWORK_OBJECTS",
                Self::FlashHasNetworkMethods => "FLASH_HAS_NETWORK_METHODS",
                Self::FlashHasUrl => "FLASH_HAS_URL",
                Self::FlashHasMouseTracking => "FLASH_HAS_MOUSE_TRACKING",
                Self::FlashHasRandomNum => "FLASH_HAS_RANDOM_NUM",
                Self::FlashSelfTargets => "FLASH_SELF_TARGETS",
                Self::FlashBadGeturlTarget => "FLASH_BAD_GETURL_TARGET",
                Self::FlashVersionNotSupported => "FLASH_VERSION_NOT_SUPPORTED",
                Self::FlashWithoutHardCodedClickUrl => {
                    "FLASH_WITHOUT_HARD_CODED_CLICK_URL"
                }
                Self::InvalidFlashFile => "INVALID_FLASH_FILE",
                Self::FailedToFixClickTagInFlash => "FAILED_TO_FIX_CLICK_TAG_IN_FLASH",
                Self::FlashAccessesNetworkResources => "FLASH_ACCESSES_NETWORK_RESOURCES",
                Self::FlashExternalJsCall => "FLASH_EXTERNAL_JS_CALL",
                Self::FlashExternalFsCall => "FLASH_EXTERNAL_FS_CALL",
                Self::FileTooLarge => "FILE_TOO_LARGE",
                Self::ImageDataTooLarge => "IMAGE_DATA_TOO_LARGE",
                Self::ImageProcessingError => "IMAGE_PROCESSING_ERROR",
                Self::ImageTooSmall => "IMAGE_TOO_SMALL",
                Self::InvalidInput => "INVALID_INPUT",
                Self::ProblemReadingFile => "PROBLEM_READING_FILE",
                Self::ImageConstraintsViolated => "IMAGE_CONSTRAINTS_VIOLATED",
                Self::FormatNotAllowed => "FORMAT_NOT_ALLOWED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_IMAGE" => Some(Self::InvalidImage),
                "STORAGE_ERROR" => Some(Self::StorageError),
                "BAD_REQUEST" => Some(Self::BadRequest),
                "UNEXPECTED_SIZE" => Some(Self::UnexpectedSize),
                "ANIMATED_NOT_ALLOWED" => Some(Self::AnimatedNotAllowed),
                "ANIMATION_TOO_LONG" => Some(Self::AnimationTooLong),
                "SERVER_ERROR" => Some(Self::ServerError),
                "CMYK_JPEG_NOT_ALLOWED" => Some(Self::CmykJpegNotAllowed),
                "FLASH_NOT_ALLOWED" => Some(Self::FlashNotAllowed),
                "FLASH_WITHOUT_CLICKTAG" => Some(Self::FlashWithoutClicktag),
                "FLASH_ERROR_AFTER_FIXING_CLICK_TAG" => {
                    Some(Self::FlashErrorAfterFixingClickTag)
                }
                "ANIMATED_VISUAL_EFFECT" => Some(Self::AnimatedVisualEffect),
                "FLASH_ERROR" => Some(Self::FlashError),
                "LAYOUT_PROBLEM" => Some(Self::LayoutProblem),
                "PROBLEM_READING_IMAGE_FILE" => Some(Self::ProblemReadingImageFile),
                "ERROR_STORING_IMAGE" => Some(Self::ErrorStoringImage),
                "ASPECT_RATIO_NOT_ALLOWED" => Some(Self::AspectRatioNotAllowed),
                "FLASH_HAS_NETWORK_OBJECTS" => Some(Self::FlashHasNetworkObjects),
                "FLASH_HAS_NETWORK_METHODS" => Some(Self::FlashHasNetworkMethods),
                "FLASH_HAS_URL" => Some(Self::FlashHasUrl),
                "FLASH_HAS_MOUSE_TRACKING" => Some(Self::FlashHasMouseTracking),
                "FLASH_HAS_RANDOM_NUM" => Some(Self::FlashHasRandomNum),
                "FLASH_SELF_TARGETS" => Some(Self::FlashSelfTargets),
                "FLASH_BAD_GETURL_TARGET" => Some(Self::FlashBadGeturlTarget),
                "FLASH_VERSION_NOT_SUPPORTED" => Some(Self::FlashVersionNotSupported),
                "FLASH_WITHOUT_HARD_CODED_CLICK_URL" => {
                    Some(Self::FlashWithoutHardCodedClickUrl)
                }
                "INVALID_FLASH_FILE" => Some(Self::InvalidFlashFile),
                "FAILED_TO_FIX_CLICK_TAG_IN_FLASH" => {
                    Some(Self::FailedToFixClickTagInFlash)
                }
                "FLASH_ACCESSES_NETWORK_RESOURCES" => {
                    Some(Self::FlashAccessesNetworkResources)
                }
                "FLASH_EXTERNAL_JS_CALL" => Some(Self::FlashExternalJsCall),
                "FLASH_EXTERNAL_FS_CALL" => Some(Self::FlashExternalFsCall),
                "FILE_TOO_LARGE" => Some(Self::FileTooLarge),
                "IMAGE_DATA_TOO_LARGE" => Some(Self::ImageDataTooLarge),
                "IMAGE_PROCESSING_ERROR" => Some(Self::ImageProcessingError),
                "IMAGE_TOO_SMALL" => Some(Self::ImageTooSmall),
                "INVALID_INPUT" => Some(Self::InvalidInput),
                "PROBLEM_READING_FILE" => Some(Self::ProblemReadingFile),
                "IMAGE_CONSTRAINTS_VIOLATED" => Some(Self::ImageConstraintsViolated),
                "FORMAT_NOT_ALLOWED" => Some(Self::FormatNotAllowed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible internal errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InternalErrorEnum {}
/// Nested message and enum types in `InternalErrorEnum`.
pub mod internal_error_enum {
    /// Enum describing possible internal errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InternalError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Google Ads API encountered unexpected internal error.
        InternalError = 2,
        /// The intended error code doesn't exist in specified API version. It will
        /// be released in a future API version.
        ErrorCodeNotPublished = 3,
        /// Google Ads API encountered an unexpected transient error. The user
        /// should retry their request in these cases.
        TransientError = 4,
        /// The request took longer than a deadline.
        DeadlineExceeded = 5,
    }
    impl InternalError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InternalError => "INTERNAL_ERROR",
                Self::ErrorCodeNotPublished => "ERROR_CODE_NOT_PUBLISHED",
                Self::TransientError => "TRANSIENT_ERROR",
                Self::DeadlineExceeded => "DEADLINE_EXCEEDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INTERNAL_ERROR" => Some(Self::InternalError),
                "ERROR_CODE_NOT_PUBLISHED" => Some(Self::ErrorCodeNotPublished),
                "TRANSIENT_ERROR" => Some(Self::TransientError),
                "DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible invoice errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InvoiceErrorEnum {}
/// Nested message and enum types in `InvoiceErrorEnum`.
pub mod invoice_error_enum {
    /// Enum describing possible invoice errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InvoiceError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Cannot request invoices issued before 2019-01-01.
        YearMonthTooOld = 2,
        /// Cannot request invoices for customer who doesn't receive invoices.
        NotInvoicedCustomer = 3,
        /// Cannot request invoices for a non approved billing setup.
        BillingSetupNotApproved = 4,
        /// Cannot request invoices for a billing setup that is not on monthly
        /// invoicing.
        BillingSetupNotOnMonthlyInvoicing = 5,
        /// Cannot request invoices for a non serving customer.
        NonServingCustomer = 6,
    }
    impl InvoiceError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::YearMonthTooOld => "YEAR_MONTH_TOO_OLD",
                Self::NotInvoicedCustomer => "NOT_INVOICED_CUSTOMER",
                Self::BillingSetupNotApproved => "BILLING_SETUP_NOT_APPROVED",
                Self::BillingSetupNotOnMonthlyInvoicing => {
                    "BILLING_SETUP_NOT_ON_MONTHLY_INVOICING"
                }
                Self::NonServingCustomer => "NON_SERVING_CUSTOMER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "YEAR_MONTH_TOO_OLD" => Some(Self::YearMonthTooOld),
                "NOT_INVOICED_CUSTOMER" => Some(Self::NotInvoicedCustomer),
                "BILLING_SETUP_NOT_APPROVED" => Some(Self::BillingSetupNotApproved),
                "BILLING_SETUP_NOT_ON_MONTHLY_INVOICING" => {
                    Some(Self::BillingSetupNotOnMonthlyInvoicing)
                }
                "NON_SERVING_CUSTOMER" => Some(Self::NonServingCustomer),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible errors from applying a keyword plan
/// ad group.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanAdGroupErrorEnum {}
/// Nested message and enum types in `KeywordPlanAdGroupErrorEnum`.
pub mod keyword_plan_ad_group_error_enum {
    /// Enum describing possible errors from applying a keyword plan ad group.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanAdGroupError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The keyword plan ad group name is missing, empty, longer than allowed
        /// limit or contains invalid chars.
        InvalidName = 2,
        /// The keyword plan ad group name is duplicate to an existing keyword plan
        /// AdGroup name or other keyword plan AdGroup name in the request.
        DuplicateName = 3,
    }
    impl KeywordPlanAdGroupError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidName => "INVALID_NAME",
                Self::DuplicateName => "DUPLICATE_NAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_NAME" => Some(Self::InvalidName),
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible errors from applying an ad group
/// keyword or a campaign keyword from a keyword plan.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanAdGroupKeywordErrorEnum {}
/// Nested message and enum types in `KeywordPlanAdGroupKeywordErrorEnum`.
pub mod keyword_plan_ad_group_keyword_error_enum {
    /// Enum describing possible errors from applying a keyword plan ad group
    /// keyword or keyword plan campaign keyword.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanAdGroupKeywordError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// A keyword or negative keyword has invalid match type.
        InvalidKeywordMatchType = 2,
        /// A keyword or negative keyword with same text and match type already
        /// exists.
        DuplicateKeyword = 3,
        /// Keyword or negative keyword text exceeds the allowed limit.
        KeywordTextTooLong = 4,
        /// Keyword or negative keyword text has invalid characters or symbols.
        KeywordHasInvalidChars = 5,
        /// Keyword or negative keyword text has too many words.
        KeywordHasTooManyWords = 6,
        /// Keyword or negative keyword has invalid text.
        InvalidKeywordText = 7,
        /// Cpc Bid set for negative keyword.
        NegativeKeywordHasCpcBid = 8,
        /// New broad match modifier (BMM) KpAdGroupKeywords are not allowed.
        NewBmmKeywordsNotAllowed = 9,
    }
    impl KeywordPlanAdGroupKeywordError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidKeywordMatchType => "INVALID_KEYWORD_MATCH_TYPE",
                Self::DuplicateKeyword => "DUPLICATE_KEYWORD",
                Self::KeywordTextTooLong => "KEYWORD_TEXT_TOO_LONG",
                Self::KeywordHasInvalidChars => "KEYWORD_HAS_INVALID_CHARS",
                Self::KeywordHasTooManyWords => "KEYWORD_HAS_TOO_MANY_WORDS",
                Self::InvalidKeywordText => "INVALID_KEYWORD_TEXT",
                Self::NegativeKeywordHasCpcBid => "NEGATIVE_KEYWORD_HAS_CPC_BID",
                Self::NewBmmKeywordsNotAllowed => "NEW_BMM_KEYWORDS_NOT_ALLOWED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_KEYWORD_MATCH_TYPE" => Some(Self::InvalidKeywordMatchType),
                "DUPLICATE_KEYWORD" => Some(Self::DuplicateKeyword),
                "KEYWORD_TEXT_TOO_LONG" => Some(Self::KeywordTextTooLong),
                "KEYWORD_HAS_INVALID_CHARS" => Some(Self::KeywordHasInvalidChars),
                "KEYWORD_HAS_TOO_MANY_WORDS" => Some(Self::KeywordHasTooManyWords),
                "INVALID_KEYWORD_TEXT" => Some(Self::InvalidKeywordText),
                "NEGATIVE_KEYWORD_HAS_CPC_BID" => Some(Self::NegativeKeywordHasCpcBid),
                "NEW_BMM_KEYWORDS_NOT_ALLOWED" => Some(Self::NewBmmKeywordsNotAllowed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible errors from applying a keyword plan
/// campaign.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanCampaignErrorEnum {}
/// Nested message and enum types in `KeywordPlanCampaignErrorEnum`.
pub mod keyword_plan_campaign_error_enum {
    /// Enum describing possible errors from applying a keyword plan campaign.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanCampaignError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// A keyword plan campaign name is missing, empty, longer than allowed limit
        /// or contains invalid chars.
        InvalidName = 2,
        /// A keyword plan campaign contains one or more untargetable languages.
        InvalidLanguages = 3,
        /// A keyword plan campaign contains one or more invalid geo targets.
        InvalidGeos = 4,
        /// The keyword plan campaign name is duplicate to an existing keyword plan
        /// campaign name or other keyword plan campaign name in the request.
        DuplicateName = 5,
        /// The number of geo targets in the keyword plan campaign exceeds limits.
        MaxGeosExceeded = 6,
        /// The number of languages in the keyword plan campaign exceeds limits.
        MaxLanguagesExceeded = 7,
    }
    impl KeywordPlanCampaignError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidName => "INVALID_NAME",
                Self::InvalidLanguages => "INVALID_LANGUAGES",
                Self::InvalidGeos => "INVALID_GEOS",
                Self::DuplicateName => "DUPLICATE_NAME",
                Self::MaxGeosExceeded => "MAX_GEOS_EXCEEDED",
                Self::MaxLanguagesExceeded => "MAX_LANGUAGES_EXCEEDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_NAME" => Some(Self::InvalidName),
                "INVALID_LANGUAGES" => Some(Self::InvalidLanguages),
                "INVALID_GEOS" => Some(Self::InvalidGeos),
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "MAX_GEOS_EXCEEDED" => Some(Self::MaxGeosExceeded),
                "MAX_LANGUAGES_EXCEEDED" => Some(Self::MaxLanguagesExceeded),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible errors from applying a keyword plan
/// campaign keyword.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanCampaignKeywordErrorEnum {}
/// Nested message and enum types in `KeywordPlanCampaignKeywordErrorEnum`.
pub mod keyword_plan_campaign_keyword_error_enum {
    /// Enum describing possible errors from applying a keyword plan campaign
    /// keyword.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanCampaignKeywordError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Keyword plan campaign keyword is positive.
        CampaignKeywordIsPositive = 8,
    }
    impl KeywordPlanCampaignKeywordError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CampaignKeywordIsPositive => "CAMPAIGN_KEYWORD_IS_POSITIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_KEYWORD_IS_POSITIVE" => Some(Self::CampaignKeywordIsPositive),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible errors from applying a keyword plan
/// resource (keyword plan, keyword plan campaign, keyword plan ad group or
/// keyword plan keyword) or KeywordPlanService RPC.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanErrorEnum {}
/// Nested message and enum types in `KeywordPlanErrorEnum`.
pub mod keyword_plan_error_enum {
    /// Enum describing possible errors from applying a keyword plan.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The plan's bid multiplier value is outside the valid range.
        BidMultiplierOutOfRange = 2,
        /// The plan's bid value is too high.
        BidTooHigh = 3,
        /// The plan's bid value is too low.
        BidTooLow = 4,
        /// The plan's cpc bid is not a multiple of the minimum billable unit.
        BidTooManyFractionalDigits = 5,
        /// The plan's daily budget value is too low.
        DailyBudgetTooLow = 6,
        /// The plan's daily budget is not a multiple of the minimum billable unit.
        DailyBudgetTooManyFractionalDigits = 7,
        /// The input has an invalid value.
        InvalidValue = 8,
        /// The plan has no keyword.
        KeywordPlanHasNoKeywords = 9,
        /// The plan is not enabled and API cannot provide mutation, forecast or
        /// stats.
        KeywordPlanNotEnabled = 10,
        /// The requested plan cannot be found for providing forecast or stats.
        KeywordPlanNotFound = 11,
        /// The plan is missing a cpc bid.
        MissingBid = 13,
        /// The plan is missing required forecast_period field.
        MissingForecastPeriod = 14,
        /// The plan's forecast_period has invalid forecast date range.
        InvalidForecastDateRange = 15,
        /// The plan's name is invalid.
        InvalidName = 16,
    }
    impl KeywordPlanError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::BidMultiplierOutOfRange => "BID_MULTIPLIER_OUT_OF_RANGE",
                Self::BidTooHigh => "BID_TOO_HIGH",
                Self::BidTooLow => "BID_TOO_LOW",
                Self::BidTooManyFractionalDigits => "BID_TOO_MANY_FRACTIONAL_DIGITS",
                Self::DailyBudgetTooLow => "DAILY_BUDGET_TOO_LOW",
                Self::DailyBudgetTooManyFractionalDigits => {
                    "DAILY_BUDGET_TOO_MANY_FRACTIONAL_DIGITS"
                }
                Self::InvalidValue => "INVALID_VALUE",
                Self::KeywordPlanHasNoKeywords => "KEYWORD_PLAN_HAS_NO_KEYWORDS",
                Self::KeywordPlanNotEnabled => "KEYWORD_PLAN_NOT_ENABLED",
                Self::KeywordPlanNotFound => "KEYWORD_PLAN_NOT_FOUND",
                Self::MissingBid => "MISSING_BID",
                Self::MissingForecastPeriod => "MISSING_FORECAST_PERIOD",
                Self::InvalidForecastDateRange => "INVALID_FORECAST_DATE_RANGE",
                Self::InvalidName => "INVALID_NAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BID_MULTIPLIER_OUT_OF_RANGE" => Some(Self::BidMultiplierOutOfRange),
                "BID_TOO_HIGH" => Some(Self::BidTooHigh),
                "BID_TOO_LOW" => Some(Self::BidTooLow),
                "BID_TOO_MANY_FRACTIONAL_DIGITS" => {
                    Some(Self::BidTooManyFractionalDigits)
                }
                "DAILY_BUDGET_TOO_LOW" => Some(Self::DailyBudgetTooLow),
                "DAILY_BUDGET_TOO_MANY_FRACTIONAL_DIGITS" => {
                    Some(Self::DailyBudgetTooManyFractionalDigits)
                }
                "INVALID_VALUE" => Some(Self::InvalidValue),
                "KEYWORD_PLAN_HAS_NO_KEYWORDS" => Some(Self::KeywordPlanHasNoKeywords),
                "KEYWORD_PLAN_NOT_ENABLED" => Some(Self::KeywordPlanNotEnabled),
                "KEYWORD_PLAN_NOT_FOUND" => Some(Self::KeywordPlanNotFound),
                "MISSING_BID" => Some(Self::MissingBid),
                "MISSING_FORECAST_PERIOD" => Some(Self::MissingForecastPeriod),
                "INVALID_FORECAST_DATE_RANGE" => Some(Self::InvalidForecastDateRange),
                "INVALID_NAME" => Some(Self::InvalidName),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible errors from KeywordPlanIdeaService.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanIdeaErrorEnum {}
/// Nested message and enum types in `KeywordPlanIdeaErrorEnum`.
pub mod keyword_plan_idea_error_enum {
    /// Enum describing possible errors from KeywordPlanIdeaService.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanIdeaError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Error when crawling the input URL.
        UrlCrawlError = 2,
        /// The input has an invalid value.
        InvalidValue = 3,
    }
    impl KeywordPlanIdeaError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::UrlCrawlError => "URL_CRAWL_ERROR",
                Self::InvalidValue => "INVALID_VALUE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "URL_CRAWL_ERROR" => Some(Self::UrlCrawlError),
                "INVALID_VALUE" => Some(Self::InvalidValue),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible label errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LabelErrorEnum {}
/// Nested message and enum types in `LabelErrorEnum`.
pub mod label_error_enum {
    /// Enum describing possible label errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LabelError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// An inactive label cannot be applied.
        CannotApplyInactiveLabel = 2,
        /// A label cannot be applied to a disabled ad group criterion.
        CannotApplyLabelToDisabledAdGroupCriterion = 3,
        /// A label cannot be applied to a negative ad group criterion.
        CannotApplyLabelToNegativeAdGroupCriterion = 4,
        /// Cannot apply more than 50 labels per resource.
        ExceededLabelLimitPerType = 5,
        /// Labels from a manager account cannot be applied to campaign, ad group,
        /// ad group ad, or ad group criterion resources.
        InvalidResourceForManagerLabel = 6,
        /// Label names must be unique.
        DuplicateName = 7,
        /// Label names cannot be empty.
        InvalidLabelName = 8,
        /// Labels cannot be applied to a draft.
        CannotAttachLabelToDraft = 9,
        /// Labels not from a manager account cannot be applied to the customer
        /// resource.
        CannotAttachNonManagerLabelToCustomer = 10,
    }
    impl LabelError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CannotApplyInactiveLabel => "CANNOT_APPLY_INACTIVE_LABEL",
                Self::CannotApplyLabelToDisabledAdGroupCriterion => {
                    "CANNOT_APPLY_LABEL_TO_DISABLED_AD_GROUP_CRITERION"
                }
                Self::CannotApplyLabelToNegativeAdGroupCriterion => {
                    "CANNOT_APPLY_LABEL_TO_NEGATIVE_AD_GROUP_CRITERION"
                }
                Self::ExceededLabelLimitPerType => "EXCEEDED_LABEL_LIMIT_PER_TYPE",
                Self::InvalidResourceForManagerLabel => {
                    "INVALID_RESOURCE_FOR_MANAGER_LABEL"
                }
                Self::DuplicateName => "DUPLICATE_NAME",
                Self::InvalidLabelName => "INVALID_LABEL_NAME",
                Self::CannotAttachLabelToDraft => "CANNOT_ATTACH_LABEL_TO_DRAFT",
                Self::CannotAttachNonManagerLabelToCustomer => {
                    "CANNOT_ATTACH_NON_MANAGER_LABEL_TO_CUSTOMER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_APPLY_INACTIVE_LABEL" => Some(Self::CannotApplyInactiveLabel),
                "CANNOT_APPLY_LABEL_TO_DISABLED_AD_GROUP_CRITERION" => {
                    Some(Self::CannotApplyLabelToDisabledAdGroupCriterion)
                }
                "CANNOT_APPLY_LABEL_TO_NEGATIVE_AD_GROUP_CRITERION" => {
                    Some(Self::CannotApplyLabelToNegativeAdGroupCriterion)
                }
                "EXCEEDED_LABEL_LIMIT_PER_TYPE" => Some(Self::ExceededLabelLimitPerType),
                "INVALID_RESOURCE_FOR_MANAGER_LABEL" => {
                    Some(Self::InvalidResourceForManagerLabel)
                }
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "INVALID_LABEL_NAME" => Some(Self::InvalidLabelName),
                "CANNOT_ATTACH_LABEL_TO_DRAFT" => Some(Self::CannotAttachLabelToDraft),
                "CANNOT_ATTACH_NON_MANAGER_LABEL_TO_CUSTOMER" => {
                    Some(Self::CannotAttachNonManagerLabelToCustomer)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing language code errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanguageCodeErrorEnum {}
/// Nested message and enum types in `LanguageCodeErrorEnum`.
pub mod language_code_error_enum {
    /// Enum describing language code errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LanguageCodeError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The input language code is not recognized.
        LanguageCodeNotFound = 2,
        /// The language code is not supported.
        InvalidLanguageCode = 3,
    }
    impl LanguageCodeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::LanguageCodeNotFound => "LANGUAGE_CODE_NOT_FOUND",
                Self::InvalidLanguageCode => "INVALID_LANGUAGE_CODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LANGUAGE_CODE_NOT_FOUND" => Some(Self::LanguageCodeNotFound),
                "INVALID_LANGUAGE_CODE" => Some(Self::InvalidLanguageCode),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible list operation errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListOperationErrorEnum {}
/// Nested message and enum types in `ListOperationErrorEnum`.
pub mod list_operation_error_enum {
    /// Enum describing possible list operation errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListOperationError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Field required in value is missing.
        RequiredFieldMissing = 7,
        /// Duplicate or identical value is sent in multiple list operations.
        DuplicateValues = 8,
    }
    impl ListOperationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::RequiredFieldMissing => "REQUIRED_FIELD_MISSING",
                Self::DuplicateValues => "DUPLICATE_VALUES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "REQUIRED_FIELD_MISSING" => Some(Self::RequiredFieldMissing),
                "DUPLICATE_VALUES" => Some(Self::DuplicateValues),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible ManagerLink errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ManagerLinkErrorEnum {}
/// Nested message and enum types in `ManagerLinkErrorEnum`.
pub mod manager_link_error_enum {
    /// Enum describing possible ManagerLink errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ManagerLinkError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The manager and client have incompatible account types.
        AccountsNotCompatibleForLinking = 2,
        /// Client is already linked to too many managers.
        TooManyManagers = 3,
        /// Manager has too many pending invitations.
        TooManyInvites = 4,
        /// Client is already invited by this manager.
        AlreadyInvitedByThisManager = 5,
        /// The client is already managed by this manager.
        AlreadyManagedByThisManager = 6,
        /// Client is already managed in hierarchy.
        AlreadyManagedInHierarchy = 7,
        /// Manager and sub-manager to be linked have duplicate client.
        DuplicateChildFound = 8,
        /// Client has no active user that can access the client account.
        ClientHasNoAdminUser = 9,
        /// Adding this link would exceed the maximum hierarchy depth.
        MaxDepthExceeded = 10,
        /// Adding this link will create a cycle.
        CycleNotAllowed = 11,
        /// Manager account has the maximum number of linked clients.
        TooManyAccounts = 12,
        /// Parent manager account has the maximum number of linked clients.
        TooManyAccountsAtManager = 13,
        /// The account is not authorized owner.
        NonOwnerUserCannotModifyLink = 14,
        /// Your manager account is suspended, and you are no longer allowed to link
        /// to clients.
        SuspendedAccountCannotAddClients = 15,
        /// You are not allowed to move a client to a manager that is not under your
        /// current hierarchy.
        ClientOutsideTree = 16,
        /// The changed status for mutate link is invalid.
        InvalidStatusChange = 17,
        /// The change for mutate link is invalid.
        InvalidChange = 18,
        /// You are not allowed to link a manager account to itself.
        CustomerCannotManageSelf = 19,
        /// The link was created with status ACTIVE and not PENDING.
        CreatingEnabledLinkNotAllowed = 20,
    }
    impl ManagerLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AccountsNotCompatibleForLinking => {
                    "ACCOUNTS_NOT_COMPATIBLE_FOR_LINKING"
                }
                Self::TooManyManagers => "TOO_MANY_MANAGERS",
                Self::TooManyInvites => "TOO_MANY_INVITES",
                Self::AlreadyInvitedByThisManager => "ALREADY_INVITED_BY_THIS_MANAGER",
                Self::AlreadyManagedByThisManager => "ALREADY_MANAGED_BY_THIS_MANAGER",
                Self::AlreadyManagedInHierarchy => "ALREADY_MANAGED_IN_HIERARCHY",
                Self::DuplicateChildFound => "DUPLICATE_CHILD_FOUND",
                Self::ClientHasNoAdminUser => "CLIENT_HAS_NO_ADMIN_USER",
                Self::MaxDepthExceeded => "MAX_DEPTH_EXCEEDED",
                Self::CycleNotAllowed => "CYCLE_NOT_ALLOWED",
                Self::TooManyAccounts => "TOO_MANY_ACCOUNTS",
                Self::TooManyAccountsAtManager => "TOO_MANY_ACCOUNTS_AT_MANAGER",
                Self::NonOwnerUserCannotModifyLink => "NON_OWNER_USER_CANNOT_MODIFY_LINK",
                Self::SuspendedAccountCannotAddClients => {
                    "SUSPENDED_ACCOUNT_CANNOT_ADD_CLIENTS"
                }
                Self::ClientOutsideTree => "CLIENT_OUTSIDE_TREE",
                Self::InvalidStatusChange => "INVALID_STATUS_CHANGE",
                Self::InvalidChange => "INVALID_CHANGE",
                Self::CustomerCannotManageSelf => "CUSTOMER_CANNOT_MANAGE_SELF",
                Self::CreatingEnabledLinkNotAllowed => {
                    "CREATING_ENABLED_LINK_NOT_ALLOWED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACCOUNTS_NOT_COMPATIBLE_FOR_LINKING" => {
                    Some(Self::AccountsNotCompatibleForLinking)
                }
                "TOO_MANY_MANAGERS" => Some(Self::TooManyManagers),
                "TOO_MANY_INVITES" => Some(Self::TooManyInvites),
                "ALREADY_INVITED_BY_THIS_MANAGER" => {
                    Some(Self::AlreadyInvitedByThisManager)
                }
                "ALREADY_MANAGED_BY_THIS_MANAGER" => {
                    Some(Self::AlreadyManagedByThisManager)
                }
                "ALREADY_MANAGED_IN_HIERARCHY" => Some(Self::AlreadyManagedInHierarchy),
                "DUPLICATE_CHILD_FOUND" => Some(Self::DuplicateChildFound),
                "CLIENT_HAS_NO_ADMIN_USER" => Some(Self::ClientHasNoAdminUser),
                "MAX_DEPTH_EXCEEDED" => Some(Self::MaxDepthExceeded),
                "CYCLE_NOT_ALLOWED" => Some(Self::CycleNotAllowed),
                "TOO_MANY_ACCOUNTS" => Some(Self::TooManyAccounts),
                "TOO_MANY_ACCOUNTS_AT_MANAGER" => Some(Self::TooManyAccountsAtManager),
                "NON_OWNER_USER_CANNOT_MODIFY_LINK" => {
                    Some(Self::NonOwnerUserCannotModifyLink)
                }
                "SUSPENDED_ACCOUNT_CANNOT_ADD_CLIENTS" => {
                    Some(Self::SuspendedAccountCannotAddClients)
                }
                "CLIENT_OUTSIDE_TREE" => Some(Self::ClientOutsideTree),
                "INVALID_STATUS_CHANGE" => Some(Self::InvalidStatusChange),
                "INVALID_CHANGE" => Some(Self::InvalidChange),
                "CUSTOMER_CANNOT_MANAGE_SELF" => Some(Self::CustomerCannotManageSelf),
                "CREATING_ENABLED_LINK_NOT_ALLOWED" => {
                    Some(Self::CreatingEnabledLinkNotAllowed)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible media bundle errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MediaBundleErrorEnum {}
/// Nested message and enum types in `MediaBundleErrorEnum`.
pub mod media_bundle_error_enum {
    /// Enum describing possible media bundle errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MediaBundleError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// There was a problem with the request.
        BadRequest = 3,
        /// HTML5 ads using DoubleClick Studio created ZIP files are not supported.
        DoubleclickBundleNotAllowed = 4,
        /// Cannot reference URL external to the media bundle.
        ExternalUrlNotAllowed = 5,
        /// Media bundle file is too large.
        FileTooLarge = 6,
        /// ZIP file from Google Web Designer is not published.
        GoogleWebDesignerZipFileNotPublished = 7,
        /// Input was invalid.
        InvalidInput = 8,
        /// There was a problem with the media bundle.
        InvalidMediaBundle = 9,
        /// There was a problem with one or more of the media bundle entries.
        InvalidMediaBundleEntry = 10,
        /// The media bundle contains a file with an unknown mime type
        InvalidMimeType = 11,
        /// The media bundle contain an invalid asset path.
        InvalidPath = 12,
        /// HTML5 ad is trying to reference an asset not in .ZIP file
        InvalidUrlReference = 13,
        /// Media data is too large.
        MediaDataTooLarge = 14,
        /// The media bundle contains no primary entry.
        MissingPrimaryMediaBundleEntry = 15,
        /// There was an error on the server.
        ServerError = 16,
        /// The image could not be stored.
        StorageError = 17,
        /// Media bundle created with the Swiffy tool is not allowed.
        SwiffyBundleNotAllowed = 18,
        /// The media bundle contains too many files.
        TooManyFiles = 19,
        /// The media bundle is not of legal dimensions.
        UnexpectedSize = 20,
        /// Google Web Designer not created for "Google Ads" environment.
        UnsupportedGoogleWebDesignerEnvironment = 21,
        /// Unsupported HTML5 feature in HTML5 asset.
        UnsupportedHtml5Feature = 22,
        /// URL in HTML5 entry is not ssl compliant.
        UrlInMediaBundleNotSslCompliant = 23,
        /// Custom exits not allowed in HTML5 entry.
        CustomExitNotAllowed = 24,
    }
    impl MediaBundleError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::BadRequest => "BAD_REQUEST",
                Self::DoubleclickBundleNotAllowed => "DOUBLECLICK_BUNDLE_NOT_ALLOWED",
                Self::ExternalUrlNotAllowed => "EXTERNAL_URL_NOT_ALLOWED",
                Self::FileTooLarge => "FILE_TOO_LARGE",
                Self::GoogleWebDesignerZipFileNotPublished => {
                    "GOOGLE_WEB_DESIGNER_ZIP_FILE_NOT_PUBLISHED"
                }
                Self::InvalidInput => "INVALID_INPUT",
                Self::InvalidMediaBundle => "INVALID_MEDIA_BUNDLE",
                Self::InvalidMediaBundleEntry => "INVALID_MEDIA_BUNDLE_ENTRY",
                Self::InvalidMimeType => "INVALID_MIME_TYPE",
                Self::InvalidPath => "INVALID_PATH",
                Self::InvalidUrlReference => "INVALID_URL_REFERENCE",
                Self::MediaDataTooLarge => "MEDIA_DATA_TOO_LARGE",
                Self::MissingPrimaryMediaBundleEntry => {
                    "MISSING_PRIMARY_MEDIA_BUNDLE_ENTRY"
                }
                Self::ServerError => "SERVER_ERROR",
                Self::StorageError => "STORAGE_ERROR",
                Self::SwiffyBundleNotAllowed => "SWIFFY_BUNDLE_NOT_ALLOWED",
                Self::TooManyFiles => "TOO_MANY_FILES",
                Self::UnexpectedSize => "UNEXPECTED_SIZE",
                Self::UnsupportedGoogleWebDesignerEnvironment => {
                    "UNSUPPORTED_GOOGLE_WEB_DESIGNER_ENVIRONMENT"
                }
                Self::UnsupportedHtml5Feature => "UNSUPPORTED_HTML5_FEATURE",
                Self::UrlInMediaBundleNotSslCompliant => {
                    "URL_IN_MEDIA_BUNDLE_NOT_SSL_COMPLIANT"
                }
                Self::CustomExitNotAllowed => "CUSTOM_EXIT_NOT_ALLOWED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BAD_REQUEST" => Some(Self::BadRequest),
                "DOUBLECLICK_BUNDLE_NOT_ALLOWED" => {
                    Some(Self::DoubleclickBundleNotAllowed)
                }
                "EXTERNAL_URL_NOT_ALLOWED" => Some(Self::ExternalUrlNotAllowed),
                "FILE_TOO_LARGE" => Some(Self::FileTooLarge),
                "GOOGLE_WEB_DESIGNER_ZIP_FILE_NOT_PUBLISHED" => {
                    Some(Self::GoogleWebDesignerZipFileNotPublished)
                }
                "INVALID_INPUT" => Some(Self::InvalidInput),
                "INVALID_MEDIA_BUNDLE" => Some(Self::InvalidMediaBundle),
                "INVALID_MEDIA_BUNDLE_ENTRY" => Some(Self::InvalidMediaBundleEntry),
                "INVALID_MIME_TYPE" => Some(Self::InvalidMimeType),
                "INVALID_PATH" => Some(Self::InvalidPath),
                "INVALID_URL_REFERENCE" => Some(Self::InvalidUrlReference),
                "MEDIA_DATA_TOO_LARGE" => Some(Self::MediaDataTooLarge),
                "MISSING_PRIMARY_MEDIA_BUNDLE_ENTRY" => {
                    Some(Self::MissingPrimaryMediaBundleEntry)
                }
                "SERVER_ERROR" => Some(Self::ServerError),
                "STORAGE_ERROR" => Some(Self::StorageError),
                "SWIFFY_BUNDLE_NOT_ALLOWED" => Some(Self::SwiffyBundleNotAllowed),
                "TOO_MANY_FILES" => Some(Self::TooManyFiles),
                "UNEXPECTED_SIZE" => Some(Self::UnexpectedSize),
                "UNSUPPORTED_GOOGLE_WEB_DESIGNER_ENVIRONMENT" => {
                    Some(Self::UnsupportedGoogleWebDesignerEnvironment)
                }
                "UNSUPPORTED_HTML5_FEATURE" => Some(Self::UnsupportedHtml5Feature),
                "URL_IN_MEDIA_BUNDLE_NOT_SSL_COMPLIANT" => {
                    Some(Self::UrlInMediaBundleNotSslCompliant)
                }
                "CUSTOM_EXIT_NOT_ALLOWED" => Some(Self::CustomExitNotAllowed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible media file errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MediaFileErrorEnum {}
/// Nested message and enum types in `MediaFileErrorEnum`.
pub mod media_file_error_enum {
    /// Enum describing possible media file errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MediaFileError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Cannot create a standard icon type.
        CannotCreateStandardIcon = 2,
        /// May only select Standard Icons alone.
        CannotSelectStandardIconWithOtherTypes = 3,
        /// Image contains both a media file ID and data.
        CannotSpecifyMediaFileIdAndData = 4,
        /// A media file with given type and reference ID already exists.
        DuplicateMedia = 5,
        /// A required field was not specified or is an empty string.
        EmptyField = 6,
        /// A media file may only be modified once per call.
        ResourceReferencedInMultipleOps = 7,
        /// Field is not supported for the media sub type.
        FieldNotSupportedForMediaSubType = 8,
        /// The media file ID is invalid.
        InvalidMediaFileId = 9,
        /// The media subtype is invalid.
        InvalidMediaSubType = 10,
        /// The media file type is invalid.
        InvalidMediaFileType = 11,
        /// The mimetype is invalid.
        InvalidMimeType = 12,
        /// The media reference ID is invalid.
        InvalidReferenceId = 13,
        /// The YouTube video ID is invalid.
        InvalidYouTubeId = 14,
        /// Media file has failed transcoding
        MediaFileFailedTranscoding = 15,
        /// Media file has not been transcoded.
        MediaNotTranscoded = 16,
        /// The media type does not match the actual media file's type.
        MediaTypeDoesNotMatchMediaFileType = 17,
        /// None of the fields have been specified.
        NoFieldsSpecified = 18,
        /// One of reference ID or media file ID must be specified.
        NullReferenceIdAndMediaId = 19,
        /// The string has too many characters.
        TooLong = 20,
        /// The specified type is not supported.
        UnsupportedType = 21,
        /// YouTube is unavailable for requesting video data.
        YouTubeServiceUnavailable = 22,
        /// The YouTube video has a non positive duration.
        YouTubeVideoHasNonPositiveDuration = 23,
        /// The YouTube video ID is syntactically valid but the video was not found.
        YouTubeVideoNotFound = 24,
    }
    impl MediaFileError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CannotCreateStandardIcon => "CANNOT_CREATE_STANDARD_ICON",
                Self::CannotSelectStandardIconWithOtherTypes => {
                    "CANNOT_SELECT_STANDARD_ICON_WITH_OTHER_TYPES"
                }
                Self::CannotSpecifyMediaFileIdAndData => {
                    "CANNOT_SPECIFY_MEDIA_FILE_ID_AND_DATA"
                }
                Self::DuplicateMedia => "DUPLICATE_MEDIA",
                Self::EmptyField => "EMPTY_FIELD",
                Self::ResourceReferencedInMultipleOps => {
                    "RESOURCE_REFERENCED_IN_MULTIPLE_OPS"
                }
                Self::FieldNotSupportedForMediaSubType => {
                    "FIELD_NOT_SUPPORTED_FOR_MEDIA_SUB_TYPE"
                }
                Self::InvalidMediaFileId => "INVALID_MEDIA_FILE_ID",
                Self::InvalidMediaSubType => "INVALID_MEDIA_SUB_TYPE",
                Self::InvalidMediaFileType => "INVALID_MEDIA_FILE_TYPE",
                Self::InvalidMimeType => "INVALID_MIME_TYPE",
                Self::InvalidReferenceId => "INVALID_REFERENCE_ID",
                Self::InvalidYouTubeId => "INVALID_YOU_TUBE_ID",
                Self::MediaFileFailedTranscoding => "MEDIA_FILE_FAILED_TRANSCODING",
                Self::MediaNotTranscoded => "MEDIA_NOT_TRANSCODED",
                Self::MediaTypeDoesNotMatchMediaFileType => {
                    "MEDIA_TYPE_DOES_NOT_MATCH_MEDIA_FILE_TYPE"
                }
                Self::NoFieldsSpecified => "NO_FIELDS_SPECIFIED",
                Self::NullReferenceIdAndMediaId => "NULL_REFERENCE_ID_AND_MEDIA_ID",
                Self::TooLong => "TOO_LONG",
                Self::UnsupportedType => "UNSUPPORTED_TYPE",
                Self::YouTubeServiceUnavailable => "YOU_TUBE_SERVICE_UNAVAILABLE",
                Self::YouTubeVideoHasNonPositiveDuration => {
                    "YOU_TUBE_VIDEO_HAS_NON_POSITIVE_DURATION"
                }
                Self::YouTubeVideoNotFound => "YOU_TUBE_VIDEO_NOT_FOUND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_CREATE_STANDARD_ICON" => Some(Self::CannotCreateStandardIcon),
                "CANNOT_SELECT_STANDARD_ICON_WITH_OTHER_TYPES" => {
                    Some(Self::CannotSelectStandardIconWithOtherTypes)
                }
                "CANNOT_SPECIFY_MEDIA_FILE_ID_AND_DATA" => {
                    Some(Self::CannotSpecifyMediaFileIdAndData)
                }
                "DUPLICATE_MEDIA" => Some(Self::DuplicateMedia),
                "EMPTY_FIELD" => Some(Self::EmptyField),
                "RESOURCE_REFERENCED_IN_MULTIPLE_OPS" => {
                    Some(Self::ResourceReferencedInMultipleOps)
                }
                "FIELD_NOT_SUPPORTED_FOR_MEDIA_SUB_TYPE" => {
                    Some(Self::FieldNotSupportedForMediaSubType)
                }
                "INVALID_MEDIA_FILE_ID" => Some(Self::InvalidMediaFileId),
                "INVALID_MEDIA_SUB_TYPE" => Some(Self::InvalidMediaSubType),
                "INVALID_MEDIA_FILE_TYPE" => Some(Self::InvalidMediaFileType),
                "INVALID_MIME_TYPE" => Some(Self::InvalidMimeType),
                "INVALID_REFERENCE_ID" => Some(Self::InvalidReferenceId),
                "INVALID_YOU_TUBE_ID" => Some(Self::InvalidYouTubeId),
                "MEDIA_FILE_FAILED_TRANSCODING" => Some(Self::MediaFileFailedTranscoding),
                "MEDIA_NOT_TRANSCODED" => Some(Self::MediaNotTranscoded),
                "MEDIA_TYPE_DOES_NOT_MATCH_MEDIA_FILE_TYPE" => {
                    Some(Self::MediaTypeDoesNotMatchMediaFileType)
                }
                "NO_FIELDS_SPECIFIED" => Some(Self::NoFieldsSpecified),
                "NULL_REFERENCE_ID_AND_MEDIA_ID" => Some(Self::NullReferenceIdAndMediaId),
                "TOO_LONG" => Some(Self::TooLong),
                "UNSUPPORTED_TYPE" => Some(Self::UnsupportedType),
                "YOU_TUBE_SERVICE_UNAVAILABLE" => Some(Self::YouTubeServiceUnavailable),
                "YOU_TUBE_VIDEO_HAS_NON_POSITIVE_DURATION" => {
                    Some(Self::YouTubeVideoHasNonPositiveDuration)
                }
                "YOU_TUBE_VIDEO_NOT_FOUND" => Some(Self::YouTubeVideoNotFound),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible media uploading errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MediaUploadErrorEnum {}
/// Nested message and enum types in `MediaUploadErrorEnum`.
pub mod media_upload_error_enum {
    /// Enum describing possible media uploading errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MediaUploadError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The uploaded file is too big.
        FileTooBig = 2,
        /// Image data is unparseable.
        UnparseableImage = 3,
        /// Animated images are not allowed.
        AnimatedImageNotAllowed = 4,
        /// The image or media bundle format is not allowed.
        FormatNotAllowed = 5,
        /// Cannot reference URL external to the media bundle.
        ExternalUrlNotAllowed = 6,
        /// HTML5 ad is trying to reference an asset not in .ZIP file.
        InvalidUrlReference = 7,
        /// The media bundle contains no primary entry.
        MissingPrimaryMediaBundleEntry = 8,
        /// Animation has disallowed visual effects.
        AnimatedVisualEffect = 9,
        /// Animation longer than the allowed 30 second limit.
        AnimationTooLong = 10,
        /// The aspect ratio of the image does not match the expected aspect ratios
        /// provided in the asset spec.
        AspectRatioNotAllowed = 11,
        /// Audio files are not allowed in bundle.
        AudioNotAllowedInMediaBundle = 12,
        /// CMYK jpegs are not supported.
        CmykJpegNotAllowed = 13,
        /// Flash movies are not allowed.
        FlashNotAllowed = 14,
        /// The frame rate of the video is higher than the allowed 5fps.
        FrameRateTooHigh = 15,
        /// ZIP file from Google Web Designer is not published.
        GoogleWebDesignerZipFileNotPublished = 16,
        /// Image constraints are violated, but more details (like
        /// DIMENSIONS_NOT_ALLOWED or ASPECT_RATIO_NOT_ALLOWED) can not be provided.
        /// This happens when asset spec contains more than one constraint and
        /// criteria of different constraints are violated.
        ImageConstraintsViolated = 17,
        /// Media bundle data is unrecognizable.
        InvalidMediaBundle = 18,
        /// There was a problem with one or more of the media bundle entries.
        InvalidMediaBundleEntry = 19,
        /// The asset has an invalid mime type.
        InvalidMimeType = 20,
        /// The media bundle contains an invalid asset path.
        InvalidPath = 21,
        /// Image has layout problem.
        LayoutProblem = 22,
        /// An asset had a URL reference that is malformed per RFC 1738 convention.
        MalformedUrl = 23,
        /// The uploaded media bundle format is not allowed.
        MediaBundleNotAllowed = 24,
        /// The media bundle is not compatible with the asset spec product type.
        /// (For example, Gmail, dynamic remarketing, etc.)
        MediaBundleNotCompatibleToProductType = 25,
        /// A bundle being uploaded that is incompatible with multiple assets for
        /// different reasons.
        MediaBundleRejectedByMultipleAssetSpecs = 26,
        /// The media bundle contains too many files.
        TooManyFilesInMediaBundle = 27,
        /// Google Web Designer not created for "Google Ads" environment.
        UnsupportedGoogleWebDesignerEnvironment = 28,
        /// Unsupported HTML5 feature in HTML5 asset.
        UnsupportedHtml5Feature = 29,
        /// URL in HTML5 entry is not SSL compliant.
        UrlInMediaBundleNotSslCompliant = 30,
        /// Video file name is longer than the 50 allowed characters.
        VideoFileNameTooLong = 31,
        /// Multiple videos with same name in a bundle.
        VideoMultipleFilesWithSameName = 32,
        /// Videos are not allowed in media bundle.
        VideoNotAllowedInMediaBundle = 33,
        /// This type of media cannot be uploaded through the Google Ads API.
        CannotUploadMediaTypeThroughApi = 34,
        /// The dimensions of the image are not allowed.
        DimensionsNotAllowed = 35,
    }
    impl MediaUploadError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::FileTooBig => "FILE_TOO_BIG",
                Self::UnparseableImage => "UNPARSEABLE_IMAGE",
                Self::AnimatedImageNotAllowed => "ANIMATED_IMAGE_NOT_ALLOWED",
                Self::FormatNotAllowed => "FORMAT_NOT_ALLOWED",
                Self::ExternalUrlNotAllowed => "EXTERNAL_URL_NOT_ALLOWED",
                Self::InvalidUrlReference => "INVALID_URL_REFERENCE",
                Self::MissingPrimaryMediaBundleEntry => {
                    "MISSING_PRIMARY_MEDIA_BUNDLE_ENTRY"
                }
                Self::AnimatedVisualEffect => "ANIMATED_VISUAL_EFFECT",
                Self::AnimationTooLong => "ANIMATION_TOO_LONG",
                Self::AspectRatioNotAllowed => "ASPECT_RATIO_NOT_ALLOWED",
                Self::AudioNotAllowedInMediaBundle => "AUDIO_NOT_ALLOWED_IN_MEDIA_BUNDLE",
                Self::CmykJpegNotAllowed => "CMYK_JPEG_NOT_ALLOWED",
                Self::FlashNotAllowed => "FLASH_NOT_ALLOWED",
                Self::FrameRateTooHigh => "FRAME_RATE_TOO_HIGH",
                Self::GoogleWebDesignerZipFileNotPublished => {
                    "GOOGLE_WEB_DESIGNER_ZIP_FILE_NOT_PUBLISHED"
                }
                Self::ImageConstraintsViolated => "IMAGE_CONSTRAINTS_VIOLATED",
                Self::InvalidMediaBundle => "INVALID_MEDIA_BUNDLE",
                Self::InvalidMediaBundleEntry => "INVALID_MEDIA_BUNDLE_ENTRY",
                Self::InvalidMimeType => "INVALID_MIME_TYPE",
                Self::InvalidPath => "INVALID_PATH",
                Self::LayoutProblem => "LAYOUT_PROBLEM",
                Self::MalformedUrl => "MALFORMED_URL",
                Self::MediaBundleNotAllowed => "MEDIA_BUNDLE_NOT_ALLOWED",
                Self::MediaBundleNotCompatibleToProductType => {
                    "MEDIA_BUNDLE_NOT_COMPATIBLE_TO_PRODUCT_TYPE"
                }
                Self::MediaBundleRejectedByMultipleAssetSpecs => {
                    "MEDIA_BUNDLE_REJECTED_BY_MULTIPLE_ASSET_SPECS"
                }
                Self::TooManyFilesInMediaBundle => "TOO_MANY_FILES_IN_MEDIA_BUNDLE",
                Self::UnsupportedGoogleWebDesignerEnvironment => {
                    "UNSUPPORTED_GOOGLE_WEB_DESIGNER_ENVIRONMENT"
                }
                Self::UnsupportedHtml5Feature => "UNSUPPORTED_HTML5_FEATURE",
                Self::UrlInMediaBundleNotSslCompliant => {
                    "URL_IN_MEDIA_BUNDLE_NOT_SSL_COMPLIANT"
                }
                Self::VideoFileNameTooLong => "VIDEO_FILE_NAME_TOO_LONG",
                Self::VideoMultipleFilesWithSameName => {
                    "VIDEO_MULTIPLE_FILES_WITH_SAME_NAME"
                }
                Self::VideoNotAllowedInMediaBundle => "VIDEO_NOT_ALLOWED_IN_MEDIA_BUNDLE",
                Self::CannotUploadMediaTypeThroughApi => {
                    "CANNOT_UPLOAD_MEDIA_TYPE_THROUGH_API"
                }
                Self::DimensionsNotAllowed => "DIMENSIONS_NOT_ALLOWED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FILE_TOO_BIG" => Some(Self::FileTooBig),
                "UNPARSEABLE_IMAGE" => Some(Self::UnparseableImage),
                "ANIMATED_IMAGE_NOT_ALLOWED" => Some(Self::AnimatedImageNotAllowed),
                "FORMAT_NOT_ALLOWED" => Some(Self::FormatNotAllowed),
                "EXTERNAL_URL_NOT_ALLOWED" => Some(Self::ExternalUrlNotAllowed),
                "INVALID_URL_REFERENCE" => Some(Self::InvalidUrlReference),
                "MISSING_PRIMARY_MEDIA_BUNDLE_ENTRY" => {
                    Some(Self::MissingPrimaryMediaBundleEntry)
                }
                "ANIMATED_VISUAL_EFFECT" => Some(Self::AnimatedVisualEffect),
                "ANIMATION_TOO_LONG" => Some(Self::AnimationTooLong),
                "ASPECT_RATIO_NOT_ALLOWED" => Some(Self::AspectRatioNotAllowed),
                "AUDIO_NOT_ALLOWED_IN_MEDIA_BUNDLE" => {
                    Some(Self::AudioNotAllowedInMediaBundle)
                }
                "CMYK_JPEG_NOT_ALLOWED" => Some(Self::CmykJpegNotAllowed),
                "FLASH_NOT_ALLOWED" => Some(Self::FlashNotAllowed),
                "FRAME_RATE_TOO_HIGH" => Some(Self::FrameRateTooHigh),
                "GOOGLE_WEB_DESIGNER_ZIP_FILE_NOT_PUBLISHED" => {
                    Some(Self::GoogleWebDesignerZipFileNotPublished)
                }
                "IMAGE_CONSTRAINTS_VIOLATED" => Some(Self::ImageConstraintsViolated),
                "INVALID_MEDIA_BUNDLE" => Some(Self::InvalidMediaBundle),
                "INVALID_MEDIA_BUNDLE_ENTRY" => Some(Self::InvalidMediaBundleEntry),
                "INVALID_MIME_TYPE" => Some(Self::InvalidMimeType),
                "INVALID_PATH" => Some(Self::InvalidPath),
                "LAYOUT_PROBLEM" => Some(Self::LayoutProblem),
                "MALFORMED_URL" => Some(Self::MalformedUrl),
                "MEDIA_BUNDLE_NOT_ALLOWED" => Some(Self::MediaBundleNotAllowed),
                "MEDIA_BUNDLE_NOT_COMPATIBLE_TO_PRODUCT_TYPE" => {
                    Some(Self::MediaBundleNotCompatibleToProductType)
                }
                "MEDIA_BUNDLE_REJECTED_BY_MULTIPLE_ASSET_SPECS" => {
                    Some(Self::MediaBundleRejectedByMultipleAssetSpecs)
                }
                "TOO_MANY_FILES_IN_MEDIA_BUNDLE" => Some(Self::TooManyFilesInMediaBundle),
                "UNSUPPORTED_GOOGLE_WEB_DESIGNER_ENVIRONMENT" => {
                    Some(Self::UnsupportedGoogleWebDesignerEnvironment)
                }
                "UNSUPPORTED_HTML5_FEATURE" => Some(Self::UnsupportedHtml5Feature),
                "URL_IN_MEDIA_BUNDLE_NOT_SSL_COMPLIANT" => {
                    Some(Self::UrlInMediaBundleNotSslCompliant)
                }
                "VIDEO_FILE_NAME_TOO_LONG" => Some(Self::VideoFileNameTooLong),
                "VIDEO_MULTIPLE_FILES_WITH_SAME_NAME" => {
                    Some(Self::VideoMultipleFilesWithSameName)
                }
                "VIDEO_NOT_ALLOWED_IN_MEDIA_BUNDLE" => {
                    Some(Self::VideoNotAllowedInMediaBundle)
                }
                "CANNOT_UPLOAD_MEDIA_TYPE_THROUGH_API" => {
                    Some(Self::CannotUploadMediaTypeThroughApi)
                }
                "DIMENSIONS_NOT_ALLOWED" => Some(Self::DimensionsNotAllowed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible merchant center errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MerchantCenterErrorEnum {}
/// Nested message and enum types in `MerchantCenterErrorEnum`.
pub mod merchant_center_error_enum {
    /// Enum describing Merchant Center errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MerchantCenterError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Merchant ID is either not found or not linked to the Google Ads customer.
        MerchantIdCannotBeAccessed = 2,
        /// Customer not allowlisted for Shopping in Performance Max Campaign.
        CustomerNotAllowedForShoppingPerformanceMax = 3,
    }
    impl MerchantCenterError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::MerchantIdCannotBeAccessed => "MERCHANT_ID_CANNOT_BE_ACCESSED",
                Self::CustomerNotAllowedForShoppingPerformanceMax => {
                    "CUSTOMER_NOT_ALLOWED_FOR_SHOPPING_PERFORMANCE_MAX"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MERCHANT_ID_CANNOT_BE_ACCESSED" => {
                    Some(Self::MerchantIdCannotBeAccessed)
                }
                "CUSTOMER_NOT_ALLOWED_FOR_SHOPPING_PERFORMANCE_MAX" => {
                    Some(Self::CustomerNotAllowedForShoppingPerformanceMax)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible multiplier errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MultiplierErrorEnum {}
/// Nested message and enum types in `MultiplierErrorEnum`.
pub mod multiplier_error_enum {
    /// Enum describing possible multiplier errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MultiplierError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Multiplier value is too high
        MultiplierTooHigh = 2,
        /// Multiplier value is too low
        MultiplierTooLow = 3,
        /// Too many fractional digits
        TooManyFractionalDigits = 4,
        /// A multiplier cannot be set for this bidding strategy
        MultiplierNotAllowedForBiddingStrategy = 5,
        /// A multiplier cannot be set when there is no base bid (for example,
        /// content max cpc)
        MultiplierNotAllowedWhenBaseBidIsMissing = 6,
        /// A bid multiplier must be specified
        NoMultiplierSpecified = 7,
        /// Multiplier causes bid to exceed daily budget
        MultiplierCausesBidToExceedDailyBudget = 8,
        /// Multiplier causes bid to exceed monthly budget
        MultiplierCausesBidToExceedMonthlyBudget = 9,
        /// Multiplier causes bid to exceed custom budget
        MultiplierCausesBidToExceedCustomBudget = 10,
        /// Multiplier causes bid to exceed maximum allowed bid
        MultiplierCausesBidToExceedMaxAllowedBid = 11,
        /// Multiplier causes bid to become less than the minimum bid allowed
        BidLessThanMinAllowedBidWithMultiplier = 12,
        /// Multiplier type (cpc versus cpm) needs to match campaign's bidding
        /// strategy
        MultiplierAndBiddingStrategyTypeMismatch = 13,
    }
    impl MultiplierError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::MultiplierTooHigh => "MULTIPLIER_TOO_HIGH",
                Self::MultiplierTooLow => "MULTIPLIER_TOO_LOW",
                Self::TooManyFractionalDigits => "TOO_MANY_FRACTIONAL_DIGITS",
                Self::MultiplierNotAllowedForBiddingStrategy => {
                    "MULTIPLIER_NOT_ALLOWED_FOR_BIDDING_STRATEGY"
                }
                Self::MultiplierNotAllowedWhenBaseBidIsMissing => {
                    "MULTIPLIER_NOT_ALLOWED_WHEN_BASE_BID_IS_MISSING"
                }
                Self::NoMultiplierSpecified => "NO_MULTIPLIER_SPECIFIED",
                Self::MultiplierCausesBidToExceedDailyBudget => {
                    "MULTIPLIER_CAUSES_BID_TO_EXCEED_DAILY_BUDGET"
                }
                Self::MultiplierCausesBidToExceedMonthlyBudget => {
                    "MULTIPLIER_CAUSES_BID_TO_EXCEED_MONTHLY_BUDGET"
                }
                Self::MultiplierCausesBidToExceedCustomBudget => {
                    "MULTIPLIER_CAUSES_BID_TO_EXCEED_CUSTOM_BUDGET"
                }
                Self::MultiplierCausesBidToExceedMaxAllowedBid => {
                    "MULTIPLIER_CAUSES_BID_TO_EXCEED_MAX_ALLOWED_BID"
                }
                Self::BidLessThanMinAllowedBidWithMultiplier => {
                    "BID_LESS_THAN_MIN_ALLOWED_BID_WITH_MULTIPLIER"
                }
                Self::MultiplierAndBiddingStrategyTypeMismatch => {
                    "MULTIPLIER_AND_BIDDING_STRATEGY_TYPE_MISMATCH"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MULTIPLIER_TOO_HIGH" => Some(Self::MultiplierTooHigh),
                "MULTIPLIER_TOO_LOW" => Some(Self::MultiplierTooLow),
                "TOO_MANY_FRACTIONAL_DIGITS" => Some(Self::TooManyFractionalDigits),
                "MULTIPLIER_NOT_ALLOWED_FOR_BIDDING_STRATEGY" => {
                    Some(Self::MultiplierNotAllowedForBiddingStrategy)
                }
                "MULTIPLIER_NOT_ALLOWED_WHEN_BASE_BID_IS_MISSING" => {
                    Some(Self::MultiplierNotAllowedWhenBaseBidIsMissing)
                }
                "NO_MULTIPLIER_SPECIFIED" => Some(Self::NoMultiplierSpecified),
                "MULTIPLIER_CAUSES_BID_TO_EXCEED_DAILY_BUDGET" => {
                    Some(Self::MultiplierCausesBidToExceedDailyBudget)
                }
                "MULTIPLIER_CAUSES_BID_TO_EXCEED_MONTHLY_BUDGET" => {
                    Some(Self::MultiplierCausesBidToExceedMonthlyBudget)
                }
                "MULTIPLIER_CAUSES_BID_TO_EXCEED_CUSTOM_BUDGET" => {
                    Some(Self::MultiplierCausesBidToExceedCustomBudget)
                }
                "MULTIPLIER_CAUSES_BID_TO_EXCEED_MAX_ALLOWED_BID" => {
                    Some(Self::MultiplierCausesBidToExceedMaxAllowedBid)
                }
                "BID_LESS_THAN_MIN_ALLOWED_BID_WITH_MULTIPLIER" => {
                    Some(Self::BidLessThanMinAllowedBidWithMultiplier)
                }
                "MULTIPLIER_AND_BIDDING_STRATEGY_TYPE_MISMATCH" => {
                    Some(Self::MultiplierAndBiddingStrategyTypeMismatch)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible mutate errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MutateErrorEnum {}
/// Nested message and enum types in `MutateErrorEnum`.
pub mod mutate_error_enum {
    /// Enum describing possible mutate errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MutateError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Requested resource was not found.
        ResourceNotFound = 3,
        /// Cannot mutate the same resource twice in one request.
        IdExistsInMultipleMutates = 7,
        /// The field's contents don't match another field that represents the same
        /// data.
        InconsistentFieldValues = 8,
        /// Mutates are not allowed for the requested resource.
        MutateNotAllowed = 9,
        /// The resource isn't in Google Ads. It belongs to another ads system.
        ResourceNotInGoogleAds = 10,
        /// The resource being created already exists.
        ResourceAlreadyExists = 11,
        /// This resource cannot be used with "validate_only".
        ResourceDoesNotSupportValidateOnly = 12,
        /// This operation cannot be used with "partial_failure".
        OperationDoesNotSupportPartialFailure = 16,
        /// Attempt to write to read-only fields.
        ResourceReadOnly = 13,
    }
    impl MutateError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ResourceNotFound => "RESOURCE_NOT_FOUND",
                Self::IdExistsInMultipleMutates => "ID_EXISTS_IN_MULTIPLE_MUTATES",
                Self::InconsistentFieldValues => "INCONSISTENT_FIELD_VALUES",
                Self::MutateNotAllowed => "MUTATE_NOT_ALLOWED",
                Self::ResourceNotInGoogleAds => "RESOURCE_NOT_IN_GOOGLE_ADS",
                Self::ResourceAlreadyExists => "RESOURCE_ALREADY_EXISTS",
                Self::ResourceDoesNotSupportValidateOnly => {
                    "RESOURCE_DOES_NOT_SUPPORT_VALIDATE_ONLY"
                }
                Self::OperationDoesNotSupportPartialFailure => {
                    "OPERATION_DOES_NOT_SUPPORT_PARTIAL_FAILURE"
                }
                Self::ResourceReadOnly => "RESOURCE_READ_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RESOURCE_NOT_FOUND" => Some(Self::ResourceNotFound),
                "ID_EXISTS_IN_MULTIPLE_MUTATES" => Some(Self::IdExistsInMultipleMutates),
                "INCONSISTENT_FIELD_VALUES" => Some(Self::InconsistentFieldValues),
                "MUTATE_NOT_ALLOWED" => Some(Self::MutateNotAllowed),
                "RESOURCE_NOT_IN_GOOGLE_ADS" => Some(Self::ResourceNotInGoogleAds),
                "RESOURCE_ALREADY_EXISTS" => Some(Self::ResourceAlreadyExists),
                "RESOURCE_DOES_NOT_SUPPORT_VALIDATE_ONLY" => {
                    Some(Self::ResourceDoesNotSupportValidateOnly)
                }
                "OPERATION_DOES_NOT_SUPPORT_PARTIAL_FAILURE" => {
                    Some(Self::OperationDoesNotSupportPartialFailure)
                }
                "RESOURCE_READ_ONLY" => Some(Self::ResourceReadOnly),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible new resource creation errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NewResourceCreationErrorEnum {}
/// Nested message and enum types in `NewResourceCreationErrorEnum`.
pub mod new_resource_creation_error_enum {
    /// Enum describing possible new resource creation errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NewResourceCreationError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Do not set the id field while creating new resources.
        CannotSetIdForCreate = 2,
        /// Creating more than one resource with the same temp ID is not allowed.
        DuplicateTempIds = 3,
        /// Parent resource with specified temp ID failed validation, so no
        /// validation will be done for this child resource.
        TempIdResourceHadErrors = 4,
    }
    impl NewResourceCreationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CannotSetIdForCreate => "CANNOT_SET_ID_FOR_CREATE",
                Self::DuplicateTempIds => "DUPLICATE_TEMP_IDS",
                Self::TempIdResourceHadErrors => "TEMP_ID_RESOURCE_HAD_ERRORS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_SET_ID_FOR_CREATE" => Some(Self::CannotSetIdForCreate),
                "DUPLICATE_TEMP_IDS" => Some(Self::DuplicateTempIds),
                "TEMP_ID_RESOURCE_HAD_ERRORS" => Some(Self::TempIdResourceHadErrors),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible not allowlisted errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotAllowlistedErrorEnum {}
/// Nested message and enum types in `NotAllowlistedErrorEnum`.
pub mod not_allowlisted_error_enum {
    /// Enum describing possible not allowlisted errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NotAllowlistedError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Customer is not allowlisted for accessing this feature.
        CustomerNotAllowlistedForThisFeature = 2,
    }
    impl NotAllowlistedError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CustomerNotAllowlistedForThisFeature => {
                    "CUSTOMER_NOT_ALLOWLISTED_FOR_THIS_FEATURE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOMER_NOT_ALLOWLISTED_FOR_THIS_FEATURE" => {
                    Some(Self::CustomerNotAllowlistedForThisFeature)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible not empty errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotEmptyErrorEnum {}
/// Nested message and enum types in `NotEmptyErrorEnum`.
pub mod not_empty_error_enum {
    /// Enum describing possible not empty errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NotEmptyError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Empty list.
        EmptyList = 2,
    }
    impl NotEmptyError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::EmptyList => "EMPTY_LIST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EMPTY_LIST" => Some(Self::EmptyList),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible null errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NullErrorEnum {}
/// Nested message and enum types in `NullErrorEnum`.
pub mod null_error_enum {
    /// Enum describing possible null errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NullError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Specified list/container must not contain any null elements
        NullContent = 2,
    }
    impl NullError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NullContent => "NULL_CONTENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NULL_CONTENT" => Some(Self::NullContent),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible offline user data job errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfflineUserDataJobErrorEnum {}
/// Nested message and enum types in `OfflineUserDataJobErrorEnum`.
pub mod offline_user_data_job_error_enum {
    /// Enum describing possible request errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OfflineUserDataJobError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The user list ID provided for the job is invalid.
        InvalidUserListId = 3,
        /// Type of the user list is not applicable for the job.
        InvalidUserListType = 4,
        /// Customer is not allowisted for using user ID in upload data.
        NotOnAllowlistForUserId = 33,
        /// Upload data is not compatible with the upload key type of the associated
        /// user list.
        IncompatibleUploadKeyType = 6,
        /// The user identifier is missing valid data.
        MissingUserIdentifier = 7,
        /// The mobile ID is malformed.
        InvalidMobileIdFormat = 8,
        /// Maximum number of user identifiers allowed per request is 100,000 and per
        /// operation is 20.
        TooManyUserIdentifiers = 9,
        /// Customer is not on the allow-list for store sales direct data.
        NotOnAllowlistForStoreSalesDirect = 31,
        /// Customer is not on the allow-list for unified store sales data.
        NotOnAllowlistForUnifiedStoreSales = 32,
        /// The partner ID in store sales direct metadata is invalid.
        InvalidPartnerId = 11,
        /// The data in user identifier should not be encoded.
        InvalidEncoding = 12,
        /// The country code is invalid.
        InvalidCountryCode = 13,
        /// Incompatible user identifier when using third_party_user_id for store
        /// sales direct first party data or not using third_party_user_id for store
        /// sales third party data.
        IncompatibleUserIdentifier = 14,
        /// A transaction time in the future is not allowed.
        FutureTransactionTime = 15,
        /// The conversion_action specified in transaction_attributes is used to
        /// report conversions to a conversion action configured in Google Ads. This
        /// error indicates there is no such conversion action in the account.
        InvalidConversionAction = 16,
        /// Mobile ID is not supported for store sales direct data.
        MobileIdNotSupported = 17,
        /// When a remove-all operation is provided, it has to be the first operation
        /// of the operation list.
        InvalidOperationOrder = 18,
        /// Mixing creation and removal of offline data in the same job is not
        /// allowed.
        ConflictingOperation = 19,
        /// The external update ID already exists.
        ExternalUpdateIdAlreadyExists = 21,
        /// Once the upload job is started, new operations cannot be added.
        JobAlreadyStarted = 22,
        /// Remove operation is not allowed for store sales direct updates.
        RemoveNotSupported = 23,
        /// Remove-all is not supported for certain offline user data job types.
        RemoveAllNotSupported = 24,
        /// The SHA256 encoded value is malformed.
        InvalidSha256Format = 25,
        /// The custom key specified is not enabled for the unified store sales
        /// upload.
        CustomKeyDisabled = 26,
        /// The custom key specified is not predefined through the Google Ads UI.
        CustomKeyNotPredefined = 27,
        /// The custom key specified is not set in the upload.
        CustomKeyNotSet = 29,
        /// The customer has not accepted the customer data terms in the conversion
        /// settings page.
        CustomerNotAcceptedCustomerDataTerms = 30,
        /// User attributes cannot be uploaded into a user list.
        AttributesNotApplicableForCustomerMatchUserList = 34,
        /// Lifetime bucket value must be a number from 0 to 10; 0 is only accepted
        /// for remove operations
        LifetimeValueBucketNotInRange = 35,
        /// Identifiers not supported for Customer Match attributes. User attributes
        /// can only be provided with contact info (email, phone, address) user
        /// identifiers.
        IncompatibleUserIdentifierForAttributes = 36,
        /// A time in the future is not allowed.
        FutureTimeNotAllowed = 37,
        /// Last purchase date time cannot be less than acquisition date time.
        LastPurchaseTimeLessThanAcquisitionTime = 38,
        /// Only emails are accepted as user identifiers for shopping loyalty match.
        /// {-- api.dev/not-precedent: The identifier is not limited to ids, but
        /// also include other user info eg. phone numbers.}
        CustomerIdentifierNotAllowed = 39,
        /// Provided item ID is invalid.
        InvalidItemId = 40,
        /// First purchase date time cannot be greater than the last purchase date
        /// time.
        FirstPurchaseTimeGreaterThanLastPurchaseTime = 42,
        /// Provided lifecycle stage is invalid.
        InvalidLifecycleStage = 43,
        /// The event value of the Customer Match user attribute is invalid.
        InvalidEventValue = 44,
        /// All the fields are not present in the EventAttribute of the Customer
        /// Match.
        EventAttributeAllFieldsAreRequired = 45,
    }
    impl OfflineUserDataJobError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidUserListId => "INVALID_USER_LIST_ID",
                Self::InvalidUserListType => "INVALID_USER_LIST_TYPE",
                Self::NotOnAllowlistForUserId => "NOT_ON_ALLOWLIST_FOR_USER_ID",
                Self::IncompatibleUploadKeyType => "INCOMPATIBLE_UPLOAD_KEY_TYPE",
                Self::MissingUserIdentifier => "MISSING_USER_IDENTIFIER",
                Self::InvalidMobileIdFormat => "INVALID_MOBILE_ID_FORMAT",
                Self::TooManyUserIdentifiers => "TOO_MANY_USER_IDENTIFIERS",
                Self::NotOnAllowlistForStoreSalesDirect => {
                    "NOT_ON_ALLOWLIST_FOR_STORE_SALES_DIRECT"
                }
                Self::NotOnAllowlistForUnifiedStoreSales => {
                    "NOT_ON_ALLOWLIST_FOR_UNIFIED_STORE_SALES"
                }
                Self::InvalidPartnerId => "INVALID_PARTNER_ID",
                Self::InvalidEncoding => "INVALID_ENCODING",
                Self::InvalidCountryCode => "INVALID_COUNTRY_CODE",
                Self::IncompatibleUserIdentifier => "INCOMPATIBLE_USER_IDENTIFIER",
                Self::FutureTransactionTime => "FUTURE_TRANSACTION_TIME",
                Self::InvalidConversionAction => "INVALID_CONVERSION_ACTION",
                Self::MobileIdNotSupported => "MOBILE_ID_NOT_SUPPORTED",
                Self::InvalidOperationOrder => "INVALID_OPERATION_ORDER",
                Self::ConflictingOperation => "CONFLICTING_OPERATION",
                Self::ExternalUpdateIdAlreadyExists => {
                    "EXTERNAL_UPDATE_ID_ALREADY_EXISTS"
                }
                Self::JobAlreadyStarted => "JOB_ALREADY_STARTED",
                Self::RemoveNotSupported => "REMOVE_NOT_SUPPORTED",
                Self::RemoveAllNotSupported => "REMOVE_ALL_NOT_SUPPORTED",
                Self::InvalidSha256Format => "INVALID_SHA256_FORMAT",
                Self::CustomKeyDisabled => "CUSTOM_KEY_DISABLED",
                Self::CustomKeyNotPredefined => "CUSTOM_KEY_NOT_PREDEFINED",
                Self::CustomKeyNotSet => "CUSTOM_KEY_NOT_SET",
                Self::CustomerNotAcceptedCustomerDataTerms => {
                    "CUSTOMER_NOT_ACCEPTED_CUSTOMER_DATA_TERMS"
                }
                Self::AttributesNotApplicableForCustomerMatchUserList => {
                    "ATTRIBUTES_NOT_APPLICABLE_FOR_CUSTOMER_MATCH_USER_LIST"
                }
                Self::LifetimeValueBucketNotInRange => {
                    "LIFETIME_VALUE_BUCKET_NOT_IN_RANGE"
                }
                Self::IncompatibleUserIdentifierForAttributes => {
                    "INCOMPATIBLE_USER_IDENTIFIER_FOR_ATTRIBUTES"
                }
                Self::FutureTimeNotAllowed => "FUTURE_TIME_NOT_ALLOWED",
                Self::LastPurchaseTimeLessThanAcquisitionTime => {
                    "LAST_PURCHASE_TIME_LESS_THAN_ACQUISITION_TIME"
                }
                Self::CustomerIdentifierNotAllowed => "CUSTOMER_IDENTIFIER_NOT_ALLOWED",
                Self::InvalidItemId => "INVALID_ITEM_ID",
                Self::FirstPurchaseTimeGreaterThanLastPurchaseTime => {
                    "FIRST_PURCHASE_TIME_GREATER_THAN_LAST_PURCHASE_TIME"
                }
                Self::InvalidLifecycleStage => "INVALID_LIFECYCLE_STAGE",
                Self::InvalidEventValue => "INVALID_EVENT_VALUE",
                Self::EventAttributeAllFieldsAreRequired => {
                    "EVENT_ATTRIBUTE_ALL_FIELDS_ARE_REQUIRED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_USER_LIST_ID" => Some(Self::InvalidUserListId),
                "INVALID_USER_LIST_TYPE" => Some(Self::InvalidUserListType),
                "NOT_ON_ALLOWLIST_FOR_USER_ID" => Some(Self::NotOnAllowlistForUserId),
                "INCOMPATIBLE_UPLOAD_KEY_TYPE" => Some(Self::IncompatibleUploadKeyType),
                "MISSING_USER_IDENTIFIER" => Some(Self::MissingUserIdentifier),
                "INVALID_MOBILE_ID_FORMAT" => Some(Self::InvalidMobileIdFormat),
                "TOO_MANY_USER_IDENTIFIERS" => Some(Self::TooManyUserIdentifiers),
                "NOT_ON_ALLOWLIST_FOR_STORE_SALES_DIRECT" => {
                    Some(Self::NotOnAllowlistForStoreSalesDirect)
                }
                "NOT_ON_ALLOWLIST_FOR_UNIFIED_STORE_SALES" => {
                    Some(Self::NotOnAllowlistForUnifiedStoreSales)
                }
                "INVALID_PARTNER_ID" => Some(Self::InvalidPartnerId),
                "INVALID_ENCODING" => Some(Self::InvalidEncoding),
                "INVALID_COUNTRY_CODE" => Some(Self::InvalidCountryCode),
                "INCOMPATIBLE_USER_IDENTIFIER" => Some(Self::IncompatibleUserIdentifier),
                "FUTURE_TRANSACTION_TIME" => Some(Self::FutureTransactionTime),
                "INVALID_CONVERSION_ACTION" => Some(Self::InvalidConversionAction),
                "MOBILE_ID_NOT_SUPPORTED" => Some(Self::MobileIdNotSupported),
                "INVALID_OPERATION_ORDER" => Some(Self::InvalidOperationOrder),
                "CONFLICTING_OPERATION" => Some(Self::ConflictingOperation),
                "EXTERNAL_UPDATE_ID_ALREADY_EXISTS" => {
                    Some(Self::ExternalUpdateIdAlreadyExists)
                }
                "JOB_ALREADY_STARTED" => Some(Self::JobAlreadyStarted),
                "REMOVE_NOT_SUPPORTED" => Some(Self::RemoveNotSupported),
                "REMOVE_ALL_NOT_SUPPORTED" => Some(Self::RemoveAllNotSupported),
                "INVALID_SHA256_FORMAT" => Some(Self::InvalidSha256Format),
                "CUSTOM_KEY_DISABLED" => Some(Self::CustomKeyDisabled),
                "CUSTOM_KEY_NOT_PREDEFINED" => Some(Self::CustomKeyNotPredefined),
                "CUSTOM_KEY_NOT_SET" => Some(Self::CustomKeyNotSet),
                "CUSTOMER_NOT_ACCEPTED_CUSTOMER_DATA_TERMS" => {
                    Some(Self::CustomerNotAcceptedCustomerDataTerms)
                }
                "ATTRIBUTES_NOT_APPLICABLE_FOR_CUSTOMER_MATCH_USER_LIST" => {
                    Some(Self::AttributesNotApplicableForCustomerMatchUserList)
                }
                "LIFETIME_VALUE_BUCKET_NOT_IN_RANGE" => {
                    Some(Self::LifetimeValueBucketNotInRange)
                }
                "INCOMPATIBLE_USER_IDENTIFIER_FOR_ATTRIBUTES" => {
                    Some(Self::IncompatibleUserIdentifierForAttributes)
                }
                "FUTURE_TIME_NOT_ALLOWED" => Some(Self::FutureTimeNotAllowed),
                "LAST_PURCHASE_TIME_LESS_THAN_ACQUISITION_TIME" => {
                    Some(Self::LastPurchaseTimeLessThanAcquisitionTime)
                }
                "CUSTOMER_IDENTIFIER_NOT_ALLOWED" => {
                    Some(Self::CustomerIdentifierNotAllowed)
                }
                "INVALID_ITEM_ID" => Some(Self::InvalidItemId),
                "FIRST_PURCHASE_TIME_GREATER_THAN_LAST_PURCHASE_TIME" => {
                    Some(Self::FirstPurchaseTimeGreaterThanLastPurchaseTime)
                }
                "INVALID_LIFECYCLE_STAGE" => Some(Self::InvalidLifecycleStage),
                "INVALID_EVENT_VALUE" => Some(Self::InvalidEventValue),
                "EVENT_ATTRIBUTE_ALL_FIELDS_ARE_REQUIRED" => {
                    Some(Self::EventAttributeAllFieldsAreRequired)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible operation access denied errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OperationAccessDeniedErrorEnum {}
/// Nested message and enum types in `OperationAccessDeniedErrorEnum`.
pub mod operation_access_denied_error_enum {
    /// Enum describing possible operation access denied errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OperationAccessDeniedError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Unauthorized invocation of a service's method (get, mutate, etc.)
        ActionNotPermitted = 2,
        /// Unauthorized CREATE operation in invoking a service's mutate method.
        CreateOperationNotPermitted = 3,
        /// Unauthorized REMOVE operation in invoking a service's mutate method.
        RemoveOperationNotPermitted = 4,
        /// Unauthorized UPDATE operation in invoking a service's mutate method.
        UpdateOperationNotPermitted = 5,
        /// A mutate action is not allowed on this resource, from this client.
        MutateActionNotPermittedForClient = 6,
        /// This operation is not permitted on this campaign type
        OperationNotPermittedForCampaignType = 7,
        /// A CREATE operation may not set status to REMOVED.
        CreateAsRemovedNotPermitted = 8,
        /// This operation is not allowed because the resource is removed.
        OperationNotPermittedForRemovedResource = 9,
        /// This operation is not permitted on this ad group type.
        OperationNotPermittedForAdGroupType = 10,
        /// The mutate is not allowed for this customer.
        MutateNotPermittedForCustomer = 11,
    }
    impl OperationAccessDeniedError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ActionNotPermitted => "ACTION_NOT_PERMITTED",
                Self::CreateOperationNotPermitted => "CREATE_OPERATION_NOT_PERMITTED",
                Self::RemoveOperationNotPermitted => "REMOVE_OPERATION_NOT_PERMITTED",
                Self::UpdateOperationNotPermitted => "UPDATE_OPERATION_NOT_PERMITTED",
                Self::MutateActionNotPermittedForClient => {
                    "MUTATE_ACTION_NOT_PERMITTED_FOR_CLIENT"
                }
                Self::OperationNotPermittedForCampaignType => {
                    "OPERATION_NOT_PERMITTED_FOR_CAMPAIGN_TYPE"
                }
                Self::CreateAsRemovedNotPermitted => "CREATE_AS_REMOVED_NOT_PERMITTED",
                Self::OperationNotPermittedForRemovedResource => {
                    "OPERATION_NOT_PERMITTED_FOR_REMOVED_RESOURCE"
                }
                Self::OperationNotPermittedForAdGroupType => {
                    "OPERATION_NOT_PERMITTED_FOR_AD_GROUP_TYPE"
                }
                Self::MutateNotPermittedForCustomer => {
                    "MUTATE_NOT_PERMITTED_FOR_CUSTOMER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACTION_NOT_PERMITTED" => Some(Self::ActionNotPermitted),
                "CREATE_OPERATION_NOT_PERMITTED" => {
                    Some(Self::CreateOperationNotPermitted)
                }
                "REMOVE_OPERATION_NOT_PERMITTED" => {
                    Some(Self::RemoveOperationNotPermitted)
                }
                "UPDATE_OPERATION_NOT_PERMITTED" => {
                    Some(Self::UpdateOperationNotPermitted)
                }
                "MUTATE_ACTION_NOT_PERMITTED_FOR_CLIENT" => {
                    Some(Self::MutateActionNotPermittedForClient)
                }
                "OPERATION_NOT_PERMITTED_FOR_CAMPAIGN_TYPE" => {
                    Some(Self::OperationNotPermittedForCampaignType)
                }
                "CREATE_AS_REMOVED_NOT_PERMITTED" => {
                    Some(Self::CreateAsRemovedNotPermitted)
                }
                "OPERATION_NOT_PERMITTED_FOR_REMOVED_RESOURCE" => {
                    Some(Self::OperationNotPermittedForRemovedResource)
                }
                "OPERATION_NOT_PERMITTED_FOR_AD_GROUP_TYPE" => {
                    Some(Self::OperationNotPermittedForAdGroupType)
                }
                "MUTATE_NOT_PERMITTED_FOR_CUSTOMER" => {
                    Some(Self::MutateNotPermittedForCustomer)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible operator errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OperatorErrorEnum {}
/// Nested message and enum types in `OperatorErrorEnum`.
pub mod operator_error_enum {
    /// Enum describing possible operator errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OperatorError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Operator not supported.
        OperatorNotSupported = 2,
    }
    impl OperatorError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::OperatorNotSupported => "OPERATOR_NOT_SUPPORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPERATOR_NOT_SUPPORTED" => Some(Self::OperatorNotSupported),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible partial failure errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PartialFailureErrorEnum {}
/// Nested message and enum types in `PartialFailureErrorEnum`.
pub mod partial_failure_error_enum {
    /// Enum describing possible partial failure errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PartialFailureError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The partial failure field was false in the request.
        /// This method requires this field be set to true.
        PartialFailureModeRequired = 2,
    }
    impl PartialFailureError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::PartialFailureModeRequired => "PARTIAL_FAILURE_MODE_REQUIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PARTIAL_FAILURE_MODE_REQUIRED" => Some(Self::PartialFailureModeRequired),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible errors in payments account service.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PaymentsAccountErrorEnum {}
/// Nested message and enum types in `PaymentsAccountErrorEnum`.
pub mod payments_account_error_enum {
    /// Enum describing possible errors in payments account service.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PaymentsAccountError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Manager customers are not supported for payments account service.
        NotSupportedForManagerCustomer = 2,
    }
    impl PaymentsAccountError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NotSupportedForManagerCustomer => {
                    "NOT_SUPPORTED_FOR_MANAGER_CUSTOMER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOT_SUPPORTED_FOR_MANAGER_CUSTOMER" => {
                    Some(Self::NotSupportedForManagerCustomer)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible policy finding errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyFindingErrorEnum {}
/// Nested message and enum types in `PolicyFindingErrorEnum`.
pub mod policy_finding_error_enum {
    /// Enum describing possible policy finding errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyFindingError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The resource has been disapproved since the policy summary includes
        /// policy topics of type PROHIBITED.
        PolicyFinding = 2,
        /// The given policy topic does not exist.
        PolicyTopicNotFound = 3,
    }
    impl PolicyFindingError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::PolicyFinding => "POLICY_FINDING",
                Self::PolicyTopicNotFound => "POLICY_TOPIC_NOT_FOUND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "POLICY_FINDING" => Some(Self::PolicyFinding),
                "POLICY_TOPIC_NOT_FOUND" => Some(Self::PolicyTopicNotFound),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible policy validation parameter errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyValidationParameterErrorEnum {}
/// Nested message and enum types in `PolicyValidationParameterErrorEnum`.
pub mod policy_validation_parameter_error_enum {
    /// Enum describing possible policy validation parameter errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyValidationParameterError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Ignorable policy topics are not supported for the ad type.
        UnsupportedAdTypeForIgnorablePolicyTopics = 2,
        /// Exempt policy violation keys are not supported for the ad type.
        UnsupportedAdTypeForExemptPolicyViolationKeys = 3,
        /// Cannot set ignorable policy topics and exempt policy violation keys in
        /// the same policy violation parameter.
        CannotSetBothIgnorablePolicyTopicsAndExemptPolicyViolationKeys = 4,
    }
    impl PolicyValidationParameterError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::UnsupportedAdTypeForIgnorablePolicyTopics => {
                    "UNSUPPORTED_AD_TYPE_FOR_IGNORABLE_POLICY_TOPICS"
                }
                Self::UnsupportedAdTypeForExemptPolicyViolationKeys => {
                    "UNSUPPORTED_AD_TYPE_FOR_EXEMPT_POLICY_VIOLATION_KEYS"
                }
                Self::CannotSetBothIgnorablePolicyTopicsAndExemptPolicyViolationKeys => {
                    "CANNOT_SET_BOTH_IGNORABLE_POLICY_TOPICS_AND_EXEMPT_POLICY_VIOLATION_KEYS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNSUPPORTED_AD_TYPE_FOR_IGNORABLE_POLICY_TOPICS" => {
                    Some(Self::UnsupportedAdTypeForIgnorablePolicyTopics)
                }
                "UNSUPPORTED_AD_TYPE_FOR_EXEMPT_POLICY_VIOLATION_KEYS" => {
                    Some(Self::UnsupportedAdTypeForExemptPolicyViolationKeys)
                }
                "CANNOT_SET_BOTH_IGNORABLE_POLICY_TOPICS_AND_EXEMPT_POLICY_VIOLATION_KEYS" => {
                    Some(
                        Self::CannotSetBothIgnorablePolicyTopicsAndExemptPolicyViolationKeys,
                    )
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible policy violation errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyViolationErrorEnum {}
/// Nested message and enum types in `PolicyViolationErrorEnum`.
pub mod policy_violation_error_enum {
    /// Enum describing possible policy violation errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyViolationError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// A policy was violated. See PolicyViolationDetails for more detail.
        PolicyError = 2,
    }
    impl PolicyViolationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::PolicyError => "POLICY_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "POLICY_ERROR" => Some(Self::PolicyError),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible ProductLink errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductLinkErrorEnum {}
/// Nested message and enum types in `ProductLinkErrorEnum`.
pub mod product_link_error_enum {
    /// Enum describing possible ProductLink errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductLinkError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The requested operation is invalid. For example, you are not allowed to
        /// remove a link from a partner account.
        InvalidOperation = 2,
        /// The creation request is not permitted.
        CreationNotPermitted = 3,
        /// A link cannot be created because a pending link already exists.
        InvitationExists = 4,
        /// A link cannot be created because an active link already exists.
        LinkExists = 5,
    }
    impl ProductLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidOperation => "INVALID_OPERATION",
                Self::CreationNotPermitted => "CREATION_NOT_PERMITTED",
                Self::InvitationExists => "INVITATION_EXISTS",
                Self::LinkExists => "LINK_EXISTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_OPERATION" => Some(Self::InvalidOperation),
                "CREATION_NOT_PERMITTED" => Some(Self::CreationNotPermitted),
                "INVITATION_EXISTS" => Some(Self::InvitationExists),
                "LINK_EXISTS" => Some(Self::LinkExists),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible product link invitation errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductLinkInvitationErrorEnum {}
/// Nested message and enum types in `ProductLinkInvitationErrorEnum`.
pub mod product_link_invitation_error_enum {
    /// Enum describing possible product link invitation errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductLinkInvitationError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in the version.
        Unknown = 1,
        /// The invitation status is invalid.
        InvalidStatus = 2,
        /// The customer doesn't have the permission to perform this action
        PermissionDenied = 3,
        /// An invitation could not be created, since the user already has admin
        /// access to the invited account. Use the ProductLinkService to directly
        /// create an active link.
        NoInvitationRequired = 4,
        /// The customer is not permitted to create the invitation.
        CustomerNotPermittedToCreateInvitation = 5,
    }
    impl ProductLinkInvitationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidStatus => "INVALID_STATUS",
                Self::PermissionDenied => "PERMISSION_DENIED",
                Self::NoInvitationRequired => "NO_INVITATION_REQUIRED",
                Self::CustomerNotPermittedToCreateInvitation => {
                    "CUSTOMER_NOT_PERMITTED_TO_CREATE_INVITATION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_STATUS" => Some(Self::InvalidStatus),
                "PERMISSION_DENIED" => Some(Self::PermissionDenied),
                "NO_INVITATION_REQUIRED" => Some(Self::NoInvitationRequired),
                "CUSTOMER_NOT_PERMITTED_TO_CREATE_INVITATION" => {
                    Some(Self::CustomerNotPermittedToCreateInvitation)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible query errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryErrorEnum {}
/// Nested message and enum types in `QueryErrorEnum`.
pub mod query_error_enum {
    /// Enum describing possible query errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum QueryError {
        /// Name unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Returned if all other query error reasons are not applicable.
        QueryError = 50,
        /// A condition used in the query references an invalid enum constant.
        BadEnumConstant = 18,
        /// Query contains an invalid escape sequence.
        BadEscapeSequence = 7,
        /// Field name is invalid.
        BadFieldName = 12,
        /// Limit value is invalid (for example, not a number)
        BadLimitValue = 15,
        /// Encountered number can not be parsed.
        BadNumber = 5,
        /// Invalid operator encountered.
        BadOperator = 3,
        /// Parameter unknown or not supported.
        BadParameterName = 61,
        /// Parameter have invalid value.
        BadParameterValue = 62,
        /// Invalid resource type was specified in the FROM clause.
        BadResourceTypeInFromClause = 45,
        /// Non-ASCII symbol encountered outside of strings.
        BadSymbol = 2,
        /// Value is invalid.
        BadValue = 4,
        /// Date filters fail to restrict date to a range smaller than 31 days.
        /// Applicable if the query is segmented by date.
        DateRangeTooWide = 36,
        /// Filters on date/week/month/quarter have a start date after
        /// end date.
        DateRangeTooNarrow = 60,
        /// Expected AND between values with BETWEEN operator.
        ExpectedAnd = 30,
        /// Expecting ORDER BY to have BY.
        ExpectedBy = 14,
        /// There was no dimension field selected.
        ExpectedDimensionFieldInSelectClause = 37,
        /// Missing filters on date related fields.
        ExpectedFiltersOnDateRange = 55,
        /// Missing FROM clause.
        ExpectedFrom = 44,
        /// The operator used in the conditions requires the value to be a list.
        ExpectedList = 41,
        /// Fields used in WHERE or ORDER BY clauses are missing from the SELECT
        /// clause.
        ExpectedReferencedFieldInSelectClause = 16,
        /// SELECT is missing at the beginning of query.
        ExpectedSelect = 13,
        /// A list was passed as a value to a condition whose operator expects a
        /// single value.
        ExpectedSingleValue = 42,
        /// Missing one or both values with BETWEEN operator.
        ExpectedValueWithBetweenOperator = 29,
        /// Invalid date format. Expected 'YYYY-MM-DD'.
        InvalidDateFormat = 38,
        /// Misaligned date value for the filter. The date should be the start of a
        /// week/month/quarter if the filtered field is
        /// segments.week/segments.month/segments.quarter.
        MisalignedDateForFilter = 64,
        /// Value passed was not a string when it should have been. For example, it
        /// was a number or unquoted literal.
        InvalidStringValue = 57,
        /// A String value passed to the BETWEEN operator does not parse as a date.
        InvalidValueWithBetweenOperator = 26,
        /// The value passed to the DURING operator is not a Date range literal
        InvalidValueWithDuringOperator = 22,
        /// An invalid value was passed to the LIKE operator.
        InvalidValueWithLikeOperator = 56,
        /// An operator was provided that is inapplicable to the field being
        /// filtered.
        OperatorFieldMismatch = 35,
        /// A Condition was found with an empty list.
        ProhibitedEmptyListInCondition = 28,
        /// A condition used in the query references an unsupported enum constant.
        ProhibitedEnumConstant = 54,
        /// Fields that are not allowed to be selected together were included in
        /// the SELECT clause.
        ProhibitedFieldCombinationInSelectClause = 31,
        /// A field that is not orderable was included in the ORDER BY clause.
        ProhibitedFieldInOrderByClause = 40,
        /// A field that is not selectable was included in the SELECT clause.
        ProhibitedFieldInSelectClause = 23,
        /// A field that is not filterable was included in the WHERE clause.
        ProhibitedFieldInWhereClause = 24,
        /// Resource type specified in the FROM clause is not supported by this
        /// service.
        ProhibitedResourceTypeInFromClause = 43,
        /// A field that comes from an incompatible resource was included in the
        /// SELECT clause.
        ProhibitedResourceTypeInSelectClause = 48,
        /// A field that comes from an incompatible resource was included in the
        /// WHERE clause.
        ProhibitedResourceTypeInWhereClause = 58,
        /// A metric incompatible with the main resource or other selected
        /// segmenting resources was included in the SELECT or WHERE clause.
        ProhibitedMetricInSelectOrWhereClause = 49,
        /// A segment incompatible with the main resource or other selected
        /// segmenting resources was included in the SELECT or WHERE clause.
        ProhibitedSegmentInSelectOrWhereClause = 51,
        /// A segment in the SELECT clause is incompatible with a metric in the
        /// SELECT or WHERE clause.
        ProhibitedSegmentWithMetricInSelectOrWhereClause = 53,
        /// The value passed to the limit clause is too low.
        LimitValueTooLow = 25,
        /// Query has a string containing a newline character.
        ProhibitedNewlineInString = 8,
        /// List contains values of different types.
        ProhibitedValueCombinationInList = 10,
        /// The values passed to the BETWEEN operator are not of the same type.
        ProhibitedValueCombinationWithBetweenOperator = 21,
        /// Query contains unterminated string.
        StringNotTerminated = 6,
        /// Too many segments are specified in SELECT clause.
        TooManySegments = 34,
        /// Query is incomplete and cannot be parsed.
        UnexpectedEndOfQuery = 9,
        /// FROM clause cannot be specified in this query.
        UnexpectedFromClause = 47,
        /// Query contains one or more unrecognized fields.
        UnrecognizedField = 32,
        /// Query has an unexpected extra part.
        UnexpectedInput = 11,
        /// Metrics cannot be requested for a manager account. To retrieve metrics,
        /// issue separate requests against each client account under the manager
        /// account.
        RequestedMetricsForManager = 59,
        /// The number of values (right-hand-side operands) in a filter exceeds the
        /// limit.
        FilterHasTooManyValues = 63,
    }
    impl QueryError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::QueryError => "QUERY_ERROR",
                Self::BadEnumConstant => "BAD_ENUM_CONSTANT",
                Self::BadEscapeSequence => "BAD_ESCAPE_SEQUENCE",
                Self::BadFieldName => "BAD_FIELD_NAME",
                Self::BadLimitValue => "BAD_LIMIT_VALUE",
                Self::BadNumber => "BAD_NUMBER",
                Self::BadOperator => "BAD_OPERATOR",
                Self::BadParameterName => "BAD_PARAMETER_NAME",
                Self::BadParameterValue => "BAD_PARAMETER_VALUE",
                Self::BadResourceTypeInFromClause => "BAD_RESOURCE_TYPE_IN_FROM_CLAUSE",
                Self::BadSymbol => "BAD_SYMBOL",
                Self::BadValue => "BAD_VALUE",
                Self::DateRangeTooWide => "DATE_RANGE_TOO_WIDE",
                Self::DateRangeTooNarrow => "DATE_RANGE_TOO_NARROW",
                Self::ExpectedAnd => "EXPECTED_AND",
                Self::ExpectedBy => "EXPECTED_BY",
                Self::ExpectedDimensionFieldInSelectClause => {
                    "EXPECTED_DIMENSION_FIELD_IN_SELECT_CLAUSE"
                }
                Self::ExpectedFiltersOnDateRange => "EXPECTED_FILTERS_ON_DATE_RANGE",
                Self::ExpectedFrom => "EXPECTED_FROM",
                Self::ExpectedList => "EXPECTED_LIST",
                Self::ExpectedReferencedFieldInSelectClause => {
                    "EXPECTED_REFERENCED_FIELD_IN_SELECT_CLAUSE"
                }
                Self::ExpectedSelect => "EXPECTED_SELECT",
                Self::ExpectedSingleValue => "EXPECTED_SINGLE_VALUE",
                Self::ExpectedValueWithBetweenOperator => {
                    "EXPECTED_VALUE_WITH_BETWEEN_OPERATOR"
                }
                Self::InvalidDateFormat => "INVALID_DATE_FORMAT",
                Self::MisalignedDateForFilter => "MISALIGNED_DATE_FOR_FILTER",
                Self::InvalidStringValue => "INVALID_STRING_VALUE",
                Self::InvalidValueWithBetweenOperator => {
                    "INVALID_VALUE_WITH_BETWEEN_OPERATOR"
                }
                Self::InvalidValueWithDuringOperator => {
                    "INVALID_VALUE_WITH_DURING_OPERATOR"
                }
                Self::InvalidValueWithLikeOperator => "INVALID_VALUE_WITH_LIKE_OPERATOR",
                Self::OperatorFieldMismatch => "OPERATOR_FIELD_MISMATCH",
                Self::ProhibitedEmptyListInCondition => {
                    "PROHIBITED_EMPTY_LIST_IN_CONDITION"
                }
                Self::ProhibitedEnumConstant => "PROHIBITED_ENUM_CONSTANT",
                Self::ProhibitedFieldCombinationInSelectClause => {
                    "PROHIBITED_FIELD_COMBINATION_IN_SELECT_CLAUSE"
                }
                Self::ProhibitedFieldInOrderByClause => {
                    "PROHIBITED_FIELD_IN_ORDER_BY_CLAUSE"
                }
                Self::ProhibitedFieldInSelectClause => {
                    "PROHIBITED_FIELD_IN_SELECT_CLAUSE"
                }
                Self::ProhibitedFieldInWhereClause => "PROHIBITED_FIELD_IN_WHERE_CLAUSE",
                Self::ProhibitedResourceTypeInFromClause => {
                    "PROHIBITED_RESOURCE_TYPE_IN_FROM_CLAUSE"
                }
                Self::ProhibitedResourceTypeInSelectClause => {
                    "PROHIBITED_RESOURCE_TYPE_IN_SELECT_CLAUSE"
                }
                Self::ProhibitedResourceTypeInWhereClause => {
                    "PROHIBITED_RESOURCE_TYPE_IN_WHERE_CLAUSE"
                }
                Self::ProhibitedMetricInSelectOrWhereClause => {
                    "PROHIBITED_METRIC_IN_SELECT_OR_WHERE_CLAUSE"
                }
                Self::ProhibitedSegmentInSelectOrWhereClause => {
                    "PROHIBITED_SEGMENT_IN_SELECT_OR_WHERE_CLAUSE"
                }
                Self::ProhibitedSegmentWithMetricInSelectOrWhereClause => {
                    "PROHIBITED_SEGMENT_WITH_METRIC_IN_SELECT_OR_WHERE_CLAUSE"
                }
                Self::LimitValueTooLow => "LIMIT_VALUE_TOO_LOW",
                Self::ProhibitedNewlineInString => "PROHIBITED_NEWLINE_IN_STRING",
                Self::ProhibitedValueCombinationInList => {
                    "PROHIBITED_VALUE_COMBINATION_IN_LIST"
                }
                Self::ProhibitedValueCombinationWithBetweenOperator => {
                    "PROHIBITED_VALUE_COMBINATION_WITH_BETWEEN_OPERATOR"
                }
                Self::StringNotTerminated => "STRING_NOT_TERMINATED",
                Self::TooManySegments => "TOO_MANY_SEGMENTS",
                Self::UnexpectedEndOfQuery => "UNEXPECTED_END_OF_QUERY",
                Self::UnexpectedFromClause => "UNEXPECTED_FROM_CLAUSE",
                Self::UnrecognizedField => "UNRECOGNIZED_FIELD",
                Self::UnexpectedInput => "UNEXPECTED_INPUT",
                Self::RequestedMetricsForManager => "REQUESTED_METRICS_FOR_MANAGER",
                Self::FilterHasTooManyValues => "FILTER_HAS_TOO_MANY_VALUES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "QUERY_ERROR" => Some(Self::QueryError),
                "BAD_ENUM_CONSTANT" => Some(Self::BadEnumConstant),
                "BAD_ESCAPE_SEQUENCE" => Some(Self::BadEscapeSequence),
                "BAD_FIELD_NAME" => Some(Self::BadFieldName),
                "BAD_LIMIT_VALUE" => Some(Self::BadLimitValue),
                "BAD_NUMBER" => Some(Self::BadNumber),
                "BAD_OPERATOR" => Some(Self::BadOperator),
                "BAD_PARAMETER_NAME" => Some(Self::BadParameterName),
                "BAD_PARAMETER_VALUE" => Some(Self::BadParameterValue),
                "BAD_RESOURCE_TYPE_IN_FROM_CLAUSE" => {
                    Some(Self::BadResourceTypeInFromClause)
                }
                "BAD_SYMBOL" => Some(Self::BadSymbol),
                "BAD_VALUE" => Some(Self::BadValue),
                "DATE_RANGE_TOO_WIDE" => Some(Self::DateRangeTooWide),
                "DATE_RANGE_TOO_NARROW" => Some(Self::DateRangeTooNarrow),
                "EXPECTED_AND" => Some(Self::ExpectedAnd),
                "EXPECTED_BY" => Some(Self::ExpectedBy),
                "EXPECTED_DIMENSION_FIELD_IN_SELECT_CLAUSE" => {
                    Some(Self::ExpectedDimensionFieldInSelectClause)
                }
                "EXPECTED_FILTERS_ON_DATE_RANGE" => {
                    Some(Self::ExpectedFiltersOnDateRange)
                }
                "EXPECTED_FROM" => Some(Self::ExpectedFrom),
                "EXPECTED_LIST" => Some(Self::ExpectedList),
                "EXPECTED_REFERENCED_FIELD_IN_SELECT_CLAUSE" => {
                    Some(Self::ExpectedReferencedFieldInSelectClause)
                }
                "EXPECTED_SELECT" => Some(Self::ExpectedSelect),
                "EXPECTED_SINGLE_VALUE" => Some(Self::ExpectedSingleValue),
                "EXPECTED_VALUE_WITH_BETWEEN_OPERATOR" => {
                    Some(Self::ExpectedValueWithBetweenOperator)
                }
                "INVALID_DATE_FORMAT" => Some(Self::InvalidDateFormat),
                "MISALIGNED_DATE_FOR_FILTER" => Some(Self::MisalignedDateForFilter),
                "INVALID_STRING_VALUE" => Some(Self::InvalidStringValue),
                "INVALID_VALUE_WITH_BETWEEN_OPERATOR" => {
                    Some(Self::InvalidValueWithBetweenOperator)
                }
                "INVALID_VALUE_WITH_DURING_OPERATOR" => {
                    Some(Self::InvalidValueWithDuringOperator)
                }
                "INVALID_VALUE_WITH_LIKE_OPERATOR" => {
                    Some(Self::InvalidValueWithLikeOperator)
                }
                "OPERATOR_FIELD_MISMATCH" => Some(Self::OperatorFieldMismatch),
                "PROHIBITED_EMPTY_LIST_IN_CONDITION" => {
                    Some(Self::ProhibitedEmptyListInCondition)
                }
                "PROHIBITED_ENUM_CONSTANT" => Some(Self::ProhibitedEnumConstant),
                "PROHIBITED_FIELD_COMBINATION_IN_SELECT_CLAUSE" => {
                    Some(Self::ProhibitedFieldCombinationInSelectClause)
                }
                "PROHIBITED_FIELD_IN_ORDER_BY_CLAUSE" => {
                    Some(Self::ProhibitedFieldInOrderByClause)
                }
                "PROHIBITED_FIELD_IN_SELECT_CLAUSE" => {
                    Some(Self::ProhibitedFieldInSelectClause)
                }
                "PROHIBITED_FIELD_IN_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedFieldInWhereClause)
                }
                "PROHIBITED_RESOURCE_TYPE_IN_FROM_CLAUSE" => {
                    Some(Self::ProhibitedResourceTypeInFromClause)
                }
                "PROHIBITED_RESOURCE_TYPE_IN_SELECT_CLAUSE" => {
                    Some(Self::ProhibitedResourceTypeInSelectClause)
                }
                "PROHIBITED_RESOURCE_TYPE_IN_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedResourceTypeInWhereClause)
                }
                "PROHIBITED_METRIC_IN_SELECT_OR_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedMetricInSelectOrWhereClause)
                }
                "PROHIBITED_SEGMENT_IN_SELECT_OR_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedSegmentInSelectOrWhereClause)
                }
                "PROHIBITED_SEGMENT_WITH_METRIC_IN_SELECT_OR_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedSegmentWithMetricInSelectOrWhereClause)
                }
                "LIMIT_VALUE_TOO_LOW" => Some(Self::LimitValueTooLow),
                "PROHIBITED_NEWLINE_IN_STRING" => Some(Self::ProhibitedNewlineInString),
                "PROHIBITED_VALUE_COMBINATION_IN_LIST" => {
                    Some(Self::ProhibitedValueCombinationInList)
                }
                "PROHIBITED_VALUE_COMBINATION_WITH_BETWEEN_OPERATOR" => {
                    Some(Self::ProhibitedValueCombinationWithBetweenOperator)
                }
                "STRING_NOT_TERMINATED" => Some(Self::StringNotTerminated),
                "TOO_MANY_SEGMENTS" => Some(Self::TooManySegments),
                "UNEXPECTED_END_OF_QUERY" => Some(Self::UnexpectedEndOfQuery),
                "UNEXPECTED_FROM_CLAUSE" => Some(Self::UnexpectedFromClause),
                "UNRECOGNIZED_FIELD" => Some(Self::UnrecognizedField),
                "UNEXPECTED_INPUT" => Some(Self::UnexpectedInput),
                "REQUESTED_METRICS_FOR_MANAGER" => Some(Self::RequestedMetricsForManager),
                "FILTER_HAS_TOO_MANY_VALUES" => Some(Self::FilterHasTooManyValues),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible quota errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuotaErrorEnum {}
/// Nested message and enum types in `QuotaErrorEnum`.
pub mod quota_error_enum {
    /// Enum describing possible quota errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum QuotaError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Too many requests.
        ResourceExhausted = 2,
        /// Access is prohibited.
        AccessProhibited = 3,
        /// Too many requests in a short amount of time.
        ResourceTemporarilyExhausted = 4,
    }
    impl QuotaError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ResourceExhausted => "RESOURCE_EXHAUSTED",
                Self::AccessProhibited => "ACCESS_PROHIBITED",
                Self::ResourceTemporarilyExhausted => "RESOURCE_TEMPORARILY_EXHAUSTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RESOURCE_EXHAUSTED" => Some(Self::ResourceExhausted),
                "ACCESS_PROHIBITED" => Some(Self::AccessProhibited),
                "RESOURCE_TEMPORARILY_EXHAUSTED" => {
                    Some(Self::ResourceTemporarilyExhausted)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible range errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RangeErrorEnum {}
/// Nested message and enum types in `RangeErrorEnum`.
pub mod range_error_enum {
    /// Enum describing possible range errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RangeError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Too low.
        TooLow = 2,
        /// Too high.
        TooHigh = 3,
    }
    impl RangeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::TooLow => "TOO_LOW",
                Self::TooHigh => "TOO_HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TOO_LOW" => Some(Self::TooLow),
                "TOO_HIGH" => Some(Self::TooHigh),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible errors returned from
/// the ReachPlanService.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReachPlanErrorEnum {}
/// Nested message and enum types in `ReachPlanErrorEnum`.
pub mod reach_plan_error_enum {
    /// Enum describing possible errors from ReachPlanService.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReachPlanError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Not forecastable due to missing rate card data.
        NotForecastableMissingRate = 2,
        /// Not forecastable due to not enough inventory.
        NotForecastableNotEnoughInventory = 3,
        /// Not forecastable due to account not being enabled.
        NotForecastableAccountNotEnabled = 4,
    }
    impl ReachPlanError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NotForecastableMissingRate => "NOT_FORECASTABLE_MISSING_RATE",
                Self::NotForecastableNotEnoughInventory => {
                    "NOT_FORECASTABLE_NOT_ENOUGH_INVENTORY"
                }
                Self::NotForecastableAccountNotEnabled => {
                    "NOT_FORECASTABLE_ACCOUNT_NOT_ENABLED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOT_FORECASTABLE_MISSING_RATE" => Some(Self::NotForecastableMissingRate),
                "NOT_FORECASTABLE_NOT_ENOUGH_INVENTORY" => {
                    Some(Self::NotForecastableNotEnoughInventory)
                }
                "NOT_FORECASTABLE_ACCOUNT_NOT_ENABLED" => {
                    Some(Self::NotForecastableAccountNotEnabled)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible errors from applying a recommendation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecommendationErrorEnum {}
/// Nested message and enum types in `RecommendationErrorEnum`.
pub mod recommendation_error_enum {
    /// Enum describing possible errors from applying a recommendation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RecommendationError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The specified budget amount is too low for example, lower than minimum
        /// currency unit or lower than ad group minimum cost-per-click.
        BudgetAmountTooSmall = 2,
        /// The specified budget amount is too large.
        BudgetAmountTooLarge = 3,
        /// The specified budget amount is not a valid amount, for example, not a
        /// multiple of minimum currency unit.
        InvalidBudgetAmount = 4,
        /// The specified keyword or ad violates ad policy.
        PolicyError = 5,
        /// The specified bid amount is not valid, for example, too many fractional
        /// digits, or negative amount.
        InvalidBidAmount = 6,
        /// The number of keywords in ad group have reached the maximum allowed.
        AdgroupKeywordLimit = 7,
        /// The recommendation requested to apply has already been applied.
        RecommendationAlreadyApplied = 8,
        /// The recommendation requested to apply has been invalidated.
        RecommendationInvalidated = 9,
        /// The number of operations in a single request exceeds the maximum allowed.
        TooManyOperations = 10,
        /// There are no operations in the request.
        NoOperations = 11,
        /// Operations with multiple recommendation types are not supported when
        /// partial failure mode is not enabled.
        DifferentTypesNotSupported = 12,
        /// Request contains multiple operations with the same resource_name.
        DuplicateResourceName = 13,
        /// The recommendation requested to dismiss has already been dismissed.
        RecommendationAlreadyDismissed = 14,
        /// The recommendation apply request was malformed and invalid.
        InvalidApplyRequest = 15,
        /// The type of recommendation requested to apply is not supported.
        RecommendationTypeApplyNotSupported = 17,
        /// The target multiplier specified is invalid.
        InvalidMultiplier = 18,
        /// The passed in advertising_channel_type is not supported.
        AdvertisingChannelTypeGenerateNotSupported = 19,
        /// The passed in recommendation_type is not supported.
        RecommendationTypeGenerateNotSupported = 20,
        /// One or more recommendation_types need to be passed into the generate
        /// recommendations request.
        RecommendationTypesCannotBeEmpty = 21,
    }
    impl RecommendationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::BudgetAmountTooSmall => "BUDGET_AMOUNT_TOO_SMALL",
                Self::BudgetAmountTooLarge => "BUDGET_AMOUNT_TOO_LARGE",
                Self::InvalidBudgetAmount => "INVALID_BUDGET_AMOUNT",
                Self::PolicyError => "POLICY_ERROR",
                Self::InvalidBidAmount => "INVALID_BID_AMOUNT",
                Self::AdgroupKeywordLimit => "ADGROUP_KEYWORD_LIMIT",
                Self::RecommendationAlreadyApplied => "RECOMMENDATION_ALREADY_APPLIED",
                Self::RecommendationInvalidated => "RECOMMENDATION_INVALIDATED",
                Self::TooManyOperations => "TOO_MANY_OPERATIONS",
                Self::NoOperations => "NO_OPERATIONS",
                Self::DifferentTypesNotSupported => "DIFFERENT_TYPES_NOT_SUPPORTED",
                Self::DuplicateResourceName => "DUPLICATE_RESOURCE_NAME",
                Self::RecommendationAlreadyDismissed => {
                    "RECOMMENDATION_ALREADY_DISMISSED"
                }
                Self::InvalidApplyRequest => "INVALID_APPLY_REQUEST",
                Self::RecommendationTypeApplyNotSupported => {
                    "RECOMMENDATION_TYPE_APPLY_NOT_SUPPORTED"
                }
                Self::InvalidMultiplier => "INVALID_MULTIPLIER",
                Self::AdvertisingChannelTypeGenerateNotSupported => {
                    "ADVERTISING_CHANNEL_TYPE_GENERATE_NOT_SUPPORTED"
                }
                Self::RecommendationTypeGenerateNotSupported => {
                    "RECOMMENDATION_TYPE_GENERATE_NOT_SUPPORTED"
                }
                Self::RecommendationTypesCannotBeEmpty => {
                    "RECOMMENDATION_TYPES_CANNOT_BE_EMPTY"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUDGET_AMOUNT_TOO_SMALL" => Some(Self::BudgetAmountTooSmall),
                "BUDGET_AMOUNT_TOO_LARGE" => Some(Self::BudgetAmountTooLarge),
                "INVALID_BUDGET_AMOUNT" => Some(Self::InvalidBudgetAmount),
                "POLICY_ERROR" => Some(Self::PolicyError),
                "INVALID_BID_AMOUNT" => Some(Self::InvalidBidAmount),
                "ADGROUP_KEYWORD_LIMIT" => Some(Self::AdgroupKeywordLimit),
                "RECOMMENDATION_ALREADY_APPLIED" => {
                    Some(Self::RecommendationAlreadyApplied)
                }
                "RECOMMENDATION_INVALIDATED" => Some(Self::RecommendationInvalidated),
                "TOO_MANY_OPERATIONS" => Some(Self::TooManyOperations),
                "NO_OPERATIONS" => Some(Self::NoOperations),
                "DIFFERENT_TYPES_NOT_SUPPORTED" => Some(Self::DifferentTypesNotSupported),
                "DUPLICATE_RESOURCE_NAME" => Some(Self::DuplicateResourceName),
                "RECOMMENDATION_ALREADY_DISMISSED" => {
                    Some(Self::RecommendationAlreadyDismissed)
                }
                "INVALID_APPLY_REQUEST" => Some(Self::InvalidApplyRequest),
                "RECOMMENDATION_TYPE_APPLY_NOT_SUPPORTED" => {
                    Some(Self::RecommendationTypeApplyNotSupported)
                }
                "INVALID_MULTIPLIER" => Some(Self::InvalidMultiplier),
                "ADVERTISING_CHANNEL_TYPE_GENERATE_NOT_SUPPORTED" => {
                    Some(Self::AdvertisingChannelTypeGenerateNotSupported)
                }
                "RECOMMENDATION_TYPE_GENERATE_NOT_SUPPORTED" => {
                    Some(Self::RecommendationTypeGenerateNotSupported)
                }
                "RECOMMENDATION_TYPES_CANNOT_BE_EMPTY" => {
                    Some(Self::RecommendationTypesCannotBeEmpty)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible recommendation subscription errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecommendationSubscriptionErrorEnum {}
/// Nested message and enum types in `RecommendationSubscriptionErrorEnum`.
pub mod recommendation_subscription_error_enum {
    /// Enum describing possible recommendation subscription errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RecommendationSubscriptionError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
    }
    impl RecommendationSubscriptionError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible region code errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegionCodeErrorEnum {}
/// Nested message and enum types in `RegionCodeErrorEnum`.
pub mod region_code_error_enum {
    /// Enum describing possible region code errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RegionCodeError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Invalid region code.
        InvalidRegionCode = 2,
    }
    impl RegionCodeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidRegionCode => "INVALID_REGION_CODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_REGION_CODE" => Some(Self::InvalidRegionCode),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible request errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestErrorEnum {}
/// Nested message and enum types in `RequestErrorEnum`.
pub mod request_error_enum {
    /// Enum describing possible request errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RequestError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Resource name is required for this request.
        ResourceNameMissing = 3,
        /// Resource name provided is malformed.
        ResourceNameMalformed = 4,
        /// Resource name provided is malformed.
        BadResourceId = 17,
        /// Customer ID is invalid.
        InvalidCustomerId = 16,
        /// Mutate operation should have either create, update, or remove specified.
        OperationRequired = 5,
        /// Requested resource not found.
        ResourceNotFound = 6,
        /// Next page token specified in user request is invalid.
        InvalidPageToken = 7,
        /// Next page token specified in user request has expired.
        ExpiredPageToken = 8,
        /// Page size specified in user request is invalid.
        InvalidPageSize = 22,
        /// Setting the page size is not supported, and will be unavailable in a
        /// future version.
        PageSizeNotSupported = 40,
        /// Required field is missing.
        RequiredFieldMissing = 9,
        /// The field cannot be modified because it's immutable. It's also possible
        /// that the field can be modified using 'create' operation but not 'update'.
        ImmutableField = 11,
        /// Received too many entries in request.
        TooManyMutateOperations = 13,
        /// Request cannot be executed by a manager account.
        CannotBeExecutedByManagerAccount = 14,
        /// Mutate request was attempting to modify a readonly field.
        /// For instance, Budget fields can be requested for Ad Group,
        /// but are read-only for adGroups:mutate.
        CannotModifyForeignField = 15,
        /// Enum value is not permitted.
        InvalidEnumValue = 18,
        /// The developer-token parameter is required for all requests.
        DeveloperTokenParameterMissing = 19,
        /// The login-customer-id parameter is required for this request.
        LoginCustomerIdParameterMissing = 20,
        /// page_token is set in the validate only request
        ValidateOnlyRequestHasPageToken = 21,
        /// return_summary_row cannot be enabled if request did not select any
        /// metrics field.
        CannotReturnSummaryRowForRequestWithoutMetrics = 29,
        /// return_summary_row should not be enabled for validate only requests.
        CannotReturnSummaryRowForValidateOnlyRequests = 30,
        /// return_summary_row parameter value should be the same between requests
        /// with page_token field set and their original request.
        InconsistentReturnSummaryRowValue = 31,
        /// The total results count cannot be returned if it was not requested in the
        /// original request.
        TotalResultsCountNotOriginallyRequested = 32,
        /// Deadline specified by the client was too short.
        RpcDeadlineTooShort = 33,
        /// This API version has been sunset and is no longer supported.
        UnsupportedVersion = 38,
        /// The Google Cloud project in the request was not found.
        CloudProjectNotFound = 39,
    }
    impl RequestError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ResourceNameMissing => "RESOURCE_NAME_MISSING",
                Self::ResourceNameMalformed => "RESOURCE_NAME_MALFORMED",
                Self::BadResourceId => "BAD_RESOURCE_ID",
                Self::InvalidCustomerId => "INVALID_CUSTOMER_ID",
                Self::OperationRequired => "OPERATION_REQUIRED",
                Self::ResourceNotFound => "RESOURCE_NOT_FOUND",
                Self::InvalidPageToken => "INVALID_PAGE_TOKEN",
                Self::ExpiredPageToken => "EXPIRED_PAGE_TOKEN",
                Self::InvalidPageSize => "INVALID_PAGE_SIZE",
                Self::PageSizeNotSupported => "PAGE_SIZE_NOT_SUPPORTED",
                Self::RequiredFieldMissing => "REQUIRED_FIELD_MISSING",
                Self::ImmutableField => "IMMUTABLE_FIELD",
                Self::TooManyMutateOperations => "TOO_MANY_MUTATE_OPERATIONS",
                Self::CannotBeExecutedByManagerAccount => {
                    "CANNOT_BE_EXECUTED_BY_MANAGER_ACCOUNT"
                }
                Self::CannotModifyForeignField => "CANNOT_MODIFY_FOREIGN_FIELD",
                Self::InvalidEnumValue => "INVALID_ENUM_VALUE",
                Self::DeveloperTokenParameterMissing => {
                    "DEVELOPER_TOKEN_PARAMETER_MISSING"
                }
                Self::LoginCustomerIdParameterMissing => {
                    "LOGIN_CUSTOMER_ID_PARAMETER_MISSING"
                }
                Self::ValidateOnlyRequestHasPageToken => {
                    "VALIDATE_ONLY_REQUEST_HAS_PAGE_TOKEN"
                }
                Self::CannotReturnSummaryRowForRequestWithoutMetrics => {
                    "CANNOT_RETURN_SUMMARY_ROW_FOR_REQUEST_WITHOUT_METRICS"
                }
                Self::CannotReturnSummaryRowForValidateOnlyRequests => {
                    "CANNOT_RETURN_SUMMARY_ROW_FOR_VALIDATE_ONLY_REQUESTS"
                }
                Self::InconsistentReturnSummaryRowValue => {
                    "INCONSISTENT_RETURN_SUMMARY_ROW_VALUE"
                }
                Self::TotalResultsCountNotOriginallyRequested => {
                    "TOTAL_RESULTS_COUNT_NOT_ORIGINALLY_REQUESTED"
                }
                Self::RpcDeadlineTooShort => "RPC_DEADLINE_TOO_SHORT",
                Self::UnsupportedVersion => "UNSUPPORTED_VERSION",
                Self::CloudProjectNotFound => "CLOUD_PROJECT_NOT_FOUND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RESOURCE_NAME_MISSING" => Some(Self::ResourceNameMissing),
                "RESOURCE_NAME_MALFORMED" => Some(Self::ResourceNameMalformed),
                "BAD_RESOURCE_ID" => Some(Self::BadResourceId),
                "INVALID_CUSTOMER_ID" => Some(Self::InvalidCustomerId),
                "OPERATION_REQUIRED" => Some(Self::OperationRequired),
                "RESOURCE_NOT_FOUND" => Some(Self::ResourceNotFound),
                "INVALID_PAGE_TOKEN" => Some(Self::InvalidPageToken),
                "EXPIRED_PAGE_TOKEN" => Some(Self::ExpiredPageToken),
                "INVALID_PAGE_SIZE" => Some(Self::InvalidPageSize),
                "PAGE_SIZE_NOT_SUPPORTED" => Some(Self::PageSizeNotSupported),
                "REQUIRED_FIELD_MISSING" => Some(Self::RequiredFieldMissing),
                "IMMUTABLE_FIELD" => Some(Self::ImmutableField),
                "TOO_MANY_MUTATE_OPERATIONS" => Some(Self::TooManyMutateOperations),
                "CANNOT_BE_EXECUTED_BY_MANAGER_ACCOUNT" => {
                    Some(Self::CannotBeExecutedByManagerAccount)
                }
                "CANNOT_MODIFY_FOREIGN_FIELD" => Some(Self::CannotModifyForeignField),
                "INVALID_ENUM_VALUE" => Some(Self::InvalidEnumValue),
                "DEVELOPER_TOKEN_PARAMETER_MISSING" => {
                    Some(Self::DeveloperTokenParameterMissing)
                }
                "LOGIN_CUSTOMER_ID_PARAMETER_MISSING" => {
                    Some(Self::LoginCustomerIdParameterMissing)
                }
                "VALIDATE_ONLY_REQUEST_HAS_PAGE_TOKEN" => {
                    Some(Self::ValidateOnlyRequestHasPageToken)
                }
                "CANNOT_RETURN_SUMMARY_ROW_FOR_REQUEST_WITHOUT_METRICS" => {
                    Some(Self::CannotReturnSummaryRowForRequestWithoutMetrics)
                }
                "CANNOT_RETURN_SUMMARY_ROW_FOR_VALIDATE_ONLY_REQUESTS" => {
                    Some(Self::CannotReturnSummaryRowForValidateOnlyRequests)
                }
                "INCONSISTENT_RETURN_SUMMARY_ROW_VALUE" => {
                    Some(Self::InconsistentReturnSummaryRowValue)
                }
                "TOTAL_RESULTS_COUNT_NOT_ORIGINALLY_REQUESTED" => {
                    Some(Self::TotalResultsCountNotOriginallyRequested)
                }
                "RPC_DEADLINE_TOO_SHORT" => Some(Self::RpcDeadlineTooShort),
                "UNSUPPORTED_VERSION" => Some(Self::UnsupportedVersion),
                "CLOUD_PROJECT_NOT_FOUND" => Some(Self::CloudProjectNotFound),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible resource access denied errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourceAccessDeniedErrorEnum {}
/// Nested message and enum types in `ResourceAccessDeniedErrorEnum`.
pub mod resource_access_denied_error_enum {
    /// Enum describing possible resource access denied errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResourceAccessDeniedError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// User did not have write access.
        WriteAccessDenied = 3,
    }
    impl ResourceAccessDeniedError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::WriteAccessDenied => "WRITE_ACCESS_DENIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "WRITE_ACCESS_DENIED" => Some(Self::WriteAccessDenied),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible resource count limit exceeded errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourceCountLimitExceededErrorEnum {}
/// Nested message and enum types in `ResourceCountLimitExceededErrorEnum`.
pub mod resource_count_limit_exceeded_error_enum {
    /// Enum describing possible resource count limit exceeded errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResourceCountLimitExceededError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Indicates that this request would exceed the number of allowed resources
        /// for the Google Ads account. The exact resource type and limit being
        /// checked can be inferred from accountLimitType.
        AccountLimit = 2,
        /// Indicates that this request would exceed the number of allowed resources
        /// in a Campaign. The exact resource type and limit being checked can be
        /// inferred from accountLimitType, and the numeric id of the
        /// Campaign involved is given by enclosingId.
        CampaignLimit = 3,
        /// Indicates that this request would exceed the number of allowed resources
        /// in an ad group. The exact resource type and limit being checked can be
        /// inferred from accountLimitType, and the numeric id of the
        /// ad group involved is given by enclosingId.
        AdgroupLimit = 4,
        /// Indicates that this request would exceed the number of allowed resources
        /// in an ad group ad. The exact resource type and limit being checked can
        /// be inferred from accountLimitType, and the enclosingId
        /// contains the ad group id followed by the ad id, separated by a single
        /// comma (,).
        AdGroupAdLimit = 5,
        /// Indicates that this request would exceed the number of allowed resources
        /// in an ad group criterion. The exact resource type and limit being checked
        /// can be inferred from accountLimitType, and the
        /// enclosingId contains the ad group id followed by the
        /// criterion id, separated by a single comma (,).
        AdGroupCriterionLimit = 6,
        /// Indicates that this request would exceed the number of allowed resources
        /// in this shared set. The exact resource type and limit being checked can
        /// be inferred from accountLimitType, and the numeric id of the
        /// shared set involved is given by enclosingId.
        SharedSetLimit = 7,
        /// Exceeds a limit related to a matching function.
        MatchingFunctionLimit = 8,
        /// The response for this request would exceed the maximum number of rows
        /// that can be returned.
        ResponseRowLimitExceeded = 9,
        /// This request would exceed a limit on the number of allowed resources.
        /// The details of which type of limit was exceeded will eventually be
        /// returned in ErrorDetails.
        ResourceLimit = 10,
    }
    impl ResourceCountLimitExceededError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AccountLimit => "ACCOUNT_LIMIT",
                Self::CampaignLimit => "CAMPAIGN_LIMIT",
                Self::AdgroupLimit => "ADGROUP_LIMIT",
                Self::AdGroupAdLimit => "AD_GROUP_AD_LIMIT",
                Self::AdGroupCriterionLimit => "AD_GROUP_CRITERION_LIMIT",
                Self::SharedSetLimit => "SHARED_SET_LIMIT",
                Self::MatchingFunctionLimit => "MATCHING_FUNCTION_LIMIT",
                Self::ResponseRowLimitExceeded => "RESPONSE_ROW_LIMIT_EXCEEDED",
                Self::ResourceLimit => "RESOURCE_LIMIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACCOUNT_LIMIT" => Some(Self::AccountLimit),
                "CAMPAIGN_LIMIT" => Some(Self::CampaignLimit),
                "ADGROUP_LIMIT" => Some(Self::AdgroupLimit),
                "AD_GROUP_AD_LIMIT" => Some(Self::AdGroupAdLimit),
                "AD_GROUP_CRITERION_LIMIT" => Some(Self::AdGroupCriterionLimit),
                "SHARED_SET_LIMIT" => Some(Self::SharedSetLimit),
                "MATCHING_FUNCTION_LIMIT" => Some(Self::MatchingFunctionLimit),
                "RESPONSE_ROW_LIMIT_EXCEEDED" => Some(Self::ResponseRowLimitExceeded),
                "RESOURCE_LIMIT" => Some(Self::ResourceLimit),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible search term insight errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SearchTermInsightErrorEnum {}
/// Nested message and enum types in `SearchTermInsightErrorEnum`.
pub mod search_term_insight_error_enum {
    /// Enum describing possible search term insight errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SearchTermInsightError {
        /// Name unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Search term insights cannot be filtered by metrics when segmenting.
        FilteringNotAllowedWithSegments = 2,
        /// Search term insights cannot have a LIMIT when segmenting.
        LimitNotAllowedWithSegments = 3,
        /// A selected field requires another field to be selected with it.
        MissingFieldInSelectClause = 4,
        /// A selected field/resource requires filtering by a single resource.
        RequiresFilterBySingleResource = 5,
        /// Search term insights cannot be sorted when segmenting.
        SortingNotAllowedWithSegments = 6,
        /// Search term insights cannot have a summary row when segmenting.
        SummaryRowNotAllowedWithSegments = 7,
    }
    impl SearchTermInsightError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::FilteringNotAllowedWithSegments => {
                    "FILTERING_NOT_ALLOWED_WITH_SEGMENTS"
                }
                Self::LimitNotAllowedWithSegments => "LIMIT_NOT_ALLOWED_WITH_SEGMENTS",
                Self::MissingFieldInSelectClause => "MISSING_FIELD_IN_SELECT_CLAUSE",
                Self::RequiresFilterBySingleResource => {
                    "REQUIRES_FILTER_BY_SINGLE_RESOURCE"
                }
                Self::SortingNotAllowedWithSegments => {
                    "SORTING_NOT_ALLOWED_WITH_SEGMENTS"
                }
                Self::SummaryRowNotAllowedWithSegments => {
                    "SUMMARY_ROW_NOT_ALLOWED_WITH_SEGMENTS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FILTERING_NOT_ALLOWED_WITH_SEGMENTS" => {
                    Some(Self::FilteringNotAllowedWithSegments)
                }
                "LIMIT_NOT_ALLOWED_WITH_SEGMENTS" => {
                    Some(Self::LimitNotAllowedWithSegments)
                }
                "MISSING_FIELD_IN_SELECT_CLAUSE" => {
                    Some(Self::MissingFieldInSelectClause)
                }
                "REQUIRES_FILTER_BY_SINGLE_RESOURCE" => {
                    Some(Self::RequiresFilterBySingleResource)
                }
                "SORTING_NOT_ALLOWED_WITH_SEGMENTS" => {
                    Some(Self::SortingNotAllowedWithSegments)
                }
                "SUMMARY_ROW_NOT_ALLOWED_WITH_SEGMENTS" => {
                    Some(Self::SummaryRowNotAllowedWithSegments)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible setting errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SettingErrorEnum {}
/// Nested message and enum types in `SettingErrorEnum`.
pub mod setting_error_enum {
    /// Enum describing possible setting errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SettingError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The campaign setting is not available for this Google Ads account.
        SettingTypeIsNotAvailable = 3,
        /// The setting is not compatible with the campaign.
        SettingTypeIsNotCompatibleWithCampaign = 4,
        /// The supplied TargetingSetting contains an invalid CriterionTypeGroup. See
        /// CriterionTypeGroup documentation for CriterionTypeGroups allowed
        /// in Campaign or AdGroup TargetingSettings.
        TargetingSettingContainsInvalidCriterionTypeGroup = 5,
        /// TargetingSetting must not explicitly
        /// set any of the Demographic CriterionTypeGroups (AGE_RANGE, GENDER,
        /// PARENT, INCOME_RANGE) to false (it's okay to not set them at all, in
        /// which case the system will set them to true automatically).
        TargetingSettingDemographicCriterionTypeGroupsMustBeSetToTargetAll = 6,
        /// TargetingSetting cannot change any of
        /// the Demographic CriterionTypeGroups (AGE_RANGE, GENDER, PARENT,
        /// INCOME_RANGE) from true to false.
        TargetingSettingCannotChangeTargetAllToFalseForDemographicCriterionTypeGroup = 7,
        /// At least one feed id should be present.
        DynamicSearchAdsSettingAtLeastOneFeedIdMustBePresent = 8,
        /// The supplied DynamicSearchAdsSetting contains an invalid domain name.
        DynamicSearchAdsSettingContainsInvalidDomainName = 9,
        /// The supplied DynamicSearchAdsSetting contains a subdomain name.
        DynamicSearchAdsSettingContainsSubdomainName = 10,
        /// The supplied DynamicSearchAdsSetting contains an invalid language code.
        DynamicSearchAdsSettingContainsInvalidLanguageCode = 11,
        /// TargetingSettings in search campaigns should not have
        /// CriterionTypeGroup.PLACEMENT set to targetAll.
        TargetAllIsNotAllowedForPlacementInSearchCampaign = 12,
        /// The setting value is not compatible with the campaign type.
        SettingValueNotCompatibleWithCampaign = 20,
        /// Switching from observation setting to targeting setting is not allowed
        /// for Customer Match lists. See
        /// <https://support.google.com/google-ads/answer/6299717.>
        BidOnlyIsNotAllowedToBeModifiedWithCustomerMatchTargeting = 21,
    }
    impl SettingError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::SettingTypeIsNotAvailable => "SETTING_TYPE_IS_NOT_AVAILABLE",
                Self::SettingTypeIsNotCompatibleWithCampaign => {
                    "SETTING_TYPE_IS_NOT_COMPATIBLE_WITH_CAMPAIGN"
                }
                Self::TargetingSettingContainsInvalidCriterionTypeGroup => {
                    "TARGETING_SETTING_CONTAINS_INVALID_CRITERION_TYPE_GROUP"
                }
                Self::TargetingSettingDemographicCriterionTypeGroupsMustBeSetToTargetAll => {
                    "TARGETING_SETTING_DEMOGRAPHIC_CRITERION_TYPE_GROUPS_MUST_BE_SET_TO_TARGET_ALL"
                }
                Self::TargetingSettingCannotChangeTargetAllToFalseForDemographicCriterionTypeGroup => {
                    "TARGETING_SETTING_CANNOT_CHANGE_TARGET_ALL_TO_FALSE_FOR_DEMOGRAPHIC_CRITERION_TYPE_GROUP"
                }
                Self::DynamicSearchAdsSettingAtLeastOneFeedIdMustBePresent => {
                    "DYNAMIC_SEARCH_ADS_SETTING_AT_LEAST_ONE_FEED_ID_MUST_BE_PRESENT"
                }
                Self::DynamicSearchAdsSettingContainsInvalidDomainName => {
                    "DYNAMIC_SEARCH_ADS_SETTING_CONTAINS_INVALID_DOMAIN_NAME"
                }
                Self::DynamicSearchAdsSettingContainsSubdomainName => {
                    "DYNAMIC_SEARCH_ADS_SETTING_CONTAINS_SUBDOMAIN_NAME"
                }
                Self::DynamicSearchAdsSettingContainsInvalidLanguageCode => {
                    "DYNAMIC_SEARCH_ADS_SETTING_CONTAINS_INVALID_LANGUAGE_CODE"
                }
                Self::TargetAllIsNotAllowedForPlacementInSearchCampaign => {
                    "TARGET_ALL_IS_NOT_ALLOWED_FOR_PLACEMENT_IN_SEARCH_CAMPAIGN"
                }
                Self::SettingValueNotCompatibleWithCampaign => {
                    "SETTING_VALUE_NOT_COMPATIBLE_WITH_CAMPAIGN"
                }
                Self::BidOnlyIsNotAllowedToBeModifiedWithCustomerMatchTargeting => {
                    "BID_ONLY_IS_NOT_ALLOWED_TO_BE_MODIFIED_WITH_CUSTOMER_MATCH_TARGETING"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SETTING_TYPE_IS_NOT_AVAILABLE" => Some(Self::SettingTypeIsNotAvailable),
                "SETTING_TYPE_IS_NOT_COMPATIBLE_WITH_CAMPAIGN" => {
                    Some(Self::SettingTypeIsNotCompatibleWithCampaign)
                }
                "TARGETING_SETTING_CONTAINS_INVALID_CRITERION_TYPE_GROUP" => {
                    Some(Self::TargetingSettingContainsInvalidCriterionTypeGroup)
                }
                "TARGETING_SETTING_DEMOGRAPHIC_CRITERION_TYPE_GROUPS_MUST_BE_SET_TO_TARGET_ALL" => {
                    Some(
                        Self::TargetingSettingDemographicCriterionTypeGroupsMustBeSetToTargetAll,
                    )
                }
                "TARGETING_SETTING_CANNOT_CHANGE_TARGET_ALL_TO_FALSE_FOR_DEMOGRAPHIC_CRITERION_TYPE_GROUP" => {
                    Some(
                        Self::TargetingSettingCannotChangeTargetAllToFalseForDemographicCriterionTypeGroup,
                    )
                }
                "DYNAMIC_SEARCH_ADS_SETTING_AT_LEAST_ONE_FEED_ID_MUST_BE_PRESENT" => {
                    Some(Self::DynamicSearchAdsSettingAtLeastOneFeedIdMustBePresent)
                }
                "DYNAMIC_SEARCH_ADS_SETTING_CONTAINS_INVALID_DOMAIN_NAME" => {
                    Some(Self::DynamicSearchAdsSettingContainsInvalidDomainName)
                }
                "DYNAMIC_SEARCH_ADS_SETTING_CONTAINS_SUBDOMAIN_NAME" => {
                    Some(Self::DynamicSearchAdsSettingContainsSubdomainName)
                }
                "DYNAMIC_SEARCH_ADS_SETTING_CONTAINS_INVALID_LANGUAGE_CODE" => {
                    Some(Self::DynamicSearchAdsSettingContainsInvalidLanguageCode)
                }
                "TARGET_ALL_IS_NOT_ALLOWED_FOR_PLACEMENT_IN_SEARCH_CAMPAIGN" => {
                    Some(Self::TargetAllIsNotAllowedForPlacementInSearchCampaign)
                }
                "SETTING_VALUE_NOT_COMPATIBLE_WITH_CAMPAIGN" => {
                    Some(Self::SettingValueNotCompatibleWithCampaign)
                }
                "BID_ONLY_IS_NOT_ALLOWED_TO_BE_MODIFIED_WITH_CUSTOMER_MATCH_TARGETING" => {
                    Some(Self::BidOnlyIsNotAllowedToBeModifiedWithCustomerMatchTargeting)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible shared criterion errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SharedCriterionErrorEnum {}
/// Nested message and enum types in `SharedCriterionErrorEnum`.
pub mod shared_criterion_error_enum {
    /// Enum describing possible shared criterion errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SharedCriterionError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The criterion is not appropriate for the shared set type.
        CriterionTypeNotAllowedForSharedSetType = 2,
    }
    impl SharedCriterionError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CriterionTypeNotAllowedForSharedSetType => {
                    "CRITERION_TYPE_NOT_ALLOWED_FOR_SHARED_SET_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CRITERION_TYPE_NOT_ALLOWED_FOR_SHARED_SET_TYPE" => {
                    Some(Self::CriterionTypeNotAllowedForSharedSetType)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible shared set errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SharedSetErrorEnum {}
/// Nested message and enum types in `SharedSetErrorEnum`.
pub mod shared_set_error_enum {
    /// Enum describing possible shared set errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SharedSetError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The customer cannot create this type of shared set.
        CustomerCannotCreateSharedSetOfThisType = 2,
        /// A shared set with this name already exists.
        DuplicateName = 3,
        /// Removed shared sets cannot be mutated.
        SharedSetRemoved = 4,
        /// The shared set cannot be removed because it is in use.
        SharedSetInUse = 5,
    }
    impl SharedSetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CustomerCannotCreateSharedSetOfThisType => {
                    "CUSTOMER_CANNOT_CREATE_SHARED_SET_OF_THIS_TYPE"
                }
                Self::DuplicateName => "DUPLICATE_NAME",
                Self::SharedSetRemoved => "SHARED_SET_REMOVED",
                Self::SharedSetInUse => "SHARED_SET_IN_USE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOMER_CANNOT_CREATE_SHARED_SET_OF_THIS_TYPE" => {
                    Some(Self::CustomerCannotCreateSharedSetOfThisType)
                }
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "SHARED_SET_REMOVED" => Some(Self::SharedSetRemoved),
                "SHARED_SET_IN_USE" => Some(Self::SharedSetInUse),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible size limit errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SizeLimitErrorEnum {}
/// Nested message and enum types in `SizeLimitErrorEnum`.
pub mod size_limit_error_enum {
    /// Enum describing possible size limit errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SizeLimitError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The number of entries in the request exceeds the system limit, or the
        /// contents of the operations exceed transaction limits due to their size
        /// or complexity. Try reducing the number of entries per request.
        RequestSizeLimitExceeded = 2,
        /// The number of entries in the response exceeds the system limit.
        ResponseSizeLimitExceeded = 3,
    }
    impl SizeLimitError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::RequestSizeLimitExceeded => "REQUEST_SIZE_LIMIT_EXCEEDED",
                Self::ResponseSizeLimitExceeded => "RESPONSE_SIZE_LIMIT_EXCEEDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "REQUEST_SIZE_LIMIT_EXCEEDED" => Some(Self::RequestSizeLimitExceeded),
                "RESPONSE_SIZE_LIMIT_EXCEEDED" => Some(Self::ResponseSizeLimitExceeded),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible Smart campaign errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SmartCampaignErrorEnum {}
/// Nested message and enum types in `SmartCampaignErrorEnum`.
pub mod smart_campaign_error_enum {
    /// Enum describing possible Smart campaign errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SmartCampaignError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The business location id is invalid.
        InvalidBusinessLocationId = 2,
        /// The SmartCampaignSetting resource is only applicable for campaigns
        /// with advertising channel type SMART.
        InvalidCampaign = 3,
        /// The business name or business location id is required.
        BusinessNameOrBusinessLocationIdMissing = 4,
        /// A Smart campaign suggestion request field is required.
        RequiredSuggestionFieldMissing = 5,
        /// A location list or proximity is required.
        GeoTargetsRequired = 6,
        /// The locale could not be determined.
        CannotDetermineSuggestionLocale = 7,
        /// The final URL could not be crawled.
        FinalUrlNotCrawlable = 8,
    }
    impl SmartCampaignError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidBusinessLocationId => "INVALID_BUSINESS_LOCATION_ID",
                Self::InvalidCampaign => "INVALID_CAMPAIGN",
                Self::BusinessNameOrBusinessLocationIdMissing => {
                    "BUSINESS_NAME_OR_BUSINESS_LOCATION_ID_MISSING"
                }
                Self::RequiredSuggestionFieldMissing => {
                    "REQUIRED_SUGGESTION_FIELD_MISSING"
                }
                Self::GeoTargetsRequired => "GEO_TARGETS_REQUIRED",
                Self::CannotDetermineSuggestionLocale => {
                    "CANNOT_DETERMINE_SUGGESTION_LOCALE"
                }
                Self::FinalUrlNotCrawlable => "FINAL_URL_NOT_CRAWLABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_BUSINESS_LOCATION_ID" => Some(Self::InvalidBusinessLocationId),
                "INVALID_CAMPAIGN" => Some(Self::InvalidCampaign),
                "BUSINESS_NAME_OR_BUSINESS_LOCATION_ID_MISSING" => {
                    Some(Self::BusinessNameOrBusinessLocationIdMissing)
                }
                "REQUIRED_SUGGESTION_FIELD_MISSING" => {
                    Some(Self::RequiredSuggestionFieldMissing)
                }
                "GEO_TARGETS_REQUIRED" => Some(Self::GeoTargetsRequired),
                "CANNOT_DETERMINE_SUGGESTION_LOCALE" => {
                    Some(Self::CannotDetermineSuggestionLocale)
                }
                "FINAL_URL_NOT_CRAWLABLE" => Some(Self::FinalUrlNotCrawlable),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible string format errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StringFormatErrorEnum {}
/// Nested message and enum types in `StringFormatErrorEnum`.
pub mod string_format_error_enum {
    /// Enum describing possible string format errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StringFormatError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The input string value contains disallowed characters.
        IllegalChars = 2,
        /// The input string value is invalid for the associated field.
        InvalidFormat = 3,
    }
    impl StringFormatError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::IllegalChars => "ILLEGAL_CHARS",
                Self::InvalidFormat => "INVALID_FORMAT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ILLEGAL_CHARS" => Some(Self::IllegalChars),
                "INVALID_FORMAT" => Some(Self::InvalidFormat),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible string length errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StringLengthErrorEnum {}
/// Nested message and enum types in `StringLengthErrorEnum`.
pub mod string_length_error_enum {
    /// Enum describing possible string length errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StringLengthError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The specified field should have a least one non-whitespace character in
        /// it.
        Empty = 4,
        /// Too short.
        TooShort = 2,
        /// Too long.
        TooLong = 3,
    }
    impl StringLengthError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Empty => "EMPTY",
                Self::TooShort => "TOO_SHORT",
                Self::TooLong => "TOO_LONG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EMPTY" => Some(Self::Empty),
                "TOO_SHORT" => Some(Self::TooShort),
                "TOO_LONG" => Some(Self::TooLong),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible third party app analytics link errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ThirdPartyAppAnalyticsLinkErrorEnum {}
/// Nested message and enum types in `ThirdPartyAppAnalyticsLinkErrorEnum`.
pub mod third_party_app_analytics_link_error_enum {
    /// Enum describing possible third party app analytics link errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ThirdPartyAppAnalyticsLinkError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The provided analytics provider ID is invalid.
        InvalidAnalyticsProviderId = 2,
        /// The provided mobile app ID is invalid.
        InvalidMobileAppId = 3,
        /// The mobile app corresponding to the provided app ID is not
        /// active/enabled.
        MobileAppIsNotEnabled = 4,
        /// Regenerating shareable link ID is only allowed on active links
        CannotRegenerateShareableLinkIdForRemovedLink = 5,
    }
    impl ThirdPartyAppAnalyticsLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidAnalyticsProviderId => "INVALID_ANALYTICS_PROVIDER_ID",
                Self::InvalidMobileAppId => "INVALID_MOBILE_APP_ID",
                Self::MobileAppIsNotEnabled => "MOBILE_APP_IS_NOT_ENABLED",
                Self::CannotRegenerateShareableLinkIdForRemovedLink => {
                    "CANNOT_REGENERATE_SHAREABLE_LINK_ID_FOR_REMOVED_LINK"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_ANALYTICS_PROVIDER_ID" => Some(Self::InvalidAnalyticsProviderId),
                "INVALID_MOBILE_APP_ID" => Some(Self::InvalidMobileAppId),
                "MOBILE_APP_IS_NOT_ENABLED" => Some(Self::MobileAppIsNotEnabled),
                "CANNOT_REGENERATE_SHAREABLE_LINK_ID_FOR_REMOVED_LINK" => {
                    Some(Self::CannotRegenerateShareableLinkIdForRemovedLink)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible time zone errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeZoneErrorEnum {}
/// Nested message and enum types in `TimeZoneErrorEnum`.
pub mod time_zone_error_enum {
    /// Enum describing possible currency code errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimeZoneError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Time zone is not valid.
        InvalidTimeZone = 5,
    }
    impl TimeZoneError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidTimeZone => "INVALID_TIME_ZONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_TIME_ZONE" => Some(Self::InvalidTimeZone),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible url field errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UrlFieldErrorEnum {}
/// Nested message and enum types in `UrlFieldErrorEnum`.
pub mod url_field_error_enum {
    /// Enum describing possible url field errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UrlFieldError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The tracking url template is invalid.
        InvalidTrackingUrlTemplate = 2,
        /// The tracking url template contains invalid tag.
        InvalidTagInTrackingUrlTemplate = 3,
        /// The tracking url template must contain at least one tag (for example,
        /// {lpurl}), This applies only to tracking url template associated with
        /// website ads or product ads.
        MissingTrackingUrlTemplateTag = 4,
        /// The tracking url template must start with a valid protocol (or lpurl
        /// tag).
        MissingProtocolInTrackingUrlTemplate = 5,
        /// The tracking url template starts with an invalid protocol.
        InvalidProtocolInTrackingUrlTemplate = 6,
        /// The tracking url template contains illegal characters.
        MalformedTrackingUrlTemplate = 7,
        /// The tracking url template must contain a host name (or lpurl tag).
        MissingHostInTrackingUrlTemplate = 8,
        /// The tracking url template has an invalid or missing top level domain
        /// extension.
        InvalidTldInTrackingUrlTemplate = 9,
        /// The tracking url template contains nested occurrences of the same
        /// conditional tag (for example, {ifmobile:{ifmobile:x}}).
        RedundantNestedTrackingUrlTemplateTag = 10,
        /// The final url is invalid.
        InvalidFinalUrl = 11,
        /// The final url contains invalid tag.
        InvalidTagInFinalUrl = 12,
        /// The final url contains nested occurrences of the same conditional tag
        /// (for example, {ifmobile:{ifmobile:x}}).
        RedundantNestedFinalUrlTag = 13,
        /// The final url must start with a valid protocol.
        MissingProtocolInFinalUrl = 14,
        /// The final url starts with an invalid protocol.
        InvalidProtocolInFinalUrl = 15,
        /// The final url contains illegal characters.
        MalformedFinalUrl = 16,
        /// The final url must contain a host name.
        MissingHostInFinalUrl = 17,
        /// The tracking url template has an invalid or missing top level domain
        /// extension.
        InvalidTldInFinalUrl = 18,
        /// The final mobile url is invalid.
        InvalidFinalMobileUrl = 19,
        /// The final mobile url contains invalid tag.
        InvalidTagInFinalMobileUrl = 20,
        /// The final mobile url contains nested occurrences of the same conditional
        /// tag (for example, {ifmobile:{ifmobile:x}}).
        RedundantNestedFinalMobileUrlTag = 21,
        /// The final mobile url must start with a valid protocol.
        MissingProtocolInFinalMobileUrl = 22,
        /// The final mobile url starts with an invalid protocol.
        InvalidProtocolInFinalMobileUrl = 23,
        /// The final mobile url contains illegal characters.
        MalformedFinalMobileUrl = 24,
        /// The final mobile url must contain a host name.
        MissingHostInFinalMobileUrl = 25,
        /// The tracking url template has an invalid or missing top level domain
        /// extension.
        InvalidTldInFinalMobileUrl = 26,
        /// The final app url is invalid.
        InvalidFinalAppUrl = 27,
        /// The final app url contains invalid tag.
        InvalidTagInFinalAppUrl = 28,
        /// The final app url contains nested occurrences of the same conditional tag
        /// (for example, {ifmobile:{ifmobile:x}}).
        RedundantNestedFinalAppUrlTag = 29,
        /// More than one app url found for the same OS type.
        MultipleAppUrlsForOstype = 30,
        /// The OS type given for an app url is not valid.
        InvalidOstype = 31,
        /// The protocol given for an app url is not valid. (For example,
        /// "android-app://")
        InvalidProtocolForAppUrl = 32,
        /// The package id (app id) given for an app url is not valid.
        InvalidPackageIdForAppUrl = 33,
        /// The number of url custom parameters for an resource exceeds the maximum
        /// limit allowed.
        UrlCustomParametersCountExceedsLimit = 34,
        /// An invalid character appears in the parameter key.
        InvalidCharactersInUrlCustomParameterKey = 39,
        /// An invalid character appears in the parameter value.
        InvalidCharactersInUrlCustomParameterValue = 40,
        /// The url custom parameter value fails url tag validation.
        InvalidTagInUrlCustomParameterValue = 41,
        /// The custom parameter contains nested occurrences of the same conditional
        /// tag (for example, {ifmobile:{ifmobile:x}}).
        RedundantNestedUrlCustomParameterTag = 42,
        /// The protocol (http:// or https://) is missing.
        MissingProtocol = 43,
        /// Unsupported protocol in URL. Only http and https are supported.
        InvalidProtocol = 52,
        /// The url is invalid.
        InvalidUrl = 44,
        /// Destination Url is deprecated.
        DestinationUrlDeprecated = 45,
        /// The url contains invalid tag.
        InvalidTagInUrl = 46,
        /// The url must contain at least one tag (for example, {lpurl}).
        MissingUrlTag = 47,
        /// Duplicate url id.
        DuplicateUrlId = 48,
        /// Invalid url id.
        InvalidUrlId = 49,
        /// The final url suffix cannot begin with '?' or '&' characters and must be
        /// a valid query string.
        FinalUrlSuffixMalformed = 50,
        /// The final url suffix cannot contain {lpurl} related or {ignore} tags.
        InvalidTagInFinalUrlSuffix = 51,
        /// The top level domain is invalid, for example, not a public top level
        /// domain listed in publicsuffix.org.
        InvalidTopLevelDomain = 53,
        /// Malformed top level domain in URL.
        MalformedTopLevelDomain = 54,
        /// Malformed URL.
        MalformedUrl = 55,
        /// No host found in URL.
        MissingHost = 56,
        /// Custom parameter value cannot be null.
        NullCustomParameterValue = 57,
        /// Track parameter is not supported.
        ValueTrackParameterNotSupported = 58,
    }
    impl UrlFieldError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidTrackingUrlTemplate => "INVALID_TRACKING_URL_TEMPLATE",
                Self::InvalidTagInTrackingUrlTemplate => {
                    "INVALID_TAG_IN_TRACKING_URL_TEMPLATE"
                }
                Self::MissingTrackingUrlTemplateTag => {
                    "MISSING_TRACKING_URL_TEMPLATE_TAG"
                }
                Self::MissingProtocolInTrackingUrlTemplate => {
                    "MISSING_PROTOCOL_IN_TRACKING_URL_TEMPLATE"
                }
                Self::InvalidProtocolInTrackingUrlTemplate => {
                    "INVALID_PROTOCOL_IN_TRACKING_URL_TEMPLATE"
                }
                Self::MalformedTrackingUrlTemplate => "MALFORMED_TRACKING_URL_TEMPLATE",
                Self::MissingHostInTrackingUrlTemplate => {
                    "MISSING_HOST_IN_TRACKING_URL_TEMPLATE"
                }
                Self::InvalidTldInTrackingUrlTemplate => {
                    "INVALID_TLD_IN_TRACKING_URL_TEMPLATE"
                }
                Self::RedundantNestedTrackingUrlTemplateTag => {
                    "REDUNDANT_NESTED_TRACKING_URL_TEMPLATE_TAG"
                }
                Self::InvalidFinalUrl => "INVALID_FINAL_URL",
                Self::InvalidTagInFinalUrl => "INVALID_TAG_IN_FINAL_URL",
                Self::RedundantNestedFinalUrlTag => "REDUNDANT_NESTED_FINAL_URL_TAG",
                Self::MissingProtocolInFinalUrl => "MISSING_PROTOCOL_IN_FINAL_URL",
                Self::InvalidProtocolInFinalUrl => "INVALID_PROTOCOL_IN_FINAL_URL",
                Self::MalformedFinalUrl => "MALFORMED_FINAL_URL",
                Self::MissingHostInFinalUrl => "MISSING_HOST_IN_FINAL_URL",
                Self::InvalidTldInFinalUrl => "INVALID_TLD_IN_FINAL_URL",
                Self::InvalidFinalMobileUrl => "INVALID_FINAL_MOBILE_URL",
                Self::InvalidTagInFinalMobileUrl => "INVALID_TAG_IN_FINAL_MOBILE_URL",
                Self::RedundantNestedFinalMobileUrlTag => {
                    "REDUNDANT_NESTED_FINAL_MOBILE_URL_TAG"
                }
                Self::MissingProtocolInFinalMobileUrl => {
                    "MISSING_PROTOCOL_IN_FINAL_MOBILE_URL"
                }
                Self::InvalidProtocolInFinalMobileUrl => {
                    "INVALID_PROTOCOL_IN_FINAL_MOBILE_URL"
                }
                Self::MalformedFinalMobileUrl => "MALFORMED_FINAL_MOBILE_URL",
                Self::MissingHostInFinalMobileUrl => "MISSING_HOST_IN_FINAL_MOBILE_URL",
                Self::InvalidTldInFinalMobileUrl => "INVALID_TLD_IN_FINAL_MOBILE_URL",
                Self::InvalidFinalAppUrl => "INVALID_FINAL_APP_URL",
                Self::InvalidTagInFinalAppUrl => "INVALID_TAG_IN_FINAL_APP_URL",
                Self::RedundantNestedFinalAppUrlTag => {
                    "REDUNDANT_NESTED_FINAL_APP_URL_TAG"
                }
                Self::MultipleAppUrlsForOstype => "MULTIPLE_APP_URLS_FOR_OSTYPE",
                Self::InvalidOstype => "INVALID_OSTYPE",
                Self::InvalidProtocolForAppUrl => "INVALID_PROTOCOL_FOR_APP_URL",
                Self::InvalidPackageIdForAppUrl => "INVALID_PACKAGE_ID_FOR_APP_URL",
                Self::UrlCustomParametersCountExceedsLimit => {
                    "URL_CUSTOM_PARAMETERS_COUNT_EXCEEDS_LIMIT"
                }
                Self::InvalidCharactersInUrlCustomParameterKey => {
                    "INVALID_CHARACTERS_IN_URL_CUSTOM_PARAMETER_KEY"
                }
                Self::InvalidCharactersInUrlCustomParameterValue => {
                    "INVALID_CHARACTERS_IN_URL_CUSTOM_PARAMETER_VALUE"
                }
                Self::InvalidTagInUrlCustomParameterValue => {
                    "INVALID_TAG_IN_URL_CUSTOM_PARAMETER_VALUE"
                }
                Self::RedundantNestedUrlCustomParameterTag => {
                    "REDUNDANT_NESTED_URL_CUSTOM_PARAMETER_TAG"
                }
                Self::MissingProtocol => "MISSING_PROTOCOL",
                Self::InvalidProtocol => "INVALID_PROTOCOL",
                Self::InvalidUrl => "INVALID_URL",
                Self::DestinationUrlDeprecated => "DESTINATION_URL_DEPRECATED",
                Self::InvalidTagInUrl => "INVALID_TAG_IN_URL",
                Self::MissingUrlTag => "MISSING_URL_TAG",
                Self::DuplicateUrlId => "DUPLICATE_URL_ID",
                Self::InvalidUrlId => "INVALID_URL_ID",
                Self::FinalUrlSuffixMalformed => "FINAL_URL_SUFFIX_MALFORMED",
                Self::InvalidTagInFinalUrlSuffix => "INVALID_TAG_IN_FINAL_URL_SUFFIX",
                Self::InvalidTopLevelDomain => "INVALID_TOP_LEVEL_DOMAIN",
                Self::MalformedTopLevelDomain => "MALFORMED_TOP_LEVEL_DOMAIN",
                Self::MalformedUrl => "MALFORMED_URL",
                Self::MissingHost => "MISSING_HOST",
                Self::NullCustomParameterValue => "NULL_CUSTOM_PARAMETER_VALUE",
                Self::ValueTrackParameterNotSupported => {
                    "VALUE_TRACK_PARAMETER_NOT_SUPPORTED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_TRACKING_URL_TEMPLATE" => Some(Self::InvalidTrackingUrlTemplate),
                "INVALID_TAG_IN_TRACKING_URL_TEMPLATE" => {
                    Some(Self::InvalidTagInTrackingUrlTemplate)
                }
                "MISSING_TRACKING_URL_TEMPLATE_TAG" => {
                    Some(Self::MissingTrackingUrlTemplateTag)
                }
                "MISSING_PROTOCOL_IN_TRACKING_URL_TEMPLATE" => {
                    Some(Self::MissingProtocolInTrackingUrlTemplate)
                }
                "INVALID_PROTOCOL_IN_TRACKING_URL_TEMPLATE" => {
                    Some(Self::InvalidProtocolInTrackingUrlTemplate)
                }
                "MALFORMED_TRACKING_URL_TEMPLATE" => {
                    Some(Self::MalformedTrackingUrlTemplate)
                }
                "MISSING_HOST_IN_TRACKING_URL_TEMPLATE" => {
                    Some(Self::MissingHostInTrackingUrlTemplate)
                }
                "INVALID_TLD_IN_TRACKING_URL_TEMPLATE" => {
                    Some(Self::InvalidTldInTrackingUrlTemplate)
                }
                "REDUNDANT_NESTED_TRACKING_URL_TEMPLATE_TAG" => {
                    Some(Self::RedundantNestedTrackingUrlTemplateTag)
                }
                "INVALID_FINAL_URL" => Some(Self::InvalidFinalUrl),
                "INVALID_TAG_IN_FINAL_URL" => Some(Self::InvalidTagInFinalUrl),
                "REDUNDANT_NESTED_FINAL_URL_TAG" => {
                    Some(Self::RedundantNestedFinalUrlTag)
                }
                "MISSING_PROTOCOL_IN_FINAL_URL" => Some(Self::MissingProtocolInFinalUrl),
                "INVALID_PROTOCOL_IN_FINAL_URL" => Some(Self::InvalidProtocolInFinalUrl),
                "MALFORMED_FINAL_URL" => Some(Self::MalformedFinalUrl),
                "MISSING_HOST_IN_FINAL_URL" => Some(Self::MissingHostInFinalUrl),
                "INVALID_TLD_IN_FINAL_URL" => Some(Self::InvalidTldInFinalUrl),
                "INVALID_FINAL_MOBILE_URL" => Some(Self::InvalidFinalMobileUrl),
                "INVALID_TAG_IN_FINAL_MOBILE_URL" => {
                    Some(Self::InvalidTagInFinalMobileUrl)
                }
                "REDUNDANT_NESTED_FINAL_MOBILE_URL_TAG" => {
                    Some(Self::RedundantNestedFinalMobileUrlTag)
                }
                "MISSING_PROTOCOL_IN_FINAL_MOBILE_URL" => {
                    Some(Self::MissingProtocolInFinalMobileUrl)
                }
                "INVALID_PROTOCOL_IN_FINAL_MOBILE_URL" => {
                    Some(Self::InvalidProtocolInFinalMobileUrl)
                }
                "MALFORMED_FINAL_MOBILE_URL" => Some(Self::MalformedFinalMobileUrl),
                "MISSING_HOST_IN_FINAL_MOBILE_URL" => {
                    Some(Self::MissingHostInFinalMobileUrl)
                }
                "INVALID_TLD_IN_FINAL_MOBILE_URL" => {
                    Some(Self::InvalidTldInFinalMobileUrl)
                }
                "INVALID_FINAL_APP_URL" => Some(Self::InvalidFinalAppUrl),
                "INVALID_TAG_IN_FINAL_APP_URL" => Some(Self::InvalidTagInFinalAppUrl),
                "REDUNDANT_NESTED_FINAL_APP_URL_TAG" => {
                    Some(Self::RedundantNestedFinalAppUrlTag)
                }
                "MULTIPLE_APP_URLS_FOR_OSTYPE" => Some(Self::MultipleAppUrlsForOstype),
                "INVALID_OSTYPE" => Some(Self::InvalidOstype),
                "INVALID_PROTOCOL_FOR_APP_URL" => Some(Self::InvalidProtocolForAppUrl),
                "INVALID_PACKAGE_ID_FOR_APP_URL" => Some(Self::InvalidPackageIdForAppUrl),
                "URL_CUSTOM_PARAMETERS_COUNT_EXCEEDS_LIMIT" => {
                    Some(Self::UrlCustomParametersCountExceedsLimit)
                }
                "INVALID_CHARACTERS_IN_URL_CUSTOM_PARAMETER_KEY" => {
                    Some(Self::InvalidCharactersInUrlCustomParameterKey)
                }
                "INVALID_CHARACTERS_IN_URL_CUSTOM_PARAMETER_VALUE" => {
                    Some(Self::InvalidCharactersInUrlCustomParameterValue)
                }
                "INVALID_TAG_IN_URL_CUSTOM_PARAMETER_VALUE" => {
                    Some(Self::InvalidTagInUrlCustomParameterValue)
                }
                "REDUNDANT_NESTED_URL_CUSTOM_PARAMETER_TAG" => {
                    Some(Self::RedundantNestedUrlCustomParameterTag)
                }
                "MISSING_PROTOCOL" => Some(Self::MissingProtocol),
                "INVALID_PROTOCOL" => Some(Self::InvalidProtocol),
                "INVALID_URL" => Some(Self::InvalidUrl),
                "DESTINATION_URL_DEPRECATED" => Some(Self::DestinationUrlDeprecated),
                "INVALID_TAG_IN_URL" => Some(Self::InvalidTagInUrl),
                "MISSING_URL_TAG" => Some(Self::MissingUrlTag),
                "DUPLICATE_URL_ID" => Some(Self::DuplicateUrlId),
                "INVALID_URL_ID" => Some(Self::InvalidUrlId),
                "FINAL_URL_SUFFIX_MALFORMED" => Some(Self::FinalUrlSuffixMalformed),
                "INVALID_TAG_IN_FINAL_URL_SUFFIX" => {
                    Some(Self::InvalidTagInFinalUrlSuffix)
                }
                "INVALID_TOP_LEVEL_DOMAIN" => Some(Self::InvalidTopLevelDomain),
                "MALFORMED_TOP_LEVEL_DOMAIN" => Some(Self::MalformedTopLevelDomain),
                "MALFORMED_URL" => Some(Self::MalformedUrl),
                "MISSING_HOST" => Some(Self::MissingHost),
                "NULL_CUSTOM_PARAMETER_VALUE" => Some(Self::NullCustomParameterValue),
                "VALUE_TRACK_PARAMETER_NOT_SUPPORTED" => {
                    Some(Self::ValueTrackParameterNotSupported)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible user data errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserDataErrorEnum {}
/// Nested message and enum types in `UserDataErrorEnum`.
pub mod user_data_error_enum {
    /// Enum describing possible request errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserDataError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Customer is not allowed to perform operations related to Customer Match.
        OperationsForCustomerMatchNotAllowed = 2,
        /// Maximum number of user identifiers allowed for each request is 100 and
        /// for each operation is 20.
        TooManyUserIdentifiers = 3,
        /// Current user list is not applicable for the given customer.
        UserListNotApplicable = 4,
    }
    impl UserDataError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::OperationsForCustomerMatchNotAllowed => {
                    "OPERATIONS_FOR_CUSTOMER_MATCH_NOT_ALLOWED"
                }
                Self::TooManyUserIdentifiers => "TOO_MANY_USER_IDENTIFIERS",
                Self::UserListNotApplicable => "USER_LIST_NOT_APPLICABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPERATIONS_FOR_CUSTOMER_MATCH_NOT_ALLOWED" => {
                    Some(Self::OperationsForCustomerMatchNotAllowed)
                }
                "TOO_MANY_USER_IDENTIFIERS" => Some(Self::TooManyUserIdentifiers),
                "USER_LIST_NOT_APPLICABLE" => Some(Self::UserListNotApplicable),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible user list errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListErrorEnum {}
/// Nested message and enum types in `UserListErrorEnum`.
pub mod user_list_error_enum {
    /// Enum describing possible user list errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Creating and updating external remarketing user lists is not supported.
        ExternalRemarketingUserListMutateNotSupported = 2,
        /// Concrete type of user list is required.
        ConcreteTypeRequired = 3,
        /// Creating/updating user list conversion types requires specifying the
        /// conversion type Id.
        ConversionTypeIdRequired = 4,
        /// Remarketing user list cannot have duplicate conversion types.
        DuplicateConversionTypes = 5,
        /// Conversion type is invalid/unknown.
        InvalidConversionType = 6,
        /// User list description is empty or invalid.
        InvalidDescription = 7,
        /// User list name is empty or invalid.
        InvalidName = 8,
        /// Type of the UserList does not match.
        InvalidType = 9,
        /// Embedded logical user lists are not allowed.
        CanNotAddLogicalListAsLogicalListOperand = 10,
        /// User list rule operand is invalid.
        InvalidUserListLogicalRuleOperand = 11,
        /// Name is already being used for another user list for the account.
        NameAlreadyUsed = 12,
        /// Name is required when creating a new conversion type.
        NewConversionTypeNameRequired = 13,
        /// The given conversion type name has been used.
        ConversionTypeNameAlreadyUsed = 14,
        /// Only an owner account may edit a user list.
        OwnershipRequiredForSet = 15,
        /// Creating user list without setting type in oneof user_list field, or
        /// creating/updating read-only user list types is not allowed.
        UserListMutateNotSupported = 16,
        /// Rule is invalid.
        InvalidRule = 17,
        /// The specified date range is empty.
        InvalidDateRange = 27,
        /// A UserList which is privacy sensitive or legal rejected cannot be mutated
        /// by external users.
        CanNotMutateSensitiveUserlist = 28,
        /// Maximum number of rulebased user lists a customer can have.
        MaxNumRulebasedUserlists = 29,
        /// BasicUserList's billable record field cannot be modified once it is set.
        CannotModifyBillableRecordCount = 30,
        /// crm_based_user_list.app_id field must be set when upload_key_type is
        /// MOBILE_ADVERTISING_ID.
        AppIdNotSet = 31,
        /// Name of the user list is reserved for system generated lists and cannot
        /// be used.
        UserlistNameIsReservedForSystemList = 32,
        /// Advertiser needs to be on the allow-list to use remarketing lists created
        /// from advertiser uploaded data (for example, Customer Match lists).
        AdvertiserNotOnAllowlistForUsingUploadedData = 37,
        /// The provided rule_type is not supported for the user list.
        RuleTypeIsNotSupported = 34,
        /// Similar user list cannot be used as a logical user list operand.
        CanNotAddASimilarUserlistAsLogicalListOperand = 35,
        /// Logical user list should not have a mix of CRM based user list and other
        /// types of lists in its rules.
        CanNotMixCrmBasedInLogicalListWithOtherLists = 36,
        /// crm_based_user_list.app_id field can only be set when upload_key_type is
        /// MOBILE_ADVERTISING_ID.
        AppIdNotAllowed = 39,
        /// Google system generated user lists cannot be mutated.
        CannotMutateSystemList = 40,
        /// The mobile app associated with the remarketing list is sensitive.
        MobileAppIsSensitive = 41,
        /// One or more given seed lists do not exist.
        SeedListDoesNotExist = 42,
        /// One or more given seed lists are not accessible to the current user.
        InvalidSeedListAccessReason = 43,
        /// One or more given seed lists have an unsupported type.
        InvalidSeedListType = 44,
        /// One or more invalid country codes are added to Lookalike UserList.
        InvalidCountryCodes = 45,
    }
    impl UserListError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ExternalRemarketingUserListMutateNotSupported => {
                    "EXTERNAL_REMARKETING_USER_LIST_MUTATE_NOT_SUPPORTED"
                }
                Self::ConcreteTypeRequired => "CONCRETE_TYPE_REQUIRED",
                Self::ConversionTypeIdRequired => "CONVERSION_TYPE_ID_REQUIRED",
                Self::DuplicateConversionTypes => "DUPLICATE_CONVERSION_TYPES",
                Self::InvalidConversionType => "INVALID_CONVERSION_TYPE",
                Self::InvalidDescription => "INVALID_DESCRIPTION",
                Self::InvalidName => "INVALID_NAME",
                Self::InvalidType => "INVALID_TYPE",
                Self::CanNotAddLogicalListAsLogicalListOperand => {
                    "CAN_NOT_ADD_LOGICAL_LIST_AS_LOGICAL_LIST_OPERAND"
                }
                Self::InvalidUserListLogicalRuleOperand => {
                    "INVALID_USER_LIST_LOGICAL_RULE_OPERAND"
                }
                Self::NameAlreadyUsed => "NAME_ALREADY_USED",
                Self::NewConversionTypeNameRequired => {
                    "NEW_CONVERSION_TYPE_NAME_REQUIRED"
                }
                Self::ConversionTypeNameAlreadyUsed => {
                    "CONVERSION_TYPE_NAME_ALREADY_USED"
                }
                Self::OwnershipRequiredForSet => "OWNERSHIP_REQUIRED_FOR_SET",
                Self::UserListMutateNotSupported => "USER_LIST_MUTATE_NOT_SUPPORTED",
                Self::InvalidRule => "INVALID_RULE",
                Self::InvalidDateRange => "INVALID_DATE_RANGE",
                Self::CanNotMutateSensitiveUserlist => {
                    "CAN_NOT_MUTATE_SENSITIVE_USERLIST"
                }
                Self::MaxNumRulebasedUserlists => "MAX_NUM_RULEBASED_USERLISTS",
                Self::CannotModifyBillableRecordCount => {
                    "CANNOT_MODIFY_BILLABLE_RECORD_COUNT"
                }
                Self::AppIdNotSet => "APP_ID_NOT_SET",
                Self::UserlistNameIsReservedForSystemList => {
                    "USERLIST_NAME_IS_RESERVED_FOR_SYSTEM_LIST"
                }
                Self::AdvertiserNotOnAllowlistForUsingUploadedData => {
                    "ADVERTISER_NOT_ON_ALLOWLIST_FOR_USING_UPLOADED_DATA"
                }
                Self::RuleTypeIsNotSupported => "RULE_TYPE_IS_NOT_SUPPORTED",
                Self::CanNotAddASimilarUserlistAsLogicalListOperand => {
                    "CAN_NOT_ADD_A_SIMILAR_USERLIST_AS_LOGICAL_LIST_OPERAND"
                }
                Self::CanNotMixCrmBasedInLogicalListWithOtherLists => {
                    "CAN_NOT_MIX_CRM_BASED_IN_LOGICAL_LIST_WITH_OTHER_LISTS"
                }
                Self::AppIdNotAllowed => "APP_ID_NOT_ALLOWED",
                Self::CannotMutateSystemList => "CANNOT_MUTATE_SYSTEM_LIST",
                Self::MobileAppIsSensitive => "MOBILE_APP_IS_SENSITIVE",
                Self::SeedListDoesNotExist => "SEED_LIST_DOES_NOT_EXIST",
                Self::InvalidSeedListAccessReason => "INVALID_SEED_LIST_ACCESS_REASON",
                Self::InvalidSeedListType => "INVALID_SEED_LIST_TYPE",
                Self::InvalidCountryCodes => "INVALID_COUNTRY_CODES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXTERNAL_REMARKETING_USER_LIST_MUTATE_NOT_SUPPORTED" => {
                    Some(Self::ExternalRemarketingUserListMutateNotSupported)
                }
                "CONCRETE_TYPE_REQUIRED" => Some(Self::ConcreteTypeRequired),
                "CONVERSION_TYPE_ID_REQUIRED" => Some(Self::ConversionTypeIdRequired),
                "DUPLICATE_CONVERSION_TYPES" => Some(Self::DuplicateConversionTypes),
                "INVALID_CONVERSION_TYPE" => Some(Self::InvalidConversionType),
                "INVALID_DESCRIPTION" => Some(Self::InvalidDescription),
                "INVALID_NAME" => Some(Self::InvalidName),
                "INVALID_TYPE" => Some(Self::InvalidType),
                "CAN_NOT_ADD_LOGICAL_LIST_AS_LOGICAL_LIST_OPERAND" => {
                    Some(Self::CanNotAddLogicalListAsLogicalListOperand)
                }
                "INVALID_USER_LIST_LOGICAL_RULE_OPERAND" => {
                    Some(Self::InvalidUserListLogicalRuleOperand)
                }
                "NAME_ALREADY_USED" => Some(Self::NameAlreadyUsed),
                "NEW_CONVERSION_TYPE_NAME_REQUIRED" => {
                    Some(Self::NewConversionTypeNameRequired)
                }
                "CONVERSION_TYPE_NAME_ALREADY_USED" => {
                    Some(Self::ConversionTypeNameAlreadyUsed)
                }
                "OWNERSHIP_REQUIRED_FOR_SET" => Some(Self::OwnershipRequiredForSet),
                "USER_LIST_MUTATE_NOT_SUPPORTED" => {
                    Some(Self::UserListMutateNotSupported)
                }
                "INVALID_RULE" => Some(Self::InvalidRule),
                "INVALID_DATE_RANGE" => Some(Self::InvalidDateRange),
                "CAN_NOT_MUTATE_SENSITIVE_USERLIST" => {
                    Some(Self::CanNotMutateSensitiveUserlist)
                }
                "MAX_NUM_RULEBASED_USERLISTS" => Some(Self::MaxNumRulebasedUserlists),
                "CANNOT_MODIFY_BILLABLE_RECORD_COUNT" => {
                    Some(Self::CannotModifyBillableRecordCount)
                }
                "APP_ID_NOT_SET" => Some(Self::AppIdNotSet),
                "USERLIST_NAME_IS_RESERVED_FOR_SYSTEM_LIST" => {
                    Some(Self::UserlistNameIsReservedForSystemList)
                }
                "ADVERTISER_NOT_ON_ALLOWLIST_FOR_USING_UPLOADED_DATA" => {
                    Some(Self::AdvertiserNotOnAllowlistForUsingUploadedData)
                }
                "RULE_TYPE_IS_NOT_SUPPORTED" => Some(Self::RuleTypeIsNotSupported),
                "CAN_NOT_ADD_A_SIMILAR_USERLIST_AS_LOGICAL_LIST_OPERAND" => {
                    Some(Self::CanNotAddASimilarUserlistAsLogicalListOperand)
                }
                "CAN_NOT_MIX_CRM_BASED_IN_LOGICAL_LIST_WITH_OTHER_LISTS" => {
                    Some(Self::CanNotMixCrmBasedInLogicalListWithOtherLists)
                }
                "APP_ID_NOT_ALLOWED" => Some(Self::AppIdNotAllowed),
                "CANNOT_MUTATE_SYSTEM_LIST" => Some(Self::CannotMutateSystemList),
                "MOBILE_APP_IS_SENSITIVE" => Some(Self::MobileAppIsSensitive),
                "SEED_LIST_DOES_NOT_EXIST" => Some(Self::SeedListDoesNotExist),
                "INVALID_SEED_LIST_ACCESS_REASON" => {
                    Some(Self::InvalidSeedListAccessReason)
                }
                "INVALID_SEED_LIST_TYPE" => Some(Self::InvalidSeedListType),
                "INVALID_COUNTRY_CODES" => Some(Self::InvalidCountryCodes),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible video campaign errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VideoCampaignErrorEnum {}
/// Nested message and enum types in `VideoCampaignErrorEnum`.
pub mod video_campaign_error_enum {
    /// Enum describing possible video campaign errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VideoCampaignError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Cannot modify the video campaign without reservation.
        /// See <https://support.google.com/google-ads/answer/9547606.>
        MutateRequiresReservation = 2,
    }
    impl VideoCampaignError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::MutateRequiresReservation => "MUTATE_REQUIRES_RESERVATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MUTATE_REQUIRES_RESERVATION" => Some(Self::MutateRequiresReservation),
                _ => None,
            }
        }
    }
}
/// Container for enum describing YouTube video registration errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct YoutubeVideoRegistrationErrorEnum {}
/// Nested message and enum types in `YoutubeVideoRegistrationErrorEnum`.
pub mod youtube_video_registration_error_enum {
    /// Enum describing YouTube video registration errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum YoutubeVideoRegistrationError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Video to be registered wasn't found.
        VideoNotFound = 2,
        /// Video to be registered is not accessible (for example, private).
        VideoNotAccessible = 3,
        /// Video to be registered is not eligible (for example, mature content).
        VideoNotEligible = 4,
    }
    impl YoutubeVideoRegistrationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::VideoNotFound => "VIDEO_NOT_FOUND",
                Self::VideoNotAccessible => "VIDEO_NOT_ACCESSIBLE",
                Self::VideoNotEligible => "VIDEO_NOT_ELIGIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "VIDEO_NOT_FOUND" => Some(Self::VideoNotFound),
                "VIDEO_NOT_ACCESSIBLE" => Some(Self::VideoNotAccessible),
                "VIDEO_NOT_ELIGIBLE" => Some(Self::VideoNotEligible),
                _ => None,
            }
        }
    }
}
/// Describes how a GoogleAds API call failed. It's returned inside
/// google.rpc.Status.details when a call fails.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleAdsFailure {
    /// The list of errors that occurred.
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<GoogleAdsError>,
    /// The unique ID of the request that is used for debugging purposes.
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// GoogleAds-specific error.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleAdsError {
    /// An enum value that indicates which error occurred.
    #[prost(message, optional, tag = "1")]
    pub error_code: ::core::option::Option<ErrorCode>,
    /// A human-readable description of the error.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// The value that triggered the error.
    #[prost(message, optional, tag = "3")]
    pub trigger: ::core::option::Option<super::common::Value>,
    /// Describes the part of the request proto that caused the error.
    #[prost(message, optional, tag = "4")]
    pub location: ::core::option::Option<ErrorLocation>,
    /// Additional error details, which are returned by certain error codes. Most
    /// error codes do not include details.
    #[prost(message, optional, tag = "5")]
    pub details: ::core::option::Option<ErrorDetails>,
}
/// The error reason represented by type and enum.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ErrorCode {
    /// The list of error enums
    #[prost(
        oneof = "error_code::ErrorCode",
        tags = "1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 182, 17, 161, 18, 159, 19, 21, 24, 25, 107, 149, 155, 148, 153, 154, 152, 26, 29, 166, 160, 31, 165, 109, 32, 150, 158, 90, 151, 33, 34, 35, 36, 37, 38, 39, 40, 110, 42, 116, 86, 162, 44, 45, 46, 47, 48, 49, 58, 180, 51, 52, 53, 54, 55, 56, 57, 117, 59, 60, 61, 62, 63, 64, 65, 115, 143, 111, 145, 146, 66, 67, 68, 70, 71, 72, 132, 74, 133, 76, 77, 78, 136, 79, 80, 81, 82, 83, 84, 87, 88, 91, 92, 93, 94, 96, 97, 98, 100, 101, 102, 103, 140, 141, 104, 105, 112, 114, 118, 119, 137, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 134, 135, 138, 139, 164, 174, 147, 156, 167, 169, 170, 171, 176, 177, 178, 179, 181"
    )]
    pub error_code: ::core::option::Option<error_code::ErrorCode>,
}
/// Nested message and enum types in `ErrorCode`.
pub mod error_code {
    /// The list of error enums
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ErrorCode {
        /// An error caused by the request
        #[prost(enumeration = "super::request_error_enum::RequestError", tag = "1")]
        RequestError(i32),
        /// An error with a Bidding Strategy mutate.
        #[prost(
            enumeration = "super::bidding_strategy_error_enum::BiddingStrategyError",
            tag = "2"
        )]
        BiddingStrategyError(i32),
        /// An error with a URL field mutate.
        #[prost(enumeration = "super::url_field_error_enum::UrlFieldError", tag = "3")]
        UrlFieldError(i32),
        /// An error with a list operation.
        #[prost(
            enumeration = "super::list_operation_error_enum::ListOperationError",
            tag = "4"
        )]
        ListOperationError(i32),
        /// An error with an AWQL query
        #[prost(enumeration = "super::query_error_enum::QueryError", tag = "5")]
        QueryError(i32),
        /// An error with a mutate
        #[prost(enumeration = "super::mutate_error_enum::MutateError", tag = "7")]
        MutateError(i32),
        /// An error with a field mask
        #[prost(enumeration = "super::field_mask_error_enum::FieldMaskError", tag = "8")]
        FieldMaskError(i32),
        /// An error encountered when trying to authorize a user.
        #[prost(
            enumeration = "super::authorization_error_enum::AuthorizationError",
            tag = "9"
        )]
        AuthorizationError(i32),
        /// An unexpected server-side error.
        #[prost(enumeration = "super::internal_error_enum::InternalError", tag = "10")]
        InternalError(i32),
        /// An error with the amount of quota remaining.
        #[prost(enumeration = "super::quota_error_enum::QuotaError", tag = "11")]
        QuotaError(i32),
        /// An error with an Ad Group Ad mutate.
        #[prost(enumeration = "super::ad_error_enum::AdError", tag = "12")]
        AdError(i32),
        /// An error with an Ad Group mutate.
        #[prost(enumeration = "super::ad_group_error_enum::AdGroupError", tag = "13")]
        AdGroupError(i32),
        /// An error with a Campaign Budget mutate.
        #[prost(
            enumeration = "super::campaign_budget_error_enum::CampaignBudgetError",
            tag = "14"
        )]
        CampaignBudgetError(i32),
        /// An error with a Campaign mutate.
        #[prost(enumeration = "super::campaign_error_enum::CampaignError", tag = "15")]
        CampaignError(i32),
        /// An error with a Video Campaign mutate.
        #[prost(
            enumeration = "super::video_campaign_error_enum::VideoCampaignError",
            tag = "182"
        )]
        VideoCampaignError(i32),
        /// Indicates failure to properly authenticate user.
        #[prost(
            enumeration = "super::authentication_error_enum::AuthenticationError",
            tag = "17"
        )]
        AuthenticationError(i32),
        /// The reasons for the ad group criterion customizer error.
        #[prost(
            enumeration = "super::ad_group_criterion_customizer_error_enum::AdGroupCriterionCustomizerError",
            tag = "161"
        )]
        AdGroupCriterionCustomizerError(i32),
        /// Indicates failure to properly authenticate user.
        #[prost(
            enumeration = "super::ad_group_criterion_error_enum::AdGroupCriterionError",
            tag = "18"
        )]
        AdGroupCriterionError(i32),
        /// The reasons for the ad group customizer error.
        #[prost(
            enumeration = "super::ad_group_customizer_error_enum::AdGroupCustomizerError",
            tag = "159"
        )]
        AdGroupCustomizerError(i32),
        /// The reasons for the ad customizer error
        #[prost(
            enumeration = "super::ad_customizer_error_enum::AdCustomizerError",
            tag = "19"
        )]
        AdCustomizerError(i32),
        /// The reasons for the ad group ad error
        #[prost(
            enumeration = "super::ad_group_ad_error_enum::AdGroupAdError",
            tag = "21"
        )]
        AdGroupAdError(i32),
        /// The reasons for the ad sharing error
        #[prost(
            enumeration = "super::ad_sharing_error_enum::AdSharingError",
            tag = "24"
        )]
        AdSharingError(i32),
        /// The reasons for the adx error
        #[prost(enumeration = "super::adx_error_enum::AdxError", tag = "25")]
        AdxError(i32),
        /// The reasons for the asset error
        #[prost(enumeration = "super::asset_error_enum::AssetError", tag = "107")]
        AssetError(i32),
        /// The reasons for the asset group asset error
        #[prost(
            enumeration = "super::asset_group_asset_error_enum::AssetGroupAssetError",
            tag = "149"
        )]
        AssetGroupAssetError(i32),
        /// The reasons for the asset group listing group filter error
        #[prost(
            enumeration = "super::asset_group_listing_group_filter_error_enum::AssetGroupListingGroupFilterError",
            tag = "155"
        )]
        AssetGroupListingGroupFilterError(i32),
        /// The reasons for the asset group error
        #[prost(
            enumeration = "super::asset_group_error_enum::AssetGroupError",
            tag = "148"
        )]
        AssetGroupError(i32),
        /// The reasons for the asset set asset error
        #[prost(
            enumeration = "super::asset_set_asset_error_enum::AssetSetAssetError",
            tag = "153"
        )]
        AssetSetAssetError(i32),
        /// The reasons for the asset set link error
        #[prost(
            enumeration = "super::asset_set_link_error_enum::AssetSetLinkError",
            tag = "154"
        )]
        AssetSetLinkError(i32),
        /// The reasons for the asset set error
        #[prost(enumeration = "super::asset_set_error_enum::AssetSetError", tag = "152")]
        AssetSetError(i32),
        /// The reasons for the bidding errors
        #[prost(enumeration = "super::bidding_error_enum::BiddingError", tag = "26")]
        BiddingError(i32),
        /// The reasons for the campaign criterion error
        #[prost(
            enumeration = "super::campaign_criterion_error_enum::CampaignCriterionError",
            tag = "29"
        )]
        CampaignCriterionError(i32),
        /// The reasons for the campaign conversion goal error
        #[prost(
            enumeration = "super::campaign_conversion_goal_error_enum::CampaignConversionGoalError",
            tag = "166"
        )]
        CampaignConversionGoalError(i32),
        /// The reasons for the campaign customizer error.
        #[prost(
            enumeration = "super::campaign_customizer_error_enum::CampaignCustomizerError",
            tag = "160"
        )]
        CampaignCustomizerError(i32),
        /// The reasons for the collection size error
        #[prost(
            enumeration = "super::collection_size_error_enum::CollectionSizeError",
            tag = "31"
        )]
        CollectionSizeError(i32),
        /// The reasons for the conversion goal campaign config error
        #[prost(
            enumeration = "super::conversion_goal_campaign_config_error_enum::ConversionGoalCampaignConfigError",
            tag = "165"
        )]
        ConversionGoalCampaignConfigError(i32),
        /// The reasons for the country code error
        #[prost(
            enumeration = "super::country_code_error_enum::CountryCodeError",
            tag = "109"
        )]
        CountryCodeError(i32),
        /// The reasons for the criterion error
        #[prost(enumeration = "super::criterion_error_enum::CriterionError", tag = "32")]
        CriterionError(i32),
        /// The reasons for the custom conversion goal error
        #[prost(
            enumeration = "super::custom_conversion_goal_error_enum::CustomConversionGoalError",
            tag = "150"
        )]
        CustomConversionGoalError(i32),
        /// The reasons for the customer customizer error.
        #[prost(
            enumeration = "super::customer_customizer_error_enum::CustomerCustomizerError",
            tag = "158"
        )]
        CustomerCustomizerError(i32),
        /// The reasons for the customer error
        #[prost(enumeration = "super::customer_error_enum::CustomerError", tag = "90")]
        CustomerError(i32),
        /// The reasons for the customizer attribute error.
        #[prost(
            enumeration = "super::customizer_attribute_error_enum::CustomizerAttributeError",
            tag = "151"
        )]
        CustomizerAttributeError(i32),
        /// The reasons for the date error
        #[prost(enumeration = "super::date_error_enum::DateError", tag = "33")]
        DateError(i32),
        /// The reasons for the date range error
        #[prost(
            enumeration = "super::date_range_error_enum::DateRangeError",
            tag = "34"
        )]
        DateRangeError(i32),
        /// The reasons for the distinct error
        #[prost(enumeration = "super::distinct_error_enum::DistinctError", tag = "35")]
        DistinctError(i32),
        /// The reasons for the feed attribute reference error
        #[prost(
            enumeration = "super::feed_attribute_reference_error_enum::FeedAttributeReferenceError",
            tag = "36"
        )]
        FeedAttributeReferenceError(i32),
        /// The reasons for the function error
        #[prost(enumeration = "super::function_error_enum::FunctionError", tag = "37")]
        FunctionError(i32),
        /// The reasons for the function parsing error
        #[prost(
            enumeration = "super::function_parsing_error_enum::FunctionParsingError",
            tag = "38"
        )]
        FunctionParsingError(i32),
        /// The reasons for the id error
        #[prost(enumeration = "super::id_error_enum::IdError", tag = "39")]
        IdError(i32),
        /// The reasons for the image error
        #[prost(enumeration = "super::image_error_enum::ImageError", tag = "40")]
        ImageError(i32),
        /// The reasons for the language code error
        #[prost(
            enumeration = "super::language_code_error_enum::LanguageCodeError",
            tag = "110"
        )]
        LanguageCodeError(i32),
        /// The reasons for the media bundle error
        #[prost(
            enumeration = "super::media_bundle_error_enum::MediaBundleError",
            tag = "42"
        )]
        MediaBundleError(i32),
        /// The reasons for media uploading errors.
        #[prost(
            enumeration = "super::media_upload_error_enum::MediaUploadError",
            tag = "116"
        )]
        MediaUploadError(i32),
        /// The reasons for the media file error
        #[prost(
            enumeration = "super::media_file_error_enum::MediaFileError",
            tag = "86"
        )]
        MediaFileError(i32),
        /// Container for enum describing possible merchant center errors.
        #[prost(
            enumeration = "super::merchant_center_error_enum::MerchantCenterError",
            tag = "162"
        )]
        MerchantCenterError(i32),
        /// The reasons for the multiplier error
        #[prost(
            enumeration = "super::multiplier_error_enum::MultiplierError",
            tag = "44"
        )]
        MultiplierError(i32),
        /// The reasons for the new resource creation error
        #[prost(
            enumeration = "super::new_resource_creation_error_enum::NewResourceCreationError",
            tag = "45"
        )]
        NewResourceCreationError(i32),
        /// The reasons for the not empty error
        #[prost(enumeration = "super::not_empty_error_enum::NotEmptyError", tag = "46")]
        NotEmptyError(i32),
        /// The reasons for the null error
        #[prost(enumeration = "super::null_error_enum::NullError", tag = "47")]
        NullError(i32),
        /// The reasons for the operator error
        #[prost(enumeration = "super::operator_error_enum::OperatorError", tag = "48")]
        OperatorError(i32),
        /// The reasons for the range error
        #[prost(enumeration = "super::range_error_enum::RangeError", tag = "49")]
        RangeError(i32),
        /// The reasons for error in applying a recommendation
        #[prost(
            enumeration = "super::recommendation_error_enum::RecommendationError",
            tag = "58"
        )]
        RecommendationError(i32),
        /// The reasons for the recommendation subscription error.
        #[prost(
            enumeration = "super::recommendation_subscription_error_enum::RecommendationSubscriptionError",
            tag = "180"
        )]
        RecommendationSubscriptionError(i32),
        /// The reasons for the region code error
        #[prost(
            enumeration = "super::region_code_error_enum::RegionCodeError",
            tag = "51"
        )]
        RegionCodeError(i32),
        /// The reasons for the setting error
        #[prost(enumeration = "super::setting_error_enum::SettingError", tag = "52")]
        SettingError(i32),
        /// The reasons for the string format error
        #[prost(
            enumeration = "super::string_format_error_enum::StringFormatError",
            tag = "53"
        )]
        StringFormatError(i32),
        /// The reasons for the string length error
        #[prost(
            enumeration = "super::string_length_error_enum::StringLengthError",
            tag = "54"
        )]
        StringLengthError(i32),
        /// The reasons for the operation access denied error
        #[prost(
            enumeration = "super::operation_access_denied_error_enum::OperationAccessDeniedError",
            tag = "55"
        )]
        OperationAccessDeniedError(i32),
        /// The reasons for the resource access denied error
        #[prost(
            enumeration = "super::resource_access_denied_error_enum::ResourceAccessDeniedError",
            tag = "56"
        )]
        ResourceAccessDeniedError(i32),
        /// The reasons for the resource count limit exceeded error
        #[prost(
            enumeration = "super::resource_count_limit_exceeded_error_enum::ResourceCountLimitExceededError",
            tag = "57"
        )]
        ResourceCountLimitExceededError(i32),
        /// The reasons for YouTube video registration errors.
        #[prost(
            enumeration = "super::youtube_video_registration_error_enum::YoutubeVideoRegistrationError",
            tag = "117"
        )]
        YoutubeVideoRegistrationError(i32),
        /// The reasons for the ad group bid modifier error
        #[prost(
            enumeration = "super::ad_group_bid_modifier_error_enum::AdGroupBidModifierError",
            tag = "59"
        )]
        AdGroupBidModifierError(i32),
        /// The reasons for the context error
        #[prost(enumeration = "super::context_error_enum::ContextError", tag = "60")]
        ContextError(i32),
        /// The reasons for the field error
        #[prost(enumeration = "super::field_error_enum::FieldError", tag = "61")]
        FieldError(i32),
        /// The reasons for the shared set error
        #[prost(
            enumeration = "super::shared_set_error_enum::SharedSetError",
            tag = "62"
        )]
        SharedSetError(i32),
        /// The reasons for the shared criterion error
        #[prost(
            enumeration = "super::shared_criterion_error_enum::SharedCriterionError",
            tag = "63"
        )]
        SharedCriterionError(i32),
        /// The reasons for the campaign shared set error
        #[prost(
            enumeration = "super::campaign_shared_set_error_enum::CampaignSharedSetError",
            tag = "64"
        )]
        CampaignSharedSetError(i32),
        /// The reasons for the conversion action error
        #[prost(
            enumeration = "super::conversion_action_error_enum::ConversionActionError",
            tag = "65"
        )]
        ConversionActionError(i32),
        /// The reasons for the conversion adjustment upload error
        #[prost(
            enumeration = "super::conversion_adjustment_upload_error_enum::ConversionAdjustmentUploadError",
            tag = "115"
        )]
        ConversionAdjustmentUploadError(i32),
        /// The reasons for the conversion custom variable error
        #[prost(
            enumeration = "super::conversion_custom_variable_error_enum::ConversionCustomVariableError",
            tag = "143"
        )]
        ConversionCustomVariableError(i32),
        /// The reasons for the conversion upload error
        #[prost(
            enumeration = "super::conversion_upload_error_enum::ConversionUploadError",
            tag = "111"
        )]
        ConversionUploadError(i32),
        /// The reasons for the conversion value rule error
        #[prost(
            enumeration = "super::conversion_value_rule_error_enum::ConversionValueRuleError",
            tag = "145"
        )]
        ConversionValueRuleError(i32),
        /// The reasons for the conversion value rule set error
        #[prost(
            enumeration = "super::conversion_value_rule_set_error_enum::ConversionValueRuleSetError",
            tag = "146"
        )]
        ConversionValueRuleSetError(i32),
        /// The reasons for the header error.
        #[prost(enumeration = "super::header_error_enum::HeaderError", tag = "66")]
        HeaderError(i32),
        /// The reasons for the database error.
        #[prost(enumeration = "super::database_error_enum::DatabaseError", tag = "67")]
        DatabaseError(i32),
        /// The reasons for the policy finding error.
        #[prost(
            enumeration = "super::policy_finding_error_enum::PolicyFindingError",
            tag = "68"
        )]
        PolicyFindingError(i32),
        /// The reason for enum error.
        #[prost(enumeration = "super::enum_error_enum::EnumError", tag = "70")]
        EnumError(i32),
        /// The reason for keyword plan error.
        #[prost(
            enumeration = "super::keyword_plan_error_enum::KeywordPlanError",
            tag = "71"
        )]
        KeywordPlanError(i32),
        /// The reason for keyword plan campaign error.
        #[prost(
            enumeration = "super::keyword_plan_campaign_error_enum::KeywordPlanCampaignError",
            tag = "72"
        )]
        KeywordPlanCampaignError(i32),
        /// The reason for keyword plan campaign keyword error.
        #[prost(
            enumeration = "super::keyword_plan_campaign_keyword_error_enum::KeywordPlanCampaignKeywordError",
            tag = "132"
        )]
        KeywordPlanCampaignKeywordError(i32),
        /// The reason for keyword plan ad group error.
        #[prost(
            enumeration = "super::keyword_plan_ad_group_error_enum::KeywordPlanAdGroupError",
            tag = "74"
        )]
        KeywordPlanAdGroupError(i32),
        /// The reason for keyword plan ad group keyword error.
        #[prost(
            enumeration = "super::keyword_plan_ad_group_keyword_error_enum::KeywordPlanAdGroupKeywordError",
            tag = "133"
        )]
        KeywordPlanAdGroupKeywordError(i32),
        /// The reason for keyword idea error.
        #[prost(
            enumeration = "super::keyword_plan_idea_error_enum::KeywordPlanIdeaError",
            tag = "76"
        )]
        KeywordPlanIdeaError(i32),
        /// The reasons for account budget proposal errors.
        #[prost(
            enumeration = "super::account_budget_proposal_error_enum::AccountBudgetProposalError",
            tag = "77"
        )]
        AccountBudgetProposalError(i32),
        /// The reasons for the user list error
        #[prost(enumeration = "super::user_list_error_enum::UserListError", tag = "78")]
        UserListError(i32),
        /// The reasons for the change event error
        #[prost(
            enumeration = "super::change_event_error_enum::ChangeEventError",
            tag = "136"
        )]
        ChangeEventError(i32),
        /// The reasons for the change status error
        #[prost(
            enumeration = "super::change_status_error_enum::ChangeStatusError",
            tag = "79"
        )]
        ChangeStatusError(i32),
        /// The reasons for the feed error
        #[prost(enumeration = "super::feed_error_enum::FeedError", tag = "80")]
        FeedError(i32),
        /// The reasons for the geo target constant suggestion error.
        #[prost(
            enumeration = "super::geo_target_constant_suggestion_error_enum::GeoTargetConstantSuggestionError",
            tag = "81"
        )]
        GeoTargetConstantSuggestionError(i32),
        /// The reasons for the campaign draft error
        #[prost(
            enumeration = "super::campaign_draft_error_enum::CampaignDraftError",
            tag = "82"
        )]
        CampaignDraftError(i32),
        /// The reasons for the feed item error
        #[prost(enumeration = "super::feed_item_error_enum::FeedItemError", tag = "83")]
        FeedItemError(i32),
        /// The reason for the label error.
        #[prost(enumeration = "super::label_error_enum::LabelError", tag = "84")]
        LabelError(i32),
        /// The reasons for the billing setup error
        #[prost(
            enumeration = "super::billing_setup_error_enum::BillingSetupError",
            tag = "87"
        )]
        BillingSetupError(i32),
        /// The reasons for the customer client link error
        #[prost(
            enumeration = "super::customer_client_link_error_enum::CustomerClientLinkError",
            tag = "88"
        )]
        CustomerClientLinkError(i32),
        /// The reasons for the customer manager link error
        #[prost(
            enumeration = "super::customer_manager_link_error_enum::CustomerManagerLinkError",
            tag = "91"
        )]
        CustomerManagerLinkError(i32),
        /// The reasons for the feed mapping error
        #[prost(
            enumeration = "super::feed_mapping_error_enum::FeedMappingError",
            tag = "92"
        )]
        FeedMappingError(i32),
        /// The reasons for the customer feed error
        #[prost(
            enumeration = "super::customer_feed_error_enum::CustomerFeedError",
            tag = "93"
        )]
        CustomerFeedError(i32),
        /// The reasons for the ad group feed error
        #[prost(
            enumeration = "super::ad_group_feed_error_enum::AdGroupFeedError",
            tag = "94"
        )]
        AdGroupFeedError(i32),
        /// The reasons for the campaign feed error
        #[prost(
            enumeration = "super::campaign_feed_error_enum::CampaignFeedError",
            tag = "96"
        )]
        CampaignFeedError(i32),
        /// The reasons for the custom interest error
        #[prost(
            enumeration = "super::custom_interest_error_enum::CustomInterestError",
            tag = "97"
        )]
        CustomInterestError(i32),
        /// The reasons for the campaign experiment error
        #[prost(
            enumeration = "super::campaign_experiment_error_enum::CampaignExperimentError",
            tag = "98"
        )]
        CampaignExperimentError(i32),
        /// The reasons for the extension feed item error
        #[prost(
            enumeration = "super::extension_feed_item_error_enum::ExtensionFeedItemError",
            tag = "100"
        )]
        ExtensionFeedItemError(i32),
        /// The reasons for the ad parameter error
        #[prost(
            enumeration = "super::ad_parameter_error_enum::AdParameterError",
            tag = "101"
        )]
        AdParameterError(i32),
        /// The reasons for the feed item validation error
        #[prost(
            enumeration = "super::feed_item_validation_error_enum::FeedItemValidationError",
            tag = "102"
        )]
        FeedItemValidationError(i32),
        /// The reasons for the extension setting error
        #[prost(
            enumeration = "super::extension_setting_error_enum::ExtensionSettingError",
            tag = "103"
        )]
        ExtensionSettingError(i32),
        /// The reasons for the feed item set error
        #[prost(
            enumeration = "super::feed_item_set_error_enum::FeedItemSetError",
            tag = "140"
        )]
        FeedItemSetError(i32),
        /// The reasons for the feed item set link error
        #[prost(
            enumeration = "super::feed_item_set_link_error_enum::FeedItemSetLinkError",
            tag = "141"
        )]
        FeedItemSetLinkError(i32),
        /// The reasons for the feed item target error
        #[prost(
            enumeration = "super::feed_item_target_error_enum::FeedItemTargetError",
            tag = "104"
        )]
        FeedItemTargetError(i32),
        /// The reasons for the policy violation error
        #[prost(
            enumeration = "super::policy_violation_error_enum::PolicyViolationError",
            tag = "105"
        )]
        PolicyViolationError(i32),
        /// The reasons for the mutate job error
        #[prost(
            enumeration = "super::partial_failure_error_enum::PartialFailureError",
            tag = "112"
        )]
        PartialFailureError(i32),
        /// The reasons for the policy validation parameter error
        #[prost(
            enumeration = "super::policy_validation_parameter_error_enum::PolicyValidationParameterError",
            tag = "114"
        )]
        PolicyValidationParameterError(i32),
        /// The reasons for the size limit error
        #[prost(
            enumeration = "super::size_limit_error_enum::SizeLimitError",
            tag = "118"
        )]
        SizeLimitError(i32),
        /// The reasons for the offline user data job error.
        #[prost(
            enumeration = "super::offline_user_data_job_error_enum::OfflineUserDataJobError",
            tag = "119"
        )]
        OfflineUserDataJobError(i32),
        /// The reasons for the not allowlisted error
        #[prost(
            enumeration = "super::not_allowlisted_error_enum::NotAllowlistedError",
            tag = "137"
        )]
        NotAllowlistedError(i32),
        /// The reasons for the manager link error
        #[prost(
            enumeration = "super::manager_link_error_enum::ManagerLinkError",
            tag = "121"
        )]
        ManagerLinkError(i32),
        /// The reasons for the currency code error
        #[prost(
            enumeration = "super::currency_code_error_enum::CurrencyCodeError",
            tag = "122"
        )]
        CurrencyCodeError(i32),
        /// The reasons for the experiment error
        #[prost(
            enumeration = "super::experiment_error_enum::ExperimentError",
            tag = "123"
        )]
        ExperimentError(i32),
        /// The reasons for the access invitation error
        #[prost(
            enumeration = "super::access_invitation_error_enum::AccessInvitationError",
            tag = "124"
        )]
        AccessInvitationError(i32),
        /// The reasons for the reach plan error
        #[prost(
            enumeration = "super::reach_plan_error_enum::ReachPlanError",
            tag = "125"
        )]
        ReachPlanError(i32),
        /// The reasons for the invoice error
        #[prost(enumeration = "super::invoice_error_enum::InvoiceError", tag = "126")]
        InvoiceError(i32),
        /// The reasons for errors in payments accounts service
        #[prost(
            enumeration = "super::payments_account_error_enum::PaymentsAccountError",
            tag = "127"
        )]
        PaymentsAccountError(i32),
        /// The reasons for the time zone error
        #[prost(enumeration = "super::time_zone_error_enum::TimeZoneError", tag = "128")]
        TimeZoneError(i32),
        /// The reasons for the asset link error
        #[prost(
            enumeration = "super::asset_link_error_enum::AssetLinkError",
            tag = "129"
        )]
        AssetLinkError(i32),
        /// The reasons for the user data error.
        #[prost(enumeration = "super::user_data_error_enum::UserDataError", tag = "130")]
        UserDataError(i32),
        /// The reasons for the batch job error
        #[prost(enumeration = "super::batch_job_error_enum::BatchJobError", tag = "131")]
        BatchJobError(i32),
        /// The reasons for the account link status change error
        #[prost(
            enumeration = "super::account_link_error_enum::AccountLinkError",
            tag = "134"
        )]
        AccountLinkError(i32),
        /// The reasons for the third party app analytics link mutate error
        #[prost(
            enumeration = "super::third_party_app_analytics_link_error_enum::ThirdPartyAppAnalyticsLinkError",
            tag = "135"
        )]
        ThirdPartyAppAnalyticsLinkError(i32),
        /// The reasons for the customer user access mutate error
        #[prost(
            enumeration = "super::customer_user_access_error_enum::CustomerUserAccessError",
            tag = "138"
        )]
        CustomerUserAccessError(i32),
        /// The reasons for the custom audience error
        #[prost(
            enumeration = "super::custom_audience_error_enum::CustomAudienceError",
            tag = "139"
        )]
        CustomAudienceError(i32),
        /// The reasons for the audience error
        #[prost(enumeration = "super::audience_error_enum::AudienceError", tag = "164")]
        AudienceError(i32),
        /// The reasons for the Search term insight error
        #[prost(
            enumeration = "super::search_term_insight_error_enum::SearchTermInsightError",
            tag = "174"
        )]
        SearchTermInsightError(i32),
        /// The reasons for the Smart campaign error
        #[prost(
            enumeration = "super::smart_campaign_error_enum::SmartCampaignError",
            tag = "147"
        )]
        SmartCampaignError(i32),
        /// The reasons for the experiment arm error
        #[prost(
            enumeration = "super::experiment_arm_error_enum::ExperimentArmError",
            tag = "156"
        )]
        ExperimentArmError(i32),
        /// The reasons for the Audience Insights error
        #[prost(
            enumeration = "super::audience_insights_error_enum::AudienceInsightsError",
            tag = "167"
        )]
        AudienceInsightsError(i32),
        /// The reasons for the product link error
        #[prost(
            enumeration = "super::product_link_error_enum::ProductLinkError",
            tag = "169"
        )]
        ProductLinkError(i32),
        /// The reasons for the customer SK Ad network conversion value schema error
        #[prost(
            enumeration = "super::customer_sk_ad_network_conversion_value_schema_error_enum::CustomerSkAdNetworkConversionValueSchemaError",
            tag = "170"
        )]
        CustomerSkAdNetworkConversionValueSchemaError(i32),
        /// The reasons for the currency errors.
        #[prost(enumeration = "super::currency_error_enum::CurrencyError", tag = "171")]
        CurrencyError(i32),
        /// The reasons for the asset group hint error
        #[prost(
            enumeration = "super::asset_group_signal_error_enum::AssetGroupSignalError",
            tag = "176"
        )]
        AssetGroupSignalError(i32),
        /// The reasons for the product link invitation error
        #[prost(
            enumeration = "super::product_link_invitation_error_enum::ProductLinkInvitationError",
            tag = "177"
        )]
        ProductLinkInvitationError(i32),
        /// The reasons for the customer lifecycle goal error
        #[prost(
            enumeration = "super::customer_lifecycle_goal_error_enum::CustomerLifecycleGoalError",
            tag = "178"
        )]
        CustomerLifecycleGoalError(i32),
        /// The reasons for the campaign lifecycle goal error
        #[prost(
            enumeration = "super::campaign_lifecycle_goal_error_enum::CampaignLifecycleGoalError",
            tag = "179"
        )]
        CampaignLifecycleGoalError(i32),
        /// The reasons for an identity verification error.
        #[prost(
            enumeration = "super::identity_verification_error_enum::IdentityVerificationError",
            tag = "181"
        )]
        IdentityVerificationError(i32),
    }
}
/// Describes the part of the request proto that caused the error.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorLocation {
    /// A field path that indicates which field was invalid in the request.
    #[prost(message, repeated, tag = "2")]
    pub field_path_elements: ::prost::alloc::vec::Vec<error_location::FieldPathElement>,
}
/// Nested message and enum types in `ErrorLocation`.
pub mod error_location {
    /// A part of a field path.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FieldPathElement {
        /// The name of a field or a oneof
        #[prost(string, tag = "1")]
        pub field_name: ::prost::alloc::string::String,
        /// If field_name is a repeated field, this is the element that failed
        #[prost(int32, optional, tag = "3")]
        pub index: ::core::option::Option<i32>,
    }
}
/// Additional error details.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorDetails {
    /// The error code that should have been returned, but wasn't. This is used
    /// when the error code is not published in the client specified version.
    #[prost(string, tag = "1")]
    pub unpublished_error_code: ::prost::alloc::string::String,
    /// Describes an ad policy violation.
    #[prost(message, optional, tag = "2")]
    pub policy_violation_details: ::core::option::Option<PolicyViolationDetails>,
    /// Describes policy violation findings.
    #[prost(message, optional, tag = "3")]
    pub policy_finding_details: ::core::option::Option<PolicyFindingDetails>,
    /// Details on the quota error, including the scope (account or developer), the
    /// rate bucket name and the retry delay.
    #[prost(message, optional, tag = "4")]
    pub quota_error_details: ::core::option::Option<QuotaErrorDetails>,
    /// Details for a resource count limit exceeded error.
    #[prost(message, optional, tag = "5")]
    pub resource_count_details: ::core::option::Option<ResourceCountDetails>,
}
/// Error returned as part of a mutate response.
/// This error indicates single policy violation by some text
/// in one of the fields.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyViolationDetails {
    /// Human readable description of policy violation.
    #[prost(string, tag = "2")]
    pub external_policy_description: ::prost::alloc::string::String,
    /// Unique identifier for this violation.
    /// If policy is exemptible, this key may be used to request exemption.
    #[prost(message, optional, tag = "4")]
    pub key: ::core::option::Option<super::common::PolicyViolationKey>,
    /// Human readable name of the policy.
    #[prost(string, tag = "5")]
    pub external_policy_name: ::prost::alloc::string::String,
    /// Whether user can file an exemption request for this violation.
    #[prost(bool, tag = "6")]
    pub is_exemptible: bool,
}
/// Error returned as part of a mutate response.
/// This error indicates one or more policy findings in the fields of a
/// resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyFindingDetails {
    /// The list of policy topics for the resource. Contains the PROHIBITED or
    /// FULLY_LIMITED policy topic entries that prevented the resource from being
    /// saved (among any other entries the resource may also have).
    #[prost(message, repeated, tag = "1")]
    pub policy_topic_entries: ::prost::alloc::vec::Vec<super::common::PolicyTopicEntry>,
}
/// Additional quota error details when there is QuotaError.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuotaErrorDetails {
    /// The rate scope of the quota limit.
    #[prost(enumeration = "quota_error_details::QuotaRateScope", tag = "1")]
    pub rate_scope: i32,
    /// The high level description of the quota bucket.
    /// Examples are "Get requests for standard access" or "Requests per account".
    #[prost(string, tag = "2")]
    pub rate_name: ::prost::alloc::string::String,
    /// Backoff period that customers should wait before sending next request.
    #[prost(message, optional, tag = "3")]
    pub retry_delay: ::core::option::Option<::prost_types::Duration>,
}
/// Nested message and enum types in `QuotaErrorDetails`.
pub mod quota_error_details {
    /// Enum of possible scopes that quota buckets belong to.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum QuotaRateScope {
        /// Unspecified enum
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Per customer account quota
        Account = 2,
        /// Per project or DevToken quota
        Developer = 3,
    }
    impl QuotaRateScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Account => "ACCOUNT",
                Self::Developer => "DEVELOPER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACCOUNT" => Some(Self::Account),
                "DEVELOPER" => Some(Self::Developer),
                _ => None,
            }
        }
    }
}
/// Error details returned when an resource count limit was exceeded.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceCountDetails {
    /// The ID of the resource whose limit was exceeded.
    /// External customer ID if the limit is for a customer.
    #[prost(string, tag = "1")]
    pub enclosing_id: ::prost::alloc::string::String,
    /// The name of the resource (Customer, Campaign etc.) whose limit was
    /// exceeded.
    #[prost(string, tag = "5")]
    pub enclosing_resource: ::prost::alloc::string::String,
    /// The limit which was exceeded.
    #[prost(int32, tag = "2")]
    pub limit: i32,
    /// The resource limit type which was exceeded.
    #[prost(
        enumeration = "super::enums::resource_limit_type_enum::ResourceLimitType",
        tag = "3"
    )]
    pub limit_type: i32,
    /// The count of existing entities.
    #[prost(int32, tag = "4")]
    pub existing_count: i32,
}
