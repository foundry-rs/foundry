// This file is @generated by prost-build.
/// Container for enum describing possible authentication errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AuthenticationErrorEnum {}
/// Nested message and enum types in `AuthenticationErrorEnum`.
pub mod authentication_error_enum {
    /// Enum describing possible authentication errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AuthenticationError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Authentication of the request failed.
        AuthenticationError = 2,
        /// Client customer ID is not a number.
        ClientCustomerIdInvalid = 5,
        /// No customer found for the provided customer ID.
        CustomerNotFound = 8,
        /// Client's Google account is deleted.
        GoogleAccountDeleted = 9,
        /// Account login token in the cookie is invalid.
        GoogleAccountCookieInvalid = 10,
        /// A problem occurred during Google account authentication.
        GoogleAccountAuthenticationFailed = 25,
        /// The user in the Google account login token does not match the user ID in
        /// the cookie.
        GoogleAccountUserAndAdsUserMismatch = 12,
        /// Login cookie is required for authentication.
        LoginCookieRequired = 13,
        /// The Google account that generated the OAuth access
        /// token is not associated with a Search Ads 360 account. Create a new
        /// account, or add the Google account to an existing Search Ads 360 account.
        NotAdsUser = 14,
        /// OAuth token in the header is not valid.
        OauthTokenInvalid = 15,
        /// OAuth token in the header has expired.
        OauthTokenExpired = 16,
        /// OAuth token in the header has been disabled.
        OauthTokenDisabled = 17,
        /// OAuth token in the header has been revoked.
        OauthTokenRevoked = 18,
        /// OAuth token HTTP header is malformed.
        OauthTokenHeaderInvalid = 19,
        /// Login cookie is not valid.
        LoginCookieInvalid = 20,
        /// User ID in the header is not a valid ID.
        UserIdInvalid = 22,
        /// An account administrator changed this account's authentication settings.
        /// To access this account, enable 2-Step Verification in your
        /// Google account at <https://www.google.com/landing/2step.>
        TwoStepVerificationNotEnrolled = 23,
        /// An account administrator changed this account's authentication settings.
        /// To access this account, enable Advanced Protection in your
        /// Google account at <https://landing.google.com/advancedprotection.>
        AdvancedProtectionNotEnrolled = 24,
    }
    impl AuthenticationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AuthenticationError => "AUTHENTICATION_ERROR",
                Self::ClientCustomerIdInvalid => "CLIENT_CUSTOMER_ID_INVALID",
                Self::CustomerNotFound => "CUSTOMER_NOT_FOUND",
                Self::GoogleAccountDeleted => "GOOGLE_ACCOUNT_DELETED",
                Self::GoogleAccountCookieInvalid => "GOOGLE_ACCOUNT_COOKIE_INVALID",
                Self::GoogleAccountAuthenticationFailed => {
                    "GOOGLE_ACCOUNT_AUTHENTICATION_FAILED"
                }
                Self::GoogleAccountUserAndAdsUserMismatch => {
                    "GOOGLE_ACCOUNT_USER_AND_ADS_USER_MISMATCH"
                }
                Self::LoginCookieRequired => "LOGIN_COOKIE_REQUIRED",
                Self::NotAdsUser => "NOT_ADS_USER",
                Self::OauthTokenInvalid => "OAUTH_TOKEN_INVALID",
                Self::OauthTokenExpired => "OAUTH_TOKEN_EXPIRED",
                Self::OauthTokenDisabled => "OAUTH_TOKEN_DISABLED",
                Self::OauthTokenRevoked => "OAUTH_TOKEN_REVOKED",
                Self::OauthTokenHeaderInvalid => "OAUTH_TOKEN_HEADER_INVALID",
                Self::LoginCookieInvalid => "LOGIN_COOKIE_INVALID",
                Self::UserIdInvalid => "USER_ID_INVALID",
                Self::TwoStepVerificationNotEnrolled => {
                    "TWO_STEP_VERIFICATION_NOT_ENROLLED"
                }
                Self::AdvancedProtectionNotEnrolled => "ADVANCED_PROTECTION_NOT_ENROLLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AUTHENTICATION_ERROR" => Some(Self::AuthenticationError),
                "CLIENT_CUSTOMER_ID_INVALID" => Some(Self::ClientCustomerIdInvalid),
                "CUSTOMER_NOT_FOUND" => Some(Self::CustomerNotFound),
                "GOOGLE_ACCOUNT_DELETED" => Some(Self::GoogleAccountDeleted),
                "GOOGLE_ACCOUNT_COOKIE_INVALID" => Some(Self::GoogleAccountCookieInvalid),
                "GOOGLE_ACCOUNT_AUTHENTICATION_FAILED" => {
                    Some(Self::GoogleAccountAuthenticationFailed)
                }
                "GOOGLE_ACCOUNT_USER_AND_ADS_USER_MISMATCH" => {
                    Some(Self::GoogleAccountUserAndAdsUserMismatch)
                }
                "LOGIN_COOKIE_REQUIRED" => Some(Self::LoginCookieRequired),
                "NOT_ADS_USER" => Some(Self::NotAdsUser),
                "OAUTH_TOKEN_INVALID" => Some(Self::OauthTokenInvalid),
                "OAUTH_TOKEN_EXPIRED" => Some(Self::OauthTokenExpired),
                "OAUTH_TOKEN_DISABLED" => Some(Self::OauthTokenDisabled),
                "OAUTH_TOKEN_REVOKED" => Some(Self::OauthTokenRevoked),
                "OAUTH_TOKEN_HEADER_INVALID" => Some(Self::OauthTokenHeaderInvalid),
                "LOGIN_COOKIE_INVALID" => Some(Self::LoginCookieInvalid),
                "USER_ID_INVALID" => Some(Self::UserIdInvalid),
                "TWO_STEP_VERIFICATION_NOT_ENROLLED" => {
                    Some(Self::TwoStepVerificationNotEnrolled)
                }
                "ADVANCED_PROTECTION_NOT_ENROLLED" => {
                    Some(Self::AdvancedProtectionNotEnrolled)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible authorization errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AuthorizationErrorEnum {}
/// Nested message and enum types in `AuthorizationErrorEnum`.
pub mod authorization_error_enum {
    /// Enum describing possible authorization errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AuthorizationError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// User doesn't have permission to access customer. Note: If you're
        /// accessing a client customer, the manager's customer ID must be set in the
        /// `login-customer-id` header. Learn more at
        /// <https://developers.google.com/search-ads/reporting/concepts/call-structure#login_customer_id_header>
        UserPermissionDenied = 2,
        /// The Google Cloud project sent in the request does not have permission to
        /// access the api.
        ProjectDisabled = 5,
        /// Authorization of the client failed.
        AuthorizationError = 6,
        /// The user does not have permission to perform this action
        /// (for example, ADD, UPDATE, REMOVE) on the resource or call a method.
        ActionNotPermitted = 7,
        /// Signup not complete.
        IncompleteSignup = 8,
        /// The customer account can't be accessed because it is not yet enabled or
        /// has been deactivated.
        CustomerNotEnabled = 24,
        /// The developer must sign the terms of service. They can be found here:
        /// <https://developers.google.com/terms>
        MissingTos = 9,
        /// The login customer specified does not have access to the account
        /// specified, so the request is invalid.
        InvalidLoginCustomerIdServingCustomerIdCombination = 11,
        /// The developer specified does not have access to the service.
        ServiceAccessDenied = 12,
        /// The customer (or login customer) isn't allowed in Search Ads 360 API. It
        /// belongs to another ads system.
        AccessDeniedForAccountType = 25,
        /// The developer does not have access to the metrics queried.
        MetricAccessDenied = 26,
    }
    impl AuthorizationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::UserPermissionDenied => "USER_PERMISSION_DENIED",
                Self::ProjectDisabled => "PROJECT_DISABLED",
                Self::AuthorizationError => "AUTHORIZATION_ERROR",
                Self::ActionNotPermitted => "ACTION_NOT_PERMITTED",
                Self::IncompleteSignup => "INCOMPLETE_SIGNUP",
                Self::CustomerNotEnabled => "CUSTOMER_NOT_ENABLED",
                Self::MissingTos => "MISSING_TOS",
                Self::InvalidLoginCustomerIdServingCustomerIdCombination => {
                    "INVALID_LOGIN_CUSTOMER_ID_SERVING_CUSTOMER_ID_COMBINATION"
                }
                Self::ServiceAccessDenied => "SERVICE_ACCESS_DENIED",
                Self::AccessDeniedForAccountType => "ACCESS_DENIED_FOR_ACCOUNT_TYPE",
                Self::MetricAccessDenied => "METRIC_ACCESS_DENIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "USER_PERMISSION_DENIED" => Some(Self::UserPermissionDenied),
                "PROJECT_DISABLED" => Some(Self::ProjectDisabled),
                "AUTHORIZATION_ERROR" => Some(Self::AuthorizationError),
                "ACTION_NOT_PERMITTED" => Some(Self::ActionNotPermitted),
                "INCOMPLETE_SIGNUP" => Some(Self::IncompleteSignup),
                "CUSTOMER_NOT_ENABLED" => Some(Self::CustomerNotEnabled),
                "MISSING_TOS" => Some(Self::MissingTos),
                "INVALID_LOGIN_CUSTOMER_ID_SERVING_CUSTOMER_ID_COMBINATION" => {
                    Some(Self::InvalidLoginCustomerIdServingCustomerIdCombination)
                }
                "SERVICE_ACCESS_DENIED" => Some(Self::ServiceAccessDenied),
                "ACCESS_DENIED_FOR_ACCOUNT_TYPE" => {
                    Some(Self::AccessDeniedForAccountType)
                }
                "METRIC_ACCESS_DENIED" => Some(Self::MetricAccessDenied),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible custom column errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomColumnErrorEnum {}
/// Nested message and enum types in `CustomColumnErrorEnum`.
pub mod custom_column_error_enum {
    /// Enum describing possible custom column errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomColumnError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The custom column has not been found.
        CustomColumnNotFound = 2,
        /// The custom column is not available.
        CustomColumnNotAvailable = 3,
    }
    impl CustomColumnError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CustomColumnNotFound => "CUSTOM_COLUMN_NOT_FOUND",
                Self::CustomColumnNotAvailable => "CUSTOM_COLUMN_NOT_AVAILABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOM_COLUMN_NOT_FOUND" => Some(Self::CustomColumnNotFound),
                "CUSTOM_COLUMN_NOT_AVAILABLE" => Some(Self::CustomColumnNotAvailable),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible date errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DateErrorEnum {}
/// Nested message and enum types in `DateErrorEnum`.
pub mod date_error_enum {
    /// Enum describing possible date errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DateError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Given field values do not correspond to a valid date.
        InvalidFieldValuesInDate = 2,
        /// Given field values do not correspond to a valid date time.
        InvalidFieldValuesInDateTime = 3,
        /// The string date's format should be yyyy-mm-dd.
        InvalidStringDate = 4,
        /// The string date time's format should be yyyy-mm-dd hh:mm:ss.ssssss.
        InvalidStringDateTimeMicros = 6,
        /// The string date time's format should be yyyy-mm-dd hh:mm:ss.
        InvalidStringDateTimeSeconds = 11,
        /// The string date time's format should be yyyy-mm-dd hh:mm:ss+|-hh:mm.
        InvalidStringDateTimeSecondsWithOffset = 12,
        /// Date is before allowed minimum.
        EarlierThanMinimumDate = 7,
        /// Date is after allowed maximum.
        LaterThanMaximumDate = 8,
        /// Date range bounds are not in order.
        DateRangeMinimumDateLaterThanMaximumDate = 9,
        /// Both dates in range are null.
        DateRangeMinimumAndMaximumDatesBothNull = 10,
    }
    impl DateError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidFieldValuesInDate => "INVALID_FIELD_VALUES_IN_DATE",
                Self::InvalidFieldValuesInDateTime => "INVALID_FIELD_VALUES_IN_DATE_TIME",
                Self::InvalidStringDate => "INVALID_STRING_DATE",
                Self::InvalidStringDateTimeMicros => "INVALID_STRING_DATE_TIME_MICROS",
                Self::InvalidStringDateTimeSeconds => "INVALID_STRING_DATE_TIME_SECONDS",
                Self::InvalidStringDateTimeSecondsWithOffset => {
                    "INVALID_STRING_DATE_TIME_SECONDS_WITH_OFFSET"
                }
                Self::EarlierThanMinimumDate => "EARLIER_THAN_MINIMUM_DATE",
                Self::LaterThanMaximumDate => "LATER_THAN_MAXIMUM_DATE",
                Self::DateRangeMinimumDateLaterThanMaximumDate => {
                    "DATE_RANGE_MINIMUM_DATE_LATER_THAN_MAXIMUM_DATE"
                }
                Self::DateRangeMinimumAndMaximumDatesBothNull => {
                    "DATE_RANGE_MINIMUM_AND_MAXIMUM_DATES_BOTH_NULL"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_FIELD_VALUES_IN_DATE" => Some(Self::InvalidFieldValuesInDate),
                "INVALID_FIELD_VALUES_IN_DATE_TIME" => {
                    Some(Self::InvalidFieldValuesInDateTime)
                }
                "INVALID_STRING_DATE" => Some(Self::InvalidStringDate),
                "INVALID_STRING_DATE_TIME_MICROS" => {
                    Some(Self::InvalidStringDateTimeMicros)
                }
                "INVALID_STRING_DATE_TIME_SECONDS" => {
                    Some(Self::InvalidStringDateTimeSeconds)
                }
                "INVALID_STRING_DATE_TIME_SECONDS_WITH_OFFSET" => {
                    Some(Self::InvalidStringDateTimeSecondsWithOffset)
                }
                "EARLIER_THAN_MINIMUM_DATE" => Some(Self::EarlierThanMinimumDate),
                "LATER_THAN_MAXIMUM_DATE" => Some(Self::LaterThanMaximumDate),
                "DATE_RANGE_MINIMUM_DATE_LATER_THAN_MAXIMUM_DATE" => {
                    Some(Self::DateRangeMinimumDateLaterThanMaximumDate)
                }
                "DATE_RANGE_MINIMUM_AND_MAXIMUM_DATES_BOTH_NULL" => {
                    Some(Self::DateRangeMinimumAndMaximumDatesBothNull)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible date range errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DateRangeErrorEnum {}
/// Nested message and enum types in `DateRangeErrorEnum`.
pub mod date_range_error_enum {
    /// Enum describing possible date range errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DateRangeError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Invalid date.
        InvalidDate = 2,
        /// The start date was after the end date.
        StartDateAfterEndDate = 3,
        /// Cannot set date to past time
        CannotSetDateToPast = 4,
        /// A date was used that is past the system "last" date.
        AfterMaximumAllowableDate = 5,
        /// Trying to change start date on a resource that has started.
        CannotModifyStartDateIfAlreadyStarted = 6,
    }
    impl DateRangeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidDate => "INVALID_DATE",
                Self::StartDateAfterEndDate => "START_DATE_AFTER_END_DATE",
                Self::CannotSetDateToPast => "CANNOT_SET_DATE_TO_PAST",
                Self::AfterMaximumAllowableDate => "AFTER_MAXIMUM_ALLOWABLE_DATE",
                Self::CannotModifyStartDateIfAlreadyStarted => {
                    "CANNOT_MODIFY_START_DATE_IF_ALREADY_STARTED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_DATE" => Some(Self::InvalidDate),
                "START_DATE_AFTER_END_DATE" => Some(Self::StartDateAfterEndDate),
                "CANNOT_SET_DATE_TO_PAST" => Some(Self::CannotSetDateToPast),
                "AFTER_MAXIMUM_ALLOWABLE_DATE" => Some(Self::AfterMaximumAllowableDate),
                "CANNOT_MODIFY_START_DATE_IF_ALREADY_STARTED" => {
                    Some(Self::CannotModifyStartDateIfAlreadyStarted)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible distinct errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DistinctErrorEnum {}
/// Nested message and enum types in `DistinctErrorEnum`.
pub mod distinct_error_enum {
    /// Enum describing possible distinct errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DistinctError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Duplicate element.
        DuplicateElement = 2,
        /// Duplicate type.
        DuplicateType = 3,
    }
    impl DistinctError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DuplicateElement => "DUPLICATE_ELEMENT",
                Self::DuplicateType => "DUPLICATE_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_ELEMENT" => Some(Self::DuplicateElement),
                "DUPLICATE_TYPE" => Some(Self::DuplicateType),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible header errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HeaderErrorEnum {}
/// Nested message and enum types in `HeaderErrorEnum`.
pub mod header_error_enum {
    /// Enum describing possible header errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HeaderError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The user selected customer ID could not be validated.
        InvalidUserSelectedCustomerId = 2,
        /// The login customer ID could not be validated.
        InvalidLoginCustomerId = 3,
    }
    impl HeaderError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidUserSelectedCustomerId => {
                    "INVALID_USER_SELECTED_CUSTOMER_ID"
                }
                Self::InvalidLoginCustomerId => "INVALID_LOGIN_CUSTOMER_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_USER_SELECTED_CUSTOMER_ID" => {
                    Some(Self::InvalidUserSelectedCustomerId)
                }
                "INVALID_LOGIN_CUSTOMER_ID" => Some(Self::InvalidLoginCustomerId),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible internal errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InternalErrorEnum {}
/// Nested message and enum types in `InternalErrorEnum`.
pub mod internal_error_enum {
    /// Enum describing possible internal errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InternalError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// API encountered unexpected internal error.
        InternalError = 2,
        /// The intended error code doesn't exist in specified API version. It will
        /// be released in a future API version.
        ErrorCodeNotPublished = 3,
        /// API encountered an unexpected transient error. The user
        /// should retry their request in these cases.
        TransientError = 4,
        /// The request took longer than a deadline.
        DeadlineExceeded = 5,
    }
    impl InternalError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InternalError => "INTERNAL_ERROR",
                Self::ErrorCodeNotPublished => "ERROR_CODE_NOT_PUBLISHED",
                Self::TransientError => "TRANSIENT_ERROR",
                Self::DeadlineExceeded => "DEADLINE_EXCEEDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INTERNAL_ERROR" => Some(Self::InternalError),
                "ERROR_CODE_NOT_PUBLISHED" => Some(Self::ErrorCodeNotPublished),
                "TRANSIENT_ERROR" => Some(Self::TransientError),
                "DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible errors from an invalid parameter.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InvalidParameterErrorEnum {}
/// Nested message and enum types in `InvalidParameterErrorEnum`.
pub mod invalid_parameter_error_enum {
    /// Enum describing possible parameter errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InvalidParameterError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The specified currency code is invalid.
        InvalidCurrencyCode = 2,
    }
    impl InvalidParameterError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InvalidCurrencyCode => "INVALID_CURRENCY_CODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_CURRENCY_CODE" => Some(Self::InvalidCurrencyCode),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible query errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryErrorEnum {}
/// Nested message and enum types in `QueryErrorEnum`.
pub mod query_error_enum {
    /// Enum describing possible query errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum QueryError {
        /// Name unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Returned if all other query error reasons are not applicable.
        QueryError = 50,
        /// A condition used in the query references an invalid enum constant.
        BadEnumConstant = 18,
        /// Query contains an invalid escape sequence.
        BadEscapeSequence = 7,
        /// Field name is invalid.
        BadFieldName = 12,
        /// Limit value is invalid (for example, not a number)
        BadLimitValue = 15,
        /// Encountered number can not be parsed.
        BadNumber = 5,
        /// Invalid operator encountered.
        BadOperator = 3,
        /// Parameter unknown or not supported.
        BadParameterName = 61,
        /// Parameter have invalid value.
        BadParameterValue = 62,
        /// Invalid resource type was specified in the FROM clause.
        BadResourceTypeInFromClause = 45,
        /// Non-ASCII symbol encountered outside of strings.
        BadSymbol = 2,
        /// Value is invalid.
        BadValue = 4,
        /// Date filters fail to restrict date to a range smaller than 31 days.
        /// Applicable if the query is segmented by date.
        DateRangeTooWide = 36,
        /// Filters on date/week/month/quarter have a start date after
        /// end date.
        DateRangeTooNarrow = 60,
        /// Expected AND between values with BETWEEN operator.
        ExpectedAnd = 30,
        /// Expecting ORDER BY to have BY.
        ExpectedBy = 14,
        /// There was no dimension field selected.
        ExpectedDimensionFieldInSelectClause = 37,
        /// Missing filters on date related fields.
        ExpectedFiltersOnDateRange = 55,
        /// Missing FROM clause.
        ExpectedFrom = 44,
        /// The operator used in the conditions requires the value to be a list.
        ExpectedList = 41,
        /// Fields used in WHERE or ORDER BY clauses are missing from the SELECT
        /// clause.
        ExpectedReferencedFieldInSelectClause = 16,
        /// SELECT is missing at the beginning of query.
        ExpectedSelect = 13,
        /// A list was passed as a value to a condition whose operator expects a
        /// single value.
        ExpectedSingleValue = 42,
        /// Missing one or both values with BETWEEN operator.
        ExpectedValueWithBetweenOperator = 29,
        /// Invalid date format. Expected 'YYYY-MM-DD'.
        InvalidDateFormat = 38,
        /// Misaligned date value for the filter. The date should be the start of a
        /// week/month/quarter if the filtered field is
        /// segments.week/segments.month/segments.quarter.
        MisalignedDateForFilter = 64,
        /// Value passed was not a string when it should have been. For example, it
        /// was a number or unquoted literal.
        InvalidStringValue = 57,
        /// A String value passed to the BETWEEN operator does not parse as a date.
        InvalidValueWithBetweenOperator = 26,
        /// The value passed to the DURING operator is not a Date range literal
        InvalidValueWithDuringOperator = 22,
        /// A value was passed to the LIKE operator.
        InvalidValueWithLikeOperator = 56,
        /// An operator was provided that is inapplicable to the field being
        /// filtered.
        OperatorFieldMismatch = 35,
        /// A Condition was found with an empty list.
        ProhibitedEmptyListInCondition = 28,
        /// A condition used in the query references an unsupported enum constant.
        ProhibitedEnumConstant = 54,
        /// Fields that are not allowed to be selected together were included in
        /// the SELECT clause.
        ProhibitedFieldCombinationInSelectClause = 31,
        /// A field that is not orderable was included in the ORDER BY clause.
        ProhibitedFieldInOrderByClause = 40,
        /// A field that is not selectable was included in the SELECT clause.
        ProhibitedFieldInSelectClause = 23,
        /// A field that is not filterable was included in the WHERE clause.
        ProhibitedFieldInWhereClause = 24,
        /// Resource type specified in the FROM clause is not supported by this
        /// service.
        ProhibitedResourceTypeInFromClause = 43,
        /// A field that comes from an incompatible resource was included in the
        /// SELECT clause.
        ProhibitedResourceTypeInSelectClause = 48,
        /// A field that comes from an incompatible resource was included in the
        /// WHERE clause.
        ProhibitedResourceTypeInWhereClause = 58,
        /// A metric incompatible with the main resource or other selected
        /// segmenting resources was included in the SELECT or WHERE clause.
        ProhibitedMetricInSelectOrWhereClause = 49,
        /// A segment incompatible with the main resource or other selected
        /// segmenting resources was included in the SELECT or WHERE clause.
        ProhibitedSegmentInSelectOrWhereClause = 51,
        /// A segment in the SELECT clause is incompatible with a metric in the
        /// SELECT or WHERE clause.
        ProhibitedSegmentWithMetricInSelectOrWhereClause = 53,
        /// The value passed to the limit clause is too low.
        LimitValueTooLow = 25,
        /// Query has a string containing a newline character.
        ProhibitedNewlineInString = 8,
        /// List contains values of different types.
        ProhibitedValueCombinationInList = 10,
        /// The values passed to the BETWEEN operator are not of the same type.
        ProhibitedValueCombinationWithBetweenOperator = 21,
        /// Query contains unterminated string.
        StringNotTerminated = 6,
        /// Too many segments are specified in SELECT clause.
        TooManySegments = 34,
        /// Query is incomplete and cannot be parsed.
        UnexpectedEndOfQuery = 9,
        /// FROM clause cannot be specified in this query.
        UnexpectedFromClause = 47,
        /// Query contains one or more unrecognized fields.
        UnrecognizedField = 32,
        /// Query has an unexpected extra part.
        UnexpectedInput = 11,
        /// Metrics cannot be requested for a manager account. To retrieve metrics,
        /// issue separate requests against each client account under the manager
        /// account.
        RequestedMetricsForManager = 59,
        /// The number of values (right-hand-side operands) in a filter exceeds the
        /// limit.
        FilterHasTooManyValues = 63,
    }
    impl QueryError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::QueryError => "QUERY_ERROR",
                Self::BadEnumConstant => "BAD_ENUM_CONSTANT",
                Self::BadEscapeSequence => "BAD_ESCAPE_SEQUENCE",
                Self::BadFieldName => "BAD_FIELD_NAME",
                Self::BadLimitValue => "BAD_LIMIT_VALUE",
                Self::BadNumber => "BAD_NUMBER",
                Self::BadOperator => "BAD_OPERATOR",
                Self::BadParameterName => "BAD_PARAMETER_NAME",
                Self::BadParameterValue => "BAD_PARAMETER_VALUE",
                Self::BadResourceTypeInFromClause => "BAD_RESOURCE_TYPE_IN_FROM_CLAUSE",
                Self::BadSymbol => "BAD_SYMBOL",
                Self::BadValue => "BAD_VALUE",
                Self::DateRangeTooWide => "DATE_RANGE_TOO_WIDE",
                Self::DateRangeTooNarrow => "DATE_RANGE_TOO_NARROW",
                Self::ExpectedAnd => "EXPECTED_AND",
                Self::ExpectedBy => "EXPECTED_BY",
                Self::ExpectedDimensionFieldInSelectClause => {
                    "EXPECTED_DIMENSION_FIELD_IN_SELECT_CLAUSE"
                }
                Self::ExpectedFiltersOnDateRange => "EXPECTED_FILTERS_ON_DATE_RANGE",
                Self::ExpectedFrom => "EXPECTED_FROM",
                Self::ExpectedList => "EXPECTED_LIST",
                Self::ExpectedReferencedFieldInSelectClause => {
                    "EXPECTED_REFERENCED_FIELD_IN_SELECT_CLAUSE"
                }
                Self::ExpectedSelect => "EXPECTED_SELECT",
                Self::ExpectedSingleValue => "EXPECTED_SINGLE_VALUE",
                Self::ExpectedValueWithBetweenOperator => {
                    "EXPECTED_VALUE_WITH_BETWEEN_OPERATOR"
                }
                Self::InvalidDateFormat => "INVALID_DATE_FORMAT",
                Self::MisalignedDateForFilter => "MISALIGNED_DATE_FOR_FILTER",
                Self::InvalidStringValue => "INVALID_STRING_VALUE",
                Self::InvalidValueWithBetweenOperator => {
                    "INVALID_VALUE_WITH_BETWEEN_OPERATOR"
                }
                Self::InvalidValueWithDuringOperator => {
                    "INVALID_VALUE_WITH_DURING_OPERATOR"
                }
                Self::InvalidValueWithLikeOperator => "INVALID_VALUE_WITH_LIKE_OPERATOR",
                Self::OperatorFieldMismatch => "OPERATOR_FIELD_MISMATCH",
                Self::ProhibitedEmptyListInCondition => {
                    "PROHIBITED_EMPTY_LIST_IN_CONDITION"
                }
                Self::ProhibitedEnumConstant => "PROHIBITED_ENUM_CONSTANT",
                Self::ProhibitedFieldCombinationInSelectClause => {
                    "PROHIBITED_FIELD_COMBINATION_IN_SELECT_CLAUSE"
                }
                Self::ProhibitedFieldInOrderByClause => {
                    "PROHIBITED_FIELD_IN_ORDER_BY_CLAUSE"
                }
                Self::ProhibitedFieldInSelectClause => {
                    "PROHIBITED_FIELD_IN_SELECT_CLAUSE"
                }
                Self::ProhibitedFieldInWhereClause => "PROHIBITED_FIELD_IN_WHERE_CLAUSE",
                Self::ProhibitedResourceTypeInFromClause => {
                    "PROHIBITED_RESOURCE_TYPE_IN_FROM_CLAUSE"
                }
                Self::ProhibitedResourceTypeInSelectClause => {
                    "PROHIBITED_RESOURCE_TYPE_IN_SELECT_CLAUSE"
                }
                Self::ProhibitedResourceTypeInWhereClause => {
                    "PROHIBITED_RESOURCE_TYPE_IN_WHERE_CLAUSE"
                }
                Self::ProhibitedMetricInSelectOrWhereClause => {
                    "PROHIBITED_METRIC_IN_SELECT_OR_WHERE_CLAUSE"
                }
                Self::ProhibitedSegmentInSelectOrWhereClause => {
                    "PROHIBITED_SEGMENT_IN_SELECT_OR_WHERE_CLAUSE"
                }
                Self::ProhibitedSegmentWithMetricInSelectOrWhereClause => {
                    "PROHIBITED_SEGMENT_WITH_METRIC_IN_SELECT_OR_WHERE_CLAUSE"
                }
                Self::LimitValueTooLow => "LIMIT_VALUE_TOO_LOW",
                Self::ProhibitedNewlineInString => "PROHIBITED_NEWLINE_IN_STRING",
                Self::ProhibitedValueCombinationInList => {
                    "PROHIBITED_VALUE_COMBINATION_IN_LIST"
                }
                Self::ProhibitedValueCombinationWithBetweenOperator => {
                    "PROHIBITED_VALUE_COMBINATION_WITH_BETWEEN_OPERATOR"
                }
                Self::StringNotTerminated => "STRING_NOT_TERMINATED",
                Self::TooManySegments => "TOO_MANY_SEGMENTS",
                Self::UnexpectedEndOfQuery => "UNEXPECTED_END_OF_QUERY",
                Self::UnexpectedFromClause => "UNEXPECTED_FROM_CLAUSE",
                Self::UnrecognizedField => "UNRECOGNIZED_FIELD",
                Self::UnexpectedInput => "UNEXPECTED_INPUT",
                Self::RequestedMetricsForManager => "REQUESTED_METRICS_FOR_MANAGER",
                Self::FilterHasTooManyValues => "FILTER_HAS_TOO_MANY_VALUES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "QUERY_ERROR" => Some(Self::QueryError),
                "BAD_ENUM_CONSTANT" => Some(Self::BadEnumConstant),
                "BAD_ESCAPE_SEQUENCE" => Some(Self::BadEscapeSequence),
                "BAD_FIELD_NAME" => Some(Self::BadFieldName),
                "BAD_LIMIT_VALUE" => Some(Self::BadLimitValue),
                "BAD_NUMBER" => Some(Self::BadNumber),
                "BAD_OPERATOR" => Some(Self::BadOperator),
                "BAD_PARAMETER_NAME" => Some(Self::BadParameterName),
                "BAD_PARAMETER_VALUE" => Some(Self::BadParameterValue),
                "BAD_RESOURCE_TYPE_IN_FROM_CLAUSE" => {
                    Some(Self::BadResourceTypeInFromClause)
                }
                "BAD_SYMBOL" => Some(Self::BadSymbol),
                "BAD_VALUE" => Some(Self::BadValue),
                "DATE_RANGE_TOO_WIDE" => Some(Self::DateRangeTooWide),
                "DATE_RANGE_TOO_NARROW" => Some(Self::DateRangeTooNarrow),
                "EXPECTED_AND" => Some(Self::ExpectedAnd),
                "EXPECTED_BY" => Some(Self::ExpectedBy),
                "EXPECTED_DIMENSION_FIELD_IN_SELECT_CLAUSE" => {
                    Some(Self::ExpectedDimensionFieldInSelectClause)
                }
                "EXPECTED_FILTERS_ON_DATE_RANGE" => {
                    Some(Self::ExpectedFiltersOnDateRange)
                }
                "EXPECTED_FROM" => Some(Self::ExpectedFrom),
                "EXPECTED_LIST" => Some(Self::ExpectedList),
                "EXPECTED_REFERENCED_FIELD_IN_SELECT_CLAUSE" => {
                    Some(Self::ExpectedReferencedFieldInSelectClause)
                }
                "EXPECTED_SELECT" => Some(Self::ExpectedSelect),
                "EXPECTED_SINGLE_VALUE" => Some(Self::ExpectedSingleValue),
                "EXPECTED_VALUE_WITH_BETWEEN_OPERATOR" => {
                    Some(Self::ExpectedValueWithBetweenOperator)
                }
                "INVALID_DATE_FORMAT" => Some(Self::InvalidDateFormat),
                "MISALIGNED_DATE_FOR_FILTER" => Some(Self::MisalignedDateForFilter),
                "INVALID_STRING_VALUE" => Some(Self::InvalidStringValue),
                "INVALID_VALUE_WITH_BETWEEN_OPERATOR" => {
                    Some(Self::InvalidValueWithBetweenOperator)
                }
                "INVALID_VALUE_WITH_DURING_OPERATOR" => {
                    Some(Self::InvalidValueWithDuringOperator)
                }
                "INVALID_VALUE_WITH_LIKE_OPERATOR" => {
                    Some(Self::InvalidValueWithLikeOperator)
                }
                "OPERATOR_FIELD_MISMATCH" => Some(Self::OperatorFieldMismatch),
                "PROHIBITED_EMPTY_LIST_IN_CONDITION" => {
                    Some(Self::ProhibitedEmptyListInCondition)
                }
                "PROHIBITED_ENUM_CONSTANT" => Some(Self::ProhibitedEnumConstant),
                "PROHIBITED_FIELD_COMBINATION_IN_SELECT_CLAUSE" => {
                    Some(Self::ProhibitedFieldCombinationInSelectClause)
                }
                "PROHIBITED_FIELD_IN_ORDER_BY_CLAUSE" => {
                    Some(Self::ProhibitedFieldInOrderByClause)
                }
                "PROHIBITED_FIELD_IN_SELECT_CLAUSE" => {
                    Some(Self::ProhibitedFieldInSelectClause)
                }
                "PROHIBITED_FIELD_IN_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedFieldInWhereClause)
                }
                "PROHIBITED_RESOURCE_TYPE_IN_FROM_CLAUSE" => {
                    Some(Self::ProhibitedResourceTypeInFromClause)
                }
                "PROHIBITED_RESOURCE_TYPE_IN_SELECT_CLAUSE" => {
                    Some(Self::ProhibitedResourceTypeInSelectClause)
                }
                "PROHIBITED_RESOURCE_TYPE_IN_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedResourceTypeInWhereClause)
                }
                "PROHIBITED_METRIC_IN_SELECT_OR_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedMetricInSelectOrWhereClause)
                }
                "PROHIBITED_SEGMENT_IN_SELECT_OR_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedSegmentInSelectOrWhereClause)
                }
                "PROHIBITED_SEGMENT_WITH_METRIC_IN_SELECT_OR_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedSegmentWithMetricInSelectOrWhereClause)
                }
                "LIMIT_VALUE_TOO_LOW" => Some(Self::LimitValueTooLow),
                "PROHIBITED_NEWLINE_IN_STRING" => Some(Self::ProhibitedNewlineInString),
                "PROHIBITED_VALUE_COMBINATION_IN_LIST" => {
                    Some(Self::ProhibitedValueCombinationInList)
                }
                "PROHIBITED_VALUE_COMBINATION_WITH_BETWEEN_OPERATOR" => {
                    Some(Self::ProhibitedValueCombinationWithBetweenOperator)
                }
                "STRING_NOT_TERMINATED" => Some(Self::StringNotTerminated),
                "TOO_MANY_SEGMENTS" => Some(Self::TooManySegments),
                "UNEXPECTED_END_OF_QUERY" => Some(Self::UnexpectedEndOfQuery),
                "UNEXPECTED_FROM_CLAUSE" => Some(Self::UnexpectedFromClause),
                "UNRECOGNIZED_FIELD" => Some(Self::UnrecognizedField),
                "UNEXPECTED_INPUT" => Some(Self::UnexpectedInput),
                "REQUESTED_METRICS_FOR_MANAGER" => Some(Self::RequestedMetricsForManager),
                "FILTER_HAS_TOO_MANY_VALUES" => Some(Self::FilterHasTooManyValues),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible quota errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuotaErrorEnum {}
/// Nested message and enum types in `QuotaErrorEnum`.
pub mod quota_error_enum {
    /// Enum describing possible quota errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum QuotaError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Too many requests.
        ResourceExhausted = 2,
        /// Too many requests in a short amount of time.
        ResourceTemporarilyExhausted = 4,
    }
    impl QuotaError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ResourceExhausted => "RESOURCE_EXHAUSTED",
                Self::ResourceTemporarilyExhausted => "RESOURCE_TEMPORARILY_EXHAUSTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RESOURCE_EXHAUSTED" => Some(Self::ResourceExhausted),
                "RESOURCE_TEMPORARILY_EXHAUSTED" => {
                    Some(Self::ResourceTemporarilyExhausted)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible request errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestErrorEnum {}
/// Nested message and enum types in `RequestErrorEnum`.
pub mod request_error_enum {
    /// Enum describing possible request errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RequestError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// Resource name is required for this request.
        ResourceNameMissing = 3,
        /// Resource name provided is malformed.
        ResourceNameMalformed = 4,
        /// Resource name provided is malformed.
        BadResourceId = 17,
        /// Product name is invalid.
        InvalidProductName = 35,
        /// Customer ID is invalid.
        InvalidCustomerId = 16,
        /// Mutate operation should have either create, update, or remove specified.
        OperationRequired = 5,
        /// Requested resource not found.
        ResourceNotFound = 6,
        /// Next page token specified in user request is invalid.
        InvalidPageToken = 7,
        /// Next page token specified in user request has expired.
        ExpiredPageToken = 8,
        /// Page size specified in user request is invalid.
        InvalidPageSize = 22,
        /// Required field is missing.
        RequiredFieldMissing = 9,
        /// The field cannot be modified because it's immutable. It's also possible
        /// that the field can be modified using 'create' operation but not 'update'.
        ImmutableField = 11,
        /// Received too many entries in request.
        TooManyMutateOperations = 13,
        /// Request cannot be executed by a manager account.
        CannotBeExecutedByManagerAccount = 14,
        /// Mutate request was attempting to modify a readonly field.
        /// For instance, Budget fields can be requested for Ad Group,
        /// but are read-only for adGroups:mutate.
        CannotModifyForeignField = 15,
        /// Enum value is not permitted.
        InvalidEnumValue = 18,
        /// The login-customer-id parameter is required for this request.
        LoginCustomerIdParameterMissing = 20,
        /// Either login-customer-id or linked-customer-id parameter is required for
        /// this request.
        LoginOrLinkedCustomerIdParameterRequired = 34,
        /// page_token is set in the validate only request
        ValidateOnlyRequestHasPageToken = 21,
        /// return_summary_row cannot be enabled if request did not select any
        /// metrics field.
        CannotReturnSummaryRowForRequestWithoutMetrics = 29,
        /// return_summary_row should not be enabled for validate only requests.
        CannotReturnSummaryRowForValidateOnlyRequests = 30,
        /// return_summary_row parameter value should be the same between requests
        /// with page_token field set and their original request.
        InconsistentReturnSummaryRowValue = 31,
        /// The total results count cannot be returned if it was not requested in the
        /// original request.
        TotalResultsCountNotOriginallyRequested = 32,
        /// Deadline specified by the client was too short.
        RpcDeadlineTooShort = 33,
        /// The product associated with the request is not supported for the current
        /// request.
        ProductNotSupported = 37,
    }
    impl RequestError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ResourceNameMissing => "RESOURCE_NAME_MISSING",
                Self::ResourceNameMalformed => "RESOURCE_NAME_MALFORMED",
                Self::BadResourceId => "BAD_RESOURCE_ID",
                Self::InvalidProductName => "INVALID_PRODUCT_NAME",
                Self::InvalidCustomerId => "INVALID_CUSTOMER_ID",
                Self::OperationRequired => "OPERATION_REQUIRED",
                Self::ResourceNotFound => "RESOURCE_NOT_FOUND",
                Self::InvalidPageToken => "INVALID_PAGE_TOKEN",
                Self::ExpiredPageToken => "EXPIRED_PAGE_TOKEN",
                Self::InvalidPageSize => "INVALID_PAGE_SIZE",
                Self::RequiredFieldMissing => "REQUIRED_FIELD_MISSING",
                Self::ImmutableField => "IMMUTABLE_FIELD",
                Self::TooManyMutateOperations => "TOO_MANY_MUTATE_OPERATIONS",
                Self::CannotBeExecutedByManagerAccount => {
                    "CANNOT_BE_EXECUTED_BY_MANAGER_ACCOUNT"
                }
                Self::CannotModifyForeignField => "CANNOT_MODIFY_FOREIGN_FIELD",
                Self::InvalidEnumValue => "INVALID_ENUM_VALUE",
                Self::LoginCustomerIdParameterMissing => {
                    "LOGIN_CUSTOMER_ID_PARAMETER_MISSING"
                }
                Self::LoginOrLinkedCustomerIdParameterRequired => {
                    "LOGIN_OR_LINKED_CUSTOMER_ID_PARAMETER_REQUIRED"
                }
                Self::ValidateOnlyRequestHasPageToken => {
                    "VALIDATE_ONLY_REQUEST_HAS_PAGE_TOKEN"
                }
                Self::CannotReturnSummaryRowForRequestWithoutMetrics => {
                    "CANNOT_RETURN_SUMMARY_ROW_FOR_REQUEST_WITHOUT_METRICS"
                }
                Self::CannotReturnSummaryRowForValidateOnlyRequests => {
                    "CANNOT_RETURN_SUMMARY_ROW_FOR_VALIDATE_ONLY_REQUESTS"
                }
                Self::InconsistentReturnSummaryRowValue => {
                    "INCONSISTENT_RETURN_SUMMARY_ROW_VALUE"
                }
                Self::TotalResultsCountNotOriginallyRequested => {
                    "TOTAL_RESULTS_COUNT_NOT_ORIGINALLY_REQUESTED"
                }
                Self::RpcDeadlineTooShort => "RPC_DEADLINE_TOO_SHORT",
                Self::ProductNotSupported => "PRODUCT_NOT_SUPPORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RESOURCE_NAME_MISSING" => Some(Self::ResourceNameMissing),
                "RESOURCE_NAME_MALFORMED" => Some(Self::ResourceNameMalformed),
                "BAD_RESOURCE_ID" => Some(Self::BadResourceId),
                "INVALID_PRODUCT_NAME" => Some(Self::InvalidProductName),
                "INVALID_CUSTOMER_ID" => Some(Self::InvalidCustomerId),
                "OPERATION_REQUIRED" => Some(Self::OperationRequired),
                "RESOURCE_NOT_FOUND" => Some(Self::ResourceNotFound),
                "INVALID_PAGE_TOKEN" => Some(Self::InvalidPageToken),
                "EXPIRED_PAGE_TOKEN" => Some(Self::ExpiredPageToken),
                "INVALID_PAGE_SIZE" => Some(Self::InvalidPageSize),
                "REQUIRED_FIELD_MISSING" => Some(Self::RequiredFieldMissing),
                "IMMUTABLE_FIELD" => Some(Self::ImmutableField),
                "TOO_MANY_MUTATE_OPERATIONS" => Some(Self::TooManyMutateOperations),
                "CANNOT_BE_EXECUTED_BY_MANAGER_ACCOUNT" => {
                    Some(Self::CannotBeExecutedByManagerAccount)
                }
                "CANNOT_MODIFY_FOREIGN_FIELD" => Some(Self::CannotModifyForeignField),
                "INVALID_ENUM_VALUE" => Some(Self::InvalidEnumValue),
                "LOGIN_CUSTOMER_ID_PARAMETER_MISSING" => {
                    Some(Self::LoginCustomerIdParameterMissing)
                }
                "LOGIN_OR_LINKED_CUSTOMER_ID_PARAMETER_REQUIRED" => {
                    Some(Self::LoginOrLinkedCustomerIdParameterRequired)
                }
                "VALIDATE_ONLY_REQUEST_HAS_PAGE_TOKEN" => {
                    Some(Self::ValidateOnlyRequestHasPageToken)
                }
                "CANNOT_RETURN_SUMMARY_ROW_FOR_REQUEST_WITHOUT_METRICS" => {
                    Some(Self::CannotReturnSummaryRowForRequestWithoutMetrics)
                }
                "CANNOT_RETURN_SUMMARY_ROW_FOR_VALIDATE_ONLY_REQUESTS" => {
                    Some(Self::CannotReturnSummaryRowForValidateOnlyRequests)
                }
                "INCONSISTENT_RETURN_SUMMARY_ROW_VALUE" => {
                    Some(Self::InconsistentReturnSummaryRowValue)
                }
                "TOTAL_RESULTS_COUNT_NOT_ORIGINALLY_REQUESTED" => {
                    Some(Self::TotalResultsCountNotOriginallyRequested)
                }
                "RPC_DEADLINE_TOO_SHORT" => Some(Self::RpcDeadlineTooShort),
                "PRODUCT_NOT_SUPPORTED" => Some(Self::ProductNotSupported),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible size limit errors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SizeLimitErrorEnum {}
/// Nested message and enum types in `SizeLimitErrorEnum`.
pub mod size_limit_error_enum {
    /// Enum describing possible size limit errors.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SizeLimitError {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The number of entries in the request exceeds the system limit, or the
        /// contents of the operations exceed transaction limits due to their size
        /// or complexity. Try reducing the number of entries per request.
        RequestSizeLimitExceeded = 2,
        /// The number of entries in the response exceeds the system limit.
        ResponseSizeLimitExceeded = 3,
    }
    impl SizeLimitError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::RequestSizeLimitExceeded => "REQUEST_SIZE_LIMIT_EXCEEDED",
                Self::ResponseSizeLimitExceeded => "RESPONSE_SIZE_LIMIT_EXCEEDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "REQUEST_SIZE_LIMIT_EXCEEDED" => Some(Self::RequestSizeLimitExceeded),
                "RESPONSE_SIZE_LIMIT_EXCEEDED" => Some(Self::ResponseSizeLimitExceeded),
                _ => None,
            }
        }
    }
}
/// Describes how a Search Ads 360 API call failed. It's returned inside
/// google.rpc.Status.details when a call fails.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAds360Failure {
    /// The list of errors that occurred.
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<SearchAds360Error>,
    /// The unique ID of the request that is used for debugging purposes.
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Search Ads 360-specific error.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAds360Error {
    /// An enum value that indicates which error occurred.
    #[prost(message, optional, tag = "1")]
    pub error_code: ::core::option::Option<ErrorCode>,
    /// A human-readable description of the error.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// The value that triggered the error.
    #[prost(message, optional, tag = "3")]
    pub trigger: ::core::option::Option<super::common::Value>,
    /// Describes the part of the request proto that caused the error.
    #[prost(message, optional, tag = "4")]
    pub location: ::core::option::Option<ErrorLocation>,
    /// Additional error details, which are returned by certain error codes. Most
    /// error codes do not include details.
    #[prost(message, optional, tag = "5")]
    pub details: ::core::option::Option<ErrorDetails>,
}
/// The error reason represented by type and enum.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ErrorCode {
    /// The list of error enums
    #[prost(
        oneof = "error_code::ErrorCode",
        tags = "1, 5, 9, 10, 11, 17, 33, 34, 35, 66, 118, 144, 175"
    )]
    pub error_code: ::core::option::Option<error_code::ErrorCode>,
}
/// Nested message and enum types in `ErrorCode`.
pub mod error_code {
    /// The list of error enums
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ErrorCode {
        /// An error caused by the request
        #[prost(enumeration = "super::request_error_enum::RequestError", tag = "1")]
        RequestError(i32),
        /// An error with the query
        #[prost(enumeration = "super::query_error_enum::QueryError", tag = "5")]
        QueryError(i32),
        /// An error encountered when trying to authorize a user.
        #[prost(
            enumeration = "super::authorization_error_enum::AuthorizationError",
            tag = "9"
        )]
        AuthorizationError(i32),
        /// An unexpected server-side error.
        #[prost(enumeration = "super::internal_error_enum::InternalError", tag = "10")]
        InternalError(i32),
        /// An error with the amount of quota remaining.
        #[prost(enumeration = "super::quota_error_enum::QuotaError", tag = "11")]
        QuotaError(i32),
        /// Indicates failure to properly authenticate user.
        #[prost(
            enumeration = "super::authentication_error_enum::AuthenticationError",
            tag = "17"
        )]
        AuthenticationError(i32),
        /// The reasons for the date error
        #[prost(enumeration = "super::date_error_enum::DateError", tag = "33")]
        DateError(i32),
        /// The reasons for the date range error
        #[prost(
            enumeration = "super::date_range_error_enum::DateRangeError",
            tag = "34"
        )]
        DateRangeError(i32),
        /// The reasons for the distinct error
        #[prost(enumeration = "super::distinct_error_enum::DistinctError", tag = "35")]
        DistinctError(i32),
        /// The reasons for the header error.
        #[prost(enumeration = "super::header_error_enum::HeaderError", tag = "66")]
        HeaderError(i32),
        /// The reasons for the size limit error
        #[prost(
            enumeration = "super::size_limit_error_enum::SizeLimitError",
            tag = "118"
        )]
        SizeLimitError(i32),
        /// The reasons for the custom column error
        #[prost(
            enumeration = "super::custom_column_error_enum::CustomColumnError",
            tag = "144"
        )]
        CustomColumnError(i32),
        /// The reasons for invalid parameter errors.
        #[prost(
            enumeration = "super::invalid_parameter_error_enum::InvalidParameterError",
            tag = "175"
        )]
        InvalidParameterError(i32),
    }
}
/// Describes the part of the request proto that caused the error.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorLocation {
    /// A field path that indicates which field was invalid in the request.
    #[prost(message, repeated, tag = "2")]
    pub field_path_elements: ::prost::alloc::vec::Vec<error_location::FieldPathElement>,
}
/// Nested message and enum types in `ErrorLocation`.
pub mod error_location {
    /// A part of a field path.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FieldPathElement {
        /// The name of a field or a oneof
        #[prost(string, tag = "1")]
        pub field_name: ::prost::alloc::string::String,
        /// If field_name is a repeated field, this is the element that failed
        #[prost(int32, optional, tag = "3")]
        pub index: ::core::option::Option<i32>,
    }
}
/// Additional error details.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorDetails {
    /// The error code that should have been returned, but wasn't. This is used
    /// when the error code is not published in the client specified version.
    #[prost(string, tag = "1")]
    pub unpublished_error_code: ::prost::alloc::string::String,
    /// Details on the quota error, including the scope (account or developer), the
    /// rate bucket name and the retry delay.
    #[prost(message, optional, tag = "4")]
    pub quota_error_details: ::core::option::Option<QuotaErrorDetails>,
}
/// Additional quota error details when there is QuotaError.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuotaErrorDetails {
    /// The rate scope of the quota limit.
    #[prost(enumeration = "quota_error_details::QuotaRateScope", tag = "1")]
    pub rate_scope: i32,
    /// The high level description of the quota bucket.
    /// Examples are "Get requests for standard access" or "Requests per account".
    #[prost(string, tag = "2")]
    pub rate_name: ::prost::alloc::string::String,
    /// Backoff period that customers should wait before sending next request.
    #[prost(message, optional, tag = "3")]
    pub retry_delay: ::core::option::Option<::prost_types::Duration>,
}
/// Nested message and enum types in `QuotaErrorDetails`.
pub mod quota_error_details {
    /// Enum of possible scopes that quota buckets belong to.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum QuotaRateScope {
        /// Unspecified enum
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Per customer account quota
        Account = 2,
        /// Per project quota
        Developer = 3,
    }
    impl QuotaRateScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Account => "ACCOUNT",
                Self::Developer => "DEVELOPER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACCOUNT" => Some(Self::Account),
                "DEVELOPER" => Some(Self::Developer),
                _ => None,
            }
        }
    }
}
