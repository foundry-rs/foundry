// This file is @generated by prost-build.
/// **Anthos Config Management**: State for a single cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MembershipState {
    /// This field is set to the `cluster_name` field of the Membership Spec if it
    /// is not empty. Otherwise, it is set to the cluster's fleet membership name.
    #[prost(string, tag = "1")]
    pub cluster_name: ::prost::alloc::string::String,
    /// Membership configuration in the cluster. This represents the actual state
    /// in the cluster, while the MembershipSpec in the FeatureSpec represents
    /// the intended state
    #[prost(message, optional, tag = "2")]
    pub membership_spec: ::core::option::Option<MembershipSpec>,
    /// Current install status of ACM's Operator
    #[prost(message, optional, tag = "3")]
    pub operator_state: ::core::option::Option<OperatorState>,
    /// Current sync status
    #[prost(message, optional, tag = "4")]
    pub config_sync_state: ::core::option::Option<ConfigSyncState>,
    /// PolicyController status
    #[prost(message, optional, tag = "5")]
    pub policy_controller_state: ::core::option::Option<PolicyControllerState>,
    /// Hierarchy Controller status
    #[prost(message, optional, tag = "7")]
    pub hierarchy_controller_state: ::core::option::Option<HierarchyControllerState>,
}
/// **Anthos Config Management**: Configuration for a single cluster.
/// Intended to parallel the ConfigManagement CR.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MembershipSpec {
    /// Config Sync configuration for the cluster.
    #[prost(message, optional, tag = "1")]
    pub config_sync: ::core::option::Option<ConfigSync>,
    /// Policy Controller configuration for the cluster.
    #[prost(message, optional, tag = "2")]
    pub policy_controller: ::core::option::Option<PolicyController>,
    /// Hierarchy Controller configuration for the cluster.
    #[prost(message, optional, tag = "4")]
    pub hierarchy_controller: ::core::option::Option<HierarchyControllerConfig>,
    /// Version of ACM installed.
    #[prost(string, tag = "10")]
    pub version: ::prost::alloc::string::String,
    /// The user-specified cluster name used by Config Sync cluster-name-selector
    /// annotation or ClusterSelector, for applying configs to only a subset
    /// of clusters.
    /// Omit this field if the cluster's fleet membership name is used by Config
    /// Sync cluster-name-selector annotation or ClusterSelector.
    /// Set this field if a name different from the cluster's fleet membership name
    /// is used by Config Sync cluster-name-selector annotation or ClusterSelector.
    #[prost(string, tag = "11")]
    pub cluster: ::prost::alloc::string::String,
    /// Enables automatic Feature management.
    #[prost(enumeration = "membership_spec::Management", tag = "12")]
    pub management: i32,
}
/// Nested message and enum types in `MembershipSpec`.
pub mod membership_spec {
    /// Whether to automatically manage the Feature.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Management {
        /// Unspecified
        Unspecified = 0,
        /// Google will manage the Feature for the cluster.
        Automatic = 1,
        /// User will manually manage the Feature for the cluster.
        Manual = 2,
    }
    impl Management {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MANAGEMENT_UNSPECIFIED",
                Self::Automatic => "MANAGEMENT_AUTOMATIC",
                Self::Manual => "MANAGEMENT_MANUAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MANAGEMENT_UNSPECIFIED" => Some(Self::Unspecified),
                "MANAGEMENT_AUTOMATIC" => Some(Self::Automatic),
                "MANAGEMENT_MANUAL" => Some(Self::Manual),
                _ => None,
            }
        }
    }
}
/// Configuration for Config Sync
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigSync {
    /// Git repo configuration for the cluster.
    #[prost(message, optional, tag = "7")]
    pub git: ::core::option::Option<GitConfig>,
    /// Specifies whether the Config Sync Repo is
    /// in "hierarchical" or "unstructured" mode.
    #[prost(string, tag = "8")]
    pub source_format: ::prost::alloc::string::String,
    /// Enables the installation of ConfigSync.
    /// If set to true, ConfigSync resources will be created and the other
    /// ConfigSync fields will be applied if exist.
    /// If set to false, all other ConfigSync fields will be ignored, ConfigSync
    /// resources will be deleted.
    /// If omitted, ConfigSync resources will be managed depends on the presence
    /// of the git or oci field.
    #[prost(bool, optional, tag = "10")]
    pub enabled: ::core::option::Option<bool>,
    /// Set to true to enable the Config Sync admission webhook to prevent drifts.
    /// If set to `false`, disables the Config Sync admission webhook and does not
    /// prevent drifts.
    #[prost(bool, tag = "11")]
    pub prevent_drift: bool,
    /// OCI repo configuration for the cluster
    #[prost(message, optional, tag = "12")]
    pub oci: ::core::option::Option<OciConfig>,
    /// The Email of the Google Cloud Service Account (GSA) used for exporting
    /// Config Sync metrics to Cloud Monitoring when Workload Identity is enabled.
    /// The GSA should have the Monitoring Metric Writer
    /// (roles/monitoring.metricWriter) IAM role.
    /// The Kubernetes ServiceAccount `default` in the namespace
    /// `config-management-monitoring` should be bound to the GSA.
    #[prost(string, tag = "15")]
    pub metrics_gcp_service_account_email: ::prost::alloc::string::String,
}
/// Git repo configuration for a single cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitConfig {
    /// The URL of the Git repository to use as the source of truth.
    #[prost(string, tag = "1")]
    pub sync_repo: ::prost::alloc::string::String,
    /// The branch of the repository to sync from. Default: master.
    #[prost(string, tag = "2")]
    pub sync_branch: ::prost::alloc::string::String,
    /// The path within the Git repository that represents the top level of the
    /// repo to sync. Default: the root directory of the repository.
    #[prost(string, tag = "3")]
    pub policy_dir: ::prost::alloc::string::String,
    /// Period in seconds between consecutive syncs. Default: 15.
    #[prost(int64, tag = "4")]
    pub sync_wait_secs: i64,
    /// Git revision (tag or hash) to check out. Default HEAD.
    #[prost(string, tag = "5")]
    pub sync_rev: ::prost::alloc::string::String,
    /// Type of secret configured for access to the Git repo. Must be one of ssh,
    /// cookiefile, gcenode, token, gcpserviceaccount or none. The
    /// validation of this is case-sensitive. Required.
    #[prost(string, tag = "6")]
    pub secret_type: ::prost::alloc::string::String,
    /// URL for the HTTPS proxy to be used when communicating with the Git repo.
    #[prost(string, tag = "7")]
    pub https_proxy: ::prost::alloc::string::String,
    /// The Google Cloud Service Account Email used for auth when secret_type is
    /// gcpServiceAccount.
    #[prost(string, tag = "8")]
    pub gcp_service_account_email: ::prost::alloc::string::String,
}
/// OCI repo configuration for a single cluster
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OciConfig {
    /// The OCI image repository URL for the package to sync from.
    /// e.g. `LOCATION-docker.pkg.dev/PROJECT_ID/REPOSITORY_NAME/PACKAGE_NAME`.
    #[prost(string, tag = "1")]
    pub sync_repo: ::prost::alloc::string::String,
    /// The absolute path of the directory that contains
    /// the local resources.  Default: the root directory of the image.
    #[prost(string, tag = "2")]
    pub policy_dir: ::prost::alloc::string::String,
    /// Period in seconds between consecutive syncs. Default: 15.
    #[prost(int64, tag = "3")]
    pub sync_wait_secs: i64,
    /// Type of secret configured for access to the Git repo.
    #[prost(string, tag = "4")]
    pub secret_type: ::prost::alloc::string::String,
    /// The Google Cloud Service Account Email used for auth when secret_type is
    /// gcpServiceAccount.
    #[prost(string, tag = "5")]
    pub gcp_service_account_email: ::prost::alloc::string::String,
}
/// Configuration for Policy Controller
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyController {
    /// Enables the installation of Policy Controller.
    /// If false, the rest of PolicyController fields take no
    /// effect.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Installs the default template library along with Policy Controller.
    #[prost(bool, optional, tag = "2")]
    pub template_library_installed: ::core::option::Option<bool>,
    /// Sets the interval for Policy Controller Audit Scans (in seconds).
    /// When set to 0, this disables audit functionality altogether.
    #[prost(int64, optional, tag = "3")]
    pub audit_interval_seconds: ::core::option::Option<i64>,
    /// The set of namespaces that are excluded from Policy Controller checks.
    /// Namespaces do not need to currently exist on the cluster.
    #[prost(string, repeated, tag = "4")]
    pub exemptable_namespaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Enables the ability to use Constraint Templates that reference to objects
    /// other than the object currently being evaluated.
    #[prost(bool, tag = "5")]
    pub referential_rules_enabled: bool,
    /// Logs all denies and dry run failures.
    #[prost(bool, tag = "6")]
    pub log_denies_enabled: bool,
}
/// Configuration for Hierarchy Controller
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HierarchyControllerConfig {
    /// Whether Hierarchy Controller is enabled in this cluster.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Whether pod tree labels are enabled in this cluster.
    #[prost(bool, tag = "2")]
    pub enable_pod_tree_labels: bool,
    /// Whether hierarchical resource quota is enabled in this cluster.
    #[prost(bool, tag = "3")]
    pub enable_hierarchical_resource_quota: bool,
}
/// Deployment state for Hierarchy Controller
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HierarchyControllerDeploymentState {
    /// The deployment state for open source HNC (e.g. v0.7.0-hc.0)
    #[prost(enumeration = "DeploymentState", tag = "1")]
    pub hnc: i32,
    /// The deployment state for Hierarchy Controller extension (e.g. v0.7.0-hc.1)
    #[prost(enumeration = "DeploymentState", tag = "2")]
    pub extension: i32,
}
/// Version for Hierarchy Controller
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HierarchyControllerVersion {
    /// Version for open source HNC
    #[prost(string, tag = "1")]
    pub hnc: ::prost::alloc::string::String,
    /// Version for Hierarchy Controller extension
    #[prost(string, tag = "2")]
    pub extension: ::prost::alloc::string::String,
}
/// State for Hierarchy Controller
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HierarchyControllerState {
    /// The version for Hierarchy Controller
    #[prost(message, optional, tag = "1")]
    pub version: ::core::option::Option<HierarchyControllerVersion>,
    /// The deployment state for Hierarchy Controller
    #[prost(message, optional, tag = "2")]
    pub state: ::core::option::Option<HierarchyControllerDeploymentState>,
}
/// State information for an ACM's Operator
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperatorState {
    /// The semenatic version number of the operator
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// The state of the Operator's deployment
    #[prost(enumeration = "DeploymentState", tag = "2")]
    pub deployment_state: i32,
    /// Install errors.
    #[prost(message, repeated, tag = "3")]
    pub errors: ::prost::alloc::vec::Vec<InstallError>,
}
/// Errors pertaining to the installation of ACM
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallError {
    /// A string representing the user facing error message
    #[prost(string, tag = "1")]
    pub error_message: ::prost::alloc::string::String,
}
/// State information for ConfigSync
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigSyncState {
    /// The version of ConfigSync deployed
    #[prost(message, optional, tag = "1")]
    pub version: ::core::option::Option<ConfigSyncVersion>,
    /// Information about the deployment of ConfigSync, including the version
    /// of the various Pods deployed
    #[prost(message, optional, tag = "2")]
    pub deployment_state: ::core::option::Option<ConfigSyncDeploymentState>,
    /// The state of ConfigSync's process to sync configs to a cluster
    #[prost(message, optional, tag = "3")]
    pub sync_state: ::core::option::Option<SyncState>,
    /// Errors pertaining to the installation of Config Sync.
    #[prost(message, repeated, tag = "4")]
    pub errors: ::prost::alloc::vec::Vec<ConfigSyncError>,
    /// The state of the RootSync CRD
    #[prost(enumeration = "config_sync_state::CrdState", tag = "5")]
    pub rootsync_crd: i32,
    /// The state of the Reposync CRD
    #[prost(enumeration = "config_sync_state::CrdState", tag = "6")]
    pub reposync_crd: i32,
    /// The state of CS
    /// This field summarizes the other fields in this message.
    #[prost(enumeration = "config_sync_state::State", tag = "7")]
    pub state: i32,
}
/// Nested message and enum types in `ConfigSyncState`.
pub mod config_sync_state {
    /// CRDState representing the state of a CRD
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CrdState {
        /// CRD's state cannot be determined
        Unspecified = 0,
        /// CRD is not installed
        NotInstalled = 1,
        /// CRD is installed
        Installed = 2,
        /// CRD is terminating (i.e., it has been deleted and is cleaning up)
        Terminating = 3,
        /// CRD is installing
        Installing = 4,
    }
    impl CrdState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CRD_STATE_UNSPECIFIED",
                Self::NotInstalled => "NOT_INSTALLED",
                Self::Installed => "INSTALLED",
                Self::Terminating => "TERMINATING",
                Self::Installing => "INSTALLING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CRD_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "NOT_INSTALLED" => Some(Self::NotInstalled),
                "INSTALLED" => Some(Self::Installed),
                "TERMINATING" => Some(Self::Terminating),
                "INSTALLING" => Some(Self::Installing),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// CS's state cannot be determined.
        Unspecified = 0,
        /// CS is not installed.
        ConfigSyncNotInstalled = 1,
        /// The expected CS version is installed successfully.
        ConfigSyncInstalled = 2,
        /// CS encounters errors.
        ConfigSyncError = 3,
        /// CS is installing or terminating.
        ConfigSyncPending = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::ConfigSyncNotInstalled => "CONFIG_SYNC_NOT_INSTALLED",
                Self::ConfigSyncInstalled => "CONFIG_SYNC_INSTALLED",
                Self::ConfigSyncError => "CONFIG_SYNC_ERROR",
                Self::ConfigSyncPending => "CONFIG_SYNC_PENDING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CONFIG_SYNC_NOT_INSTALLED" => Some(Self::ConfigSyncNotInstalled),
                "CONFIG_SYNC_INSTALLED" => Some(Self::ConfigSyncInstalled),
                "CONFIG_SYNC_ERROR" => Some(Self::ConfigSyncError),
                "CONFIG_SYNC_PENDING" => Some(Self::ConfigSyncPending),
                _ => None,
            }
        }
    }
}
/// Errors pertaining to the installation of Config Sync
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigSyncError {
    /// A string representing the user facing error message
    #[prost(string, tag = "1")]
    pub error_message: ::prost::alloc::string::String,
}
/// Specific versioning information pertaining to ConfigSync's Pods
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigSyncVersion {
    /// Version of the deployed importer pod
    #[prost(string, tag = "1")]
    pub importer: ::prost::alloc::string::String,
    /// Version of the deployed syncer pod
    #[prost(string, tag = "2")]
    pub syncer: ::prost::alloc::string::String,
    /// Version of the deployed git-sync pod
    #[prost(string, tag = "3")]
    pub git_sync: ::prost::alloc::string::String,
    /// Version of the deployed monitor pod
    #[prost(string, tag = "4")]
    pub monitor: ::prost::alloc::string::String,
    /// Version of the deployed reconciler-manager pod
    #[prost(string, tag = "5")]
    pub reconciler_manager: ::prost::alloc::string::String,
    /// Version of the deployed reconciler container in root-reconciler pod
    #[prost(string, tag = "6")]
    pub root_reconciler: ::prost::alloc::string::String,
    /// Version of the deployed admission_webhook pod
    #[prost(string, tag = "7")]
    pub admission_webhook: ::prost::alloc::string::String,
}
/// The state of ConfigSync's deployment on a cluster
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConfigSyncDeploymentState {
    /// Deployment state of the importer pod
    #[prost(enumeration = "DeploymentState", tag = "1")]
    pub importer: i32,
    /// Deployment state of the syncer pod
    #[prost(enumeration = "DeploymentState", tag = "2")]
    pub syncer: i32,
    /// Deployment state of the git-sync pod
    #[prost(enumeration = "DeploymentState", tag = "3")]
    pub git_sync: i32,
    /// Deployment state of the monitor pod
    #[prost(enumeration = "DeploymentState", tag = "4")]
    pub monitor: i32,
    /// Deployment state of reconciler-manager pod
    #[prost(enumeration = "DeploymentState", tag = "5")]
    pub reconciler_manager: i32,
    /// Deployment state of root-reconciler
    #[prost(enumeration = "DeploymentState", tag = "6")]
    pub root_reconciler: i32,
    /// Deployment state of admission-webhook
    #[prost(enumeration = "DeploymentState", tag = "7")]
    pub admission_webhook: i32,
}
/// State indicating an ACM's progress syncing configurations to a cluster
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncState {
    /// Token indicating the state of the repo.
    #[prost(string, tag = "1")]
    pub source_token: ::prost::alloc::string::String,
    /// Token indicating the state of the importer.
    #[prost(string, tag = "2")]
    pub import_token: ::prost::alloc::string::String,
    /// Token indicating the state of the syncer.
    #[prost(string, tag = "3")]
    pub sync_token: ::prost::alloc::string::String,
    /// Deprecated: use last_sync_time instead.
    /// Timestamp of when ACM last successfully synced the repo
    /// The time format is specified in <https://golang.org/pkg/time/#Time.String>
    #[deprecated]
    #[prost(string, tag = "4")]
    pub last_sync: ::prost::alloc::string::String,
    /// Timestamp type of when ACM last successfully synced the repo
    #[prost(message, optional, tag = "7")]
    pub last_sync_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Sync status code
    #[prost(enumeration = "sync_state::SyncCode", tag = "5")]
    pub code: i32,
    /// A list of errors resulting from problematic configs.
    /// This list will be truncated after 100 errors, although it is
    /// unlikely for that many errors to simultaneously exist.
    #[prost(message, repeated, tag = "6")]
    pub errors: ::prost::alloc::vec::Vec<SyncError>,
}
/// Nested message and enum types in `SyncState`.
pub mod sync_state {
    /// An enum representing Config Sync's status of syncing configs to a cluster.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SyncCode {
        /// Config Sync cannot determine a sync code
        Unspecified = 0,
        /// Config Sync successfully synced the git Repo with the cluster
        Synced = 1,
        /// Config Sync is in the progress of syncing a new change
        Pending = 2,
        /// Indicates an error configuring Config Sync, and user action is required
        Error = 3,
        /// Config Sync has been installed but not configured
        NotConfigured = 4,
        /// Config Sync has not been installed
        NotInstalled = 5,
        /// Error authorizing with the cluster
        Unauthorized = 6,
        /// Cluster could not be reached
        Unreachable = 7,
    }
    impl SyncCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SYNC_CODE_UNSPECIFIED",
                Self::Synced => "SYNCED",
                Self::Pending => "PENDING",
                Self::Error => "ERROR",
                Self::NotConfigured => "NOT_CONFIGURED",
                Self::NotInstalled => "NOT_INSTALLED",
                Self::Unauthorized => "UNAUTHORIZED",
                Self::Unreachable => "UNREACHABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SYNC_CODE_UNSPECIFIED" => Some(Self::Unspecified),
                "SYNCED" => Some(Self::Synced),
                "PENDING" => Some(Self::Pending),
                "ERROR" => Some(Self::Error),
                "NOT_CONFIGURED" => Some(Self::NotConfigured),
                "NOT_INSTALLED" => Some(Self::NotInstalled),
                "UNAUTHORIZED" => Some(Self::Unauthorized),
                "UNREACHABLE" => Some(Self::Unreachable),
                _ => None,
            }
        }
    }
}
/// An ACM created error representing a problem syncing configurations
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncError {
    /// An ACM defined error code
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    /// A description of the error
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
    /// A list of config(s) associated with the error, if any
    #[prost(message, repeated, tag = "3")]
    pub error_resources: ::prost::alloc::vec::Vec<ErrorResource>,
}
/// Model for a config file in the git repo with an associated Sync error
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorResource {
    /// Path in the git repo of the erroneous config
    #[prost(string, tag = "1")]
    pub source_path: ::prost::alloc::string::String,
    /// Metadata name of the resource that is causing an error
    #[prost(string, tag = "2")]
    pub resource_name: ::prost::alloc::string::String,
    /// Namespace of the resource that is causing an error
    #[prost(string, tag = "3")]
    pub resource_namespace: ::prost::alloc::string::String,
    /// Group/version/kind of the resource that is causing an error
    #[prost(message, optional, tag = "4")]
    pub resource_gvk: ::core::option::Option<GroupVersionKind>,
}
/// A Kubernetes object's GVK
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupVersionKind {
    /// Kubernetes Group
    #[prost(string, tag = "1")]
    pub group: ::prost::alloc::string::String,
    /// Kubernetes Version
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// Kubernetes Kind
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
}
/// State for PolicyControllerState.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyControllerState {
    /// The version of Gatekeeper Policy Controller deployed.
    #[prost(message, optional, tag = "1")]
    pub version: ::core::option::Option<PolicyControllerVersion>,
    /// The state about the policy controller installation.
    #[prost(message, optional, tag = "2")]
    pub deployment_state: ::core::option::Option<GatekeeperDeploymentState>,
}
/// The build version of Gatekeeper Policy Controller is using.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyControllerVersion {
    /// The gatekeeper image tag that is composed of ACM version, git tag, build
    /// number.
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
}
/// State of Policy Controller installation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GatekeeperDeploymentState {
    /// Status of gatekeeper-controller-manager pod.
    #[prost(enumeration = "DeploymentState", tag = "1")]
    pub gatekeeper_controller_manager_state: i32,
    /// Status of gatekeeper-audit deployment.
    #[prost(enumeration = "DeploymentState", tag = "2")]
    pub gatekeeper_audit: i32,
}
/// Enum representing the state of an ACM's deployment on a cluster
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeploymentState {
    /// Deployment's state cannot be determined
    Unspecified = 0,
    /// Deployment is not installed
    NotInstalled = 1,
    /// Deployment is installed
    Installed = 2,
    /// Deployment was attempted to be installed, but has errors
    Error = 3,
    /// Deployment is installing or terminating
    Pending = 4,
}
impl DeploymentState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DEPLOYMENT_STATE_UNSPECIFIED",
            Self::NotInstalled => "NOT_INSTALLED",
            Self::Installed => "INSTALLED",
            Self::Error => "ERROR",
            Self::Pending => "PENDING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEPLOYMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "NOT_INSTALLED" => Some(Self::NotInstalled),
            "INSTALLED" => Some(Self::Installed),
            "ERROR" => Some(Self::Error),
            "PENDING" => Some(Self::Pending),
            _ => None,
        }
    }
}
