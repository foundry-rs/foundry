// This file is @generated by prost-build.
/// Message describing Template resource
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Template {
    /// Identifier. name of resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. \[Output only\] Create time stamp
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. \[Output only\] Update time stamp
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels as key value pairs
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. filter configuration for this template
    #[prost(message, optional, tag = "5")]
    pub filter_config: ::core::option::Option<FilterConfig>,
    /// Optional. metadata for this template
    #[prost(message, optional, tag = "6")]
    pub template_metadata: ::core::option::Option<template::TemplateMetadata>,
}
/// Nested message and enum types in `Template`.
pub mod template {
    /// Message describing TemplateMetadata
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TemplateMetadata {
        /// Optional. If true, partial detector failures should be ignored.
        #[prost(bool, tag = "1")]
        pub ignore_partial_invocation_failures: bool,
        /// Optional. Indicates the custom error code set by the user to be returned
        /// to the end user by the service extension if the prompt trips Model Armor
        /// filters.
        #[prost(int32, tag = "2")]
        pub custom_prompt_safety_error_code: i32,
        /// Optional. Indicates the custom error message set by the user to be
        /// returned to the end user if the prompt trips Model Armor filters.
        #[prost(string, tag = "3")]
        pub custom_prompt_safety_error_message: ::prost::alloc::string::String,
        /// Optional. Indicates the custom error code set by the user to be returned
        /// to the end user if the LLM response trips Model Armor filters.
        #[prost(int32, tag = "4")]
        pub custom_llm_response_safety_error_code: i32,
        /// Optional. Indicates the custom error message set by the user to be
        /// returned to the end user if the LLM response trips Model Armor filters.
        #[prost(string, tag = "5")]
        pub custom_llm_response_safety_error_message: ::prost::alloc::string::String,
        /// Optional. If true, log template crud operations.
        #[prost(bool, tag = "6")]
        pub log_template_operations: bool,
        /// Optional. If true, log sanitize operations.
        #[prost(bool, tag = "7")]
        pub log_sanitize_operations: bool,
    }
}
/// Message describing FloorSetting resource
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FloorSetting {
    /// Identifier. The resource name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. \[Output only\] Create timestamp
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. \[Output only\] Update timestamp
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. ModelArmor filter configuration.
    #[prost(message, optional, tag = "4")]
    pub filter_config: ::core::option::Option<FilterConfig>,
    /// Optional. Floor Settings enforcement status.
    #[prost(bool, tag = "5")]
    pub enable_floor_setting_enforcement: bool,
}
/// Message for requesting list of Templates
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTemplatesRequest {
    /// Required. Parent value for ListTemplatesRequest
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing Templates
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTemplatesResponse {
    /// The list of Template
    #[prost(message, repeated, tag = "1")]
    pub templates: ::prost::alloc::vec::Vec<Template>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a Template
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTemplateRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for creating a Template
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTemplateRequest {
    /// Required. Value for parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// template_id from the method_signature of Create RPC
    #[prost(string, tag = "2")]
    pub template_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub template: ::core::option::Option<Template>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server stores the
    /// request ID for 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for updating a Template
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTemplateRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Template resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated
    #[prost(message, optional, tag = "2")]
    pub template: ::core::option::Option<Template>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server stores the
    /// request ID for 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting a Template
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTemplateRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server stores the
    /// request ID for 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for getting a Floor Setting
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFloorSettingRequest {
    /// Required. The name of the floor setting to get, example
    /// projects/123/floorsetting.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for Updating a Floor Setting
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFloorSettingRequest {
    /// Required. The floor setting being updated.
    #[prost(message, optional, tag = "1")]
    pub floor_setting: ::core::option::Option<FloorSetting>,
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// FloorSetting resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Filters configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterConfig {
    /// Optional. Responsible AI settings.
    #[prost(message, optional, tag = "1")]
    pub rai_settings: ::core::option::Option<RaiFilterSettings>,
    /// Optional. Sensitive Data Protection settings.
    #[prost(message, optional, tag = "2")]
    pub sdp_settings: ::core::option::Option<SdpFilterSettings>,
    /// Optional. Prompt injection and Jailbreak filter settings.
    #[prost(message, optional, tag = "3")]
    pub pi_and_jailbreak_filter_settings: ::core::option::Option<
        PiAndJailbreakFilterSettings,
    >,
    /// Optional. Malicious URI filter settings.
    #[prost(message, optional, tag = "4")]
    pub malicious_uri_filter_settings: ::core::option::Option<
        MaliciousUriFilterSettings,
    >,
}
/// Prompt injection and Jailbreak Filter settings.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PiAndJailbreakFilterSettings {
    /// Optional. Tells whether Prompt injection and Jailbreak filter is enabled or
    /// disabled.
    #[prost(
        enumeration = "pi_and_jailbreak_filter_settings::PiAndJailbreakFilterEnforcement",
        tag = "1"
    )]
    pub filter_enforcement: i32,
    /// Optional. Confidence level for this filter.
    /// Confidence level is used to determine the threshold for the filter. If
    /// detection confidence is equal to or greater than the specified level, a
    /// positive match is reported. Confidence level will only be used if the
    /// filter is enabled.
    #[prost(enumeration = "DetectionConfidenceLevel", tag = "3")]
    pub confidence_level: i32,
}
/// Nested message and enum types in `PiAndJailbreakFilterSettings`.
pub mod pi_and_jailbreak_filter_settings {
    /// Option to specify the state of Prompt Injection and Jailbreak filter
    /// (ENABLED/DISABLED).
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PiAndJailbreakFilterEnforcement {
        /// Same as Disabled
        Unspecified = 0,
        /// Enabled
        Enabled = 1,
        /// Enabled
        Disabled = 2,
    }
    impl PiAndJailbreakFilterEnforcement {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PI_AND_JAILBREAK_FILTER_ENFORCEMENT_UNSPECIFIED",
                Self::Enabled => "ENABLED",
                Self::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PI_AND_JAILBREAK_FILTER_ENFORCEMENT_UNSPECIFIED" => {
                    Some(Self::Unspecified)
                }
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
/// Malicious URI filter settings.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaliciousUriFilterSettings {
    /// Optional. Tells whether the Malicious URI filter is enabled or disabled.
    #[prost(
        enumeration = "malicious_uri_filter_settings::MaliciousUriFilterEnforcement",
        tag = "1"
    )]
    pub filter_enforcement: i32,
}
/// Nested message and enum types in `MaliciousUriFilterSettings`.
pub mod malicious_uri_filter_settings {
    /// Option to specify the state of Malicious URI filter (ENABLED/DISABLED).
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MaliciousUriFilterEnforcement {
        /// Same as Disabled
        Unspecified = 0,
        /// Enabled
        Enabled = 1,
        /// Disabled
        Disabled = 2,
    }
    impl MaliciousUriFilterEnforcement {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MALICIOUS_URI_FILTER_ENFORCEMENT_UNSPECIFIED",
                Self::Enabled => "ENABLED",
                Self::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MALICIOUS_URI_FILTER_ENFORCEMENT_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
/// Responsible AI Filter settings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RaiFilterSettings {
    /// Required. List of Responsible AI filters enabled for template.
    #[prost(message, repeated, tag = "1")]
    pub rai_filters: ::prost::alloc::vec::Vec<rai_filter_settings::RaiFilter>,
}
/// Nested message and enum types in `RaiFilterSettings`.
pub mod rai_filter_settings {
    /// Responsible AI filter.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RaiFilter {
        /// Required. Type of responsible AI filter.
        #[prost(enumeration = "super::RaiFilterType", tag = "1")]
        pub filter_type: i32,
        /// Optional. Confidence level for this RAI filter.
        /// During data sanitization, if data is classified under this filter with a
        /// confidence level equal to or greater than the specified level, a positive
        /// match is reported. If the confidence level is unspecified (i.e., 0), the
        /// system will use a reasonable default level based on the `filter_type`.
        #[prost(enumeration = "super::DetectionConfidenceLevel", tag = "2")]
        pub confidence_level: i32,
    }
}
/// Sensitive Data Protection settings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SdpFilterSettings {
    /// Either of Sensitive Data Protection basic or advanced configuration.
    #[prost(oneof = "sdp_filter_settings::SdpConfiguration", tags = "1, 2")]
    pub sdp_configuration: ::core::option::Option<sdp_filter_settings::SdpConfiguration>,
}
/// Nested message and enum types in `SdpFilterSettings`.
pub mod sdp_filter_settings {
    /// Either of Sensitive Data Protection basic or advanced configuration.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SdpConfiguration {
        /// Optional. Basic Sensitive Data Protection configuration inspects the
        /// content for sensitive data using a fixed set of six info-types. Sensitive
        /// Data Protection templates cannot be used with basic configuration. Only
        /// Sensitive Data Protection inspection operation is supported with basic
        /// configuration.
        #[prost(message, tag = "1")]
        BasicConfig(super::SdpBasicConfig),
        /// Optional. Advanced Sensitive Data Protection configuration which enables
        /// use of Sensitive Data Protection templates. Supports both Sensitive Data
        /// Protection inspection and de-identification operations.
        #[prost(message, tag = "2")]
        AdvancedConfig(super::SdpAdvancedConfig),
    }
}
/// Sensitive Data Protection basic configuration.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SdpBasicConfig {
    /// Optional. Tells whether the Sensitive Data Protection basic config is
    /// enabled or disabled.
    #[prost(enumeration = "sdp_basic_config::SdpBasicConfigEnforcement", tag = "3")]
    pub filter_enforcement: i32,
}
/// Nested message and enum types in `SdpBasicConfig`.
pub mod sdp_basic_config {
    /// Option to specify the state of Sensitive Data Protection basic config
    /// (ENABLED/DISABLED).
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SdpBasicConfigEnforcement {
        /// Same as Disabled
        Unspecified = 0,
        /// Enabled
        Enabled = 1,
        /// Disabled
        Disabled = 2,
    }
    impl SdpBasicConfigEnforcement {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SDP_BASIC_CONFIG_ENFORCEMENT_UNSPECIFIED",
                Self::Enabled => "ENABLED",
                Self::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SDP_BASIC_CONFIG_ENFORCEMENT_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
/// Sensitive Data Protection Advanced configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SdpAdvancedConfig {
    /// Optional. Sensitive Data Protection inspect template resource name
    ///
    /// If only inspect template is provided (de-identify template not provided),
    /// then Sensitive Data Protection InspectContent action is performed during
    /// Sanitization. All Sensitive Data Protection findings identified during
    /// inspection will be returned as SdpFinding in SdpInsepctionResult e.g.
    /// `organizations/{organization}/inspectTemplates/{inspect_template}`,
    /// `projects/{project}/inspectTemplates/{inspect_template}`
    /// `organizations/{organization}/locations/{location}/inspectTemplates/{inspect_template}`
    /// `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
    #[prost(string, tag = "1")]
    pub inspect_template: ::prost::alloc::string::String,
    /// Optional. Optional Sensitive Data Protection Deidentify template resource
    /// name.
    ///
    /// If provided then DeidentifyContent action is performed during Sanitization
    /// using this template and inspect template. The De-identified data will
    /// be returned in SdpDeidentifyResult.
    /// Note that all info-types present in the deidentify template must be present
    /// in inspect template.
    ///
    /// e.g.
    /// `organizations/{organization}/deidentifyTemplates/{deidentify_template}`,
    /// `projects/{project}/deidentifyTemplates/{deidentify_template}`
    /// `organizations/{organization}/locations/{location}/deidentifyTemplates/{deidentify_template}`
    /// `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
    #[prost(string, tag = "2")]
    pub deidentify_template: ::prost::alloc::string::String,
}
/// Sanitize User Prompt request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SanitizeUserPromptRequest {
    /// Required. Represents resource name of template
    /// e.g. name=projects/sample-project/locations/us-central1/templates/templ01
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. User prompt data to sanitize.
    #[prost(message, optional, tag = "2")]
    pub user_prompt_data: ::core::option::Option<DataItem>,
}
/// Sanitize Model Response request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SanitizeModelResponseRequest {
    /// Required. Represents resource name of template
    /// e.g. name=projects/sample-project/locations/us-central1/templates/templ01
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Model response data to sanitize.
    #[prost(message, optional, tag = "2")]
    pub model_response_data: ::core::option::Option<DataItem>,
    /// Optional. User Prompt associated with Model response.
    #[prost(string, tag = "4")]
    pub user_prompt: ::prost::alloc::string::String,
}
/// Sanitized User Prompt Response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SanitizeUserPromptResponse {
    /// Output only. Sanitization Result.
    #[prost(message, optional, tag = "1")]
    pub sanitization_result: ::core::option::Option<SanitizationResult>,
}
/// Sanitized Model Response Response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SanitizeModelResponseResponse {
    /// Output only. Sanitization Result.
    #[prost(message, optional, tag = "1")]
    pub sanitization_result: ::core::option::Option<SanitizationResult>,
}
/// Sanitization result after applying all the filters on input content.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SanitizationResult {
    /// Output only. Overall filter match state for Sanitization.
    /// The state can have below two values.
    ///
    /// 1) NO_MATCH_FOUND: No filters in configuration satisfy matching criteria.
    /// In other words, input passed all filters.
    ///
    /// 2) MATCH_FOUND: At least one filter in configuration satisfies matching.
    /// In other words, input did not pass one or more filters.
    #[prost(enumeration = "FilterMatchState", tag = "1")]
    pub filter_match_state: i32,
    /// Output only. Results for all filters where the key is the filter name -
    /// either of "csam", "malicious_uris", "rai", "pi_and_jailbreak" ,"sdp".
    #[prost(map = "string, message", tag = "2")]
    pub filter_results: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        FilterResult,
    >,
    /// Output only. A field indicating the outcome of the invocation, irrespective
    /// of match status. It can have the following three values: SUCCESS: All
    /// filters were executed successfully. PARTIAL: Some filters were skipped or
    /// failed execution. FAILURE: All filters were skipped or failed execution.
    #[prost(enumeration = "InvocationResult", tag = "4")]
    pub invocation_result: i32,
    /// Output only. Metadata related to Sanitization.
    #[prost(message, optional, tag = "3")]
    pub sanitization_metadata: ::core::option::Option<
        sanitization_result::SanitizationMetadata,
    >,
}
/// Nested message and enum types in `SanitizationResult`.
pub mod sanitization_result {
    /// Message describing Sanitization metadata.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SanitizationMetadata {
        /// Error code if any.
        #[prost(int64, tag = "1")]
        pub error_code: i64,
        /// Error message if any.
        #[prost(string, tag = "2")]
        pub error_message: ::prost::alloc::string::String,
    }
}
/// Filter Result obtained after Sanitization operations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterResult {
    /// Encapsulates one of responsible AI, Sensitive Data Protection, Prompt
    /// Injection and Jailbreak, Malicious URI, CSAM, Virus Scan related filter
    /// results.
    #[prost(oneof = "filter_result::FilterResult", tags = "1, 2, 3, 4, 5, 6")]
    pub filter_result: ::core::option::Option<filter_result::FilterResult>,
}
/// Nested message and enum types in `FilterResult`.
pub mod filter_result {
    /// Encapsulates one of responsible AI, Sensitive Data Protection, Prompt
    /// Injection and Jailbreak, Malicious URI, CSAM, Virus Scan related filter
    /// results.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum FilterResult {
        /// Responsible AI filter results.
        #[prost(message, tag = "1")]
        RaiFilterResult(super::RaiFilterResult),
        /// Sensitive Data Protection results.
        #[prost(message, tag = "2")]
        SdpFilterResult(super::SdpFilterResult),
        /// Prompt injection and Jailbreak filter results.
        #[prost(message, tag = "3")]
        PiAndJailbreakFilterResult(super::PiAndJailbreakFilterResult),
        /// Malicious URI filter results.
        #[prost(message, tag = "4")]
        MaliciousUriFilterResult(super::MaliciousUriFilterResult),
        /// CSAM filter results.
        #[prost(message, tag = "5")]
        CsamFilterFilterResult(super::CsamFilterResult),
        /// Virus scan results.
        #[prost(message, tag = "6")]
        VirusScanFilterResult(super::VirusScanFilterResult),
    }
}
/// Responsible AI Result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RaiFilterResult {
    /// Output only. Reports whether the RAI filter was successfully executed or
    /// not.
    #[prost(enumeration = "FilterExecutionState", tag = "1")]
    pub execution_state: i32,
    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[prost(message, repeated, tag = "2")]
    pub message_items: ::prost::alloc::vec::Vec<MessageItem>,
    /// Output only. Overall filter match state for RAI.
    /// Value is MATCH_FOUND if at least one RAI filter confidence level is
    /// equal to or higher than the confidence level defined in configuration.
    #[prost(enumeration = "FilterMatchState", tag = "3")]
    pub match_state: i32,
    /// The map of RAI filter results where key is RAI filter type - either of
    /// "sexually_explicit", "hate_speech", "harassment", "dangerous".
    #[prost(map = "string, message", tag = "4")]
    pub rai_filter_type_results: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        rai_filter_result::RaiFilterTypeResult,
    >,
}
/// Nested message and enum types in `RaiFilterResult`.
pub mod rai_filter_result {
    /// Detailed Filter result for each of the responsible AI Filter Types.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RaiFilterTypeResult {
        /// Type of responsible AI filter.
        #[prost(enumeration = "super::RaiFilterType", tag = "1")]
        pub filter_type: i32,
        /// Confidence level identified for this RAI filter.
        #[prost(enumeration = "super::DetectionConfidenceLevel", tag = "2")]
        pub confidence_level: i32,
        /// Output only. Match state for this RAI filter.
        #[prost(enumeration = "super::FilterMatchState", tag = "3")]
        pub match_state: i32,
    }
}
/// Sensitive Data Protection filter result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SdpFilterResult {
    /// Either of Sensitive Data Protection Inspect result or Deidentify result.
    #[prost(oneof = "sdp_filter_result::Result", tags = "1, 2")]
    pub result: ::core::option::Option<sdp_filter_result::Result>,
}
/// Nested message and enum types in `SdpFilterResult`.
pub mod sdp_filter_result {
    /// Either of Sensitive Data Protection Inspect result or Deidentify result.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        /// Sensitive Data Protection Inspection result if inspection is performed.
        #[prost(message, tag = "1")]
        InspectResult(super::SdpInspectResult),
        /// Sensitive Data Protection Deidentification result if deidentification is
        /// performed.
        #[prost(message, tag = "2")]
        DeidentifyResult(super::SdpDeidentifyResult),
    }
}
/// Sensitive Data Protection Inspection Result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SdpInspectResult {
    /// Output only. Reports whether Sensitive Data Protection inspection was
    /// successfully executed or not.
    #[prost(enumeration = "FilterExecutionState", tag = "1")]
    pub execution_state: i32,
    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[prost(message, repeated, tag = "2")]
    pub message_items: ::prost::alloc::vec::Vec<MessageItem>,
    /// Output only. Match state for SDP Inspection.
    /// Value is MATCH_FOUND if at least one Sensitive Data Protection finding is
    /// identified.
    #[prost(enumeration = "FilterMatchState", tag = "3")]
    pub match_state: i32,
    /// List of Sensitive Data Protection findings.
    #[prost(message, repeated, tag = "4")]
    pub findings: ::prost::alloc::vec::Vec<SdpFinding>,
    /// If true, then there is possibility that more findings were identified and
    /// the findings returned are a subset of all findings. The findings
    /// list might be truncated because the input items were too large, or because
    /// the server reached the maximum amount of resources allowed for a single API
    /// call.
    #[prost(bool, tag = "5")]
    pub findings_truncated: bool,
}
/// Represents Data item
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataItem {
    /// Either of text or bytes data.
    #[prost(oneof = "data_item::DataItem", tags = "1, 2")]
    pub data_item: ::core::option::Option<data_item::DataItem>,
}
/// Nested message and enum types in `DataItem`.
pub mod data_item {
    /// Either of text or bytes data.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DataItem {
        /// Plaintext string data for sanitization.
        #[prost(string, tag = "1")]
        Text(::prost::alloc::string::String),
        /// Data provided in the form of bytes.
        #[prost(message, tag = "2")]
        ByteItem(super::ByteDataItem),
    }
}
/// Represents Byte Data item.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ByteDataItem {
    /// Required. The type of byte data
    #[prost(enumeration = "byte_data_item::ByteItemType", tag = "1")]
    pub byte_data_type: i32,
    /// Required. Bytes Data
    #[prost(bytes = "vec", tag = "2")]
    pub byte_data: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `ByteDataItem`.
pub mod byte_data_item {
    /// Option to specify the type of byte data.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ByteItemType {
        /// Unused
        Unspecified = 0,
        /// plain text
        PlaintextUtf8 = 1,
        /// PDF
        Pdf = 2,
    }
    impl ByteItemType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BYTE_ITEM_TYPE_UNSPECIFIED",
                Self::PlaintextUtf8 => "PLAINTEXT_UTF8",
                Self::Pdf => "PDF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BYTE_ITEM_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PLAINTEXT_UTF8" => Some(Self::PlaintextUtf8),
                "PDF" => Some(Self::Pdf),
                _ => None,
            }
        }
    }
}
/// Sensitive Data Protection Deidentification Result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SdpDeidentifyResult {
    /// Output only. Reports whether Sensitive Data Protection deidentification was
    /// successfully executed or not.
    #[prost(enumeration = "FilterExecutionState", tag = "1")]
    pub execution_state: i32,
    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[prost(message, repeated, tag = "2")]
    pub message_items: ::prost::alloc::vec::Vec<MessageItem>,
    /// Output only. Match state for Sensitive Data Protection Deidentification.
    /// Value is MATCH_FOUND if content is de-identified.
    #[prost(enumeration = "FilterMatchState", tag = "3")]
    pub match_state: i32,
    /// De-identified data.
    #[prost(message, optional, tag = "4")]
    pub data: ::core::option::Option<DataItem>,
    /// Total size in bytes that were transformed during deidentification.
    #[prost(int64, tag = "5")]
    pub transformed_bytes: i64,
}
/// Finding corresponding to Sensitive Data Protection filter.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SdpFinding {
    /// Name of Sensitive Data Protection info type for this finding.
    #[prost(string, tag = "1")]
    pub info_type: ::prost::alloc::string::String,
    /// Identified confidence likelihood for `info_type`.
    #[prost(enumeration = "SdpFindingLikelihood", tag = "2")]
    pub likelihood: i32,
    /// Location for this finding.
    #[prost(message, optional, tag = "3")]
    pub location: ::core::option::Option<sdp_finding::SdpFindingLocation>,
}
/// Nested message and enum types in `SdpFinding`.
pub mod sdp_finding {
    /// Location of this Sensitive Data Protection Finding within input content.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SdpFindingLocation {
        /// Zero-based byte offsets delimiting the finding.
        /// These are relative to the finding's containing element.
        /// Note that when the content is not textual, this references
        /// the UTF-8 encoded textual representation of the content.
        #[prost(message, optional, tag = "1")]
        pub byte_range: ::core::option::Option<super::RangeInfo>,
        /// Unicode character offsets delimiting the finding.
        /// These are relative to the finding's containing element.
        /// Provided when the content is text.
        #[prost(message, optional, tag = "2")]
        pub codepoint_range: ::core::option::Option<super::RangeInfo>,
    }
}
/// Prompt injection and Jailbreak Filter Result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PiAndJailbreakFilterResult {
    /// Output only. Reports whether Prompt injection and Jailbreak filter was
    /// successfully executed or not.
    #[prost(enumeration = "FilterExecutionState", tag = "1")]
    pub execution_state: i32,
    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[prost(message, repeated, tag = "2")]
    pub message_items: ::prost::alloc::vec::Vec<MessageItem>,
    /// Output only. Match state for Prompt injection and Jailbreak.
    #[prost(enumeration = "FilterMatchState", tag = "3")]
    pub match_state: i32,
    /// Confidence level identified for Prompt injection and Jailbreak.
    #[prost(enumeration = "DetectionConfidenceLevel", tag = "5")]
    pub confidence_level: i32,
}
/// Malicious URI Filter Result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaliciousUriFilterResult {
    /// Output only. Reports whether Malicious URI filter was successfully executed
    /// or not.
    #[prost(enumeration = "FilterExecutionState", tag = "1")]
    pub execution_state: i32,
    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[prost(message, repeated, tag = "2")]
    pub message_items: ::prost::alloc::vec::Vec<MessageItem>,
    /// Output only. Match state for this Malicious URI.
    /// Value is MATCH_FOUND if at least one Malicious URI is found.
    #[prost(enumeration = "FilterMatchState", tag = "3")]
    pub match_state: i32,
    /// List of Malicious URIs found in data.
    #[prost(message, repeated, tag = "4")]
    pub malicious_uri_matched_items: ::prost::alloc::vec::Vec<
        malicious_uri_filter_result::MaliciousUriMatchedItem,
    >,
}
/// Nested message and enum types in `MaliciousUriFilterResult`.
pub mod malicious_uri_filter_result {
    /// Information regarding malicious URI and its location within the input
    /// content.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MaliciousUriMatchedItem {
        /// Malicious URI.
        #[prost(string, tag = "1")]
        pub uri: ::prost::alloc::string::String,
        /// List of locations where Malicious URI is identified.
        /// The `locations` field is supported only for plaintext content i.e.
        /// ByteItemType.PLAINTEXT_UTF8
        #[prost(message, repeated, tag = "2")]
        pub locations: ::prost::alloc::vec::Vec<super::RangeInfo>,
    }
}
/// Virus scan results.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VirusScanFilterResult {
    /// Output only. Reports whether Virus Scan was successfully executed or not.
    #[prost(enumeration = "FilterExecutionState", tag = "1")]
    pub execution_state: i32,
    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution status is skipped then this field provides
    /// related reason/explanation.
    #[prost(message, repeated, tag = "2")]
    pub message_items: ::prost::alloc::vec::Vec<MessageItem>,
    /// Output only. Match status for Virus.
    /// Value is MATCH_FOUND if the data is infected with a virus.
    #[prost(enumeration = "FilterMatchState", tag = "3")]
    pub match_state: i32,
    /// Type of content scanned.
    #[prost(enumeration = "virus_scan_filter_result::ScannedContentType", tag = "4")]
    pub scanned_content_type: i32,
    /// Size of scanned content in bytes.
    #[prost(int64, optional, tag = "5")]
    pub scanned_size: ::core::option::Option<i64>,
    /// List of Viruses identified.
    /// This field will be empty if no virus was detected.
    #[prost(message, repeated, tag = "6")]
    pub virus_details: ::prost::alloc::vec::Vec<VirusDetail>,
}
/// Nested message and enum types in `VirusScanFilterResult`.
pub mod virus_scan_filter_result {
    /// Type of content scanned.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ScannedContentType {
        /// Unused
        Unspecified = 0,
        /// Unknown content
        Unknown = 1,
        /// Plaintext
        Plaintext = 2,
        /// PDF
        /// Scanning for only PDF is supported.
        Pdf = 3,
    }
    impl ScannedContentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SCANNED_CONTENT_TYPE_UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Plaintext => "PLAINTEXT",
                Self::Pdf => "PDF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCANNED_CONTENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PLAINTEXT" => Some(Self::Plaintext),
                "PDF" => Some(Self::Pdf),
                _ => None,
            }
        }
    }
}
/// Details of an identified virus
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VirusDetail {
    /// Name of vendor that produced this virus identification.
    #[prost(string, tag = "1")]
    pub vendor: ::prost::alloc::string::String,
    /// Names of this Virus.
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Threat type of the identified virus
    #[prost(enumeration = "virus_detail::ThreatType", tag = "3")]
    pub threat_type: i32,
}
/// Nested message and enum types in `VirusDetail`.
pub mod virus_detail {
    /// Defines all the threat types of a virus
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ThreatType {
        /// Unused
        Unspecified = 0,
        /// Unable to categorize threat
        Unknown = 1,
        /// Virus or Worm threat.
        VirusOrWorm = 2,
        /// Malicious program. E.g. Spyware, Trojan.
        MaliciousProgram = 3,
        /// Potentially harmful content. E.g. Injected code, Macro
        PotentiallyHarmfulContent = 4,
        /// Potentially unwanted content. E.g. Adware.
        PotentiallyUnwantedContent = 5,
    }
    impl ThreatType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "THREAT_TYPE_UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::VirusOrWorm => "VIRUS_OR_WORM",
                Self::MaliciousProgram => "MALICIOUS_PROGRAM",
                Self::PotentiallyHarmfulContent => "POTENTIALLY_HARMFUL_CONTENT",
                Self::PotentiallyUnwantedContent => "POTENTIALLY_UNWANTED_CONTENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "THREAT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "VIRUS_OR_WORM" => Some(Self::VirusOrWorm),
                "MALICIOUS_PROGRAM" => Some(Self::MaliciousProgram),
                "POTENTIALLY_HARMFUL_CONTENT" => Some(Self::PotentiallyHarmfulContent),
                "POTENTIALLY_UNWANTED_CONTENT" => Some(Self::PotentiallyUnwantedContent),
                _ => None,
            }
        }
    }
}
/// CSAM (Child Safety Abuse Material) Filter Result
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsamFilterResult {
    /// Output only. Reports whether the CSAM filter was successfully executed or
    /// not.
    #[prost(enumeration = "FilterExecutionState", tag = "1")]
    pub execution_state: i32,
    /// Optional messages corresponding to the result.
    /// A message can provide warnings or error details.
    /// For example, if execution state is skipped then this field provides
    /// related reason/explanation.
    #[prost(message, repeated, tag = "2")]
    pub message_items: ::prost::alloc::vec::Vec<MessageItem>,
    /// Output only. Match state for CSAM.
    #[prost(enumeration = "FilterMatchState", tag = "3")]
    pub match_state: i32,
}
/// Message item to report information, warning or error messages.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageItem {
    /// Type of message.
    #[prost(enumeration = "message_item::MessageType", tag = "1")]
    pub message_type: i32,
    /// The message content.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `MessageItem`.
pub mod message_item {
    /// Option to specify the type of message.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MessageType {
        /// Unused
        Unspecified = 0,
        /// Information related message.
        Info = 1,
        /// Warning related message.
        Warning = 2,
        /// Error message.
        Error = 3,
    }
    impl MessageType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MESSAGE_TYPE_UNSPECIFIED",
                Self::Info => "INFO",
                Self::Warning => "WARNING",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MESSAGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INFO" => Some(Self::Info),
                "WARNING" => Some(Self::Warning),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
/// Half-open range interval [start, end)
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RangeInfo {
    /// For proto3, value cannot be set to 0 unless the field is optional.
    /// Ref: <https://protobuf.dev/programming-guides/proto3/#default>
    /// Index of first character (inclusive).
    #[prost(int64, optional, tag = "1")]
    pub start: ::core::option::Option<i64>,
    /// Index of last character (exclusive).
    #[prost(int64, optional, tag = "2")]
    pub end: ::core::option::Option<i64>,
}
/// Option to specify filter match state.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FilterMatchState {
    /// Unused
    Unspecified = 0,
    /// Matching criteria is not achieved for filters.
    NoMatchFound = 1,
    /// Matching criteria is achieved for the filter.
    MatchFound = 2,
}
impl FilterMatchState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FILTER_MATCH_STATE_UNSPECIFIED",
            Self::NoMatchFound => "NO_MATCH_FOUND",
            Self::MatchFound => "MATCH_FOUND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FILTER_MATCH_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "NO_MATCH_FOUND" => Some(Self::NoMatchFound),
            "MATCH_FOUND" => Some(Self::MatchFound),
            _ => None,
        }
    }
}
/// Enum which reports whether a specific filter executed successfully or not.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FilterExecutionState {
    /// Unused
    Unspecified = 0,
    /// Filter executed successfully
    ExecutionSuccess = 1,
    /// Filter execution was skipped. This can happen due to server-side error
    /// or permission issue.
    ExecutionSkipped = 2,
}
impl FilterExecutionState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FILTER_EXECUTION_STATE_UNSPECIFIED",
            Self::ExecutionSuccess => "EXECUTION_SUCCESS",
            Self::ExecutionSkipped => "EXECUTION_SKIPPED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FILTER_EXECUTION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "EXECUTION_SUCCESS" => Some(Self::ExecutionSuccess),
            "EXECUTION_SKIPPED" => Some(Self::ExecutionSkipped),
            _ => None,
        }
    }
}
/// Options for responsible AI Filter Types.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RaiFilterType {
    /// Unspecified filter type.
    Unspecified = 0,
    /// Sexually Explicit.
    SexuallyExplicit = 2,
    /// Hate Speech.
    HateSpeech = 3,
    /// Harassment.
    Harassment = 6,
    /// Danger
    Dangerous = 17,
}
impl RaiFilterType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RAI_FILTER_TYPE_UNSPECIFIED",
            Self::SexuallyExplicit => "SEXUALLY_EXPLICIT",
            Self::HateSpeech => "HATE_SPEECH",
            Self::Harassment => "HARASSMENT",
            Self::Dangerous => "DANGEROUS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RAI_FILTER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SEXUALLY_EXPLICIT" => Some(Self::SexuallyExplicit),
            "HATE_SPEECH" => Some(Self::HateSpeech),
            "HARASSMENT" => Some(Self::Harassment),
            "DANGEROUS" => Some(Self::Dangerous),
            _ => None,
        }
    }
}
/// Confidence levels for detectors.
/// Higher value maps to a greater confidence level. To enforce stricter level a
/// lower value should be used.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DetectionConfidenceLevel {
    /// Same as LOW_AND_ABOVE.
    Unspecified = 0,
    /// Highest chance of a false positive.
    LowAndAbove = 1,
    /// Some chance of false positives.
    MediumAndAbove = 2,
    /// Low chance of false positives.
    High = 3,
}
impl DetectionConfidenceLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DETECTION_CONFIDENCE_LEVEL_UNSPECIFIED",
            Self::LowAndAbove => "LOW_AND_ABOVE",
            Self::MediumAndAbove => "MEDIUM_AND_ABOVE",
            Self::High => "HIGH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DETECTION_CONFIDENCE_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "LOW_AND_ABOVE" => Some(Self::LowAndAbove),
            "MEDIUM_AND_ABOVE" => Some(Self::MediumAndAbove),
            "HIGH" => Some(Self::High),
            _ => None,
        }
    }
}
/// For more information about each Sensitive Data Protection likelihood level,
/// see <https://cloud.google.com/sensitive-data-protection/docs/likelihood.>
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SdpFindingLikelihood {
    /// Default value; same as POSSIBLE.
    Unspecified = 0,
    /// Highest chance of a false positive.
    VeryUnlikely = 1,
    /// High chance of a false positive.
    Unlikely = 2,
    /// Some matching signals. The default value.
    Possible = 3,
    /// Low chance of a false positive.
    Likely = 4,
    /// Confidence level is high. Lowest chance of a false positive.
    VeryLikely = 5,
}
impl SdpFindingLikelihood {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SDP_FINDING_LIKELIHOOD_UNSPECIFIED",
            Self::VeryUnlikely => "VERY_UNLIKELY",
            Self::Unlikely => "UNLIKELY",
            Self::Possible => "POSSIBLE",
            Self::Likely => "LIKELY",
            Self::VeryLikely => "VERY_LIKELY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SDP_FINDING_LIKELIHOOD_UNSPECIFIED" => Some(Self::Unspecified),
            "VERY_UNLIKELY" => Some(Self::VeryUnlikely),
            "UNLIKELY" => Some(Self::Unlikely),
            "POSSIBLE" => Some(Self::Possible),
            "LIKELY" => Some(Self::Likely),
            "VERY_LIKELY" => Some(Self::VeryLikely),
            _ => None,
        }
    }
}
/// A field indicating the outcome of the invocation, irrespective of match
/// status.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InvocationResult {
    /// Unused. Default value.
    Unspecified = 0,
    /// All filters were invoked successfully.
    Success = 1,
    /// Some filters were skipped or failed.
    Partial = 2,
    /// All filters were skipped or failed.
    Failure = 3,
}
impl InvocationResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INVOCATION_RESULT_UNSPECIFIED",
            Self::Success => "SUCCESS",
            Self::Partial => "PARTIAL",
            Self::Failure => "FAILURE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INVOCATION_RESULT_UNSPECIFIED" => Some(Self::Unspecified),
            "SUCCESS" => Some(Self::Success),
            "PARTIAL" => Some(Self::Partial),
            "FAILURE" => Some(Self::Failure),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod model_armor_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing handlers for resources
    #[derive(Debug, Clone)]
    pub struct ModelArmorClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ModelArmorClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ModelArmorClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ModelArmorClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ModelArmorClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists Templates in a given project and location.
        pub async fn list_templates(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTemplatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTemplatesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.modelarmor.v1.ModelArmor/ListTemplates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.modelarmor.v1.ModelArmor",
                        "ListTemplates",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Template.
        pub async fn get_template(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTemplateRequest>,
        ) -> std::result::Result<tonic::Response<super::Template>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.modelarmor.v1.ModelArmor/GetTemplate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.modelarmor.v1.ModelArmor",
                        "GetTemplate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Template in a given project and location.
        pub async fn create_template(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTemplateRequest>,
        ) -> std::result::Result<tonic::Response<super::Template>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.modelarmor.v1.ModelArmor/CreateTemplate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.modelarmor.v1.ModelArmor",
                        "CreateTemplate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Template.
        pub async fn update_template(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateTemplateRequest>,
        ) -> std::result::Result<tonic::Response<super::Template>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.modelarmor.v1.ModelArmor/UpdateTemplate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.modelarmor.v1.ModelArmor",
                        "UpdateTemplate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Template.
        pub async fn delete_template(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTemplateRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.modelarmor.v1.ModelArmor/DeleteTemplate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.modelarmor.v1.ModelArmor",
                        "DeleteTemplate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single floor setting of a project
        pub async fn get_floor_setting(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFloorSettingRequest>,
        ) -> std::result::Result<tonic::Response<super::FloorSetting>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.modelarmor.v1.ModelArmor/GetFloorSetting",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.modelarmor.v1.ModelArmor",
                        "GetFloorSetting",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single floor setting of a project
        pub async fn update_floor_setting(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateFloorSettingRequest>,
        ) -> std::result::Result<tonic::Response<super::FloorSetting>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.modelarmor.v1.ModelArmor/UpdateFloorSetting",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.modelarmor.v1.ModelArmor",
                        "UpdateFloorSetting",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sanitizes User Prompt.
        pub async fn sanitize_user_prompt(
            &mut self,
            request: impl tonic::IntoRequest<super::SanitizeUserPromptRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SanitizeUserPromptResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.modelarmor.v1.ModelArmor/SanitizeUserPrompt",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.modelarmor.v1.ModelArmor",
                        "SanitizeUserPrompt",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sanitizes Model Response.
        pub async fn sanitize_model_response(
            &mut self,
            request: impl tonic::IntoRequest<super::SanitizeModelResponseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SanitizeModelResponseResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.modelarmor.v1.ModelArmor/SanitizeModelResponse",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.modelarmor.v1.ModelArmor",
                        "SanitizeModelResponse",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
