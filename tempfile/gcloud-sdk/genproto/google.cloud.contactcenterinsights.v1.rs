// This file is @generated by prost-build.
/// The conversation resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Conversation {
    /// Immutable. The resource name of the conversation.
    /// Format:
    /// projects/{project}/locations/{location}/conversations/{conversation}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The source of the audio and transcription for the conversation.
    #[prost(message, optional, tag = "2")]
    pub data_source: ::core::option::Option<ConversationDataSource>,
    /// Output only. The time at which the conversation was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The most recent time at which the conversation was updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time at which the conversation started.
    #[prost(message, optional, tag = "17")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// A user-specified language code for the conversation.
    #[prost(string, tag = "14")]
    pub language_code: ::prost::alloc::string::String,
    /// An opaque, user-specified string representing the human agent who handled
    /// the conversation.
    #[prost(string, tag = "5")]
    pub agent_id: ::prost::alloc::string::String,
    /// A map for the user to specify any custom fields. A maximum of 100 labels
    /// per conversation is allowed, with a maximum of 256 characters per entry.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Conversation metadata related to quality management.
    #[prost(message, optional, tag = "24")]
    pub quality_metadata: ::core::option::Option<conversation::QualityMetadata>,
    /// Input only. JSON metadata encoded as a string.
    /// This field is primarily used by Insights integrations with various telphony
    /// systems and must be in one of Insight's supported formats.
    #[prost(string, tag = "25")]
    pub metadata_json: ::prost::alloc::string::String,
    /// Output only. The conversation transcript.
    #[prost(message, optional, tag = "8")]
    pub transcript: ::core::option::Option<conversation::Transcript>,
    /// Immutable. The conversation medium, if unspecified will default to
    /// PHONE_CALL.
    #[prost(enumeration = "conversation::Medium", tag = "9")]
    pub medium: i32,
    /// Output only. The duration of the conversation.
    #[prost(message, optional, tag = "10")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
    /// Output only. The number of turns in the conversation.
    #[prost(int32, tag = "11")]
    pub turn_count: i32,
    /// Output only. The conversation's latest analysis, if one exists.
    #[prost(message, optional, tag = "12")]
    pub latest_analysis: ::core::option::Option<Analysis>,
    /// Output only. Latest summary of the conversation.
    #[prost(message, optional, tag = "20")]
    pub latest_summary: ::core::option::Option<ConversationSummarizationSuggestionData>,
    /// Output only. The annotations that were generated during the customer and
    /// agent interaction.
    #[prost(message, repeated, tag = "13")]
    pub runtime_annotations: ::prost::alloc::vec::Vec<RuntimeAnnotation>,
    /// Output only. All the matched Dialogflow intents in the call. The key
    /// corresponds to a Dialogflow intent, format:
    /// projects/{project}/agent/{agent}/intents/{intent}
    #[prost(map = "string, message", tag = "18")]
    pub dialogflow_intents: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        DialogflowIntent,
    >,
    /// Obfuscated user ID which the customer sent to us.
    #[prost(string, tag = "21")]
    pub obfuscated_user_id: ::prost::alloc::string::String,
    /// Metadata that applies to the conversation.
    #[prost(oneof = "conversation::Metadata", tags = "7")]
    pub metadata: ::core::option::Option<conversation::Metadata>,
    /// A time to live expiration setting, can be either a specified timestamp or a
    /// duration from the time that the conversation creation request was received.
    /// Conversations with an expiration set will be removed up to 24 hours after
    /// the specified time.
    #[prost(oneof = "conversation::Expiration", tags = "15, 16")]
    pub expiration: ::core::option::Option<conversation::Expiration>,
}
/// Nested message and enum types in `Conversation`.
pub mod conversation {
    /// Call-specific metadata.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CallMetadata {
        /// The audio channel that contains the customer.
        #[prost(int32, tag = "1")]
        pub customer_channel: i32,
        /// The audio channel that contains the agent.
        #[prost(int32, tag = "2")]
        pub agent_channel: i32,
    }
    /// Conversation metadata related to quality management.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QualityMetadata {
        /// An arbitrary integer value indicating the customer's satisfaction rating.
        #[prost(int32, tag = "1")]
        pub customer_satisfaction_rating: i32,
        /// The amount of time the customer waited to connect with an agent.
        #[prost(message, optional, tag = "2")]
        pub wait_duration: ::core::option::Option<::prost_types::Duration>,
        /// An arbitrary string value specifying the menu path the customer took.
        #[prost(string, tag = "3")]
        pub menu_path: ::prost::alloc::string::String,
        /// Information about agents involved in the call.
        #[prost(message, repeated, tag = "4")]
        pub agent_info: ::prost::alloc::vec::Vec<quality_metadata::AgentInfo>,
    }
    /// Nested message and enum types in `QualityMetadata`.
    pub mod quality_metadata {
        /// Information about an agent involved in the conversation.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AgentInfo {
            /// A user-specified string representing the agent.
            #[prost(string, tag = "1")]
            pub agent_id: ::prost::alloc::string::String,
            /// The agent's name.
            #[prost(string, tag = "2")]
            pub display_name: ::prost::alloc::string::String,
            /// A user-specified string representing the agent's team.
            #[prost(string, tag = "3")]
            pub team: ::prost::alloc::string::String,
            /// A user-provided string indicating the outcome of the agent's segment of
            /// the call.
            #[prost(string, tag = "4")]
            pub disposition_code: ::prost::alloc::string::String,
            /// The agent type, e.g. HUMAN_AGENT.
            #[prost(
                enumeration = "super::super::conversation_participant::Role",
                tag = "5"
            )]
            pub agent_type: i32,
        }
    }
    /// A message representing the transcript of a conversation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Transcript {
        /// A list of sequential transcript segments that comprise the conversation.
        #[prost(message, repeated, tag = "1")]
        pub transcript_segments: ::prost::alloc::vec::Vec<transcript::TranscriptSegment>,
    }
    /// Nested message and enum types in `Transcript`.
    pub mod transcript {
        /// A segment of a full transcript.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TranscriptSegment {
            /// The time that the message occurred, if provided.
            #[prost(message, optional, tag = "6")]
            pub message_time: ::core::option::Option<::prost_types::Timestamp>,
            /// The text of this segment.
            #[prost(string, tag = "1")]
            pub text: ::prost::alloc::string::String,
            /// A confidence estimate between 0.0 and 1.0 of the fidelity of this
            /// segment. A default value of 0.0 indicates that the value is unset.
            #[prost(float, tag = "2")]
            pub confidence: f32,
            /// A list of the word-specific information for each word in the segment.
            #[prost(message, repeated, tag = "3")]
            pub words: ::prost::alloc::vec::Vec<transcript_segment::WordInfo>,
            /// The language code of this segment as a
            /// [BCP-47](<https://www.rfc-editor.org/rfc/bcp/bcp47.txt>) language tag.
            /// Example: "en-US".
            #[prost(string, tag = "4")]
            pub language_code: ::prost::alloc::string::String,
            /// For conversations derived from multi-channel audio, this is the channel
            /// number corresponding to the audio from that channel. For
            /// audioChannelCount = N, its output values can range from '1' to 'N'. A
            /// channel tag of 0 indicates that the audio is mono.
            #[prost(int32, tag = "5")]
            pub channel_tag: i32,
            /// The participant of this segment.
            #[prost(message, optional, tag = "9")]
            pub segment_participant: ::core::option::Option<
                super::super::ConversationParticipant,
            >,
            /// CCAI metadata relating to the current transcript segment.
            #[prost(message, optional, tag = "10")]
            pub dialogflow_segment_metadata: ::core::option::Option<
                transcript_segment::DialogflowSegmentMetadata,
            >,
            /// The sentiment for this transcript segment.
            #[prost(message, optional, tag = "11")]
            pub sentiment: ::core::option::Option<super::super::SentimentData>,
        }
        /// Nested message and enum types in `TranscriptSegment`.
        pub mod transcript_segment {
            /// Word-level info for words in a transcript.
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct WordInfo {
                /// Time offset of the start of this word relative to the beginning of
                /// the total conversation.
                #[prost(message, optional, tag = "1")]
                pub start_offset: ::core::option::Option<::prost_types::Duration>,
                /// Time offset of the end of this word relative to the beginning of the
                /// total conversation.
                #[prost(message, optional, tag = "2")]
                pub end_offset: ::core::option::Option<::prost_types::Duration>,
                /// The word itself. Includes punctuation marks that surround the word.
                #[prost(string, tag = "3")]
                pub word: ::prost::alloc::string::String,
                /// A confidence estimate between 0.0 and 1.0 of the fidelity of this
                /// word. A default value of 0.0 indicates that the value is unset.
                #[prost(float, tag = "4")]
                pub confidence: f32,
            }
            /// Metadata from Dialogflow relating to the current transcript segment.
            #[derive(Clone, Copy, PartialEq, ::prost::Message)]
            pub struct DialogflowSegmentMetadata {
                /// Whether the transcript segment was covered under the configured smart
                /// reply allowlist in Agent Assist.
                #[prost(bool, tag = "1")]
                pub smart_reply_allowlist_covered: bool,
            }
        }
    }
    /// Possible media for the conversation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Medium {
        /// Default value, if unspecified will default to PHONE_CALL.
        Unspecified = 0,
        /// The format for conversations that took place over the phone.
        PhoneCall = 1,
        /// The format for conversations that took place over chat.
        Chat = 2,
    }
    impl Medium {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MEDIUM_UNSPECIFIED",
                Self::PhoneCall => "PHONE_CALL",
                Self::Chat => "CHAT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MEDIUM_UNSPECIFIED" => Some(Self::Unspecified),
                "PHONE_CALL" => Some(Self::PhoneCall),
                "CHAT" => Some(Self::Chat),
                _ => None,
            }
        }
    }
    /// Metadata that applies to the conversation.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Metadata {
        /// Call-specific metadata.
        #[prost(message, tag = "7")]
        CallMetadata(CallMetadata),
    }
    /// A time to live expiration setting, can be either a specified timestamp or a
    /// duration from the time that the conversation creation request was received.
    /// Conversations with an expiration set will be removed up to 24 hours after
    /// the specified time.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Expiration {
        /// The time at which this conversation should expire. After this time, the
        /// conversation data and any associated analyses will be deleted.
        #[prost(message, tag = "15")]
        ExpireTime(::prost_types::Timestamp),
        /// Input only. The TTL for this resource. If specified, then this TTL will
        /// be used to calculate the expire time.
        #[prost(message, tag = "16")]
        Ttl(::prost_types::Duration),
    }
}
/// The analysis resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Analysis {
    /// Immutable. The resource name of the analysis.
    /// Format:
    /// projects/{project}/locations/{location}/conversations/{conversation}/analyses/{analysis}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The time at which the analysis was requested.
    #[prost(message, optional, tag = "2")]
    pub request_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time at which the analysis was created, which occurs when
    /// the long-running operation completes.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The result of the analysis, which is populated when the
    /// analysis finishes.
    #[prost(message, optional, tag = "7")]
    pub analysis_result: ::core::option::Option<AnalysisResult>,
    /// To select the annotators to run and the phrase matchers to use
    /// (if any). If not specified, all annotators will be run.
    #[prost(message, optional, tag = "8")]
    pub annotator_selector: ::core::option::Option<AnnotatorSelector>,
}
/// The conversation source, which is a combination of transcript and audio.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationDataSource {
    /// The source of the conversation.
    #[prost(oneof = "conversation_data_source::Source", tags = "1, 3")]
    pub source: ::core::option::Option<conversation_data_source::Source>,
}
/// Nested message and enum types in `ConversationDataSource`.
pub mod conversation_data_source {
    /// The source of the conversation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// A Cloud Storage location specification for the audio and transcript.
        #[prost(message, tag = "1")]
        GcsSource(super::GcsSource),
        /// The source when the conversation comes from Dialogflow.
        #[prost(message, tag = "3")]
        DialogflowSource(super::DialogflowSource),
    }
}
/// A Cloud Storage source of conversation data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsSource {
    /// Cloud Storage URI that points to a file that contains the conversation
    /// audio.
    #[prost(string, tag = "1")]
    pub audio_uri: ::prost::alloc::string::String,
    /// Immutable. Cloud Storage URI that points to a file that contains the
    /// conversation transcript.
    #[prost(string, tag = "2")]
    pub transcript_uri: ::prost::alloc::string::String,
}
/// A Dialogflow source of conversation data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DialogflowSource {
    /// Output only. The name of the Dialogflow conversation that this conversation
    /// resource is derived from. Format:
    /// projects/{project}/locations/{location}/conversations/{conversation}
    #[prost(string, tag = "1")]
    pub dialogflow_conversation: ::prost::alloc::string::String,
    /// Cloud Storage URI that points to a file that contains the conversation
    /// audio.
    #[prost(string, tag = "3")]
    pub audio_uri: ::prost::alloc::string::String,
}
/// The result of an analysis.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisResult {
    /// The time at which the analysis ended.
    #[prost(message, optional, tag = "1")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Metadata discovered during analysis.
    #[prost(oneof = "analysis_result::Metadata", tags = "2")]
    pub metadata: ::core::option::Option<analysis_result::Metadata>,
}
/// Nested message and enum types in `AnalysisResult`.
pub mod analysis_result {
    /// Call-specific metadata created during analysis.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CallAnalysisMetadata {
        /// A list of call annotations that apply to this call.
        #[prost(message, repeated, tag = "2")]
        pub annotations: ::prost::alloc::vec::Vec<super::CallAnnotation>,
        /// All the entities in the call.
        #[prost(map = "string, message", tag = "3")]
        pub entities: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::Entity,
        >,
        /// Overall conversation-level sentiment for each channel of the call.
        #[prost(message, repeated, tag = "4")]
        pub sentiments: ::prost::alloc::vec::Vec<super::ConversationLevelSentiment>,
        /// Overall conversation-level silence during the call.
        #[prost(message, optional, tag = "11")]
        pub silence: ::core::option::Option<super::ConversationLevelSilence>,
        /// All the matched intents in the call.
        #[prost(map = "string, message", tag = "6")]
        pub intents: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::Intent,
        >,
        /// All the matched phrase matchers in the call.
        #[prost(map = "string, message", tag = "7")]
        pub phrase_matchers: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::PhraseMatchData,
        >,
        /// Overall conversation-level issue modeling result.
        #[prost(message, optional, tag = "8")]
        pub issue_model_result: ::core::option::Option<super::IssueModelResult>,
        /// Results of scoring QaScorecards.
        #[prost(message, repeated, tag = "10")]
        pub qa_scorecard_results: ::prost::alloc::vec::Vec<super::QaScorecardResult>,
    }
    /// Metadata discovered during analysis.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Metadata {
        /// Call-specific metadata created by the analysis.
        #[prost(message, tag = "2")]
        CallAnalysisMetadata(CallAnalysisMetadata),
    }
}
/// Issue Modeling result on a conversation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueModelResult {
    /// Issue model that generates the result.
    /// Format: projects/{project}/locations/{location}/issueModels/{issue_model}
    #[prost(string, tag = "1")]
    pub issue_model: ::prost::alloc::string::String,
    /// All the matched issues.
    #[prost(message, repeated, tag = "2")]
    pub issues: ::prost::alloc::vec::Vec<IssueAssignment>,
}
/// Represents a conversation, resource, and label provided by the user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeedbackLabel {
    /// Immutable. Resource name of the FeedbackLabel.
    /// Format:
    /// projects/{project}/locations/{location}/conversations/{conversation}/feedbackLabels/{feedback_label}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Resource name of the resource to be labeled.
    #[prost(string, tag = "3")]
    pub labeled_resource: ::prost::alloc::string::String,
    /// Output only. Create time of the label.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Update time of the label.
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Label type.
    #[prost(oneof = "feedback_label::LabelType", tags = "4, 7")]
    pub label_type: ::core::option::Option<feedback_label::LabelType>,
}
/// Nested message and enum types in `FeedbackLabel`.
pub mod feedback_label {
    /// Label type.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum LabelType {
        /// String label.
        #[prost(string, tag = "4")]
        Label(::prost::alloc::string::String),
        /// QaAnswer label.
        #[prost(message, tag = "7")]
        QaAnswerLabel(super::qa_answer::AnswerValue),
    }
}
/// One channel of conversation-level sentiment data.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversationLevelSentiment {
    /// The channel of the audio that the data applies to.
    #[prost(int32, tag = "1")]
    pub channel_tag: i32,
    /// Data specifying sentiment.
    #[prost(message, optional, tag = "2")]
    pub sentiment_data: ::core::option::Option<SentimentData>,
}
/// Conversation-level silence data.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversationLevelSilence {
    /// Amount of time calculated to be in silence.
    #[prost(message, optional, tag = "1")]
    pub silence_duration: ::core::option::Option<::prost_types::Duration>,
    /// Percentage of the total conversation spent in silence.
    #[prost(float, tag = "2")]
    pub silence_percentage: f32,
}
/// Information about the issue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueAssignment {
    /// Resource name of the assigned issue.
    #[prost(string, tag = "1")]
    pub issue: ::prost::alloc::string::String,
    /// Score indicating the likelihood of the issue assignment.
    /// currently bounded on \[0,1\].
    #[prost(double, tag = "2")]
    pub score: f64,
    /// Immutable. Display name of the assigned issue. This field is set at time of
    /// analyis and immutable since then.
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
}
/// A piece of metadata that applies to a window of a call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallAnnotation {
    /// The channel of the audio where the annotation occurs. For single-channel
    /// audio, this field is not populated.
    #[prost(int32, tag = "1")]
    pub channel_tag: i32,
    /// The boundary in the conversation where the annotation starts, inclusive.
    #[prost(message, optional, tag = "4")]
    pub annotation_start_boundary: ::core::option::Option<AnnotationBoundary>,
    /// The boundary in the conversation where the annotation ends, inclusive.
    #[prost(message, optional, tag = "5")]
    pub annotation_end_boundary: ::core::option::Option<AnnotationBoundary>,
    /// The data in the annotation.
    #[prost(oneof = "call_annotation::Data", tags = "10, 11, 12, 13, 15, 16, 17, 18")]
    pub data: ::core::option::Option<call_annotation::Data>,
}
/// Nested message and enum types in `CallAnnotation`.
pub mod call_annotation {
    /// The data in the annotation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        /// Data specifying an interruption.
        #[prost(message, tag = "10")]
        InterruptionData(super::InterruptionData),
        /// Data specifying sentiment.
        #[prost(message, tag = "11")]
        SentimentData(super::SentimentData),
        /// Data specifying silence.
        #[prost(message, tag = "12")]
        SilenceData(super::SilenceData),
        /// Data specifying a hold.
        #[prost(message, tag = "13")]
        HoldData(super::HoldData),
        /// Data specifying an entity mention.
        #[prost(message, tag = "15")]
        EntityMentionData(super::EntityMentionData),
        /// Data specifying an intent match.
        #[prost(message, tag = "16")]
        IntentMatchData(super::IntentMatchData),
        /// Data specifying a phrase match.
        #[prost(message, tag = "17")]
        PhraseMatchData(super::PhraseMatchData),
        /// Data specifying an issue match.
        #[prost(message, tag = "18")]
        IssueMatchData(super::IssueMatchData),
    }
}
/// A point in a conversation that marks the start or the end of an annotation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnnotationBoundary {
    /// The index in the sequence of transcribed pieces of the conversation where
    /// the boundary is located. This index starts at zero.
    #[prost(int32, tag = "1")]
    pub transcript_index: i32,
    /// A detailed boundary, which describes a more specific point.
    #[prost(oneof = "annotation_boundary::DetailedBoundary", tags = "3")]
    pub detailed_boundary: ::core::option::Option<annotation_boundary::DetailedBoundary>,
}
/// Nested message and enum types in `AnnotationBoundary`.
pub mod annotation_boundary {
    /// A detailed boundary, which describes a more specific point.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum DetailedBoundary {
        /// The word index of this boundary with respect to the first word in the
        /// transcript piece. This index starts at zero.
        #[prost(int32, tag = "3")]
        WordIndex(i32),
    }
}
/// The data for an entity annotation.
/// Represents a phrase in the conversation that is a known entity, such
/// as a person, an organization, or location.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entity {
    /// The representative name for the entity.
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    /// The entity type.
    #[prost(enumeration = "entity::Type", tag = "2")]
    pub r#type: i32,
    /// Metadata associated with the entity.
    ///
    /// For most entity types, the metadata is a Wikipedia URL (`wikipedia_url`)
    /// and Knowledge Graph MID (`mid`), if they are available. For the metadata
    /// associated with other entity types, see the Type table below.
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The salience score associated with the entity in the \[0, 1.0\] range.
    ///
    /// The salience score for an entity provides information about the
    /// importance or centrality of that entity to the entire document text.
    /// Scores closer to 0 are less salient, while scores closer to 1.0 are highly
    /// salient.
    #[prost(float, tag = "4")]
    pub salience: f32,
    /// The aggregate sentiment expressed for this entity in the conversation.
    #[prost(message, optional, tag = "5")]
    pub sentiment: ::core::option::Option<SentimentData>,
}
/// Nested message and enum types in `Entity`.
pub mod entity {
    /// The type of the entity. For most entity types, the associated metadata is a
    /// Wikipedia URL (`wikipedia_url`) and Knowledge Graph MID (`mid`). The table
    /// below lists the associated fields for entities that have different
    /// metadata.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Unspecified.
        Unspecified = 0,
        /// Person.
        Person = 1,
        /// Location.
        Location = 2,
        /// Organization.
        Organization = 3,
        /// Event.
        Event = 4,
        /// Artwork.
        WorkOfArt = 5,
        /// Consumer product.
        ConsumerGood = 6,
        /// Other types of entities.
        Other = 7,
        /// Phone number.
        ///
        /// The metadata lists the phone number (formatted according to local
        /// convention), plus whichever additional elements appear in the text:
        ///
        /// * `number` - The actual number, broken down into sections according to
        /// local convention.
        /// * `national_prefix` - Country code, if detected.
        /// * `area_code` - Region or area code, if detected.
        /// * `extension` - Phone extension (to be dialed after connection), if
        /// detected.
        PhoneNumber = 9,
        /// Address.
        ///
        /// The metadata identifies the street number and locality plus whichever
        /// additional elements appear in the text:
        ///
        /// * `street_number` - Street number.
        /// * `locality` - City or town.
        /// * `street_name` - Street/route name, if detected.
        /// * `postal_code` - Postal code, if detected.
        /// * `country` - Country, if detected.
        /// * `broad_region` - Administrative area, such as the state, if detected.
        /// * `narrow_region` - Smaller administrative area, such as county, if
        /// detected.
        /// * `sublocality` - Used in Asian addresses to demark a district within a
        /// city, if detected.
        Address = 10,
        /// Date.
        ///
        /// The metadata identifies the components of the date:
        ///
        /// * `year` - Four digit year, if detected.
        /// * `month` - Two digit month number, if detected.
        /// * `day` - Two digit day number, if detected.
        Date = 11,
        /// Number.
        ///
        /// The metadata is the number itself.
        Number = 12,
        /// Price.
        ///
        /// The metadata identifies the `value` and `currency`.
        Price = 13,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Person => "PERSON",
                Self::Location => "LOCATION",
                Self::Organization => "ORGANIZATION",
                Self::Event => "EVENT",
                Self::WorkOfArt => "WORK_OF_ART",
                Self::ConsumerGood => "CONSUMER_GOOD",
                Self::Other => "OTHER",
                Self::PhoneNumber => "PHONE_NUMBER",
                Self::Address => "ADDRESS",
                Self::Date => "DATE",
                Self::Number => "NUMBER",
                Self::Price => "PRICE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PERSON" => Some(Self::Person),
                "LOCATION" => Some(Self::Location),
                "ORGANIZATION" => Some(Self::Organization),
                "EVENT" => Some(Self::Event),
                "WORK_OF_ART" => Some(Self::WorkOfArt),
                "CONSUMER_GOOD" => Some(Self::ConsumerGood),
                "OTHER" => Some(Self::Other),
                "PHONE_NUMBER" => Some(Self::PhoneNumber),
                "ADDRESS" => Some(Self::Address),
                "DATE" => Some(Self::Date),
                "NUMBER" => Some(Self::Number),
                "PRICE" => Some(Self::Price),
                _ => None,
            }
        }
    }
}
/// The data for an intent.
/// Represents a detected intent in the conversation, for example MAKES_PROMISE.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Intent {
    /// The unique identifier of the intent.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The human-readable name of the intent.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
}
/// The data for a matched phrase matcher.
/// Represents information identifying a phrase matcher for a given match.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhraseMatchData {
    /// The unique identifier (the resource name) of the phrase matcher.
    #[prost(string, tag = "1")]
    pub phrase_matcher: ::prost::alloc::string::String,
    /// The human-readable name of the phrase matcher.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
}
/// The data for a Dialogflow intent.
/// Represents a detected intent in the conversation, e.g. MAKES_PROMISE.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DialogflowIntent {
    /// The human-readable name of the intent.
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
}
/// The data for an interruption annotation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InterruptionData {}
/// The data for a silence annotation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SilenceData {}
/// The data for a hold annotation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HoldData {}
/// The data for an entity mention annotation.
/// This represents a mention of an `Entity` in the conversation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityMentionData {
    /// The key of this entity in conversation entities.
    /// Can be used to retrieve the exact `Entity` this mention is attached to.
    #[prost(string, tag = "1")]
    pub entity_unique_id: ::prost::alloc::string::String,
    /// The type of the entity mention.
    #[prost(enumeration = "entity_mention_data::MentionType", tag = "2")]
    pub r#type: i32,
    /// Sentiment expressed for this mention of the entity.
    #[prost(message, optional, tag = "3")]
    pub sentiment: ::core::option::Option<SentimentData>,
}
/// Nested message and enum types in `EntityMentionData`.
pub mod entity_mention_data {
    /// The supported types of mentions.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MentionType {
        /// Unspecified.
        Unspecified = 0,
        /// Proper noun.
        Proper = 1,
        /// Common noun (or noun compound).
        Common = 2,
    }
    impl MentionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MENTION_TYPE_UNSPECIFIED",
                Self::Proper => "PROPER",
                Self::Common => "COMMON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MENTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROPER" => Some(Self::Proper),
                "COMMON" => Some(Self::Common),
                _ => None,
            }
        }
    }
}
/// The data for an intent match.
/// Represents an intent match for a text segment in the conversation. A text
/// segment can be part of a sentence, a complete sentence, or an utterance
/// with multiple sentences.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntentMatchData {
    /// The id of the matched intent.
    /// Can be used to retrieve the corresponding intent information.
    #[prost(string, tag = "1")]
    pub intent_unique_id: ::prost::alloc::string::String,
}
/// The data for a sentiment annotation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SentimentData {
    /// A non-negative number from 0 to infinity which represents the abolute
    /// magnitude of sentiment regardless of score.
    #[prost(float, tag = "1")]
    pub magnitude: f32,
    /// The sentiment score between -1.0 (negative) and 1.0 (positive).
    #[prost(float, tag = "2")]
    pub score: f32,
}
/// The data for an issue match annotation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueMatchData {
    /// Information about the issue's assignment.
    #[prost(message, optional, tag = "1")]
    pub issue_assignment: ::core::option::Option<IssueAssignment>,
}
/// The issue model resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueModel {
    /// Immutable. The resource name of the issue model.
    /// Format:
    /// projects/{project}/locations/{location}/issueModels/{issue_model}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The representative name for the issue model.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The time at which this issue model was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The most recent time at which the issue model was updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Number of issues in this issue model.
    #[prost(int64, tag = "8")]
    pub issue_count: i64,
    /// Output only. State of the model.
    #[prost(enumeration = "issue_model::State", tag = "5")]
    pub state: i32,
    /// Configs for the input data that used to create the issue model.
    #[prost(message, optional, tag = "6")]
    pub input_data_config: ::core::option::Option<issue_model::InputDataConfig>,
    /// Output only. Immutable. The issue model's label statistics on its training
    /// data.
    #[prost(message, optional, tag = "7")]
    pub training_stats: ::core::option::Option<IssueModelLabelStats>,
    /// Type of the model.
    #[prost(enumeration = "issue_model::ModelType", tag = "9")]
    pub model_type: i32,
    /// Language of the model.
    #[prost(string, tag = "10")]
    pub language_code: ::prost::alloc::string::String,
}
/// Nested message and enum types in `IssueModel`.
pub mod issue_model {
    /// Configs for the input data used to create the issue model.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InputDataConfig {
        /// Medium of conversations used in training data. This field is being
        /// deprecated. To specify the medium to be used in training a new issue
        /// model, set the `medium` field on `filter`.
        #[deprecated]
        #[prost(enumeration = "super::conversation::Medium", tag = "1")]
        pub medium: i32,
        /// Output only. Number of conversations used in training. Output only.
        #[prost(int64, tag = "2")]
        pub training_conversations_count: i64,
        /// A filter to reduce the conversations used for training the model to a
        /// specific subset.
        #[prost(string, tag = "3")]
        pub filter: ::prost::alloc::string::String,
    }
    /// State of the model.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unspecified.
        Unspecified = 0,
        /// Model is not deployed but is ready to deploy.
        Undeployed = 1,
        /// Model is being deployed.
        Deploying = 2,
        /// Model is deployed and is ready to be used. A model can only be used in
        /// analysis if it's in this state.
        Deployed = 3,
        /// Model is being undeployed.
        Undeploying = 4,
        /// Model is being deleted.
        Deleting = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Undeployed => "UNDEPLOYED",
                Self::Deploying => "DEPLOYING",
                Self::Deployed => "DEPLOYED",
                Self::Undeploying => "UNDEPLOYING",
                Self::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "UNDEPLOYED" => Some(Self::Undeployed),
                "DEPLOYING" => Some(Self::Deploying),
                "DEPLOYED" => Some(Self::Deployed),
                "UNDEPLOYING" => Some(Self::Undeploying),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
    /// Type of the model.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ModelType {
        /// Unspecified model type.
        Unspecified = 0,
        /// Type V1.
        TypeV1 = 1,
        /// Type V2.
        TypeV2 = 2,
    }
    impl ModelType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODEL_TYPE_UNSPECIFIED",
                Self::TypeV1 => "TYPE_V1",
                Self::TypeV2 => "TYPE_V2",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODEL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TYPE_V1" => Some(Self::TypeV1),
                "TYPE_V2" => Some(Self::TypeV2),
                _ => None,
            }
        }
    }
}
/// The issue resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Issue {
    /// Immutable. The resource name of the issue.
    /// Format:
    /// projects/{project}/locations/{location}/issueModels/{issue_model}/issues/{issue}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The representative name for the issue.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The time at which this issue was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The most recent time that this issue was updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Resource names of the sample representative utterances that
    /// match to this issue.
    #[prost(string, repeated, tag = "6")]
    pub sample_utterances: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Representative description of the issue.
    #[prost(string, tag = "14")]
    pub display_description: ::prost::alloc::string::String,
}
/// Aggregated statistics about an issue model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueModelLabelStats {
    /// Number of conversations the issue model has analyzed at this point in time.
    #[prost(int64, tag = "1")]
    pub analyzed_conversations_count: i64,
    /// Number of analyzed conversations for which no issue was applicable at this
    /// point in time.
    #[prost(int64, tag = "2")]
    pub unclassified_conversations_count: i64,
    /// Statistics on each issue. Key is the issue's resource name.
    #[prost(map = "string, message", tag = "3")]
    pub issue_stats: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        issue_model_label_stats::IssueStats,
    >,
}
/// Nested message and enum types in `IssueModelLabelStats`.
pub mod issue_model_label_stats {
    /// Aggregated statistics about an issue.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IssueStats {
        /// Issue resource.
        /// Format:
        /// projects/{project}/locations/{location}/issueModels/{issue_model}/issues/{issue}
        #[prost(string, tag = "1")]
        pub issue: ::prost::alloc::string::String,
        /// Number of conversations attached to the issue at this point in time.
        #[prost(int64, tag = "2")]
        pub labeled_conversations_count: i64,
        /// Display name of the issue.
        #[prost(string, tag = "3")]
        pub display_name: ::prost::alloc::string::String,
    }
}
/// The phrase matcher resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhraseMatcher {
    /// The resource name of the phrase matcher.
    /// Format:
    /// projects/{project}/locations/{location}/phraseMatchers/{phrase_matcher}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Immutable. The revision ID of the phrase matcher.
    /// A new revision is committed whenever the matcher is changed, except when it
    /// is activated or deactivated. A server generated random ID will be used.
    /// Example: locations/global/phraseMatchers/my-first-matcher@1234567
    #[prost(string, tag = "2")]
    pub revision_id: ::prost::alloc::string::String,
    /// The customized version tag to use for the phrase matcher. If not specified,
    /// it will default to `revision_id`.
    #[prost(string, tag = "3")]
    pub version_tag: ::prost::alloc::string::String,
    /// Output only. The timestamp of when the revision was created. It is also the
    /// create time when a new matcher is added.
    #[prost(message, optional, tag = "4")]
    pub revision_create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The human-readable name of the phrase matcher.
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    /// Required. The type of this phrase matcher.
    #[prost(enumeration = "phrase_matcher::PhraseMatcherType", tag = "6")]
    pub r#type: i32,
    /// Applies the phrase matcher only when it is active.
    #[prost(bool, tag = "7")]
    pub active: bool,
    /// A list of phase match rule groups that are included in this matcher.
    #[prost(message, repeated, tag = "8")]
    pub phrase_match_rule_groups: ::prost::alloc::vec::Vec<PhraseMatchRuleGroup>,
    /// Output only. The most recent time at which the activation status was
    /// updated.
    #[prost(message, optional, tag = "9")]
    pub activation_update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The role whose utterances the phrase matcher should be matched
    /// against. If the role is ROLE_UNSPECIFIED it will be matched against any
    /// utterances in the transcript.
    #[prost(enumeration = "conversation_participant::Role", tag = "10")]
    pub role_match: i32,
    /// Output only. The most recent time at which the phrase matcher was updated.
    #[prost(message, optional, tag = "11")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `PhraseMatcher`.
pub mod phrase_matcher {
    /// Specifies how to combine each phrase match rule group to determine whether
    /// there is a match.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PhraseMatcherType {
        /// Unspecified.
        Unspecified = 0,
        /// Must meet all phrase match rule groups or there is no match.
        AllOf = 1,
        /// If any of the phrase match rule groups are met, there is a match.
        AnyOf = 2,
    }
    impl PhraseMatcherType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PHRASE_MATCHER_TYPE_UNSPECIFIED",
                Self::AllOf => "ALL_OF",
                Self::AnyOf => "ANY_OF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PHRASE_MATCHER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ALL_OF" => Some(Self::AllOf),
                "ANY_OF" => Some(Self::AnyOf),
                _ => None,
            }
        }
    }
}
/// A message representing a rule in the phrase matcher.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhraseMatchRuleGroup {
    /// Required. The type of this phrase match rule group.
    #[prost(
        enumeration = "phrase_match_rule_group::PhraseMatchRuleGroupType",
        tag = "1"
    )]
    pub r#type: i32,
    /// A list of phrase match rules that are included in this group.
    #[prost(message, repeated, tag = "2")]
    pub phrase_match_rules: ::prost::alloc::vec::Vec<PhraseMatchRule>,
}
/// Nested message and enum types in `PhraseMatchRuleGroup`.
pub mod phrase_match_rule_group {
    /// Specifies how to combine each phrase match rule for whether there is a
    /// match.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PhraseMatchRuleGroupType {
        /// Unspecified.
        Unspecified = 0,
        /// Must meet all phrase match rules or there is no match.
        AllOf = 1,
        /// If any of the phrase match rules are met, there is a match.
        AnyOf = 2,
    }
    impl PhraseMatchRuleGroupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PHRASE_MATCH_RULE_GROUP_TYPE_UNSPECIFIED",
                Self::AllOf => "ALL_OF",
                Self::AnyOf => "ANY_OF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PHRASE_MATCH_RULE_GROUP_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ALL_OF" => Some(Self::AllOf),
                "ANY_OF" => Some(Self::AnyOf),
                _ => None,
            }
        }
    }
}
/// The data for a phrase match rule.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhraseMatchRule {
    /// Required. The phrase to be matched.
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    /// Specifies whether the phrase must be missing from the transcript segment or
    /// present in the transcript segment.
    #[prost(bool, tag = "2")]
    pub negated: bool,
    /// Provides additional information about the rule that specifies how to apply
    /// the rule.
    #[prost(message, optional, tag = "3")]
    pub config: ::core::option::Option<PhraseMatchRuleConfig>,
}
/// Configuration information of a phrase match rule.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PhraseMatchRuleConfig {
    /// The configuration of the phrase match rule.
    #[prost(oneof = "phrase_match_rule_config::Config", tags = "1")]
    pub config: ::core::option::Option<phrase_match_rule_config::Config>,
}
/// Nested message and enum types in `PhraseMatchRuleConfig`.
pub mod phrase_match_rule_config {
    /// The configuration of the phrase match rule.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Config {
        /// The configuration for the exact match rule.
        #[prost(message, tag = "1")]
        ExactMatchConfig(super::ExactMatchConfig),
    }
}
/// Exact match configuration.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExactMatchConfig {
    /// Whether to consider case sensitivity when performing an exact match.
    #[prost(bool, tag = "1")]
    pub case_sensitive: bool,
}
/// The CCAI Insights project wide settings.
/// Use these settings to configure the behavior of Insights.
/// View these settings with
/// [`getsettings`](<https://cloud.google.com/contact-center/insights/docs/reference/rest/v1/projects.locations/getSettings>)
/// and change the settings with
/// [`updateSettings`](<https://cloud.google.com/contact-center/insights/docs/reference/rest/v1/projects.locations/updateSettings>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Settings {
    /// Immutable. The resource name of the settings resource.
    /// Format:
    /// projects/{project}/locations/{location}/settings
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The time at which the settings was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time at which the settings were last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// A language code to be applied to each transcript segment unless the segment
    /// already specifies a language code. Language code defaults to "en-US" if it
    /// is neither specified on the segment nor here.
    #[prost(string, tag = "4")]
    pub language_code: ::prost::alloc::string::String,
    /// The default TTL for newly-created conversations. If a conversation has a
    /// specified expiration, that value will be used instead. Changing this
    /// value will not change the expiration of existing conversations.
    /// Conversations with no expire time persist until they are deleted.
    #[prost(message, optional, tag = "5")]
    pub conversation_ttl: ::core::option::Option<::prost_types::Duration>,
    /// A map that maps a notification trigger to a Pub/Sub topic. Each time a
    /// specified trigger occurs, Insights will notify the corresponding Pub/Sub
    /// topic.
    ///
    /// Keys are notification triggers. Supported keys are:
    ///
    /// * "all-triggers": Notify each time any of the supported triggers occurs.
    /// * "create-analysis": Notify each time an analysis is created.
    /// * "create-conversation": Notify each time a conversation is created.
    /// * "export-insights-data": Notify each time an export is complete.
    /// * "ingest-conversations": Notify each time an IngestConversations LRO is
    /// complete.
    /// * "update-conversation": Notify each time a conversation is updated via
    /// UpdateConversation.
    /// * "upload-conversation": Notify when an UploadConversation LRO is complete.
    ///
    /// Values are Pub/Sub topics. The format of each Pub/Sub topic is:
    /// projects/{project}/topics/{topic}
    #[prost(map = "string, string", tag = "6")]
    pub pubsub_notification_settings: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Default analysis settings.
    #[prost(message, optional, tag = "7")]
    pub analysis_config: ::core::option::Option<settings::AnalysisConfig>,
    /// Default DLP redaction resources to be applied while ingesting
    /// conversations. This applies to conversations ingested from the
    /// `UploadConversation` and `IngestConversations` endpoints, including
    /// conversations coming from CCAI Platform.
    #[prost(message, optional, tag = "10")]
    pub redaction_config: ::core::option::Option<RedactionConfig>,
    /// Optional. Default Speech-to-Text resources to use while ingesting audio
    /// files. Optional, CCAI Insights will create a default if not provided. This
    /// applies to conversations ingested from the `UploadConversation` and
    /// `IngestConversations` endpoints, including conversations coming from CCAI
    /// Platform.
    #[prost(message, optional, tag = "11")]
    pub speech_config: ::core::option::Option<SpeechConfig>,
}
/// Nested message and enum types in `Settings`.
pub mod settings {
    /// Default configuration when creating Analyses in Insights.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AnalysisConfig {
        /// Percentage of conversations created using Dialogflow runtime integration
        /// to analyze automatically, between \[0, 100\].
        #[prost(double, tag = "1")]
        pub runtime_integration_analysis_percentage: f64,
        /// Percentage of conversations created using the UploadConversation endpoint
        /// to analyze automatically, between \[0, 100\].
        #[prost(double, tag = "6")]
        pub upload_conversation_analysis_percentage: f64,
        /// To select the annotators to run and the phrase matchers to use
        /// (if any). If not specified, all annotators will be run.
        #[prost(message, optional, tag = "5")]
        pub annotator_selector: ::core::option::Option<super::AnnotatorSelector>,
    }
}
/// The CCAI Insights project wide analysis rule. This rule will be applied to
/// all conversations that match the filter defined in the rule. For a
/// conversation matches the filter, the annotators specified in the rule will be
/// run. If a conversation matches multiple rules, a union of all the annotators
/// will be run. One project can have multiple analysis rules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisRule {
    /// Identifier. The resource name of the analysis rule.
    /// Format:
    /// projects/{project}/locations/{location}/analysisRules/{analysis_rule}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The time at which this analysis rule was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The most recent time at which this analysis rule was updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Display Name of the analysis rule.
    #[prost(string, optional, tag = "4")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Filter for the conversations that should apply this analysis
    /// rule. An empty filter means this analysis rule applies to all
    /// conversations.
    #[prost(string, tag = "5")]
    pub conversation_filter: ::prost::alloc::string::String,
    /// Selector of annotators to run and the phrase matchers to use for
    /// conversations that matches the conversation_filter. If not specified, NO
    /// annotators will be run.
    #[prost(message, optional, tag = "6")]
    pub annotator_selector: ::core::option::Option<AnnotatorSelector>,
    /// Percentage of conversations that we should apply this analysis setting
    /// automatically, between \[0, 1\]. For example, 0.1 means 10%. Conversations
    /// are sampled in a determenestic way. The original runtime_percentage &
    /// upload percentage will be replaced by defining filters on the conversation.
    #[prost(double, tag = "7")]
    pub analysis_percentage: f64,
    /// If true, apply this rule to conversations. Otherwise, this rule is
    /// inactive and saved as a draft.
    #[prost(bool, tag = "8")]
    pub active: bool,
}
/// A customer-managed encryption key specification that can be applied to all
/// created resources (e.g. `Conversation`).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptionSpec {
    /// Immutable. The resource name of the encryption key specification resource.
    /// Format:
    /// projects/{project}/locations/{location}/encryptionSpec
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The name of customer-managed encryption key that is used to
    /// secure a resource and its sub-resources. If empty, the resource is secured
    /// by our default encryption key. Only the key in the same location as this
    /// resource is allowed to be used for encryption. Format:
    /// `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}`
    #[prost(string, tag = "2")]
    pub kms_key: ::prost::alloc::string::String,
}
/// DLP resources used for redaction while ingesting conversations.
/// DLP settings are applied to conversations ingested from the
/// `UploadConversation` and `IngestConversations` endpoints, including
/// conversation coming from CCAI Platform. They are not applied to conversations
/// ingested from the `CreateConversation` endpoint or the Dialogflow / Agent
/// Assist runtime integrations. When using Dialogflow / Agent Assist runtime
/// integrations, redaction should be performed in Dialogflow / Agent Assist.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedactionConfig {
    /// The fully-qualified DLP deidentify template resource name.
    /// Format:
    /// `projects/{project}/deidentifyTemplates/{template}`
    #[prost(string, tag = "1")]
    pub deidentify_template: ::prost::alloc::string::String,
    /// The fully-qualified DLP inspect template resource name.
    /// Format:
    /// `projects/{project}/locations/{location}/inspectTemplates/{template}`
    #[prost(string, tag = "2")]
    pub inspect_template: ::prost::alloc::string::String,
}
/// Speech-to-Text configuration.
/// Speech-to-Text settings are applied to conversations ingested from the
/// `UploadConversation` and `IngestConversations` endpoints, including
/// conversation coming from CCAI Platform. They are not applied to conversations
/// ingested from the `CreateConversation` endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpeechConfig {
    /// The fully-qualified Speech Recognizer resource name.
    /// Format:
    /// `projects/{project_id}/locations/{location}/recognizer/{recognizer}`
    #[prost(string, tag = "1")]
    pub speech_recognizer: ::prost::alloc::string::String,
}
/// An annotation that was generated during the customer and agent interaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeAnnotation {
    /// The unique identifier of the annotation.
    /// Format:
    /// projects/{project}/locations/{location}/conversationDatasets/{dataset}/conversationDataItems/{data_item}/conversationAnnotations/{annotation}
    #[prost(string, tag = "1")]
    pub annotation_id: ::prost::alloc::string::String,
    /// The time at which this annotation was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The boundary in the conversation where the annotation starts, inclusive.
    #[prost(message, optional, tag = "3")]
    pub start_boundary: ::core::option::Option<AnnotationBoundary>,
    /// The boundary in the conversation where the annotation ends, inclusive.
    #[prost(message, optional, tag = "4")]
    pub end_boundary: ::core::option::Option<AnnotationBoundary>,
    /// The feedback that the customer has about the answer in `data`.
    #[prost(message, optional, tag = "5")]
    pub answer_feedback: ::core::option::Option<AnswerFeedback>,
    /// Explicit input used for generating the answer
    #[prost(message, optional, tag = "16")]
    pub user_input: ::core::option::Option<runtime_annotation::UserInput>,
    /// The data in the annotation.
    #[prost(oneof = "runtime_annotation::Data", tags = "6, 7, 8, 9, 10, 12")]
    pub data: ::core::option::Option<runtime_annotation::Data>,
}
/// Nested message and enum types in `RuntimeAnnotation`.
pub mod runtime_annotation {
    /// Explicit input used for generating the answer
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserInput {
        /// Query text. Article Search uses this to store the input query used
        /// to generate the search results.
        #[prost(string, tag = "1")]
        pub query: ::prost::alloc::string::String,
        /// The resource name of associated generator. Format:
        /// `projects/<Project ID>/locations/<Location ID>/generators/<Generator ID>`
        #[prost(string, tag = "2")]
        pub generator_name: ::prost::alloc::string::String,
        /// Query source for the answer.
        #[prost(enumeration = "user_input::QuerySource", tag = "3")]
        pub query_source: i32,
    }
    /// Nested message and enum types in `UserInput`.
    pub mod user_input {
        /// The source of the query.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum QuerySource {
            /// Unknown query source.
            Unspecified = 0,
            /// The query is from agents.
            AgentQuery = 1,
            /// The query is a query from previous suggestions, e.g. from a preceding
            /// SuggestKnowledgeAssist response.
            SuggestedQuery = 2,
        }
        impl QuerySource {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "QUERY_SOURCE_UNSPECIFIED",
                    Self::AgentQuery => "AGENT_QUERY",
                    Self::SuggestedQuery => "SUGGESTED_QUERY",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "QUERY_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
                    "AGENT_QUERY" => Some(Self::AgentQuery),
                    "SUGGESTED_QUERY" => Some(Self::SuggestedQuery),
                    _ => None,
                }
            }
        }
    }
    /// The data in the annotation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        /// Agent Assist Article Suggestion data.
        #[prost(message, tag = "6")]
        ArticleSuggestion(super::ArticleSuggestionData),
        /// Agent Assist FAQ answer data.
        #[prost(message, tag = "7")]
        FaqAnswer(super::FaqAnswerData),
        /// Agent Assist Smart Reply data.
        #[prost(message, tag = "8")]
        SmartReply(super::SmartReplyData),
        /// Agent Assist Smart Compose suggestion data.
        #[prost(message, tag = "9")]
        SmartComposeSuggestion(super::SmartComposeSuggestionData),
        /// Dialogflow interaction data.
        #[prost(message, tag = "10")]
        DialogflowInteraction(super::DialogflowInteractionData),
        /// Conversation summarization suggestion data.
        #[prost(message, tag = "12")]
        ConversationSummarizationSuggestion(
            super::ConversationSummarizationSuggestionData,
        ),
    }
}
/// The feedback that the customer has about a certain answer in the
/// conversation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnswerFeedback {
    /// The correctness level of an answer.
    #[prost(enumeration = "answer_feedback::CorrectnessLevel", tag = "1")]
    pub correctness_level: i32,
    /// Indicates whether an answer or item was clicked by the human agent.
    #[prost(bool, tag = "2")]
    pub clicked: bool,
    /// Indicates whether an answer or item was displayed to the human agent in the
    /// agent desktop UI.
    #[prost(bool, tag = "3")]
    pub displayed: bool,
}
/// Nested message and enum types in `AnswerFeedback`.
pub mod answer_feedback {
    /// The correctness level of an answer.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CorrectnessLevel {
        /// Correctness level unspecified.
        Unspecified = 0,
        /// Answer is totally wrong.
        NotCorrect = 1,
        /// Answer is partially correct.
        PartiallyCorrect = 2,
        /// Answer is fully correct.
        FullyCorrect = 3,
    }
    impl CorrectnessLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CORRECTNESS_LEVEL_UNSPECIFIED",
                Self::NotCorrect => "NOT_CORRECT",
                Self::PartiallyCorrect => "PARTIALLY_CORRECT",
                Self::FullyCorrect => "FULLY_CORRECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CORRECTNESS_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
                "NOT_CORRECT" => Some(Self::NotCorrect),
                "PARTIALLY_CORRECT" => Some(Self::PartiallyCorrect),
                "FULLY_CORRECT" => Some(Self::FullyCorrect),
                _ => None,
            }
        }
    }
}
/// Agent Assist Article Suggestion data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArticleSuggestionData {
    /// Article title.
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// Article URI.
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    /// The system's confidence score that this article is a good match for this
    /// conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely
    /// certain).
    #[prost(float, tag = "3")]
    pub confidence_score: f32,
    /// Map that contains metadata about the Article Suggestion and the document
    /// that it originates from.
    #[prost(map = "string, string", tag = "4")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The name of the answer record.
    /// Format:
    /// projects/{project}/locations/{location}/answerRecords/{answer_record}
    #[prost(string, tag = "5")]
    pub query_record: ::prost::alloc::string::String,
    /// The knowledge document that this answer was extracted from.
    /// Format:
    /// projects/{project}/knowledgeBases/{knowledge_base}/documents/{document}
    #[prost(string, tag = "6")]
    pub source: ::prost::alloc::string::String,
}
/// Agent Assist frequently-asked-question answer data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FaqAnswerData {
    /// The piece of text from the `source` knowledge base document.
    #[prost(string, tag = "1")]
    pub answer: ::prost::alloc::string::String,
    /// The system's confidence score that this answer is a good match for this
    /// conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely
    /// certain).
    #[prost(float, tag = "2")]
    pub confidence_score: f32,
    /// The corresponding FAQ question.
    #[prost(string, tag = "3")]
    pub question: ::prost::alloc::string::String,
    /// Map that contains metadata about the FAQ answer and the document that
    /// it originates from.
    #[prost(map = "string, string", tag = "4")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The name of the answer record.
    /// Format:
    /// projects/{project}/locations/{location}/answerRecords/{answer_record}
    #[prost(string, tag = "5")]
    pub query_record: ::prost::alloc::string::String,
    /// The knowledge document that this answer was extracted from.
    /// Format:
    /// projects/{project}/knowledgeBases/{knowledge_base}/documents/{document}.
    #[prost(string, tag = "6")]
    pub source: ::prost::alloc::string::String,
}
/// Agent Assist Smart Reply data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartReplyData {
    /// The content of the reply.
    #[prost(string, tag = "1")]
    pub reply: ::prost::alloc::string::String,
    /// The system's confidence score that this reply is a good match for this
    /// conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely
    /// certain).
    #[prost(double, tag = "2")]
    pub confidence_score: f64,
    /// Map that contains metadata about the Smart Reply and the document from
    /// which it originates.
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The name of the answer record.
    /// Format:
    /// projects/{project}/locations/{location}/answerRecords/{answer_record}
    #[prost(string, tag = "4")]
    pub query_record: ::prost::alloc::string::String,
}
/// Agent Assist Smart Compose suggestion data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartComposeSuggestionData {
    /// The content of the suggestion.
    #[prost(string, tag = "1")]
    pub suggestion: ::prost::alloc::string::String,
    /// The system's confidence score that this suggestion is a good match for this
    /// conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely
    /// certain).
    #[prost(double, tag = "2")]
    pub confidence_score: f64,
    /// Map that contains metadata about the Smart Compose suggestion and the
    /// document from which it originates.
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The name of the answer record.
    /// Format:
    /// projects/{project}/locations/{location}/answerRecords/{answer_record}
    #[prost(string, tag = "4")]
    pub query_record: ::prost::alloc::string::String,
}
/// Dialogflow interaction data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DialogflowInteractionData {
    /// The Dialogflow intent resource path. Format:
    /// projects/{project}/agent/{agent}/intents/{intent}
    #[prost(string, tag = "1")]
    pub dialogflow_intent_id: ::prost::alloc::string::String,
    /// The confidence of the match ranging from 0.0 (completely uncertain) to 1.0
    /// (completely certain).
    #[prost(float, tag = "2")]
    pub confidence: f32,
}
/// Conversation summarization suggestion data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationSummarizationSuggestionData {
    /// The summarization content that is concatenated into one string.
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// The summarization content that is divided into sections. The key is the
    /// section's name and the value is the section's content. There is no
    /// specific format for the key or value.
    #[prost(map = "string, string", tag = "5")]
    pub text_sections: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The confidence score of the summarization.
    #[prost(float, tag = "2")]
    pub confidence: f32,
    /// A map that contains metadata about the summarization and the document
    /// from which it originates.
    #[prost(map = "string, string", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The name of the answer record.
    /// Format:
    /// projects/{project}/locations/{location}/answerRecords/{answer_record}
    #[prost(string, tag = "4")]
    pub answer_record: ::prost::alloc::string::String,
    /// The name of the model that generates this summary.
    /// Format:
    /// projects/{project}/locations/{location}/conversationModels/{conversation_model}
    #[prost(string, tag = "6")]
    pub conversation_model: ::prost::alloc::string::String,
}
/// The call participant speaking for a given utterance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationParticipant {
    /// Deprecated. Use `dialogflow_participant_name` instead.
    /// The name of the Dialogflow participant. Format:
    /// projects/{project}/locations/{location}/conversations/{conversation}/participants/{participant}
    #[deprecated]
    #[prost(string, tag = "1")]
    pub dialogflow_participant: ::prost::alloc::string::String,
    /// Obfuscated user ID from Dialogflow.
    #[prost(string, tag = "3")]
    pub obfuscated_external_user_id: ::prost::alloc::string::String,
    /// The role of the participant.
    #[prost(enumeration = "conversation_participant::Role", tag = "2")]
    pub role: i32,
    #[prost(oneof = "conversation_participant::Participant", tags = "5, 6")]
    pub participant: ::core::option::Option<conversation_participant::Participant>,
}
/// Nested message and enum types in `ConversationParticipant`.
pub mod conversation_participant {
    /// The role of the participant.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Role {
        /// Participant's role is not set.
        Unspecified = 0,
        /// Participant is a human agent.
        HumanAgent = 1,
        /// Participant is an automated agent.
        AutomatedAgent = 2,
        /// Participant is an end user who conversed with the contact center.
        EndUser = 3,
        /// Participant is either a human or automated agent.
        AnyAgent = 4,
    }
    impl Role {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ROLE_UNSPECIFIED",
                Self::HumanAgent => "HUMAN_AGENT",
                Self::AutomatedAgent => "AUTOMATED_AGENT",
                Self::EndUser => "END_USER",
                Self::AnyAgent => "ANY_AGENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROLE_UNSPECIFIED" => Some(Self::Unspecified),
                "HUMAN_AGENT" => Some(Self::HumanAgent),
                "AUTOMATED_AGENT" => Some(Self::AutomatedAgent),
                "END_USER" => Some(Self::EndUser),
                "ANY_AGENT" => Some(Self::AnyAgent),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Participant {
        /// The name of the participant provided by Dialogflow. Format:
        /// projects/{project}/locations/{location}/conversations/{conversation}/participants/{participant}
        #[prost(string, tag = "5")]
        DialogflowParticipantName(::prost::alloc::string::String),
        /// A user-specified ID representing the participant.
        #[prost(string, tag = "6")]
        UserId(::prost::alloc::string::String),
    }
}
/// The View resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct View {
    /// Immutable. The resource name of the view.
    /// Format:
    /// projects/{project}/locations/{location}/views/{view}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The human-readable display name of the view.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The time at which this view was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The most recent time at which the view was updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// String with specific view properties, must be non-empty.
    #[prost(string, tag = "5")]
    pub value: ::prost::alloc::string::String,
}
/// Selector of all available annotators and phrase matchers to run.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotatorSelector {
    /// Whether to run the interruption annotator.
    #[prost(bool, tag = "1")]
    pub run_interruption_annotator: bool,
    /// Whether to run the silence annotator.
    #[prost(bool, tag = "2")]
    pub run_silence_annotator: bool,
    /// Whether to run the active phrase matcher annotator(s).
    #[prost(bool, tag = "3")]
    pub run_phrase_matcher_annotator: bool,
    /// The list of phrase matchers to run. If not provided, all active phrase
    /// matchers will be used. If inactive phrase matchers are provided, they will
    /// not be used. Phrase matchers will be run only if
    /// run_phrase_matcher_annotator is set to true. Format:
    /// projects/{project}/locations/{location}/phraseMatchers/{phrase_matcher}
    #[prost(string, repeated, tag = "4")]
    pub phrase_matchers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Whether to run the sentiment annotator.
    #[prost(bool, tag = "5")]
    pub run_sentiment_annotator: bool,
    /// Whether to run the entity annotator.
    #[prost(bool, tag = "6")]
    pub run_entity_annotator: bool,
    /// Whether to run the intent annotator.
    #[prost(bool, tag = "7")]
    pub run_intent_annotator: bool,
    /// Whether to run the issue model annotator. A model should have already been
    /// deployed for this to take effect.
    #[prost(bool, tag = "8")]
    pub run_issue_model_annotator: bool,
    /// The issue model to run. If not provided, the most recently deployed topic
    /// model will be used. The provided issue model will only be used for
    /// inference if the issue model is deployed and if run_issue_model_annotator
    /// is set to true. If more than one issue model is provided, only the first
    /// provided issue model will be used for inference.
    #[prost(string, repeated, tag = "10")]
    pub issue_models: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Whether to run the summarization annotator.
    #[prost(bool, tag = "9")]
    pub run_summarization_annotator: bool,
    /// Configuration for the summarization annotator.
    #[prost(message, optional, tag = "11")]
    pub summarization_config: ::core::option::Option<
        annotator_selector::SummarizationConfig,
    >,
    /// Whether to run the QA annotator.
    #[prost(bool, tag = "12")]
    pub run_qa_annotator: bool,
    /// Configuration for the QA annotator.
    #[prost(message, optional, tag = "13")]
    pub qa_config: ::core::option::Option<annotator_selector::QaConfig>,
}
/// Nested message and enum types in `AnnotatorSelector`.
pub mod annotator_selector {
    /// Configuration for summarization.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SummarizationConfig {
        /// Summarization must use either a preexisting conversation profile or one
        /// of the supported default models.
        #[prost(oneof = "summarization_config::ModelSource", tags = "1, 2")]
        pub model_source: ::core::option::Option<summarization_config::ModelSource>,
    }
    /// Nested message and enum types in `SummarizationConfig`.
    pub mod summarization_config {
        /// Summarization model to use, if `conversation_profile` is not used.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SummarizationModel {
            /// Unspecified summarization model.
            Unspecified = 0,
            /// The CCAI baseline model.
            BaselineModel = 1,
            /// The CCAI baseline model, V2.0.
            BaselineModelV20 = 2,
        }
        impl SummarizationModel {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SUMMARIZATION_MODEL_UNSPECIFIED",
                    Self::BaselineModel => "BASELINE_MODEL",
                    Self::BaselineModelV20 => "BASELINE_MODEL_V2_0",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SUMMARIZATION_MODEL_UNSPECIFIED" => Some(Self::Unspecified),
                    "BASELINE_MODEL" => Some(Self::BaselineModel),
                    "BASELINE_MODEL_V2_0" => Some(Self::BaselineModelV20),
                    _ => None,
                }
            }
        }
        /// Summarization must use either a preexisting conversation profile or one
        /// of the supported default models.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ModelSource {
            /// Resource name of the Dialogflow conversation profile.
            /// Format:
            /// projects/{project}/locations/{location}/conversationProfiles/{conversation_profile}
            #[prost(string, tag = "1")]
            ConversationProfile(::prost::alloc::string::String),
            /// Default summarization model to be used.
            #[prost(enumeration = "SummarizationModel", tag = "2")]
            SummarizationModel(i32),
        }
    }
    /// Configuration for the QA feature.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QaConfig {
        /// Which scorecards should be scored.
        #[prost(oneof = "qa_config::ScorecardSource", tags = "1")]
        pub scorecard_source: ::core::option::Option<qa_config::ScorecardSource>,
    }
    /// Nested message and enum types in `QaConfig`.
    pub mod qa_config {
        /// Container for a list of scorecards.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ScorecardList {
            /// List of QaScorecardRevisions.
            #[prost(string, repeated, tag = "1")]
            pub qa_scorecard_revisions: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
        }
        /// Which scorecards should be scored.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ScorecardSource {
            /// A manual list of scorecards to score.
            #[prost(message, tag = "1")]
            ScorecardList(ScorecardList),
        }
    }
}
/// A single question to be scored by the Insights QA feature.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QaQuestion {
    /// Identifier. The resource name of the question.
    /// Format:
    /// projects/{project}/locations/{location}/qaScorecards/{qa_scorecard}/revisions/{revision}/qaQuestions/{qa_question}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Short, descriptive string, used in the UI where it's not practical
    /// to display the full question body. E.g., "Greeting".
    #[prost(string, tag = "2")]
    pub abbreviation: ::prost::alloc::string::String,
    /// Output only. The time at which this question was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The most recent time at which the question was updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Question text. E.g., "Did the agent greet the customer?"
    #[prost(string, tag = "5")]
    pub question_body: ::prost::alloc::string::String,
    /// Instructions describing how to determine the answer.
    #[prost(string, tag = "9")]
    pub answer_instructions: ::prost::alloc::string::String,
    /// A list of valid answers to the question, which the LLM must choose from.
    #[prost(message, repeated, tag = "6")]
    pub answer_choices: ::prost::alloc::vec::Vec<qa_question::AnswerChoice>,
    /// User-defined list of arbitrary tags for the question. Used for
    /// grouping/organization and for weighting the score of each question.
    #[prost(string, repeated, tag = "7")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Defines the order of the question within its parent scorecard revision.
    #[prost(int32, tag = "8")]
    pub order: i32,
    /// Metrics of the underlying tuned LLM over a holdout/test set while fine
    /// tuning the underlying LLM for the given question. This field will only be
    /// populated if and only if the question is part of a scorecard revision that
    /// has been tuned.
    #[prost(message, optional, tag = "10")]
    pub metrics: ::core::option::Option<qa_question::Metrics>,
    /// Metadata about the tuning operation for the question.This field will only
    /// be populated if and only if the question is part of a scorecard revision
    /// that has been tuned.
    #[prost(message, optional, tag = "11")]
    pub tuning_metadata: ::core::option::Option<qa_question::TuningMetadata>,
}
/// Nested message and enum types in `QaQuestion`.
pub mod qa_question {
    /// Message representing a possible answer to the question.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AnswerChoice {
        /// A short string used as an identifier.
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        /// Numerical score of the answer, used for generating the overall score of
        /// a QaScorecardResult. If the answer uses na_value, this field is unused.
        #[prost(double, optional, tag = "6")]
        pub score: ::core::option::Option<f64>,
        /// The answer value may be one of a few different types.
        #[prost(oneof = "answer_choice::Value", tags = "2, 3, 4, 5")]
        pub value: ::core::option::Option<answer_choice::Value>,
    }
    /// Nested message and enum types in `AnswerChoice`.
    pub mod answer_choice {
        /// The answer value may be one of a few different types.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            /// String value.
            #[prost(string, tag = "2")]
            StrValue(::prost::alloc::string::String),
            /// Numerical value.
            #[prost(double, tag = "3")]
            NumValue(f64),
            /// Boolean value.
            #[prost(bool, tag = "4")]
            BoolValue(bool),
            /// A value of "Not Applicable (N/A)". If provided, this field may only
            /// be set to `true`. If a question receives this answer, it will be
            /// excluded from any score calculations.
            #[prost(bool, tag = "5")]
            NaValue(bool),
        }
    }
    /// A wrapper representing metrics calculated against a test-set on a LLM that
    /// was fine tuned for this question.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Metrics {
        /// Output only. Accuracy of the model. Measures the percentage of correct
        /// answers the model gave on the test set.
        #[prost(double, tag = "1")]
        pub accuracy: f64,
    }
    /// Metadata about the tuning operation for the question. Will only be set if a
    /// scorecard containing this question has been tuned.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TuningMetadata {
        /// Total number of valid labels provided for the question at the time of
        /// tuining.
        #[prost(int64, tag = "1")]
        pub total_valid_label_count: i64,
        /// A list of any applicable data validation warnings about the question's
        /// feedback labels.
        #[prost(enumeration = "super::DatasetValidationWarning", repeated, tag = "2")]
        pub dataset_validation_warnings: ::prost::alloc::vec::Vec<i32>,
        /// Error status of the tuning operation for the question. Will only be set
        /// if the tuning operation failed.
        #[prost(string, tag = "3")]
        pub tuning_error: ::prost::alloc::string::String,
    }
}
/// A QaScorecard represents a collection of questions to be scored during
/// analysis.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QaScorecard {
    /// Identifier. The scorecard name.
    /// Format:
    /// projects/{project}/locations/{location}/qaScorecards/{qa_scorecard}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The user-specified display name of the scorecard.
    #[prost(string, tag = "7")]
    pub display_name: ::prost::alloc::string::String,
    /// A text description explaining the intent of the scorecard.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The time at which this scorecard was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The most recent time at which the scorecard was updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// A revision of a QaScorecard.
///
/// Modifying published scorecard fields would invalidate existing scorecard
/// results — the questions may have changed, or the score weighting will make
/// existing scores impossible to understand. So changes must create a new
/// revision, rather than modifying the existing resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QaScorecardRevision {
    /// Identifier. The name of the scorecard revision.
    /// Format:
    /// projects/{project}/locations/{location}/qaScorecards/{qa_scorecard}/revisions/{revision}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The snapshot of the scorecard at the time of this revision's creation.
    #[prost(message, optional, tag = "2")]
    pub snapshot: ::core::option::Option<QaScorecard>,
    /// Output only. The timestamp that the revision was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Alternative IDs for this revision of the scorecard, e.g.,
    /// `latest`.
    #[prost(string, repeated, tag = "4")]
    pub alternate_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. State of the scorecard revision, indicating whether it's ready
    /// to be used in analysis.
    #[prost(enumeration = "qa_scorecard_revision::State", tag = "5")]
    pub state: i32,
}
/// Nested message and enum types in `QaScorecardRevision`.
pub mod qa_scorecard_revision {
    /// Enum representing the set of states a scorecard revision may be in.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unspecified.
        Unspecified = 0,
        /// The scorecard revision can be edited.
        Editable = 12,
        /// Scorecard model training is in progress.
        Training = 2,
        /// Scorecard revision model training failed.
        TrainingFailed = 9,
        /// The revision can be used in analysis.
        Ready = 11,
        /// Scorecard is being deleted.
        Deleting = 7,
        /// Scorecard model training was explicitly cancelled by the user.
        TrainingCancelled = 14,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Editable => "EDITABLE",
                Self::Training => "TRAINING",
                Self::TrainingFailed => "TRAINING_FAILED",
                Self::Ready => "READY",
                Self::Deleting => "DELETING",
                Self::TrainingCancelled => "TRAINING_CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "EDITABLE" => Some(Self::Editable),
                "TRAINING" => Some(Self::Training),
                "TRAINING_FAILED" => Some(Self::TrainingFailed),
                "READY" => Some(Self::Ready),
                "DELETING" => Some(Self::Deleting),
                "TRAINING_CANCELLED" => Some(Self::TrainingCancelled),
                _ => None,
            }
        }
    }
}
/// An answer to a QaQuestion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QaAnswer {
    /// The QaQuestion answered by this answer.
    #[prost(string, tag = "7")]
    pub qa_question: ::prost::alloc::string::String,
    /// The conversation the answer applies to.
    #[prost(string, tag = "2")]
    pub conversation: ::prost::alloc::string::String,
    /// Question text. E.g., "Did the agent greet the customer?"
    #[prost(string, tag = "6")]
    pub question_body: ::prost::alloc::string::String,
    /// The main answer value, incorporating any manual edits if they exist.
    #[prost(message, optional, tag = "3")]
    pub answer_value: ::core::option::Option<qa_answer::AnswerValue>,
    /// User-defined list of arbitrary tags. Matches the value from
    /// QaScorecard.ScorecardQuestion.tags. Used for grouping/organization and
    /// for weighting the score of each answer.
    #[prost(string, repeated, tag = "5")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of all individual answers given to the question.
    #[prost(message, repeated, tag = "8")]
    pub answer_sources: ::prost::alloc::vec::Vec<qa_answer::AnswerSource>,
}
/// Nested message and enum types in `QaAnswer`.
pub mod qa_answer {
    /// Message for holding the value of a
    /// [QaAnswer][google.cloud.contactcenterinsights.v1.QaAnswer].
    /// [QaQuestion.AnswerChoice][google.cloud.contactcenterinsights.v1.QaQuestion.AnswerChoice]
    /// defines the possible answer values for a question.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AnswerValue {
        /// A short string used as an identifier. Matches the value used in
        /// QaQuestion.AnswerChoice.key.
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        /// Output only. Numerical score of the answer.
        #[prost(double, optional, tag = "6")]
        pub score: ::core::option::Option<f64>,
        /// Output only. The maximum potential score of the question.
        #[prost(double, optional, tag = "7")]
        pub potential_score: ::core::option::Option<f64>,
        /// Output only. Normalized score of the questions. Calculated as score /
        /// potential_score.
        #[prost(double, optional, tag = "8")]
        pub normalized_score: ::core::option::Option<f64>,
        /// The answer value may be one of a few different types.
        #[prost(oneof = "answer_value::Value", tags = "2, 3, 4, 5")]
        pub value: ::core::option::Option<answer_value::Value>,
    }
    /// Nested message and enum types in `AnswerValue`.
    pub mod answer_value {
        /// The answer value may be one of a few different types.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            /// String value.
            #[prost(string, tag = "2")]
            StrValue(::prost::alloc::string::String),
            /// Numerical value.
            #[prost(double, tag = "3")]
            NumValue(f64),
            /// Boolean value.
            #[prost(bool, tag = "4")]
            BoolValue(bool),
            /// A value of "Not Applicable (N/A)". Should only ever be `true`.
            #[prost(bool, tag = "5")]
            NaValue(bool),
        }
    }
    /// A question may have multiple answers from varying sources, one of which
    /// becomes the "main" answer above. AnswerSource represents each individual
    /// answer.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AnswerSource {
        /// What created the answer.
        #[prost(enumeration = "answer_source::SourceType", tag = "1")]
        pub source_type: i32,
        /// The answer value from this source.
        #[prost(message, optional, tag = "2")]
        pub answer_value: ::core::option::Option<AnswerValue>,
    }
    /// Nested message and enum types in `AnswerSource`.
    pub mod answer_source {
        /// What created the answer.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SourceType {
            /// Source type is unspecified.
            Unspecified = 0,
            /// Answer was system-generated; created during an Insights analysis.
            SystemGenerated = 1,
            /// Answer was created by a human via manual edit.
            ManualEdit = 2,
        }
        impl SourceType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SOURCE_TYPE_UNSPECIFIED",
                    Self::SystemGenerated => "SYSTEM_GENERATED",
                    Self::ManualEdit => "MANUAL_EDIT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SYSTEM_GENERATED" => Some(Self::SystemGenerated),
                    "MANUAL_EDIT" => Some(Self::ManualEdit),
                    _ => None,
                }
            }
        }
    }
}
/// The results of scoring a single conversation against a QaScorecard. Contains
/// a collection of QaAnswers and aggregate score.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QaScorecardResult {
    /// Identifier. The name of the scorecard result.
    /// Format:
    /// projects/{project}/locations/{location}/qaScorecardResults/{qa_scorecard_result}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The QaScorecardRevision scored by this result.
    #[prost(string, tag = "2")]
    pub qa_scorecard_revision: ::prost::alloc::string::String,
    /// The conversation scored by this result.
    #[prost(string, tag = "3")]
    pub conversation: ::prost::alloc::string::String,
    /// Output only. The timestamp that the revision was created.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// ID of the agent that handled the conversation.
    #[prost(string, tag = "5")]
    pub agent_id: ::prost::alloc::string::String,
    /// Set of QaAnswers represented in the result.
    #[prost(message, repeated, tag = "6")]
    pub qa_answers: ::prost::alloc::vec::Vec<QaAnswer>,
    /// The overall numerical score of the result, incorporating any manual edits
    /// if they exist.
    #[prost(double, optional, tag = "7")]
    pub score: ::core::option::Option<f64>,
    /// The maximum potential overall score of the scorecard. Any questions
    /// answered using `na_value` are excluded from this calculation.
    #[prost(double, optional, tag = "8")]
    pub potential_score: ::core::option::Option<f64>,
    /// The normalized score, which is the score divided by the potential score.
    /// Any manual edits are included if they exist.
    #[prost(double, optional, tag = "9")]
    pub normalized_score: ::core::option::Option<f64>,
    /// Collection of tags and their scores.
    #[prost(message, repeated, tag = "10")]
    pub qa_tag_results: ::prost::alloc::vec::Vec<qa_scorecard_result::QaTagResult>,
    /// List of all individual score sets.
    #[prost(message, repeated, tag = "11")]
    pub score_sources: ::prost::alloc::vec::Vec<qa_scorecard_result::ScoreSource>,
}
/// Nested message and enum types in `QaScorecardResult`.
pub mod qa_scorecard_result {
    /// Tags and their corresponding results.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QaTagResult {
        /// The tag the score applies to.
        #[prost(string, tag = "1")]
        pub tag: ::prost::alloc::string::String,
        /// The score the tag applies to.
        #[prost(double, optional, tag = "2")]
        pub score: ::core::option::Option<f64>,
        /// The potential score the tag applies to.
        #[prost(double, optional, tag = "3")]
        pub potential_score: ::core::option::Option<f64>,
        /// The normalized score the tag applies to.
        #[prost(double, optional, tag = "4")]
        pub normalized_score: ::core::option::Option<f64>,
    }
    /// A scorecard result may have multiple sets of scores from varying sources,
    /// one of which becomes the "main" answer above. A ScoreSource represents
    /// each individual set of scores.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ScoreSource {
        /// What created the score.
        #[prost(enumeration = "score_source::SourceType", tag = "1")]
        pub source_type: i32,
        /// The overall numerical score of the result.
        #[prost(double, optional, tag = "2")]
        pub score: ::core::option::Option<f64>,
        /// The maximum potential overall score of the scorecard. Any questions
        /// answered using `na_value` are excluded from this calculation.
        #[prost(double, optional, tag = "3")]
        pub potential_score: ::core::option::Option<f64>,
        /// The normalized score, which is the score divided by the potential score.
        #[prost(double, optional, tag = "4")]
        pub normalized_score: ::core::option::Option<f64>,
        /// Collection of tags and their scores.
        #[prost(message, repeated, tag = "5")]
        pub qa_tag_results: ::prost::alloc::vec::Vec<QaTagResult>,
    }
    /// Nested message and enum types in `ScoreSource`.
    pub mod score_source {
        /// What created the score.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SourceType {
            /// Source type is unspecified.
            Unspecified = 0,
            /// Score is derived only from system-generated answers.
            SystemGeneratedOnly = 1,
            /// Score is derived from both system-generated answers, and includes
            /// any manual edits if they exist.
            IncludesManualEdits = 2,
        }
        impl SourceType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SOURCE_TYPE_UNSPECIFIED",
                    Self::SystemGeneratedOnly => "SYSTEM_GENERATED_ONLY",
                    Self::IncludesManualEdits => "INCLUDES_MANUAL_EDITS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SYSTEM_GENERATED_ONLY" => Some(Self::SystemGeneratedOnly),
                    "INCLUDES_MANUAL_EDITS" => Some(Self::IncludesManualEdits),
                    _ => None,
                }
            }
        }
    }
}
/// Enum for the different types of issues a tuning dataset can have.
/// These warnings are currentlyraised when trying to validate a dataset for
/// tuning a scorecard.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DatasetValidationWarning {
    /// Unspecified data validation warning.
    Unspecified = 0,
    /// A non-trivial percentage of the feedback labels are invalid.
    TooManyInvalidFeedbackLabels = 1,
    /// The quantity of valid feedback labels provided is less than the
    /// recommended minimum.
    InsufficientFeedbackLabels = 2,
    /// One or more of the answers have less than the recommended minimum of
    /// feedback labels.
    InsufficientFeedbackLabelsPerAnswer = 3,
    /// All the labels in the dataset come from a single answer choice.
    AllFeedbackLabelsHaveTheSameAnswer = 4,
}
impl DatasetValidationWarning {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DATASET_VALIDATION_WARNING_UNSPECIFIED",
            Self::TooManyInvalidFeedbackLabels => "TOO_MANY_INVALID_FEEDBACK_LABELS",
            Self::InsufficientFeedbackLabels => "INSUFFICIENT_FEEDBACK_LABELS",
            Self::InsufficientFeedbackLabelsPerAnswer => {
                "INSUFFICIENT_FEEDBACK_LABELS_PER_ANSWER"
            }
            Self::AllFeedbackLabelsHaveTheSameAnswer => {
                "ALL_FEEDBACK_LABELS_HAVE_THE_SAME_ANSWER"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATASET_VALIDATION_WARNING_UNSPECIFIED" => Some(Self::Unspecified),
            "TOO_MANY_INVALID_FEEDBACK_LABELS" => {
                Some(Self::TooManyInvalidFeedbackLabels)
            }
            "INSUFFICIENT_FEEDBACK_LABELS" => Some(Self::InsufficientFeedbackLabels),
            "INSUFFICIENT_FEEDBACK_LABELS_PER_ANSWER" => {
                Some(Self::InsufficientFeedbackLabelsPerAnswer)
            }
            "ALL_FEEDBACK_LABELS_HAVE_THE_SAME_ANSWER" => {
                Some(Self::AllFeedbackLabelsHaveTheSameAnswer)
            }
            _ => None,
        }
    }
}
/// The request for calculating conversation statistics.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateStatsRequest {
    /// Required. The location of the conversations.
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
    /// A filter to reduce results to a specific subset. This field is useful for
    /// getting statistics about conversations with specific properties.
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
}
/// The response for calculating conversation statistics.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateStatsResponse {
    /// The average duration of all conversations. The average is calculated using
    /// only conversations that have a time duration.
    #[prost(message, optional, tag = "1")]
    pub average_duration: ::core::option::Option<::prost_types::Duration>,
    /// The average number of turns per conversation.
    #[prost(int32, tag = "2")]
    pub average_turn_count: i32,
    /// The total number of conversations.
    #[prost(int32, tag = "3")]
    pub conversation_count: i32,
    /// A map associating each smart highlighter display name with its respective
    /// number of matches in the set of conversations.
    #[prost(map = "string, int32", tag = "4")]
    pub smart_highlighter_matches: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        i32,
    >,
    /// A map associating each custom highlighter resource name with its respective
    /// number of matches in the set of conversations.
    #[prost(map = "string, int32", tag = "5")]
    pub custom_highlighter_matches: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        i32,
    >,
    /// A map associating each issue resource name with its respective number of
    /// matches in the set of conversations. Key has the format:
    /// `projects/<Project-ID>/locations/<Location-ID>/issueModels/<Issue-Model-ID>/issues/<Issue-ID>`
    /// Deprecated, use `issue_matches_stats` field instead.
    #[prost(map = "string, int32", tag = "6")]
    pub issue_matches: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
    /// A map associating each issue resource name with its respective number of
    /// matches in the set of conversations. Key has the format:
    /// `projects/<Project-ID>/locations/<Location-ID>/issueModels/<Issue-Model-ID>/issues/<Issue-ID>`
    #[prost(map = "string, message", tag = "8")]
    pub issue_matches_stats: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        issue_model_label_stats::IssueStats,
    >,
    /// A time series representing the count of conversations created over time
    /// that match that requested filter criteria.
    #[prost(message, optional, tag = "7")]
    pub conversation_count_time_series: ::core::option::Option<
        calculate_stats_response::TimeSeries,
    >,
}
/// Nested message and enum types in `CalculateStatsResponse`.
pub mod calculate_stats_response {
    /// A time series representing conversations over time.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TimeSeries {
        /// The duration of each interval.
        #[prost(message, optional, tag = "1")]
        pub interval_duration: ::core::option::Option<::prost_types::Duration>,
        /// An ordered list of intervals from earliest to latest, where each interval
        /// represents the number of conversations that transpired during the time
        /// window.
        #[prost(message, repeated, tag = "2")]
        pub points: ::prost::alloc::vec::Vec<time_series::Interval>,
    }
    /// Nested message and enum types in `TimeSeries`.
    pub mod time_series {
        /// A single interval in a time series.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Interval {
            /// The start time of this interval.
            #[prost(message, optional, tag = "1")]
            pub start_time: ::core::option::Option<::prost_types::Timestamp>,
            /// The number of conversations created in this interval.
            #[prost(int32, tag = "2")]
            pub conversation_count: i32,
        }
    }
}
/// Metadata for a create analysis operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAnalysisOperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The Conversation that this Analysis Operation belongs to.
    #[prost(string, tag = "3")]
    pub conversation: ::prost::alloc::string::String,
    /// Output only. The annotator selector used for the analysis (if any).
    #[prost(message, optional, tag = "4")]
    pub annotator_selector: ::core::option::Option<AnnotatorSelector>,
}
/// Request to create a conversation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConversationRequest {
    /// Required. The parent resource of the conversation.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The conversation resource to create.
    #[prost(message, optional, tag = "2")]
    pub conversation: ::core::option::Option<Conversation>,
    /// A unique ID for the new conversation. This ID will become the final
    /// component of the conversation's resource name. If no ID is specified, a
    /// server-generated ID will be used.
    ///
    /// This value should be 4-64 characters and must match the regular
    /// expression `^\[a-z0-9-\]{4,64}$`. Valid characters are `[a-z][0-9]-`
    #[prost(string, tag = "3")]
    pub conversation_id: ::prost::alloc::string::String,
}
/// Request to upload a conversation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadConversationRequest {
    /// Required. The parent resource of the conversation.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The conversation resource to create.
    #[prost(message, optional, tag = "2")]
    pub conversation: ::core::option::Option<Conversation>,
    /// Optional. A unique ID for the new conversation. This ID will become the
    /// final component of the conversation's resource name. If no ID is specified,
    /// a server-generated ID will be used.
    ///
    /// This value should be 4-64 characters and must match the regular
    /// expression `^\[a-z0-9-\]{4,64}$`. Valid characters are `[a-z][0-9]-`
    #[prost(string, tag = "3")]
    pub conversation_id: ::prost::alloc::string::String,
    /// Optional. DLP settings for transcript redaction. Will default to the config
    /// specified in Settings.
    #[prost(message, optional, tag = "4")]
    pub redaction_config: ::core::option::Option<RedactionConfig>,
    /// Optional. Speech-to-Text configuration. Will default to the config
    /// specified in Settings.
    #[prost(message, optional, tag = "11")]
    pub speech_config: ::core::option::Option<SpeechConfig>,
}
/// The metadata for an `UploadConversation` operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadConversationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The original request.
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<UploadConversationRequest>,
    /// Output only. The operation name for a successfully created analysis
    /// operation, if any.
    #[prost(string, tag = "4")]
    pub analysis_operation: ::prost::alloc::string::String,
    /// Output only. The redaction config applied to the uploaded conversation.
    #[prost(message, optional, tag = "5")]
    pub applied_redaction_config: ::core::option::Option<RedactionConfig>,
}
/// Request to list conversations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversationsRequest {
    /// Required. The parent resource of the conversation.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of conversations to return in the response. A valid page
    /// size ranges from 0 to 100,000 inclusive. If the page size is zero or
    /// unspecified, a default page size of 100 will be chosen. Note that a call
    /// might return fewer results than the requested page size.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last `ListConversationsResponse`. This value
    /// indicates that this is a continuation of a prior `ListConversations` call
    /// and that the system should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// A filter to reduce results to a specific subset. Useful for querying
    /// conversations with specific properties.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The attribute by which to order conversations in the response.
    /// If empty, conversations will be ordered by descending creation time.
    /// Supported values are one of the following:
    ///
    /// * create_time
    /// * customer_satisfaction_rating
    /// * duration
    /// * latest_analysis
    /// * start_time
    /// * turn_count
    ///
    /// The default sort order is ascending. To specify order, append `asc` or
    /// `desc` (`create_time desc`).
    /// For more details, see [Google AIPs
    /// Ordering](<https://google.aip.dev/132#ordering>).
    #[prost(string, tag = "7")]
    pub order_by: ::prost::alloc::string::String,
    /// The level of details of the conversation. Default is `BASIC`.
    #[prost(enumeration = "ConversationView", tag = "5")]
    pub view: i32,
}
/// The response of listing conversations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversationsResponse {
    /// The conversations that match the request.
    #[prost(message, repeated, tag = "1")]
    pub conversations: ::prost::alloc::vec::Vec<Conversation>,
    /// A token which can be sent as `page_token` to retrieve the next page. If
    /// this field is set, it means there is another page available. If it is not
    /// set, it means no other pages are available.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request to get a conversation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConversationRequest {
    /// Required. The name of the conversation to get.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The level of details of the conversation. Default is `FULL`.
    #[prost(enumeration = "ConversationView", tag = "2")]
    pub view: i32,
}
/// The request to update a conversation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConversationRequest {
    /// Required. The new values for the conversation.
    #[prost(message, optional, tag = "1")]
    pub conversation: ::core::option::Option<Conversation>,
    /// The list of fields to be updated. All possible fields can be updated by
    /// passing `*`, or a subset of the following updateable fields can be
    /// provided:
    ///
    /// * `agent_id`
    /// * `language_code`
    /// * `labels`
    /// * `metadata`
    /// * `quality_metadata`
    /// * `call_metadata`
    /// * `start_time`
    /// * `expire_time` or `ttl`
    /// * `data_source.gcs_source.audio_uri` or
    /// `data_source.dialogflow_source.audio_uri`
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request to delete a conversation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteConversationRequest {
    /// Required. The name of the conversation to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// If set to true, all of this conversation's analyses will also be deleted.
    /// Otherwise, the request will only succeed if the conversation has no
    /// analyses.
    #[prost(bool, tag = "2")]
    pub force: bool,
}
/// The request to ingest conversations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngestConversationsRequest {
    /// Required. The parent resource for new conversations.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Configuration that applies to all conversations.
    #[prost(message, optional, tag = "4")]
    pub conversation_config: ::core::option::Option<
        ingest_conversations_request::ConversationConfig,
    >,
    /// Optional. DLP settings for transcript redaction. Optional, will default to
    /// the config specified in Settings.
    #[prost(message, optional, tag = "5")]
    pub redaction_config: ::core::option::Option<RedactionConfig>,
    /// Optional. Default Speech-to-Text configuration. Optional, will default to
    /// the config specified in Settings.
    #[prost(message, optional, tag = "6")]
    pub speech_config: ::core::option::Option<SpeechConfig>,
    /// Optional. If set, this fields indicates the number of objects to ingest
    /// from the Cloud Storage bucket. If empty, the entire bucket will be
    /// ingested. Unless they are first deleted, conversations produced through
    /// sampling won't be ingested by subsequent ingest requests.
    #[prost(int32, optional, tag = "7")]
    pub sample_size: ::core::option::Option<i32>,
    /// Configuration for an external data store containing objects that will
    /// be converted to conversations.
    #[prost(oneof = "ingest_conversations_request::Source", tags = "2")]
    pub source: ::core::option::Option<ingest_conversations_request::Source>,
    /// Configuration for converting individual `source` objects to conversations.
    #[prost(oneof = "ingest_conversations_request::ObjectConfig", tags = "3")]
    pub object_config: ::core::option::Option<
        ingest_conversations_request::ObjectConfig,
    >,
}
/// Nested message and enum types in `IngestConversationsRequest`.
pub mod ingest_conversations_request {
    /// Configuration for Cloud Storage bucket sources.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GcsSource {
        /// Required. The Cloud Storage bucket containing source objects.
        #[prost(string, tag = "1")]
        pub bucket_uri: ::prost::alloc::string::String,
        /// Optional. Specifies the type of the objects in `bucket_uri`.
        #[prost(enumeration = "gcs_source::BucketObjectType", tag = "2")]
        pub bucket_object_type: i32,
        /// Optional. The Cloud Storage path to the conversation metadata. Note that:
        /// \[1\] Metadata files are expected to be in JSON format.
        /// \[2\] Metadata and source files (transcripts or audio) must be in
        ///      separate buckets.
        /// \[3\] A source file and its corresponding metadata file must share the same
        /// name to
        ///      be properly ingested, E.g. `gs://bucket/audio/conversation1.mp3` and
        ///      `gs://bucket/metadata/conversation1.json`.
        #[prost(string, optional, tag = "3")]
        pub metadata_bucket_uri: ::core::option::Option<::prost::alloc::string::String>,
        /// Optional. Custom keys to extract as conversation labels from metadata
        /// files in `metadata_bucket_uri`. Keys not included in this field will be
        /// ignored. Note that there is a limit of 100 labels per conversation.
        #[prost(string, repeated, tag = "12")]
        pub custom_metadata_keys: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
    /// Nested message and enum types in `GcsSource`.
    pub mod gcs_source {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum BucketObjectType {
            /// The object type is unspecified and will default to `TRANSCRIPT`.
            Unspecified = 0,
            /// The object is a transcript.
            Transcript = 1,
            /// The object is an audio file.
            Audio = 2,
        }
        impl BucketObjectType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "BUCKET_OBJECT_TYPE_UNSPECIFIED",
                    Self::Transcript => "TRANSCRIPT",
                    Self::Audio => "AUDIO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "BUCKET_OBJECT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "TRANSCRIPT" => Some(Self::Transcript),
                    "AUDIO" => Some(Self::Audio),
                    _ => None,
                }
            }
        }
    }
    /// Configuration for processing transcript objects.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TranscriptObjectConfig {
        /// Required. The medium transcript objects represent.
        #[prost(enumeration = "super::conversation::Medium", tag = "1")]
        pub medium: i32,
    }
    /// Configuration that applies to all conversations.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConversationConfig {
        /// Optional. An opaque, user-specified string representing a human agent who
        /// handled all conversations in the import. Note that this will be
        /// overridden if per-conversation metadata is provided through the
        /// `metadata_bucket_uri`.
        #[prost(string, tag = "1")]
        pub agent_id: ::prost::alloc::string::String,
        /// Optional. Indicates which of the channels, 1 or 2, contains the agent.
        /// Note that this must be set for conversations to be properly displayed and
        /// analyzed.
        #[prost(int32, tag = "2")]
        pub agent_channel: i32,
        /// Optional. Indicates which of the channels, 1 or 2, contains the agent.
        /// Note that this must be set for conversations to be properly displayed and
        /// analyzed.
        #[prost(int32, tag = "3")]
        pub customer_channel: i32,
    }
    /// Configuration for an external data store containing objects that will
    /// be converted to conversations.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// A cloud storage bucket source. Note that any previously ingested objects
        /// from the source will be skipped to avoid duplication.
        #[prost(message, tag = "2")]
        GcsSource(GcsSource),
    }
    /// Configuration for converting individual `source` objects to conversations.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ObjectConfig {
        /// Configuration for when `source` contains conversation transcripts.
        #[prost(message, tag = "3")]
        TranscriptObjectConfig(TranscriptObjectConfig),
    }
}
/// The metadata for an IngestConversations operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngestConversationsMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The original request for ingest.
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<IngestConversationsRequest>,
    /// Output only. Partial errors during ingest operation that might cause the
    /// operation output to be incomplete.
    #[prost(message, repeated, tag = "4")]
    pub partial_errors: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    /// Output only. Statistics for IngestConversations operation.
    #[prost(message, optional, tag = "5")]
    pub ingest_conversations_stats: ::core::option::Option<
        ingest_conversations_metadata::IngestConversationsStats,
    >,
}
/// Nested message and enum types in `IngestConversationsMetadata`.
pub mod ingest_conversations_metadata {
    /// Statistics for IngestConversations operation.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct IngestConversationsStats {
        /// Output only. The number of objects processed during the ingest operation.
        #[prost(int32, tag = "1")]
        pub processed_object_count: i32,
        /// Output only. The number of objects skipped because another conversation
        /// with the same transcript uri had already been ingested.
        #[prost(int32, tag = "2")]
        pub duplicates_skipped_count: i32,
        /// Output only. The number of new conversations added during this ingest
        /// operation.
        #[prost(int32, tag = "3")]
        pub successful_ingest_count: i32,
        /// Output only. The number of objects which were unable to be ingested due
        /// to errors. The errors are populated in the partial_errors field.
        #[prost(int32, tag = "4")]
        pub failed_ingest_count: i32,
    }
}
/// The response to an IngestConversations operation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IngestConversationsResponse {}
/// The request to create an analysis.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAnalysisRequest {
    /// Required. The parent resource of the analysis.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The analysis to create.
    #[prost(message, optional, tag = "2")]
    pub analysis: ::core::option::Option<Analysis>,
}
/// The request to list analyses.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnalysesRequest {
    /// Required. The parent resource of the analyses.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of analyses to return in the response. If this
    /// value is zero, the service will select a default size. A call might return
    /// fewer objects than requested. A non-empty `next_page_token` in the response
    /// indicates that more data is available.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last `ListAnalysesResponse`; indicates
    /// that this is a continuation of a prior `ListAnalyses` call and
    /// the system should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// A filter to reduce results to a specific subset. Useful for querying
    /// conversations with specific properties.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response to list analyses.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnalysesResponse {
    /// The analyses that match the request.
    #[prost(message, repeated, tag = "1")]
    pub analyses: ::prost::alloc::vec::Vec<Analysis>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request to get an analysis.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnalysisRequest {
    /// Required. The name of the analysis to get.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request to delete an analysis.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAnalysisRequest {
    /// Required. The name of the analysis to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request to analyze conversations in bulk.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkAnalyzeConversationsRequest {
    /// Required. The parent resource to create analyses in.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Filter used to select the subset of conversations to analyze.
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Required. Percentage of selected conversation to analyze, between
    /// \[0, 100\].
    #[prost(float, tag = "3")]
    pub analysis_percentage: f32,
    /// To select the annotators to run and the phrase matchers to use
    /// (if any). If not specified, all annotators will be run.
    #[prost(message, optional, tag = "8")]
    pub annotator_selector: ::core::option::Option<AnnotatorSelector>,
}
/// The metadata for a bulk analyze conversations operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkAnalyzeConversationsMetadata {
    /// The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The original request for bulk analyze.
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<BulkAnalyzeConversationsRequest>,
    /// The number of requested analyses that have completed successfully so far.
    #[prost(int32, tag = "4")]
    pub completed_analyses_count: i32,
    /// The number of requested analyses that have failed so far.
    #[prost(int32, tag = "5")]
    pub failed_analyses_count: i32,
    /// Total number of analyses requested. Computed by the number of conversations
    /// returned by `filter` multiplied by `analysis_percentage` in the request.
    #[prost(int32, tag = "6")]
    pub total_requested_analyses_count: i32,
    /// Output only. Partial errors during bulk analyze operation that might cause
    /// the operation output to be incomplete.
    #[prost(message, repeated, tag = "7")]
    pub partial_errors: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
/// The response for a bulk analyze conversations operation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BulkAnalyzeConversationsResponse {
    /// Count of successful analyses.
    #[prost(int32, tag = "1")]
    pub successful_analysis_count: i32,
    /// Count of failed analyses.
    #[prost(int32, tag = "2")]
    pub failed_analysis_count: i32,
}
/// The request to delete conversations in bulk.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkDeleteConversationsRequest {
    /// Required. The parent resource to delete conversations from.
    /// Format:
    /// projects/{project}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Filter used to select the subset of conversations to delete.
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Maximum number of conversations to delete.
    #[prost(int32, tag = "3")]
    pub max_delete_count: i32,
    /// If set to true, all of this conversation's analyses will also be deleted.
    /// Otherwise, the request will only succeed if the conversation has no
    /// analyses.
    #[prost(bool, tag = "4")]
    pub force: bool,
}
/// The metadata for a bulk delete conversations operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkDeleteConversationsMetadata {
    /// The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The original request for bulk delete.
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<BulkDeleteConversationsRequest>,
    /// Partial errors during bulk delete conversations operation that might cause
    /// the operation output to be incomplete.
    #[prost(message, repeated, tag = "4")]
    pub partial_errors: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
/// The response for a bulk delete conversations operation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BulkDeleteConversationsResponse {}
/// The request to export insights.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportInsightsDataRequest {
    /// Required. The parent resource to export data from.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// A filter to reduce results to a specific subset. Useful for exporting
    /// conversations with specific properties.
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
    /// A fully qualified KMS key name for BigQuery tables protected by CMEK.
    /// Format:
    /// projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{key}/cryptoKeyVersions/{version}
    #[prost(string, tag = "4")]
    pub kms_key: ::prost::alloc::string::String,
    /// Options for what to do if the destination table already exists.
    #[prost(enumeration = "export_insights_data_request::WriteDisposition", tag = "5")]
    pub write_disposition: i32,
    /// Exporter destination.
    #[prost(oneof = "export_insights_data_request::Destination", tags = "2")]
    pub destination: ::core::option::Option<export_insights_data_request::Destination>,
}
/// Nested message and enum types in `ExportInsightsDataRequest`.
pub mod export_insights_data_request {
    /// A BigQuery Table Reference.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BigQueryDestination {
        /// A project ID or number. If specified, then export will attempt to
        /// write data to this project instead of the resource project. Otherwise,
        /// the resource project will be used.
        #[prost(string, tag = "3")]
        pub project_id: ::prost::alloc::string::String,
        /// Required. The name of the BigQuery dataset that the snapshot result
        /// should be exported to. If this dataset does not exist, the export call
        /// returns an INVALID_ARGUMENT error.
        #[prost(string, tag = "1")]
        pub dataset: ::prost::alloc::string::String,
        /// The BigQuery table name to which the insights data should be written.
        /// If this table does not exist, the export call returns an INVALID_ARGUMENT
        /// error.
        #[prost(string, tag = "2")]
        pub table: ::prost::alloc::string::String,
    }
    /// Specifies the action that occurs if the destination table already exists.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WriteDisposition {
        /// Write disposition is not specified. Defaults to WRITE_TRUNCATE.
        Unspecified = 0,
        /// If the table already exists, BigQuery will overwrite the table data and
        /// use the schema from the load.
        WriteTruncate = 1,
        /// If the table already exists, BigQuery will append data to the table.
        WriteAppend = 2,
    }
    impl WriteDisposition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "WRITE_DISPOSITION_UNSPECIFIED",
                Self::WriteTruncate => "WRITE_TRUNCATE",
                Self::WriteAppend => "WRITE_APPEND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WRITE_DISPOSITION_UNSPECIFIED" => Some(Self::Unspecified),
                "WRITE_TRUNCATE" => Some(Self::WriteTruncate),
                "WRITE_APPEND" => Some(Self::WriteAppend),
                _ => None,
            }
        }
    }
    /// Exporter destination.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Destination {
        /// Specified if sink is a BigQuery table.
        #[prost(message, tag = "2")]
        BigQueryDestination(BigQueryDestination),
    }
}
/// Metadata for an export insights operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportInsightsDataMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The original request for export.
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<ExportInsightsDataRequest>,
    /// Partial errors during export operation that might cause the operation
    /// output to be incomplete.
    #[prost(message, repeated, tag = "4")]
    pub partial_errors: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
/// Response for an export insights operation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportInsightsDataResponse {}
/// The request to create an issue model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIssueModelRequest {
    /// Required. The parent resource of the issue model.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The issue model to create.
    #[prost(message, optional, tag = "2")]
    pub issue_model: ::core::option::Option<IssueModel>,
}
/// Metadata for creating an issue model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIssueModelMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The original request for creation.
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<CreateIssueModelRequest>,
}
/// The request to update an issue model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIssueModelRequest {
    /// Required. The new values for the issue model.
    #[prost(message, optional, tag = "1")]
    pub issue_model: ::core::option::Option<IssueModel>,
    /// The list of fields to be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request to list issue models.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIssueModelsRequest {
    /// Required. The parent resource of the issue model.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// The response of listing issue models.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIssueModelsResponse {
    /// The issue models that match the request.
    #[prost(message, repeated, tag = "1")]
    pub issue_models: ::prost::alloc::vec::Vec<IssueModel>,
}
/// The request to get an issue model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIssueModelRequest {
    /// Required. The name of the issue model to get.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request to delete an issue model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIssueModelRequest {
    /// Required. The name of the issue model to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Metadata for deleting an issue model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIssueModelMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The original request for deletion.
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<DeleteIssueModelRequest>,
}
/// The request to deploy an issue model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployIssueModelRequest {
    /// Required. The issue model to deploy.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The response to deploy an issue model.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeployIssueModelResponse {}
/// Metadata for deploying an issue model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployIssueModelMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The original request for deployment.
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<DeployIssueModelRequest>,
}
/// The request to undeploy an issue model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployIssueModelRequest {
    /// Required. The issue model to undeploy.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The response to undeploy an issue model.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UndeployIssueModelResponse {}
/// Metadata for undeploying an issue model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployIssueModelMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The original request for undeployment.
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<UndeployIssueModelRequest>,
}
/// Request to export an issue model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportIssueModelRequest {
    /// Required. The issue model to export.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(oneof = "export_issue_model_request::Destination", tags = "2")]
    pub destination: ::core::option::Option<export_issue_model_request::Destination>,
}
/// Nested message and enum types in `ExportIssueModelRequest`.
pub mod export_issue_model_request {
    /// Google Cloud Storage Object URI to save the issue model to.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GcsDestination {
        /// Required. Format: `gs://<bucket-name>/<object-name>`
        #[prost(string, tag = "1")]
        pub object_uri: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Destination {
        /// Google Cloud Storage URI to export the issue model to.
        #[prost(message, tag = "2")]
        GcsDestination(GcsDestination),
    }
}
/// Response from export issue model
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportIssueModelResponse {}
/// Metadata used for export issue model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportIssueModelMetadata {
    /// The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The original export request.
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<ExportIssueModelRequest>,
}
/// Request to import an issue model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportIssueModelRequest {
    /// Required. The parent resource of the issue model.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. If set to true, will create an issue model from the imported file
    /// with randomly generated IDs for the issue model and corresponding issues.
    /// Otherwise, replaces an existing model with the same ID as the file.
    #[prost(bool, tag = "3")]
    pub create_new_model: bool,
    #[prost(oneof = "import_issue_model_request::Source", tags = "2")]
    pub source: ::core::option::Option<import_issue_model_request::Source>,
}
/// Nested message and enum types in `ImportIssueModelRequest`.
pub mod import_issue_model_request {
    /// Google Cloud Storage Object URI to get the issue model file from.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GcsSource {
        /// Required. Format: `gs://<bucket-name>/<object-name>`
        #[prost(string, tag = "1")]
        pub object_uri: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// Google Cloud Storage source message.
        #[prost(message, tag = "2")]
        GcsSource(GcsSource),
    }
}
/// Response from import issue model
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportIssueModelResponse {}
/// Metadata used for import issue model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportIssueModelMetadata {
    /// The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The original import request.
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<ImportIssueModelRequest>,
}
/// The request to get an issue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIssueRequest {
    /// Required. The name of the issue to get.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request to list issues.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIssuesRequest {
    /// Required. The parent resource of the issue.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// The response of listing issues.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIssuesResponse {
    /// The issues that match the request.
    #[prost(message, repeated, tag = "1")]
    pub issues: ::prost::alloc::vec::Vec<Issue>,
}
/// The request to update an issue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIssueRequest {
    /// Required. The new values for the issue.
    #[prost(message, optional, tag = "1")]
    pub issue: ::core::option::Option<Issue>,
    /// The list of fields to be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request to delete an issue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIssueRequest {
    /// Required. The name of the issue to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request to get statistics of an issue model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateIssueModelStatsRequest {
    /// Required. The resource name of the issue model to query against.
    #[prost(string, tag = "1")]
    pub issue_model: ::prost::alloc::string::String,
}
/// Response of querying an issue model's statistics.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateIssueModelStatsResponse {
    /// The latest label statistics for the queried issue model. Includes results
    /// on both training data and data labeled after deployment.
    #[prost(message, optional, tag = "4")]
    pub current_stats: ::core::option::Option<IssueModelLabelStats>,
}
/// Request to create a phrase matcher.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePhraseMatcherRequest {
    /// Required. The parent resource of the phrase matcher. Required. The location
    /// to create a phrase matcher for. Format: `projects/<Project
    /// ID>/locations/<Location ID>` or `projects/<Project
    /// Number>/locations/<Location ID>`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The phrase matcher resource to create.
    #[prost(message, optional, tag = "2")]
    pub phrase_matcher: ::core::option::Option<PhraseMatcher>,
}
/// Request to list phrase matchers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPhraseMatchersRequest {
    /// Required. The parent resource of the phrase matcher.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of phrase matchers to return in the response. If this
    /// value is zero, the service will select a default size. A call might return
    /// fewer objects than requested. A non-empty `next_page_token` in the response
    /// indicates that more data is available.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last `ListPhraseMatchersResponse`. This value
    /// indicates that this is a continuation of a prior `ListPhraseMatchers` call
    /// and that the system should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// A filter to reduce results to a specific subset. Useful for querying
    /// phrase matchers with specific properties.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response of listing phrase matchers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPhraseMatchersResponse {
    /// The phrase matchers that match the request.
    #[prost(message, repeated, tag = "1")]
    pub phrase_matchers: ::prost::alloc::vec::Vec<PhraseMatcher>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request to get a a phrase matcher.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPhraseMatcherRequest {
    /// Required. The name of the phrase matcher to get.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request to delete a phrase matcher.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePhraseMatcherRequest {
    /// Required. The name of the phrase matcher to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request to update a phrase matcher.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePhraseMatcherRequest {
    /// Required. The new values for the phrase matcher.
    #[prost(message, optional, tag = "1")]
    pub phrase_matcher: ::core::option::Option<PhraseMatcher>,
    /// The list of fields to be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request to get project-level settings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSettingsRequest {
    /// Required. The name of the settings resource to get.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request to update project-level settings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSettingsRequest {
    /// Required. The new settings values.
    #[prost(message, optional, tag = "1")]
    pub settings: ::core::option::Option<Settings>,
    /// Required. The list of fields to be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request to create a analysis rule.
/// analysis_rule_id will be generated by the server.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAnalysisRuleRequest {
    /// Required. The parent resource of the analysis rule. Required. The location
    /// to create a analysis rule for. Format: `projects/<Project
    /// ID>/locations/<Location ID>` or `projects/<Project
    /// Number>/locations/<Location ID>`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The analysis rule resource to create.
    #[prost(message, optional, tag = "2")]
    pub analysis_rule: ::core::option::Option<AnalysisRule>,
}
/// The request for getting a analysis rule.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnalysisRuleRequest {
    /// Required. The name of the AnalysisRule to get.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request to update a analysis rule.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAnalysisRuleRequest {
    /// Required. The new analysis rule.
    #[prost(message, optional, tag = "1")]
    pub analysis_rule: ::core::option::Option<AnalysisRule>,
    /// Optional. The list of fields to be updated.
    /// If the update_mask is not provided, the update will be applied to all
    /// fields.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request to delete a analysis rule.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAnalysisRuleRequest {
    /// Required. The name of the analysis rule to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request to list analysis rules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnalysisRulesRequest {
    /// Required. The parent resource of the analysis rules.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of analysis rule to return in the response. If
    /// this value is zero, the service will select a default size. A call may
    /// return fewer objects than requested. A non-empty `next_page_token` in the
    /// response indicates that more data is available.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The value returned by the last `ListAnalysisRulesResponse`;
    /// indicates that this is a continuation of a prior `ListAnalysisRules` call
    /// and the system should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response of listing views.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnalysisRulesResponse {
    /// The analysis_rule that match the request.
    #[prost(message, repeated, tag = "1")]
    pub analysis_rules: ::prost::alloc::vec::Vec<AnalysisRule>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request to get location-level encryption specification.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEncryptionSpecRequest {
    /// Required. The name of the encryption spec resource to get.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request to initialize a location-level encryption specification.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitializeEncryptionSpecRequest {
    /// Required. The encryption spec used for CMEK encryption. It is required that
    /// the kms key is in the same region as the endpoint. The same key will be
    /// used for all provisioned resources, if encryption is available. If the
    /// `kms_key_name` field is left empty, no encryption will be enforced.
    #[prost(message, optional, tag = "1")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
}
/// The response to initialize a location-level encryption specification.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InitializeEncryptionSpecResponse {}
/// Metadata for initializing a location-level encryption specification.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitializeEncryptionSpecMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The original request for initialization.
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<InitializeEncryptionSpecRequest>,
    /// Partial errors during initializing operation that might cause the operation
    /// output to be incomplete.
    #[prost(message, repeated, tag = "4")]
    pub partial_errors: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
/// The request to create a view.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateViewRequest {
    /// Required. The parent resource of the view. Required. The location to create
    /// a view for.
    /// Format: `projects/<Project ID>/locations/<Location ID>` or
    /// `projects/<Project Number>/locations/<Location ID>`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The view resource to create.
    #[prost(message, optional, tag = "2")]
    pub view: ::core::option::Option<View>,
}
/// The request to get a view.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetViewRequest {
    /// Required. The name of the view to get.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request to list views.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListViewsRequest {
    /// Required. The parent resource of the views.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of views to return in the response. If this
    /// value is zero, the service will select a default size. A call may return
    /// fewer objects than requested. A non-empty `next_page_token` in the response
    /// indicates that more data is available.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last `ListViewsResponse`; indicates
    /// that this is a continuation of a prior `ListViews` call and
    /// the system should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response of listing views.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListViewsResponse {
    /// The views that match the request.
    #[prost(message, repeated, tag = "1")]
    pub views: ::prost::alloc::vec::Vec<View>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request to update a view.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateViewRequest {
    /// Required. The new view.
    #[prost(message, optional, tag = "1")]
    pub view: ::core::option::Option<View>,
    /// The list of fields to be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request to delete a view.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteViewRequest {
    /// Required. The name of the view to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A dimension determines the grouping key for the query. In SQL terms, these
/// would be part of both the "SELECT" and "GROUP BY" clauses.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dimension {
    /// The key of the dimension.
    #[prost(enumeration = "dimension::DimensionKey", tag = "1")]
    pub dimension_key: i32,
    /// Output-only metadata about the dimension.
    #[prost(oneof = "dimension::DimensionMetadata", tags = "2, 3, 4, 5")]
    pub dimension_metadata: ::core::option::Option<dimension::DimensionMetadata>,
}
/// Nested message and enum types in `Dimension`.
pub mod dimension {
    /// Metadata about the issue dimension.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IssueDimensionMetadata {
        /// The issue ID.
        #[prost(string, tag = "1")]
        pub issue_id: ::prost::alloc::string::String,
        /// The issue display name.
        #[prost(string, tag = "2")]
        pub issue_display_name: ::prost::alloc::string::String,
        /// The parent issue model ID.
        #[prost(string, tag = "3")]
        pub issue_model_id: ::prost::alloc::string::String,
    }
    /// Metadata about the agent dimension.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AgentDimensionMetadata {
        /// Optional. A user-specified string representing the agent.
        #[prost(string, tag = "1")]
        pub agent_id: ::prost::alloc::string::String,
        /// Optional. The agent's name
        #[prost(string, tag = "2")]
        pub agent_display_name: ::prost::alloc::string::String,
        /// Optional. A user-specified string representing the agent's team.
        #[prost(string, tag = "3")]
        pub agent_team: ::prost::alloc::string::String,
    }
    /// Metadata about the QA question dimension.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QaQuestionDimensionMetadata {
        /// Optional. The QA scorecard ID.
        #[prost(string, tag = "1")]
        pub qa_scorecard_id: ::prost::alloc::string::String,
        /// Optional. The QA question ID.
        #[prost(string, tag = "2")]
        pub qa_question_id: ::prost::alloc::string::String,
        /// Optional. The full body of the question.
        #[prost(string, tag = "3")]
        pub question_body: ::prost::alloc::string::String,
    }
    /// Metadata about the QA question-answer dimension.
    /// This is useful for showing the answer distribution for questions for a
    /// given scorecard.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QaQuestionAnswerDimensionMetadata {
        /// Optional. The QA scorecard ID.
        #[prost(string, tag = "1")]
        pub qa_scorecard_id: ::prost::alloc::string::String,
        /// Optional. The QA question ID.
        #[prost(string, tag = "2")]
        pub qa_question_id: ::prost::alloc::string::String,
        /// Optional. The full body of the question.
        #[prost(string, tag = "3")]
        pub question_body: ::prost::alloc::string::String,
        /// Optional. The full body of the question.
        #[prost(string, tag = "4")]
        pub answer_value: ::prost::alloc::string::String,
    }
    /// The key of the dimension.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DimensionKey {
        /// The key of the dimension is unspecified.
        Unspecified = 0,
        /// The dimension is keyed by issues.
        Issue = 1,
        /// The dimension is keyed by agents.
        Agent = 2,
        /// The dimension is keyed by agent teams.
        AgentTeam = 3,
        /// The dimension is keyed by QaQuestionIds.
        /// Note that: We only group by the QuestionId and not the revision-id of the
        /// scorecard this question is a part of. This allows for showing stats for
        /// the same question across different scorecard revisions.
        QaQuestionId = 4,
        /// The dimension is keyed by QaQuestionIds-Answer value pairs.
        /// Note that: We only group by the QuestionId and not the revision-id of the
        /// scorecard this question is a part of. This allows for showing
        /// distribution of answers per question across different scorecard
        /// revisions.
        QaQuestionAnswerValue = 5,
        /// The dimension is keyed by the conversation profile ID.
        ConversationProfileId = 6,
    }
    impl DimensionKey {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DIMENSION_KEY_UNSPECIFIED",
                Self::Issue => "ISSUE",
                Self::Agent => "AGENT",
                Self::AgentTeam => "AGENT_TEAM",
                Self::QaQuestionId => "QA_QUESTION_ID",
                Self::QaQuestionAnswerValue => "QA_QUESTION_ANSWER_VALUE",
                Self::ConversationProfileId => "CONVERSATION_PROFILE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DIMENSION_KEY_UNSPECIFIED" => Some(Self::Unspecified),
                "ISSUE" => Some(Self::Issue),
                "AGENT" => Some(Self::Agent),
                "AGENT_TEAM" => Some(Self::AgentTeam),
                "QA_QUESTION_ID" => Some(Self::QaQuestionId),
                "QA_QUESTION_ANSWER_VALUE" => Some(Self::QaQuestionAnswerValue),
                "CONVERSATION_PROFILE_ID" => Some(Self::ConversationProfileId),
                _ => None,
            }
        }
    }
    /// Output-only metadata about the dimension.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DimensionMetadata {
        /// Output only. Metadata about the issue dimension.
        #[prost(message, tag = "2")]
        IssueDimensionMetadata(IssueDimensionMetadata),
        /// Output only. Metadata about the agent dimension.
        #[prost(message, tag = "3")]
        AgentDimensionMetadata(AgentDimensionMetadata),
        /// Output only. Metadata about the QA question dimension.
        #[prost(message, tag = "4")]
        QaQuestionDimensionMetadata(QaQuestionDimensionMetadata),
        /// Output only. Metadata about the QA question-answer dimension.
        #[prost(message, tag = "5")]
        QaQuestionAnswerDimensionMetadata(QaQuestionAnswerDimensionMetadata),
    }
}
/// The request for querying metrics.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMetricsRequest {
    /// Required. The location of the data.
    /// "projects/{project}/locations/{location}"
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
    /// Required. Filter to select a subset of conversations to compute the
    /// metrics. Must specify a window of the conversation create time to compute
    /// the metrics. The returned metrics will be from the range [DATE(starting
    /// create time), DATE(ending create time)).
    ///
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// The time granularity of each data point in the time series.
    /// Defaults to NONE if this field is unspecified.
    #[prost(enumeration = "query_metrics_request::TimeGranularity", tag = "3")]
    pub time_granularity: i32,
    /// The dimensions that determine the grouping key for the query. Defaults to
    /// no dimension if this field is unspecified. If a dimension is specified,
    /// its key must also be specified. Each dimension's key must be unique.
    ///
    /// If a time granularity is also specified, metric values in the dimension
    /// will be bucketed by this granularity.
    ///
    /// Up to one dimension is supported for now.
    #[prost(message, repeated, tag = "4")]
    pub dimensions: ::prost::alloc::vec::Vec<Dimension>,
    /// Measures to return. Defaults to all measures if this field is unspecified.
    /// A valid mask should traverse from the `measure` field from the response.
    /// For example, a path from a measure mask to get the conversation count is
    /// "conversation_measure.count".
    #[prost(message, optional, tag = "5")]
    pub measure_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Nested message and enum types in `QueryMetricsRequest`.
pub mod query_metrics_request {
    /// A time granularity divides the time line into discrete time periods.
    /// This is useful for defining buckets over which filtering and aggregation
    /// should be performed.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimeGranularity {
        /// The time granularity is unspecified and will default to NONE.
        Unspecified = 0,
        /// No time granularity. The response won't contain a time series.
        /// This is the default value if no time granularity is specified.
        None = 1,
        /// Data points in the time series will aggregate at a daily granularity.
        /// 1 day means [midnight to midnight).
        Daily = 2,
        /// Data points in the time series will aggregate at a daily granularity.
        /// 1 HOUR means [01:00 to 02:00).
        Hourly = 3,
        /// Data points in the time series will aggregate at a daily granularity.
        /// PER_MINUTE means [01:00 to 01:01).
        PerMinute = 4,
        /// Data points in the time series will aggregate at a 1 minute  granularity.
        /// PER_5_MINUTES means [01:00 to 01:05).
        Per5Minutes = 5,
        /// Data points in the time series will aggregate at a monthly granularity.
        /// 1 MONTH means [01st of the month to 1st of the next month).
        Monthly = 6,
    }
    impl TimeGranularity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TIME_GRANULARITY_UNSPECIFIED",
                Self::None => "NONE",
                Self::Daily => "DAILY",
                Self::Hourly => "HOURLY",
                Self::PerMinute => "PER_MINUTE",
                Self::Per5Minutes => "PER_5_MINUTES",
                Self::Monthly => "MONTHLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIME_GRANULARITY_UNSPECIFIED" => Some(Self::Unspecified),
                "NONE" => Some(Self::None),
                "DAILY" => Some(Self::Daily),
                "HOURLY" => Some(Self::Hourly),
                "PER_MINUTE" => Some(Self::PerMinute),
                "PER_5_MINUTES" => Some(Self::Per5Minutes),
                "MONTHLY" => Some(Self::Monthly),
                _ => None,
            }
        }
    }
}
/// The response for querying metrics.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMetricsResponse {
    /// Required. The location of the data.
    /// "projects/{project}/locations/{location}"
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
    /// The metrics last update time.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// A slice contains a total and (if the request specified a time granularity)
    /// a time series of metric values. Each slice contains a unique combination of
    /// the cardinality of dimensions from the request.
    #[prost(message, repeated, tag = "2")]
    pub slices: ::prost::alloc::vec::Vec<query_metrics_response::Slice>,
    /// The macro average slice contains aggregated averages across the selected
    /// dimension. i.e. if group_by agent is specified this field will contain the
    /// average across all agents.
    /// This field is only populated if the request specifies a Dimension.
    #[prost(message, optional, tag = "4")]
    pub macro_average_slice: ::core::option::Option<query_metrics_response::Slice>,
}
/// Nested message and enum types in `QueryMetricsResponse`.
pub mod query_metrics_response {
    /// A slice contains a total and (if the request specified a time granularity)
    /// a time series of metric values. Each slice contains a unique combination of
    /// the cardinality of dimensions from the request.
    ///
    /// For example, if the request specifies a single ISSUE dimension and it has a
    /// cardinality of 2 (i.e. the data used to compute the metrics has 2 issues in
    /// total), the response will have 2 slices:
    ///
    /// * Slice 1 -> dimensions=\[Issue 1\]
    /// * Slice 2 -> dimensions=\[Issue 2\]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Slice {
        /// A unique combination of dimensions that this slice represents.
        #[prost(message, repeated, tag = "1")]
        pub dimensions: ::prost::alloc::vec::Vec<super::Dimension>,
        /// The total metric value. The interval of this data point is
        /// [starting create time, ending create time) from the request.
        #[prost(message, optional, tag = "2")]
        pub total: ::core::option::Option<slice::DataPoint>,
        /// A time series of metric values. This is only populated if the request
        /// specifies a time granularity other than NONE.
        #[prost(message, optional, tag = "3")]
        pub time_series: ::core::option::Option<slice::TimeSeries>,
    }
    /// Nested message and enum types in `Slice`.
    pub mod slice {
        /// A data point contains the metric values mapped to an interval.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DataPoint {
            /// The interval that this data point represents.
            ///
            /// * If this is the total data point, the interval is
            /// [starting create time, ending create time) from the request.
            /// * If this a data point from the time series, the interval is
            /// [time, time + time granularity from the request).
            #[prost(message, optional, tag = "1")]
            pub interval: ::core::option::Option<
                super::super::super::super::super::r#type::Interval,
            >,
            /// The measure included in this data point.
            #[prost(oneof = "data_point::Measure", tags = "2")]
            pub measure: ::core::option::Option<data_point::Measure>,
        }
        /// Nested message and enum types in `DataPoint`.
        pub mod data_point {
            /// The measure related to conversations.
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ConversationMeasure {
                /// The conversation count.
                #[prost(int32, optional, tag = "1")]
                pub conversation_count: ::core::option::Option<i32>,
                /// The average silence percentage.
                #[prost(float, optional, tag = "2")]
                pub average_silence_percentage: ::core::option::Option<f32>,
                /// The average duration.
                #[prost(message, optional, tag = "3")]
                pub average_duration: ::core::option::Option<::prost_types::Duration>,
                /// The average turn count.
                #[prost(float, optional, tag = "4")]
                pub average_turn_count: ::core::option::Option<f32>,
                /// The average agent's sentiment score.
                #[prost(float, optional, tag = "5")]
                pub average_agent_sentiment_score: ::core::option::Option<f32>,
                /// The average client's sentiment score.
                #[prost(float, optional, tag = "6")]
                pub average_client_sentiment_score: ::core::option::Option<f32>,
                /// The average customer satisfaction rating.
                #[prost(double, optional, tag = "8")]
                pub average_customer_satisfaction_rating: ::core::option::Option<f64>,
                /// Average QA normalized score.
                /// Will exclude 0's in average calculation.
                #[prost(double, optional, tag = "7")]
                pub average_qa_normalized_score: ::core::option::Option<f64>,
                /// Average QA normalized score for all the tags.
                #[prost(message, repeated, tag = "9")]
                pub qa_tag_scores: ::prost::alloc::vec::Vec<
                    conversation_measure::QaTagScore,
                >,
                /// Average QA normalized score averaged for questions averaged across
                /// all revisions of the parent scorecard.
                /// Will be only populated if the request specifies a dimension of
                /// QA_QUESTION_ID.
                #[prost(double, optional, tag = "10")]
                pub average_qa_question_normalized_score: ::core::option::Option<f64>,
            }
            /// Nested message and enum types in `ConversationMeasure`.
            pub mod conversation_measure {
                /// Average QA normalized score for the tag.
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct QaTagScore {
                    /// Tag name.
                    #[prost(string, tag = "1")]
                    pub tag: ::prost::alloc::string::String,
                    /// Average tag normalized score per tag.
                    #[prost(double, tag = "2")]
                    pub average_tag_normalized_score: f64,
                }
            }
            /// The measure included in this data point.
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Measure {
                /// The measure related to conversations.
                #[prost(message, tag = "2")]
                ConversationMeasure(ConversationMeasure),
            }
        }
        /// A time series of metric values.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TimeSeries {
            /// The data points that make up the time series .
            #[prost(message, repeated, tag = "4")]
            pub data_points: ::prost::alloc::vec::Vec<DataPoint>,
        }
    }
}
/// The metadata from querying metrics.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryMetricsMetadata {}
/// The request for creating a QaQuestion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateQaQuestionRequest {
    /// Required. The parent resource of the QaQuestion.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The QaQuestion to create.
    #[prost(message, optional, tag = "2")]
    pub qa_question: ::core::option::Option<QaQuestion>,
    /// Optional. A unique ID for the new question. This ID will become the final
    /// component of the question's resource name. If no ID is specified, a
    /// server-generated ID will be used.
    ///
    /// This value should be 4-64 characters and must match the regular
    /// expression `^\[a-z0-9-\]{4,64}$`. Valid characters are `[a-z][0-9]-`.
    #[prost(string, tag = "3")]
    pub qa_question_id: ::prost::alloc::string::String,
}
/// The request for a QaQuestion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetQaQuestionRequest {
    /// Required. The name of the QaQuestion to get.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request to list QaQuestions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListQaQuestionsRequest {
    /// Required. The parent resource of the questions.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of questions to return in the response. If the
    /// value is zero, the service will select a default size. A call might return
    /// fewer objects than requested. A non-empty `next_page_token` in the response
    /// indicates that more data is available.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The value returned by the last `ListQaQuestionsResponse`. This
    /// value indicates that this is a continuation of a prior `ListQaQuestions`
    /// call and that the system should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response from a ListQaQuestions request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListQaQuestionsResponse {
    /// The QaQuestions under the parent.
    #[prost(message, repeated, tag = "1")]
    pub qa_questions: ::prost::alloc::vec::Vec<QaQuestion>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for updating a QaQuestion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateQaQuestionRequest {
    /// Required. The QaQuestion to update.
    #[prost(message, optional, tag = "1")]
    pub qa_question: ::core::option::Option<QaQuestion>,
    /// Required. The list of fields to be updated. All possible fields can be
    /// updated by passing `*`, or a subset of the following updateable fields can
    /// be provided:
    ///
    /// * `abbreviation`
    /// * `answer_choices`
    /// * `answer_instructions`
    /// * `order`
    /// * `question_body`
    /// * `tags`
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request for deleting a QaQuestion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteQaQuestionRequest {
    /// Required. The name of the QaQuestion to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for creating a QaScorecard.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateQaScorecardRequest {
    /// Required. The parent resource of the QaScorecard.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The QaScorecard to create.
    #[prost(message, optional, tag = "2")]
    pub qa_scorecard: ::core::option::Option<QaScorecard>,
    /// Optional. A unique ID for the new QaScorecard. This ID will become the
    /// final component of the QaScorecard's resource name. If no ID is specified,
    /// a server-generated ID will be used.
    ///
    /// This value should be 4-64 characters and must match the regular
    /// expression `^\[a-z0-9-\]{4,64}$`. Valid characters are `[a-z][0-9]-`.
    #[prost(string, tag = "3")]
    pub qa_scorecard_id: ::prost::alloc::string::String,
}
/// The request for a QaScorecard. By default, returns the latest revision.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetQaScorecardRequest {
    /// Required. The name of the QaScorecard to get.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for updating a QaScorecard.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateQaScorecardRequest {
    /// Required. The QaScorecard to update.
    #[prost(message, optional, tag = "1")]
    pub qa_scorecard: ::core::option::Option<QaScorecard>,
    /// Required. The list of fields to be updated. All possible fields can be
    /// updated by passing `*`, or a subset of the following updateable fields can
    /// be provided:
    ///
    /// * `description`
    /// * `display_name`
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request for deleting a QaScorecard.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteQaScorecardRequest {
    /// Required. The name of the QaScorecard to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If set to true, all of this QaScorecard's child resources will
    /// also be deleted. Otherwise, the request will only succeed if it has none.
    #[prost(bool, tag = "2")]
    pub force: bool,
}
/// The request for creating a QaScorecardRevision.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateQaScorecardRevisionRequest {
    /// Required. The parent resource of the QaScorecardRevision.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The QaScorecardRevision to create.
    #[prost(message, optional, tag = "2")]
    pub qa_scorecard_revision: ::core::option::Option<QaScorecardRevision>,
    /// Optional. A unique ID for the new QaScorecardRevision. This ID will become
    /// the final component of the QaScorecardRevision's resource name. If no ID is
    /// specified, a server-generated ID will be used.
    ///
    /// This value should be 4-64 characters and must match the regular
    /// expression `^\[a-z0-9-\]{4,64}$`. Valid characters are `[a-z][0-9]-`.
    #[prost(string, tag = "3")]
    pub qa_scorecard_revision_id: ::prost::alloc::string::String,
}
/// The request for a QaScorecardRevision.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetQaScorecardRevisionRequest {
    /// Required. The name of the QaScorecardRevision to get.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for TuneQaScorecardRevision endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TuneQaScorecardRevisionRequest {
    /// Required. The parent resource for new fine tuning job instance.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Filter for selecting the feedback labels that needs to be
    /// used for training.
    /// This filter can be used to limit the feedback labels used for tuning to a
    /// feedback labels created or updated for a specific time-window etc.
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Run in validate only mode, no fine tuning will actually run.
    /// Data quality validations like training data distributions will run.
    /// Even when set to false, the data quality validations will still run but
    /// once the validations complete we will proceed with the fine tune, if
    /// applicable.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Response for TuneQaScorecardRevision endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TuneQaScorecardRevisionResponse {}
/// Metadata for TuneQaScorecardRevision endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TuneQaScorecardRevisionMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The original request.
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<TuneQaScorecardRevisionRequest>,
    /// Output only. The results of data validation per question in the request.
    #[prost(message, repeated, tag = "4")]
    pub qa_question_dataset_validation_results: ::prost::alloc::vec::Vec<
        tune_qa_scorecard_revision_metadata::QaQuestionDatasetValidationResult,
    >,
    /// Output only. The metrics for each QaQuestion in the TuneScorecardRevision
    /// request.
    #[prost(message, repeated, tag = "5")]
    pub qa_question_dataset_tuning_metrics: ::prost::alloc::vec::Vec<
        tune_qa_scorecard_revision_metadata::QaQuestionDatasetTuningMetrics,
    >,
    /// Output only. The percentage of the tuning job that has completed. Always
    /// between 0 and 1 where 0 indicates the job has not started i.e. 0% and 1
    /// indicates the job has completed i.e. 100%.
    #[prost(double, tag = "6")]
    pub tuning_completion_ratio: f64,
}
/// Nested message and enum types in `TuneQaScorecardRevisionMetadata`.
pub mod tune_qa_scorecard_revision_metadata {
    /// Contains validation results for a question in the tuning request.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QaQuestionDatasetValidationResult {
        /// Output only. The resource path of the question whose dataset was
        /// evaluated for tuning.
        #[prost(string, tag = "1")]
        pub question: ::prost::alloc::string::String,
        /// A list of any applicable data validation warnings about the question's
        /// feedback labels.
        #[prost(enumeration = "super::DatasetValidationWarning", repeated, tag = "2")]
        pub dataset_validation_warnings: ::prost::alloc::vec::Vec<i32>,
        /// The number of valid feedback labels in the question's dataset.
        #[prost(int32, tag = "3")]
        pub valid_feedback_labels_count: i32,
    }
    /// Contains performance metrics for each QaQuestion in the
    /// TuneScorecardRevision request.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QaQuestionDatasetTuningMetrics {
        /// Output only. The resource path of the question whose dataset was
        /// evaluated for tuning.
        #[prost(string, tag = "1")]
        pub question: ::prost::alloc::string::String,
        /// Output only. The metrics for the question's dataset.
        #[prost(message, optional, tag = "2")]
        pub metrics: ::core::option::Option<qa_question_dataset_tuning_metrics::Metrics>,
    }
    /// Nested message and enum types in `QaQuestionDatasetTuningMetrics`.
    pub mod qa_question_dataset_tuning_metrics {
        /// Performance metrics for the question's dataset calculated over the tuned
        /// model.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Metrics {
            /// Accuracy of the question's dataset.
            #[prost(double, tag = "1")]
            pub accuracy: f64,
        }
    }
}
/// The request to deploy a QaScorecardRevision
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployQaScorecardRevisionRequest {
    /// Required. The name of the QaScorecardRevision to deploy.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request to undeploy a QaScorecardRevision
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployQaScorecardRevisionRequest {
    /// Required. The name of the QaScorecardRevision to undeploy.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request to delete a QaScorecardRevision.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteQaScorecardRevisionRequest {
    /// Required. The name of the QaScorecardRevision to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If set to true, all of this QaScorecardRevision's child resources
    /// will also be deleted. Otherwise, the request will only succeed if it has
    /// none.
    #[prost(bool, tag = "2")]
    pub force: bool,
}
/// Request to list QaScorecards.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListQaScorecardsRequest {
    /// Required. The parent resource of the scorecards.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of scorecards to return in the response. If
    /// the value is zero, the service will select a default size. A call might
    /// return fewer objects than requested. A non-empty `next_page_token` in the
    /// response indicates that more data is available.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The value returned by the last `ListQaScorecardsResponse`. This
    /// value indicates that this is a continuation of a prior `ListQaScorecards`
    /// call and that the system should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response from a ListQaScorecards request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListQaScorecardsResponse {
    /// The QaScorecards under the parent.
    #[prost(message, repeated, tag = "1")]
    pub qa_scorecards: ::prost::alloc::vec::Vec<QaScorecard>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request to list QaScorecardRevisions
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListQaScorecardRevisionsRequest {
    /// Required. The parent resource of the scorecard revisions. To list all
    /// revisions of all scorecards, substitute the QaScorecard ID with a '-'
    /// character.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of scorecard revisions to return in the
    /// response. If the value is zero, the service will select a default size. A
    /// call might return fewer objects than requested. A non-empty
    /// `next_page_token` in the response indicates that more data is available.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The value returned by the last
    /// `ListQaScorecardRevisionsResponse`. This value indicates that this is a
    /// continuation of a prior `ListQaScorecardRevisions` call and that the system
    /// should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. A filter to reduce results to a specific subset. Useful for
    /// querying scorecard revisions with specific properties.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response from a ListQaScorecardRevisions request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListQaScorecardRevisionsResponse {
    /// The QaScorecards under the parent.
    #[prost(message, repeated, tag = "1")]
    pub qa_scorecard_revisions: ::prost::alloc::vec::Vec<QaScorecardRevision>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for creating a feedback label.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeedbackLabelRequest {
    /// Required. The parent resource of the feedback label.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The ID of the feedback label to create.
    /// If one is not specified it will be generated by the server.
    #[prost(string, tag = "2")]
    pub feedback_label_id: ::prost::alloc::string::String,
    /// Required. The feedback label to create.
    #[prost(message, optional, tag = "3")]
    pub feedback_label: ::core::option::Option<FeedbackLabel>,
}
/// The request for listing feedback labels.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeedbackLabelsRequest {
    /// Required. The parent resource of the feedback labels.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. A filter to reduce results to a specific subset. Supports
    /// disjunctions (OR) and conjunctions (AND). Automatically sorts by
    /// conversation ID. To sort by all feedback labels in a project see
    /// ListAllFeedbackLabels.
    ///
    /// Supported fields:
    ///
    /// * `issue_model_id`
    /// * `qa_question_id`
    /// * `qa_scorecard_id`
    /// * `min_create_time`
    /// * `max_create_time`
    /// * `min_update_time`
    /// * `max_update_time`
    /// * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The maximum number of feedback labels to return in the response.
    /// A valid page size ranges from 0 to 100,000 inclusive. If the page size is
    /// zero or unspecified, a default page size of 100 will be chosen. Note that a
    /// call might return fewer results than the requested page size.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. The value returned by the last `ListFeedbackLabelsResponse`. This
    /// value indicates that this is a continuation of a prior `ListFeedbackLabels`
    /// call and that the system should return the next page of data.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for listing feedback labels.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeedbackLabelsResponse {
    /// The feedback labels that match the request.
    #[prost(message, repeated, tag = "1")]
    pub feedback_labels: ::prost::alloc::vec::Vec<FeedbackLabel>,
    /// The next page token.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for getting a feedback label.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeedbackLabelRequest {
    /// Required. The name of the feedback label to get.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for updating a feedback label.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeedbackLabelRequest {
    /// Required. The feedback label to update.
    #[prost(message, optional, tag = "1")]
    pub feedback_label: ::core::option::Option<FeedbackLabel>,
    /// Required. The list of fields to be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request for deleting a feedback label.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFeedbackLabelRequest {
    /// Required. The name of the feedback label to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for listing all feedback labels.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAllFeedbackLabelsRequest {
    /// Required. The parent resource of all feedback labels per project.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of feedback labels to return in the response.
    /// A valid page size ranges from 0 to 100,000 inclusive. If the page size is
    /// zero or unspecified, a default page size of 100 will be chosen. Note that a
    /// call might return fewer results than the requested page size.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The value returned by the last `ListAllFeedbackLabelsResponse`.
    /// This value indicates that this is a continuation of a prior
    /// `ListAllFeedbackLabels` call and that the system should return the next
    /// page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. A filter to reduce results to a specific subset in the entire
    /// project. Supports disjunctions (OR) and conjunctions (AND).
    ///
    /// Supported fields:
    ///
    /// * `issue_model_id`
    /// * `qa_question_id`
    /// * `min_create_time`
    /// * `max_create_time`
    /// * `min_update_time`
    /// * `max_update_time`
    /// * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response for listing all feedback labels.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAllFeedbackLabelsResponse {
    /// The feedback labels that match the request.
    #[prost(message, repeated, tag = "1")]
    pub feedback_labels: ::prost::alloc::vec::Vec<FeedbackLabel>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for bulk uploading feedback labels.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkUploadFeedbackLabelsRequest {
    /// Required. The parent resource for new feedback labels.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. If set, upload will not happen and the labels will be validated.
    /// If not set, then default behavior will be to upload the labels after
    /// validation is complete.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
    /// Configuration for an external data store containing objects that will
    /// be converted to FeedbackLabels.
    #[prost(oneof = "bulk_upload_feedback_labels_request::Source", tags = "2")]
    pub source: ::core::option::Option<bulk_upload_feedback_labels_request::Source>,
}
/// Nested message and enum types in `BulkUploadFeedbackLabelsRequest`.
pub mod bulk_upload_feedback_labels_request {
    /// Google Cloud Storage Object details to get the feedback label file from.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GcsSource {
        /// Required. File format which will be ingested.
        #[prost(enumeration = "gcs_source::Format", tag = "1")]
        pub format: i32,
        /// Required. The Google Cloud Storage URI of the file to import.
        /// Format: `gs://bucket_name/object_name`
        #[prost(string, tag = "2")]
        pub object_uri: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `GcsSource`.
    pub mod gcs_source {
        /// All permissible file formats.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Format {
            /// Unspecified format.
            Unspecified = 0,
            /// CSV format.
            Csv = 1,
            /// JSON format.
            Json = 2,
        }
        impl Format {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "FORMAT_UNSPECIFIED",
                    Self::Csv => "CSV",
                    Self::Json => "JSON",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                    "CSV" => Some(Self::Csv),
                    "JSON" => Some(Self::Json),
                    _ => None,
                }
            }
        }
    }
    /// Configuration for an external data store containing objects that will
    /// be converted to FeedbackLabels.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// A cloud storage bucket source.
        #[prost(message, tag = "2")]
        GcsSource(GcsSource),
    }
}
/// Response for the Bulk Upload Feedback Labels API.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BulkUploadFeedbackLabelsResponse {}
/// Metadata for the Bulk Upload Feedback Labels API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkUploadFeedbackLabelsMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The original request for ingest.
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<BulkUploadFeedbackLabelsRequest>,
    /// Partial errors during ingest operation that might cause the operation
    /// output to be incomplete.
    #[prost(message, repeated, tag = "4")]
    pub partial_errors: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    /// Output only. Statistics for BulkUploadFeedbackLabels operation.
    #[prost(message, optional, tag = "5")]
    pub upload_stats: ::core::option::Option<
        bulk_upload_feedback_labels_metadata::UploadStats,
    >,
}
/// Nested message and enum types in `BulkUploadFeedbackLabelsMetadata`.
pub mod bulk_upload_feedback_labels_metadata {
    /// Statistics for BulkUploadFeedbackLabels operation.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UploadStats {
        /// The number of objects processed during the upload operation.
        #[prost(int32, tag = "1")]
        pub processed_object_count: i32,
        /// The number of objects skipped because of failed validation
        #[prost(int32, tag = "2")]
        pub failed_validation_count: i32,
        /// The number of new feedback labels added during this ingest operation.
        #[prost(int32, tag = "3")]
        pub successful_upload_count: i32,
    }
}
/// Request for the BulkDownloadFeedbackLabel endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkDownloadFeedbackLabelsRequest {
    /// Required. The parent resource for new feedback labels.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. A filter to reduce results to a specific subset. Supports
    /// disjunctions (OR) and conjunctions (AND).
    ///
    /// Supported fields:
    ///
    /// * `issue_model_id`
    /// * `qa_question_id`
    /// * `qa_scorecard_id`
    /// * `min_create_time`
    /// * `max_create_time`
    /// * `min_update_time`
    /// * `max_update_time`
    /// * `feedback_label_type`: QUALITY_AI, TOPIC_MODELING
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Limits the maximum number of feedback labels that will be
    /// downloaded. The first `N` feedback labels will be downloaded.
    #[prost(int32, tag = "4")]
    pub max_download_count: i32,
    /// Optional. The type of feedback labels that will be downloaded.
    #[prost(
        enumeration = "bulk_download_feedback_labels_request::FeedbackLabelType",
        tag = "5"
    )]
    pub feedback_label_type: i32,
    /// Optional. Filter parent conversations to download feedback labels for.
    /// When specified, the feedback labels will be downloaded for the
    /// conversations that match the filter.
    /// If `template_qa_scorecard_id` is set, all the conversations that match the
    /// filter will be paired with the questions under the scorecard for labeling.
    #[prost(string, tag = "6")]
    pub conversation_filter: ::prost::alloc::string::String,
    /// Optional. If set, a template for labeling conversations and scorecard
    /// questions will be created from the conversation_filter and the questions
    /// under the scorecard(s). The feedback label `filter` will be ignored.
    #[prost(string, repeated, tag = "7")]
    pub template_qa_scorecard_id: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Configuration for an external data store to which the feedback labels
    /// will be written to.
    #[prost(oneof = "bulk_download_feedback_labels_request::Destination", tags = "3")]
    pub destination: ::core::option::Option<
        bulk_download_feedback_labels_request::Destination,
    >,
}
/// Nested message and enum types in `BulkDownloadFeedbackLabelsRequest`.
pub mod bulk_download_feedback_labels_request {
    /// Google Cloud Storage Object details to write the feedback labels to.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GcsDestination {
        /// Required. File format in which the labels will be exported.
        #[prost(enumeration = "gcs_destination::Format", tag = "1")]
        pub format: i32,
        /// Required. The Google Cloud Storage URI to write the feedback labels to.
        /// The file name will be used as a prefix for the files written to the
        /// bucket if the output needs to be split across multiple files, otherwise
        /// it will be used as is. The file extension will be appended to the file
        /// name based on the format selected.
        ///   E.g. `gs://bucket_name/object_uri_prefix`
        #[prost(string, tag = "2")]
        pub object_uri: ::prost::alloc::string::String,
        /// Optional. Add whitespace to the JSON file. Makes easier to read, but
        /// increases file size. Only applicable for JSON format.
        #[prost(bool, tag = "3")]
        pub add_whitespace: bool,
        /// Optional. Always print fields with no presence.
        /// This is useful for printing fields that are not set, like implicit 0
        /// value or empty lists/maps. Only applicable for JSON format.
        #[prost(bool, tag = "4")]
        pub always_print_empty_fields: bool,
        /// Optional. The number of records per file. Applicable for either format.
        #[prost(int64, tag = "5")]
        pub records_per_file_count: i64,
    }
    /// Nested message and enum types in `GcsDestination`.
    pub mod gcs_destination {
        /// All permissible file formats.
        /// See `records_per_file_count` to override the default number of records
        /// per file.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Format {
            /// Unspecified format.
            Unspecified = 0,
            /// CSV format.
            /// 1,000 labels are stored per CSV file by default.
            Csv = 1,
            /// JSON format.
            /// 1 label stored per JSON file by default.
            Json = 2,
        }
        impl Format {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "FORMAT_UNSPECIFIED",
                    Self::Csv => "CSV",
                    Self::Json => "JSON",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                    "CSV" => Some(Self::Csv),
                    "JSON" => Some(Self::Json),
                    _ => None,
                }
            }
        }
    }
    /// Possible feedback label types that will be downloaded.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedbackLabelType {
        /// Unspecified format
        Unspecified = 0,
        /// Downloaded file will contain all Quality AI labels from the latest
        /// scorecard revision.
        QualityAi = 1,
        /// Downloaded file will contain only Topic Modeling labels.
        TopicModeling = 2,
    }
    impl FeedbackLabelType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FEEDBACK_LABEL_TYPE_UNSPECIFIED",
                Self::QualityAi => "QUALITY_AI",
                Self::TopicModeling => "TOPIC_MODELING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FEEDBACK_LABEL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "QUALITY_AI" => Some(Self::QualityAi),
                "TOPIC_MODELING" => Some(Self::TopicModeling),
                _ => None,
            }
        }
    }
    /// Configuration for an external data store to which the feedback labels
    /// will be written to.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Destination {
        /// A cloud storage bucket destination.
        #[prost(message, tag = "3")]
        GcsDestination(GcsDestination),
    }
}
/// Response for the BulkDownloadFeedbackLabel endpoint.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BulkDownloadFeedbackLabelsResponse {}
/// Metadata for the BulkDownloadFeedbackLabel endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkDownloadFeedbackLabelsMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The original request for download.
    #[prost(message, optional, tag = "3")]
    pub request: ::core::option::Option<BulkDownloadFeedbackLabelsRequest>,
    /// Partial errors during ingest operation that might cause the operation
    /// output to be incomplete.
    #[prost(message, repeated, tag = "4")]
    pub partial_errors: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    /// Output only. Statistics for BulkDownloadFeedbackLabels operation.
    #[prost(message, optional, tag = "5")]
    pub download_stats: ::core::option::Option<
        bulk_download_feedback_labels_metadata::DownloadStats,
    >,
}
/// Nested message and enum types in `BulkDownloadFeedbackLabelsMetadata`.
pub mod bulk_download_feedback_labels_metadata {
    /// Statistics for BulkDownloadFeedbackLabels operation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DownloadStats {
        /// The number of objects processed during the download operation.
        #[prost(int32, tag = "1")]
        pub processed_object_count: i32,
        /// The number of new feedback labels downloaded during this operation.
        /// Different from "processed" because some labels might not be downloaded
        /// because an error.
        #[prost(int32, tag = "2")]
        pub successful_download_count: i32,
        /// Total number of files written to the provided Cloud Storage bucket.
        #[prost(int32, tag = "3")]
        pub total_files_written: i32,
        /// Output only. Full name of the files written to Cloud storage.
        #[prost(string, repeated, tag = "4")]
        pub file_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
/// Represents the options for viewing a conversation.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConversationView {
    /// The conversation view is not specified.
    ///
    /// * Defaults to `FULL` in `GetConversationRequest`.
    /// * Defaults to `BASIC` in `ListConversationsRequest`.
    Unspecified = 0,
    /// Populates all fields in the conversation.
    Full = 2,
    /// Populates all fields in the conversation except the transcript.
    Basic = 1,
}
impl ConversationView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONVERSATION_VIEW_UNSPECIFIED",
            Self::Full => "FULL",
            Self::Basic => "BASIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONVERSATION_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "FULL" => Some(Self::Full),
            "BASIC" => Some(Self::Basic),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod contact_center_insights_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// An API that lets users analyze and explore their business conversation data.
    #[derive(Debug, Clone)]
    pub struct ContactCenterInsightsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ContactCenterInsightsClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ContactCenterInsightsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ContactCenterInsightsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ContactCenterInsightsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a conversation.
        /// Note that this method does not support audio transcription or redaction.
        /// Use `conversations.upload` instead.
        pub async fn create_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateConversationRequest>,
        ) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CreateConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "CreateConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a long-running conversation upload operation. This method differs
        /// from `CreateConversation` by allowing audio transcription and optional DLP
        /// redaction.
        pub async fn upload_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::UploadConversationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UploadConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "UploadConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a conversation.
        pub async fn update_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateConversationRequest>,
        ) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UpdateConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "UpdateConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a conversation.
        pub async fn get_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConversationRequest>,
        ) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "GetConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists conversations.
        pub async fn list_conversations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConversationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListConversationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListConversations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "ListConversations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a conversation.
        pub async fn delete_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteConversationRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeleteConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "DeleteConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an analysis. The long running operation is done when the analysis
        /// has completed.
        pub async fn create_analysis(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAnalysisRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CreateAnalysis",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "CreateAnalysis",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an analysis.
        pub async fn get_analysis(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAnalysisRequest>,
        ) -> std::result::Result<tonic::Response<super::Analysis>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetAnalysis",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "GetAnalysis",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists analyses.
        pub async fn list_analyses(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAnalysesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAnalysesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListAnalyses",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "ListAnalyses",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an analysis.
        pub async fn delete_analysis(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAnalysisRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeleteAnalysis",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "DeleteAnalysis",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Analyzes multiple conversations in a single request.
        pub async fn bulk_analyze_conversations(
            &mut self,
            request: impl tonic::IntoRequest<super::BulkAnalyzeConversationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/BulkAnalyzeConversations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "BulkAnalyzeConversations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes multiple conversations in a single request.
        pub async fn bulk_delete_conversations(
            &mut self,
            request: impl tonic::IntoRequest<super::BulkDeleteConversationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/BulkDeleteConversations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "BulkDeleteConversations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Imports conversations and processes them according to the user's
        /// configuration.
        pub async fn ingest_conversations(
            &mut self,
            request: impl tonic::IntoRequest<super::IngestConversationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/IngestConversations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "IngestConversations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Export insights data to a destination defined in the request body.
        pub async fn export_insights_data(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportInsightsDataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ExportInsightsData",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "ExportInsightsData",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an issue model.
        pub async fn create_issue_model(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateIssueModelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CreateIssueModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "CreateIssueModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an issue model.
        pub async fn update_issue_model(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateIssueModelRequest>,
        ) -> std::result::Result<tonic::Response<super::IssueModel>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UpdateIssueModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "UpdateIssueModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an issue model.
        pub async fn get_issue_model(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIssueModelRequest>,
        ) -> std::result::Result<tonic::Response<super::IssueModel>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetIssueModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "GetIssueModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists issue models.
        pub async fn list_issue_models(
            &mut self,
            request: impl tonic::IntoRequest<super::ListIssueModelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListIssueModelsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListIssueModels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "ListIssueModels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an issue model.
        pub async fn delete_issue_model(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIssueModelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeleteIssueModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "DeleteIssueModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deploys an issue model. Returns an error if a model is already deployed.
        /// An issue model can only be used in analysis after it has been deployed.
        pub async fn deploy_issue_model(
            &mut self,
            request: impl tonic::IntoRequest<super::DeployIssueModelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeployIssueModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "DeployIssueModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Undeploys an issue model.
        /// An issue model can not be used in analysis after it has been undeployed.
        pub async fn undeploy_issue_model(
            &mut self,
            request: impl tonic::IntoRequest<super::UndeployIssueModelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UndeployIssueModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "UndeployIssueModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Exports an issue model to the provided destination.
        pub async fn export_issue_model(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportIssueModelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ExportIssueModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "ExportIssueModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Imports an issue model from a Cloud Storage bucket.
        pub async fn import_issue_model(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportIssueModelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ImportIssueModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "ImportIssueModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an issue.
        pub async fn get_issue(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIssueRequest>,
        ) -> std::result::Result<tonic::Response<super::Issue>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetIssue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "GetIssue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists issues.
        pub async fn list_issues(
            &mut self,
            request: impl tonic::IntoRequest<super::ListIssuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListIssuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListIssues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "ListIssues",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an issue.
        pub async fn update_issue(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateIssueRequest>,
        ) -> std::result::Result<tonic::Response<super::Issue>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UpdateIssue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "UpdateIssue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an issue.
        pub async fn delete_issue(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIssueRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeleteIssue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "DeleteIssue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an issue model's statistics.
        pub async fn calculate_issue_model_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::CalculateIssueModelStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CalculateIssueModelStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CalculateIssueModelStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "CalculateIssueModelStats",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a phrase matcher.
        pub async fn create_phrase_matcher(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePhraseMatcherRequest>,
        ) -> std::result::Result<tonic::Response<super::PhraseMatcher>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CreatePhraseMatcher",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "CreatePhraseMatcher",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a phrase matcher.
        pub async fn get_phrase_matcher(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPhraseMatcherRequest>,
        ) -> std::result::Result<tonic::Response<super::PhraseMatcher>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetPhraseMatcher",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "GetPhraseMatcher",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists phrase matchers.
        pub async fn list_phrase_matchers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPhraseMatchersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPhraseMatchersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListPhraseMatchers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "ListPhraseMatchers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a phrase matcher.
        pub async fn delete_phrase_matcher(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePhraseMatcherRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeletePhraseMatcher",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "DeletePhraseMatcher",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a phrase matcher.
        pub async fn update_phrase_matcher(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePhraseMatcherRequest>,
        ) -> std::result::Result<tonic::Response<super::PhraseMatcher>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UpdatePhraseMatcher",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "UpdatePhraseMatcher",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets conversation statistics.
        pub async fn calculate_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::CalculateStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CalculateStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CalculateStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "CalculateStats",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets project-level settings.
        pub async fn get_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSettingsRequest>,
        ) -> std::result::Result<tonic::Response<super::Settings>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "GetSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates project-level settings.
        pub async fn update_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSettingsRequest>,
        ) -> std::result::Result<tonic::Response<super::Settings>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UpdateSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "UpdateSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a analysis rule.
        pub async fn create_analysis_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAnalysisRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::AnalysisRule>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CreateAnalysisRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "CreateAnalysisRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a analysis rule.
        pub async fn get_analysis_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAnalysisRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::AnalysisRule>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetAnalysisRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "GetAnalysisRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists analysis rules.
        pub async fn list_analysis_rules(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAnalysisRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAnalysisRulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListAnalysisRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "ListAnalysisRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a analysis rule.
        pub async fn update_analysis_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAnalysisRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::AnalysisRule>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UpdateAnalysisRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "UpdateAnalysisRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a analysis rule.
        pub async fn delete_analysis_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAnalysisRuleRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeleteAnalysisRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "DeleteAnalysisRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets location-level encryption key specification.
        pub async fn get_encryption_spec(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEncryptionSpecRequest>,
        ) -> std::result::Result<tonic::Response<super::EncryptionSpec>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetEncryptionSpec",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "GetEncryptionSpec",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Initializes a location-level encryption key specification. An error will
        /// result if the location has resources already created before the
        /// initialization. After the encryption specification is initialized at a
        /// location, it is immutable and all newly created resources under the
        /// location will be encrypted with the existing specification.
        pub async fn initialize_encryption_spec(
            &mut self,
            request: impl tonic::IntoRequest<super::InitializeEncryptionSpecRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/InitializeEncryptionSpec",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "InitializeEncryptionSpec",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a view.
        pub async fn create_view(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateViewRequest>,
        ) -> std::result::Result<tonic::Response<super::View>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CreateView",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "CreateView",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a view.
        pub async fn get_view(
            &mut self,
            request: impl tonic::IntoRequest<super::GetViewRequest>,
        ) -> std::result::Result<tonic::Response<super::View>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetView",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "GetView",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists views.
        pub async fn list_views(
            &mut self,
            request: impl tonic::IntoRequest<super::ListViewsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListViewsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListViews",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "ListViews",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a view.
        pub async fn update_view(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateViewRequest>,
        ) -> std::result::Result<tonic::Response<super::View>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UpdateView",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "UpdateView",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a view.
        pub async fn delete_view(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteViewRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeleteView",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "DeleteView",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Query metrics.
        pub async fn query_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/QueryMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "QueryMetrics",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a QaQuestion.
        pub async fn create_qa_question(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateQaQuestionRequest>,
        ) -> std::result::Result<tonic::Response<super::QaQuestion>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CreateQaQuestion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "CreateQaQuestion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a QaQuestion.
        pub async fn get_qa_question(
            &mut self,
            request: impl tonic::IntoRequest<super::GetQaQuestionRequest>,
        ) -> std::result::Result<tonic::Response<super::QaQuestion>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetQaQuestion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "GetQaQuestion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a QaQuestion.
        pub async fn update_qa_question(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateQaQuestionRequest>,
        ) -> std::result::Result<tonic::Response<super::QaQuestion>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UpdateQaQuestion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "UpdateQaQuestion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a QaQuestion.
        pub async fn delete_qa_question(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteQaQuestionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeleteQaQuestion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "DeleteQaQuestion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists QaQuestions.
        pub async fn list_qa_questions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListQaQuestionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListQaQuestionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListQaQuestions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "ListQaQuestions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a QaScorecard.
        pub async fn create_qa_scorecard(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateQaScorecardRequest>,
        ) -> std::result::Result<tonic::Response<super::QaScorecard>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CreateQaScorecard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "CreateQaScorecard",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a QaScorecard.
        pub async fn get_qa_scorecard(
            &mut self,
            request: impl tonic::IntoRequest<super::GetQaScorecardRequest>,
        ) -> std::result::Result<tonic::Response<super::QaScorecard>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetQaScorecard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "GetQaScorecard",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a QaScorecard.
        pub async fn update_qa_scorecard(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateQaScorecardRequest>,
        ) -> std::result::Result<tonic::Response<super::QaScorecard>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UpdateQaScorecard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "UpdateQaScorecard",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a QaScorecard.
        pub async fn delete_qa_scorecard(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteQaScorecardRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeleteQaScorecard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "DeleteQaScorecard",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists QaScorecards.
        pub async fn list_qa_scorecards(
            &mut self,
            request: impl tonic::IntoRequest<super::ListQaScorecardsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListQaScorecardsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListQaScorecards",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "ListQaScorecards",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a QaScorecardRevision.
        pub async fn create_qa_scorecard_revision(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateQaScorecardRevisionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QaScorecardRevision>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CreateQaScorecardRevision",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "CreateQaScorecardRevision",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a QaScorecardRevision.
        pub async fn get_qa_scorecard_revision(
            &mut self,
            request: impl tonic::IntoRequest<super::GetQaScorecardRevisionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QaScorecardRevision>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetQaScorecardRevision",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "GetQaScorecardRevision",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Fine tune one or more QaModels.
        pub async fn tune_qa_scorecard_revision(
            &mut self,
            request: impl tonic::IntoRequest<super::TuneQaScorecardRevisionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/TuneQaScorecardRevision",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "TuneQaScorecardRevision",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deploy a QaScorecardRevision.
        pub async fn deploy_qa_scorecard_revision(
            &mut self,
            request: impl tonic::IntoRequest<super::DeployQaScorecardRevisionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QaScorecardRevision>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeployQaScorecardRevision",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "DeployQaScorecardRevision",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Undeploy a QaScorecardRevision.
        pub async fn undeploy_qa_scorecard_revision(
            &mut self,
            request: impl tonic::IntoRequest<super::UndeployQaScorecardRevisionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QaScorecardRevision>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UndeployQaScorecardRevision",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "UndeployQaScorecardRevision",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a QaScorecardRevision.
        pub async fn delete_qa_scorecard_revision(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteQaScorecardRevisionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeleteQaScorecardRevision",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "DeleteQaScorecardRevision",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all revisions under the parent QaScorecard.
        pub async fn list_qa_scorecard_revisions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListQaScorecardRevisionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListQaScorecardRevisionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListQaScorecardRevisions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "ListQaScorecardRevisions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create feedback label.
        pub async fn create_feedback_label(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFeedbackLabelRequest>,
        ) -> std::result::Result<tonic::Response<super::FeedbackLabel>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/CreateFeedbackLabel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "CreateFeedbackLabel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List feedback labels.
        pub async fn list_feedback_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFeedbackLabelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFeedbackLabelsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListFeedbackLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "ListFeedbackLabels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get feedback label.
        pub async fn get_feedback_label(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFeedbackLabelRequest>,
        ) -> std::result::Result<tonic::Response<super::FeedbackLabel>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/GetFeedbackLabel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "GetFeedbackLabel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update feedback label.
        pub async fn update_feedback_label(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateFeedbackLabelRequest>,
        ) -> std::result::Result<tonic::Response<super::FeedbackLabel>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/UpdateFeedbackLabel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "UpdateFeedbackLabel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete feedback label.
        pub async fn delete_feedback_label(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFeedbackLabelRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/DeleteFeedbackLabel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "DeleteFeedbackLabel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all feedback labels by project number.
        pub async fn list_all_feedback_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAllFeedbackLabelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAllFeedbackLabelsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/ListAllFeedbackLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "ListAllFeedbackLabels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Upload feedback labels in bulk.
        pub async fn bulk_upload_feedback_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::BulkUploadFeedbackLabelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/BulkUploadFeedbackLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "BulkUploadFeedbackLabels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Download feedback labels in bulk.
        pub async fn bulk_download_feedback_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::BulkDownloadFeedbackLabelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contactcenterinsights.v1.ContactCenterInsights/BulkDownloadFeedbackLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contactcenterinsights.v1.ContactCenterInsights",
                        "BulkDownloadFeedbackLabels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
