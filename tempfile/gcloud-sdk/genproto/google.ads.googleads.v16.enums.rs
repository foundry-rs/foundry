// This file is @generated by prost-build.
/// Container for enum describing possible policy topic entry types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyTopicEntryTypeEnum {}
/// Nested message and enum types in `PolicyTopicEntryTypeEnum`.
pub mod policy_topic_entry_type_enum {
    /// The possible policy topic entry types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyTopicEntryType {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// The resource will not be served.
        Prohibited = 2,
        /// The resource will not be served under some circumstances.
        Limited = 4,
        /// The resource cannot serve at all because of the current targeting
        /// criteria.
        FullyLimited = 8,
        /// May be of interest, but does not limit how the resource is served.
        Descriptive = 5,
        /// Could increase coverage beyond normal.
        Broadening = 6,
        /// Constrained for all targeted countries, but may serve in other countries
        /// through area of interest.
        AreaOfInterestOnly = 7,
    }
    impl PolicyTopicEntryType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Prohibited => "PROHIBITED",
                Self::Limited => "LIMITED",
                Self::FullyLimited => "FULLY_LIMITED",
                Self::Descriptive => "DESCRIPTIVE",
                Self::Broadening => "BROADENING",
                Self::AreaOfInterestOnly => "AREA_OF_INTEREST_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PROHIBITED" => Some(Self::Prohibited),
                "LIMITED" => Some(Self::Limited),
                "FULLY_LIMITED" => Some(Self::FullyLimited),
                "DESCRIPTIVE" => Some(Self::Descriptive),
                "BROADENING" => Some(Self::Broadening),
                "AREA_OF_INTEREST_ONLY" => Some(Self::AreaOfInterestOnly),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible policy topic evidence destination
/// mismatch url types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyTopicEvidenceDestinationMismatchUrlTypeEnum {}
/// Nested message and enum types in `PolicyTopicEvidenceDestinationMismatchUrlTypeEnum`.
pub mod policy_topic_evidence_destination_mismatch_url_type_enum {
    /// The possible policy topic evidence destination mismatch url types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyTopicEvidenceDestinationMismatchUrlType {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// The display url.
        DisplayUrl = 2,
        /// The final url.
        FinalUrl = 3,
        /// The final mobile url.
        FinalMobileUrl = 4,
        /// The tracking url template, with substituted desktop url.
        TrackingUrl = 5,
        /// The tracking url template, with substituted mobile url.
        MobileTrackingUrl = 6,
    }
    impl PolicyTopicEvidenceDestinationMismatchUrlType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DisplayUrl => "DISPLAY_URL",
                Self::FinalUrl => "FINAL_URL",
                Self::FinalMobileUrl => "FINAL_MOBILE_URL",
                Self::TrackingUrl => "TRACKING_URL",
                Self::MobileTrackingUrl => "MOBILE_TRACKING_URL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DISPLAY_URL" => Some(Self::DisplayUrl),
                "FINAL_URL" => Some(Self::FinalUrl),
                "FINAL_MOBILE_URL" => Some(Self::FinalMobileUrl),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "MOBILE_TRACKING_URL" => Some(Self::MobileTrackingUrl),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible policy topic evidence destination not
/// working devices.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyTopicEvidenceDestinationNotWorkingDeviceEnum {}
/// Nested message and enum types in `PolicyTopicEvidenceDestinationNotWorkingDeviceEnum`.
pub mod policy_topic_evidence_destination_not_working_device_enum {
    /// The possible policy topic evidence destination not working devices.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyTopicEvidenceDestinationNotWorkingDevice {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// Landing page doesn't work on desktop device.
        Desktop = 2,
        /// Landing page doesn't work on Android device.
        Android = 3,
        /// Landing page doesn't work on iOS device.
        Ios = 4,
    }
    impl PolicyTopicEvidenceDestinationNotWorkingDevice {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Desktop => "DESKTOP",
                Self::Android => "ANDROID",
                Self::Ios => "IOS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DESKTOP" => Some(Self::Desktop),
                "ANDROID" => Some(Self::Android),
                "IOS" => Some(Self::Ios),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible policy topic evidence destination not
/// working DNS error types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyTopicEvidenceDestinationNotWorkingDnsErrorTypeEnum {}
/// Nested message and enum types in `PolicyTopicEvidenceDestinationNotWorkingDnsErrorTypeEnum`.
pub mod policy_topic_evidence_destination_not_working_dns_error_type_enum {
    /// The possible policy topic evidence destination not working DNS error types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyTopicEvidenceDestinationNotWorkingDnsErrorType {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// Host name not found in DNS when fetching landing page.
        HostnameNotFound = 2,
        /// Google internal crawler issue when communicating with DNS. This error
        /// doesn't mean the landing page doesn't work. Google will recrawl the
        /// landing page.
        GoogleCrawlerDnsIssue = 3,
    }
    impl PolicyTopicEvidenceDestinationNotWorkingDnsErrorType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::HostnameNotFound => "HOSTNAME_NOT_FOUND",
                Self::GoogleCrawlerDnsIssue => "GOOGLE_CRAWLER_DNS_ISSUE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "HOSTNAME_NOT_FOUND" => Some(Self::HostnameNotFound),
                "GOOGLE_CRAWLER_DNS_ISSUE" => Some(Self::GoogleCrawlerDnsIssue),
                _ => None,
            }
        }
    }
}
/// Provides the primary status of an asset link.
/// For example: a sitelink may be paused for a particular campaign.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetLinkPrimaryStatusEnum {}
/// Nested message and enum types in `AssetLinkPrimaryStatusEnum`.
pub mod asset_link_primary_status_enum {
    /// Enum Provides insight into why an asset is not serving or not serving
    /// at full capacity for a particular link level. There could be one status
    /// with multiple reasons. For example, a sitelink might be paused by the user,
    /// but also limited in serving due to violation of an alcohol policy. In
    /// this case, the PrimaryStatus will be returned as PAUSED, since the asset's
    /// effective status is determined by its paused state.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetLinkPrimaryStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The asset is eligible to serve.
        Eligible = 2,
        /// The user-specified asset link status is paused.
        Paused = 3,
        /// The user-specified asset link status is removed.
        Removed = 4,
        /// The asset may serve in the future.
        Pending = 5,
        /// The asset is serving in a partial capacity.
        Limited = 6,
        /// The asset is not eligible to serve.
        NotEligible = 7,
    }
    impl AssetLinkPrimaryStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Eligible => "ELIGIBLE",
                Self::Paused => "PAUSED",
                Self::Removed => "REMOVED",
                Self::Pending => "PENDING",
                Self::Limited => "LIMITED",
                Self::NotEligible => "NOT_ELIGIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ELIGIBLE" => Some(Self::Eligible),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                "PENDING" => Some(Self::Pending),
                "LIMITED" => Some(Self::Limited),
                "NOT_ELIGIBLE" => Some(Self::NotEligible),
                _ => None,
            }
        }
    }
}
/// Provides the reason of a primary status.
/// For example: a sitelink may be paused for a particular campaign.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetLinkPrimaryStatusReasonEnum {}
/// Nested message and enum types in `AssetLinkPrimaryStatusReasonEnum`.
pub mod asset_link_primary_status_reason_enum {
    /// Enum Provides insight into why an asset is not serving or not serving
    /// at full capacity for a particular link level. These reasons are
    /// aggregated to determine a final PrimaryStatus.
    /// For example, a sitelink might be paused by the user,
    /// but also limited in serving due to violation of an alcohol policy. In
    /// this case, the PrimaryStatus will be returned as PAUSED, since the asset's
    /// effective status is determined by its paused state.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetLinkPrimaryStatusReason {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The asset is paused for its linked rollup level. Contributes to a
        /// PrimaryStatus of PAUSED.
        AssetLinkPaused = 2,
        /// The asset is removed for its linked rollup level. Contributes to a
        /// PrimaryStatus of REMOVED.
        AssetLinkRemoved = 3,
        /// The asset has been marked as disapproved. Contributes to a PrimaryStatus
        /// of NOT_ELIGIBLE
        AssetDisapproved = 4,
        /// The asset has not completed policy review. Contributes to a PrimaryStatus
        /// of PENDING.
        AssetUnderReview = 5,
        /// The asset is approved with policies applied. Contributes to a
        /// PrimaryStatus of LIMITED.
        AssetApprovedLabeled = 6,
    }
    impl AssetLinkPrimaryStatusReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AssetLinkPaused => "ASSET_LINK_PAUSED",
                Self::AssetLinkRemoved => "ASSET_LINK_REMOVED",
                Self::AssetDisapproved => "ASSET_DISAPPROVED",
                Self::AssetUnderReview => "ASSET_UNDER_REVIEW",
                Self::AssetApprovedLabeled => "ASSET_APPROVED_LABELED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ASSET_LINK_PAUSED" => Some(Self::AssetLinkPaused),
                "ASSET_LINK_REMOVED" => Some(Self::AssetLinkRemoved),
                "ASSET_DISAPPROVED" => Some(Self::AssetDisapproved),
                "ASSET_UNDER_REVIEW" => Some(Self::AssetUnderReview),
                "ASSET_APPROVED_LABELED" => Some(Self::AssetApprovedLabeled),
                _ => None,
            }
        }
    }
}
/// Provides the quality evaluation disapproval reason of an asset.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetOfflineEvaluationErrorReasonsEnum {}
/// Nested message and enum types in `AssetOfflineEvaluationErrorReasonsEnum`.
pub mod asset_offline_evaluation_error_reasons_enum {
    /// Enum describing the quality evaluation disapproval reason of an asset.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetOfflineEvaluationErrorReasons {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// One or more descriptions repeats its corresponding row header.
        PriceAssetDescriptionRepeatsRowHeader = 2,
        /// Price asset contains repetitive headers.
        PriceAssetRepetitiveHeaders = 3,
        /// Price item header is not relevant to the price type.
        PriceAssetHeaderIncompatibleWithPriceType = 4,
        /// Price item description is not relevant to the item header.
        PriceAssetDescriptionIncompatibleWithItemHeader = 5,
        /// Price asset has a price qualifier in a description.
        PriceAssetDescriptionHasPriceQualifier = 6,
        /// Unsupported language for price assets
        PriceAssetUnsupportedLanguage = 7,
        /// Human raters identified an issue with the price asset that isn't captured
        /// by other error reasons. The primary purpose of this value is to represent
        /// legacy FeedItem disapprovals that are no longer produced.
        PriceAssetOtherError = 8,
    }
    impl AssetOfflineEvaluationErrorReasons {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::PriceAssetDescriptionRepeatsRowHeader => {
                    "PRICE_ASSET_DESCRIPTION_REPEATS_ROW_HEADER"
                }
                Self::PriceAssetRepetitiveHeaders => "PRICE_ASSET_REPETITIVE_HEADERS",
                Self::PriceAssetHeaderIncompatibleWithPriceType => {
                    "PRICE_ASSET_HEADER_INCOMPATIBLE_WITH_PRICE_TYPE"
                }
                Self::PriceAssetDescriptionIncompatibleWithItemHeader => {
                    "PRICE_ASSET_DESCRIPTION_INCOMPATIBLE_WITH_ITEM_HEADER"
                }
                Self::PriceAssetDescriptionHasPriceQualifier => {
                    "PRICE_ASSET_DESCRIPTION_HAS_PRICE_QUALIFIER"
                }
                Self::PriceAssetUnsupportedLanguage => "PRICE_ASSET_UNSUPPORTED_LANGUAGE",
                Self::PriceAssetOtherError => "PRICE_ASSET_OTHER_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PRICE_ASSET_DESCRIPTION_REPEATS_ROW_HEADER" => {
                    Some(Self::PriceAssetDescriptionRepeatsRowHeader)
                }
                "PRICE_ASSET_REPETITIVE_HEADERS" => {
                    Some(Self::PriceAssetRepetitiveHeaders)
                }
                "PRICE_ASSET_HEADER_INCOMPATIBLE_WITH_PRICE_TYPE" => {
                    Some(Self::PriceAssetHeaderIncompatibleWithPriceType)
                }
                "PRICE_ASSET_DESCRIPTION_INCOMPATIBLE_WITH_ITEM_HEADER" => {
                    Some(Self::PriceAssetDescriptionIncompatibleWithItemHeader)
                }
                "PRICE_ASSET_DESCRIPTION_HAS_PRICE_QUALIFIER" => {
                    Some(Self::PriceAssetDescriptionHasPriceQualifier)
                }
                "PRICE_ASSET_UNSUPPORTED_LANGUAGE" => {
                    Some(Self::PriceAssetUnsupportedLanguage)
                }
                "PRICE_ASSET_OTHER_ERROR" => Some(Self::PriceAssetOtherError),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible policy approval statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyApprovalStatusEnum {}
/// Nested message and enum types in `PolicyApprovalStatusEnum`.
pub mod policy_approval_status_enum {
    /// The possible policy approval statuses. When there are several approval
    /// statuses available the most severe one will be used. The order of severity
    /// is DISAPPROVED, AREA_OF_INTEREST_ONLY, APPROVED_LIMITED and APPROVED.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyApprovalStatus {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// Will not serve.
        Disapproved = 2,
        /// Serves with restrictions.
        ApprovedLimited = 3,
        /// Serves without restrictions.
        Approved = 4,
        /// Will not serve in targeted countries, but may serve for users who are
        /// searching for information about the targeted countries.
        AreaOfInterestOnly = 5,
    }
    impl PolicyApprovalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Disapproved => "DISAPPROVED",
                Self::ApprovedLimited => "APPROVED_LIMITED",
                Self::Approved => "APPROVED",
                Self::AreaOfInterestOnly => "AREA_OF_INTEREST_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DISAPPROVED" => Some(Self::Disapproved),
                "APPROVED_LIMITED" => Some(Self::ApprovedLimited),
                "APPROVED" => Some(Self::Approved),
                "AREA_OF_INTEREST_ONLY" => Some(Self::AreaOfInterestOnly),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible policy review statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyReviewStatusEnum {}
/// Nested message and enum types in `PolicyReviewStatusEnum`.
pub mod policy_review_status_enum {
    /// The possible policy review statuses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyReviewStatus {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// Currently under review.
        ReviewInProgress = 2,
        /// Primary review complete. Other reviews may be continuing.
        Reviewed = 3,
        /// The resource has been resubmitted for approval or its policy decision has
        /// been appealed.
        UnderAppeal = 4,
        /// The resource is eligible and may be serving but could still undergo
        /// further review.
        EligibleMayServe = 5,
    }
    impl PolicyReviewStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ReviewInProgress => "REVIEW_IN_PROGRESS",
                Self::Reviewed => "REVIEWED",
                Self::UnderAppeal => "UNDER_APPEAL",
                Self::EligibleMayServe => "ELIGIBLE_MAY_SERVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "REVIEW_IN_PROGRESS" => Some(Self::ReviewInProgress),
                "REVIEWED" => Some(Self::Reviewed),
                "UNDER_APPEAL" => Some(Self::UnderAppeal),
                "ELIGIBLE_MAY_SERVE" => Some(Self::EligibleMayServe),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the performance label of an asset.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetPerformanceLabelEnum {}
/// Nested message and enum types in `AssetPerformanceLabelEnum`.
pub mod asset_performance_label_enum {
    /// Enum describing the possible performance labels of an asset, usually
    /// computed in the context of a linkage.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetPerformanceLabel {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// This asset does not yet have any performance informantion. This may be
        /// because it is still under review.
        Pending = 2,
        /// The asset has started getting impressions but the stats are not
        /// statistically significant enough to get an asset performance label.
        Learning = 3,
        /// Worst performing assets.
        Low = 4,
        /// Good performing assets.
        Good = 5,
        /// Best performing assets.
        Best = 6,
    }
    impl AssetPerformanceLabel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Pending => "PENDING",
                Self::Learning => "LEARNING",
                Self::Low => "LOW",
                Self::Good => "GOOD",
                Self::Best => "BEST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "LEARNING" => Some(Self::Learning),
                "LOW" => Some(Self::Low),
                "GOOD" => Some(Self::Good),
                "BEST" => Some(Self::Best),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible asset field types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServedAssetFieldTypeEnum {}
/// Nested message and enum types in `ServedAssetFieldTypeEnum`.
pub mod served_asset_field_type_enum {
    /// The possible asset field types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ServedAssetFieldType {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// The asset is used in headline 1.
        Headline1 = 2,
        /// The asset is used in headline 2.
        Headline2 = 3,
        /// The asset is used in headline 3.
        Headline3 = 4,
        /// The asset is used in description 1.
        Description1 = 5,
        /// The asset is used in description 2.
        Description2 = 6,
        /// The asset was used in a headline. Use this only if there is only one
        /// headline in the ad. Otherwise, use the HEADLINE_1, HEADLINE_2 or
        /// HEADLINE_3 enums
        Headline = 7,
        /// The asset was used as a headline in portrait image.
        HeadlineInPortrait = 8,
        /// The asset was used in a long headline (used in MultiAssetResponsiveAd).
        LongHeadline = 9,
        /// The asset was used in a description. Use this only if there is only one
        /// description in the ad. Otherwise, use the DESCRIPTION_1 or DESCRIPTION_@
        /// enums
        Description = 10,
        /// The asset was used as description in portrait image.
        DescriptionInPortrait = 11,
        /// The asset was used as business name in portrait image.
        BusinessNameInPortrait = 12,
        /// The asset was used as business name.
        BusinessName = 13,
        /// The asset was used as a marketing image.
        MarketingImage = 14,
        /// The asset was used as a marketing image in portrait image.
        MarketingImageInPortrait = 15,
        /// The asset was used as a square marketing image.
        SquareMarketingImage = 16,
        /// The asset was used as a portrait marketing image.
        PortraitMarketingImage = 17,
        /// The asset was used as a logo.
        Logo = 18,
        /// The asset was used as a landscape logo.
        LandscapeLogo = 19,
        /// The asset was used as a call-to-action.
        CallToAction = 20,
        /// The asset was used as a YouTube video.
        YouTubeVideo = 21,
        /// This asset is used as a sitelink.
        Sitelink = 22,
        /// This asset is used as a call.
        Call = 23,
        /// This asset is used as a mobile app.
        MobileApp = 24,
        /// This asset is used as a callout.
        Callout = 25,
        /// This asset is used as a structured snippet.
        StructuredSnippet = 26,
        /// This asset is used as a price.
        Price = 27,
        /// This asset is used as a promotion.
        Promotion = 28,
        /// This asset is used as an image.
        AdImage = 29,
        /// The asset is used as a lead form.
        LeadForm = 30,
        /// The asset is used as a business logo.
        BusinessLogo = 31,
    }
    impl ServedAssetFieldType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Headline1 => "HEADLINE_1",
                Self::Headline2 => "HEADLINE_2",
                Self::Headline3 => "HEADLINE_3",
                Self::Description1 => "DESCRIPTION_1",
                Self::Description2 => "DESCRIPTION_2",
                Self::Headline => "HEADLINE",
                Self::HeadlineInPortrait => "HEADLINE_IN_PORTRAIT",
                Self::LongHeadline => "LONG_HEADLINE",
                Self::Description => "DESCRIPTION",
                Self::DescriptionInPortrait => "DESCRIPTION_IN_PORTRAIT",
                Self::BusinessNameInPortrait => "BUSINESS_NAME_IN_PORTRAIT",
                Self::BusinessName => "BUSINESS_NAME",
                Self::MarketingImage => "MARKETING_IMAGE",
                Self::MarketingImageInPortrait => "MARKETING_IMAGE_IN_PORTRAIT",
                Self::SquareMarketingImage => "SQUARE_MARKETING_IMAGE",
                Self::PortraitMarketingImage => "PORTRAIT_MARKETING_IMAGE",
                Self::Logo => "LOGO",
                Self::LandscapeLogo => "LANDSCAPE_LOGO",
                Self::CallToAction => "CALL_TO_ACTION",
                Self::YouTubeVideo => "YOU_TUBE_VIDEO",
                Self::Sitelink => "SITELINK",
                Self::Call => "CALL",
                Self::MobileApp => "MOBILE_APP",
                Self::Callout => "CALLOUT",
                Self::StructuredSnippet => "STRUCTURED_SNIPPET",
                Self::Price => "PRICE",
                Self::Promotion => "PROMOTION",
                Self::AdImage => "AD_IMAGE",
                Self::LeadForm => "LEAD_FORM",
                Self::BusinessLogo => "BUSINESS_LOGO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "HEADLINE_1" => Some(Self::Headline1),
                "HEADLINE_2" => Some(Self::Headline2),
                "HEADLINE_3" => Some(Self::Headline3),
                "DESCRIPTION_1" => Some(Self::Description1),
                "DESCRIPTION_2" => Some(Self::Description2),
                "HEADLINE" => Some(Self::Headline),
                "HEADLINE_IN_PORTRAIT" => Some(Self::HeadlineInPortrait),
                "LONG_HEADLINE" => Some(Self::LongHeadline),
                "DESCRIPTION" => Some(Self::Description),
                "DESCRIPTION_IN_PORTRAIT" => Some(Self::DescriptionInPortrait),
                "BUSINESS_NAME_IN_PORTRAIT" => Some(Self::BusinessNameInPortrait),
                "BUSINESS_NAME" => Some(Self::BusinessName),
                "MARKETING_IMAGE" => Some(Self::MarketingImage),
                "MARKETING_IMAGE_IN_PORTRAIT" => Some(Self::MarketingImageInPortrait),
                "SQUARE_MARKETING_IMAGE" => Some(Self::SquareMarketingImage),
                "PORTRAIT_MARKETING_IMAGE" => Some(Self::PortraitMarketingImage),
                "LOGO" => Some(Self::Logo),
                "LANDSCAPE_LOGO" => Some(Self::LandscapeLogo),
                "CALL_TO_ACTION" => Some(Self::CallToAction),
                "YOU_TUBE_VIDEO" => Some(Self::YouTubeVideo),
                "SITELINK" => Some(Self::Sitelink),
                "CALL" => Some(Self::Call),
                "MOBILE_APP" => Some(Self::MobileApp),
                "CALLOUT" => Some(Self::Callout),
                "STRUCTURED_SNIPPET" => Some(Self::StructuredSnippet),
                "PRICE" => Some(Self::Price),
                "PROMOTION" => Some(Self::Promotion),
                "AD_IMAGE" => Some(Self::AdImage),
                "LEAD_FORM" => Some(Self::LeadForm),
                "BUSINESS_LOGO" => Some(Self::BusinessLogo),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible data types for call conversion
/// reporting state.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CallConversionReportingStateEnum {}
/// Nested message and enum types in `CallConversionReportingStateEnum`.
pub mod call_conversion_reporting_state_enum {
    /// Possible data types for a call conversion action state.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallConversionReportingState {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Call conversion action is disabled.
        Disabled = 2,
        /// Call conversion action will use call conversion type set at the
        /// account level.
        UseAccountLevelCallConversionAction = 3,
        /// Call conversion action will use call conversion type set at the resource
        /// (call only ads/call extensions) level.
        UseResourceLevelCallConversionAction = 4,
    }
    impl CallConversionReportingState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Disabled => "DISABLED",
                Self::UseAccountLevelCallConversionAction => {
                    "USE_ACCOUNT_LEVEL_CALL_CONVERSION_ACTION"
                }
                Self::UseResourceLevelCallConversionAction => {
                    "USE_RESOURCE_LEVEL_CALL_CONVERSION_ACTION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DISABLED" => Some(Self::Disabled),
                "USE_ACCOUNT_LEVEL_CALL_CONVERSION_ACTION" => {
                    Some(Self::UseAccountLevelCallConversionAction)
                }
                "USE_RESOURCE_LEVEL_CALL_CONVERSION_ACTION" => {
                    Some(Self::UseResourceLevelCallConversionAction)
                }
                _ => None,
            }
        }
    }
}
/// Container for display ad format settings.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisplayAdFormatSettingEnum {}
/// Nested message and enum types in `DisplayAdFormatSettingEnum`.
pub mod display_ad_format_setting_enum {
    /// Enumerates display ad format settings.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DisplayAdFormatSetting {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Text, image and native formats.
        AllFormats = 2,
        /// Text and image formats.
        NonNative = 3,
        /// Native format, for example, the format rendering is controlled by the
        /// publisher and not by Google.
        Native = 4,
    }
    impl DisplayAdFormatSetting {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AllFormats => "ALL_FORMATS",
                Self::NonNative => "NON_NATIVE",
                Self::Native => "NATIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ALL_FORMATS" => Some(Self::AllFormats),
                "NON_NATIVE" => Some(Self::NonNative),
                "NATIVE" => Some(Self::Native),
                _ => None,
            }
        }
    }
}
/// Container for display upload product types. Product types that have the word
/// "DYNAMIC" in them must be associated with a campaign that has a dynamic
/// remarketing feed. See <https://support.google.com/google-ads/answer/6053288>
/// for more info about dynamic remarketing. Other product types are regarded
/// as "static" and do not have this requirement.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisplayUploadProductTypeEnum {}
/// Nested message and enum types in `DisplayUploadProductTypeEnum`.
pub mod display_upload_product_type_enum {
    /// Enumerates display upload product types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DisplayUploadProductType {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// HTML5 upload ad. This product type requires the upload_media_bundle
        /// field in DisplayUploadAdInfo to be set.
        Html5UploadAd = 2,
        /// Dynamic HTML5 education ad. This product type requires the
        /// upload_media_bundle field in DisplayUploadAdInfo to be set. Can only be
        /// used in an education campaign.
        DynamicHtml5EducationAd = 3,
        /// Dynamic HTML5 flight ad. This product type requires the
        /// upload_media_bundle field in DisplayUploadAdInfo to be set. Can only be
        /// used in a flight campaign.
        DynamicHtml5FlightAd = 4,
        /// Dynamic HTML5 hotel and rental ad. This product type requires the
        /// upload_media_bundle field in DisplayUploadAdInfo to be set. Can only be
        /// used in a hotel campaign.
        DynamicHtml5HotelRentalAd = 5,
        /// Dynamic HTML5 job ad. This product type requires the
        /// upload_media_bundle field in DisplayUploadAdInfo to be set. Can only be
        /// used in a job campaign.
        DynamicHtml5JobAd = 6,
        /// Dynamic HTML5 local ad. This product type requires the
        /// upload_media_bundle field in DisplayUploadAdInfo to be set. Can only be
        /// used in a local campaign.
        DynamicHtml5LocalAd = 7,
        /// Dynamic HTML5 real estate ad. This product type requires the
        /// upload_media_bundle field in DisplayUploadAdInfo to be set. Can only be
        /// used in a real estate campaign.
        DynamicHtml5RealEstateAd = 8,
        /// Dynamic HTML5 custom ad. This product type requires the
        /// upload_media_bundle field in DisplayUploadAdInfo to be set. Can only be
        /// used in a custom campaign.
        DynamicHtml5CustomAd = 9,
        /// Dynamic HTML5 travel ad. This product type requires the
        /// upload_media_bundle field in DisplayUploadAdInfo to be set. Can only be
        /// used in a travel campaign.
        DynamicHtml5TravelAd = 10,
        /// Dynamic HTML5 hotel ad. This product type requires the
        /// upload_media_bundle field in DisplayUploadAdInfo to be set. Can only be
        /// used in a hotel campaign.
        DynamicHtml5HotelAd = 11,
    }
    impl DisplayUploadProductType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Html5UploadAd => "HTML5_UPLOAD_AD",
                Self::DynamicHtml5EducationAd => "DYNAMIC_HTML5_EDUCATION_AD",
                Self::DynamicHtml5FlightAd => "DYNAMIC_HTML5_FLIGHT_AD",
                Self::DynamicHtml5HotelRentalAd => "DYNAMIC_HTML5_HOTEL_RENTAL_AD",
                Self::DynamicHtml5JobAd => "DYNAMIC_HTML5_JOB_AD",
                Self::DynamicHtml5LocalAd => "DYNAMIC_HTML5_LOCAL_AD",
                Self::DynamicHtml5RealEstateAd => "DYNAMIC_HTML5_REAL_ESTATE_AD",
                Self::DynamicHtml5CustomAd => "DYNAMIC_HTML5_CUSTOM_AD",
                Self::DynamicHtml5TravelAd => "DYNAMIC_HTML5_TRAVEL_AD",
                Self::DynamicHtml5HotelAd => "DYNAMIC_HTML5_HOTEL_AD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "HTML5_UPLOAD_AD" => Some(Self::Html5UploadAd),
                "DYNAMIC_HTML5_EDUCATION_AD" => Some(Self::DynamicHtml5EducationAd),
                "DYNAMIC_HTML5_FLIGHT_AD" => Some(Self::DynamicHtml5FlightAd),
                "DYNAMIC_HTML5_HOTEL_RENTAL_AD" => Some(Self::DynamicHtml5HotelRentalAd),
                "DYNAMIC_HTML5_JOB_AD" => Some(Self::DynamicHtml5JobAd),
                "DYNAMIC_HTML5_LOCAL_AD" => Some(Self::DynamicHtml5LocalAd),
                "DYNAMIC_HTML5_REAL_ESTATE_AD" => Some(Self::DynamicHtml5RealEstateAd),
                "DYNAMIC_HTML5_CUSTOM_AD" => Some(Self::DynamicHtml5CustomAd),
                "DYNAMIC_HTML5_TRAVEL_AD" => Some(Self::DynamicHtml5TravelAd),
                "DYNAMIC_HTML5_HOTEL_AD" => Some(Self::DynamicHtml5HotelAd),
                _ => None,
            }
        }
    }
}
/// Container for enum describing app store type in a legacy app install ad.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LegacyAppInstallAdAppStoreEnum {}
/// Nested message and enum types in `LegacyAppInstallAdAppStoreEnum`.
pub mod legacy_app_install_ad_app_store_enum {
    /// App store type in a legacy app install ad.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LegacyAppInstallAdAppStore {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Apple iTunes.
        AppleAppStore = 2,
        /// Google Play.
        GooglePlay = 3,
        /// Windows Store.
        WindowsStore = 4,
        /// Windows Phone Store.
        WindowsPhoneStore = 5,
        /// The app is hosted in a Chinese app store.
        CnAppStore = 6,
    }
    impl LegacyAppInstallAdAppStore {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AppleAppStore => "APPLE_APP_STORE",
                Self::GooglePlay => "GOOGLE_PLAY",
                Self::WindowsStore => "WINDOWS_STORE",
                Self::WindowsPhoneStore => "WINDOWS_PHONE_STORE",
                Self::CnAppStore => "CN_APP_STORE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APPLE_APP_STORE" => Some(Self::AppleAppStore),
                "GOOGLE_PLAY" => Some(Self::GooglePlay),
                "WINDOWS_STORE" => Some(Self::WindowsStore),
                "WINDOWS_PHONE_STORE" => Some(Self::WindowsPhoneStore),
                "CN_APP_STORE" => Some(Self::CnAppStore),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the mime types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MimeTypeEnum {}
/// Nested message and enum types in `MimeTypeEnum`.
pub mod mime_type_enum {
    /// The mime type
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MimeType {
        /// The mime type has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// MIME type of image/jpeg.
        ImageJpeg = 2,
        /// MIME type of image/gif.
        ImageGif = 3,
        /// MIME type of image/png.
        ImagePng = 4,
        /// MIME type of application/x-shockwave-flash.
        Flash = 5,
        /// MIME type of text/html.
        TextHtml = 6,
        /// MIME type of application/pdf.
        Pdf = 7,
        /// MIME type of application/msword.
        Msword = 8,
        /// MIME type of application/vnd.ms-excel.
        Msexcel = 9,
        /// MIME type of application/rtf.
        Rtf = 10,
        /// MIME type of audio/wav.
        AudioWav = 11,
        /// MIME type of audio/mp3.
        AudioMp3 = 12,
        /// MIME type of application/x-html5-ad-zip.
        Html5AdZip = 13,
    }
    impl MimeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ImageJpeg => "IMAGE_JPEG",
                Self::ImageGif => "IMAGE_GIF",
                Self::ImagePng => "IMAGE_PNG",
                Self::Flash => "FLASH",
                Self::TextHtml => "TEXT_HTML",
                Self::Pdf => "PDF",
                Self::Msword => "MSWORD",
                Self::Msexcel => "MSEXCEL",
                Self::Rtf => "RTF",
                Self::AudioWav => "AUDIO_WAV",
                Self::AudioMp3 => "AUDIO_MP3",
                Self::Html5AdZip => "HTML5_AD_ZIP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "IMAGE_JPEG" => Some(Self::ImageJpeg),
                "IMAGE_GIF" => Some(Self::ImageGif),
                "IMAGE_PNG" => Some(Self::ImagePng),
                "FLASH" => Some(Self::Flash),
                "TEXT_HTML" => Some(Self::TextHtml),
                "PDF" => Some(Self::Pdf),
                "MSWORD" => Some(Self::Msword),
                "MSEXCEL" => Some(Self::Msexcel),
                "RTF" => Some(Self::Rtf),
                "AUDIO_WAV" => Some(Self::AudioWav),
                "AUDIO_MP3" => Some(Self::AudioMp3),
                "HTML5_AD_ZIP" => Some(Self::Html5AdZip),
                _ => None,
            }
        }
    }
}
/// Defines the thumbnail to use for In-Display video ads. Note that
/// DEFAULT_THUMBNAIL may have been uploaded by the user while thumbnails 1-3 are
/// auto-generated from the video.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VideoThumbnailEnum {}
/// Nested message and enum types in `VideoThumbnailEnum`.
pub mod video_thumbnail_enum {
    /// Enum listing the possible types of a video thumbnail.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VideoThumbnail {
        /// The type has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        /// This is a response-only value.
        Unknown = 1,
        /// The default thumbnail. Can be auto-generated or user-uploaded.
        DefaultThumbnail = 2,
        /// Thumbnail 1, generated from the video.
        Thumbnail1 = 3,
        /// Thumbnail 2, generated from the video.
        Thumbnail2 = 4,
        /// Thumbnail 3, generated from the video.
        Thumbnail3 = 5,
    }
    impl VideoThumbnail {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DefaultThumbnail => "DEFAULT_THUMBNAIL",
                Self::Thumbnail1 => "THUMBNAIL_1",
                Self::Thumbnail2 => "THUMBNAIL_2",
                Self::Thumbnail3 => "THUMBNAIL_3",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DEFAULT_THUMBNAIL" => Some(Self::DefaultThumbnail),
                "THUMBNAIL_1" => Some(Self::Thumbnail1),
                "THUMBNAIL_2" => Some(Self::Thumbnail2),
                "THUMBNAIL_3" => Some(Self::Thumbnail3),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible types of a relationship.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChainRelationshipTypeEnum {}
/// Nested message and enum types in `ChainRelationshipTypeEnum`.
pub mod chain_relationship_type_enum {
    /// Possible types of a relationship.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChainRelationshipType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Auto dealer relationship.
        AutoDealers = 2,
        /// General retailer relationship.
        GeneralRetailers = 3,
    }
    impl ChainRelationshipType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AutoDealers => "AUTO_DEALERS",
                Self::GeneralRetailers => "GENERAL_RETAILERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AUTO_DEALERS" => Some(Self::AutoDealers),
                "GENERAL_RETAILERS" => Some(Self::GeneralRetailers),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible types of a location ownership.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationOwnershipTypeEnum {}
/// Nested message and enum types in `LocationOwnershipTypeEnum`.
pub mod location_ownership_type_enum {
    /// Possible types of a location ownership.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationOwnershipType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Business Owner of location(legacy location extension - LE).
        BusinessOwner = 2,
        /// Affiliate location(Third party location extension - ALE).
        Affiliate = 3,
    }
    impl LocationOwnershipType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::BusinessOwner => "BUSINESS_OWNER",
                Self::Affiliate => "AFFILIATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_OWNER" => Some(Self::BusinessOwner),
                "AFFILIATE" => Some(Self::Affiliate),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible types of a location string filter.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationStringFilterTypeEnum {}
/// Nested message and enum types in `LocationStringFilterTypeEnum`.
pub mod location_string_filter_type_enum {
    /// Possible types of a location string filter.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationStringFilterType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The filter will use exact string matching.
        Exact = 2,
    }
    impl LocationStringFilterType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Exact => "EXACT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXACT" => Some(Self::Exact),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of demographic age ranges.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AgeRangeTypeEnum {}
/// Nested message and enum types in `AgeRangeTypeEnum`.
pub mod age_range_type_enum {
    /// The type of demographic age ranges (for example, between 18 and 24 years
    /// old).
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AgeRangeType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Between 18 and 24 years old.
        AgeRange1824 = 503001,
        /// Between 25 and 34 years old.
        AgeRange2534 = 503002,
        /// Between 35 and 44 years old.
        AgeRange3544 = 503003,
        /// Between 45 and 54 years old.
        AgeRange4554 = 503004,
        /// Between 55 and 64 years old.
        AgeRange5564 = 503005,
        /// 65 years old and beyond.
        AgeRange65Up = 503006,
        /// Undetermined age range.
        AgeRangeUndetermined = 503999,
    }
    impl AgeRangeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AgeRange1824 => "AGE_RANGE_18_24",
                Self::AgeRange2534 => "AGE_RANGE_25_34",
                Self::AgeRange3544 => "AGE_RANGE_35_44",
                Self::AgeRange4554 => "AGE_RANGE_45_54",
                Self::AgeRange5564 => "AGE_RANGE_55_64",
                Self::AgeRange65Up => "AGE_RANGE_65_UP",
                Self::AgeRangeUndetermined => "AGE_RANGE_UNDETERMINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AGE_RANGE_18_24" => Some(Self::AgeRange1824),
                "AGE_RANGE_25_34" => Some(Self::AgeRange2534),
                "AGE_RANGE_35_44" => Some(Self::AgeRange3544),
                "AGE_RANGE_45_54" => Some(Self::AgeRange4554),
                "AGE_RANGE_55_64" => Some(Self::AgeRange5564),
                "AGE_RANGE_65_UP" => Some(Self::AgeRange65Up),
                "AGE_RANGE_UNDETERMINED" => Some(Self::AgeRangeUndetermined),
                _ => None,
            }
        }
    }
}
/// Represents a criterion for targeting paid apps.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppPaymentModelTypeEnum {}
/// Nested message and enum types in `AppPaymentModelTypeEnum`.
pub mod app_payment_model_type_enum {
    /// Enum describing possible app payment models.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AppPaymentModelType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Represents paid-for apps.
        Paid = 30,
    }
    impl AppPaymentModelType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Paid => "PAID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PAID" => Some(Self::Paid),
                _ => None,
            }
        }
    }
}
/// Container for enum describing rejection reasons for the customer brand
/// requests.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrandRequestRejectionReasonEnum {}
/// Nested message and enum types in `BrandRequestRejectionReasonEnum`.
pub mod brand_request_rejection_reason_enum {
    /// Enumeration of different brand request rejection reasons.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BrandRequestRejectionReason {
        /// No value has been specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Brand is already present in the commercial brand set.
        ExistingBrand = 2,
        /// Brand is already present in the commercial brand set, but is a variant.
        ExistingBrandVariant = 3,
        /// Brand information is not correct (eg: URL and name don't match).
        IncorrectInformation = 4,
        /// Not a valid brand as per Google policy.
        NotABrand = 5,
    }
    impl BrandRequestRejectionReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ExistingBrand => "EXISTING_BRAND",
                Self::ExistingBrandVariant => "EXISTING_BRAND_VARIANT",
                Self::IncorrectInformation => "INCORRECT_INFORMATION",
                Self::NotABrand => "NOT_A_BRAND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXISTING_BRAND" => Some(Self::ExistingBrand),
                "EXISTING_BRAND_VARIANT" => Some(Self::ExistingBrandVariant),
                "INCORRECT_INFORMATION" => Some(Self::IncorrectInformation),
                "NOT_A_BRAND" => Some(Self::NotABrand),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible brand states.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrandStateEnum {}
/// Nested message and enum types in `BrandStateEnum`.
pub mod brand_state_enum {
    /// Enumeration of different brand states.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BrandState {
        /// No value has been specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Brand is verified and globally available for selection
        Enabled = 2,
        /// Brand was globally available in past but is no longer a valid brand
        /// (based on business criteria)
        Deprecated = 3,
        /// Brand is unverified and customer scoped, but can be selected by customer
        /// (only who requested for same) for targeting
        Unverified = 4,
        /// Was a customer-scoped (unverified) brand, which got approved by business
        /// and added to the global list. Its assigned CKG MID should be used instead
        /// of this
        Approved = 5,
        /// Was a customer-scoped (unverified) brand, but the request was canceled by
        /// customer and this brand id is no longer valid
        Cancelled = 6,
        /// Was a customer-scoped (unverified) brand, but the request was rejected by
        /// internal business team and this brand id is no longer valid
        Rejected = 7,
    }
    impl BrandState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Deprecated => "DEPRECATED",
                Self::Unverified => "UNVERIFIED",
                Self::Approved => "APPROVED",
                Self::Cancelled => "CANCELLED",
                Self::Rejected => "REJECTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "DEPRECATED" => Some(Self::Deprecated),
                "UNVERIFIED" => Some(Self::Unverified),
                "APPROVED" => Some(Self::Approved),
                "CANCELLED" => Some(Self::Cancelled),
                "REJECTED" => Some(Self::Rejected),
                _ => None,
            }
        }
    }
}
/// Container for enum describing content label types in ContentLabel.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ContentLabelTypeEnum {}
/// Nested message and enum types in `ContentLabelTypeEnum`.
pub mod content_label_type_enum {
    /// Enum listing the content label types supported by ContentLabel criterion.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContentLabelType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Sexually suggestive content.
        SexuallySuggestive = 2,
        /// Below the fold placement.
        BelowTheFold = 3,
        /// Parked domain.
        ParkedDomain = 4,
        /// Juvenile, gross & bizarre content.
        Juvenile = 6,
        /// Profanity & rough language.
        Profanity = 7,
        /// Death & tragedy.
        Tragedy = 8,
        /// Video.
        Video = 9,
        /// Content rating: G.
        VideoRatingDvG = 10,
        /// Content rating: PG.
        VideoRatingDvPg = 11,
        /// Content rating: T.
        VideoRatingDvT = 12,
        /// Content rating: MA.
        VideoRatingDvMa = 13,
        /// Content rating: not yet rated.
        VideoNotYetRated = 14,
        /// Embedded video.
        EmbeddedVideo = 15,
        /// Live streaming video.
        LiveStreamingVideo = 16,
        /// Sensitive social issues.
        SocialIssues = 17,
    }
    impl ContentLabelType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::SexuallySuggestive => "SEXUALLY_SUGGESTIVE",
                Self::BelowTheFold => "BELOW_THE_FOLD",
                Self::ParkedDomain => "PARKED_DOMAIN",
                Self::Juvenile => "JUVENILE",
                Self::Profanity => "PROFANITY",
                Self::Tragedy => "TRAGEDY",
                Self::Video => "VIDEO",
                Self::VideoRatingDvG => "VIDEO_RATING_DV_G",
                Self::VideoRatingDvPg => "VIDEO_RATING_DV_PG",
                Self::VideoRatingDvT => "VIDEO_RATING_DV_T",
                Self::VideoRatingDvMa => "VIDEO_RATING_DV_MA",
                Self::VideoNotYetRated => "VIDEO_NOT_YET_RATED",
                Self::EmbeddedVideo => "EMBEDDED_VIDEO",
                Self::LiveStreamingVideo => "LIVE_STREAMING_VIDEO",
                Self::SocialIssues => "SOCIAL_ISSUES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEXUALLY_SUGGESTIVE" => Some(Self::SexuallySuggestive),
                "BELOW_THE_FOLD" => Some(Self::BelowTheFold),
                "PARKED_DOMAIN" => Some(Self::ParkedDomain),
                "JUVENILE" => Some(Self::Juvenile),
                "PROFANITY" => Some(Self::Profanity),
                "TRAGEDY" => Some(Self::Tragedy),
                "VIDEO" => Some(Self::Video),
                "VIDEO_RATING_DV_G" => Some(Self::VideoRatingDvG),
                "VIDEO_RATING_DV_PG" => Some(Self::VideoRatingDvPg),
                "VIDEO_RATING_DV_T" => Some(Self::VideoRatingDvT),
                "VIDEO_RATING_DV_MA" => Some(Self::VideoRatingDvMa),
                "VIDEO_NOT_YET_RATED" => Some(Self::VideoNotYetRated),
                "EMBEDDED_VIDEO" => Some(Self::EmbeddedVideo),
                "LIVE_STREAMING_VIDEO" => Some(Self::LiveStreamingVideo),
                "SOCIAL_ISSUES" => Some(Self::SocialIssues),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of days of the week, for example, "Monday".
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DayOfWeekEnum {}
/// Nested message and enum types in `DayOfWeekEnum`.
pub mod day_of_week_enum {
    /// Enumerates days of the week, for example, "Monday".
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DayOfWeek {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Monday.
        Monday = 2,
        /// Tuesday.
        Tuesday = 3,
        /// Wednesday.
        Wednesday = 4,
        /// Thursday.
        Thursday = 5,
        /// Friday.
        Friday = 6,
        /// Saturday.
        Saturday = 7,
        /// Sunday.
        Sunday = 8,
    }
    impl DayOfWeek {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Monday => "MONDAY",
                Self::Tuesday => "TUESDAY",
                Self::Wednesday => "WEDNESDAY",
                Self::Thursday => "THURSDAY",
                Self::Friday => "FRIDAY",
                Self::Saturday => "SATURDAY",
                Self::Sunday => "SUNDAY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MONDAY" => Some(Self::Monday),
                "TUESDAY" => Some(Self::Tuesday),
                "WEDNESDAY" => Some(Self::Wednesday),
                "THURSDAY" => Some(Self::Thursday),
                "FRIDAY" => Some(Self::Friday),
                "SATURDAY" => Some(Self::Saturday),
                "SUNDAY" => Some(Self::Sunday),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of Google Ads devices available for targeting.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeviceEnum {}
/// Nested message and enum types in `DeviceEnum`.
pub mod device_enum {
    /// Enumerates Google Ads devices available for targeting.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Device {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Mobile devices with full browsers.
        Mobile = 2,
        /// Tablets with full browsers.
        Tablet = 3,
        /// Computers.
        Desktop = 4,
        /// Smart TVs and game consoles.
        ConnectedTv = 6,
        /// Other device types.
        Other = 5,
    }
    impl Device {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Mobile => "MOBILE",
                Self::Tablet => "TABLET",
                Self::Desktop => "DESKTOP",
                Self::ConnectedTv => "CONNECTED_TV",
                Self::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MOBILE" => Some(Self::Mobile),
                "TABLET" => Some(Self::Tablet),
                "DESKTOP" => Some(Self::Desktop),
                "CONNECTED_TV" => Some(Self::ConnectedTv),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of demographic genders.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GenderTypeEnum {}
/// Nested message and enum types in `GenderTypeEnum`.
pub mod gender_type_enum {
    /// The type of demographic genders (for example, female).
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GenderType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Male.
        Male = 10,
        /// Female.
        Female = 11,
        /// Undetermined gender.
        Undetermined = 20,
    }
    impl GenderType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Male => "MALE",
                Self::Female => "FEMALE",
                Self::Undetermined => "UNDETERMINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MALE" => Some(Self::Male),
                "FEMALE" => Some(Self::Female),
                "UNDETERMINED" => Some(Self::Undetermined),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible hotel date selection types
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HotelDateSelectionTypeEnum {}
/// Nested message and enum types in `HotelDateSelectionTypeEnum`.
pub mod hotel_date_selection_type_enum {
    /// Enum describing possible hotel date selection types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HotelDateSelectionType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Dates selected by default.
        DefaultSelection = 50,
        /// Dates selected by the user.
        UserSelected = 51,
    }
    impl HotelDateSelectionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DefaultSelection => "DEFAULT_SELECTION",
                Self::UserSelected => "USER_SELECTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DEFAULT_SELECTION" => Some(Self::DefaultSelection),
                "USER_SELECTED" => Some(Self::UserSelected),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of demographic income ranges.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IncomeRangeTypeEnum {}
/// Nested message and enum types in `IncomeRangeTypeEnum`.
pub mod income_range_type_enum {
    /// The type of demographic income ranges (for example, between 0% to 50%).
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IncomeRangeType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// 0%-50%.
        IncomeRange050 = 510001,
        /// 50% to 60%.
        IncomeRange5060 = 510002,
        /// 60% to 70%.
        IncomeRange6070 = 510003,
        /// 70% to 80%.
        IncomeRange7080 = 510004,
        /// 80% to 90%.
        IncomeRange8090 = 510005,
        /// Greater than 90%.
        IncomeRange90Up = 510006,
        /// Undetermined income range.
        IncomeRangeUndetermined = 510000,
    }
    impl IncomeRangeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::IncomeRange050 => "INCOME_RANGE_0_50",
                Self::IncomeRange5060 => "INCOME_RANGE_50_60",
                Self::IncomeRange6070 => "INCOME_RANGE_60_70",
                Self::IncomeRange7080 => "INCOME_RANGE_70_80",
                Self::IncomeRange8090 => "INCOME_RANGE_80_90",
                Self::IncomeRange90Up => "INCOME_RANGE_90_UP",
                Self::IncomeRangeUndetermined => "INCOME_RANGE_UNDETERMINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INCOME_RANGE_0_50" => Some(Self::IncomeRange050),
                "INCOME_RANGE_50_60" => Some(Self::IncomeRange5060),
                "INCOME_RANGE_60_70" => Some(Self::IncomeRange6070),
                "INCOME_RANGE_70_80" => Some(Self::IncomeRange7080),
                "INCOME_RANGE_80_90" => Some(Self::IncomeRange8090),
                "INCOME_RANGE_90_UP" => Some(Self::IncomeRange90Up),
                "INCOME_RANGE_UNDETERMINED" => Some(Self::IncomeRangeUndetermined),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible interaction types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InteractionTypeEnum {}
/// Nested message and enum types in `InteractionTypeEnum`.
pub mod interaction_type_enum {
    /// Enum describing possible interaction types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InteractionType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Calls.
        Calls = 8000,
    }
    impl InteractionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Calls => "CALLS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CALLS" => Some(Self::Calls),
                _ => None,
            }
        }
    }
}
/// Message describing Keyword match types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordMatchTypeEnum {}
/// Nested message and enum types in `KeywordMatchTypeEnum`.
pub mod keyword_match_type_enum {
    /// Possible Keyword match types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordMatchType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Exact match.
        Exact = 2,
        /// Phrase match.
        Phrase = 3,
        /// Broad match.
        Broad = 4,
    }
    impl KeywordMatchType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Exact => "EXACT",
                Self::Phrase => "PHRASE",
                Self::Broad => "BROAD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXACT" => Some(Self::Exact),
                "PHRASE" => Some(Self::Phrase),
                "BROAD" => Some(Self::Broad),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of the listing group.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupTypeEnum {}
/// Nested message and enum types in `ListingGroupTypeEnum`.
pub mod listing_group_type_enum {
    /// The type of the listing group.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Subdivision of products along some listing dimension. These nodes
        /// are not used by serving to target listing entries, but is purely
        /// to define the structure of the tree.
        Subdivision = 2,
        /// Listing group unit that defines a bid.
        Unit = 3,
    }
    impl ListingGroupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Subdivision => "SUBDIVISION",
                Self::Unit => "UNIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SUBDIVISION" => Some(Self::Subdivision),
                "UNIT" => Some(Self::Unit),
                _ => None,
            }
        }
    }
}
/// Container for enum describing unit of radius in location group.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationGroupRadiusUnitsEnum {}
/// Nested message and enum types in `LocationGroupRadiusUnitsEnum`.
pub mod location_group_radius_units_enum {
    /// The unit of radius distance in location group (for example, MILES)
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationGroupRadiusUnits {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Meters
        Meters = 2,
        /// Miles
        Miles = 3,
        /// Milli Miles
        MilliMiles = 4,
    }
    impl LocationGroupRadiusUnits {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Meters => "METERS",
                Self::Miles => "MILES",
                Self::MilliMiles => "MILLI_MILES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "METERS" => Some(Self::Meters),
                "MILES" => Some(Self::Miles),
                "MILLI_MILES" => Some(Self::MilliMiles),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of quarter-hours.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MinuteOfHourEnum {}
/// Nested message and enum types in `MinuteOfHourEnum`.
pub mod minute_of_hour_enum {
    /// Enumerates of quarter-hours. For example, "FIFTEEN"
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MinuteOfHour {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Zero minutes past the hour.
        Zero = 2,
        /// Fifteen minutes past the hour.
        Fifteen = 3,
        /// Thirty minutes past the hour.
        Thirty = 4,
        /// Forty-five minutes past the hour.
        FortyFive = 5,
    }
    impl MinuteOfHour {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Zero => "ZERO",
                Self::Fifteen => "FIFTEEN",
                Self::Thirty => "THIRTY",
                Self::FortyFive => "FORTY_FIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ZERO" => Some(Self::Zero),
                "FIFTEEN" => Some(Self::Fifteen),
                "THIRTY" => Some(Self::Thirty),
                "FORTY_FIVE" => Some(Self::FortyFive),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of demographic parental statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ParentalStatusTypeEnum {}
/// Nested message and enum types in `ParentalStatusTypeEnum`.
pub mod parental_status_type_enum {
    /// The type of parental statuses (for example, not a parent).
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ParentalStatusType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Parent.
        Parent = 300,
        /// Not a parent.
        NotAParent = 301,
        /// Undetermined parental status.
        Undetermined = 302,
    }
    impl ParentalStatusType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Parent => "PARENT",
                Self::NotAParent => "NOT_A_PARENT",
                Self::Undetermined => "UNDETERMINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PARENT" => Some(Self::Parent),
                "NOT_A_PARENT" => Some(Self::NotAParent),
                "UNDETERMINED" => Some(Self::Undetermined),
                _ => None,
            }
        }
    }
}
/// Level of a product category.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductCategoryLevelEnum {}
/// Nested message and enum types in `ProductCategoryLevelEnum`.
pub mod product_category_level_enum {
    /// Enum describing the level of the product category.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductCategoryLevel {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Level 1.
        Level1 = 2,
        /// Level 2.
        Level2 = 3,
        /// Level 3.
        Level3 = 4,
        /// Level 4.
        Level4 = 5,
        /// Level 5.
        Level5 = 6,
    }
    impl ProductCategoryLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Level1 => "LEVEL1",
                Self::Level2 => "LEVEL2",
                Self::Level3 => "LEVEL3",
                Self::Level4 => "LEVEL4",
                Self::Level5 => "LEVEL5",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LEVEL1" => Some(Self::Level1),
                "LEVEL2" => Some(Self::Level2),
                "LEVEL3" => Some(Self::Level3),
                "LEVEL4" => Some(Self::Level4),
                "LEVEL5" => Some(Self::Level5),
                _ => None,
            }
        }
    }
}
/// Locality of a product offer.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductChannelEnum {}
/// Nested message and enum types in `ProductChannelEnum`.
pub mod product_channel_enum {
    /// Enum describing the locality of a product offer.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductChannel {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The item is sold online.
        Online = 2,
        /// The item is sold in local stores.
        Local = 3,
    }
    impl ProductChannel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Online => "ONLINE",
                Self::Local => "LOCAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ONLINE" => Some(Self::Online),
                "LOCAL" => Some(Self::Local),
                _ => None,
            }
        }
    }
}
/// Availability of a product offer.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductChannelExclusivityEnum {}
/// Nested message and enum types in `ProductChannelExclusivityEnum`.
pub mod product_channel_exclusivity_enum {
    /// Enum describing the availability of a product offer.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductChannelExclusivity {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The item is sold through one channel only, either local stores or online
        /// as indicated by its ProductChannel.
        SingleChannel = 2,
        /// The item is matched to its online or local stores counterpart, indicating
        /// it is available for purchase in both ShoppingProductChannels.
        MultiChannel = 3,
    }
    impl ProductChannelExclusivity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::SingleChannel => "SINGLE_CHANNEL",
                Self::MultiChannel => "MULTI_CHANNEL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SINGLE_CHANNEL" => Some(Self::SingleChannel),
                "MULTI_CHANNEL" => Some(Self::MultiChannel),
                _ => None,
            }
        }
    }
}
/// Condition of a product offer.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductConditionEnum {}
/// Nested message and enum types in `ProductConditionEnum`.
pub mod product_condition_enum {
    /// Enum describing the condition of a product offer.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductCondition {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The product condition is new.
        New = 3,
        /// The product condition is refurbished.
        Refurbished = 4,
        /// The product condition is used.
        Used = 5,
    }
    impl ProductCondition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::New => "NEW",
                Self::Refurbished => "REFURBISHED",
                Self::Used => "USED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEW" => Some(Self::New),
                "REFURBISHED" => Some(Self::Refurbished),
                "USED" => Some(Self::Used),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the index of the product custom attribute.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductCustomAttributeIndexEnum {}
/// Nested message and enum types in `ProductCustomAttributeIndexEnum`.
pub mod product_custom_attribute_index_enum {
    /// The index of the product custom attribute.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductCustomAttributeIndex {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// First product custom attribute.
        Index0 = 7,
        /// Second product custom attribute.
        Index1 = 8,
        /// Third product custom attribute.
        Index2 = 9,
        /// Fourth product custom attribute.
        Index3 = 10,
        /// Fifth product custom attribute.
        Index4 = 11,
    }
    impl ProductCustomAttributeIndex {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Index0 => "INDEX0",
                Self::Index1 => "INDEX1",
                Self::Index2 => "INDEX2",
                Self::Index3 => "INDEX3",
                Self::Index4 => "INDEX4",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INDEX0" => Some(Self::Index0),
                "INDEX1" => Some(Self::Index1),
                "INDEX2" => Some(Self::Index2),
                "INDEX3" => Some(Self::Index3),
                "INDEX4" => Some(Self::Index4),
                _ => None,
            }
        }
    }
}
/// Level of the type of a product offer.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductTypeLevelEnum {}
/// Nested message and enum types in `ProductTypeLevelEnum`.
pub mod product_type_level_enum {
    /// Enum describing the level of the type of a product offer.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductTypeLevel {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Level 1.
        Level1 = 7,
        /// Level 2.
        Level2 = 8,
        /// Level 3.
        Level3 = 9,
        /// Level 4.
        Level4 = 10,
        /// Level 5.
        Level5 = 11,
    }
    impl ProductTypeLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Level1 => "LEVEL1",
                Self::Level2 => "LEVEL2",
                Self::Level3 => "LEVEL3",
                Self::Level4 => "LEVEL4",
                Self::Level5 => "LEVEL5",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LEVEL1" => Some(Self::Level1),
                "LEVEL2" => Some(Self::Level2),
                "LEVEL3" => Some(Self::Level3),
                "LEVEL4" => Some(Self::Level4),
                "LEVEL5" => Some(Self::Level5),
                _ => None,
            }
        }
    }
}
/// Container for enum describing unit of radius in proximity.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProximityRadiusUnitsEnum {}
/// Nested message and enum types in `ProximityRadiusUnitsEnum`.
pub mod proximity_radius_units_enum {
    /// The unit of radius distance in proximity (for example, MILES)
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProximityRadiusUnits {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Miles
        Miles = 2,
        /// Kilometers
        Kilometers = 3,
    }
    impl ProximityRadiusUnits {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Miles => "MILES",
                Self::Kilometers => "KILOMETERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MILES" => Some(Self::Miles),
                "KILOMETERS" => Some(Self::Kilometers),
                _ => None,
            }
        }
    }
}
/// Container for enum describing webpage condition operand in webpage criterion.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WebpageConditionOperandEnum {}
/// Nested message and enum types in `WebpageConditionOperandEnum`.
pub mod webpage_condition_operand_enum {
    /// The webpage condition operand in webpage criterion.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WebpageConditionOperand {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Operand denoting a webpage URL targeting condition.
        Url = 2,
        /// Operand denoting a webpage category targeting condition.
        Category = 3,
        /// Operand denoting a webpage title targeting condition.
        PageTitle = 4,
        /// Operand denoting a webpage content targeting condition.
        PageContent = 5,
        /// Operand denoting a webpage custom label targeting condition.
        CustomLabel = 6,
    }
    impl WebpageConditionOperand {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Url => "URL",
                Self::Category => "CATEGORY",
                Self::PageTitle => "PAGE_TITLE",
                Self::PageContent => "PAGE_CONTENT",
                Self::CustomLabel => "CUSTOM_LABEL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "URL" => Some(Self::Url),
                "CATEGORY" => Some(Self::Category),
                "PAGE_TITLE" => Some(Self::PageTitle),
                "PAGE_CONTENT" => Some(Self::PageContent),
                "CUSTOM_LABEL" => Some(Self::CustomLabel),
                _ => None,
            }
        }
    }
}
/// Container for enum describing webpage condition operator in webpage
/// criterion.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WebpageConditionOperatorEnum {}
/// Nested message and enum types in `WebpageConditionOperatorEnum`.
pub mod webpage_condition_operator_enum {
    /// The webpage condition operator in webpage criterion.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WebpageConditionOperator {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The argument web condition is equal to the compared web condition.
        Equals = 2,
        /// The argument web condition is part of the compared web condition.
        Contains = 3,
    }
    impl WebpageConditionOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Equals => "EQUALS",
                Self::Contains => "CONTAINS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EQUALS" => Some(Self::Equals),
                "CONTAINS" => Some(Self::Contains),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the call to action types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CallToActionTypeEnum {}
/// Nested message and enum types in `CallToActionTypeEnum`.
pub mod call_to_action_type_enum {
    /// Enum describing possible types of call to action.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallToActionType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The call to action type is learn more.
        LearnMore = 2,
        /// The call to action type is get quote.
        GetQuote = 3,
        /// The call to action type is apply now.
        ApplyNow = 4,
        /// The call to action type is sign up.
        SignUp = 5,
        /// The call to action type is contact us.
        ContactUs = 6,
        /// The call to action type is subscribe.
        Subscribe = 7,
        /// The call to action type is download.
        Download = 8,
        /// The call to action type is book now.
        BookNow = 9,
        /// The call to action type is shop now.
        ShopNow = 10,
        /// The call to action type is buy now.
        BuyNow = 11,
        /// The call to action type is donate now.
        DonateNow = 12,
        /// The call to action type is order now.
        OrderNow = 13,
        /// The call to action type is play now.
        PlayNow = 14,
        /// The call to action type is see more.
        SeeMore = 15,
        /// The call to action type is start now.
        StartNow = 16,
        /// The call to action type is visit site.
        VisitSite = 17,
        /// The call to action type is watch now.
        WatchNow = 18,
    }
    impl CallToActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::LearnMore => "LEARN_MORE",
                Self::GetQuote => "GET_QUOTE",
                Self::ApplyNow => "APPLY_NOW",
                Self::SignUp => "SIGN_UP",
                Self::ContactUs => "CONTACT_US",
                Self::Subscribe => "SUBSCRIBE",
                Self::Download => "DOWNLOAD",
                Self::BookNow => "BOOK_NOW",
                Self::ShopNow => "SHOP_NOW",
                Self::BuyNow => "BUY_NOW",
                Self::DonateNow => "DONATE_NOW",
                Self::OrderNow => "ORDER_NOW",
                Self::PlayNow => "PLAY_NOW",
                Self::SeeMore => "SEE_MORE",
                Self::StartNow => "START_NOW",
                Self::VisitSite => "VISIT_SITE",
                Self::WatchNow => "WATCH_NOW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LEARN_MORE" => Some(Self::LearnMore),
                "GET_QUOTE" => Some(Self::GetQuote),
                "APPLY_NOW" => Some(Self::ApplyNow),
                "SIGN_UP" => Some(Self::SignUp),
                "CONTACT_US" => Some(Self::ContactUs),
                "SUBSCRIBE" => Some(Self::Subscribe),
                "DOWNLOAD" => Some(Self::Download),
                "BOOK_NOW" => Some(Self::BookNow),
                "SHOP_NOW" => Some(Self::ShopNow),
                "BUY_NOW" => Some(Self::BuyNow),
                "DONATE_NOW" => Some(Self::DonateNow),
                "ORDER_NOW" => Some(Self::OrderNow),
                "PLAY_NOW" => Some(Self::PlayNow),
                "SEE_MORE" => Some(Self::SeeMore),
                "START_NOW" => Some(Self::StartNow),
                "VISIT_SITE" => Some(Self::VisitSite),
                "WATCH_NOW" => Some(Self::WatchNow),
                _ => None,
            }
        }
    }
}
/// Describes the type of call-to-action phrases in a lead form.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LeadFormCallToActionTypeEnum {}
/// Nested message and enum types in `LeadFormCallToActionTypeEnum`.
pub mod lead_form_call_to_action_type_enum {
    /// Enum describing the type of call-to-action phrases in a lead form.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LeadFormCallToActionType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Learn more.
        LearnMore = 2,
        /// Get quote.
        GetQuote = 3,
        /// Apply now.
        ApplyNow = 4,
        /// Sign Up.
        SignUp = 5,
        /// Contact us.
        ContactUs = 6,
        /// Subscribe.
        Subscribe = 7,
        /// Download.
        Download = 8,
        /// Book now.
        BookNow = 9,
        /// Get offer.
        GetOffer = 10,
        /// Register.
        Register = 11,
        /// Get info.
        GetInfo = 12,
        /// Request a demo.
        RequestDemo = 13,
        /// Join now.
        JoinNow = 14,
        /// Get started.
        GetStarted = 15,
    }
    impl LeadFormCallToActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::LearnMore => "LEARN_MORE",
                Self::GetQuote => "GET_QUOTE",
                Self::ApplyNow => "APPLY_NOW",
                Self::SignUp => "SIGN_UP",
                Self::ContactUs => "CONTACT_US",
                Self::Subscribe => "SUBSCRIBE",
                Self::Download => "DOWNLOAD",
                Self::BookNow => "BOOK_NOW",
                Self::GetOffer => "GET_OFFER",
                Self::Register => "REGISTER",
                Self::GetInfo => "GET_INFO",
                Self::RequestDemo => "REQUEST_DEMO",
                Self::JoinNow => "JOIN_NOW",
                Self::GetStarted => "GET_STARTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LEARN_MORE" => Some(Self::LearnMore),
                "GET_QUOTE" => Some(Self::GetQuote),
                "APPLY_NOW" => Some(Self::ApplyNow),
                "SIGN_UP" => Some(Self::SignUp),
                "CONTACT_US" => Some(Self::ContactUs),
                "SUBSCRIBE" => Some(Self::Subscribe),
                "DOWNLOAD" => Some(Self::Download),
                "BOOK_NOW" => Some(Self::BookNow),
                "GET_OFFER" => Some(Self::GetOffer),
                "REGISTER" => Some(Self::Register),
                "GET_INFO" => Some(Self::GetInfo),
                "REQUEST_DEMO" => Some(Self::RequestDemo),
                "JOIN_NOW" => Some(Self::JoinNow),
                "GET_STARTED" => Some(Self::GetStarted),
                _ => None,
            }
        }
    }
}
/// Describes the chosen level of intent of generated leads.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LeadFormDesiredIntentEnum {}
/// Nested message and enum types in `LeadFormDesiredIntentEnum`.
pub mod lead_form_desired_intent_enum {
    /// Enum describing the chosen level of intent of generated leads.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LeadFormDesiredIntent {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Deliver more leads at a potentially lower quality.
        LowIntent = 2,
        /// Deliver leads that are more qualified.
        HighIntent = 3,
    }
    impl LeadFormDesiredIntent {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::LowIntent => "LOW_INTENT",
                Self::HighIntent => "HIGH_INTENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LOW_INTENT" => Some(Self::LowIntent),
                "HIGH_INTENT" => Some(Self::HighIntent),
                _ => None,
            }
        }
    }
}
/// Describes the input type of a lead form field.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LeadFormFieldUserInputTypeEnum {}
/// Nested message and enum types in `LeadFormFieldUserInputTypeEnum`.
pub mod lead_form_field_user_input_type_enum {
    /// Enum describing the input type of a lead form field.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LeadFormFieldUserInputType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The user will be asked to fill in their given and family name. This field
        /// cannot be set at the same time as GIVEN_NAME or FAMILY_NAME.
        FullName = 2,
        /// The user will be asked to fill in their email address.
        Email = 3,
        /// The user will be asked to fill in their phone number.
        PhoneNumber = 4,
        /// The user will be asked to fill in their zip code.
        PostalCode = 5,
        /// The user will be asked to fill in their street address.
        StreetAddress = 8,
        /// The user will be asked to fill in their city.
        City = 9,
        /// The user will be asked to fill in their region part of the address (for
        /// example, state for US, province for Canada).
        Region = 10,
        /// The user will be asked to fill in their country.
        Country = 11,
        /// The user will be asked to fill in their work email address.
        WorkEmail = 12,
        /// The user will be asked to fill in their company name.
        CompanyName = 13,
        /// The user will be asked to fill in their work phone.
        WorkPhone = 14,
        /// The user will be asked to fill in their job title.
        JobTitle = 15,
        /// The user will be asked to fill in their CPF for Brazil users.
        GovernmentIssuedIdCpfBr = 16,
        /// The user will be asked to fill in their DNI for Argentina users.
        GovernmentIssuedIdDniAr = 17,
        /// The user will be asked to fill in their DNI for Peru users.
        GovernmentIssuedIdDniPe = 18,
        /// The user will be asked to fill in their RUT for Chile users.
        GovernmentIssuedIdRutCl = 19,
        /// The user will be asked to fill in their CC for Colombia users.
        GovernmentIssuedIdCcCo = 20,
        /// The user will be asked to fill in their CI for Ecuador users.
        GovernmentIssuedIdCiEc = 21,
        /// The user will be asked to fill in their RFC for Mexico users.
        GovernmentIssuedIdRfcMx = 22,
        /// The user will be asked to fill in their first name. This
        /// field can not be set at the same time as FULL_NAME.
        FirstName = 23,
        /// The user will be asked to fill in their last name. This
        /// field can not be set at the same time as FULL_NAME.
        LastName = 24,
        /// Question: "Which model are you interested in?"
        /// Category: "Auto"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        VehicleModel = 1001,
        /// Question: "Which type of vehicle are you interested in?"
        /// Category: "Auto"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        VehicleType = 1002,
        /// Question: "What is your preferred dealership?"
        /// Category: "Auto"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        PreferredDealership = 1003,
        /// Question: "When do you plan on purchasing a vehicle?"
        /// Category: "Auto"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        VehiclePurchaseTimeline = 1004,
        /// Question: "Do you own a vehicle?"
        /// Category: "Auto"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        VehicleOwnership = 1005,
        /// Question: "What vehicle ownership option are you interested in?"
        /// Category: "Auto"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        VehiclePaymentType = 1009,
        /// Question: "What type of vehicle condition are you interested in?"
        /// Category: "Auto"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        VehicleCondition = 1010,
        /// Question: "What size is your company?"
        /// Category: "Business"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        CompanySize = 1006,
        /// Question: "What is your annual sales volume?"
        /// Category: "Business"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        AnnualSales = 1007,
        /// Question: "How many years have you been in business?"
        /// Category: "Business"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        YearsInBusiness = 1008,
        /// Question: "What is your job department?"
        /// Category: "Business"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        JobDepartment = 1011,
        /// Question: "What is your job role?"
        /// Category: "Business"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        JobRole = 1012,
        /// Question: "Are you over 18 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over18Age = 1078,
        /// Question: "Are you over 19 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over19Age = 1079,
        /// Question: "Are you over 20 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over20Age = 1080,
        /// Question: "Are you over 21 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over21Age = 1081,
        /// Question: "Are you over 22 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over22Age = 1082,
        /// Question: "Are you over 23 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over23Age = 1083,
        /// Question: "Are you over 24 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over24Age = 1084,
        /// Question: "Are you over 25 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over25Age = 1085,
        /// Question: "Are you over 26 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over26Age = 1086,
        /// Question: "Are you over 27 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over27Age = 1087,
        /// Question: "Are you over 28 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over28Age = 1088,
        /// Question: "Are you over 29 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over29Age = 1089,
        /// Question: "Are you over 30 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over30Age = 1090,
        /// Question: "Are you over 31 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over31Age = 1091,
        /// Question: "Are you over 32 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over32Age = 1092,
        /// Question: "Are you over 33 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over33Age = 1093,
        /// Question: "Are you over 34 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over34Age = 1094,
        /// Question: "Are you over 35 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over35Age = 1095,
        /// Question: "Are you over 36 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over36Age = 1096,
        /// Question: "Are you over 37 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over37Age = 1097,
        /// Question: "Are you over 38 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over38Age = 1098,
        /// Question: "Are you over 39 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over39Age = 1099,
        /// Question: "Are you over 40 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over40Age = 1100,
        /// Question: "Are you over 41 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over41Age = 1101,
        /// Question: "Are you over 42 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over42Age = 1102,
        /// Question: "Are you over 43 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over43Age = 1103,
        /// Question: "Are you over 44 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over44Age = 1104,
        /// Question: "Are you over 45 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over45Age = 1105,
        /// Question: "Are you over 46 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over46Age = 1106,
        /// Question: "Are you over 47 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over47Age = 1107,
        /// Question: "Are you over 48 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over48Age = 1108,
        /// Question: "Are you over 49 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over49Age = 1109,
        /// Question: "Are you over 50 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over50Age = 1110,
        /// Question: "Are you over 51 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over51Age = 1111,
        /// Question: "Are you over 52 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over52Age = 1112,
        /// Question: "Are you over 53 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over53Age = 1113,
        /// Question: "Are you over 54 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over54Age = 1114,
        /// Question: "Are you over 55 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over55Age = 1115,
        /// Question: "Are you over 56 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over56Age = 1116,
        /// Question: "Are you over 57 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over57Age = 1117,
        /// Question: "Are you over 58 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over58Age = 1118,
        /// Question: "Are you over 59 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over59Age = 1119,
        /// Question: "Are you over 60 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over60Age = 1120,
        /// Question: "Are you over 61 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over61Age = 1121,
        /// Question: "Are you over 62 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over62Age = 1122,
        /// Question: "Are you over 63 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over63Age = 1123,
        /// Question: "Are you over 64 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over64Age = 1124,
        /// Question: "Are you over 65 years of age?"
        /// Category: "Demographics"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Over65Age = 1125,
        /// Question: "Which program are you interested in?"
        /// Category: "Education"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        EducationProgram = 1013,
        /// Question: "Which course are you interested in?"
        /// Category: "Education"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        EducationCourse = 1014,
        /// Question: "Which product are you interested in?"
        /// Category: "General"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Product = 1016,
        /// Question: "Which service are you interested in?"
        /// Category: "General"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Service = 1017,
        /// Question: "Which offer are you interested in?"
        /// Category: "General"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Offer = 1018,
        /// Question: "Which category are you interested in?"
        /// Category: "General"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        Category = 1019,
        /// Question: "What is your preferred method of contact?"
        /// Category: "General"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        PreferredContactMethod = 1020,
        /// Question: "What is your preferred location?"
        /// Category: "General"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        PreferredLocation = 1021,
        /// Question: "What is the best time to contact you?"
        /// Category: "General"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        PreferredContactTime = 1022,
        /// Question: "When are you looking to make a purchase?"
        /// Category: "General"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        PurchaseTimeline = 1023,
        /// Question: "How many years of work experience do you have?"
        /// Category: "Jobs"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        YearsOfExperience = 1048,
        /// Question: "What industry do you work in?"
        /// Category: "Jobs"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        JobIndustry = 1049,
        /// Question: "What is your highest level of education?"
        /// Category: "Jobs"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        LevelOfEducation = 1050,
        /// Question: "What type of property are you looking for?"
        /// Category: "Real Estate"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        PropertyType = 1024,
        /// Question: "What do you need a realtor's help with?"
        /// Category: "Real Estate"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        RealtorHelpGoal = 1025,
        /// Question: "What neighborhood are you interested in?"
        /// Category: "Real Estate"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        PropertyCommunity = 1026,
        /// Question: "What price range are you looking for?"
        /// Category: "Real Estate"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        PriceRange = 1027,
        /// Question: "How many bedrooms are you looking for?"
        /// Category: "Real Estate"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        NumberOfBedrooms = 1028,
        /// Question: "Are you looking for a fully furnished property?"
        /// Category: "Real Estate"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        FurnishedProperty = 1029,
        /// Question: "Are you looking for properties that allow pets?"
        /// Category: "Real Estate"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        PetsAllowedProperty = 1030,
        /// Question: "What is the next product you plan to purchase?"
        /// Category: "Retail"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        NextPlannedPurchase = 1031,
        /// Question: "Would you like to sign up for an event?"
        /// Category: "Retail"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        EventSignupInterest = 1033,
        /// Question: "Where are you interested in shopping?"
        /// Category: "Retail"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        PreferredShoppingPlaces = 1034,
        /// Question: "What is your favorite brand?"
        /// Category: "Retail"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        FavoriteBrand = 1035,
        /// Question: "Which type of valid commercial license do you have?"
        /// Category: "Transportation"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        TransportationCommercialLicenseType = 1036,
        /// Question: "Interested in booking an event?"
        /// Category: "Travel"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        EventBookingInterest = 1038,
        /// Question: "What is your destination country?"
        /// Category: "Travel"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        DestinationCountry = 1039,
        /// Question: "What is your destination city?"
        /// Category: "Travel"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        DestinationCity = 1040,
        /// Question: "What is your departure country?"
        /// Category: "Travel"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        DepartureCountry = 1041,
        /// Question: "What is your departure city?"
        /// Category: "Travel"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        DepartureCity = 1042,
        /// Question: "What is your departure date?"
        /// Category: "Travel"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        DepartureDate = 1043,
        /// Question: "What is your return date?"
        /// Category: "Travel"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        ReturnDate = 1044,
        /// Question: "How many people are you traveling with?"
        /// Category: "Travel"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        NumberOfTravelers = 1045,
        /// Question: "What is your travel budget?"
        /// Category: "Travel"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        TravelBudget = 1046,
        /// Question: "Where do you want to stay during your travel?"
        /// Category: "Travel"
        /// This field is subject to a limit of 5 qualifying questions per form and
        /// cannot be used if values are set using custom_question_fields.
        TravelAccommodation = 1047,
    }
    impl LeadFormFieldUserInputType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::FullName => "FULL_NAME",
                Self::Email => "EMAIL",
                Self::PhoneNumber => "PHONE_NUMBER",
                Self::PostalCode => "POSTAL_CODE",
                Self::StreetAddress => "STREET_ADDRESS",
                Self::City => "CITY",
                Self::Region => "REGION",
                Self::Country => "COUNTRY",
                Self::WorkEmail => "WORK_EMAIL",
                Self::CompanyName => "COMPANY_NAME",
                Self::WorkPhone => "WORK_PHONE",
                Self::JobTitle => "JOB_TITLE",
                Self::GovernmentIssuedIdCpfBr => "GOVERNMENT_ISSUED_ID_CPF_BR",
                Self::GovernmentIssuedIdDniAr => "GOVERNMENT_ISSUED_ID_DNI_AR",
                Self::GovernmentIssuedIdDniPe => "GOVERNMENT_ISSUED_ID_DNI_PE",
                Self::GovernmentIssuedIdRutCl => "GOVERNMENT_ISSUED_ID_RUT_CL",
                Self::GovernmentIssuedIdCcCo => "GOVERNMENT_ISSUED_ID_CC_CO",
                Self::GovernmentIssuedIdCiEc => "GOVERNMENT_ISSUED_ID_CI_EC",
                Self::GovernmentIssuedIdRfcMx => "GOVERNMENT_ISSUED_ID_RFC_MX",
                Self::FirstName => "FIRST_NAME",
                Self::LastName => "LAST_NAME",
                Self::VehicleModel => "VEHICLE_MODEL",
                Self::VehicleType => "VEHICLE_TYPE",
                Self::PreferredDealership => "PREFERRED_DEALERSHIP",
                Self::VehiclePurchaseTimeline => "VEHICLE_PURCHASE_TIMELINE",
                Self::VehicleOwnership => "VEHICLE_OWNERSHIP",
                Self::VehiclePaymentType => "VEHICLE_PAYMENT_TYPE",
                Self::VehicleCondition => "VEHICLE_CONDITION",
                Self::CompanySize => "COMPANY_SIZE",
                Self::AnnualSales => "ANNUAL_SALES",
                Self::YearsInBusiness => "YEARS_IN_BUSINESS",
                Self::JobDepartment => "JOB_DEPARTMENT",
                Self::JobRole => "JOB_ROLE",
                Self::Over18Age => "OVER_18_AGE",
                Self::Over19Age => "OVER_19_AGE",
                Self::Over20Age => "OVER_20_AGE",
                Self::Over21Age => "OVER_21_AGE",
                Self::Over22Age => "OVER_22_AGE",
                Self::Over23Age => "OVER_23_AGE",
                Self::Over24Age => "OVER_24_AGE",
                Self::Over25Age => "OVER_25_AGE",
                Self::Over26Age => "OVER_26_AGE",
                Self::Over27Age => "OVER_27_AGE",
                Self::Over28Age => "OVER_28_AGE",
                Self::Over29Age => "OVER_29_AGE",
                Self::Over30Age => "OVER_30_AGE",
                Self::Over31Age => "OVER_31_AGE",
                Self::Over32Age => "OVER_32_AGE",
                Self::Over33Age => "OVER_33_AGE",
                Self::Over34Age => "OVER_34_AGE",
                Self::Over35Age => "OVER_35_AGE",
                Self::Over36Age => "OVER_36_AGE",
                Self::Over37Age => "OVER_37_AGE",
                Self::Over38Age => "OVER_38_AGE",
                Self::Over39Age => "OVER_39_AGE",
                Self::Over40Age => "OVER_40_AGE",
                Self::Over41Age => "OVER_41_AGE",
                Self::Over42Age => "OVER_42_AGE",
                Self::Over43Age => "OVER_43_AGE",
                Self::Over44Age => "OVER_44_AGE",
                Self::Over45Age => "OVER_45_AGE",
                Self::Over46Age => "OVER_46_AGE",
                Self::Over47Age => "OVER_47_AGE",
                Self::Over48Age => "OVER_48_AGE",
                Self::Over49Age => "OVER_49_AGE",
                Self::Over50Age => "OVER_50_AGE",
                Self::Over51Age => "OVER_51_AGE",
                Self::Over52Age => "OVER_52_AGE",
                Self::Over53Age => "OVER_53_AGE",
                Self::Over54Age => "OVER_54_AGE",
                Self::Over55Age => "OVER_55_AGE",
                Self::Over56Age => "OVER_56_AGE",
                Self::Over57Age => "OVER_57_AGE",
                Self::Over58Age => "OVER_58_AGE",
                Self::Over59Age => "OVER_59_AGE",
                Self::Over60Age => "OVER_60_AGE",
                Self::Over61Age => "OVER_61_AGE",
                Self::Over62Age => "OVER_62_AGE",
                Self::Over63Age => "OVER_63_AGE",
                Self::Over64Age => "OVER_64_AGE",
                Self::Over65Age => "OVER_65_AGE",
                Self::EducationProgram => "EDUCATION_PROGRAM",
                Self::EducationCourse => "EDUCATION_COURSE",
                Self::Product => "PRODUCT",
                Self::Service => "SERVICE",
                Self::Offer => "OFFER",
                Self::Category => "CATEGORY",
                Self::PreferredContactMethod => "PREFERRED_CONTACT_METHOD",
                Self::PreferredLocation => "PREFERRED_LOCATION",
                Self::PreferredContactTime => "PREFERRED_CONTACT_TIME",
                Self::PurchaseTimeline => "PURCHASE_TIMELINE",
                Self::YearsOfExperience => "YEARS_OF_EXPERIENCE",
                Self::JobIndustry => "JOB_INDUSTRY",
                Self::LevelOfEducation => "LEVEL_OF_EDUCATION",
                Self::PropertyType => "PROPERTY_TYPE",
                Self::RealtorHelpGoal => "REALTOR_HELP_GOAL",
                Self::PropertyCommunity => "PROPERTY_COMMUNITY",
                Self::PriceRange => "PRICE_RANGE",
                Self::NumberOfBedrooms => "NUMBER_OF_BEDROOMS",
                Self::FurnishedProperty => "FURNISHED_PROPERTY",
                Self::PetsAllowedProperty => "PETS_ALLOWED_PROPERTY",
                Self::NextPlannedPurchase => "NEXT_PLANNED_PURCHASE",
                Self::EventSignupInterest => "EVENT_SIGNUP_INTEREST",
                Self::PreferredShoppingPlaces => "PREFERRED_SHOPPING_PLACES",
                Self::FavoriteBrand => "FAVORITE_BRAND",
                Self::TransportationCommercialLicenseType => {
                    "TRANSPORTATION_COMMERCIAL_LICENSE_TYPE"
                }
                Self::EventBookingInterest => "EVENT_BOOKING_INTEREST",
                Self::DestinationCountry => "DESTINATION_COUNTRY",
                Self::DestinationCity => "DESTINATION_CITY",
                Self::DepartureCountry => "DEPARTURE_COUNTRY",
                Self::DepartureCity => "DEPARTURE_CITY",
                Self::DepartureDate => "DEPARTURE_DATE",
                Self::ReturnDate => "RETURN_DATE",
                Self::NumberOfTravelers => "NUMBER_OF_TRAVELERS",
                Self::TravelBudget => "TRAVEL_BUDGET",
                Self::TravelAccommodation => "TRAVEL_ACCOMMODATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FULL_NAME" => Some(Self::FullName),
                "EMAIL" => Some(Self::Email),
                "PHONE_NUMBER" => Some(Self::PhoneNumber),
                "POSTAL_CODE" => Some(Self::PostalCode),
                "STREET_ADDRESS" => Some(Self::StreetAddress),
                "CITY" => Some(Self::City),
                "REGION" => Some(Self::Region),
                "COUNTRY" => Some(Self::Country),
                "WORK_EMAIL" => Some(Self::WorkEmail),
                "COMPANY_NAME" => Some(Self::CompanyName),
                "WORK_PHONE" => Some(Self::WorkPhone),
                "JOB_TITLE" => Some(Self::JobTitle),
                "GOVERNMENT_ISSUED_ID_CPF_BR" => Some(Self::GovernmentIssuedIdCpfBr),
                "GOVERNMENT_ISSUED_ID_DNI_AR" => Some(Self::GovernmentIssuedIdDniAr),
                "GOVERNMENT_ISSUED_ID_DNI_PE" => Some(Self::GovernmentIssuedIdDniPe),
                "GOVERNMENT_ISSUED_ID_RUT_CL" => Some(Self::GovernmentIssuedIdRutCl),
                "GOVERNMENT_ISSUED_ID_CC_CO" => Some(Self::GovernmentIssuedIdCcCo),
                "GOVERNMENT_ISSUED_ID_CI_EC" => Some(Self::GovernmentIssuedIdCiEc),
                "GOVERNMENT_ISSUED_ID_RFC_MX" => Some(Self::GovernmentIssuedIdRfcMx),
                "FIRST_NAME" => Some(Self::FirstName),
                "LAST_NAME" => Some(Self::LastName),
                "VEHICLE_MODEL" => Some(Self::VehicleModel),
                "VEHICLE_TYPE" => Some(Self::VehicleType),
                "PREFERRED_DEALERSHIP" => Some(Self::PreferredDealership),
                "VEHICLE_PURCHASE_TIMELINE" => Some(Self::VehiclePurchaseTimeline),
                "VEHICLE_OWNERSHIP" => Some(Self::VehicleOwnership),
                "VEHICLE_PAYMENT_TYPE" => Some(Self::VehiclePaymentType),
                "VEHICLE_CONDITION" => Some(Self::VehicleCondition),
                "COMPANY_SIZE" => Some(Self::CompanySize),
                "ANNUAL_SALES" => Some(Self::AnnualSales),
                "YEARS_IN_BUSINESS" => Some(Self::YearsInBusiness),
                "JOB_DEPARTMENT" => Some(Self::JobDepartment),
                "JOB_ROLE" => Some(Self::JobRole),
                "OVER_18_AGE" => Some(Self::Over18Age),
                "OVER_19_AGE" => Some(Self::Over19Age),
                "OVER_20_AGE" => Some(Self::Over20Age),
                "OVER_21_AGE" => Some(Self::Over21Age),
                "OVER_22_AGE" => Some(Self::Over22Age),
                "OVER_23_AGE" => Some(Self::Over23Age),
                "OVER_24_AGE" => Some(Self::Over24Age),
                "OVER_25_AGE" => Some(Self::Over25Age),
                "OVER_26_AGE" => Some(Self::Over26Age),
                "OVER_27_AGE" => Some(Self::Over27Age),
                "OVER_28_AGE" => Some(Self::Over28Age),
                "OVER_29_AGE" => Some(Self::Over29Age),
                "OVER_30_AGE" => Some(Self::Over30Age),
                "OVER_31_AGE" => Some(Self::Over31Age),
                "OVER_32_AGE" => Some(Self::Over32Age),
                "OVER_33_AGE" => Some(Self::Over33Age),
                "OVER_34_AGE" => Some(Self::Over34Age),
                "OVER_35_AGE" => Some(Self::Over35Age),
                "OVER_36_AGE" => Some(Self::Over36Age),
                "OVER_37_AGE" => Some(Self::Over37Age),
                "OVER_38_AGE" => Some(Self::Over38Age),
                "OVER_39_AGE" => Some(Self::Over39Age),
                "OVER_40_AGE" => Some(Self::Over40Age),
                "OVER_41_AGE" => Some(Self::Over41Age),
                "OVER_42_AGE" => Some(Self::Over42Age),
                "OVER_43_AGE" => Some(Self::Over43Age),
                "OVER_44_AGE" => Some(Self::Over44Age),
                "OVER_45_AGE" => Some(Self::Over45Age),
                "OVER_46_AGE" => Some(Self::Over46Age),
                "OVER_47_AGE" => Some(Self::Over47Age),
                "OVER_48_AGE" => Some(Self::Over48Age),
                "OVER_49_AGE" => Some(Self::Over49Age),
                "OVER_50_AGE" => Some(Self::Over50Age),
                "OVER_51_AGE" => Some(Self::Over51Age),
                "OVER_52_AGE" => Some(Self::Over52Age),
                "OVER_53_AGE" => Some(Self::Over53Age),
                "OVER_54_AGE" => Some(Self::Over54Age),
                "OVER_55_AGE" => Some(Self::Over55Age),
                "OVER_56_AGE" => Some(Self::Over56Age),
                "OVER_57_AGE" => Some(Self::Over57Age),
                "OVER_58_AGE" => Some(Self::Over58Age),
                "OVER_59_AGE" => Some(Self::Over59Age),
                "OVER_60_AGE" => Some(Self::Over60Age),
                "OVER_61_AGE" => Some(Self::Over61Age),
                "OVER_62_AGE" => Some(Self::Over62Age),
                "OVER_63_AGE" => Some(Self::Over63Age),
                "OVER_64_AGE" => Some(Self::Over64Age),
                "OVER_65_AGE" => Some(Self::Over65Age),
                "EDUCATION_PROGRAM" => Some(Self::EducationProgram),
                "EDUCATION_COURSE" => Some(Self::EducationCourse),
                "PRODUCT" => Some(Self::Product),
                "SERVICE" => Some(Self::Service),
                "OFFER" => Some(Self::Offer),
                "CATEGORY" => Some(Self::Category),
                "PREFERRED_CONTACT_METHOD" => Some(Self::PreferredContactMethod),
                "PREFERRED_LOCATION" => Some(Self::PreferredLocation),
                "PREFERRED_CONTACT_TIME" => Some(Self::PreferredContactTime),
                "PURCHASE_TIMELINE" => Some(Self::PurchaseTimeline),
                "YEARS_OF_EXPERIENCE" => Some(Self::YearsOfExperience),
                "JOB_INDUSTRY" => Some(Self::JobIndustry),
                "LEVEL_OF_EDUCATION" => Some(Self::LevelOfEducation),
                "PROPERTY_TYPE" => Some(Self::PropertyType),
                "REALTOR_HELP_GOAL" => Some(Self::RealtorHelpGoal),
                "PROPERTY_COMMUNITY" => Some(Self::PropertyCommunity),
                "PRICE_RANGE" => Some(Self::PriceRange),
                "NUMBER_OF_BEDROOMS" => Some(Self::NumberOfBedrooms),
                "FURNISHED_PROPERTY" => Some(Self::FurnishedProperty),
                "PETS_ALLOWED_PROPERTY" => Some(Self::PetsAllowedProperty),
                "NEXT_PLANNED_PURCHASE" => Some(Self::NextPlannedPurchase),
                "EVENT_SIGNUP_INTEREST" => Some(Self::EventSignupInterest),
                "PREFERRED_SHOPPING_PLACES" => Some(Self::PreferredShoppingPlaces),
                "FAVORITE_BRAND" => Some(Self::FavoriteBrand),
                "TRANSPORTATION_COMMERCIAL_LICENSE_TYPE" => {
                    Some(Self::TransportationCommercialLicenseType)
                }
                "EVENT_BOOKING_INTEREST" => Some(Self::EventBookingInterest),
                "DESTINATION_COUNTRY" => Some(Self::DestinationCountry),
                "DESTINATION_CITY" => Some(Self::DestinationCity),
                "DEPARTURE_COUNTRY" => Some(Self::DepartureCountry),
                "DEPARTURE_CITY" => Some(Self::DepartureCity),
                "DEPARTURE_DATE" => Some(Self::DepartureDate),
                "RETURN_DATE" => Some(Self::ReturnDate),
                "NUMBER_OF_TRAVELERS" => Some(Self::NumberOfTravelers),
                "TRAVEL_BUDGET" => Some(Self::TravelBudget),
                "TRAVEL_ACCOMMODATION" => Some(Self::TravelAccommodation),
                _ => None,
            }
        }
    }
}
/// Describes the type of post-submit call-to-action phrases for a lead form.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LeadFormPostSubmitCallToActionTypeEnum {}
/// Nested message and enum types in `LeadFormPostSubmitCallToActionTypeEnum`.
pub mod lead_form_post_submit_call_to_action_type_enum {
    /// Enum describing the type of post-submit call-to-action phrases for a lead
    /// form.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LeadFormPostSubmitCallToActionType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Visit site.
        VisitSite = 2,
        /// Download.
        Download = 3,
        /// Learn more.
        LearnMore = 4,
        /// Shop now.
        ShopNow = 5,
    }
    impl LeadFormPostSubmitCallToActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::VisitSite => "VISIT_SITE",
                Self::Download => "DOWNLOAD",
                Self::LearnMore => "LEARN_MORE",
                Self::ShopNow => "SHOP_NOW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "VISIT_SITE" => Some(Self::VisitSite),
                "DOWNLOAD" => Some(Self::Download),
                "LEARN_MORE" => Some(Self::LearnMore),
                "SHOP_NOW" => Some(Self::ShopNow),
                _ => None,
            }
        }
    }
}
/// Container for enum describing different types of mobile app vendors.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MobileAppVendorEnum {}
/// Nested message and enum types in `MobileAppVendorEnum`.
pub mod mobile_app_vendor_enum {
    /// The type of mobile app vendor
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MobileAppVendor {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Mobile app vendor for Apple app store.
        AppleAppStore = 2,
        /// Mobile app vendor for Google app store.
        GoogleAppStore = 3,
    }
    impl MobileAppVendor {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AppleAppStore => "APPLE_APP_STORE",
                Self::GoogleAppStore => "GOOGLE_APP_STORE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APPLE_APP_STORE" => Some(Self::AppleAppStore),
                "GOOGLE_APP_STORE" => Some(Self::GoogleAppStore),
                _ => None,
            }
        }
    }
}
/// Container for enum describing a price extension price qualifier.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PriceExtensionPriceQualifierEnum {}
/// Nested message and enum types in `PriceExtensionPriceQualifierEnum`.
pub mod price_extension_price_qualifier_enum {
    /// Enums of price extension price qualifier.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PriceExtensionPriceQualifier {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// 'From' qualifier for the price.
        From = 2,
        /// 'Up to' qualifier for the price.
        UpTo = 3,
        /// 'Average' qualifier for the price.
        Average = 4,
    }
    impl PriceExtensionPriceQualifier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::From => "FROM",
                Self::UpTo => "UP_TO",
                Self::Average => "AVERAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FROM" => Some(Self::From),
                "UP_TO" => Some(Self::UpTo),
                "AVERAGE" => Some(Self::Average),
                _ => None,
            }
        }
    }
}
/// Container for enum describing price extension price unit.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PriceExtensionPriceUnitEnum {}
/// Nested message and enum types in `PriceExtensionPriceUnitEnum`.
pub mod price_extension_price_unit_enum {
    /// Price extension price unit.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PriceExtensionPriceUnit {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Per hour.
        PerHour = 2,
        /// Per day.
        PerDay = 3,
        /// Per week.
        PerWeek = 4,
        /// Per month.
        PerMonth = 5,
        /// Per year.
        PerYear = 6,
        /// Per night.
        PerNight = 7,
    }
    impl PriceExtensionPriceUnit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::PerHour => "PER_HOUR",
                Self::PerDay => "PER_DAY",
                Self::PerWeek => "PER_WEEK",
                Self::PerMonth => "PER_MONTH",
                Self::PerYear => "PER_YEAR",
                Self::PerNight => "PER_NIGHT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PER_HOUR" => Some(Self::PerHour),
                "PER_DAY" => Some(Self::PerDay),
                "PER_WEEK" => Some(Self::PerWeek),
                "PER_MONTH" => Some(Self::PerMonth),
                "PER_YEAR" => Some(Self::PerYear),
                "PER_NIGHT" => Some(Self::PerNight),
                _ => None,
            }
        }
    }
}
/// Container for enum describing types for a price extension.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PriceExtensionTypeEnum {}
/// Nested message and enum types in `PriceExtensionTypeEnum`.
pub mod price_extension_type_enum {
    /// Price extension type.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PriceExtensionType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The type for showing a list of brands.
        Brands = 2,
        /// The type for showing a list of events.
        Events = 3,
        /// The type for showing locations relevant to your business.
        Locations = 4,
        /// The type for showing sub-regions or districts within a city or region.
        Neighborhoods = 5,
        /// The type for showing a collection of product categories.
        ProductCategories = 6,
        /// The type for showing a collection of related product tiers.
        ProductTiers = 7,
        /// The type for showing a collection of services offered by your business.
        Services = 8,
        /// The type for showing a collection of service categories.
        ServiceCategories = 9,
        /// The type for showing a collection of related service tiers.
        ServiceTiers = 10,
    }
    impl PriceExtensionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Brands => "BRANDS",
                Self::Events => "EVENTS",
                Self::Locations => "LOCATIONS",
                Self::Neighborhoods => "NEIGHBORHOODS",
                Self::ProductCategories => "PRODUCT_CATEGORIES",
                Self::ProductTiers => "PRODUCT_TIERS",
                Self::Services => "SERVICES",
                Self::ServiceCategories => "SERVICE_CATEGORIES",
                Self::ServiceTiers => "SERVICE_TIERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BRANDS" => Some(Self::Brands),
                "EVENTS" => Some(Self::Events),
                "LOCATIONS" => Some(Self::Locations),
                "NEIGHBORHOODS" => Some(Self::Neighborhoods),
                "PRODUCT_CATEGORIES" => Some(Self::ProductCategories),
                "PRODUCT_TIERS" => Some(Self::ProductTiers),
                "SERVICES" => Some(Self::Services),
                "SERVICE_CATEGORIES" => Some(Self::ServiceCategories),
                "SERVICE_TIERS" => Some(Self::ServiceTiers),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible a promotion extension
/// discount modifier.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PromotionExtensionDiscountModifierEnum {}
/// Nested message and enum types in `PromotionExtensionDiscountModifierEnum`.
pub mod promotion_extension_discount_modifier_enum {
    /// A promotion extension discount modifier.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PromotionExtensionDiscountModifier {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// 'Up to'.
        UpTo = 2,
    }
    impl PromotionExtensionDiscountModifier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::UpTo => "UP_TO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UP_TO" => Some(Self::UpTo),
                _ => None,
            }
        }
    }
}
/// Container for enum describing a promotion extension occasion.
/// For more information about the occasions  check:
/// <https://support.google.com/google-ads/answer/7367521>
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PromotionExtensionOccasionEnum {}
/// Nested message and enum types in `PromotionExtensionOccasionEnum`.
pub mod promotion_extension_occasion_enum {
    /// A promotion extension occasion.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PromotionExtensionOccasion {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// New Year's.
        NewYears = 2,
        /// Chinese New Year.
        ChineseNewYear = 3,
        /// Valentine's Day.
        ValentinesDay = 4,
        /// Easter.
        Easter = 5,
        /// Mother's Day.
        MothersDay = 6,
        /// Father's Day.
        FathersDay = 7,
        /// Labor Day.
        LaborDay = 8,
        /// Back To School.
        BackToSchool = 9,
        /// Halloween.
        Halloween = 10,
        /// Black Friday.
        BlackFriday = 11,
        /// Cyber Monday.
        CyberMonday = 12,
        /// Christmas.
        Christmas = 13,
        /// Boxing Day.
        BoxingDay = 14,
        /// Independence Day in any country.
        IndependenceDay = 15,
        /// National Day in any country.
        NationalDay = 16,
        /// End of any season.
        EndOfSeason = 17,
        /// Winter Sale.
        WinterSale = 18,
        /// Summer sale.
        SummerSale = 19,
        /// Fall Sale.
        FallSale = 20,
        /// Spring Sale.
        SpringSale = 21,
        /// Ramadan.
        Ramadan = 22,
        /// Eid al-Fitr.
        EidAlFitr = 23,
        /// Eid al-Adha.
        EidAlAdha = 24,
        /// Singles Day.
        SinglesDay = 25,
        /// Women's Day.
        WomensDay = 26,
        /// Holi.
        Holi = 27,
        /// Parent's Day.
        ParentsDay = 28,
        /// St. Nicholas Day.
        StNicholasDay = 29,
        /// Carnival.
        Carnival = 30,
        /// Epiphany, also known as Three Kings' Day.
        Epiphany = 31,
        /// Rosh Hashanah.
        RoshHashanah = 32,
        /// Passover.
        Passover = 33,
        /// Hanukkah.
        Hanukkah = 34,
        /// Diwali.
        Diwali = 35,
        /// Navratri.
        Navratri = 36,
        /// Available in Thai: Songkran.
        Songkran = 37,
        /// Available in Japanese: Year-end Gift.
        YearEndGift = 38,
    }
    impl PromotionExtensionOccasion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NewYears => "NEW_YEARS",
                Self::ChineseNewYear => "CHINESE_NEW_YEAR",
                Self::ValentinesDay => "VALENTINES_DAY",
                Self::Easter => "EASTER",
                Self::MothersDay => "MOTHERS_DAY",
                Self::FathersDay => "FATHERS_DAY",
                Self::LaborDay => "LABOR_DAY",
                Self::BackToSchool => "BACK_TO_SCHOOL",
                Self::Halloween => "HALLOWEEN",
                Self::BlackFriday => "BLACK_FRIDAY",
                Self::CyberMonday => "CYBER_MONDAY",
                Self::Christmas => "CHRISTMAS",
                Self::BoxingDay => "BOXING_DAY",
                Self::IndependenceDay => "INDEPENDENCE_DAY",
                Self::NationalDay => "NATIONAL_DAY",
                Self::EndOfSeason => "END_OF_SEASON",
                Self::WinterSale => "WINTER_SALE",
                Self::SummerSale => "SUMMER_SALE",
                Self::FallSale => "FALL_SALE",
                Self::SpringSale => "SPRING_SALE",
                Self::Ramadan => "RAMADAN",
                Self::EidAlFitr => "EID_AL_FITR",
                Self::EidAlAdha => "EID_AL_ADHA",
                Self::SinglesDay => "SINGLES_DAY",
                Self::WomensDay => "WOMENS_DAY",
                Self::Holi => "HOLI",
                Self::ParentsDay => "PARENTS_DAY",
                Self::StNicholasDay => "ST_NICHOLAS_DAY",
                Self::Carnival => "CARNIVAL",
                Self::Epiphany => "EPIPHANY",
                Self::RoshHashanah => "ROSH_HASHANAH",
                Self::Passover => "PASSOVER",
                Self::Hanukkah => "HANUKKAH",
                Self::Diwali => "DIWALI",
                Self::Navratri => "NAVRATRI",
                Self::Songkran => "SONGKRAN",
                Self::YearEndGift => "YEAR_END_GIFT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEW_YEARS" => Some(Self::NewYears),
                "CHINESE_NEW_YEAR" => Some(Self::ChineseNewYear),
                "VALENTINES_DAY" => Some(Self::ValentinesDay),
                "EASTER" => Some(Self::Easter),
                "MOTHERS_DAY" => Some(Self::MothersDay),
                "FATHERS_DAY" => Some(Self::FathersDay),
                "LABOR_DAY" => Some(Self::LaborDay),
                "BACK_TO_SCHOOL" => Some(Self::BackToSchool),
                "HALLOWEEN" => Some(Self::Halloween),
                "BLACK_FRIDAY" => Some(Self::BlackFriday),
                "CYBER_MONDAY" => Some(Self::CyberMonday),
                "CHRISTMAS" => Some(Self::Christmas),
                "BOXING_DAY" => Some(Self::BoxingDay),
                "INDEPENDENCE_DAY" => Some(Self::IndependenceDay),
                "NATIONAL_DAY" => Some(Self::NationalDay),
                "END_OF_SEASON" => Some(Self::EndOfSeason),
                "WINTER_SALE" => Some(Self::WinterSale),
                "SUMMER_SALE" => Some(Self::SummerSale),
                "FALL_SALE" => Some(Self::FallSale),
                "SPRING_SALE" => Some(Self::SpringSale),
                "RAMADAN" => Some(Self::Ramadan),
                "EID_AL_FITR" => Some(Self::EidAlFitr),
                "EID_AL_ADHA" => Some(Self::EidAlAdha),
                "SINGLES_DAY" => Some(Self::SinglesDay),
                "WOMENS_DAY" => Some(Self::WomensDay),
                "HOLI" => Some(Self::Holi),
                "PARENTS_DAY" => Some(Self::ParentsDay),
                "ST_NICHOLAS_DAY" => Some(Self::StNicholasDay),
                "CARNIVAL" => Some(Self::Carnival),
                "EPIPHANY" => Some(Self::Epiphany),
                "ROSH_HASHANAH" => Some(Self::RoshHashanah),
                "PASSOVER" => Some(Self::Passover),
                "HANUKKAH" => Some(Self::Hanukkah),
                "DIWALI" => Some(Self::Diwali),
                "NAVRATRI" => Some(Self::Navratri),
                "SONGKRAN" => Some(Self::Songkran),
                "YEAR_END_GIFT" => Some(Self::YearEndGift),
                _ => None,
            }
        }
    }
}
/// Container for enum describing bidding goal Target Frequency time units.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TargetFrequencyTimeUnitEnum {}
/// Nested message and enum types in `TargetFrequencyTimeUnitEnum`.
pub mod target_frequency_time_unit_enum {
    /// Enum describing time window over which we want to reach Target Frequency.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetFrequencyTimeUnit {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Optimize bidding to reach Target Frequency in a week.
        Weekly = 2,
    }
    impl TargetFrequencyTimeUnit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Weekly => "WEEKLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "WEEKLY" => Some(Self::Weekly),
                _ => None,
            }
        }
    }
}
/// Container for enum describing where on the first search results page the
/// automated bidding system should target impressions for the
/// TargetImpressionShare bidding strategy.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TargetImpressionShareLocationEnum {}
/// Nested message and enum types in `TargetImpressionShareLocationEnum`.
pub mod target_impression_share_location_enum {
    /// Enum describing possible goals.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetImpressionShareLocation {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Any location on the web page.
        AnywhereOnPage = 2,
        /// Top box of ads.
        TopOfPage = 3,
        /// Top slot in the top box of ads.
        AbsoluteTopOfPage = 4,
    }
    impl TargetImpressionShareLocation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AnywhereOnPage => "ANYWHERE_ON_PAGE",
                Self::TopOfPage => "TOP_OF_PAGE",
                Self::AbsoluteTopOfPage => "ABSOLUTE_TOP_OF_PAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ANYWHERE_ON_PAGE" => Some(Self::AnywhereOnPage),
                "TOP_OF_PAGE" => Some(Self::TopOfPage),
                "ABSOLUTE_TOP_OF_PAGE" => Some(Self::AbsoluteTopOfPage),
                _ => None,
            }
        }
    }
}
/// Enums represent consent status.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConsentStatusEnum {}
/// Nested message and enum types in `ConsentStatusEnum`.
pub mod consent_status_enum {
    /// Consent status
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConsentStatus {
        /// Not specified.
        Unspecified = 0,
        /// Output-only. Represents a format not yet defined in this enum.
        Unknown = 1,
        /// Granted.
        Granted = 2,
        /// Denied.
        Denied = 3,
    }
    impl ConsentStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Granted => "GRANTED",
                Self::Denied => "DENIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "GRANTED" => Some(Self::Granted),
                "DENIED" => Some(Self::Denied),
                _ => None,
            }
        }
    }
}
/// An immutable specialization of an Advertising Channel.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdvertisingChannelSubTypeEnum {}
/// Nested message and enum types in `AdvertisingChannelSubTypeEnum`.
pub mod advertising_channel_sub_type_enum {
    /// Enum describing the different channel subtypes.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdvertisingChannelSubType {
        /// Not specified.
        Unspecified = 0,
        /// Used as a return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Mobile app campaigns for Search.
        SearchMobileApp = 2,
        /// Mobile app campaigns for Display.
        DisplayMobileApp = 3,
        /// AdWords express campaigns for search.
        SearchExpress = 4,
        /// AdWords Express campaigns for display.
        DisplayExpress = 5,
        /// Smart Shopping campaigns.
        ShoppingSmartAds = 6,
        /// Gmail Ad campaigns.
        DisplayGmailAd = 7,
        /// Smart display campaigns. New campaigns of this sub type cannot be
        /// created.
        DisplaySmartCampaign = 8,
        /// Video Outstream campaigns.
        VideoOutstream = 9,
        /// Video TrueView for Action campaigns.
        VideoAction = 10,
        /// Video campaigns with non-skippable video ads.
        VideoNonSkippable = 11,
        /// App Campaign that lets you easily promote your Android or iOS app
        /// across Google's top properties including Search, Play, YouTube, and the
        /// Google Display Network.
        AppCampaign = 12,
        /// App Campaign for engagement, focused on driving re-engagement with the
        /// app across several of Google's top properties including Search, YouTube,
        /// and the Google Display Network.
        AppCampaignForEngagement = 13,
        /// Campaigns specialized for local advertising.
        LocalCampaign = 14,
        /// Shopping Comparison Listing campaigns.
        ShoppingComparisonListingAds = 15,
        /// Standard Smart campaigns.
        SmartCampaign = 16,
        /// Video campaigns with sequence video ads.
        VideoSequence = 17,
        /// App Campaign for pre registration, specialized for advertising mobile
        /// app pre-registration, that targets multiple advertising channels across
        /// Google Play, YouTube and Display Network. See
        /// <https://support.google.com/google-ads/answer/9441344> to learn more.
        AppCampaignForPreRegistration = 18,
        /// Video reach campaign with Target Frequency bidding strategy.
        VideoReachTargetFrequency = 19,
        /// Travel Activities campaigns.
        TravelActivities = 20,
    }
    impl AdvertisingChannelSubType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::SearchMobileApp => "SEARCH_MOBILE_APP",
                Self::DisplayMobileApp => "DISPLAY_MOBILE_APP",
                Self::SearchExpress => "SEARCH_EXPRESS",
                Self::DisplayExpress => "DISPLAY_EXPRESS",
                Self::ShoppingSmartAds => "SHOPPING_SMART_ADS",
                Self::DisplayGmailAd => "DISPLAY_GMAIL_AD",
                Self::DisplaySmartCampaign => "DISPLAY_SMART_CAMPAIGN",
                Self::VideoOutstream => "VIDEO_OUTSTREAM",
                Self::VideoAction => "VIDEO_ACTION",
                Self::VideoNonSkippable => "VIDEO_NON_SKIPPABLE",
                Self::AppCampaign => "APP_CAMPAIGN",
                Self::AppCampaignForEngagement => "APP_CAMPAIGN_FOR_ENGAGEMENT",
                Self::LocalCampaign => "LOCAL_CAMPAIGN",
                Self::ShoppingComparisonListingAds => "SHOPPING_COMPARISON_LISTING_ADS",
                Self::SmartCampaign => "SMART_CAMPAIGN",
                Self::VideoSequence => "VIDEO_SEQUENCE",
                Self::AppCampaignForPreRegistration => {
                    "APP_CAMPAIGN_FOR_PRE_REGISTRATION"
                }
                Self::VideoReachTargetFrequency => "VIDEO_REACH_TARGET_FREQUENCY",
                Self::TravelActivities => "TRAVEL_ACTIVITIES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEARCH_MOBILE_APP" => Some(Self::SearchMobileApp),
                "DISPLAY_MOBILE_APP" => Some(Self::DisplayMobileApp),
                "SEARCH_EXPRESS" => Some(Self::SearchExpress),
                "DISPLAY_EXPRESS" => Some(Self::DisplayExpress),
                "SHOPPING_SMART_ADS" => Some(Self::ShoppingSmartAds),
                "DISPLAY_GMAIL_AD" => Some(Self::DisplayGmailAd),
                "DISPLAY_SMART_CAMPAIGN" => Some(Self::DisplaySmartCampaign),
                "VIDEO_OUTSTREAM" => Some(Self::VideoOutstream),
                "VIDEO_ACTION" => Some(Self::VideoAction),
                "VIDEO_NON_SKIPPABLE" => Some(Self::VideoNonSkippable),
                "APP_CAMPAIGN" => Some(Self::AppCampaign),
                "APP_CAMPAIGN_FOR_ENGAGEMENT" => Some(Self::AppCampaignForEngagement),
                "LOCAL_CAMPAIGN" => Some(Self::LocalCampaign),
                "SHOPPING_COMPARISON_LISTING_ADS" => {
                    Some(Self::ShoppingComparisonListingAds)
                }
                "SMART_CAMPAIGN" => Some(Self::SmartCampaign),
                "VIDEO_SEQUENCE" => Some(Self::VideoSequence),
                "APP_CAMPAIGN_FOR_PRE_REGISTRATION" => {
                    Some(Self::AppCampaignForPreRegistration)
                }
                "VIDEO_REACH_TARGET_FREQUENCY" => Some(Self::VideoReachTargetFrequency),
                "TRAVEL_ACTIVITIES" => Some(Self::TravelActivities),
                _ => None,
            }
        }
    }
}
/// The channel type a campaign may target to serve on.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdvertisingChannelTypeEnum {}
/// Nested message and enum types in `AdvertisingChannelTypeEnum`.
pub mod advertising_channel_type_enum {
    /// Enum describing the various advertising channel types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdvertisingChannelType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Search Network. Includes display bundled, and Search+ campaigns.
        Search = 2,
        /// Google Display Network only.
        Display = 3,
        /// Shopping campaigns serve on the shopping property
        /// and on google.com search results.
        Shopping = 4,
        /// Hotel Ads campaigns.
        Hotel = 5,
        /// Video campaigns.
        Video = 6,
        /// App Campaigns, and App Campaigns for Engagement, that run
        /// across multiple channels.
        MultiChannel = 7,
        /// Local ads campaigns.
        Local = 8,
        /// Smart campaigns.
        Smart = 9,
        /// Performance Max campaigns.
        PerformanceMax = 10,
        /// Local services campaigns.
        LocalServices = 11,
        /// Discovery campaigns.
        Discovery = 12,
        /// Travel campaigns.
        Travel = 13,
    }
    impl AdvertisingChannelType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Search => "SEARCH",
                Self::Display => "DISPLAY",
                Self::Shopping => "SHOPPING",
                Self::Hotel => "HOTEL",
                Self::Video => "VIDEO",
                Self::MultiChannel => "MULTI_CHANNEL",
                Self::Local => "LOCAL",
                Self::Smart => "SMART",
                Self::PerformanceMax => "PERFORMANCE_MAX",
                Self::LocalServices => "LOCAL_SERVICES",
                Self::Discovery => "DISCOVERY",
                Self::Travel => "TRAVEL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEARCH" => Some(Self::Search),
                "DISPLAY" => Some(Self::Display),
                "SHOPPING" => Some(Self::Shopping),
                "HOTEL" => Some(Self::Hotel),
                "VIDEO" => Some(Self::Video),
                "MULTI_CHANNEL" => Some(Self::MultiChannel),
                "LOCAL" => Some(Self::Local),
                "SMART" => Some(Self::Smart),
                "PERFORMANCE_MAX" => Some(Self::PerformanceMax),
                "LOCAL_SERVICES" => Some(Self::LocalServices),
                "DISCOVERY" => Some(Self::Discovery),
                "TRAVEL" => Some(Self::Travel),
                _ => None,
            }
        }
    }
}
/// Describes channel availability mode for a criterion availability - whether
/// the availability is meant to include all advertising channels, or a
/// particular channel with all its channel subtypes, or a channel with a certain
/// subset of channel subtypes.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CriterionCategoryChannelAvailabilityModeEnum {}
/// Nested message and enum types in `CriterionCategoryChannelAvailabilityModeEnum`.
pub mod criterion_category_channel_availability_mode_enum {
    /// Enum containing the possible CriterionCategoryChannelAvailabilityMode.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CriterionCategoryChannelAvailabilityMode {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The category is available to campaigns of all channel types and subtypes.
        AllChannels = 2,
        /// The category is available to campaigns of a specific channel type,
        /// including all subtypes under it.
        ChannelTypeAndAllSubtypes = 3,
        /// The category is available to campaigns of a specific channel type and
        /// subtype(s).
        ChannelTypeAndSubsetSubtypes = 4,
    }
    impl CriterionCategoryChannelAvailabilityMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AllChannels => "ALL_CHANNELS",
                Self::ChannelTypeAndAllSubtypes => "CHANNEL_TYPE_AND_ALL_SUBTYPES",
                Self::ChannelTypeAndSubsetSubtypes => "CHANNEL_TYPE_AND_SUBSET_SUBTYPES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ALL_CHANNELS" => Some(Self::AllChannels),
                "CHANNEL_TYPE_AND_ALL_SUBTYPES" => Some(Self::ChannelTypeAndAllSubtypes),
                "CHANNEL_TYPE_AND_SUBSET_SUBTYPES" => {
                    Some(Self::ChannelTypeAndSubsetSubtypes)
                }
                _ => None,
            }
        }
    }
}
/// Describes locale availability mode for a criterion availability - whether
/// it's available globally, or a particular country with all languages, or a
/// particular language with all countries, or a country-language pair.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CriterionCategoryLocaleAvailabilityModeEnum {}
/// Nested message and enum types in `CriterionCategoryLocaleAvailabilityModeEnum`.
pub mod criterion_category_locale_availability_mode_enum {
    /// Enum containing the possible CriterionCategoryLocaleAvailabilityMode.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CriterionCategoryLocaleAvailabilityMode {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The category is available to campaigns of all locales.
        AllLocales = 2,
        /// The category is available to campaigns within a list of countries,
        /// regardless of language.
        CountryAndAllLanguages = 3,
        /// The category is available to campaigns within a list of languages,
        /// regardless of country.
        LanguageAndAllCountries = 4,
        /// The category is available to campaigns within a list of country, language
        /// pairs.
        CountryAndLanguage = 5,
    }
    impl CriterionCategoryLocaleAvailabilityMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AllLocales => "ALL_LOCALES",
                Self::CountryAndAllLanguages => "COUNTRY_AND_ALL_LANGUAGES",
                Self::LanguageAndAllCountries => "LANGUAGE_AND_ALL_COUNTRIES",
                Self::CountryAndLanguage => "COUNTRY_AND_LANGUAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ALL_LOCALES" => Some(Self::AllLocales),
                "COUNTRY_AND_ALL_LANGUAGES" => Some(Self::CountryAndAllLanguages),
                "LANGUAGE_AND_ALL_COUNTRIES" => Some(Self::LanguageAndAllCountries),
                "COUNTRY_AND_LANGUAGE" => Some(Self::CountryAndLanguage),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible types of a customizer attribute.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomizerAttributeTypeEnum {}
/// Nested message and enum types in `CustomizerAttributeTypeEnum`.
pub mod customizer_attribute_type_enum {
    /// The possible types of a customizer attribute.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomizerAttributeType {
        /// The status has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        Unknown = 1,
        /// Text customizer.
        Text = 2,
        /// Number customizer.
        Number = 3,
        /// Price customizer consisting of a number and a currency.
        Price = 4,
        /// Percentage customizer consisting of a number and a '%'.
        Percent = 5,
    }
    impl CustomizerAttributeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Text => "TEXT",
                Self::Number => "NUMBER",
                Self::Price => "PRICE",
                Self::Percent => "PERCENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TEXT" => Some(Self::Text),
                "NUMBER" => Some(Self::Number),
                "PRICE" => Some(Self::Price),
                "PERCENT" => Some(Self::Percent),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of months of the year, for example, "January".
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MonthOfYearEnum {}
/// Nested message and enum types in `MonthOfYearEnum`.
pub mod month_of_year_enum {
    /// Enumerates months of the year, for example, "January".
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MonthOfYear {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// January.
        January = 2,
        /// February.
        February = 3,
        /// March.
        March = 4,
        /// April.
        April = 5,
        /// May.
        May = 6,
        /// June.
        June = 7,
        /// July.
        July = 8,
        /// August.
        August = 9,
        /// September.
        September = 10,
        /// October.
        October = 11,
        /// November.
        November = 12,
        /// December.
        December = 13,
    }
    impl MonthOfYear {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::January => "JANUARY",
                Self::February => "FEBRUARY",
                Self::March => "MARCH",
                Self::April => "APRIL",
                Self::May => "MAY",
                Self::June => "JUNE",
                Self::July => "JULY",
                Self::August => "AUGUST",
                Self::September => "SEPTEMBER",
                Self::October => "OCTOBER",
                Self::November => "NOVEMBER",
                Self::December => "DECEMBER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "JANUARY" => Some(Self::January),
                "FEBRUARY" => Some(Self::February),
                "MARCH" => Some(Self::March),
                "APRIL" => Some(Self::April),
                "MAY" => Some(Self::May),
                "JUNE" => Some(Self::June),
                "JULY" => Some(Self::July),
                "AUGUST" => Some(Self::August),
                "SEPTEMBER" => Some(Self::September),
                "OCTOBER" => Some(Self::October),
                "NOVEMBER" => Some(Self::November),
                "DECEMBER" => Some(Self::December),
                _ => None,
            }
        }
    }
}
/// Container for enum describing app store type in an app extension.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppStoreEnum {}
/// Nested message and enum types in `AppStoreEnum`.
pub mod app_store_enum {
    /// App store type in an app extension.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AppStore {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Apple iTunes.
        AppleItunes = 2,
        /// Google Play.
        GooglePlay = 3,
    }
    impl AppStore {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AppleItunes => "APPLE_ITUNES",
                Self::GooglePlay => "GOOGLE_PLAY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APPLE_ITUNES" => Some(Self::AppleItunes),
                "GOOGLE_PLAY" => Some(Self::GooglePlay),
                _ => None,
            }
        }
    }
}
/// The type of string matching to be used for a dynamic FeedItemSet filter.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemSetStringFilterTypeEnum {}
/// Nested message and enum types in `FeedItemSetStringFilterTypeEnum`.
pub mod feed_item_set_string_filter_type_enum {
    /// describe the possible types for a FeedItemSetStringFilter.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemSetStringFilterType {
        /// Not specified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The dynamic set filter will use exact string matching.
        Exact = 2,
    }
    impl FeedItemSetStringFilterType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Exact => "EXACT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXACT" => Some(Self::Exact),
                _ => None,
            }
        }
    }
}
/// The possible OS types for a deeplink AppUrl.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppUrlOperatingSystemTypeEnum {}
/// Nested message and enum types in `AppUrlOperatingSystemTypeEnum`.
pub mod app_url_operating_system_type_enum {
    /// Operating System
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AppUrlOperatingSystemType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The Apple IOS operating system.
        Ios = 2,
        /// The Android operating system.
        Android = 3,
    }
    impl AppUrlOperatingSystemType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Ios => "IOS",
                Self::Android => "ANDROID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "IOS" => Some(Self::Ios),
                "ANDROID" => Some(Self::Android),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of event that the cap applies to.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FrequencyCapEventTypeEnum {}
/// Nested message and enum types in `FrequencyCapEventTypeEnum`.
pub mod frequency_cap_event_type_enum {
    /// The type of event that the cap applies to (for example, impression).
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FrequencyCapEventType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The cap applies on ad impressions.
        Impression = 2,
        /// The cap applies on video ad views.
        VideoView = 3,
    }
    impl FrequencyCapEventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Impression => "IMPRESSION",
                Self::VideoView => "VIDEO_VIEW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "IMPRESSION" => Some(Self::Impression),
                "VIDEO_VIEW" => Some(Self::VideoView),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the level on which the cap is to be applied.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FrequencyCapLevelEnum {}
/// Nested message and enum types in `FrequencyCapLevelEnum`.
pub mod frequency_cap_level_enum {
    /// The level on which the cap is to be applied (e.g ad group ad, ad group).
    /// Cap is applied to all the resources of this level.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FrequencyCapLevel {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The cap is applied at the ad group ad level.
        AdGroupAd = 2,
        /// The cap is applied at the ad group level.
        AdGroup = 3,
        /// The cap is applied at the campaign level.
        Campaign = 4,
    }
    impl FrequencyCapLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AdGroupAd => "AD_GROUP_AD",
                Self::AdGroup => "AD_GROUP",
                Self::Campaign => "CAMPAIGN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_GROUP_AD" => Some(Self::AdGroupAd),
                "AD_GROUP" => Some(Self::AdGroup),
                "CAMPAIGN" => Some(Self::Campaign),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the unit of time the cap is defined at.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FrequencyCapTimeUnitEnum {}
/// Nested message and enum types in `FrequencyCapTimeUnitEnum`.
pub mod frequency_cap_time_unit_enum {
    /// Unit of time the cap is defined at (for example, day, week).
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FrequencyCapTimeUnit {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The cap would define limit per one day.
        Day = 2,
        /// The cap would define limit per one week.
        Week = 3,
        /// The cap would define limit per one month.
        Month = 4,
    }
    impl FrequencyCapTimeUnit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Day => "DAY",
                Self::Week => "WEEK",
                Self::Month => "MONTH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DAY" => Some(Self::Day),
                "WEEK" => Some(Self::Week),
                "MONTH" => Some(Self::Month),
                _ => None,
            }
        }
    }
}
/// The enumeration of keyword plan aggregate metric types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanAggregateMetricTypeEnum {}
/// Nested message and enum types in `KeywordPlanAggregateMetricTypeEnum`.
pub mod keyword_plan_aggregate_metric_type_enum {
    /// Aggregate fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanAggregateMetricType {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// The device breakdown of aggregate search volume.
        Device = 2,
    }
    impl KeywordPlanAggregateMetricType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Device => "DEVICE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DEVICE" => Some(Self::Device),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of keyword competition levels. The competition
/// level indicates how competitive ad placement is for a keyword and
/// is determined by the number of advertisers bidding on that keyword relative
/// to all keywords across Google. The competition level can depend on the
/// location and Search Network targeting options you've selected.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanCompetitionLevelEnum {}
/// Nested message and enum types in `KeywordPlanCompetitionLevelEnum`.
pub mod keyword_plan_competition_level_enum {
    /// Competition level of a keyword.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanCompetitionLevel {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Low competition. The Competition Index range for this is \[0, 33\].
        Low = 2,
        /// Medium competition. The Competition Index range for this is \[34, 66\].
        Medium = 3,
        /// High competition. The Competition Index range for this is \[67, 100\].
        High = 4,
    }
    impl KeywordPlanCompetitionLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Low => "LOW",
                Self::Medium => "MEDIUM",
                Self::High => "HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LOW" => Some(Self::Low),
                "MEDIUM" => Some(Self::Medium),
                "HIGH" => Some(Self::High),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of keyword plan concept group types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanConceptGroupTypeEnum {}
/// Nested message and enum types in `KeywordPlanConceptGroupTypeEnum`.
pub mod keyword_plan_concept_group_type_enum {
    /// Enumerates keyword plan concept group types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanConceptGroupType {
        /// The concept group classification different from brand/non-brand.
        /// This is a catch all bucket for all classifications that are none of the
        /// below.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// The concept group classification is based on BRAND.
        Brand = 2,
        /// The concept group classification based on BRAND, that didn't fit well
        /// with the BRAND classifications. These are generally outliers and can have
        /// very few keywords in this type of classification.
        OtherBrands = 3,
        /// These concept group classification is not based on BRAND. This is
        /// returned for generic keywords that don't have a brand association.
        NonBrand = 4,
    }
    impl KeywordPlanConceptGroupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Brand => "BRAND",
                Self::OtherBrands => "OTHER_BRANDS",
                Self::NonBrand => "NON_BRAND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BRAND" => Some(Self::Brand),
                "OTHER_BRANDS" => Some(Self::OtherBrands),
                "NON_BRAND" => Some(Self::NonBrand),
                _ => None,
            }
        }
    }
}
/// Container for context types for an operand in a matching function.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MatchingFunctionContextTypeEnum {}
/// Nested message and enum types in `MatchingFunctionContextTypeEnum`.
pub mod matching_function_context_type_enum {
    /// Possible context types for an operand in a matching function.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MatchingFunctionContextType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Feed item id in the request context.
        FeedItemId = 2,
        /// The device being used (possible values are 'Desktop' or 'Mobile').
        DeviceName = 3,
        /// Feed item set id in the request context.
        FeedItemSetId = 4,
    }
    impl MatchingFunctionContextType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::FeedItemId => "FEED_ITEM_ID",
                Self::DeviceName => "DEVICE_NAME",
                Self::FeedItemSetId => "FEED_ITEM_SET_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FEED_ITEM_ID" => Some(Self::FeedItemId),
                "DEVICE_NAME" => Some(Self::DeviceName),
                "FEED_ITEM_SET_ID" => Some(Self::FeedItemSetId),
                _ => None,
            }
        }
    }
}
/// Container for enum describing matching function operator.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MatchingFunctionOperatorEnum {}
/// Nested message and enum types in `MatchingFunctionOperatorEnum`.
pub mod matching_function_operator_enum {
    /// Possible operators in a matching function.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MatchingFunctionOperator {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The IN operator.
        In = 2,
        /// The IDENTITY operator.
        Identity = 3,
        /// The EQUALS operator
        Equals = 4,
        /// Operator that takes two or more operands that are of type
        /// FunctionOperand and checks that all the operands evaluate to true.
        /// For functions related to ad formats, all the operands must be in
        /// left_operands.
        And = 5,
        /// Operator that returns true if the elements in left_operands contain any
        /// of the elements in right_operands. Otherwise, return false. The
        /// right_operands must contain at least 1 and no more than 3
        /// ConstantOperands.
        ContainsAny = 6,
    }
    impl MatchingFunctionOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::In => "IN",
                Self::Identity => "IDENTITY",
                Self::Equals => "EQUALS",
                Self::And => "AND",
                Self::ContainsAny => "CONTAINS_ANY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "IN" => Some(Self::In),
                "IDENTITY" => Some(Self::Identity),
                "EQUALS" => Some(Self::Equals),
                "AND" => Some(Self::And),
                "CONTAINS_ANY" => Some(Self::ContainsAny),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of experiment metric.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExperimentMetricEnum {}
/// Nested message and enum types in `ExperimentMetricEnum`.
pub mod experiment_metric_enum {
    /// The type of experiment metric.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExperimentMetric {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// The goal of the experiment is clicks.
        Clicks = 2,
        /// The goal of the experiment is impressions.
        Impressions = 3,
        /// The goal of the experiment is cost.
        Cost = 4,
        /// The goal of the experiment is conversion rate.
        ConversionsPerInteractionRate = 5,
        /// The goal of the experiment is cost per conversion.
        CostPerConversion = 6,
        /// The goal of the experiment is conversion value per cost.
        ConversionsValuePerCost = 7,
        /// The goal of the experiment is avg cpc.
        AverageCpc = 8,
        /// The goal of the experiment is ctr.
        Ctr = 9,
        /// The goal of the experiment is incremental conversions.
        IncrementalConversions = 10,
        /// The goal of the experiment is completed video views.
        CompletedVideoViews = 11,
        /// The goal of the experiment is custom algorithms.
        CustomAlgorithms = 12,
        /// The goal of the experiment is conversions.
        Conversions = 13,
        /// The goal of the experiment is conversion value.
        ConversionValue = 14,
    }
    impl ExperimentMetric {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Clicks => "CLICKS",
                Self::Impressions => "IMPRESSIONS",
                Self::Cost => "COST",
                Self::ConversionsPerInteractionRate => "CONVERSIONS_PER_INTERACTION_RATE",
                Self::CostPerConversion => "COST_PER_CONVERSION",
                Self::ConversionsValuePerCost => "CONVERSIONS_VALUE_PER_COST",
                Self::AverageCpc => "AVERAGE_CPC",
                Self::Ctr => "CTR",
                Self::IncrementalConversions => "INCREMENTAL_CONVERSIONS",
                Self::CompletedVideoViews => "COMPLETED_VIDEO_VIEWS",
                Self::CustomAlgorithms => "CUSTOM_ALGORITHMS",
                Self::Conversions => "CONVERSIONS",
                Self::ConversionValue => "CONVERSION_VALUE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CLICKS" => Some(Self::Clicks),
                "IMPRESSIONS" => Some(Self::Impressions),
                "COST" => Some(Self::Cost),
                "CONVERSIONS_PER_INTERACTION_RATE" => {
                    Some(Self::ConversionsPerInteractionRate)
                }
                "COST_PER_CONVERSION" => Some(Self::CostPerConversion),
                "CONVERSIONS_VALUE_PER_COST" => Some(Self::ConversionsValuePerCost),
                "AVERAGE_CPC" => Some(Self::AverageCpc),
                "CTR" => Some(Self::Ctr),
                "INCREMENTAL_CONVERSIONS" => Some(Self::IncrementalConversions),
                "COMPLETED_VIDEO_VIEWS" => Some(Self::CompletedVideoViews),
                "CUSTOM_ALGORITHMS" => Some(Self::CustomAlgorithms),
                "CONVERSIONS" => Some(Self::Conversions),
                "CONVERSION_VALUE" => Some(Self::ConversionValue),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of experiment metric direction.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExperimentMetricDirectionEnum {}
/// Nested message and enum types in `ExperimentMetricDirectionEnum`.
pub mod experiment_metric_direction_enum {
    /// The type of experiment metric direction.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExperimentMetricDirection {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// The goal of the experiment is to not change the metric.
        NoChange = 2,
        /// The goal of the experiment is to increate the metric.
        Increase = 3,
        /// The goal of the experiment is to decrease the metric.
        Decrease = 4,
        /// The goal of the experiment is to either not change or increase the
        /// metric.
        NoChangeOrIncrease = 5,
        /// The goal of the experiment is to either not change or decrease the
        /// metric.
        NoChangeOrDecrease = 6,
    }
    impl ExperimentMetricDirection {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NoChange => "NO_CHANGE",
                Self::Increase => "INCREASE",
                Self::Decrease => "DECREASE",
                Self::NoChangeOrIncrease => "NO_CHANGE_OR_INCREASE",
                Self::NoChangeOrDecrease => "NO_CHANGE_OR_DECREASE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NO_CHANGE" => Some(Self::NoChange),
                "INCREASE" => Some(Self::Increase),
                "DECREASE" => Some(Self::Decrease),
                "NO_CHANGE_OR_INCREASE" => Some(Self::NoChangeOrIncrease),
                "NO_CHANGE_OR_DECREASE" => Some(Self::NoChangeOrDecrease),
                _ => None,
            }
        }
    }
}
/// Container for enum describing types of payable and free interactions.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InteractionEventTypeEnum {}
/// Nested message and enum types in `InteractionEventTypeEnum`.
pub mod interaction_event_type_enum {
    /// Enum describing possible types of payable and free interactions.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InteractionEventType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Click to site. In most cases, this interaction navigates to an external
        /// location, usually the advertiser's landing page. This is also the default
        /// InteractionEventType for click events.
        Click = 2,
        /// The user's expressed intent to engage with the ad in-place.
        Engagement = 3,
        /// User viewed a video ad.
        VideoView = 4,
        /// The default InteractionEventType for ad conversion events.
        /// This is used when an ad conversion row does NOT indicate
        /// that the free interactions (for example, the ad conversions)
        /// should be 'promoted' and reported as part of the core metrics.
        /// These are simply other (ad) conversions.
        None = 5,
    }
    impl InteractionEventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Click => "CLICK",
                Self::Engagement => "ENGAGEMENT",
                Self::VideoView => "VIDEO_VIEW",
                Self::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CLICK" => Some(Self::Click),
                "ENGAGEMENT" => Some(Self::Engagement),
                "VIDEO_VIEW" => Some(Self::VideoView),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
/// The relative performance compared to other advertisers.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QualityScoreBucketEnum {}
/// Nested message and enum types in `QualityScoreBucketEnum`.
pub mod quality_score_bucket_enum {
    /// Enum listing the possible quality score buckets.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum QualityScoreBucket {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Quality of the creative is below average.
        BelowAverage = 2,
        /// Quality of the creative is average.
        Average = 3,
        /// Quality of the creative is above average.
        AboveAverage = 4,
    }
    impl QualityScoreBucket {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::BelowAverage => "BELOW_AVERAGE",
                Self::Average => "AVERAGE",
                Self::AboveAverage => "ABOVE_AVERAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BELOW_AVERAGE" => Some(Self::BelowAverage),
                "AVERAGE" => Some(Self::Average),
                "ABOVE_AVERAGE" => Some(Self::AboveAverage),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the source of the user identifier for offline
/// Store Sales, click conversion, and conversion adjustment uploads.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserIdentifierSourceEnum {}
/// Nested message and enum types in `UserIdentifierSourceEnum`.
pub mod user_identifier_source_enum {
    /// The type of user identifier source for offline Store Sales, click
    /// conversion, and conversion adjustment uploads.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserIdentifierSource {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version
        Unknown = 1,
        /// Indicates that the user identifier was provided by the first party
        /// (advertiser).
        FirstParty = 2,
        /// Indicates that the user identifier was provided by the third party
        /// (partner).
        ThirdParty = 3,
    }
    impl UserIdentifierSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::FirstParty => "FIRST_PARTY",
                Self::ThirdParty => "THIRD_PARTY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FIRST_PARTY" => Some(Self::FirstParty),
                "THIRD_PARTY" => Some(Self::ThirdParty),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of Google Ads destination types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdDestinationTypeEnum {}
/// Nested message and enum types in `AdDestinationTypeEnum`.
pub mod ad_destination_type_enum {
    /// Enumerates Google Ads destination types
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdDestinationType {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Ads that don't intend to drive users off from ads to other destinations
        NotApplicable = 2,
        /// Website
        Website = 3,
        /// App Deep Link
        AppDeepLink = 4,
        /// iOS App Store or Play Store
        AppStore = 5,
        /// Call Dialer
        PhoneCall = 6,
        /// Map App
        MapDirections = 7,
        /// Location Dedicated Page
        LocationListing = 8,
        /// Text Message
        Message = 9,
        /// Lead Generation Form
        LeadForm = 10,
        /// YouTube
        Youtube = 11,
        /// Ad Destination for Conversions with keys unknown
        UnmodeledForConversions = 12,
    }
    impl AdDestinationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NotApplicable => "NOT_APPLICABLE",
                Self::Website => "WEBSITE",
                Self::AppDeepLink => "APP_DEEP_LINK",
                Self::AppStore => "APP_STORE",
                Self::PhoneCall => "PHONE_CALL",
                Self::MapDirections => "MAP_DIRECTIONS",
                Self::LocationListing => "LOCATION_LISTING",
                Self::Message => "MESSAGE",
                Self::LeadForm => "LEAD_FORM",
                Self::Youtube => "YOUTUBE",
                Self::UnmodeledForConversions => "UNMODELED_FOR_CONVERSIONS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOT_APPLICABLE" => Some(Self::NotApplicable),
                "WEBSITE" => Some(Self::Website),
                "APP_DEEP_LINK" => Some(Self::AppDeepLink),
                "APP_STORE" => Some(Self::AppStore),
                "PHONE_CALL" => Some(Self::PhoneCall),
                "MAP_DIRECTIONS" => Some(Self::MapDirections),
                "LOCATION_LISTING" => Some(Self::LocationListing),
                "MESSAGE" => Some(Self::Message),
                "LEAD_FORM" => Some(Self::LeadForm),
                "YOUTUBE" => Some(Self::Youtube),
                "UNMODELED_FOR_CONVERSIONS" => Some(Self::UnmodeledForConversions),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of Google Ads network types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdNetworkTypeEnum {}
/// Nested message and enum types in `AdNetworkTypeEnum`.
pub mod ad_network_type_enum {
    /// Enumerates Google Ads network types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdNetworkType {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Google search.
        Search = 2,
        /// Search partners.
        SearchPartners = 3,
        /// Display Network.
        Content = 4,
        /// Cross-network.
        Mixed = 7,
        /// YouTube
        Youtube = 8,
        /// Google TV
        GoogleTv = 9,
    }
    impl AdNetworkType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Search => "SEARCH",
                Self::SearchPartners => "SEARCH_PARTNERS",
                Self::Content => "CONTENT",
                Self::Mixed => "MIXED",
                Self::Youtube => "YOUTUBE",
                Self::GoogleTv => "GOOGLE_TV",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEARCH" => Some(Self::Search),
                "SEARCH_PARTNERS" => Some(Self::SearchPartners),
                "CONTENT" => Some(Self::Content),
                "MIXED" => Some(Self::Mixed),
                "YOUTUBE" => Some(Self::Youtube),
                "GOOGLE_TV" => Some(Self::GoogleTv),
                _ => None,
            }
        }
    }
}
/// Message describing the status of the association between the Budget and the
/// Campaign.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BudgetCampaignAssociationStatusEnum {}
/// Nested message and enum types in `BudgetCampaignAssociationStatusEnum`.
pub mod budget_campaign_association_status_enum {
    /// Possible statuses of the association between the Budget and the Campaign.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BudgetCampaignAssociationStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The campaign is currently using the budget.
        Enabled = 2,
        /// The campaign is no longer using the budget.
        Removed = 3,
    }
    impl BudgetCampaignAssociationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of Google Ads click types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClickTypeEnum {}
/// Nested message and enum types in `ClickTypeEnum`.
pub mod click_type_enum {
    /// Enumerates Google Ads click types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ClickType {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// App engagement ad deep link.
        AppDeeplink = 2,
        /// Breadcrumbs.
        Breadcrumbs = 3,
        /// Broadband Plan.
        BroadbandPlan = 4,
        /// Manually dialed phone calls.
        CallTracking = 5,
        /// Phone calls.
        Calls = 6,
        /// Click on engagement ad.
        ClickOnEngagementAd = 7,
        /// Driving direction.
        GetDirections = 8,
        /// Get location details.
        LocationExpansion = 9,
        /// Call.
        LocationFormatCall = 10,
        /// Directions.
        LocationFormatDirections = 11,
        /// Image(s).
        LocationFormatImage = 12,
        /// Go to landing page.
        LocationFormatLandingPage = 13,
        /// Map.
        LocationFormatMap = 14,
        /// Go to store info.
        LocationFormatStoreInfo = 15,
        /// Text.
        LocationFormatText = 16,
        /// Mobile phone calls.
        MobileCallTracking = 17,
        /// Print offer.
        OfferPrints = 18,
        /// Other.
        Other = 19,
        /// Product plusbox offer.
        ProductExtensionClicks = 20,
        /// Shopping - Product - Online.
        ProductListingAdClicks = 21,
        /// Sitelink.
        Sitelinks = 22,
        /// Show nearby locations.
        StoreLocator = 23,
        /// Headline.
        UrlClicks = 25,
        /// App store.
        VideoAppStoreClicks = 26,
        /// Call-to-Action overlay.
        VideoCallToActionClicks = 27,
        /// Cards.
        VideoCardActionHeadlineClicks = 28,
        /// End cap.
        VideoEndCapClicks = 29,
        /// Website.
        VideoWebsiteClicks = 30,
        /// Visual Sitelinks.
        VisualSitelinks = 31,
        /// Wireless Plan.
        WirelessPlan = 32,
        /// Shopping - Product - Local.
        ProductListingAdLocal = 33,
        /// Shopping - Product - MultiChannel Local.
        ProductListingAdMultichannelLocal = 34,
        /// Shopping - Product - MultiChannel Online.
        ProductListingAdMultichannelOnline = 35,
        /// Shopping - Product - Coupon.
        ProductListingAdsCoupon = 36,
        /// Shopping - Product - Sell on Google.
        ProductListingAdTransactable = 37,
        /// Shopping - Product - App engagement ad deep link.
        ProductAdAppDeeplink = 38,
        /// Shopping - Showcase - Category.
        ShowcaseAdCategoryLink = 39,
        /// Shopping - Showcase - Local storefront.
        ShowcaseAdLocalStorefrontLink = 40,
        /// Shopping - Showcase - Online product.
        ShowcaseAdOnlineProductLink = 42,
        /// Shopping - Showcase - Local product.
        ShowcaseAdLocalProductLink = 43,
        /// Promotion Extension.
        PromotionExtension = 44,
        /// Ad Headline.
        SwipeableGalleryAdHeadline = 45,
        /// Swipes.
        SwipeableGalleryAdSwipes = 46,
        /// See More.
        SwipeableGalleryAdSeeMore = 47,
        /// Sitelink 1.
        SwipeableGalleryAdSitelinkOne = 48,
        /// Sitelink 2.
        SwipeableGalleryAdSitelinkTwo = 49,
        /// Sitelink 3.
        SwipeableGalleryAdSitelinkThree = 50,
        /// Sitelink 4.
        SwipeableGalleryAdSitelinkFour = 51,
        /// Sitelink 5.
        SwipeableGalleryAdSitelinkFive = 52,
        /// Hotel price.
        HotelPrice = 53,
        /// Price Extension.
        PriceExtension = 54,
        /// Book on Google hotel room selection.
        HotelBookOnGoogleRoomSelection = 55,
        /// Shopping - Comparison Listing.
        ShoppingComparisonListing = 56,
        /// Cross-network. From Performance Max and Discovery Campaigns.
        CrossNetwork = 57,
    }
    impl ClickType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AppDeeplink => "APP_DEEPLINK",
                Self::Breadcrumbs => "BREADCRUMBS",
                Self::BroadbandPlan => "BROADBAND_PLAN",
                Self::CallTracking => "CALL_TRACKING",
                Self::Calls => "CALLS",
                Self::ClickOnEngagementAd => "CLICK_ON_ENGAGEMENT_AD",
                Self::GetDirections => "GET_DIRECTIONS",
                Self::LocationExpansion => "LOCATION_EXPANSION",
                Self::LocationFormatCall => "LOCATION_FORMAT_CALL",
                Self::LocationFormatDirections => "LOCATION_FORMAT_DIRECTIONS",
                Self::LocationFormatImage => "LOCATION_FORMAT_IMAGE",
                Self::LocationFormatLandingPage => "LOCATION_FORMAT_LANDING_PAGE",
                Self::LocationFormatMap => "LOCATION_FORMAT_MAP",
                Self::LocationFormatStoreInfo => "LOCATION_FORMAT_STORE_INFO",
                Self::LocationFormatText => "LOCATION_FORMAT_TEXT",
                Self::MobileCallTracking => "MOBILE_CALL_TRACKING",
                Self::OfferPrints => "OFFER_PRINTS",
                Self::Other => "OTHER",
                Self::ProductExtensionClicks => "PRODUCT_EXTENSION_CLICKS",
                Self::ProductListingAdClicks => "PRODUCT_LISTING_AD_CLICKS",
                Self::Sitelinks => "SITELINKS",
                Self::StoreLocator => "STORE_LOCATOR",
                Self::UrlClicks => "URL_CLICKS",
                Self::VideoAppStoreClicks => "VIDEO_APP_STORE_CLICKS",
                Self::VideoCallToActionClicks => "VIDEO_CALL_TO_ACTION_CLICKS",
                Self::VideoCardActionHeadlineClicks => {
                    "VIDEO_CARD_ACTION_HEADLINE_CLICKS"
                }
                Self::VideoEndCapClicks => "VIDEO_END_CAP_CLICKS",
                Self::VideoWebsiteClicks => "VIDEO_WEBSITE_CLICKS",
                Self::VisualSitelinks => "VISUAL_SITELINKS",
                Self::WirelessPlan => "WIRELESS_PLAN",
                Self::ProductListingAdLocal => "PRODUCT_LISTING_AD_LOCAL",
                Self::ProductListingAdMultichannelLocal => {
                    "PRODUCT_LISTING_AD_MULTICHANNEL_LOCAL"
                }
                Self::ProductListingAdMultichannelOnline => {
                    "PRODUCT_LISTING_AD_MULTICHANNEL_ONLINE"
                }
                Self::ProductListingAdsCoupon => "PRODUCT_LISTING_ADS_COUPON",
                Self::ProductListingAdTransactable => "PRODUCT_LISTING_AD_TRANSACTABLE",
                Self::ProductAdAppDeeplink => "PRODUCT_AD_APP_DEEPLINK",
                Self::ShowcaseAdCategoryLink => "SHOWCASE_AD_CATEGORY_LINK",
                Self::ShowcaseAdLocalStorefrontLink => {
                    "SHOWCASE_AD_LOCAL_STOREFRONT_LINK"
                }
                Self::ShowcaseAdOnlineProductLink => "SHOWCASE_AD_ONLINE_PRODUCT_LINK",
                Self::ShowcaseAdLocalProductLink => "SHOWCASE_AD_LOCAL_PRODUCT_LINK",
                Self::PromotionExtension => "PROMOTION_EXTENSION",
                Self::SwipeableGalleryAdHeadline => "SWIPEABLE_GALLERY_AD_HEADLINE",
                Self::SwipeableGalleryAdSwipes => "SWIPEABLE_GALLERY_AD_SWIPES",
                Self::SwipeableGalleryAdSeeMore => "SWIPEABLE_GALLERY_AD_SEE_MORE",
                Self::SwipeableGalleryAdSitelinkOne => {
                    "SWIPEABLE_GALLERY_AD_SITELINK_ONE"
                }
                Self::SwipeableGalleryAdSitelinkTwo => {
                    "SWIPEABLE_GALLERY_AD_SITELINK_TWO"
                }
                Self::SwipeableGalleryAdSitelinkThree => {
                    "SWIPEABLE_GALLERY_AD_SITELINK_THREE"
                }
                Self::SwipeableGalleryAdSitelinkFour => {
                    "SWIPEABLE_GALLERY_AD_SITELINK_FOUR"
                }
                Self::SwipeableGalleryAdSitelinkFive => {
                    "SWIPEABLE_GALLERY_AD_SITELINK_FIVE"
                }
                Self::HotelPrice => "HOTEL_PRICE",
                Self::PriceExtension => "PRICE_EXTENSION",
                Self::HotelBookOnGoogleRoomSelection => {
                    "HOTEL_BOOK_ON_GOOGLE_ROOM_SELECTION"
                }
                Self::ShoppingComparisonListing => "SHOPPING_COMPARISON_LISTING",
                Self::CrossNetwork => "CROSS_NETWORK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APP_DEEPLINK" => Some(Self::AppDeeplink),
                "BREADCRUMBS" => Some(Self::Breadcrumbs),
                "BROADBAND_PLAN" => Some(Self::BroadbandPlan),
                "CALL_TRACKING" => Some(Self::CallTracking),
                "CALLS" => Some(Self::Calls),
                "CLICK_ON_ENGAGEMENT_AD" => Some(Self::ClickOnEngagementAd),
                "GET_DIRECTIONS" => Some(Self::GetDirections),
                "LOCATION_EXPANSION" => Some(Self::LocationExpansion),
                "LOCATION_FORMAT_CALL" => Some(Self::LocationFormatCall),
                "LOCATION_FORMAT_DIRECTIONS" => Some(Self::LocationFormatDirections),
                "LOCATION_FORMAT_IMAGE" => Some(Self::LocationFormatImage),
                "LOCATION_FORMAT_LANDING_PAGE" => Some(Self::LocationFormatLandingPage),
                "LOCATION_FORMAT_MAP" => Some(Self::LocationFormatMap),
                "LOCATION_FORMAT_STORE_INFO" => Some(Self::LocationFormatStoreInfo),
                "LOCATION_FORMAT_TEXT" => Some(Self::LocationFormatText),
                "MOBILE_CALL_TRACKING" => Some(Self::MobileCallTracking),
                "OFFER_PRINTS" => Some(Self::OfferPrints),
                "OTHER" => Some(Self::Other),
                "PRODUCT_EXTENSION_CLICKS" => Some(Self::ProductExtensionClicks),
                "PRODUCT_LISTING_AD_CLICKS" => Some(Self::ProductListingAdClicks),
                "SITELINKS" => Some(Self::Sitelinks),
                "STORE_LOCATOR" => Some(Self::StoreLocator),
                "URL_CLICKS" => Some(Self::UrlClicks),
                "VIDEO_APP_STORE_CLICKS" => Some(Self::VideoAppStoreClicks),
                "VIDEO_CALL_TO_ACTION_CLICKS" => Some(Self::VideoCallToActionClicks),
                "VIDEO_CARD_ACTION_HEADLINE_CLICKS" => {
                    Some(Self::VideoCardActionHeadlineClicks)
                }
                "VIDEO_END_CAP_CLICKS" => Some(Self::VideoEndCapClicks),
                "VIDEO_WEBSITE_CLICKS" => Some(Self::VideoWebsiteClicks),
                "VISUAL_SITELINKS" => Some(Self::VisualSitelinks),
                "WIRELESS_PLAN" => Some(Self::WirelessPlan),
                "PRODUCT_LISTING_AD_LOCAL" => Some(Self::ProductListingAdLocal),
                "PRODUCT_LISTING_AD_MULTICHANNEL_LOCAL" => {
                    Some(Self::ProductListingAdMultichannelLocal)
                }
                "PRODUCT_LISTING_AD_MULTICHANNEL_ONLINE" => {
                    Some(Self::ProductListingAdMultichannelOnline)
                }
                "PRODUCT_LISTING_ADS_COUPON" => Some(Self::ProductListingAdsCoupon),
                "PRODUCT_LISTING_AD_TRANSACTABLE" => {
                    Some(Self::ProductListingAdTransactable)
                }
                "PRODUCT_AD_APP_DEEPLINK" => Some(Self::ProductAdAppDeeplink),
                "SHOWCASE_AD_CATEGORY_LINK" => Some(Self::ShowcaseAdCategoryLink),
                "SHOWCASE_AD_LOCAL_STOREFRONT_LINK" => {
                    Some(Self::ShowcaseAdLocalStorefrontLink)
                }
                "SHOWCASE_AD_ONLINE_PRODUCT_LINK" => {
                    Some(Self::ShowcaseAdOnlineProductLink)
                }
                "SHOWCASE_AD_LOCAL_PRODUCT_LINK" => {
                    Some(Self::ShowcaseAdLocalProductLink)
                }
                "PROMOTION_EXTENSION" => Some(Self::PromotionExtension),
                "SWIPEABLE_GALLERY_AD_HEADLINE" => Some(Self::SwipeableGalleryAdHeadline),
                "SWIPEABLE_GALLERY_AD_SWIPES" => Some(Self::SwipeableGalleryAdSwipes),
                "SWIPEABLE_GALLERY_AD_SEE_MORE" => Some(Self::SwipeableGalleryAdSeeMore),
                "SWIPEABLE_GALLERY_AD_SITELINK_ONE" => {
                    Some(Self::SwipeableGalleryAdSitelinkOne)
                }
                "SWIPEABLE_GALLERY_AD_SITELINK_TWO" => {
                    Some(Self::SwipeableGalleryAdSitelinkTwo)
                }
                "SWIPEABLE_GALLERY_AD_SITELINK_THREE" => {
                    Some(Self::SwipeableGalleryAdSitelinkThree)
                }
                "SWIPEABLE_GALLERY_AD_SITELINK_FOUR" => {
                    Some(Self::SwipeableGalleryAdSitelinkFour)
                }
                "SWIPEABLE_GALLERY_AD_SITELINK_FIVE" => {
                    Some(Self::SwipeableGalleryAdSitelinkFive)
                }
                "HOTEL_PRICE" => Some(Self::HotelPrice),
                "PRICE_EXTENSION" => Some(Self::PriceExtension),
                "HOTEL_BOOK_ON_GOOGLE_ROOM_SELECTION" => {
                    Some(Self::HotelBookOnGoogleRoomSelection)
                }
                "SHOPPING_COMPARISON_LISTING" => Some(Self::ShoppingComparisonListing),
                "CROSS_NETWORK" => Some(Self::CrossNetwork),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the category of conversions that are associated
/// with a ConversionAction.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionActionCategoryEnum {}
/// Nested message and enum types in `ConversionActionCategoryEnum`.
pub mod conversion_action_category_enum {
    /// The category of conversions that are associated with a ConversionAction.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionActionCategory {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Default category.
        Default = 2,
        /// User visiting a page.
        PageView = 3,
        /// Purchase, sales, or "order placed" event.
        Purchase = 4,
        /// Signup user action.
        Signup = 5,
        /// Software download action (as for an app).
        Download = 7,
        /// The addition of items to a shopping cart or bag on an advertiser site.
        AddToCart = 8,
        /// When someone enters the checkout flow on an advertiser site.
        BeginCheckout = 9,
        /// The start of a paid subscription for a product or service.
        SubscribePaid = 10,
        /// A call to indicate interest in an advertiser's offering.
        PhoneCallLead = 11,
        /// A lead conversion imported from an external source into Google Ads.
        ImportedLead = 12,
        /// A submission of a form on an advertiser site indicating business
        /// interest.
        SubmitLeadForm = 13,
        /// A booking of an appointment with an advertiser's business.
        BookAppointment = 14,
        /// A quote or price estimate request.
        RequestQuote = 15,
        /// A search for an advertiser's business location with intention to visit.
        GetDirections = 16,
        /// A click to an advertiser's partner's site.
        OutboundClick = 17,
        /// A call, SMS, email, chat or other type of contact to an advertiser.
        Contact = 18,
        /// A website engagement event such as long site time or a Google Analytics
        /// (GA) Smart Goal. Intended to be used for GA, Firebase, GA Gold goal
        /// imports.
        Engagement = 19,
        /// A visit to a physical store location.
        StoreVisit = 20,
        /// A sale occurring in a physical store.
        StoreSale = 21,
        /// A lead conversion imported from an external source into Google Ads,
        /// that has been further qualified by the advertiser (marketing/sales team).
        /// In the lead-to-sale journey, advertisers get leads, then act on them
        /// by reaching out to the consumer. If the consumer is interested and
        /// may end up buying their product, the advertiser marks such leads as
        /// "qualified leads".
        QualifiedLead = 22,
        /// A lead conversion imported from an external source into Google Ads, that
        /// has further completed a chosen stage as defined by the lead gen
        /// advertiser.
        ConvertedLead = 23,
    }
    impl ConversionActionCategory {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Default => "DEFAULT",
                Self::PageView => "PAGE_VIEW",
                Self::Purchase => "PURCHASE",
                Self::Signup => "SIGNUP",
                Self::Download => "DOWNLOAD",
                Self::AddToCart => "ADD_TO_CART",
                Self::BeginCheckout => "BEGIN_CHECKOUT",
                Self::SubscribePaid => "SUBSCRIBE_PAID",
                Self::PhoneCallLead => "PHONE_CALL_LEAD",
                Self::ImportedLead => "IMPORTED_LEAD",
                Self::SubmitLeadForm => "SUBMIT_LEAD_FORM",
                Self::BookAppointment => "BOOK_APPOINTMENT",
                Self::RequestQuote => "REQUEST_QUOTE",
                Self::GetDirections => "GET_DIRECTIONS",
                Self::OutboundClick => "OUTBOUND_CLICK",
                Self::Contact => "CONTACT",
                Self::Engagement => "ENGAGEMENT",
                Self::StoreVisit => "STORE_VISIT",
                Self::StoreSale => "STORE_SALE",
                Self::QualifiedLead => "QUALIFIED_LEAD",
                Self::ConvertedLead => "CONVERTED_LEAD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DEFAULT" => Some(Self::Default),
                "PAGE_VIEW" => Some(Self::PageView),
                "PURCHASE" => Some(Self::Purchase),
                "SIGNUP" => Some(Self::Signup),
                "DOWNLOAD" => Some(Self::Download),
                "ADD_TO_CART" => Some(Self::AddToCart),
                "BEGIN_CHECKOUT" => Some(Self::BeginCheckout),
                "SUBSCRIBE_PAID" => Some(Self::SubscribePaid),
                "PHONE_CALL_LEAD" => Some(Self::PhoneCallLead),
                "IMPORTED_LEAD" => Some(Self::ImportedLead),
                "SUBMIT_LEAD_FORM" => Some(Self::SubmitLeadForm),
                "BOOK_APPOINTMENT" => Some(Self::BookAppointment),
                "REQUEST_QUOTE" => Some(Self::RequestQuote),
                "GET_DIRECTIONS" => Some(Self::GetDirections),
                "OUTBOUND_CLICK" => Some(Self::OutboundClick),
                "CONTACT" => Some(Self::Contact),
                "ENGAGEMENT" => Some(Self::Engagement),
                "STORE_VISIT" => Some(Self::StoreVisit),
                "STORE_SALE" => Some(Self::StoreSale),
                "QUALIFIED_LEAD" => Some(Self::QualifiedLead),
                "CONVERTED_LEAD" => Some(Self::ConvertedLead),
                _ => None,
            }
        }
    }
}
/// Container for enum indicating the event type the conversion is attributed to.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionAttributionEventTypeEnum {}
/// Nested message and enum types in `ConversionAttributionEventTypeEnum`.
pub mod conversion_attribution_event_type_enum {
    /// The event type of conversions that are attributed to.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionAttributionEventType {
        /// Not specified.
        Unspecified = 0,
        /// Represents value unknown in this version.
        Unknown = 1,
        /// The conversion is attributed to an impression.
        Impression = 2,
        /// The conversion is attributed to an interaction.
        Interaction = 3,
    }
    impl ConversionAttributionEventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Impression => "IMPRESSION",
                Self::Interaction => "INTERACTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "IMPRESSION" => Some(Self::Impression),
                "INTERACTION" => Some(Self::Interaction),
                _ => None,
            }
        }
    }
}
/// Container for enum representing the number of days between impression and
/// conversion.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionLagBucketEnum {}
/// Nested message and enum types in `ConversionLagBucketEnum`.
pub mod conversion_lag_bucket_enum {
    /// Enum representing the number of days between impression and conversion.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionLagBucket {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Conversion lag bucket from 0 to 1 day. 0 day is included, 1 day is not.
        LessThanOneDay = 2,
        /// Conversion lag bucket from 1 to 2 days. 1 day is included, 2 days is not.
        OneToTwoDays = 3,
        /// Conversion lag bucket from 2 to 3 days. 2 days is included,
        /// 3 days is not.
        TwoToThreeDays = 4,
        /// Conversion lag bucket from 3 to 4 days. 3 days is included,
        /// 4 days is not.
        ThreeToFourDays = 5,
        /// Conversion lag bucket from 4 to 5 days. 4 days is included,
        /// 5 days is not.
        FourToFiveDays = 6,
        /// Conversion lag bucket from 5 to 6 days. 5 days is included,
        /// 6 days is not.
        FiveToSixDays = 7,
        /// Conversion lag bucket from 6 to 7 days. 6 days is included,
        /// 7 days is not.
        SixToSevenDays = 8,
        /// Conversion lag bucket from 7 to 8 days. 7 days is included,
        /// 8 days is not.
        SevenToEightDays = 9,
        /// Conversion lag bucket from 8 to 9 days. 8 days is included,
        /// 9 days is not.
        EightToNineDays = 10,
        /// Conversion lag bucket from 9 to 10 days. 9 days is included,
        /// 10 days is not.
        NineToTenDays = 11,
        /// Conversion lag bucket from 10 to 11 days. 10 days is included,
        /// 11 days is not.
        TenToElevenDays = 12,
        /// Conversion lag bucket from 11 to 12 days. 11 days is included,
        /// 12 days is not.
        ElevenToTwelveDays = 13,
        /// Conversion lag bucket from 12 to 13 days. 12 days is included,
        /// 13 days is not.
        TwelveToThirteenDays = 14,
        /// Conversion lag bucket from 13 to 14 days. 13 days is included,
        /// 14 days is not.
        ThirteenToFourteenDays = 15,
        /// Conversion lag bucket from 14 to 21 days. 14 days is included,
        /// 21 days is not.
        FourteenToTwentyOneDays = 16,
        /// Conversion lag bucket from 21 to 30 days. 21 days is included,
        /// 30 days is not.
        TwentyOneToThirtyDays = 17,
        /// Conversion lag bucket from 30 to 45 days. 30 days is included,
        /// 45 days is not.
        ThirtyToFortyFiveDays = 18,
        /// Conversion lag bucket from 45 to 60 days. 45 days is included,
        /// 60 days is not.
        FortyFiveToSixtyDays = 19,
        /// Conversion lag bucket from 60 to 90 days. 60 days is included,
        /// 90 days is not.
        SixtyToNinetyDays = 20,
    }
    impl ConversionLagBucket {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::LessThanOneDay => "LESS_THAN_ONE_DAY",
                Self::OneToTwoDays => "ONE_TO_TWO_DAYS",
                Self::TwoToThreeDays => "TWO_TO_THREE_DAYS",
                Self::ThreeToFourDays => "THREE_TO_FOUR_DAYS",
                Self::FourToFiveDays => "FOUR_TO_FIVE_DAYS",
                Self::FiveToSixDays => "FIVE_TO_SIX_DAYS",
                Self::SixToSevenDays => "SIX_TO_SEVEN_DAYS",
                Self::SevenToEightDays => "SEVEN_TO_EIGHT_DAYS",
                Self::EightToNineDays => "EIGHT_TO_NINE_DAYS",
                Self::NineToTenDays => "NINE_TO_TEN_DAYS",
                Self::TenToElevenDays => "TEN_TO_ELEVEN_DAYS",
                Self::ElevenToTwelveDays => "ELEVEN_TO_TWELVE_DAYS",
                Self::TwelveToThirteenDays => "TWELVE_TO_THIRTEEN_DAYS",
                Self::ThirteenToFourteenDays => "THIRTEEN_TO_FOURTEEN_DAYS",
                Self::FourteenToTwentyOneDays => "FOURTEEN_TO_TWENTY_ONE_DAYS",
                Self::TwentyOneToThirtyDays => "TWENTY_ONE_TO_THIRTY_DAYS",
                Self::ThirtyToFortyFiveDays => "THIRTY_TO_FORTY_FIVE_DAYS",
                Self::FortyFiveToSixtyDays => "FORTY_FIVE_TO_SIXTY_DAYS",
                Self::SixtyToNinetyDays => "SIXTY_TO_NINETY_DAYS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LESS_THAN_ONE_DAY" => Some(Self::LessThanOneDay),
                "ONE_TO_TWO_DAYS" => Some(Self::OneToTwoDays),
                "TWO_TO_THREE_DAYS" => Some(Self::TwoToThreeDays),
                "THREE_TO_FOUR_DAYS" => Some(Self::ThreeToFourDays),
                "FOUR_TO_FIVE_DAYS" => Some(Self::FourToFiveDays),
                "FIVE_TO_SIX_DAYS" => Some(Self::FiveToSixDays),
                "SIX_TO_SEVEN_DAYS" => Some(Self::SixToSevenDays),
                "SEVEN_TO_EIGHT_DAYS" => Some(Self::SevenToEightDays),
                "EIGHT_TO_NINE_DAYS" => Some(Self::EightToNineDays),
                "NINE_TO_TEN_DAYS" => Some(Self::NineToTenDays),
                "TEN_TO_ELEVEN_DAYS" => Some(Self::TenToElevenDays),
                "ELEVEN_TO_TWELVE_DAYS" => Some(Self::ElevenToTwelveDays),
                "TWELVE_TO_THIRTEEN_DAYS" => Some(Self::TwelveToThirteenDays),
                "THIRTEEN_TO_FOURTEEN_DAYS" => Some(Self::ThirteenToFourteenDays),
                "FOURTEEN_TO_TWENTY_ONE_DAYS" => Some(Self::FourteenToTwentyOneDays),
                "TWENTY_ONE_TO_THIRTY_DAYS" => Some(Self::TwentyOneToThirtyDays),
                "THIRTY_TO_FORTY_FIVE_DAYS" => Some(Self::ThirtyToFortyFiveDays),
                "FORTY_FIVE_TO_SIXTY_DAYS" => Some(Self::FortyFiveToSixtyDays),
                "SIXTY_TO_NINETY_DAYS" => Some(Self::SixtyToNinetyDays),
                _ => None,
            }
        }
    }
}
/// Container for enum representing the number of days between the impression and
/// the conversion or between the impression and adjustments to the conversion.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionOrAdjustmentLagBucketEnum {}
/// Nested message and enum types in `ConversionOrAdjustmentLagBucketEnum`.
pub mod conversion_or_adjustment_lag_bucket_enum {
    /// Enum representing the number of days between the impression and the
    /// conversion or between the impression and adjustments to the conversion.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionOrAdjustmentLagBucket {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Conversion lag bucket from 0 to 1 day. 0 day is included, 1 day is not.
        ConversionLessThanOneDay = 2,
        /// Conversion lag bucket from 1 to 2 days. 1 day is included, 2 days is not.
        ConversionOneToTwoDays = 3,
        /// Conversion lag bucket from 2 to 3 days. 2 days is included,
        /// 3 days is not.
        ConversionTwoToThreeDays = 4,
        /// Conversion lag bucket from 3 to 4 days. 3 days is included,
        /// 4 days is not.
        ConversionThreeToFourDays = 5,
        /// Conversion lag bucket from 4 to 5 days. 4 days is included,
        /// 5 days is not.
        ConversionFourToFiveDays = 6,
        /// Conversion lag bucket from 5 to 6 days. 5 days is included,
        /// 6 days is not.
        ConversionFiveToSixDays = 7,
        /// Conversion lag bucket from 6 to 7 days. 6 days is included,
        /// 7 days is not.
        ConversionSixToSevenDays = 8,
        /// Conversion lag bucket from 7 to 8 days. 7 days is included,
        /// 8 days is not.
        ConversionSevenToEightDays = 9,
        /// Conversion lag bucket from 8 to 9 days. 8 days is included,
        /// 9 days is not.
        ConversionEightToNineDays = 10,
        /// Conversion lag bucket from 9 to 10 days. 9 days is included,
        /// 10 days is not.
        ConversionNineToTenDays = 11,
        /// Conversion lag bucket from 10 to 11 days. 10 days is included,
        /// 11 days is not.
        ConversionTenToElevenDays = 12,
        /// Conversion lag bucket from 11 to 12 days. 11 days is included,
        /// 12 days is not.
        ConversionElevenToTwelveDays = 13,
        /// Conversion lag bucket from 12 to 13 days. 12 days is included,
        /// 13 days is not.
        ConversionTwelveToThirteenDays = 14,
        /// Conversion lag bucket from 13 to 14 days. 13 days is included,
        /// 14 days is not.
        ConversionThirteenToFourteenDays = 15,
        /// Conversion lag bucket from 14 to 21 days. 14 days is included,
        /// 21 days is not.
        ConversionFourteenToTwentyOneDays = 16,
        /// Conversion lag bucket from 21 to 30 days. 21 days is included,
        /// 30 days is not.
        ConversionTwentyOneToThirtyDays = 17,
        /// Conversion lag bucket from 30 to 45 days. 30 days is included,
        /// 45 days is not.
        ConversionThirtyToFortyFiveDays = 18,
        /// Conversion lag bucket from 45 to 60 days. 45 days is included,
        /// 60 days is not.
        ConversionFortyFiveToSixtyDays = 19,
        /// Conversion lag bucket from 60 to 90 days. 60 days is included,
        /// 90 days is not.
        ConversionSixtyToNinetyDays = 20,
        /// Conversion adjustment lag bucket from 0 to 1 day. 0 day is included,
        /// 1 day is not.
        AdjustmentLessThanOneDay = 21,
        /// Conversion adjustment lag bucket from 1 to 2 days. 1 day is included,
        /// 2 days is not.
        AdjustmentOneToTwoDays = 22,
        /// Conversion adjustment lag bucket from 2 to 3 days. 2 days is included,
        /// 3 days is not.
        AdjustmentTwoToThreeDays = 23,
        /// Conversion adjustment lag bucket from 3 to 4 days. 3 days is included,
        /// 4 days is not.
        AdjustmentThreeToFourDays = 24,
        /// Conversion adjustment lag bucket from 4 to 5 days. 4 days is included,
        /// 5 days is not.
        AdjustmentFourToFiveDays = 25,
        /// Conversion adjustment lag bucket from 5 to 6 days. 5 days is included,
        /// 6 days is not.
        AdjustmentFiveToSixDays = 26,
        /// Conversion adjustment lag bucket from 6 to 7 days. 6 days is included,
        /// 7 days is not.
        AdjustmentSixToSevenDays = 27,
        /// Conversion adjustment lag bucket from 7 to 8 days. 7 days is included,
        /// 8 days is not.
        AdjustmentSevenToEightDays = 28,
        /// Conversion adjustment lag bucket from 8 to 9 days. 8 days is included,
        /// 9 days is not.
        AdjustmentEightToNineDays = 29,
        /// Conversion adjustment lag bucket from 9 to 10 days. 9 days is included,
        /// 10 days is not.
        AdjustmentNineToTenDays = 30,
        /// Conversion adjustment lag bucket from 10 to 11 days. 10 days is included,
        /// 11 days is not.
        AdjustmentTenToElevenDays = 31,
        /// Conversion adjustment lag bucket from 11 to 12 days. 11 days is included,
        /// 12 days is not.
        AdjustmentElevenToTwelveDays = 32,
        /// Conversion adjustment lag bucket from 12 to 13 days. 12 days is included,
        /// 13 days is not.
        AdjustmentTwelveToThirteenDays = 33,
        /// Conversion adjustment lag bucket from 13 to 14 days. 13 days is included,
        /// 14 days is not.
        AdjustmentThirteenToFourteenDays = 34,
        /// Conversion adjustment lag bucket from 14 to 21 days. 14 days is included,
        /// 21 days is not.
        AdjustmentFourteenToTwentyOneDays = 35,
        /// Conversion adjustment lag bucket from 21 to 30 days. 21 days is included,
        /// 30 days is not.
        AdjustmentTwentyOneToThirtyDays = 36,
        /// Conversion adjustment lag bucket from 30 to 45 days. 30 days is included,
        /// 45 days is not.
        AdjustmentThirtyToFortyFiveDays = 37,
        /// Conversion adjustment lag bucket from 45 to 60 days. 45 days is included,
        /// 60 days is not.
        AdjustmentFortyFiveToSixtyDays = 38,
        /// Conversion adjustment lag bucket from 60 to 90 days. 60 days is included,
        /// 90 days is not.
        AdjustmentSixtyToNinetyDays = 39,
        /// Conversion adjustment lag bucket from 90 to 145 days. 90 days is
        /// included, 145 days is not.
        AdjustmentNinetyToOneHundredAndFortyFiveDays = 40,
        /// Conversion lag bucket UNKNOWN. This is for dates before conversion lag
        /// bucket was available in Google Ads.
        ConversionUnknown = 41,
        /// Conversion adjustment lag bucket UNKNOWN. This is for dates before
        /// conversion adjustment lag bucket was available in Google Ads.
        AdjustmentUnknown = 42,
    }
    impl ConversionOrAdjustmentLagBucket {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ConversionLessThanOneDay => "CONVERSION_LESS_THAN_ONE_DAY",
                Self::ConversionOneToTwoDays => "CONVERSION_ONE_TO_TWO_DAYS",
                Self::ConversionTwoToThreeDays => "CONVERSION_TWO_TO_THREE_DAYS",
                Self::ConversionThreeToFourDays => "CONVERSION_THREE_TO_FOUR_DAYS",
                Self::ConversionFourToFiveDays => "CONVERSION_FOUR_TO_FIVE_DAYS",
                Self::ConversionFiveToSixDays => "CONVERSION_FIVE_TO_SIX_DAYS",
                Self::ConversionSixToSevenDays => "CONVERSION_SIX_TO_SEVEN_DAYS",
                Self::ConversionSevenToEightDays => "CONVERSION_SEVEN_TO_EIGHT_DAYS",
                Self::ConversionEightToNineDays => "CONVERSION_EIGHT_TO_NINE_DAYS",
                Self::ConversionNineToTenDays => "CONVERSION_NINE_TO_TEN_DAYS",
                Self::ConversionTenToElevenDays => "CONVERSION_TEN_TO_ELEVEN_DAYS",
                Self::ConversionElevenToTwelveDays => "CONVERSION_ELEVEN_TO_TWELVE_DAYS",
                Self::ConversionTwelveToThirteenDays => {
                    "CONVERSION_TWELVE_TO_THIRTEEN_DAYS"
                }
                Self::ConversionThirteenToFourteenDays => {
                    "CONVERSION_THIRTEEN_TO_FOURTEEN_DAYS"
                }
                Self::ConversionFourteenToTwentyOneDays => {
                    "CONVERSION_FOURTEEN_TO_TWENTY_ONE_DAYS"
                }
                Self::ConversionTwentyOneToThirtyDays => {
                    "CONVERSION_TWENTY_ONE_TO_THIRTY_DAYS"
                }
                Self::ConversionThirtyToFortyFiveDays => {
                    "CONVERSION_THIRTY_TO_FORTY_FIVE_DAYS"
                }
                Self::ConversionFortyFiveToSixtyDays => {
                    "CONVERSION_FORTY_FIVE_TO_SIXTY_DAYS"
                }
                Self::ConversionSixtyToNinetyDays => "CONVERSION_SIXTY_TO_NINETY_DAYS",
                Self::AdjustmentLessThanOneDay => "ADJUSTMENT_LESS_THAN_ONE_DAY",
                Self::AdjustmentOneToTwoDays => "ADJUSTMENT_ONE_TO_TWO_DAYS",
                Self::AdjustmentTwoToThreeDays => "ADJUSTMENT_TWO_TO_THREE_DAYS",
                Self::AdjustmentThreeToFourDays => "ADJUSTMENT_THREE_TO_FOUR_DAYS",
                Self::AdjustmentFourToFiveDays => "ADJUSTMENT_FOUR_TO_FIVE_DAYS",
                Self::AdjustmentFiveToSixDays => "ADJUSTMENT_FIVE_TO_SIX_DAYS",
                Self::AdjustmentSixToSevenDays => "ADJUSTMENT_SIX_TO_SEVEN_DAYS",
                Self::AdjustmentSevenToEightDays => "ADJUSTMENT_SEVEN_TO_EIGHT_DAYS",
                Self::AdjustmentEightToNineDays => "ADJUSTMENT_EIGHT_TO_NINE_DAYS",
                Self::AdjustmentNineToTenDays => "ADJUSTMENT_NINE_TO_TEN_DAYS",
                Self::AdjustmentTenToElevenDays => "ADJUSTMENT_TEN_TO_ELEVEN_DAYS",
                Self::AdjustmentElevenToTwelveDays => "ADJUSTMENT_ELEVEN_TO_TWELVE_DAYS",
                Self::AdjustmentTwelveToThirteenDays => {
                    "ADJUSTMENT_TWELVE_TO_THIRTEEN_DAYS"
                }
                Self::AdjustmentThirteenToFourteenDays => {
                    "ADJUSTMENT_THIRTEEN_TO_FOURTEEN_DAYS"
                }
                Self::AdjustmentFourteenToTwentyOneDays => {
                    "ADJUSTMENT_FOURTEEN_TO_TWENTY_ONE_DAYS"
                }
                Self::AdjustmentTwentyOneToThirtyDays => {
                    "ADJUSTMENT_TWENTY_ONE_TO_THIRTY_DAYS"
                }
                Self::AdjustmentThirtyToFortyFiveDays => {
                    "ADJUSTMENT_THIRTY_TO_FORTY_FIVE_DAYS"
                }
                Self::AdjustmentFortyFiveToSixtyDays => {
                    "ADJUSTMENT_FORTY_FIVE_TO_SIXTY_DAYS"
                }
                Self::AdjustmentSixtyToNinetyDays => "ADJUSTMENT_SIXTY_TO_NINETY_DAYS",
                Self::AdjustmentNinetyToOneHundredAndFortyFiveDays => {
                    "ADJUSTMENT_NINETY_TO_ONE_HUNDRED_AND_FORTY_FIVE_DAYS"
                }
                Self::ConversionUnknown => "CONVERSION_UNKNOWN",
                Self::AdjustmentUnknown => "ADJUSTMENT_UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CONVERSION_LESS_THAN_ONE_DAY" => Some(Self::ConversionLessThanOneDay),
                "CONVERSION_ONE_TO_TWO_DAYS" => Some(Self::ConversionOneToTwoDays),
                "CONVERSION_TWO_TO_THREE_DAYS" => Some(Self::ConversionTwoToThreeDays),
                "CONVERSION_THREE_TO_FOUR_DAYS" => Some(Self::ConversionThreeToFourDays),
                "CONVERSION_FOUR_TO_FIVE_DAYS" => Some(Self::ConversionFourToFiveDays),
                "CONVERSION_FIVE_TO_SIX_DAYS" => Some(Self::ConversionFiveToSixDays),
                "CONVERSION_SIX_TO_SEVEN_DAYS" => Some(Self::ConversionSixToSevenDays),
                "CONVERSION_SEVEN_TO_EIGHT_DAYS" => {
                    Some(Self::ConversionSevenToEightDays)
                }
                "CONVERSION_EIGHT_TO_NINE_DAYS" => Some(Self::ConversionEightToNineDays),
                "CONVERSION_NINE_TO_TEN_DAYS" => Some(Self::ConversionNineToTenDays),
                "CONVERSION_TEN_TO_ELEVEN_DAYS" => Some(Self::ConversionTenToElevenDays),
                "CONVERSION_ELEVEN_TO_TWELVE_DAYS" => {
                    Some(Self::ConversionElevenToTwelveDays)
                }
                "CONVERSION_TWELVE_TO_THIRTEEN_DAYS" => {
                    Some(Self::ConversionTwelveToThirteenDays)
                }
                "CONVERSION_THIRTEEN_TO_FOURTEEN_DAYS" => {
                    Some(Self::ConversionThirteenToFourteenDays)
                }
                "CONVERSION_FOURTEEN_TO_TWENTY_ONE_DAYS" => {
                    Some(Self::ConversionFourteenToTwentyOneDays)
                }
                "CONVERSION_TWENTY_ONE_TO_THIRTY_DAYS" => {
                    Some(Self::ConversionTwentyOneToThirtyDays)
                }
                "CONVERSION_THIRTY_TO_FORTY_FIVE_DAYS" => {
                    Some(Self::ConversionThirtyToFortyFiveDays)
                }
                "CONVERSION_FORTY_FIVE_TO_SIXTY_DAYS" => {
                    Some(Self::ConversionFortyFiveToSixtyDays)
                }
                "CONVERSION_SIXTY_TO_NINETY_DAYS" => {
                    Some(Self::ConversionSixtyToNinetyDays)
                }
                "ADJUSTMENT_LESS_THAN_ONE_DAY" => Some(Self::AdjustmentLessThanOneDay),
                "ADJUSTMENT_ONE_TO_TWO_DAYS" => Some(Self::AdjustmentOneToTwoDays),
                "ADJUSTMENT_TWO_TO_THREE_DAYS" => Some(Self::AdjustmentTwoToThreeDays),
                "ADJUSTMENT_THREE_TO_FOUR_DAYS" => Some(Self::AdjustmentThreeToFourDays),
                "ADJUSTMENT_FOUR_TO_FIVE_DAYS" => Some(Self::AdjustmentFourToFiveDays),
                "ADJUSTMENT_FIVE_TO_SIX_DAYS" => Some(Self::AdjustmentFiveToSixDays),
                "ADJUSTMENT_SIX_TO_SEVEN_DAYS" => Some(Self::AdjustmentSixToSevenDays),
                "ADJUSTMENT_SEVEN_TO_EIGHT_DAYS" => {
                    Some(Self::AdjustmentSevenToEightDays)
                }
                "ADJUSTMENT_EIGHT_TO_NINE_DAYS" => Some(Self::AdjustmentEightToNineDays),
                "ADJUSTMENT_NINE_TO_TEN_DAYS" => Some(Self::AdjustmentNineToTenDays),
                "ADJUSTMENT_TEN_TO_ELEVEN_DAYS" => Some(Self::AdjustmentTenToElevenDays),
                "ADJUSTMENT_ELEVEN_TO_TWELVE_DAYS" => {
                    Some(Self::AdjustmentElevenToTwelveDays)
                }
                "ADJUSTMENT_TWELVE_TO_THIRTEEN_DAYS" => {
                    Some(Self::AdjustmentTwelveToThirteenDays)
                }
                "ADJUSTMENT_THIRTEEN_TO_FOURTEEN_DAYS" => {
                    Some(Self::AdjustmentThirteenToFourteenDays)
                }
                "ADJUSTMENT_FOURTEEN_TO_TWENTY_ONE_DAYS" => {
                    Some(Self::AdjustmentFourteenToTwentyOneDays)
                }
                "ADJUSTMENT_TWENTY_ONE_TO_THIRTY_DAYS" => {
                    Some(Self::AdjustmentTwentyOneToThirtyDays)
                }
                "ADJUSTMENT_THIRTY_TO_FORTY_FIVE_DAYS" => {
                    Some(Self::AdjustmentThirtyToFortyFiveDays)
                }
                "ADJUSTMENT_FORTY_FIVE_TO_SIXTY_DAYS" => {
                    Some(Self::AdjustmentFortyFiveToSixtyDays)
                }
                "ADJUSTMENT_SIXTY_TO_NINETY_DAYS" => {
                    Some(Self::AdjustmentSixtyToNinetyDays)
                }
                "ADJUSTMENT_NINETY_TO_ONE_HUNDRED_AND_FORTY_FIVE_DAYS" => {
                    Some(Self::AdjustmentNinetyToOneHundredAndFortyFiveDays)
                }
                "CONVERSION_UNKNOWN" => Some(Self::ConversionUnknown),
                "ADJUSTMENT_UNKNOWN" => Some(Self::AdjustmentUnknown),
                _ => None,
            }
        }
    }
}
/// Container for enum describing value rule primary dimension for stats.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionValueRulePrimaryDimensionEnum {}
/// Nested message and enum types in `ConversionValueRulePrimaryDimensionEnum`.
pub mod conversion_value_rule_primary_dimension_enum {
    /// Identifies the primary dimension for conversion value rule stats.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionValueRulePrimaryDimension {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// For no-value-rule-applied conversions after value rule is enabled.
        NoRuleApplied = 2,
        /// Below are for value-rule-applied conversions:
        /// The original stats.
        Original = 3,
        /// When a new or returning customer condition is satisfied.
        NewVsReturningUser = 4,
        /// When a query-time Geo location condition is satisfied.
        GeoLocation = 5,
        /// When a query-time browsing device condition is satisfied.
        Device = 6,
        /// When a query-time audience condition is satisfied.
        Audience = 7,
        /// When multiple rules are applied.
        Multiple = 8,
    }
    impl ConversionValueRulePrimaryDimension {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NoRuleApplied => "NO_RULE_APPLIED",
                Self::Original => "ORIGINAL",
                Self::NewVsReturningUser => "NEW_VS_RETURNING_USER",
                Self::GeoLocation => "GEO_LOCATION",
                Self::Device => "DEVICE",
                Self::Audience => "AUDIENCE",
                Self::Multiple => "MULTIPLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NO_RULE_APPLIED" => Some(Self::NoRuleApplied),
                "ORIGINAL" => Some(Self::Original),
                "NEW_VS_RETURNING_USER" => Some(Self::NewVsReturningUser),
                "GEO_LOCATION" => Some(Self::GeoLocation),
                "DEVICE" => Some(Self::Device),
                "AUDIENCE" => Some(Self::Audience),
                "MULTIPLE" => Some(Self::Multiple),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of converting user prior engagement types and
/// lifetime-value bucket.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConvertingUserPriorEngagementTypeAndLtvBucketEnum {}
/// Nested message and enum types in `ConvertingUserPriorEngagementTypeAndLtvBucketEnum`.
pub mod converting_user_prior_engagement_type_and_ltv_bucket_enum {
    /// Enumerates converting user prior engagement types and lifetime-value bucket
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConvertingUserPriorEngagementTypeAndLtvBucket {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Converting user is new to the advertiser.
        New = 2,
        /// Converting user is returning to the advertiser. Definition of returning
        /// differs among conversion types, such as a second store visit versus a
        /// second online purchase.
        Returning = 3,
        /// Converting user is new to the advertiser and has high lifetime value.
        NewAndHighLtv = 4,
    }
    impl ConvertingUserPriorEngagementTypeAndLtvBucket {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::New => "NEW",
                Self::Returning => "RETURNING",
                Self::NewAndHighLtv => "NEW_AND_HIGH_LTV",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEW" => Some(Self::New),
                "RETURNING" => Some(Self::Returning),
                "NEW_AND_HIGH_LTV" => Some(Self::NewAndHighLtv),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the external conversion source that is
/// associated with a ConversionAction.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExternalConversionSourceEnum {}
/// Nested message and enum types in `ExternalConversionSourceEnum`.
pub mod external_conversion_source_enum {
    /// The external conversion source that is associated with a ConversionAction.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExternalConversionSource {
        /// Not specified.
        Unspecified = 0,
        /// Represents value unknown in this version.
        Unknown = 1,
        /// Conversion that occurs when a user navigates to a particular webpage
        /// after viewing an ad; Displayed in Google Ads UI as 'Website'.
        Webpage = 2,
        /// Conversion that comes from linked Google Analytics goal or transaction;
        /// Displayed in Google Ads UI as 'Analytics'.
        Analytics = 3,
        /// Website conversion that is uploaded through ConversionUploadService;
        /// Displayed in Google Ads UI as 'Import from clicks'.
        Upload = 4,
        /// Conversion that occurs when a user clicks on a call extension directly on
        /// an ad; Displayed in Google Ads UI as 'Calls from ads'.
        AdCallMetrics = 5,
        /// Conversion that occurs when a user calls a dynamically-generated phone
        /// number (by installed javascript) from an advertiser's website after
        /// clicking on an ad; Displayed in Google Ads UI as 'Calls from website'.
        WebsiteCallMetrics = 6,
        /// Conversion that occurs when a user visits an advertiser's retail store
        /// after clicking on a Google ad;
        /// Displayed in Google Ads UI as 'Store visits'.
        StoreVisits = 7,
        /// Conversion that occurs when a user takes an in-app action such as a
        /// purchase in an Android app;
        /// Displayed in Google Ads UI as 'Android in-app action'.
        AndroidInApp = 8,
        /// Conversion that occurs when a user takes an in-app action such as a
        /// purchase in an iOS app;
        /// Displayed in Google Ads UI as 'iOS in-app action'.
        IosInApp = 9,
        /// Conversion that occurs when a user opens an iOS app for the first time;
        /// Displayed in Google Ads UI as 'iOS app install (first open)'.
        IosFirstOpen = 10,
        /// Legacy app conversions that do not have an AppPlatform provided;
        /// Displayed in Google Ads UI as 'Mobile app'.
        AppUnspecified = 11,
        /// Conversion that occurs when a user opens an Android app for the first
        /// time; Displayed in Google Ads UI as 'Android app install (first open)'.
        AndroidFirstOpen = 12,
        /// Call conversion that is uploaded through ConversionUploadService;
        /// Displayed in Google Ads UI as 'Import from calls'.
        UploadCalls = 13,
        /// Conversion that comes from a linked Firebase event;
        /// Displayed in Google Ads UI as 'Firebase'.
        Firebase = 14,
        /// Conversion that occurs when a user clicks on a mobile phone number;
        /// Displayed in Google Ads UI as 'Phone number clicks'.
        ClickToCall = 15,
        /// Conversion that comes from Salesforce;
        /// Displayed in Google Ads UI as 'Salesforce.com'.
        Salesforce = 16,
        /// Conversion that comes from in-store purchases recorded by CRM;
        /// Displayed in Google Ads UI as 'Store sales (data partner)'.
        StoreSalesCrm = 17,
        /// Conversion that comes from in-store purchases from payment network;
        /// Displayed in Google Ads UI as 'Store sales (payment network)'.
        StoreSalesPaymentNetwork = 18,
        /// Codeless Google Play conversion;
        /// Displayed in Google Ads UI as 'Google Play'.
        GooglePlay = 19,
        /// Conversion that comes from a linked third-party app analytics event;
        /// Displayed in Google Ads UI as 'Third-party app analytics'.
        ThirdPartyAppAnalytics = 20,
        /// Conversion that is controlled by Google Attribution.
        GoogleAttribution = 21,
        /// Store Sales conversion based on first-party or third-party merchant data
        /// uploads. Displayed in Google Ads UI as 'Store sales (direct upload)'.
        StoreSalesDirectUpload = 23,
        /// Store Sales conversion based on first-party or third-party merchant
        /// data uploads and/or from in-store purchases using cards from payment
        /// networks. Displayed in Google Ads UI as 'Store sales'.
        StoreSales = 24,
        /// Conversions imported from Search Ads 360 Floodlight data.
        SearchAds360 = 25,
        /// Conversions that track local actions from Google's products and services
        /// after interacting with an ad.
        GoogleHosted = 27,
        /// Conversions reported by Floodlight tags.
        Floodlight = 29,
        /// Conversions that come from Google Analytics specifically for Search Ads
        /// 360. Displayed in Google Ads UI as Analytics (SA360).
        AnalyticsSearchAds360 = 31,
        /// Conversion that comes from a linked Firebase event for Search Ads 360.
        FirebaseSearchAds360 = 33,
        /// Conversion that is reported by Floodlight for DV360.
        DisplayAndVideo360Floodlight = 34,
    }
    impl ExternalConversionSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Webpage => "WEBPAGE",
                Self::Analytics => "ANALYTICS",
                Self::Upload => "UPLOAD",
                Self::AdCallMetrics => "AD_CALL_METRICS",
                Self::WebsiteCallMetrics => "WEBSITE_CALL_METRICS",
                Self::StoreVisits => "STORE_VISITS",
                Self::AndroidInApp => "ANDROID_IN_APP",
                Self::IosInApp => "IOS_IN_APP",
                Self::IosFirstOpen => "IOS_FIRST_OPEN",
                Self::AppUnspecified => "APP_UNSPECIFIED",
                Self::AndroidFirstOpen => "ANDROID_FIRST_OPEN",
                Self::UploadCalls => "UPLOAD_CALLS",
                Self::Firebase => "FIREBASE",
                Self::ClickToCall => "CLICK_TO_CALL",
                Self::Salesforce => "SALESFORCE",
                Self::StoreSalesCrm => "STORE_SALES_CRM",
                Self::StoreSalesPaymentNetwork => "STORE_SALES_PAYMENT_NETWORK",
                Self::GooglePlay => "GOOGLE_PLAY",
                Self::ThirdPartyAppAnalytics => "THIRD_PARTY_APP_ANALYTICS",
                Self::GoogleAttribution => "GOOGLE_ATTRIBUTION",
                Self::StoreSalesDirectUpload => "STORE_SALES_DIRECT_UPLOAD",
                Self::StoreSales => "STORE_SALES",
                Self::SearchAds360 => "SEARCH_ADS_360",
                Self::GoogleHosted => "GOOGLE_HOSTED",
                Self::Floodlight => "FLOODLIGHT",
                Self::AnalyticsSearchAds360 => "ANALYTICS_SEARCH_ADS_360",
                Self::FirebaseSearchAds360 => "FIREBASE_SEARCH_ADS_360",
                Self::DisplayAndVideo360Floodlight => "DISPLAY_AND_VIDEO_360_FLOODLIGHT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "WEBPAGE" => Some(Self::Webpage),
                "ANALYTICS" => Some(Self::Analytics),
                "UPLOAD" => Some(Self::Upload),
                "AD_CALL_METRICS" => Some(Self::AdCallMetrics),
                "WEBSITE_CALL_METRICS" => Some(Self::WebsiteCallMetrics),
                "STORE_VISITS" => Some(Self::StoreVisits),
                "ANDROID_IN_APP" => Some(Self::AndroidInApp),
                "IOS_IN_APP" => Some(Self::IosInApp),
                "IOS_FIRST_OPEN" => Some(Self::IosFirstOpen),
                "APP_UNSPECIFIED" => Some(Self::AppUnspecified),
                "ANDROID_FIRST_OPEN" => Some(Self::AndroidFirstOpen),
                "UPLOAD_CALLS" => Some(Self::UploadCalls),
                "FIREBASE" => Some(Self::Firebase),
                "CLICK_TO_CALL" => Some(Self::ClickToCall),
                "SALESFORCE" => Some(Self::Salesforce),
                "STORE_SALES_CRM" => Some(Self::StoreSalesCrm),
                "STORE_SALES_PAYMENT_NETWORK" => Some(Self::StoreSalesPaymentNetwork),
                "GOOGLE_PLAY" => Some(Self::GooglePlay),
                "THIRD_PARTY_APP_ANALYTICS" => Some(Self::ThirdPartyAppAnalytics),
                "GOOGLE_ATTRIBUTION" => Some(Self::GoogleAttribution),
                "STORE_SALES_DIRECT_UPLOAD" => Some(Self::StoreSalesDirectUpload),
                "STORE_SALES" => Some(Self::StoreSales),
                "SEARCH_ADS_360" => Some(Self::SearchAds360),
                "GOOGLE_HOSTED" => Some(Self::GoogleHosted),
                "FLOODLIGHT" => Some(Self::Floodlight),
                "ANALYTICS_SEARCH_ADS_360" => Some(Self::AnalyticsSearchAds360),
                "FIREBASE_SEARCH_ADS_360" => Some(Self::FirebaseSearchAds360),
                "DISPLAY_AND_VIDEO_360_FLOODLIGHT" => {
                    Some(Self::DisplayAndVideo360Floodlight)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing hotel price bucket for a hotel itinerary.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HotelPriceBucketEnum {}
/// Nested message and enum types in `HotelPriceBucketEnum`.
pub mod hotel_price_bucket_enum {
    /// Enum describing possible hotel price buckets.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HotelPriceBucket {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Uniquely lowest price. Partner has the lowest price, and no other
        /// partners are within a small variance of that price.
        LowestUnique = 2,
        /// Tied for lowest price. Partner is within a small variance of the lowest
        /// price.
        LowestTied = 3,
        /// Not lowest price. Partner is not within a small variance of the lowest
        /// price.
        NotLowest = 4,
        /// Partner was the only one shown.
        OnlyPartnerShown = 5,
    }
    impl HotelPriceBucket {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::LowestUnique => "LOWEST_UNIQUE",
                Self::LowestTied => "LOWEST_TIED",
                Self::NotLowest => "NOT_LOWEST",
                Self::OnlyPartnerShown => "ONLY_PARTNER_SHOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LOWEST_UNIQUE" => Some(Self::LowestUnique),
                "LOWEST_TIED" => Some(Self::LowestTied),
                "NOT_LOWEST" => Some(Self::NotLowest),
                "ONLY_PARTNER_SHOWN" => Some(Self::OnlyPartnerShown),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible hotel rate types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HotelRateTypeEnum {}
/// Nested message and enum types in `HotelRateTypeEnum`.
pub mod hotel_rate_type_enum {
    /// Enum describing possible hotel rate types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HotelRateType {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Rate type information is unavailable.
        Unavailable = 2,
        /// Rates available to everyone.
        PublicRate = 3,
        /// A membership program rate is available and satisfies basic requirements
        /// like having a public rate available. UI treatment will strikethrough the
        /// public rate and indicate that a discount is available to the user. For
        /// more on Qualified Rates, visit
        /// <https://developers.google.com/hotels/hotel-ads/dev-guide/qualified-rates>
        QualifiedRate = 4,
        /// Rates available to users that satisfy some eligibility criteria, for
        /// example, all signed-in users, 20% of mobile users, all mobile users in
        /// Canada, etc.
        PrivateRate = 5,
    }
    impl HotelRateType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Unavailable => "UNAVAILABLE",
                Self::PublicRate => "PUBLIC_RATE",
                Self::QualifiedRate => "QUALIFIED_RATE",
                Self::PrivateRate => "PRIVATE_RATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "PUBLIC_RATE" => Some(Self::PublicRate),
                "QUALIFIED_RATE" => Some(Self::QualifiedRate),
                "PRIVATE_RATE" => Some(Self::PrivateRate),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible placeholder types for a feed mapping.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlaceholderTypeEnum {}
/// Nested message and enum types in `PlaceholderTypeEnum`.
pub mod placeholder_type_enum {
    /// Possible placeholder types for a feed mapping.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PlaceholderType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Lets you show links in your ad to pages from your website, including the
        /// main landing page.
        Sitelink = 2,
        /// Lets you attach a phone number to an ad, allowing customers to call
        /// directly from the ad.
        Call = 3,
        /// Lets you provide users with a link that points to a mobile app in
        /// addition to a website.
        App = 4,
        /// Lets you show locations of businesses from your Business Profile
        /// in your ad. This helps people find your locations by showing your
        /// ads with your address, a map to your location, or the distance to your
        /// business. This extension type is useful to draw customers to your
        /// brick-and-mortar location.
        Location = 5,
        /// If you sell your product through retail chains, affiliate location
        /// extensions let you show nearby stores that carry your products.
        AffiliateLocation = 6,
        /// Lets you include additional text with your search ads that provide
        /// detailed information about your business, including products and services
        /// you offer. Callouts appear in ads at the top and bottom of Google search
        /// results.
        Callout = 7,
        /// Lets you add more info to your ad, specific to some predefined categories
        /// such as types, brands, styles, etc. A minimum of 3 text (SNIPPETS) values
        /// are required.
        StructuredSnippet = 8,
        /// Allows users to see your ad, click an icon, and contact you directly by
        /// text message. With one tap on your ad, people can contact you to book an
        /// appointment, get a quote, ask for information, or request a service.
        Message = 9,
        /// Lets you display prices for a list of items along with your ads. A price
        /// feed is composed of three to eight price table rows.
        Price = 10,
        /// Lets you highlight sales and other promotions that let users see how
        /// they can save by buying now.
        Promotion = 11,
        /// Lets you dynamically inject custom data into the title and description
        /// of your ads.
        AdCustomizer = 12,
        /// Indicates that this feed is for education dynamic remarketing.
        DynamicEducation = 13,
        /// Indicates that this feed is for flight dynamic remarketing.
        DynamicFlight = 14,
        /// Indicates that this feed is for a custom dynamic remarketing type. Use
        /// this only if the other business types don't apply to your products or
        /// services.
        DynamicCustom = 15,
        /// Indicates that this feed is for hotels and rentals dynamic remarketing.
        DynamicHotel = 16,
        /// Indicates that this feed is for real estate dynamic remarketing.
        DynamicRealEstate = 17,
        /// Indicates that this feed is for travel dynamic remarketing.
        DynamicTravel = 18,
        /// Indicates that this feed is for local deals dynamic remarketing.
        DynamicLocal = 19,
        /// Indicates that this feed is for job dynamic remarketing.
        DynamicJob = 20,
        /// Lets you attach an image to an ad.
        Image = 21,
    }
    impl PlaceholderType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Sitelink => "SITELINK",
                Self::Call => "CALL",
                Self::App => "APP",
                Self::Location => "LOCATION",
                Self::AffiliateLocation => "AFFILIATE_LOCATION",
                Self::Callout => "CALLOUT",
                Self::StructuredSnippet => "STRUCTURED_SNIPPET",
                Self::Message => "MESSAGE",
                Self::Price => "PRICE",
                Self::Promotion => "PROMOTION",
                Self::AdCustomizer => "AD_CUSTOMIZER",
                Self::DynamicEducation => "DYNAMIC_EDUCATION",
                Self::DynamicFlight => "DYNAMIC_FLIGHT",
                Self::DynamicCustom => "DYNAMIC_CUSTOM",
                Self::DynamicHotel => "DYNAMIC_HOTEL",
                Self::DynamicRealEstate => "DYNAMIC_REAL_ESTATE",
                Self::DynamicTravel => "DYNAMIC_TRAVEL",
                Self::DynamicLocal => "DYNAMIC_LOCAL",
                Self::DynamicJob => "DYNAMIC_JOB",
                Self::Image => "IMAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SITELINK" => Some(Self::Sitelink),
                "CALL" => Some(Self::Call),
                "APP" => Some(Self::App),
                "LOCATION" => Some(Self::Location),
                "AFFILIATE_LOCATION" => Some(Self::AffiliateLocation),
                "CALLOUT" => Some(Self::Callout),
                "STRUCTURED_SNIPPET" => Some(Self::StructuredSnippet),
                "MESSAGE" => Some(Self::Message),
                "PRICE" => Some(Self::Price),
                "PROMOTION" => Some(Self::Promotion),
                "AD_CUSTOMIZER" => Some(Self::AdCustomizer),
                "DYNAMIC_EDUCATION" => Some(Self::DynamicEducation),
                "DYNAMIC_FLIGHT" => Some(Self::DynamicFlight),
                "DYNAMIC_CUSTOM" => Some(Self::DynamicCustom),
                "DYNAMIC_HOTEL" => Some(Self::DynamicHotel),
                "DYNAMIC_REAL_ESTATE" => Some(Self::DynamicRealEstate),
                "DYNAMIC_TRAVEL" => Some(Self::DynamicTravel),
                "DYNAMIC_LOCAL" => Some(Self::DynamicLocal),
                "DYNAMIC_JOB" => Some(Self::DynamicJob),
                "IMAGE" => Some(Self::Image),
                _ => None,
            }
        }
    }
}
/// Container for enum describing types of recommendations.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecommendationTypeEnum {}
/// Nested message and enum types in `RecommendationTypeEnum`.
pub mod recommendation_type_enum {
    /// Types of recommendations.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RecommendationType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Budget recommendation for campaigns that are currently budget-constrained
        /// (as opposed to the FORECASTING_CAMPAIGN_BUDGET recommendation, which
        /// applies to campaigns that are expected to become budget-constrained in
        /// the future).
        CampaignBudget = 2,
        /// Keyword recommendation.
        Keyword = 3,
        /// Recommendation to add a new text ad.
        TextAd = 4,
        /// Recommendation to update a campaign to use a Target CPA bidding strategy.
        TargetCpaOptIn = 5,
        /// Recommendation to update a campaign to use the Maximize Conversions
        /// bidding strategy.
        MaximizeConversionsOptIn = 6,
        /// Recommendation to enable Enhanced Cost Per Click for a campaign.
        EnhancedCpcOptIn = 7,
        /// Recommendation to start showing your campaign's ads on Google Search
        /// Partners Websites.
        SearchPartnersOptIn = 8,
        /// Recommendation to update a campaign to use a Maximize Clicks bidding
        /// strategy.
        MaximizeClicksOptIn = 9,
        /// Recommendation to start using the "Optimize" ad rotation setting for the
        /// given ad group.
        OptimizeAdRotation = 10,
        /// Recommendation to change an existing keyword from one match type to a
        /// broader match type.
        KeywordMatchType = 14,
        /// Recommendation to move unused budget from one budget to a constrained
        /// budget.
        MoveUnusedBudget = 15,
        /// Budget recommendation for campaigns that are expected to become
        /// budget-constrained in the future (as opposed to the CAMPAIGN_BUDGET
        /// recommendation, which applies to campaigns that are currently
        /// budget-constrained).
        ForecastingCampaignBudget = 16,
        /// Recommendation to update a campaign to use a Target ROAS bidding
        /// strategy.
        TargetRoasOptIn = 17,
        /// Recommendation to add a new responsive search ad.
        ResponsiveSearchAd = 18,
        /// Budget recommendation for campaigns whose ROI is predicted to increase
        /// with a budget adjustment.
        MarginalRoiCampaignBudget = 19,
        /// Recommendation to add broad match versions of keywords for fully
        /// automated conversion-based bidding campaigns.
        UseBroadMatchKeyword = 20,
        /// Recommendation to add new responsive search ad assets.
        ResponsiveSearchAdAsset = 21,
        /// Recommendation to upgrade a Smart Shopping campaign to a Performance Max
        /// campaign.
        UpgradeSmartShoppingCampaignToPerformanceMax = 22,
        /// Recommendation to improve strength of responsive search ad.
        ResponsiveSearchAdImproveAdStrength = 23,
        /// Recommendation to update a campaign to use Display Expansion.
        DisplayExpansionOptIn = 24,
        /// Recommendation to upgrade a Local campaign to a Performance Max
        /// campaign.
        UpgradeLocalCampaignToPerformanceMax = 25,
        /// Recommendation to raise target CPA when it is too low and there are very
        /// few or no conversions.
        /// It is applied asynchronously and can take minutes
        /// depending on the number of ad groups there are in the related campaign.
        RaiseTargetCpaBidTooLow = 26,
        /// Recommendation to raise the budget in advance of a seasonal event that is
        /// forecasted to increase traffic, and change bidding strategy from maximize
        /// conversion value to target ROAS.
        ForecastingSetTargetRoas = 27,
        /// Recommendation to add callout assets to campaign or customer level.
        CalloutAsset = 28,
        /// Recommendation to add sitelink assets to campaign or customer level.
        SitelinkAsset = 29,
        /// Recommendation to add call assets to campaign or customer level.
        CallAsset = 30,
        /// Recommendation to add the age group attribute to offers that are
        /// demoted because of a missing age group.
        ShoppingAddAgeGroup = 31,
        /// Recommendation to add a color to offers that are demoted
        /// because of a missing color.
        ShoppingAddColor = 32,
        /// Recommendation to add a gender to offers that are demoted
        /// because of a missing gender.
        ShoppingAddGender = 33,
        /// Recommendation to add a GTIN (Global Trade Item Number) to offers
        /// that are demoted because of a missing GTIN.
        ShoppingAddGtin = 34,
        /// Recommendation to add more identifiers to offers that are demoted because
        /// of missing identifiers.
        ShoppingAddMoreIdentifiers = 35,
        /// Recommendation to add the size to offers that are demoted
        /// because of a missing size.
        ShoppingAddSize = 36,
        /// Recommendation informing a customer about a campaign that cannot serve
        /// because no products are being targeted.
        ShoppingAddProductsToCampaign = 37,
        /// The shopping recommendation informing a customer about campaign with a
        /// high percentage of disapproved products.
        ShoppingFixDisapprovedProducts = 38,
        /// Recommendation to create a catch-all campaign that targets all offers.
        ShoppingTargetAllOffers = 39,
        /// Recommendation to fix Merchant Center account suspension issues.
        ShoppingFixSuspendedMerchantCenterAccount = 40,
        /// Recommendation to fix Merchant Center account suspension warning issues.
        ShoppingFixMerchantCenterAccountSuspensionWarning = 41,
        /// Recommendation to migrate offers targeted by Regular Shopping Campaigns
        /// to existing Performance Max campaigns.
        ShoppingMigrateRegularShoppingCampaignOffersToPerformanceMax = 42,
        /// Recommendation to enable dynamic image extensions on the account,
        /// allowing Google to find the best images from ad landing pages and
        /// complement text ads.
        DynamicImageExtensionOptIn = 43,
        /// Recommendation to raise Target CPA based on Google predictions modeled
        /// from past conversions. It is applied asynchronously and can take minutes
        /// depending on the number of ad groups there are in the related campaign.
        RaiseTargetCpa = 44,
        /// Recommendation to lower Target ROAS.
        LowerTargetRoas = 45,
        /// Recommendation to opt into Performance Max campaigns.
        PerformanceMaxOptIn = 46,
        /// Recommendation to improve the asset group strength of a Performance Max
        /// campaign to an "Excellent" rating.
        ImprovePerformanceMaxAdStrength = 47,
        /// Recommendation to migrate Dynamic Search Ads to Performance Max
        /// campaigns.
        MigrateDynamicSearchAdsCampaignToPerformanceMax = 48,
        /// Recommendation to set a target CPA for campaigns that do not have one
        /// specified, in advance of a seasonal event that is forecasted to increase
        /// traffic.
        ForecastingSetTargetCpa = 49,
        /// Recommendation to set a target CPA for campaigns that do not have one
        /// specified.
        SetTargetCpa = 50,
        /// Recommendation to set a target ROAS for campaigns that do not have one
        /// specified.
        SetTargetRoas = 51,
        /// Recommendation to update a campaign to use the Maximize Conversion Value
        /// bidding strategy.
        MaximizeConversionValueOptIn = 52,
        /// Recommendation to deploy Google Tag on more pages.
        ImproveGoogleTagCoverage = 53,
        /// Recommendation to turn on Final URL expansion for your Performance Max
        /// campaigns.
        PerformanceMaxFinalUrlOptIn = 54,
        /// Recommendation to update a customer list that hasn't been updated
        /// in the last 90 days.
        RefreshCustomerMatchList = 55,
        /// Recommendation to create a custom audience.
        CustomAudienceOptIn = 56,
        /// Recommendation to add lead form assets to campaign or customer level.
        LeadFormAsset = 57,
        /// Recommendation to improve the strength of ads in
        /// Demand Gen campaigns.
        ImproveDemandGenAdStrength = 58,
    }
    impl RecommendationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CampaignBudget => "CAMPAIGN_BUDGET",
                Self::Keyword => "KEYWORD",
                Self::TextAd => "TEXT_AD",
                Self::TargetCpaOptIn => "TARGET_CPA_OPT_IN",
                Self::MaximizeConversionsOptIn => "MAXIMIZE_CONVERSIONS_OPT_IN",
                Self::EnhancedCpcOptIn => "ENHANCED_CPC_OPT_IN",
                Self::SearchPartnersOptIn => "SEARCH_PARTNERS_OPT_IN",
                Self::MaximizeClicksOptIn => "MAXIMIZE_CLICKS_OPT_IN",
                Self::OptimizeAdRotation => "OPTIMIZE_AD_ROTATION",
                Self::KeywordMatchType => "KEYWORD_MATCH_TYPE",
                Self::MoveUnusedBudget => "MOVE_UNUSED_BUDGET",
                Self::ForecastingCampaignBudget => "FORECASTING_CAMPAIGN_BUDGET",
                Self::TargetRoasOptIn => "TARGET_ROAS_OPT_IN",
                Self::ResponsiveSearchAd => "RESPONSIVE_SEARCH_AD",
                Self::MarginalRoiCampaignBudget => "MARGINAL_ROI_CAMPAIGN_BUDGET",
                Self::UseBroadMatchKeyword => "USE_BROAD_MATCH_KEYWORD",
                Self::ResponsiveSearchAdAsset => "RESPONSIVE_SEARCH_AD_ASSET",
                Self::UpgradeSmartShoppingCampaignToPerformanceMax => {
                    "UPGRADE_SMART_SHOPPING_CAMPAIGN_TO_PERFORMANCE_MAX"
                }
                Self::ResponsiveSearchAdImproveAdStrength => {
                    "RESPONSIVE_SEARCH_AD_IMPROVE_AD_STRENGTH"
                }
                Self::DisplayExpansionOptIn => "DISPLAY_EXPANSION_OPT_IN",
                Self::UpgradeLocalCampaignToPerformanceMax => {
                    "UPGRADE_LOCAL_CAMPAIGN_TO_PERFORMANCE_MAX"
                }
                Self::RaiseTargetCpaBidTooLow => "RAISE_TARGET_CPA_BID_TOO_LOW",
                Self::ForecastingSetTargetRoas => "FORECASTING_SET_TARGET_ROAS",
                Self::CalloutAsset => "CALLOUT_ASSET",
                Self::SitelinkAsset => "SITELINK_ASSET",
                Self::CallAsset => "CALL_ASSET",
                Self::ShoppingAddAgeGroup => "SHOPPING_ADD_AGE_GROUP",
                Self::ShoppingAddColor => "SHOPPING_ADD_COLOR",
                Self::ShoppingAddGender => "SHOPPING_ADD_GENDER",
                Self::ShoppingAddGtin => "SHOPPING_ADD_GTIN",
                Self::ShoppingAddMoreIdentifiers => "SHOPPING_ADD_MORE_IDENTIFIERS",
                Self::ShoppingAddSize => "SHOPPING_ADD_SIZE",
                Self::ShoppingAddProductsToCampaign => {
                    "SHOPPING_ADD_PRODUCTS_TO_CAMPAIGN"
                }
                Self::ShoppingFixDisapprovedProducts => {
                    "SHOPPING_FIX_DISAPPROVED_PRODUCTS"
                }
                Self::ShoppingTargetAllOffers => "SHOPPING_TARGET_ALL_OFFERS",
                Self::ShoppingFixSuspendedMerchantCenterAccount => {
                    "SHOPPING_FIX_SUSPENDED_MERCHANT_CENTER_ACCOUNT"
                }
                Self::ShoppingFixMerchantCenterAccountSuspensionWarning => {
                    "SHOPPING_FIX_MERCHANT_CENTER_ACCOUNT_SUSPENSION_WARNING"
                }
                Self::ShoppingMigrateRegularShoppingCampaignOffersToPerformanceMax => {
                    "SHOPPING_MIGRATE_REGULAR_SHOPPING_CAMPAIGN_OFFERS_TO_PERFORMANCE_MAX"
                }
                Self::DynamicImageExtensionOptIn => "DYNAMIC_IMAGE_EXTENSION_OPT_IN",
                Self::RaiseTargetCpa => "RAISE_TARGET_CPA",
                Self::LowerTargetRoas => "LOWER_TARGET_ROAS",
                Self::PerformanceMaxOptIn => "PERFORMANCE_MAX_OPT_IN",
                Self::ImprovePerformanceMaxAdStrength => {
                    "IMPROVE_PERFORMANCE_MAX_AD_STRENGTH"
                }
                Self::MigrateDynamicSearchAdsCampaignToPerformanceMax => {
                    "MIGRATE_DYNAMIC_SEARCH_ADS_CAMPAIGN_TO_PERFORMANCE_MAX"
                }
                Self::ForecastingSetTargetCpa => "FORECASTING_SET_TARGET_CPA",
                Self::SetTargetCpa => "SET_TARGET_CPA",
                Self::SetTargetRoas => "SET_TARGET_ROAS",
                Self::MaximizeConversionValueOptIn => "MAXIMIZE_CONVERSION_VALUE_OPT_IN",
                Self::ImproveGoogleTagCoverage => "IMPROVE_GOOGLE_TAG_COVERAGE",
                Self::PerformanceMaxFinalUrlOptIn => "PERFORMANCE_MAX_FINAL_URL_OPT_IN",
                Self::RefreshCustomerMatchList => "REFRESH_CUSTOMER_MATCH_LIST",
                Self::CustomAudienceOptIn => "CUSTOM_AUDIENCE_OPT_IN",
                Self::LeadFormAsset => "LEAD_FORM_ASSET",
                Self::ImproveDemandGenAdStrength => "IMPROVE_DEMAND_GEN_AD_STRENGTH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_BUDGET" => Some(Self::CampaignBudget),
                "KEYWORD" => Some(Self::Keyword),
                "TEXT_AD" => Some(Self::TextAd),
                "TARGET_CPA_OPT_IN" => Some(Self::TargetCpaOptIn),
                "MAXIMIZE_CONVERSIONS_OPT_IN" => Some(Self::MaximizeConversionsOptIn),
                "ENHANCED_CPC_OPT_IN" => Some(Self::EnhancedCpcOptIn),
                "SEARCH_PARTNERS_OPT_IN" => Some(Self::SearchPartnersOptIn),
                "MAXIMIZE_CLICKS_OPT_IN" => Some(Self::MaximizeClicksOptIn),
                "OPTIMIZE_AD_ROTATION" => Some(Self::OptimizeAdRotation),
                "KEYWORD_MATCH_TYPE" => Some(Self::KeywordMatchType),
                "MOVE_UNUSED_BUDGET" => Some(Self::MoveUnusedBudget),
                "FORECASTING_CAMPAIGN_BUDGET" => Some(Self::ForecastingCampaignBudget),
                "TARGET_ROAS_OPT_IN" => Some(Self::TargetRoasOptIn),
                "RESPONSIVE_SEARCH_AD" => Some(Self::ResponsiveSearchAd),
                "MARGINAL_ROI_CAMPAIGN_BUDGET" => Some(Self::MarginalRoiCampaignBudget),
                "USE_BROAD_MATCH_KEYWORD" => Some(Self::UseBroadMatchKeyword),
                "RESPONSIVE_SEARCH_AD_ASSET" => Some(Self::ResponsiveSearchAdAsset),
                "UPGRADE_SMART_SHOPPING_CAMPAIGN_TO_PERFORMANCE_MAX" => {
                    Some(Self::UpgradeSmartShoppingCampaignToPerformanceMax)
                }
                "RESPONSIVE_SEARCH_AD_IMPROVE_AD_STRENGTH" => {
                    Some(Self::ResponsiveSearchAdImproveAdStrength)
                }
                "DISPLAY_EXPANSION_OPT_IN" => Some(Self::DisplayExpansionOptIn),
                "UPGRADE_LOCAL_CAMPAIGN_TO_PERFORMANCE_MAX" => {
                    Some(Self::UpgradeLocalCampaignToPerformanceMax)
                }
                "RAISE_TARGET_CPA_BID_TOO_LOW" => Some(Self::RaiseTargetCpaBidTooLow),
                "FORECASTING_SET_TARGET_ROAS" => Some(Self::ForecastingSetTargetRoas),
                "CALLOUT_ASSET" => Some(Self::CalloutAsset),
                "SITELINK_ASSET" => Some(Self::SitelinkAsset),
                "CALL_ASSET" => Some(Self::CallAsset),
                "SHOPPING_ADD_AGE_GROUP" => Some(Self::ShoppingAddAgeGroup),
                "SHOPPING_ADD_COLOR" => Some(Self::ShoppingAddColor),
                "SHOPPING_ADD_GENDER" => Some(Self::ShoppingAddGender),
                "SHOPPING_ADD_GTIN" => Some(Self::ShoppingAddGtin),
                "SHOPPING_ADD_MORE_IDENTIFIERS" => Some(Self::ShoppingAddMoreIdentifiers),
                "SHOPPING_ADD_SIZE" => Some(Self::ShoppingAddSize),
                "SHOPPING_ADD_PRODUCTS_TO_CAMPAIGN" => {
                    Some(Self::ShoppingAddProductsToCampaign)
                }
                "SHOPPING_FIX_DISAPPROVED_PRODUCTS" => {
                    Some(Self::ShoppingFixDisapprovedProducts)
                }
                "SHOPPING_TARGET_ALL_OFFERS" => Some(Self::ShoppingTargetAllOffers),
                "SHOPPING_FIX_SUSPENDED_MERCHANT_CENTER_ACCOUNT" => {
                    Some(Self::ShoppingFixSuspendedMerchantCenterAccount)
                }
                "SHOPPING_FIX_MERCHANT_CENTER_ACCOUNT_SUSPENSION_WARNING" => {
                    Some(Self::ShoppingFixMerchantCenterAccountSuspensionWarning)
                }
                "SHOPPING_MIGRATE_REGULAR_SHOPPING_CAMPAIGN_OFFERS_TO_PERFORMANCE_MAX" => {
                    Some(
                        Self::ShoppingMigrateRegularShoppingCampaignOffersToPerformanceMax,
                    )
                }
                "DYNAMIC_IMAGE_EXTENSION_OPT_IN" => {
                    Some(Self::DynamicImageExtensionOptIn)
                }
                "RAISE_TARGET_CPA" => Some(Self::RaiseTargetCpa),
                "LOWER_TARGET_ROAS" => Some(Self::LowerTargetRoas),
                "PERFORMANCE_MAX_OPT_IN" => Some(Self::PerformanceMaxOptIn),
                "IMPROVE_PERFORMANCE_MAX_AD_STRENGTH" => {
                    Some(Self::ImprovePerformanceMaxAdStrength)
                }
                "MIGRATE_DYNAMIC_SEARCH_ADS_CAMPAIGN_TO_PERFORMANCE_MAX" => {
                    Some(Self::MigrateDynamicSearchAdsCampaignToPerformanceMax)
                }
                "FORECASTING_SET_TARGET_CPA" => Some(Self::ForecastingSetTargetCpa),
                "SET_TARGET_CPA" => Some(Self::SetTargetCpa),
                "SET_TARGET_ROAS" => Some(Self::SetTargetRoas),
                "MAXIMIZE_CONVERSION_VALUE_OPT_IN" => {
                    Some(Self::MaximizeConversionValueOptIn)
                }
                "IMPROVE_GOOGLE_TAG_COVERAGE" => Some(Self::ImproveGoogleTagCoverage),
                "PERFORMANCE_MAX_FINAL_URL_OPT_IN" => {
                    Some(Self::PerformanceMaxFinalUrlOptIn)
                }
                "REFRESH_CUSTOMER_MATCH_LIST" => Some(Self::RefreshCustomerMatchList),
                "CUSTOM_AUDIENCE_OPT_IN" => Some(Self::CustomAudienceOptIn),
                "LEAD_FORM_ASSET" => Some(Self::LeadFormAsset),
                "IMPROVE_DEMAND_GEN_AD_STRENGTH" => {
                    Some(Self::ImproveDemandGenAdStrength)
                }
                _ => None,
            }
        }
    }
}
/// The type of the search engine results page.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SearchEngineResultsPageTypeEnum {}
/// Nested message and enum types in `SearchEngineResultsPageTypeEnum`.
pub mod search_engine_results_page_type_enum {
    /// The type of the search engine results page.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SearchEngineResultsPageType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Only ads were contained in the search engine results page.
        AdsOnly = 2,
        /// Only organic results were contained in the search engine results page.
        OrganicOnly = 3,
        /// Both ads and organic results were contained in the search engine results
        /// page.
        AdsAndOrganic = 4,
    }
    impl SearchEngineResultsPageType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AdsOnly => "ADS_ONLY",
                Self::OrganicOnly => "ORGANIC_ONLY",
                Self::AdsAndOrganic => "ADS_AND_ORGANIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADS_ONLY" => Some(Self::AdsOnly),
                "ORGANIC_ONLY" => Some(Self::OrganicOnly),
                "ADS_AND_ORGANIC" => Some(Self::AdsAndOrganic),
                _ => None,
            }
        }
    }
}
/// Container for enum describing match types for a keyword triggering an ad.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SearchTermMatchTypeEnum {}
/// Nested message and enum types in `SearchTermMatchTypeEnum`.
pub mod search_term_match_type_enum {
    /// Possible match types for a keyword triggering an ad, including variants.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SearchTermMatchType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Broad match.
        Broad = 2,
        /// Exact match.
        Exact = 3,
        /// Phrase match.
        Phrase = 4,
        /// Exact match (close variant).
        NearExact = 5,
        /// Phrase match (close variant).
        NearPhrase = 6,
    }
    impl SearchTermMatchType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Broad => "BROAD",
                Self::Exact => "EXACT",
                Self::Phrase => "PHRASE",
                Self::NearExact => "NEAR_EXACT",
                Self::NearPhrase => "NEAR_PHRASE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BROAD" => Some(Self::Broad),
                "EXACT" => Some(Self::Exact),
                "PHRASE" => Some(Self::Phrase),
                "NEAR_EXACT" => Some(Self::NearExact),
                "NEAR_PHRASE" => Some(Self::NearPhrase),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of SkAdNetwork ad event types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SkAdNetworkAdEventTypeEnum {}
/// Nested message and enum types in `SkAdNetworkAdEventTypeEnum`.
pub mod sk_ad_network_ad_event_type_enum {
    /// Enumerates SkAdNetwork ad event types
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SkAdNetworkAdEventType {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// The value was not present in the postback or we do not have this data for
        /// other reasons.
        Unavailable = 2,
        /// The user interacted with the ad.
        Interaction = 3,
        /// The user viewed the ad.
        View = 4,
    }
    impl SkAdNetworkAdEventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Unavailable => "UNAVAILABLE",
                Self::Interaction => "INTERACTION",
                Self::View => "VIEW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "INTERACTION" => Some(Self::Interaction),
                "VIEW" => Some(Self::View),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of SkAdNetwork attribution credits.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SkAdNetworkAttributionCreditEnum {}
/// Nested message and enum types in `SkAdNetworkAttributionCreditEnum`.
pub mod sk_ad_network_attribution_credit_enum {
    /// Enumerates SkAdNetwork attribution credits.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SkAdNetworkAttributionCredit {
        /// Default value. This value is equivalent to null.
        Unspecified = 0,
        /// The value is unknown in this API version. The true enum value cannot be
        /// returned in this API version or is not supported yet.
        Unknown = 1,
        /// The value was not present in the postback or we do not have this data for
        /// other reasons.
        Unavailable = 2,
        /// Google was the ad network that won ad attribution.
        Won = 3,
        /// Google qualified for attribution, but didn't win.
        Contributed = 4,
    }
    impl SkAdNetworkAttributionCredit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Unavailable => "UNAVAILABLE",
                Self::Won => "WON",
                Self::Contributed => "CONTRIBUTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "WON" => Some(Self::Won),
                "CONTRIBUTED" => Some(Self::Contributed),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of SkAdNetwork coarse conversion values.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SkAdNetworkCoarseConversionValueEnum {}
/// Nested message and enum types in `SkAdNetworkCoarseConversionValueEnum`.
pub mod sk_ad_network_coarse_conversion_value_enum {
    /// Enumerates SkAdNetwork coarse conversion values
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SkAdNetworkCoarseConversionValue {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// The value was not present in the postback or we do not have this data for
        /// other reasons.
        Unavailable = 2,
        /// A low coarse conversion value.
        Low = 3,
        /// A medium coarse conversion value.
        Medium = 4,
        /// A high coarse conversion value.
        High = 5,
        /// A coarse conversion value was not configured.
        None = 6,
    }
    impl SkAdNetworkCoarseConversionValue {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Unavailable => "UNAVAILABLE",
                Self::Low => "LOW",
                Self::Medium => "MEDIUM",
                Self::High => "HIGH",
                Self::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "LOW" => Some(Self::Low),
                "MEDIUM" => Some(Self::Medium),
                "HIGH" => Some(Self::High),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of SkAdNetwork source types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SkAdNetworkSourceTypeEnum {}
/// Nested message and enum types in `SkAdNetworkSourceTypeEnum`.
pub mod sk_ad_network_source_type_enum {
    /// Enumerates SkAdNetwork source types
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SkAdNetworkSourceType {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// The source app ID or source domain was not present in the postback or we
        /// do not have this data for other reasons.
        Unavailable = 2,
        /// The ad was shown on a webpage.
        Website = 3,
        /// The ad was shown on an app.
        MobileApplication = 4,
    }
    impl SkAdNetworkSourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Unavailable => "UNAVAILABLE",
                Self::Website => "WEBSITE",
                Self::MobileApplication => "MOBILE_APPLICATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "WEBSITE" => Some(Self::Website),
                "MOBILE_APPLICATION" => Some(Self::MobileApplication),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of SkAdNetwork user types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SkAdNetworkUserTypeEnum {}
/// Nested message and enum types in `SkAdNetworkUserTypeEnum`.
pub mod sk_ad_network_user_type_enum {
    /// Enumerates SkAdNetwork user types
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SkAdNetworkUserType {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// The value was not present in the postback or we do not have this data for
        /// other reasons.
        Unavailable = 2,
        /// The user installed the app for the first time.
        NewInstaller = 3,
        /// The user has previously installed the app.
        Reinstaller = 4,
    }
    impl SkAdNetworkUserType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Unavailable => "UNAVAILABLE",
                Self::NewInstaller => "NEW_INSTALLER",
                Self::Reinstaller => "REINSTALLER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "NEW_INSTALLER" => Some(Self::NewInstaller),
                "REINSTALLER" => Some(Self::Reinstaller),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of possible positions of the Ad.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SlotEnum {}
/// Nested message and enum types in `SlotEnum`.
pub mod slot_enum {
    /// Enumerates possible positions of the Ad.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Slot {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Google search: Side.
        SearchSide = 2,
        /// Google search: Top.
        SearchTop = 3,
        /// Google search: Other.
        SearchOther = 4,
        /// Google Display Network.
        Content = 5,
        /// Search partners: Top.
        SearchPartnerTop = 6,
        /// Search partners: Other.
        SearchPartnerOther = 7,
        /// Cross-network.
        Mixed = 8,
    }
    impl Slot {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::SearchSide => "SEARCH_SIDE",
                Self::SearchTop => "SEARCH_TOP",
                Self::SearchOther => "SEARCH_OTHER",
                Self::Content => "CONTENT",
                Self::SearchPartnerTop => "SEARCH_PARTNER_TOP",
                Self::SearchPartnerOther => "SEARCH_PARTNER_OTHER",
                Self::Mixed => "MIXED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEARCH_SIDE" => Some(Self::SearchSide),
                "SEARCH_TOP" => Some(Self::SearchTop),
                "SEARCH_OTHER" => Some(Self::SearchOther),
                "CONTENT" => Some(Self::Content),
                "SEARCH_PARTNER_TOP" => Some(Self::SearchPartnerTop),
                "SEARCH_PARTNER_OTHER" => Some(Self::SearchPartnerOther),
                "MIXED" => Some(Self::Mixed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the format of the web page where the tracking
/// tag and snippet will be installed.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrackingCodePageFormatEnum {}
/// Nested message and enum types in `TrackingCodePageFormatEnum`.
pub mod tracking_code_page_format_enum {
    /// The format of the web page where the tracking tag and snippet will be
    /// installed.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TrackingCodePageFormat {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Standard HTML page format.
        Html = 2,
        /// Google AMP page format.
        Amp = 3,
    }
    impl TrackingCodePageFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Html => "HTML",
                Self::Amp => "AMP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "HTML" => Some(Self::Html),
                "AMP" => Some(Self::Amp),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of the generated tag snippets for
/// tracking conversions.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrackingCodeTypeEnum {}
/// Nested message and enum types in `TrackingCodeTypeEnum`.
pub mod tracking_code_type_enum {
    /// The type of the generated tag snippets for tracking conversions.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TrackingCodeType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The snippet that is fired as a result of a website page loading.
        Webpage = 2,
        /// The snippet contains a JavaScript function which fires the tag. This
        /// function is typically called from an onClick handler added to a link or
        /// button element on the page.
        WebpageOnclick = 3,
        /// For embedding on a mobile webpage. The snippet contains a JavaScript
        /// function which fires the tag.
        ClickToCall = 4,
        /// The snippet that is used to replace the phone number on your website with
        /// a Google forwarding number for call tracking purposes.
        WebsiteCall = 5,
    }
    impl TrackingCodeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Webpage => "WEBPAGE",
                Self::WebpageOnclick => "WEBPAGE_ONCLICK",
                Self::ClickToCall => "CLICK_TO_CALL",
                Self::WebsiteCall => "WEBSITE_CALL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "WEBPAGE" => Some(Self::Webpage),
                "WEBPAGE_ONCLICK" => Some(Self::WebpageOnclick),
                "CLICK_TO_CALL" => Some(Self::ClickToCall),
                "WEBSITE_CALL" => Some(Self::WebsiteCall),
                _ => None,
            }
        }
    }
}
/// The dimensions that can be targeted.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TargetingDimensionEnum {}
/// Nested message and enum types in `TargetingDimensionEnum`.
pub mod targeting_dimension_enum {
    /// Enum describing possible targeting dimensions.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetingDimension {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Keyword criteria, for example, 'mars cruise'. KEYWORD may be used as a
        /// custom bid dimension. Keywords are always a targeting dimension, so may
        /// not be set as a target "ALL" dimension with TargetRestriction.
        Keyword = 2,
        /// Audience criteria, which include user list, user interest, custom
        /// affinity,  and custom in market.
        Audience = 3,
        /// Topic criteria for targeting categories of content, for example,
        /// 'category::Animals>Pets' Used for Display and Video targeting.
        Topic = 4,
        /// Criteria for targeting gender.
        Gender = 5,
        /// Criteria for targeting age ranges.
        AgeRange = 6,
        /// Placement criteria, which include websites like 'www.flowers4sale.com',
        /// as well as mobile applications, mobile app categories, YouTube videos,
        /// and YouTube channels.
        Placement = 7,
        /// Criteria for parental status targeting.
        ParentalStatus = 8,
        /// Criteria for income range targeting.
        IncomeRange = 9,
    }
    impl TargetingDimension {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Keyword => "KEYWORD",
                Self::Audience => "AUDIENCE",
                Self::Topic => "TOPIC",
                Self::Gender => "GENDER",
                Self::AgeRange => "AGE_RANGE",
                Self::Placement => "PLACEMENT",
                Self::ParentalStatus => "PARENTAL_STATUS",
                Self::IncomeRange => "INCOME_RANGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "KEYWORD" => Some(Self::Keyword),
                "AUDIENCE" => Some(Self::Audience),
                "TOPIC" => Some(Self::Topic),
                "GENDER" => Some(Self::Gender),
                "AGE_RANGE" => Some(Self::AgeRange),
                "PLACEMENT" => Some(Self::Placement),
                "PARENTAL_STATUS" => Some(Self::ParentalStatus),
                "INCOME_RANGE" => Some(Self::IncomeRange),
                _ => None,
            }
        }
    }
}
/// Indicates what type of data are the user list's members matched from.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerMatchUploadKeyTypeEnum {}
/// Nested message and enum types in `CustomerMatchUploadKeyTypeEnum`.
pub mod customer_match_upload_key_type_enum {
    /// Enum describing possible customer match upload key types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerMatchUploadKeyType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Members are matched from customer info such as email address, phone
        /// number or physical address.
        ContactInfo = 2,
        /// Members are matched from a user id generated and assigned by the
        /// advertiser.
        CrmId = 3,
        /// Members are matched from mobile advertising ids.
        MobileAdvertisingId = 4,
    }
    impl CustomerMatchUploadKeyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ContactInfo => "CONTACT_INFO",
                Self::CrmId => "CRM_ID",
                Self::MobileAdvertisingId => "MOBILE_ADVERTISING_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CONTACT_INFO" => Some(Self::ContactInfo),
                "CRM_ID" => Some(Self::CrmId),
                "MOBILE_ADVERTISING_ID" => Some(Self::MobileAdvertisingId),
                _ => None,
            }
        }
    }
}
/// Lookalike Expansion level proto
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LookalikeExpansionLevelEnum {}
/// Nested message and enum types in `LookalikeExpansionLevelEnum`.
pub mod lookalike_expansion_level_enum {
    /// Expansion level, reflecting the size of the lookalike audience
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LookalikeExpansionLevel {
        /// Not specified.
        Unspecified = 0,
        /// Invalid expansion level.
        Unknown = 1,
        /// Expansion to a small set of users that are similar to the seed lists
        Narrow = 2,
        /// Expansion to a medium set of users that are similar to the seed lists.
        /// Includes all users of EXPANSION_LEVEL_NARROW, and more.
        Balanced = 3,
        /// Expansion to a large set of users that are similar to the seed lists.
        /// Includes all users of EXPANSION_LEVEL_BALANCED, and more.
        Broad = 4,
    }
    impl LookalikeExpansionLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Narrow => "NARROW",
                Self::Balanced => "BALANCED",
                Self::Broad => "BROAD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NARROW" => Some(Self::Narrow),
                "BALANCED" => Some(Self::Balanced),
                "BROAD" => Some(Self::Broad),
                _ => None,
            }
        }
    }
}
/// Indicates source of Crm upload data.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListCrmDataSourceTypeEnum {}
/// Nested message and enum types in `UserListCrmDataSourceTypeEnum`.
pub mod user_list_crm_data_source_type_enum {
    /// Enum describing possible user list crm data source type.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListCrmDataSourceType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The uploaded data is first-party data.
        FirstParty = 2,
        /// The uploaded data is from a third-party credit bureau.
        ThirdPartyCreditBureau = 3,
        /// The uploaded data is from a third-party voter file.
        ThirdPartyVoterFile = 4,
    }
    impl UserListCrmDataSourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::FirstParty => "FIRST_PARTY",
                Self::ThirdPartyCreditBureau => "THIRD_PARTY_CREDIT_BUREAU",
                Self::ThirdPartyVoterFile => "THIRD_PARTY_VOTER_FILE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FIRST_PARTY" => Some(Self::FirstParty),
                "THIRD_PARTY_CREDIT_BUREAU" => Some(Self::ThirdPartyCreditBureau),
                "THIRD_PARTY_VOTER_FILE" => Some(Self::ThirdPartyVoterFile),
                _ => None,
            }
        }
    }
}
/// Supported rule operator for date type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListDateRuleItemOperatorEnum {}
/// Nested message and enum types in `UserListDateRuleItemOperatorEnum`.
pub mod user_list_date_rule_item_operator_enum {
    /// Enum describing possible user list date rule item operators.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListDateRuleItemOperator {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Equals.
        Equals = 2,
        /// Not Equals.
        NotEquals = 3,
        /// Before.
        Before = 4,
        /// After.
        After = 5,
    }
    impl UserListDateRuleItemOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Equals => "EQUALS",
                Self::NotEquals => "NOT_EQUALS",
                Self::Before => "BEFORE",
                Self::After => "AFTER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EQUALS" => Some(Self::Equals),
                "NOT_EQUALS" => Some(Self::NotEquals),
                "BEFORE" => Some(Self::Before),
                "AFTER" => Some(Self::After),
                _ => None,
            }
        }
    }
}
/// Logical operator connecting two rules.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListFlexibleRuleOperatorEnum {}
/// Nested message and enum types in `UserListFlexibleRuleOperatorEnum`.
pub mod user_list_flexible_rule_operator_enum {
    /// Enum describing possible user list combined rule operators.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListFlexibleRuleOperator {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// A AND B.
        And = 2,
        /// A OR B.
        Or = 3,
    }
    impl UserListFlexibleRuleOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::And => "AND",
                Self::Or => "OR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AND" => Some(Self::And),
                "OR" => Some(Self::Or),
                _ => None,
            }
        }
    }
}
/// The logical operator of the rule.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListLogicalRuleOperatorEnum {}
/// Nested message and enum types in `UserListLogicalRuleOperatorEnum`.
pub mod user_list_logical_rule_operator_enum {
    /// Enum describing possible user list logical rule operators.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListLogicalRuleOperator {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// And - all of the operands.
        All = 2,
        /// Or - at least one of the operands.
        Any = 3,
        /// Not - none of the operands.
        None = 4,
    }
    impl UserListLogicalRuleOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::All => "ALL",
                Self::Any => "ANY",
                Self::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ALL" => Some(Self::All),
                "ANY" => Some(Self::Any),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
/// Supported rule operator for number type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListNumberRuleItemOperatorEnum {}
/// Nested message and enum types in `UserListNumberRuleItemOperatorEnum`.
pub mod user_list_number_rule_item_operator_enum {
    /// Enum describing possible user list number rule item operators.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListNumberRuleItemOperator {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Greater than.
        GreaterThan = 2,
        /// Greater than or equal.
        GreaterThanOrEqual = 3,
        /// Equals.
        Equals = 4,
        /// Not equals.
        NotEquals = 5,
        /// Less than.
        LessThan = 6,
        /// Less than or equal.
        LessThanOrEqual = 7,
    }
    impl UserListNumberRuleItemOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::GreaterThan => "GREATER_THAN",
                Self::GreaterThanOrEqual => "GREATER_THAN_OR_EQUAL",
                Self::Equals => "EQUALS",
                Self::NotEquals => "NOT_EQUALS",
                Self::LessThan => "LESS_THAN",
                Self::LessThanOrEqual => "LESS_THAN_OR_EQUAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "GREATER_THAN" => Some(Self::GreaterThan),
                "GREATER_THAN_OR_EQUAL" => Some(Self::GreaterThanOrEqual),
                "EQUALS" => Some(Self::Equals),
                "NOT_EQUALS" => Some(Self::NotEquals),
                "LESS_THAN" => Some(Self::LessThan),
                "LESS_THAN_OR_EQUAL" => Some(Self::LessThanOrEqual),
                _ => None,
            }
        }
    }
}
/// Indicates status of prepopulation based on the rule.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListPrepopulationStatusEnum {}
/// Nested message and enum types in `UserListPrepopulationStatusEnum`.
pub mod user_list_prepopulation_status_enum {
    /// Enum describing possible user list prepopulation status.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListPrepopulationStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Prepopoulation is being requested.
        Requested = 2,
        /// Prepopulation is finished.
        Finished = 3,
        /// Prepopulation failed.
        Failed = 4,
    }
    impl UserListPrepopulationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Requested => "REQUESTED",
                Self::Finished => "FINISHED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "REQUESTED" => Some(Self::Requested),
                "FINISHED" => Some(Self::Finished),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Rule based user list rule type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListRuleTypeEnum {}
/// Nested message and enum types in `UserListRuleTypeEnum`.
pub mod user_list_rule_type_enum {
    /// Enum describing possible user list rule types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListRuleType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Conjunctive normal form.
        AndOfOrs = 2,
        /// Disjunctive normal form.
        OrOfAnds = 3,
    }
    impl UserListRuleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AndOfOrs => "AND_OF_ORS",
                Self::OrOfAnds => "OR_OF_ANDS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AND_OF_ORS" => Some(Self::AndOfOrs),
                "OR_OF_ANDS" => Some(Self::OrOfAnds),
                _ => None,
            }
        }
    }
}
/// Supported rule operator for string type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListStringRuleItemOperatorEnum {}
/// Nested message and enum types in `UserListStringRuleItemOperatorEnum`.
pub mod user_list_string_rule_item_operator_enum {
    /// Enum describing possible user list string rule item operators.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListStringRuleItemOperator {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Contains.
        Contains = 2,
        /// Equals.
        Equals = 3,
        /// Starts with.
        StartsWith = 4,
        /// Ends with.
        EndsWith = 5,
        /// Not equals.
        NotEquals = 6,
        /// Not contains.
        NotContains = 7,
        /// Not starts with.
        NotStartsWith = 8,
        /// Not ends with.
        NotEndsWith = 9,
    }
    impl UserListStringRuleItemOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Contains => "CONTAINS",
                Self::Equals => "EQUALS",
                Self::StartsWith => "STARTS_WITH",
                Self::EndsWith => "ENDS_WITH",
                Self::NotEquals => "NOT_EQUALS",
                Self::NotContains => "NOT_CONTAINS",
                Self::NotStartsWith => "NOT_STARTS_WITH",
                Self::NotEndsWith => "NOT_ENDS_WITH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CONTAINS" => Some(Self::Contains),
                "EQUALS" => Some(Self::Equals),
                "STARTS_WITH" => Some(Self::StartsWith),
                "ENDS_WITH" => Some(Self::EndsWith),
                "NOT_EQUALS" => Some(Self::NotEquals),
                "NOT_CONTAINS" => Some(Self::NotContains),
                "NOT_STARTS_WITH" => Some(Self::NotStartsWith),
                "NOT_ENDS_WITH" => Some(Self::NotEndsWith),
                _ => None,
            }
        }
    }
}
/// Container for enum for identifying the status of access invitation
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccessInvitationStatusEnum {}
/// Nested message and enum types in `AccessInvitationStatusEnum`.
pub mod access_invitation_status_enum {
    /// Possible access invitation status of a user
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccessInvitationStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The initial state of an invitation, before being acted upon by anyone.
        Pending = 2,
        /// Invitation process was terminated by the email recipient. No new user was
        /// created.
        Declined = 3,
        /// Invitation URLs expired without being acted upon. No new user can be
        /// created.  Invitations expire 20 days after creation.
        Expired = 4,
    }
    impl AccessInvitationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Pending => "PENDING",
                Self::Declined => "DECLINED",
                Self::Expired => "EXPIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "DECLINED" => Some(Self::Declined),
                "EXPIRED" => Some(Self::Expired),
                _ => None,
            }
        }
    }
}
/// Indicates the way the resource such as user list is related to a user.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccessReasonEnum {}
/// Nested message and enum types in `AccessReasonEnum`.
pub mod access_reason_enum {
    /// Enum describing possible access reasons.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccessReason {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The resource is owned by the user.
        Owned = 2,
        /// The resource is shared to the user.
        Shared = 3,
        /// The resource is licensed to the user.
        Licensed = 4,
        /// The user subscribed to the resource.
        Subscribed = 5,
        /// The resource is accessible to the user.
        Affiliated = 6,
    }
    impl AccessReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Owned => "OWNED",
                Self::Shared => "SHARED",
                Self::Licensed => "LICENSED",
                Self::Subscribed => "SUBSCRIBED",
                Self::Affiliated => "AFFILIATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OWNED" => Some(Self::Owned),
                "SHARED" => Some(Self::Shared),
                "LICENSED" => Some(Self::Licensed),
                "SUBSCRIBED" => Some(Self::Subscribed),
                "AFFILIATED" => Some(Self::Affiliated),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible access role for user.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccessRoleEnum {}
/// Nested message and enum types in `AccessRoleEnum`.
pub mod access_role_enum {
    /// Possible access role of a user.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccessRole {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Owns its account and can control the addition of other users.
        Admin = 2,
        /// Can modify campaigns, but can't affect other users.
        Standard = 3,
        /// Can view campaigns and account changes, but cannot make edits.
        ReadOnly = 4,
        /// Role for \"email only\" access. Represents an email recipient rather than
        /// a true User entity.
        EmailOnly = 5,
    }
    impl AccessRole {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Admin => "ADMIN",
                Self::Standard => "STANDARD",
                Self::ReadOnly => "READ_ONLY",
                Self::EmailOnly => "EMAIL_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADMIN" => Some(Self::Admin),
                "STANDARD" => Some(Self::Standard),
                "READ_ONLY" => Some(Self::ReadOnly),
                "EMAIL_ONLY" => Some(Self::EmailOnly),
                _ => None,
            }
        }
    }
}
/// Message describing AccountBudgetProposal statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccountBudgetProposalStatusEnum {}
/// Nested message and enum types in `AccountBudgetProposalStatusEnum`.
pub mod account_budget_proposal_status_enum {
    /// The possible statuses of an AccountBudgetProposal.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountBudgetProposalStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The proposal is pending approval.
        Pending = 2,
        /// The proposal has been approved but the corresponding billing setup
        /// has not.  This can occur for proposals that set up the first budget
        /// when signing up for billing or when performing a change of bill-to
        /// operation.
        ApprovedHeld = 3,
        /// The proposal has been approved.
        Approved = 4,
        /// The proposal has been cancelled by the user.
        Cancelled = 5,
        /// The proposal has been rejected by the user, for example, by rejecting an
        /// acceptance email.
        Rejected = 6,
    }
    impl AccountBudgetProposalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Pending => "PENDING",
                Self::ApprovedHeld => "APPROVED_HELD",
                Self::Approved => "APPROVED",
                Self::Cancelled => "CANCELLED",
                Self::Rejected => "REJECTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "APPROVED_HELD" => Some(Self::ApprovedHeld),
                "APPROVED" => Some(Self::Approved),
                "CANCELLED" => Some(Self::Cancelled),
                "REJECTED" => Some(Self::Rejected),
                _ => None,
            }
        }
    }
}
/// Message describing AccountBudgetProposal types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccountBudgetProposalTypeEnum {}
/// Nested message and enum types in `AccountBudgetProposalTypeEnum`.
pub mod account_budget_proposal_type_enum {
    /// The possible types of an AccountBudgetProposal.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountBudgetProposalType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Identifies a request to create a new budget.
        Create = 2,
        /// Identifies a request to edit an existing budget.
        Update = 3,
        /// Identifies a request to end a budget that has already started.
        End = 4,
        /// Identifies a request to remove a budget that hasn't started yet.
        Remove = 5,
    }
    impl AccountBudgetProposalType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Create => "CREATE",
                Self::Update => "UPDATE",
                Self::End => "END",
                Self::Remove => "REMOVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CREATE" => Some(Self::Create),
                "UPDATE" => Some(Self::Update),
                "END" => Some(Self::End),
                "REMOVE" => Some(Self::Remove),
                _ => None,
            }
        }
    }
}
/// Message describing AccountBudget statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccountBudgetStatusEnum {}
/// Nested message and enum types in `AccountBudgetStatusEnum`.
pub mod account_budget_status_enum {
    /// The possible statuses of an AccountBudget.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountBudgetStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The account budget is pending approval.
        Pending = 2,
        /// The account budget has been approved.
        Approved = 3,
        /// The account budget has been cancelled by the user.
        Cancelled = 4,
    }
    impl AccountBudgetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Pending => "PENDING",
                Self::Approved => "APPROVED",
                Self::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "APPROVED" => Some(Self::Approved),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of an account link.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccountLinkStatusEnum {}
/// Nested message and enum types in `AccountLinkStatusEnum`.
pub mod account_link_status_enum {
    /// Describes the possible statuses for a link between a Google Ads customer
    /// and another account.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountLinkStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The link is enabled.
        Enabled = 2,
        /// The link is removed/disabled.
        Removed = 3,
        /// The link to the other account has been requested. A user on the other
        /// account may now approve the link by setting the status to ENABLED.
        Requested = 4,
        /// This link has been requested by a user on the other account. It may be
        /// approved by a user on this account by setting the status to ENABLED.
        PendingApproval = 5,
        /// The link is rejected by the approver.
        Rejected = 6,
        /// The link is revoked by the user who requested the link.
        Revoked = 7,
    }
    impl AccountLinkStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
                Self::Requested => "REQUESTED",
                Self::PendingApproval => "PENDING_APPROVAL",
                Self::Rejected => "REJECTED",
                Self::Revoked => "REVOKED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                "REQUESTED" => Some(Self::Requested),
                "PENDING_APPROVAL" => Some(Self::PendingApproval),
                "REJECTED" => Some(Self::Rejected),
                "REVOKED" => Some(Self::Revoked),
                _ => None,
            }
        }
    }
}
/// Values for Ad Customizer placeholder fields.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdCustomizerPlaceholderFieldEnum {}
/// Nested message and enum types in `AdCustomizerPlaceholderFieldEnum`.
pub mod ad_customizer_placeholder_field_enum {
    /// Possible values for Ad Customizers placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdCustomizerPlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: INT64. Integer value to be inserted.
        Integer = 2,
        /// Data Type: STRING. Price value to be inserted.
        Price = 3,
        /// Data Type: DATE_TIME. Date value to be inserted.
        Date = 4,
        /// Data Type: STRING. String value to be inserted.
        String = 5,
    }
    impl AdCustomizerPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Integer => "INTEGER",
                Self::Price => "PRICE",
                Self::Date => "DATE",
                Self::String => "STRING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INTEGER" => Some(Self::Integer),
                "PRICE" => Some(Self::Price),
                "DATE" => Some(Self::Date),
                "STRING" => Some(Self::String),
                _ => None,
            }
        }
    }
}
/// Ad Group Ad Primary Status. Provides insight into why an ad group ad is not
/// serving or not serving optimally.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupAdPrimaryStatusEnum {}
/// Nested message and enum types in `AdGroupAdPrimaryStatusEnum`.
pub mod ad_group_ad_primary_status_enum {
    /// The possible statuses of an AdGroupAd.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupAdPrimaryStatus {
        /// No value has been specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The ad group ad is eligible to serve.
        Eligible = 2,
        /// The ad group ad is paused.
        Paused = 3,
        /// The ad group ad is removed.
        Removed = 4,
        /// The ad cannot serve now, but may serve later without advertiser action.
        Pending = 5,
        /// The ad group ad is serving in a limited capacity.
        Limited = 6,
        /// The ad group ad is not eligible to serve.
        NotEligible = 7,
    }
    impl AdGroupAdPrimaryStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Eligible => "ELIGIBLE",
                Self::Paused => "PAUSED",
                Self::Removed => "REMOVED",
                Self::Pending => "PENDING",
                Self::Limited => "LIMITED",
                Self::NotEligible => "NOT_ELIGIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ELIGIBLE" => Some(Self::Eligible),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                "PENDING" => Some(Self::Pending),
                "LIMITED" => Some(Self::Limited),
                "NOT_ELIGIBLE" => Some(Self::NotEligible),
                _ => None,
            }
        }
    }
}
/// AdGroupAd Primary Status Reason. Provides insight into why an ad group ad is
/// not serving or not serving optimally. These reasons are aggregated to
/// determine an overall AdGroupAdPrimaryStatus.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupAdPrimaryStatusReasonEnum {}
/// Nested message and enum types in `AdGroupAdPrimaryStatusReasonEnum`.
pub mod ad_group_ad_primary_status_reason_enum {
    /// Possible ad group ad status reasons.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupAdPrimaryStatusReason {
        /// No value has been specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The user-specified campaign status is removed. Contributes to
        /// AdGroupAdPrimaryStatus.REMOVED.
        CampaignRemoved = 2,
        /// The user-specified campaign status is paused. Contributes to
        /// AdGroupAdPrimaryStatus.PAUSED.
        CampaignPaused = 3,
        /// The user-specified time for this campaign to start is in the future.
        /// Contributes to AdGroupAdPrimaryStatus.PENDING.
        CampaignPending = 4,
        /// The user-specified time for this campaign to end has passed. Contributes
        /// to AdGroupAdPrimaryStatus.ENDED.
        CampaignEnded = 5,
        /// The user-specified ad group status is paused. Contributes to
        /// AdGroupAdPrimaryStatus.PAUSED.
        AdGroupPaused = 6,
        /// The user-specified ad group status is removed. Contributes to
        /// AdGroupAdPrimaryStatus.REMOVED.
        AdGroupRemoved = 7,
        /// The user-specified ad status is paused. Contributes to
        /// AdGroupAdPrimaryStatus.PAUSED.
        AdGroupAdPaused = 8,
        /// The user-specified ad status is removed. Contributes to
        /// AdGroupAdPrimaryStatus.REMOVED.
        AdGroupAdRemoved = 9,
        /// The ad is disapproved. Contributes to
        /// AdGroupAdPrimaryStatus.NOT_ELIGIBLE.
        AdGroupAdDisapproved = 10,
        /// The ad is under review. Contributes to AdGroupAdPrimaryStatus.PENDING.
        AdGroupAdUnderReview = 11,
        /// The ad is poor quality. This is determined by the serving stack that
        /// served the Ad. Contributes to AdGroupAdPrimaryStatus.LIMITED.
        AdGroupAdPoorQuality = 12,
        /// No eligible ads instances could be generated. Contributes to
        /// AdGroupAdPrimaryStatus.PENDING.
        AdGroupAdNoAds = 13,
        /// The ad is internally labeled with a limiting label. Contributes to
        /// AdGroupAdPrimaryStatus.LIMITED.
        AdGroupAdApprovedLabeled = 14,
        /// The ad is only serving in the user-specified area of interest.
        /// Contributes to AdGroupAdPrimaryStatus.LIMITED.
        AdGroupAdAreaOfInterestOnly = 15,
        /// The ad is part of an ongoing appeal. This reason does not impact
        /// AdGroupAdPrimaryStatus.
        AdGroupAdUnderAppeal = 16,
    }
    impl AdGroupAdPrimaryStatusReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CampaignRemoved => "CAMPAIGN_REMOVED",
                Self::CampaignPaused => "CAMPAIGN_PAUSED",
                Self::CampaignPending => "CAMPAIGN_PENDING",
                Self::CampaignEnded => "CAMPAIGN_ENDED",
                Self::AdGroupPaused => "AD_GROUP_PAUSED",
                Self::AdGroupRemoved => "AD_GROUP_REMOVED",
                Self::AdGroupAdPaused => "AD_GROUP_AD_PAUSED",
                Self::AdGroupAdRemoved => "AD_GROUP_AD_REMOVED",
                Self::AdGroupAdDisapproved => "AD_GROUP_AD_DISAPPROVED",
                Self::AdGroupAdUnderReview => "AD_GROUP_AD_UNDER_REVIEW",
                Self::AdGroupAdPoorQuality => "AD_GROUP_AD_POOR_QUALITY",
                Self::AdGroupAdNoAds => "AD_GROUP_AD_NO_ADS",
                Self::AdGroupAdApprovedLabeled => "AD_GROUP_AD_APPROVED_LABELED",
                Self::AdGroupAdAreaOfInterestOnly => "AD_GROUP_AD_AREA_OF_INTEREST_ONLY",
                Self::AdGroupAdUnderAppeal => "AD_GROUP_AD_UNDER_APPEAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_REMOVED" => Some(Self::CampaignRemoved),
                "CAMPAIGN_PAUSED" => Some(Self::CampaignPaused),
                "CAMPAIGN_PENDING" => Some(Self::CampaignPending),
                "CAMPAIGN_ENDED" => Some(Self::CampaignEnded),
                "AD_GROUP_PAUSED" => Some(Self::AdGroupPaused),
                "AD_GROUP_REMOVED" => Some(Self::AdGroupRemoved),
                "AD_GROUP_AD_PAUSED" => Some(Self::AdGroupAdPaused),
                "AD_GROUP_AD_REMOVED" => Some(Self::AdGroupAdRemoved),
                "AD_GROUP_AD_DISAPPROVED" => Some(Self::AdGroupAdDisapproved),
                "AD_GROUP_AD_UNDER_REVIEW" => Some(Self::AdGroupAdUnderReview),
                "AD_GROUP_AD_POOR_QUALITY" => Some(Self::AdGroupAdPoorQuality),
                "AD_GROUP_AD_NO_ADS" => Some(Self::AdGroupAdNoAds),
                "AD_GROUP_AD_APPROVED_LABELED" => Some(Self::AdGroupAdApprovedLabeled),
                "AD_GROUP_AD_AREA_OF_INTEREST_ONLY" => {
                    Some(Self::AdGroupAdAreaOfInterestOnly)
                }
                "AD_GROUP_AD_UNDER_APPEAL" => Some(Self::AdGroupAdUnderAppeal),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible ad rotation modes of ads within an
/// ad group.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupAdRotationModeEnum {}
/// Nested message and enum types in `AdGroupAdRotationModeEnum`.
pub mod ad_group_ad_rotation_mode_enum {
    /// The possible ad rotation modes of an ad group.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupAdRotationMode {
        /// The ad rotation mode has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// Optimize ad group ads based on clicks or conversions.
        Optimize = 2,
        /// Rotate evenly forever.
        RotateForever = 3,
    }
    impl AdGroupAdRotationMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Optimize => "OPTIMIZE",
                Self::RotateForever => "ROTATE_FOREVER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPTIMIZE" => Some(Self::Optimize),
                "ROTATE_FOREVER" => Some(Self::RotateForever),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of an AdGroupAd.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupAdStatusEnum {}
/// Nested message and enum types in `AdGroupAdStatusEnum`.
pub mod ad_group_ad_status_enum {
    /// The possible statuses of an AdGroupAd.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupAdStatus {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// The ad group ad is enabled.
        Enabled = 2,
        /// The ad group ad is paused.
        Paused = 3,
        /// The ad group ad is removed.
        Removed = 4,
    }
    impl AdGroupAdStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Paused => "PAUSED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible AdGroupCriterion approval statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionApprovalStatusEnum {}
/// Nested message and enum types in `AdGroupCriterionApprovalStatusEnum`.
pub mod ad_group_criterion_approval_status_enum {
    /// Enumerates AdGroupCriterion approval statuses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupCriterionApprovalStatus {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Approved.
        Approved = 2,
        /// Disapproved.
        Disapproved = 3,
        /// Pending Review.
        PendingReview = 4,
        /// Under review.
        UnderReview = 5,
    }
    impl AdGroupCriterionApprovalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Approved => "APPROVED",
                Self::Disapproved => "DISAPPROVED",
                Self::PendingReview => "PENDING_REVIEW",
                Self::UnderReview => "UNDER_REVIEW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APPROVED" => Some(Self::Approved),
                "DISAPPROVED" => Some(Self::Disapproved),
                "PENDING_REVIEW" => Some(Self::PendingReview),
                "UNDER_REVIEW" => Some(Self::UnderReview),
                _ => None,
            }
        }
    }
}
/// Message describing AdGroupCriterion statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionStatusEnum {}
/// Nested message and enum types in `AdGroupCriterionStatusEnum`.
pub mod ad_group_criterion_status_enum {
    /// The possible statuses of an AdGroupCriterion.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupCriterionStatus {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// The ad group criterion is enabled.
        Enabled = 2,
        /// The ad group criterion is paused.
        Paused = 3,
        /// The ad group criterion is removed.
        Removed = 4,
    }
    impl AdGroupCriterionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Paused => "PAUSED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Ad Group Primary Status. Provides insight into why an ad group is not serving
/// or not serving optimally.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupPrimaryStatusEnum {}
/// Nested message and enum types in `AdGroupPrimaryStatusEnum`.
pub mod ad_group_primary_status_enum {
    /// The possible statuses of an AdGroup.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupPrimaryStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The ad group is eligible to serve.
        Eligible = 2,
        /// The ad group is paused.
        Paused = 3,
        /// The ad group is removed.
        Removed = 4,
        /// The ad group may serve in the future.
        Pending = 5,
        /// The ad group is not eligible to serve.
        NotEligible = 6,
        /// The ad group has limited servability.
        Limited = 7,
    }
    impl AdGroupPrimaryStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Eligible => "ELIGIBLE",
                Self::Paused => "PAUSED",
                Self::Removed => "REMOVED",
                Self::Pending => "PENDING",
                Self::NotEligible => "NOT_ELIGIBLE",
                Self::Limited => "LIMITED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ELIGIBLE" => Some(Self::Eligible),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                "PENDING" => Some(Self::Pending),
                "NOT_ELIGIBLE" => Some(Self::NotEligible),
                "LIMITED" => Some(Self::Limited),
                _ => None,
            }
        }
    }
}
/// Ad Group Primary Status Reason. Provides insight into why an ad group is not
/// serving or not serving optimally. These reasons are aggregated to determine
/// an overall AdGroupPrimaryStatus.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupPrimaryStatusReasonEnum {}
/// Nested message and enum types in `AdGroupPrimaryStatusReasonEnum`.
pub mod ad_group_primary_status_reason_enum {
    /// Possible ad group status reasons.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupPrimaryStatusReason {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The user-specified campaign status is removed. Contributes to
        /// AdGroupPrimaryStatus.NOT_ELIGIBLE.
        CampaignRemoved = 2,
        /// The user-specified campaign status is paused. Contributes to
        /// AdGroupPrimaryStatus.NOT_ELIGIBLE.
        CampaignPaused = 3,
        /// The user-specified time for this campaign to start is in the future.
        /// Contributes to AdGroupPrimaryStatus.NOT_ELIGIBLE
        CampaignPending = 4,
        /// The user-specified time for this campaign to end has passed. Contributes
        /// to AdGroupPrimaryStatus.NOT_ELIGIBLE.
        CampaignEnded = 5,
        /// The user-specified ad group status is paused. Contributes to
        /// AdGroupPrimaryStatus.PAUSED.
        AdGroupPaused = 6,
        /// The user-specified ad group status is removed. Contributes to
        /// AdGroupPrimaryStatus.REMOVED.
        AdGroupRemoved = 7,
        /// The construction of this ad group is not yet complete. Contributes to
        /// AdGroupPrimaryStatus.NOT_ELIGIBLE.
        AdGroupIncomplete = 8,
        /// The user-specified keyword statuses in this ad group are all paused.
        /// Contributes to AdGroupPrimaryStatus.NOT_ELIGIBLE.
        KeywordsPaused = 9,
        /// No eligible keywords exist in this ad group. Contributes to
        /// AdGroupPrimaryStatus.NOT_ELIGIBLE.
        NoKeywords = 10,
        /// The user-specified ad group ads statuses in this ad group are all paused.
        /// Contributes to AdGroupPrimaryStatus.NOT_ELIGIBLE.
        AdGroupAdsPaused = 11,
        /// No eligible ad group ads exist in this ad group. Contributes to
        /// AdGroupPrimaryStatus.NOT_ELIGIBLE.
        NoAdGroupAds = 12,
        /// Policy status reason when at least one ad is disapproved. Contributes to
        /// multiple AdGroupPrimaryStatus.
        HasAdsDisapproved = 13,
        /// Policy status reason when at least one ad is limited by policy.
        /// Contributes to multiple AdGroupPrimaryStatus.
        HasAdsLimitedByPolicy = 14,
        /// Policy status reason when most ads are pending review. Contributes to
        /// AdGroupPrimaryStatus.PENDING.
        MostAdsUnderReview = 15,
        /// The AdGroup belongs to a Draft campaign. Contributes to
        /// AdGroupPrimaryStatus.NOT_ELIGIBLE.
        CampaignDraft = 16,
        /// Ad group has been paused due to prolonged low activity in serving.
        /// Contributes to AdGroupPrimaryStatus.PAUSED.
        AdGroupPausedDueToLowActivity = 19,
    }
    impl AdGroupPrimaryStatusReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CampaignRemoved => "CAMPAIGN_REMOVED",
                Self::CampaignPaused => "CAMPAIGN_PAUSED",
                Self::CampaignPending => "CAMPAIGN_PENDING",
                Self::CampaignEnded => "CAMPAIGN_ENDED",
                Self::AdGroupPaused => "AD_GROUP_PAUSED",
                Self::AdGroupRemoved => "AD_GROUP_REMOVED",
                Self::AdGroupIncomplete => "AD_GROUP_INCOMPLETE",
                Self::KeywordsPaused => "KEYWORDS_PAUSED",
                Self::NoKeywords => "NO_KEYWORDS",
                Self::AdGroupAdsPaused => "AD_GROUP_ADS_PAUSED",
                Self::NoAdGroupAds => "NO_AD_GROUP_ADS",
                Self::HasAdsDisapproved => "HAS_ADS_DISAPPROVED",
                Self::HasAdsLimitedByPolicy => "HAS_ADS_LIMITED_BY_POLICY",
                Self::MostAdsUnderReview => "MOST_ADS_UNDER_REVIEW",
                Self::CampaignDraft => "CAMPAIGN_DRAFT",
                Self::AdGroupPausedDueToLowActivity => {
                    "AD_GROUP_PAUSED_DUE_TO_LOW_ACTIVITY"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_REMOVED" => Some(Self::CampaignRemoved),
                "CAMPAIGN_PAUSED" => Some(Self::CampaignPaused),
                "CAMPAIGN_PENDING" => Some(Self::CampaignPending),
                "CAMPAIGN_ENDED" => Some(Self::CampaignEnded),
                "AD_GROUP_PAUSED" => Some(Self::AdGroupPaused),
                "AD_GROUP_REMOVED" => Some(Self::AdGroupRemoved),
                "AD_GROUP_INCOMPLETE" => Some(Self::AdGroupIncomplete),
                "KEYWORDS_PAUSED" => Some(Self::KeywordsPaused),
                "NO_KEYWORDS" => Some(Self::NoKeywords),
                "AD_GROUP_ADS_PAUSED" => Some(Self::AdGroupAdsPaused),
                "NO_AD_GROUP_ADS" => Some(Self::NoAdGroupAds),
                "HAS_ADS_DISAPPROVED" => Some(Self::HasAdsDisapproved),
                "HAS_ADS_LIMITED_BY_POLICY" => Some(Self::HasAdsLimitedByPolicy),
                "MOST_ADS_UNDER_REVIEW" => Some(Self::MostAdsUnderReview),
                "CAMPAIGN_DRAFT" => Some(Self::CampaignDraft),
                "AD_GROUP_PAUSED_DUE_TO_LOW_ACTIVITY" => {
                    Some(Self::AdGroupPausedDueToLowActivity)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of an ad group.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupStatusEnum {}
/// Nested message and enum types in `AdGroupStatusEnum`.
pub mod ad_group_status_enum {
    /// The possible statuses of an ad group.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupStatus {
        /// The status has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// The ad group is enabled.
        Enabled = 2,
        /// The ad group is paused.
        Paused = 3,
        /// The ad group is removed.
        Removed = 4,
    }
    impl AdGroupStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Paused => "PAUSED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Defines types of an ad group, specific to a particular campaign channel
/// type. This type drives validations that restrict which entities can be
/// added to the ad group.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupTypeEnum {}
/// Nested message and enum types in `AdGroupTypeEnum`.
pub mod ad_group_type_enum {
    /// Enum listing the possible types of an ad group.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupType {
        /// The type has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// The default ad group type for Search campaigns.
        SearchStandard = 2,
        /// The default ad group type for Display campaigns.
        DisplayStandard = 3,
        /// The ad group type for Shopping campaigns serving standard product ads.
        ShoppingProductAds = 4,
        /// The default ad group type for Hotel campaigns.
        HotelAds = 6,
        /// The type for ad groups in Smart Shopping campaigns.
        ShoppingSmartAds = 7,
        /// Short unskippable in-stream video ads.
        VideoBumper = 8,
        /// TrueView (skippable) in-stream video ads.
        VideoTrueViewInStream = 9,
        /// TrueView in-display video ads.
        VideoTrueViewInDisplay = 10,
        /// Unskippable in-stream video ads.
        VideoNonSkippableInStream = 11,
        /// Outstream video ads.
        VideoOutstream = 12,
        /// Ad group type for Dynamic Search Ads ad groups.
        SearchDynamicAds = 13,
        /// The type for ad groups in Shopping Comparison Listing campaigns.
        ShoppingComparisonListingAds = 14,
        /// The ad group type for Promoted Hotel ad groups.
        PromotedHotelAds = 15,
        /// Video responsive ad groups.
        VideoResponsive = 16,
        /// Video efficient reach ad groups.
        VideoEfficientReach = 17,
        /// Ad group type for Smart campaigns.
        SmartCampaignAds = 18,
        /// Ad group type for Travel campaigns.
        TravelAds = 19,
    }
    impl AdGroupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::SearchStandard => "SEARCH_STANDARD",
                Self::DisplayStandard => "DISPLAY_STANDARD",
                Self::ShoppingProductAds => "SHOPPING_PRODUCT_ADS",
                Self::HotelAds => "HOTEL_ADS",
                Self::ShoppingSmartAds => "SHOPPING_SMART_ADS",
                Self::VideoBumper => "VIDEO_BUMPER",
                Self::VideoTrueViewInStream => "VIDEO_TRUE_VIEW_IN_STREAM",
                Self::VideoTrueViewInDisplay => "VIDEO_TRUE_VIEW_IN_DISPLAY",
                Self::VideoNonSkippableInStream => "VIDEO_NON_SKIPPABLE_IN_STREAM",
                Self::VideoOutstream => "VIDEO_OUTSTREAM",
                Self::SearchDynamicAds => "SEARCH_DYNAMIC_ADS",
                Self::ShoppingComparisonListingAds => "SHOPPING_COMPARISON_LISTING_ADS",
                Self::PromotedHotelAds => "PROMOTED_HOTEL_ADS",
                Self::VideoResponsive => "VIDEO_RESPONSIVE",
                Self::VideoEfficientReach => "VIDEO_EFFICIENT_REACH",
                Self::SmartCampaignAds => "SMART_CAMPAIGN_ADS",
                Self::TravelAds => "TRAVEL_ADS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEARCH_STANDARD" => Some(Self::SearchStandard),
                "DISPLAY_STANDARD" => Some(Self::DisplayStandard),
                "SHOPPING_PRODUCT_ADS" => Some(Self::ShoppingProductAds),
                "HOTEL_ADS" => Some(Self::HotelAds),
                "SHOPPING_SMART_ADS" => Some(Self::ShoppingSmartAds),
                "VIDEO_BUMPER" => Some(Self::VideoBumper),
                "VIDEO_TRUE_VIEW_IN_STREAM" => Some(Self::VideoTrueViewInStream),
                "VIDEO_TRUE_VIEW_IN_DISPLAY" => Some(Self::VideoTrueViewInDisplay),
                "VIDEO_NON_SKIPPABLE_IN_STREAM" => Some(Self::VideoNonSkippableInStream),
                "VIDEO_OUTSTREAM" => Some(Self::VideoOutstream),
                "SEARCH_DYNAMIC_ADS" => Some(Self::SearchDynamicAds),
                "SHOPPING_COMPARISON_LISTING_ADS" => {
                    Some(Self::ShoppingComparisonListingAds)
                }
                "PROMOTED_HOTEL_ADS" => Some(Self::PromotedHotelAds),
                "VIDEO_RESPONSIVE" => Some(Self::VideoResponsive),
                "VIDEO_EFFICIENT_REACH" => Some(Self::VideoEfficientReach),
                "SMART_CAMPAIGN_ADS" => Some(Self::SmartCampaignAds),
                "TRAVEL_ADS" => Some(Self::TravelAds),
                _ => None,
            }
        }
    }
}
/// Possible ad serving statuses of a campaign.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdServingOptimizationStatusEnum {}
/// Nested message and enum types in `AdServingOptimizationStatusEnum`.
pub mod ad_serving_optimization_status_enum {
    /// Enum describing possible serving statuses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdServingOptimizationStatus {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// Ad serving is optimized based on CTR for the campaign.
        Optimize = 2,
        /// Ad serving is optimized based on CTR * Conversion for the campaign. If
        /// the campaign is not in the conversion optimizer bidding strategy, it will
        /// default to OPTIMIZED.
        ConversionOptimize = 3,
        /// Ads are rotated evenly for 90 days, then optimized for clicks.
        Rotate = 4,
        /// Show lower performing ads more evenly with higher performing ads, and do
        /// not optimize.
        RotateIndefinitely = 5,
        /// Ad serving optimization status is not available.
        Unavailable = 6,
    }
    impl AdServingOptimizationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Optimize => "OPTIMIZE",
                Self::ConversionOptimize => "CONVERSION_OPTIMIZE",
                Self::Rotate => "ROTATE",
                Self::RotateIndefinitely => "ROTATE_INDEFINITELY",
                Self::Unavailable => "UNAVAILABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPTIMIZE" => Some(Self::Optimize),
                "CONVERSION_OPTIMIZE" => Some(Self::ConversionOptimize),
                "ROTATE" => Some(Self::Rotate),
                "ROTATE_INDEFINITELY" => Some(Self::RotateIndefinitely),
                "UNAVAILABLE" => Some(Self::Unavailable),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible ad strengths.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdStrengthEnum {}
/// Nested message and enum types in `AdStrengthEnum`.
pub mod ad_strength_enum {
    /// Enum listing the possible ad strengths.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdStrength {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The ad strength is currently pending.
        Pending = 2,
        /// No ads could be generated.
        NoAds = 3,
        /// Poor strength.
        Poor = 4,
        /// Average strength.
        Average = 5,
        /// Good strength.
        Good = 6,
        /// Excellent strength.
        Excellent = 7,
    }
    impl AdStrength {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Pending => "PENDING",
                Self::NoAds => "NO_ADS",
                Self::Poor => "POOR",
                Self::Average => "AVERAGE",
                Self::Good => "GOOD",
                Self::Excellent => "EXCELLENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "NO_ADS" => Some(Self::NoAds),
                "POOR" => Some(Self::Poor),
                "AVERAGE" => Some(Self::Average),
                "GOOD" => Some(Self::Good),
                "EXCELLENT" => Some(Self::Excellent),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible types of an ad.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdTypeEnum {}
/// Nested message and enum types in `AdTypeEnum`.
pub mod ad_type_enum {
    /// The possible types of an ad.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdType {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// The ad is a text ad.
        TextAd = 2,
        /// The ad is an expanded text ad.
        ExpandedTextAd = 3,
        /// The ad is an expanded dynamic search ad.
        ExpandedDynamicSearchAd = 7,
        /// The ad is a hotel ad.
        HotelAd = 8,
        /// The ad is a Smart Shopping ad.
        ShoppingSmartAd = 9,
        /// The ad is a standard Shopping ad.
        ShoppingProductAd = 10,
        /// The ad is a video ad.
        VideoAd = 12,
        /// This ad is an Image ad.
        ImageAd = 14,
        /// The ad is a responsive search ad.
        ResponsiveSearchAd = 15,
        /// The ad is a legacy responsive display ad.
        LegacyResponsiveDisplayAd = 16,
        /// The ad is an app ad.
        AppAd = 17,
        /// The ad is a legacy app install ad.
        LegacyAppInstallAd = 18,
        /// The ad is a responsive display ad.
        ResponsiveDisplayAd = 19,
        /// The ad is a local ad.
        LocalAd = 20,
        /// The ad is a display upload ad with the HTML5_UPLOAD_AD product type.
        Html5UploadAd = 21,
        /// The ad is a display upload ad with one of the DYNAMIC_HTML5_* product
        /// types.
        DynamicHtml5Ad = 22,
        /// The ad is an app engagement ad.
        AppEngagementAd = 23,
        /// The ad is a Shopping Comparison Listing ad.
        ShoppingComparisonListingAd = 24,
        /// Video bumper ad.
        VideoBumperAd = 25,
        /// Video non-skippable in-stream ad.
        VideoNonSkippableInStreamAd = 26,
        /// Video outstream ad.
        VideoOutstreamAd = 27,
        /// Video TrueView in-stream ad.
        VideoTrueviewInStreamAd = 29,
        /// Video responsive ad.
        VideoResponsiveAd = 30,
        /// Smart campaign ad.
        SmartCampaignAd = 31,
        /// Call ad.
        CallAd = 32,
        /// Universal app pre-registration ad.
        AppPreRegistrationAd = 33,
        /// In-feed video ad.
        InFeedVideoAd = 34,
        /// Discovery multi asset ad.
        DiscoveryMultiAssetAd = 35,
        /// Discovery carousel ad.
        DiscoveryCarouselAd = 36,
        /// Travel ad.
        TravelAd = 37,
        /// Discovery video responsive ad.
        DiscoveryVideoResponsiveAd = 38,
        /// Demand Gen product ad.
        DemandGenProductAd = 39,
    }
    impl AdType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::TextAd => "TEXT_AD",
                Self::ExpandedTextAd => "EXPANDED_TEXT_AD",
                Self::ExpandedDynamicSearchAd => "EXPANDED_DYNAMIC_SEARCH_AD",
                Self::HotelAd => "HOTEL_AD",
                Self::ShoppingSmartAd => "SHOPPING_SMART_AD",
                Self::ShoppingProductAd => "SHOPPING_PRODUCT_AD",
                Self::VideoAd => "VIDEO_AD",
                Self::ImageAd => "IMAGE_AD",
                Self::ResponsiveSearchAd => "RESPONSIVE_SEARCH_AD",
                Self::LegacyResponsiveDisplayAd => "LEGACY_RESPONSIVE_DISPLAY_AD",
                Self::AppAd => "APP_AD",
                Self::LegacyAppInstallAd => "LEGACY_APP_INSTALL_AD",
                Self::ResponsiveDisplayAd => "RESPONSIVE_DISPLAY_AD",
                Self::LocalAd => "LOCAL_AD",
                Self::Html5UploadAd => "HTML5_UPLOAD_AD",
                Self::DynamicHtml5Ad => "DYNAMIC_HTML5_AD",
                Self::AppEngagementAd => "APP_ENGAGEMENT_AD",
                Self::ShoppingComparisonListingAd => "SHOPPING_COMPARISON_LISTING_AD",
                Self::VideoBumperAd => "VIDEO_BUMPER_AD",
                Self::VideoNonSkippableInStreamAd => "VIDEO_NON_SKIPPABLE_IN_STREAM_AD",
                Self::VideoOutstreamAd => "VIDEO_OUTSTREAM_AD",
                Self::VideoTrueviewInStreamAd => "VIDEO_TRUEVIEW_IN_STREAM_AD",
                Self::VideoResponsiveAd => "VIDEO_RESPONSIVE_AD",
                Self::SmartCampaignAd => "SMART_CAMPAIGN_AD",
                Self::CallAd => "CALL_AD",
                Self::AppPreRegistrationAd => "APP_PRE_REGISTRATION_AD",
                Self::InFeedVideoAd => "IN_FEED_VIDEO_AD",
                Self::DiscoveryMultiAssetAd => "DISCOVERY_MULTI_ASSET_AD",
                Self::DiscoveryCarouselAd => "DISCOVERY_CAROUSEL_AD",
                Self::TravelAd => "TRAVEL_AD",
                Self::DiscoveryVideoResponsiveAd => "DISCOVERY_VIDEO_RESPONSIVE_AD",
                Self::DemandGenProductAd => "DEMAND_GEN_PRODUCT_AD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TEXT_AD" => Some(Self::TextAd),
                "EXPANDED_TEXT_AD" => Some(Self::ExpandedTextAd),
                "EXPANDED_DYNAMIC_SEARCH_AD" => Some(Self::ExpandedDynamicSearchAd),
                "HOTEL_AD" => Some(Self::HotelAd),
                "SHOPPING_SMART_AD" => Some(Self::ShoppingSmartAd),
                "SHOPPING_PRODUCT_AD" => Some(Self::ShoppingProductAd),
                "VIDEO_AD" => Some(Self::VideoAd),
                "IMAGE_AD" => Some(Self::ImageAd),
                "RESPONSIVE_SEARCH_AD" => Some(Self::ResponsiveSearchAd),
                "LEGACY_RESPONSIVE_DISPLAY_AD" => Some(Self::LegacyResponsiveDisplayAd),
                "APP_AD" => Some(Self::AppAd),
                "LEGACY_APP_INSTALL_AD" => Some(Self::LegacyAppInstallAd),
                "RESPONSIVE_DISPLAY_AD" => Some(Self::ResponsiveDisplayAd),
                "LOCAL_AD" => Some(Self::LocalAd),
                "HTML5_UPLOAD_AD" => Some(Self::Html5UploadAd),
                "DYNAMIC_HTML5_AD" => Some(Self::DynamicHtml5Ad),
                "APP_ENGAGEMENT_AD" => Some(Self::AppEngagementAd),
                "SHOPPING_COMPARISON_LISTING_AD" => {
                    Some(Self::ShoppingComparisonListingAd)
                }
                "VIDEO_BUMPER_AD" => Some(Self::VideoBumperAd),
                "VIDEO_NON_SKIPPABLE_IN_STREAM_AD" => {
                    Some(Self::VideoNonSkippableInStreamAd)
                }
                "VIDEO_OUTSTREAM_AD" => Some(Self::VideoOutstreamAd),
                "VIDEO_TRUEVIEW_IN_STREAM_AD" => Some(Self::VideoTrueviewInStreamAd),
                "VIDEO_RESPONSIVE_AD" => Some(Self::VideoResponsiveAd),
                "SMART_CAMPAIGN_AD" => Some(Self::SmartCampaignAd),
                "CALL_AD" => Some(Self::CallAd),
                "APP_PRE_REGISTRATION_AD" => Some(Self::AppPreRegistrationAd),
                "IN_FEED_VIDEO_AD" => Some(Self::InFeedVideoAd),
                "DISCOVERY_MULTI_ASSET_AD" => Some(Self::DiscoveryMultiAssetAd),
                "DISCOVERY_CAROUSEL_AD" => Some(Self::DiscoveryCarouselAd),
                "TRAVEL_AD" => Some(Self::TravelAd),
                "DISCOVERY_VIDEO_RESPONSIVE_AD" => Some(Self::DiscoveryVideoResponsiveAd),
                "DEMAND_GEN_PRODUCT_AD" => Some(Self::DemandGenProductAd),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible values for a relationship type for
/// an affiliate location feed.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AffiliateLocationFeedRelationshipTypeEnum {}
/// Nested message and enum types in `AffiliateLocationFeedRelationshipTypeEnum`.
pub mod affiliate_location_feed_relationship_type_enum {
    /// Possible values for a relationship type for an affiliate location feed.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AffiliateLocationFeedRelationshipType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// General retailer relationship.
        GeneralRetailer = 2,
    }
    impl AffiliateLocationFeedRelationshipType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::GeneralRetailer => "GENERAL_RETAILER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "GENERAL_RETAILER" => Some(Self::GeneralRetailer),
                _ => None,
            }
        }
    }
}
/// Values for Affiliate Location placeholder fields.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AffiliateLocationPlaceholderFieldEnum {}
/// Nested message and enum types in `AffiliateLocationPlaceholderFieldEnum`.
pub mod affiliate_location_placeholder_field_enum {
    /// Possible values for Affiliate Location placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AffiliateLocationPlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. The name of the business.
        BusinessName = 2,
        /// Data Type: STRING. Line 1 of the business address.
        AddressLine1 = 3,
        /// Data Type: STRING. Line 2 of the business address.
        AddressLine2 = 4,
        /// Data Type: STRING. City of the business address.
        City = 5,
        /// Data Type: STRING. Province of the business address.
        Province = 6,
        /// Data Type: STRING. Postal code of the business address.
        PostalCode = 7,
        /// Data Type: STRING. Country code of the business address.
        CountryCode = 8,
        /// Data Type: STRING. Phone number of the business.
        PhoneNumber = 9,
        /// Data Type: STRING. Language code of the business.
        LanguageCode = 10,
        /// Data Type: INT64. ID of the chain.
        ChainId = 11,
        /// Data Type: STRING. Name of the chain.
        ChainName = 12,
    }
    impl AffiliateLocationPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::BusinessName => "BUSINESS_NAME",
                Self::AddressLine1 => "ADDRESS_LINE_1",
                Self::AddressLine2 => "ADDRESS_LINE_2",
                Self::City => "CITY",
                Self::Province => "PROVINCE",
                Self::PostalCode => "POSTAL_CODE",
                Self::CountryCode => "COUNTRY_CODE",
                Self::PhoneNumber => "PHONE_NUMBER",
                Self::LanguageCode => "LANGUAGE_CODE",
                Self::ChainId => "CHAIN_ID",
                Self::ChainName => "CHAIN_NAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_NAME" => Some(Self::BusinessName),
                "ADDRESS_LINE_1" => Some(Self::AddressLine1),
                "ADDRESS_LINE_2" => Some(Self::AddressLine2),
                "CITY" => Some(Self::City),
                "PROVINCE" => Some(Self::Province),
                "POSTAL_CODE" => Some(Self::PostalCode),
                "COUNTRY_CODE" => Some(Self::CountryCode),
                "PHONE_NUMBER" => Some(Self::PhoneNumber),
                "LANGUAGE_CODE" => Some(Self::LanguageCode),
                "CHAIN_ID" => Some(Self::ChainId),
                "CHAIN_NAME" => Some(Self::ChainName),
                _ => None,
            }
        }
    }
}
/// The interaction type enum for Android privacy shared key.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AndroidPrivacyInteractionTypeEnum {}
/// Nested message and enum types in `AndroidPrivacyInteractionTypeEnum`.
pub mod android_privacy_interaction_type_enum {
    /// Enumerates interaction types
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AndroidPrivacyInteractionType {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// The physical click interaction type.
        Click = 2,
        /// The 10 seconds engaged view interaction type.
        EngagedView = 3,
        /// The view (ad impression) interaction type.
        View = 4,
    }
    impl AndroidPrivacyInteractionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Click => "CLICK",
                Self::EngagedView => "ENGAGED_VIEW",
                Self::View => "VIEW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CLICK" => Some(Self::Click),
                "ENGAGED_VIEW" => Some(Self::EngagedView),
                "VIEW" => Some(Self::View),
                _ => None,
            }
        }
    }
}
/// The network type enum for Android privacy shared key.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AndroidPrivacyNetworkTypeEnum {}
/// Nested message and enum types in `AndroidPrivacyNetworkTypeEnum`.
pub mod android_privacy_network_type_enum {
    /// Enumerates network types
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AndroidPrivacyNetworkType {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Search Network.
        Search = 2,
        /// Display Network.
        Display = 3,
        /// YouTube Network.
        Youtube = 4,
    }
    impl AndroidPrivacyNetworkType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Search => "SEARCH",
                Self::Display => "DISPLAY",
                Self::Youtube => "YOUTUBE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEARCH" => Some(Self::Search),
                "DISPLAY" => Some(Self::Display),
                "YOUTUBE" => Some(Self::Youtube),
                _ => None,
            }
        }
    }
}
/// Container for enum describing an app bidding goal for raise Target CPA
/// recommendation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppBiddingGoalEnum {}
/// Nested message and enum types in `AppBiddingGoalEnum`.
pub mod app_bidding_goal_enum {
    /// Represents the goal towards which the bidding strategy, of an app
    /// campaign, should optimize for.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AppBiddingGoal {
        /// Not specified.
        Unspecified = 0,
        /// Represents value unknown in this version of the API.
        Unknown = 1,
        /// The bidding strategy of the app campaign should aim to maximize
        /// installation of the app.
        OptimizeForInstallConversionVolume = 2,
        /// The bidding strategy of the app campaign should aim to maximize
        /// the selected in-app conversions' volume.
        OptimizeForInAppConversionVolume = 3,
        /// The bidding strategy of the app campaign should aim to maximize
        /// all conversions' value, that is, install and selected in-app conversions.
        OptimizeForTotalConversionValue = 4,
        /// The bidding strategy of the app campaign should aim to maximize
        /// just the selected in-app conversion's volume, while achieving or
        /// exceeding target cost per in-app conversion.
        OptimizeForTargetInAppConversion = 5,
        /// The bidding strategy of the app campaign should aim to maximize
        /// all conversions' value, that is, install and selected in-app conversions
        /// while achieving or exceeding target return on advertising spend.
        OptimizeForReturnOnAdvertisingSpend = 6,
        /// This bidding strategy of the app campaign should aim to
        /// maximize installation of the app without advertiser-provided target
        /// cost-per-install.
        OptimizeForInstallConversionVolumeWithoutTargetCpi = 7,
        /// This bidding strategy of the app campaign should aim to
        /// maximize pre-registration of the app.
        OptimizeForPreRegistrationConversionVolume = 8,
    }
    impl AppBiddingGoal {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::OptimizeForInstallConversionVolume => {
                    "OPTIMIZE_FOR_INSTALL_CONVERSION_VOLUME"
                }
                Self::OptimizeForInAppConversionVolume => {
                    "OPTIMIZE_FOR_IN_APP_CONVERSION_VOLUME"
                }
                Self::OptimizeForTotalConversionValue => {
                    "OPTIMIZE_FOR_TOTAL_CONVERSION_VALUE"
                }
                Self::OptimizeForTargetInAppConversion => {
                    "OPTIMIZE_FOR_TARGET_IN_APP_CONVERSION"
                }
                Self::OptimizeForReturnOnAdvertisingSpend => {
                    "OPTIMIZE_FOR_RETURN_ON_ADVERTISING_SPEND"
                }
                Self::OptimizeForInstallConversionVolumeWithoutTargetCpi => {
                    "OPTIMIZE_FOR_INSTALL_CONVERSION_VOLUME_WITHOUT_TARGET_CPI"
                }
                Self::OptimizeForPreRegistrationConversionVolume => {
                    "OPTIMIZE_FOR_PRE_REGISTRATION_CONVERSION_VOLUME"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPTIMIZE_FOR_INSTALL_CONVERSION_VOLUME" => {
                    Some(Self::OptimizeForInstallConversionVolume)
                }
                "OPTIMIZE_FOR_IN_APP_CONVERSION_VOLUME" => {
                    Some(Self::OptimizeForInAppConversionVolume)
                }
                "OPTIMIZE_FOR_TOTAL_CONVERSION_VALUE" => {
                    Some(Self::OptimizeForTotalConversionValue)
                }
                "OPTIMIZE_FOR_TARGET_IN_APP_CONVERSION" => {
                    Some(Self::OptimizeForTargetInAppConversion)
                }
                "OPTIMIZE_FOR_RETURN_ON_ADVERTISING_SPEND" => {
                    Some(Self::OptimizeForReturnOnAdvertisingSpend)
                }
                "OPTIMIZE_FOR_INSTALL_CONVERSION_VOLUME_WITHOUT_TARGET_CPI" => {
                    Some(Self::OptimizeForInstallConversionVolumeWithoutTargetCpi)
                }
                "OPTIMIZE_FOR_PRE_REGISTRATION_CONVERSION_VOLUME" => {
                    Some(Self::OptimizeForPreRegistrationConversionVolume)
                }
                _ => None,
            }
        }
    }
}
/// The application store that distributes mobile applications.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppCampaignAppStoreEnum {}
/// Nested message and enum types in `AppCampaignAppStoreEnum`.
pub mod app_campaign_app_store_enum {
    /// Enum describing app campaign app store.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AppCampaignAppStore {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Apple app store.
        AppleAppStore = 2,
        /// Google play.
        GoogleAppStore = 3,
    }
    impl AppCampaignAppStore {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AppleAppStore => "APPLE_APP_STORE",
                Self::GoogleAppStore => "GOOGLE_APP_STORE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APPLE_APP_STORE" => Some(Self::AppleAppStore),
                "GOOGLE_APP_STORE" => Some(Self::GoogleAppStore),
                _ => None,
            }
        }
    }
}
/// Container for enum describing goal towards which the bidding strategy of an
/// app campaign should optimize for.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppCampaignBiddingStrategyGoalTypeEnum {}
/// Nested message and enum types in `AppCampaignBiddingStrategyGoalTypeEnum`.
pub mod app_campaign_bidding_strategy_goal_type_enum {
    /// Goal type of App campaign BiddingStrategy.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AppCampaignBiddingStrategyGoalType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Aim to maximize the number of app installs. The cpa bid is the
        /// target cost per install.
        OptimizeInstallsTargetInstallCost = 2,
        /// Aim to maximize the long term number of selected in-app conversions from
        /// app installs. The cpa bid is the target cost per install.
        OptimizeInAppConversionsTargetInstallCost = 3,
        /// Aim to maximize the long term number of selected in-app conversions from
        /// app installs. The cpa bid is the target cost per in-app conversion. Note
        /// that the actual cpa may seem higher than the target cpa at first, since
        /// the long term conversions haven't happened yet.
        OptimizeInAppConversionsTargetConversionCost = 4,
        /// Aim to maximize all conversions' value, for example, install + selected
        /// in-app conversions while achieving or exceeding target return on
        /// advertising spend.
        OptimizeReturnOnAdvertisingSpend = 5,
        /// Aim to maximize the pre-registration of the app.
        OptimizePreRegistrationConversionVolume = 6,
        /// Aim to maximize installation of the app without target cost-per-install.
        OptimizeInstallsWithoutTargetInstallCost = 7,
    }
    impl AppCampaignBiddingStrategyGoalType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::OptimizeInstallsTargetInstallCost => {
                    "OPTIMIZE_INSTALLS_TARGET_INSTALL_COST"
                }
                Self::OptimizeInAppConversionsTargetInstallCost => {
                    "OPTIMIZE_IN_APP_CONVERSIONS_TARGET_INSTALL_COST"
                }
                Self::OptimizeInAppConversionsTargetConversionCost => {
                    "OPTIMIZE_IN_APP_CONVERSIONS_TARGET_CONVERSION_COST"
                }
                Self::OptimizeReturnOnAdvertisingSpend => {
                    "OPTIMIZE_RETURN_ON_ADVERTISING_SPEND"
                }
                Self::OptimizePreRegistrationConversionVolume => {
                    "OPTIMIZE_PRE_REGISTRATION_CONVERSION_VOLUME"
                }
                Self::OptimizeInstallsWithoutTargetInstallCost => {
                    "OPTIMIZE_INSTALLS_WITHOUT_TARGET_INSTALL_COST"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPTIMIZE_INSTALLS_TARGET_INSTALL_COST" => {
                    Some(Self::OptimizeInstallsTargetInstallCost)
                }
                "OPTIMIZE_IN_APP_CONVERSIONS_TARGET_INSTALL_COST" => {
                    Some(Self::OptimizeInAppConversionsTargetInstallCost)
                }
                "OPTIMIZE_IN_APP_CONVERSIONS_TARGET_CONVERSION_COST" => {
                    Some(Self::OptimizeInAppConversionsTargetConversionCost)
                }
                "OPTIMIZE_RETURN_ON_ADVERTISING_SPEND" => {
                    Some(Self::OptimizeReturnOnAdvertisingSpend)
                }
                "OPTIMIZE_PRE_REGISTRATION_CONVERSION_VOLUME" => {
                    Some(Self::OptimizePreRegistrationConversionVolume)
                }
                "OPTIMIZE_INSTALLS_WITHOUT_TARGET_INSTALL_COST" => {
                    Some(Self::OptimizeInstallsWithoutTargetInstallCost)
                }
                _ => None,
            }
        }
    }
}
/// Values for App placeholder fields.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppPlaceholderFieldEnum {}
/// Nested message and enum types in `AppPlaceholderFieldEnum`.
pub mod app_placeholder_field_enum {
    /// Possible values for App placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AppPlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: INT64. The application store that the target application
        /// belongs to. Valid values are: 1 = Apple iTunes Store; 2 = Google Play
        /// Store.
        Store = 2,
        /// Data Type: STRING. The store-specific ID for the target application.
        Id = 3,
        /// Data Type: STRING. The visible text displayed when the link is rendered
        /// in an ad.
        LinkText = 4,
        /// Data Type: STRING. The destination URL of the in-app link.
        Url = 5,
        /// Data Type: URL_LIST. Final URLs for the in-app link when using Upgraded
        /// URLs.
        FinalUrls = 6,
        /// Data Type: URL_LIST. Final Mobile URLs for the in-app link when using
        /// Upgraded URLs.
        FinalMobileUrls = 7,
        /// Data Type: URL. Tracking template for the in-app link when using Upgraded
        /// URLs.
        TrackingUrl = 8,
        /// Data Type: STRING. Final URL suffix for the in-app link when using
        /// parallel tracking.
        FinalUrlSuffix = 9,
    }
    impl AppPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Store => "STORE",
                Self::Id => "ID",
                Self::LinkText => "LINK_TEXT",
                Self::Url => "URL",
                Self::FinalUrls => "FINAL_URLS",
                Self::FinalMobileUrls => "FINAL_MOBILE_URLS",
                Self::TrackingUrl => "TRACKING_URL",
                Self::FinalUrlSuffix => "FINAL_URL_SUFFIX",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "STORE" => Some(Self::Store),
                "ID" => Some(Self::Id),
                "LINK_TEXT" => Some(Self::LinkText),
                "URL" => Some(Self::Url),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "FINAL_URL_SUFFIX" => Some(Self::FinalUrlSuffix),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the status of asset automation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetAutomationStatusEnum {}
/// Nested message and enum types in `AssetAutomationStatusEnum`.
pub mod asset_automation_status_enum {
    /// The status of asset automation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetAutomationStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used as a return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Opted-in will enable generating and serving an asset
        /// automation type.
        OptedIn = 2,
        /// Opted-out will stop generating and serving an asset
        /// automation type.
        OptedOut = 3,
    }
    impl AssetAutomationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::OptedIn => "OPTED_IN",
                Self::OptedOut => "OPTED_OUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPTED_IN" => Some(Self::OptedIn),
                "OPTED_OUT" => Some(Self::OptedOut),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of asset automation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetAutomationTypeEnum {}
/// Nested message and enum types in `AssetAutomationTypeEnum`.
pub mod asset_automation_type_enum {
    /// The type of asset automation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetAutomationType {
        /// Not specified.
        Unspecified = 0,
        /// Used as a return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Text asset automation includes headlines and descriptions.
        /// By default, advertisers are opted-in for Performance Max and
        /// opted-out for Search.
        TextAssetAutomation = 2,
    }
    impl AssetAutomationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::TextAssetAutomation => "TEXT_ASSET_AUTOMATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TEXT_ASSET_AUTOMATION" => Some(Self::TextAssetAutomation),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the possible placements of an asset.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetFieldTypeEnum {}
/// Nested message and enum types in `AssetFieldTypeEnum`.
pub mod asset_field_type_enum {
    /// Enum describing the possible placements of an asset.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetFieldType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The asset is linked for use as a headline.
        Headline = 2,
        /// The asset is linked for use as a description.
        Description = 3,
        /// The asset is linked for use as mandatory ad text.
        MandatoryAdText = 4,
        /// The asset is linked for use as a marketing image.
        MarketingImage = 5,
        /// The asset is linked for use as a media bundle.
        MediaBundle = 6,
        /// The asset is linked for use as a YouTube video.
        YoutubeVideo = 7,
        /// The asset is linked to indicate that a hotels campaign is "Book on
        /// Google" enabled.
        BookOnGoogle = 8,
        /// The asset is linked for use as a Lead Form extension.
        LeadForm = 9,
        /// The asset is linked for use as a Promotion extension.
        Promotion = 10,
        /// The asset is linked for use as a Callout extension.
        Callout = 11,
        /// The asset is linked for use as a Structured Snippet extension.
        StructuredSnippet = 12,
        /// The asset is linked for use as a Sitelink.
        Sitelink = 13,
        /// The asset is linked for use as a Mobile App extension.
        MobileApp = 14,
        /// The asset is linked for use as a Hotel Callout extension.
        HotelCallout = 15,
        /// The asset is linked for use as a Call extension.
        Call = 16,
        /// The asset is linked for use as a Price extension.
        Price = 24,
        /// The asset is linked for use as a long headline.
        LongHeadline = 17,
        /// The asset is linked for use as a business name.
        BusinessName = 18,
        /// The asset is linked for use as a square marketing image.
        SquareMarketingImage = 19,
        /// The asset is linked for use as a portrait marketing image.
        PortraitMarketingImage = 20,
        /// The asset is linked for use as a logo.
        Logo = 21,
        /// The asset is linked for use as a landscape logo.
        LandscapeLogo = 22,
        /// The asset is linked for use as a non YouTube logo.
        Video = 23,
        /// The asset is linked for use to select a call-to-action.
        CallToActionSelection = 25,
        /// The asset is linked for use to select an ad image.
        AdImage = 26,
        /// The asset is linked for use as a business logo.
        BusinessLogo = 27,
        /// The asset is linked for use as a hotel property in a Performance Max for
        /// travel goals campaign.
        HotelProperty = 28,
        /// The asset is linked for use as a discovery carousel card.
        DiscoveryCarouselCard = 29,
    }
    impl AssetFieldType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Headline => "HEADLINE",
                Self::Description => "DESCRIPTION",
                Self::MandatoryAdText => "MANDATORY_AD_TEXT",
                Self::MarketingImage => "MARKETING_IMAGE",
                Self::MediaBundle => "MEDIA_BUNDLE",
                Self::YoutubeVideo => "YOUTUBE_VIDEO",
                Self::BookOnGoogle => "BOOK_ON_GOOGLE",
                Self::LeadForm => "LEAD_FORM",
                Self::Promotion => "PROMOTION",
                Self::Callout => "CALLOUT",
                Self::StructuredSnippet => "STRUCTURED_SNIPPET",
                Self::Sitelink => "SITELINK",
                Self::MobileApp => "MOBILE_APP",
                Self::HotelCallout => "HOTEL_CALLOUT",
                Self::Call => "CALL",
                Self::Price => "PRICE",
                Self::LongHeadline => "LONG_HEADLINE",
                Self::BusinessName => "BUSINESS_NAME",
                Self::SquareMarketingImage => "SQUARE_MARKETING_IMAGE",
                Self::PortraitMarketingImage => "PORTRAIT_MARKETING_IMAGE",
                Self::Logo => "LOGO",
                Self::LandscapeLogo => "LANDSCAPE_LOGO",
                Self::Video => "VIDEO",
                Self::CallToActionSelection => "CALL_TO_ACTION_SELECTION",
                Self::AdImage => "AD_IMAGE",
                Self::BusinessLogo => "BUSINESS_LOGO",
                Self::HotelProperty => "HOTEL_PROPERTY",
                Self::DiscoveryCarouselCard => "DISCOVERY_CAROUSEL_CARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "HEADLINE" => Some(Self::Headline),
                "DESCRIPTION" => Some(Self::Description),
                "MANDATORY_AD_TEXT" => Some(Self::MandatoryAdText),
                "MARKETING_IMAGE" => Some(Self::MarketingImage),
                "MEDIA_BUNDLE" => Some(Self::MediaBundle),
                "YOUTUBE_VIDEO" => Some(Self::YoutubeVideo),
                "BOOK_ON_GOOGLE" => Some(Self::BookOnGoogle),
                "LEAD_FORM" => Some(Self::LeadForm),
                "PROMOTION" => Some(Self::Promotion),
                "CALLOUT" => Some(Self::Callout),
                "STRUCTURED_SNIPPET" => Some(Self::StructuredSnippet),
                "SITELINK" => Some(Self::Sitelink),
                "MOBILE_APP" => Some(Self::MobileApp),
                "HOTEL_CALLOUT" => Some(Self::HotelCallout),
                "CALL" => Some(Self::Call),
                "PRICE" => Some(Self::Price),
                "LONG_HEADLINE" => Some(Self::LongHeadline),
                "BUSINESS_NAME" => Some(Self::BusinessName),
                "SQUARE_MARKETING_IMAGE" => Some(Self::SquareMarketingImage),
                "PORTRAIT_MARKETING_IMAGE" => Some(Self::PortraitMarketingImage),
                "LOGO" => Some(Self::Logo),
                "LANDSCAPE_LOGO" => Some(Self::LandscapeLogo),
                "VIDEO" => Some(Self::Video),
                "CALL_TO_ACTION_SELECTION" => Some(Self::CallToActionSelection),
                "AD_IMAGE" => Some(Self::AdImage),
                "BUSINESS_LOGO" => Some(Self::BusinessLogo),
                "HOTEL_PROPERTY" => Some(Self::HotelProperty),
                "DISCOVERY_CAROUSEL_CARD" => Some(Self::DiscoveryCarouselCard),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible asset group primary status.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupPrimaryStatusEnum {}
/// Nested message and enum types in `AssetGroupPrimaryStatusEnum`.
pub mod asset_group_primary_status_enum {
    /// Enum describing the possible asset group primary status. Provides insights
    /// into why an asset group is not serving or not serving optimally.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupPrimaryStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The asset group is eligible to serve.
        Eligible = 2,
        /// The asset group is paused.
        Paused = 3,
        /// The asset group is removed.
        Removed = 4,
        /// The asset group is not eligible to serve.
        NotEligible = 5,
        /// The asset group has limited servability.
        Limited = 6,
        /// The asset group is pending approval and may serve in the future.
        Pending = 7,
    }
    impl AssetGroupPrimaryStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Eligible => "ELIGIBLE",
                Self::Paused => "PAUSED",
                Self::Removed => "REMOVED",
                Self::NotEligible => "NOT_ELIGIBLE",
                Self::Limited => "LIMITED",
                Self::Pending => "PENDING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ELIGIBLE" => Some(Self::Eligible),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                "NOT_ELIGIBLE" => Some(Self::NotEligible),
                "LIMITED" => Some(Self::Limited),
                "PENDING" => Some(Self::Pending),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible asset group primary status reasons.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupPrimaryStatusReasonEnum {}
/// Nested message and enum types in `AssetGroupPrimaryStatusReasonEnum`.
pub mod asset_group_primary_status_reason_enum {
    /// Enum describing the possible asset group primary status reasons. Provides
    /// reasons into why an asset group is not serving or not serving optimally.
    /// It will be empty when the asset group is serving without issues.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupPrimaryStatusReason {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The user-specified asset group status is paused.
        AssetGroupPaused = 2,
        /// The user-specified asset group status is removed.
        AssetGroupRemoved = 3,
        /// The user-specified campaign status is removed.
        CampaignRemoved = 4,
        /// The user-specified campaign status is paused.
        CampaignPaused = 5,
        /// The user-specified time for this campaign to start is in the future.
        CampaignPending = 6,
        /// The user-specified time for this campaign to end has passed.
        CampaignEnded = 7,
        /// The asset group is approved but only serves in limited capacity due to
        /// policies.
        AssetGroupLimited = 8,
        /// The asset group has been marked as disapproved.
        AssetGroupDisapproved = 9,
        /// The asset group has not completed policy review.
        AssetGroupUnderReview = 10,
    }
    impl AssetGroupPrimaryStatusReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AssetGroupPaused => "ASSET_GROUP_PAUSED",
                Self::AssetGroupRemoved => "ASSET_GROUP_REMOVED",
                Self::CampaignRemoved => "CAMPAIGN_REMOVED",
                Self::CampaignPaused => "CAMPAIGN_PAUSED",
                Self::CampaignPending => "CAMPAIGN_PENDING",
                Self::CampaignEnded => "CAMPAIGN_ENDED",
                Self::AssetGroupLimited => "ASSET_GROUP_LIMITED",
                Self::AssetGroupDisapproved => "ASSET_GROUP_DISAPPROVED",
                Self::AssetGroupUnderReview => "ASSET_GROUP_UNDER_REVIEW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ASSET_GROUP_PAUSED" => Some(Self::AssetGroupPaused),
                "ASSET_GROUP_REMOVED" => Some(Self::AssetGroupRemoved),
                "CAMPAIGN_REMOVED" => Some(Self::CampaignRemoved),
                "CAMPAIGN_PAUSED" => Some(Self::CampaignPaused),
                "CAMPAIGN_PENDING" => Some(Self::CampaignPending),
                "CAMPAIGN_ENDED" => Some(Self::CampaignEnded),
                "ASSET_GROUP_LIMITED" => Some(Self::AssetGroupLimited),
                "ASSET_GROUP_DISAPPROVED" => Some(Self::AssetGroupDisapproved),
                "ASSET_GROUP_UNDER_REVIEW" => Some(Self::AssetGroupUnderReview),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible AssetGroupSignal approval statuses.
/// Details see <https://support.google.com/google-ads/answer/2453978.>
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupSignalApprovalStatusEnum {}
/// Nested message and enum types in `AssetGroupSignalApprovalStatusEnum`.
pub mod asset_group_signal_approval_status_enum {
    /// Enumerates AssetGroupSignal approval statuses, which are only used for
    /// Search Theme Signal.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupSignalApprovalStatus {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Search Theme is eligible to show ads.
        Approved = 2,
        /// Low search volume; Below first page bid estimate.
        Limited = 3,
        /// Search Theme is inactive and isn't showing ads. A disapproved Search
        /// Theme usually means there's an issue with one or more of our advertising
        /// policies.
        Disapproved = 4,
        /// Search Theme is under review. It won’t be able to trigger ads until
        /// it's been reviewed.
        UnderReview = 5,
    }
    impl AssetGroupSignalApprovalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Approved => "APPROVED",
                Self::Limited => "LIMITED",
                Self::Disapproved => "DISAPPROVED",
                Self::UnderReview => "UNDER_REVIEW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APPROVED" => Some(Self::Approved),
                "LIMITED" => Some(Self::Limited),
                "DISAPPROVED" => Some(Self::Disapproved),
                "UNDER_REVIEW" => Some(Self::UnderReview),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of an asset group.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupStatusEnum {}
/// Nested message and enum types in `AssetGroupStatusEnum`.
pub mod asset_group_status_enum {
    /// The possible statuses of an asset group.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupStatus {
        /// The status has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        Unknown = 1,
        /// The asset group is enabled.
        Enabled = 2,
        /// The asset group is paused.
        Paused = 3,
        /// The asset group is removed.
        Removed = 4,
    }
    impl AssetGroupStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Paused => "PAUSED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of an asset link.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetLinkStatusEnum {}
/// Nested message and enum types in `AssetLinkStatusEnum`.
pub mod asset_link_status_enum {
    /// Enum describing statuses of an asset link.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetLinkStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Asset link is enabled.
        Enabled = 2,
        /// Asset link has been removed.
        Removed = 3,
        /// Asset link is paused.
        Paused = 4,
    }
    impl AssetLinkStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
                Self::Paused => "PAUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                "PAUSED" => Some(Self::Paused),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of an asset set asset.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSetAssetStatusEnum {}
/// Nested message and enum types in `AssetSetAssetStatusEnum`.
pub mod asset_set_asset_status_enum {
    /// The possible statuses of an asset set asset.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSetAssetStatus {
        /// The status has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        /// This is a response-only value.
        Unknown = 1,
        /// The asset set asset is enabled.
        Enabled = 2,
        /// The asset set asset is removed.
        Removed = 3,
    }
    impl AssetSetAssetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of the linkage between asset
/// set and its container.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSetLinkStatusEnum {}
/// Nested message and enum types in `AssetSetLinkStatusEnum`.
pub mod asset_set_link_status_enum {
    /// The possible statuses of the linkage between asset set and its container.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSetLinkStatus {
        /// The status has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        /// This is a response-only value.
        Unknown = 1,
        /// The linkage between asset set and its container is enabled.
        Enabled = 2,
        /// The linkage between asset set and its container is removed.
        Removed = 3,
    }
    impl AssetSetLinkStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of an asset set.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSetStatusEnum {}
/// Nested message and enum types in `AssetSetStatusEnum`.
pub mod asset_set_status_enum {
    /// The possible statuses of an asset set.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSetStatus {
        /// The status has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        /// This is a response-only value.
        Unknown = 1,
        /// The asset set is enabled.
        Enabled = 2,
        /// The asset set is removed.
        Removed = 3,
    }
    impl AssetSetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible types of an asset set.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSetTypeEnum {}
/// Nested message and enum types in `AssetSetTypeEnum`.
pub mod asset_set_type_enum {
    /// Possible types of an asset set.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSetType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Page asset set.
        PageFeed = 2,
        /// Dynamic education asset set.
        DynamicEducation = 3,
        /// Google Merchant Center asset set.
        MerchantCenterFeed = 4,
        /// Dynamic real estate asset set.
        DynamicRealEstate = 5,
        /// Dynamic custom asset set.
        DynamicCustom = 6,
        /// Dynamic hotels and rentals asset set.
        DynamicHotelsAndRentals = 7,
        /// Dynamic flights asset set.
        DynamicFlights = 8,
        /// Dynamic travel asset set.
        DynamicTravel = 9,
        /// Dynamic local asset set.
        DynamicLocal = 10,
        /// Dynamic jobs asset set.
        DynamicJobs = 11,
        /// Location sync level asset set.
        LocationSync = 12,
        /// Business Profile location group asset set.
        BusinessProfileDynamicLocationGroup = 13,
        /// Chain location group asset set which can be used for both owned
        /// locations and affiliate locations.
        ChainDynamicLocationGroup = 14,
        /// Static location group asset set which can be used for both owned
        /// locations and affiliate locations.
        StaticLocationGroup = 15,
        /// Hotel Property asset set which is used to link a hotel property feed to
        /// Performance Max for travel goals campaigns.
        HotelProperty = 16,
    }
    impl AssetSetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::PageFeed => "PAGE_FEED",
                Self::DynamicEducation => "DYNAMIC_EDUCATION",
                Self::MerchantCenterFeed => "MERCHANT_CENTER_FEED",
                Self::DynamicRealEstate => "DYNAMIC_REAL_ESTATE",
                Self::DynamicCustom => "DYNAMIC_CUSTOM",
                Self::DynamicHotelsAndRentals => "DYNAMIC_HOTELS_AND_RENTALS",
                Self::DynamicFlights => "DYNAMIC_FLIGHTS",
                Self::DynamicTravel => "DYNAMIC_TRAVEL",
                Self::DynamicLocal => "DYNAMIC_LOCAL",
                Self::DynamicJobs => "DYNAMIC_JOBS",
                Self::LocationSync => "LOCATION_SYNC",
                Self::BusinessProfileDynamicLocationGroup => {
                    "BUSINESS_PROFILE_DYNAMIC_LOCATION_GROUP"
                }
                Self::ChainDynamicLocationGroup => "CHAIN_DYNAMIC_LOCATION_GROUP",
                Self::StaticLocationGroup => "STATIC_LOCATION_GROUP",
                Self::HotelProperty => "HOTEL_PROPERTY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PAGE_FEED" => Some(Self::PageFeed),
                "DYNAMIC_EDUCATION" => Some(Self::DynamicEducation),
                "MERCHANT_CENTER_FEED" => Some(Self::MerchantCenterFeed),
                "DYNAMIC_REAL_ESTATE" => Some(Self::DynamicRealEstate),
                "DYNAMIC_CUSTOM" => Some(Self::DynamicCustom),
                "DYNAMIC_HOTELS_AND_RENTALS" => Some(Self::DynamicHotelsAndRentals),
                "DYNAMIC_FLIGHTS" => Some(Self::DynamicFlights),
                "DYNAMIC_TRAVEL" => Some(Self::DynamicTravel),
                "DYNAMIC_LOCAL" => Some(Self::DynamicLocal),
                "DYNAMIC_JOBS" => Some(Self::DynamicJobs),
                "LOCATION_SYNC" => Some(Self::LocationSync),
                "BUSINESS_PROFILE_DYNAMIC_LOCATION_GROUP" => {
                    Some(Self::BusinessProfileDynamicLocationGroup)
                }
                "CHAIN_DYNAMIC_LOCATION_GROUP" => Some(Self::ChainDynamicLocationGroup),
                "STATIC_LOCATION_GROUP" => Some(Self::StaticLocationGroup),
                "HOTEL_PROPERTY" => Some(Self::HotelProperty),
                _ => None,
            }
        }
    }
}
/// Source of the asset or asset link for who generated the entity.
/// For example, advertiser or automatically created.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSourceEnum {}
/// Nested message and enum types in `AssetSourceEnum`.
pub mod asset_source_enum {
    /// Enum describing possible source of asset.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSource {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The asset or asset link is provided by advertiser.
        Advertiser = 2,
        /// The asset or asset link is generated by Google.
        AutomaticallyCreated = 3,
    }
    impl AssetSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Advertiser => "ADVERTISER",
                Self::AutomaticallyCreated => "AUTOMATICALLY_CREATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADVERTISER" => Some(Self::Advertiser),
                "AUTOMATICALLY_CREATED" => Some(Self::AutomaticallyCreated),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the types of asset.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetTypeEnum {}
/// Nested message and enum types in `AssetTypeEnum`.
pub mod asset_type_enum {
    /// Enum describing possible types of asset.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// YouTube video asset.
        YoutubeVideo = 2,
        /// Media bundle asset.
        MediaBundle = 3,
        /// Image asset.
        Image = 4,
        /// Text asset.
        Text = 5,
        /// Lead form asset.
        LeadForm = 6,
        /// Book on Google asset.
        BookOnGoogle = 7,
        /// Promotion asset.
        Promotion = 8,
        /// Callout asset.
        Callout = 9,
        /// Structured Snippet asset.
        StructuredSnippet = 10,
        /// Sitelink asset.
        Sitelink = 11,
        /// Page Feed asset.
        PageFeed = 12,
        /// Dynamic Education asset.
        DynamicEducation = 13,
        /// Mobile app asset.
        MobileApp = 14,
        /// Hotel callout asset.
        HotelCallout = 15,
        /// Call asset.
        Call = 16,
        /// Price asset.
        Price = 17,
        /// Call to action asset.
        CallToAction = 18,
        /// Dynamic real estate asset.
        DynamicRealEstate = 19,
        /// Dynamic custom asset.
        DynamicCustom = 20,
        /// Dynamic hotels and rentals asset.
        DynamicHotelsAndRentals = 21,
        /// Dynamic flights asset.
        DynamicFlights = 22,
        /// Discovery Carousel Card asset.
        DiscoveryCarouselCard = 23,
        /// Dynamic travel asset.
        DynamicTravel = 24,
        /// Dynamic local asset.
        DynamicLocal = 25,
        /// Dynamic jobs asset.
        DynamicJobs = 26,
        /// Location asset.
        Location = 27,
        /// Hotel property asset.
        HotelProperty = 28,
    }
    impl AssetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::YoutubeVideo => "YOUTUBE_VIDEO",
                Self::MediaBundle => "MEDIA_BUNDLE",
                Self::Image => "IMAGE",
                Self::Text => "TEXT",
                Self::LeadForm => "LEAD_FORM",
                Self::BookOnGoogle => "BOOK_ON_GOOGLE",
                Self::Promotion => "PROMOTION",
                Self::Callout => "CALLOUT",
                Self::StructuredSnippet => "STRUCTURED_SNIPPET",
                Self::Sitelink => "SITELINK",
                Self::PageFeed => "PAGE_FEED",
                Self::DynamicEducation => "DYNAMIC_EDUCATION",
                Self::MobileApp => "MOBILE_APP",
                Self::HotelCallout => "HOTEL_CALLOUT",
                Self::Call => "CALL",
                Self::Price => "PRICE",
                Self::CallToAction => "CALL_TO_ACTION",
                Self::DynamicRealEstate => "DYNAMIC_REAL_ESTATE",
                Self::DynamicCustom => "DYNAMIC_CUSTOM",
                Self::DynamicHotelsAndRentals => "DYNAMIC_HOTELS_AND_RENTALS",
                Self::DynamicFlights => "DYNAMIC_FLIGHTS",
                Self::DiscoveryCarouselCard => "DISCOVERY_CAROUSEL_CARD",
                Self::DynamicTravel => "DYNAMIC_TRAVEL",
                Self::DynamicLocal => "DYNAMIC_LOCAL",
                Self::DynamicJobs => "DYNAMIC_JOBS",
                Self::Location => "LOCATION",
                Self::HotelProperty => "HOTEL_PROPERTY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "YOUTUBE_VIDEO" => Some(Self::YoutubeVideo),
                "MEDIA_BUNDLE" => Some(Self::MediaBundle),
                "IMAGE" => Some(Self::Image),
                "TEXT" => Some(Self::Text),
                "LEAD_FORM" => Some(Self::LeadForm),
                "BOOK_ON_GOOGLE" => Some(Self::BookOnGoogle),
                "PROMOTION" => Some(Self::Promotion),
                "CALLOUT" => Some(Self::Callout),
                "STRUCTURED_SNIPPET" => Some(Self::StructuredSnippet),
                "SITELINK" => Some(Self::Sitelink),
                "PAGE_FEED" => Some(Self::PageFeed),
                "DYNAMIC_EDUCATION" => Some(Self::DynamicEducation),
                "MOBILE_APP" => Some(Self::MobileApp),
                "HOTEL_CALLOUT" => Some(Self::HotelCallout),
                "CALL" => Some(Self::Call),
                "PRICE" => Some(Self::Price),
                "CALL_TO_ACTION" => Some(Self::CallToAction),
                "DYNAMIC_REAL_ESTATE" => Some(Self::DynamicRealEstate),
                "DYNAMIC_CUSTOM" => Some(Self::DynamicCustom),
                "DYNAMIC_HOTELS_AND_RENTALS" => Some(Self::DynamicHotelsAndRentals),
                "DYNAMIC_FLIGHTS" => Some(Self::DynamicFlights),
                "DISCOVERY_CAROUSEL_CARD" => Some(Self::DiscoveryCarouselCard),
                "DYNAMIC_TRAVEL" => Some(Self::DynamicTravel),
                "DYNAMIC_LOCAL" => Some(Self::DynamicLocal),
                "DYNAMIC_JOBS" => Some(Self::DynamicJobs),
                "LOCATION" => Some(Self::Location),
                "HOTEL_PROPERTY" => Some(Self::HotelProperty),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the experiment async action status.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AsyncActionStatusEnum {}
/// Nested message and enum types in `AsyncActionStatusEnum`.
pub mod async_action_status_enum {
    /// The async action status of the experiment.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AsyncActionStatus {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Action has not started.
        NotStarted = 2,
        /// Action is in progress.
        InProgress = 3,
        /// Action has completed successfully.
        Completed = 4,
        /// Action has failed.
        Failed = 5,
        /// Action has completed successfully with warnings.
        CompletedWithWarning = 6,
    }
    impl AsyncActionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NotStarted => "NOT_STARTED",
                Self::InProgress => "IN_PROGRESS",
                Self::Completed => "COMPLETED",
                Self::Failed => "FAILED",
                Self::CompletedWithWarning => "COMPLETED_WITH_WARNING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOT_STARTED" => Some(Self::NotStarted),
                "IN_PROGRESS" => Some(Self::InProgress),
                "COMPLETED" => Some(Self::Completed),
                "FAILED" => Some(Self::Failed),
                "COMPLETED_WITH_WARNING" => Some(Self::CompletedWithWarning),
                _ => None,
            }
        }
    }
}
/// Container for enum representing the attribution model that describes how to
/// distribute credit for a particular conversion across potentially many prior
/// interactions.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AttributionModelEnum {}
/// Nested message and enum types in `AttributionModelEnum`.
pub mod attribution_model_enum {
    /// The attribution model that describes how to distribute credit for a
    /// particular conversion across potentially many prior interactions.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AttributionModel {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Uses external attribution.
        External = 100,
        /// Attributes all credit for a conversion to its last click.
        GoogleAdsLastClick = 101,
        /// Attributes all credit for a conversion to its first click using Google
        /// Search attribution.
        GoogleSearchAttributionFirstClick = 102,
        /// Attributes credit for a conversion equally across all of its clicks using
        /// Google Search attribution.
        GoogleSearchAttributionLinear = 103,
        /// Attributes exponentially more credit for a conversion to its more recent
        /// clicks using Google Search attribution (half-life is 1 week).
        GoogleSearchAttributionTimeDecay = 104,
        /// Attributes 40% of the credit for a conversion to its first and last
        /// clicks. Remaining 20% is evenly distributed across all other clicks. This
        /// uses Google Search attribution.
        GoogleSearchAttributionPositionBased = 105,
        /// Flexible model that uses machine learning to determine the appropriate
        /// distribution of credit among clicks using Google Search attribution.
        GoogleSearchAttributionDataDriven = 106,
    }
    impl AttributionModel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::External => "EXTERNAL",
                Self::GoogleAdsLastClick => "GOOGLE_ADS_LAST_CLICK",
                Self::GoogleSearchAttributionFirstClick => {
                    "GOOGLE_SEARCH_ATTRIBUTION_FIRST_CLICK"
                }
                Self::GoogleSearchAttributionLinear => "GOOGLE_SEARCH_ATTRIBUTION_LINEAR",
                Self::GoogleSearchAttributionTimeDecay => {
                    "GOOGLE_SEARCH_ATTRIBUTION_TIME_DECAY"
                }
                Self::GoogleSearchAttributionPositionBased => {
                    "GOOGLE_SEARCH_ATTRIBUTION_POSITION_BASED"
                }
                Self::GoogleSearchAttributionDataDriven => {
                    "GOOGLE_SEARCH_ATTRIBUTION_DATA_DRIVEN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXTERNAL" => Some(Self::External),
                "GOOGLE_ADS_LAST_CLICK" => Some(Self::GoogleAdsLastClick),
                "GOOGLE_SEARCH_ATTRIBUTION_FIRST_CLICK" => {
                    Some(Self::GoogleSearchAttributionFirstClick)
                }
                "GOOGLE_SEARCH_ATTRIBUTION_LINEAR" => {
                    Some(Self::GoogleSearchAttributionLinear)
                }
                "GOOGLE_SEARCH_ATTRIBUTION_TIME_DECAY" => {
                    Some(Self::GoogleSearchAttributionTimeDecay)
                }
                "GOOGLE_SEARCH_ATTRIBUTION_POSITION_BASED" => {
                    Some(Self::GoogleSearchAttributionPositionBased)
                }
                "GOOGLE_SEARCH_ATTRIBUTION_DATA_DRIVEN" => {
                    Some(Self::GoogleSearchAttributionDataDriven)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing insights dimensions.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudienceInsightsDimensionEnum {}
/// Nested message and enum types in `AudienceInsightsDimensionEnum`.
pub mod audience_insights_dimension_enum {
    /// Possible dimensions for use in generating insights.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AudienceInsightsDimension {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// A Product & Service category.
        Category = 2,
        /// A Knowledge Graph entity.
        KnowledgeGraph = 3,
        /// A country, represented by a geo target.
        GeoTargetCountry = 4,
        /// A geographic location within a country.
        SubCountryLocation = 5,
        /// A YouTube channel.
        YoutubeChannel = 6,
        /// A YouTube Dynamic Lineup.
        YoutubeDynamicLineup = 7,
        /// An Affinity UserInterest.
        AffinityUserInterest = 8,
        /// An In-Market UserInterest.
        InMarketUserInterest = 9,
        /// A Parental Status value (parent, or not a parent).
        ParentalStatus = 10,
        /// A household income percentile range.
        IncomeRange = 11,
        /// An age range.
        AgeRange = 12,
        /// A gender.
        Gender = 13,
    }
    impl AudienceInsightsDimension {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Category => "CATEGORY",
                Self::KnowledgeGraph => "KNOWLEDGE_GRAPH",
                Self::GeoTargetCountry => "GEO_TARGET_COUNTRY",
                Self::SubCountryLocation => "SUB_COUNTRY_LOCATION",
                Self::YoutubeChannel => "YOUTUBE_CHANNEL",
                Self::YoutubeDynamicLineup => "YOUTUBE_DYNAMIC_LINEUP",
                Self::AffinityUserInterest => "AFFINITY_USER_INTEREST",
                Self::InMarketUserInterest => "IN_MARKET_USER_INTEREST",
                Self::ParentalStatus => "PARENTAL_STATUS",
                Self::IncomeRange => "INCOME_RANGE",
                Self::AgeRange => "AGE_RANGE",
                Self::Gender => "GENDER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CATEGORY" => Some(Self::Category),
                "KNOWLEDGE_GRAPH" => Some(Self::KnowledgeGraph),
                "GEO_TARGET_COUNTRY" => Some(Self::GeoTargetCountry),
                "SUB_COUNTRY_LOCATION" => Some(Self::SubCountryLocation),
                "YOUTUBE_CHANNEL" => Some(Self::YoutubeChannel),
                "YOUTUBE_DYNAMIC_LINEUP" => Some(Self::YoutubeDynamicLineup),
                "AFFINITY_USER_INTEREST" => Some(Self::AffinityUserInterest),
                "IN_MARKET_USER_INTEREST" => Some(Self::InMarketUserInterest),
                "PARENTAL_STATUS" => Some(Self::ParentalStatus),
                "INCOME_RANGE" => Some(Self::IncomeRange),
                "AGE_RANGE" => Some(Self::AgeRange),
                "GENDER" => Some(Self::Gender),
                _ => None,
            }
        }
    }
}
/// Defines the scope an audience can be used in.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudienceScopeEnum {}
/// Nested message and enum types in `AudienceScopeEnum`.
pub mod audience_scope_enum {
    /// Enum containing possible audience scope values.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AudienceScope {
        /// The scope has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        Unknown = 1,
        /// The audience is scoped at the customer level.
        Customer = 2,
        /// The audience is scoped under a specific AssetGroup.
        AssetGroup = 3,
    }
    impl AudienceScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Customer => "CUSTOMER",
                Self::AssetGroup => "ASSET_GROUP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOMER" => Some(Self::Customer),
                "ASSET_GROUP" => Some(Self::AssetGroup),
                _ => None,
            }
        }
    }
}
/// The status of audience.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudienceStatusEnum {}
/// Nested message and enum types in `AudienceStatusEnum`.
pub mod audience_status_enum {
    /// Enum containing possible audience status types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AudienceStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Enabled status - audience is enabled and can be targeted.
        Enabled = 2,
        /// Removed status - audience is removed and cannot be used for
        /// targeting.
        Removed = 3,
    }
    impl AudienceStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible batch job statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchJobStatusEnum {}
/// Nested message and enum types in `BatchJobStatusEnum`.
pub mod batch_job_status_enum {
    /// The batch job statuses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BatchJobStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The job is not currently running.
        Pending = 2,
        /// The job is running.
        Running = 3,
        /// The job is done.
        Done = 4,
    }
    impl BatchJobStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Pending => "PENDING",
                Self::Running => "RUNNING",
                Self::Done => "DONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "RUNNING" => Some(Self::Running),
                "DONE" => Some(Self::Done),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible bid modifier sources.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BidModifierSourceEnum {}
/// Nested message and enum types in `BidModifierSourceEnum`.
pub mod bid_modifier_source_enum {
    /// Enum describing possible bid modifier sources.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BidModifierSource {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The bid modifier is specified at the campaign level, on the campaign
        /// level criterion.
        Campaign = 2,
        /// The bid modifier is specified (overridden) at the ad group level.
        AdGroup = 3,
    }
    impl BidModifierSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Campaign => "CAMPAIGN",
                Self::AdGroup => "AD_GROUP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN" => Some(Self::Campaign),
                "AD_GROUP" => Some(Self::AdGroup),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible bidding sources.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BiddingSourceEnum {}
/// Nested message and enum types in `BiddingSourceEnum`.
pub mod bidding_source_enum {
    /// Indicates where a bid or target is defined. For example, an ad group
    /// criterion may define a cpc bid directly, or it can inherit its cpc bid from
    /// the ad group.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BiddingSource {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Effective bid or target is inherited from campaign bidding strategy.
        CampaignBiddingStrategy = 5,
        /// The bid or target is defined on the ad group.
        AdGroup = 6,
        /// The bid or target is defined on the ad group criterion.
        AdGroupCriterion = 7,
    }
    impl BiddingSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CampaignBiddingStrategy => "CAMPAIGN_BIDDING_STRATEGY",
                Self::AdGroup => "AD_GROUP",
                Self::AdGroupCriterion => "AD_GROUP_CRITERION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_BIDDING_STRATEGY" => Some(Self::CampaignBiddingStrategy),
                "AD_GROUP" => Some(Self::AdGroup),
                "AD_GROUP_CRITERION" => Some(Self::AdGroupCriterion),
                _ => None,
            }
        }
    }
}
/// Message describing BiddingStrategy statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BiddingStrategyStatusEnum {}
/// Nested message and enum types in `BiddingStrategyStatusEnum`.
pub mod bidding_strategy_status_enum {
    /// The possible statuses of a BiddingStrategy.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BiddingStrategyStatus {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// The bidding strategy is enabled.
        Enabled = 2,
        /// The bidding strategy is removed.
        Removed = 4,
    }
    impl BiddingStrategyStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Message describing BiddingStrategy system statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BiddingStrategySystemStatusEnum {}
/// Nested message and enum types in `BiddingStrategySystemStatusEnum`.
pub mod bidding_strategy_system_status_enum {
    /// The possible system statuses of a BiddingStrategy.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BiddingStrategySystemStatus {
        /// Signals that an unexpected error occurred, for example, no bidding
        /// strategy type was found, or no status information was found.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The bid strategy is active, and AdWords cannot find any specific issues
        /// with the strategy.
        Enabled = 2,
        /// The bid strategy is learning because it has been recently created or
        /// recently reactivated.
        LearningNew = 3,
        /// The bid strategy is learning because of a recent setting change.
        LearningSettingChange = 4,
        /// The bid strategy is learning because of a recent budget change.
        LearningBudgetChange = 5,
        /// The bid strategy is learning because of recent change in number of
        /// campaigns, ad groups or keywords attached to it.
        LearningCompositionChange = 6,
        /// The bid strategy depends on conversion reporting and the customer
        /// recently modified conversion types that were relevant to the
        /// bid strategy.
        LearningConversionTypeChange = 7,
        /// The bid strategy depends on conversion reporting and the customer
        /// recently changed their conversion settings.
        LearningConversionSettingChange = 8,
        /// The bid strategy is limited by its bid ceiling.
        LimitedByCpcBidCeiling = 9,
        /// The bid strategy is limited by its bid floor.
        LimitedByCpcBidFloor = 10,
        /// The bid strategy is limited because there was not enough conversion
        /// traffic over the past weeks.
        LimitedByData = 11,
        /// A significant fraction of keywords in this bid strategy are limited by
        /// budget.
        LimitedByBudget = 12,
        /// The bid strategy cannot reach its target spend because its spend has
        /// been de-prioritized.
        LimitedByLowPrioritySpend = 13,
        /// A significant fraction of keywords in this bid strategy have a low
        /// Quality Score.
        LimitedByLowQuality = 14,
        /// The bid strategy cannot fully spend its budget because of narrow
        /// targeting.
        LimitedByInventory = 15,
        /// Missing conversion tracking (no pings present) and/or remarketing lists
        /// for SSC.
        MisconfiguredZeroEligibility = 16,
        /// The bid strategy depends on conversion reporting and the customer is
        /// lacking conversion types that might be reported against this strategy.
        MisconfiguredConversionTypes = 17,
        /// The bid strategy depends on conversion reporting and the customer's
        /// conversion settings are misconfigured.
        MisconfiguredConversionSettings = 18,
        /// There are campaigns outside the bid strategy that share budgets with
        /// campaigns included in the strategy.
        MisconfiguredSharedBudget = 19,
        /// The campaign has an invalid strategy type and is not serving.
        MisconfiguredStrategyType = 20,
        /// The bid strategy is not active. Either there are no active campaigns,
        /// ad groups or keywords attached to the bid strategy. Or there are no
        /// active budgets connected to the bid strategy.
        Paused = 21,
        /// This bid strategy currently does not support status reporting.
        Unavailable = 22,
        /// There were multiple LEARNING_* system statuses for this bid strategy
        /// during the time in question.
        MultipleLearning = 23,
        /// There were multiple LIMITED_* system statuses for this bid strategy
        /// during the time in question.
        MultipleLimited = 24,
        /// There were multiple MISCONFIGURED_* system statuses for this bid strategy
        /// during the time in question.
        MultipleMisconfigured = 25,
        /// There were multiple system statuses for this bid strategy during the
        /// time in question.
        Multiple = 26,
    }
    impl BiddingStrategySystemStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::LearningNew => "LEARNING_NEW",
                Self::LearningSettingChange => "LEARNING_SETTING_CHANGE",
                Self::LearningBudgetChange => "LEARNING_BUDGET_CHANGE",
                Self::LearningCompositionChange => "LEARNING_COMPOSITION_CHANGE",
                Self::LearningConversionTypeChange => "LEARNING_CONVERSION_TYPE_CHANGE",
                Self::LearningConversionSettingChange => {
                    "LEARNING_CONVERSION_SETTING_CHANGE"
                }
                Self::LimitedByCpcBidCeiling => "LIMITED_BY_CPC_BID_CEILING",
                Self::LimitedByCpcBidFloor => "LIMITED_BY_CPC_BID_FLOOR",
                Self::LimitedByData => "LIMITED_BY_DATA",
                Self::LimitedByBudget => "LIMITED_BY_BUDGET",
                Self::LimitedByLowPrioritySpend => "LIMITED_BY_LOW_PRIORITY_SPEND",
                Self::LimitedByLowQuality => "LIMITED_BY_LOW_QUALITY",
                Self::LimitedByInventory => "LIMITED_BY_INVENTORY",
                Self::MisconfiguredZeroEligibility => "MISCONFIGURED_ZERO_ELIGIBILITY",
                Self::MisconfiguredConversionTypes => "MISCONFIGURED_CONVERSION_TYPES",
                Self::MisconfiguredConversionSettings => {
                    "MISCONFIGURED_CONVERSION_SETTINGS"
                }
                Self::MisconfiguredSharedBudget => "MISCONFIGURED_SHARED_BUDGET",
                Self::MisconfiguredStrategyType => "MISCONFIGURED_STRATEGY_TYPE",
                Self::Paused => "PAUSED",
                Self::Unavailable => "UNAVAILABLE",
                Self::MultipleLearning => "MULTIPLE_LEARNING",
                Self::MultipleLimited => "MULTIPLE_LIMITED",
                Self::MultipleMisconfigured => "MULTIPLE_MISCONFIGURED",
                Self::Multiple => "MULTIPLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "LEARNING_NEW" => Some(Self::LearningNew),
                "LEARNING_SETTING_CHANGE" => Some(Self::LearningSettingChange),
                "LEARNING_BUDGET_CHANGE" => Some(Self::LearningBudgetChange),
                "LEARNING_COMPOSITION_CHANGE" => Some(Self::LearningCompositionChange),
                "LEARNING_CONVERSION_TYPE_CHANGE" => {
                    Some(Self::LearningConversionTypeChange)
                }
                "LEARNING_CONVERSION_SETTING_CHANGE" => {
                    Some(Self::LearningConversionSettingChange)
                }
                "LIMITED_BY_CPC_BID_CEILING" => Some(Self::LimitedByCpcBidCeiling),
                "LIMITED_BY_CPC_BID_FLOOR" => Some(Self::LimitedByCpcBidFloor),
                "LIMITED_BY_DATA" => Some(Self::LimitedByData),
                "LIMITED_BY_BUDGET" => Some(Self::LimitedByBudget),
                "LIMITED_BY_LOW_PRIORITY_SPEND" => Some(Self::LimitedByLowPrioritySpend),
                "LIMITED_BY_LOW_QUALITY" => Some(Self::LimitedByLowQuality),
                "LIMITED_BY_INVENTORY" => Some(Self::LimitedByInventory),
                "MISCONFIGURED_ZERO_ELIGIBILITY" => {
                    Some(Self::MisconfiguredZeroEligibility)
                }
                "MISCONFIGURED_CONVERSION_TYPES" => {
                    Some(Self::MisconfiguredConversionTypes)
                }
                "MISCONFIGURED_CONVERSION_SETTINGS" => {
                    Some(Self::MisconfiguredConversionSettings)
                }
                "MISCONFIGURED_SHARED_BUDGET" => Some(Self::MisconfiguredSharedBudget),
                "MISCONFIGURED_STRATEGY_TYPE" => Some(Self::MisconfiguredStrategyType),
                "PAUSED" => Some(Self::Paused),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "MULTIPLE_LEARNING" => Some(Self::MultipleLearning),
                "MULTIPLE_LIMITED" => Some(Self::MultipleLimited),
                "MULTIPLE_MISCONFIGURED" => Some(Self::MultipleMisconfigured),
                "MULTIPLE" => Some(Self::Multiple),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible bidding strategy types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BiddingStrategyTypeEnum {}
/// Nested message and enum types in `BiddingStrategyTypeEnum`.
pub mod bidding_strategy_type_enum {
    /// Enum describing possible bidding strategy types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BiddingStrategyType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Commission is an automatic bidding strategy in which the advertiser pays
        /// a certain portion of the conversion value.
        Commission = 16,
        /// Enhanced CPC is a bidding strategy that raises bids for clicks
        /// that seem more likely to lead to a conversion and lowers
        /// them for clicks where they seem less likely.
        EnhancedCpc = 2,
        /// Used for return value only. Indicates that a campaign does not have a
        /// bidding strategy. This prevents the campaign from serving. For example,
        /// a campaign may be attached to a manager bidding strategy and the serving
        /// account is subsequently unlinked from the manager account. In this case
        /// the campaign will automatically be detached from the now inaccessible
        /// manager bidding strategy and transition to the INVALID bidding strategy
        /// type.
        Invalid = 17,
        /// Manual bidding strategy that allows advertiser to set the bid per
        /// advertiser-specified action.
        ManualCpa = 18,
        /// Manual click based bidding where user pays per click.
        ManualCpc = 3,
        /// Manual impression based bidding
        /// where user pays per thousand impressions.
        ManualCpm = 4,
        /// A bidding strategy that pays a configurable amount per video view.
        ManualCpv = 13,
        /// A bidding strategy that automatically maximizes number of conversions
        /// given a daily budget.
        MaximizeConversions = 10,
        /// An automated bidding strategy that automatically sets bids to maximize
        /// revenue while spending your budget.
        MaximizeConversionValue = 11,
        /// Page-One Promoted bidding scheme, which sets max cpc bids to
        /// target impressions on page one or page one promoted slots on google.com.
        /// This enum value is deprecated.
        PageOnePromoted = 5,
        /// Percent Cpc is bidding strategy where bids are a fraction of the
        /// advertised price for some good or service.
        PercentCpc = 12,
        /// Target CPA is an automated bid strategy that sets bids
        /// to help get as many conversions as possible
        /// at the target cost-per-acquisition (CPA) you set.
        TargetCpa = 6,
        /// Target CPM is an automated bid strategy that sets bids to help get
        /// as many impressions as possible at the target cost per one thousand
        /// impressions (CPM) you set.
        TargetCpm = 14,
        /// An automated bidding strategy that sets bids so that a certain percentage
        /// of search ads are shown at the top of the first page (or other targeted
        /// location).
        TargetImpressionShare = 15,
        /// Target Outrank Share is an automated bidding strategy that sets bids
        /// based on the target fraction of auctions where the advertiser
        /// should outrank a specific competitor.
        /// This enum value is deprecated.
        TargetOutrankShare = 7,
        /// Target ROAS is an automated bidding strategy
        /// that helps you maximize revenue while averaging
        /// a specific target Return On Average Spend (ROAS).
        TargetRoas = 8,
        /// Target Spend is an automated bid strategy that sets your bids
        /// to help get as many clicks as possible within your budget.
        TargetSpend = 9,
    }
    impl BiddingStrategyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Commission => "COMMISSION",
                Self::EnhancedCpc => "ENHANCED_CPC",
                Self::Invalid => "INVALID",
                Self::ManualCpa => "MANUAL_CPA",
                Self::ManualCpc => "MANUAL_CPC",
                Self::ManualCpm => "MANUAL_CPM",
                Self::ManualCpv => "MANUAL_CPV",
                Self::MaximizeConversions => "MAXIMIZE_CONVERSIONS",
                Self::MaximizeConversionValue => "MAXIMIZE_CONVERSION_VALUE",
                Self::PageOnePromoted => "PAGE_ONE_PROMOTED",
                Self::PercentCpc => "PERCENT_CPC",
                Self::TargetCpa => "TARGET_CPA",
                Self::TargetCpm => "TARGET_CPM",
                Self::TargetImpressionShare => "TARGET_IMPRESSION_SHARE",
                Self::TargetOutrankShare => "TARGET_OUTRANK_SHARE",
                Self::TargetRoas => "TARGET_ROAS",
                Self::TargetSpend => "TARGET_SPEND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "COMMISSION" => Some(Self::Commission),
                "ENHANCED_CPC" => Some(Self::EnhancedCpc),
                "INVALID" => Some(Self::Invalid),
                "MANUAL_CPA" => Some(Self::ManualCpa),
                "MANUAL_CPC" => Some(Self::ManualCpc),
                "MANUAL_CPM" => Some(Self::ManualCpm),
                "MANUAL_CPV" => Some(Self::ManualCpv),
                "MAXIMIZE_CONVERSIONS" => Some(Self::MaximizeConversions),
                "MAXIMIZE_CONVERSION_VALUE" => Some(Self::MaximizeConversionValue),
                "PAGE_ONE_PROMOTED" => Some(Self::PageOnePromoted),
                "PERCENT_CPC" => Some(Self::PercentCpc),
                "TARGET_CPA" => Some(Self::TargetCpa),
                "TARGET_CPM" => Some(Self::TargetCpm),
                "TARGET_IMPRESSION_SHARE" => Some(Self::TargetImpressionShare),
                "TARGET_OUTRANK_SHARE" => Some(Self::TargetOutrankShare),
                "TARGET_ROAS" => Some(Self::TargetRoas),
                "TARGET_SPEND" => Some(Self::TargetSpend),
                _ => None,
            }
        }
    }
}
/// Message describing BillingSetup statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BillingSetupStatusEnum {}
/// Nested message and enum types in `BillingSetupStatusEnum`.
pub mod billing_setup_status_enum {
    /// The possible statuses of a BillingSetup.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BillingSetupStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The billing setup is pending approval.
        Pending = 2,
        /// The billing setup has been approved but the corresponding first budget
        /// has not.  This can only occur for billing setups configured for monthly
        /// invoicing.
        ApprovedHeld = 3,
        /// The billing setup has been approved.
        Approved = 4,
        /// The billing setup was cancelled by the user prior to approval.
        Cancelled = 5,
    }
    impl BillingSetupStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Pending => "PENDING",
                Self::ApprovedHeld => "APPROVED_HELD",
                Self::Approved => "APPROVED",
                Self::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "APPROVED_HELD" => Some(Self::ApprovedHeld),
                "APPROVED" => Some(Self::Approved),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
/// Container for enum with 3-Tier brand safety suitability control.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrandSafetySuitabilityEnum {}
/// Nested message and enum types in `BrandSafetySuitabilityEnum`.
pub mod brand_safety_suitability_enum {
    /// 3-Tier brand safety suitability control.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BrandSafetySuitability {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// This option lets you show ads across all inventory on YouTube and video
        /// partners that meet our standards for monetization. This option may be an
        /// appropriate choice for brands that want maximum access to the full
        /// breadth of videos eligible for ads, including, for example, videos that
        /// have strong profanity in the context of comedy or a documentary, or
        /// excessive violence as featured in video games.
        ExpandedInventory = 2,
        /// This option lets you show ads across a wide range of content that's
        /// appropriate for most brands, such as popular music videos, documentaries,
        /// and movie trailers. The content you can show ads on is based on YouTube's
        /// advertiser-friendly content guidelines that take into account, for
        /// example, the strength or frequency of profanity, or the appropriateness
        /// of subject matter like sensitive events. Ads won't show, for example, on
        /// content with repeated strong profanity, strong sexual content, or graphic
        /// violence.
        StandardInventory = 3,
        /// This option lets you show ads on a reduced range of content that's
        /// appropriate for brands with particularly strict guidelines around
        /// inappropriate language and sexual suggestiveness; above and beyond what
        /// YouTube's advertiser-friendly content guidelines address. The videos
        /// accessible in this sensitive category meet heightened requirements,
        /// especially for inappropriate language and sexual suggestiveness. For
        /// example, your ads will be excluded from showing on some of YouTube's most
        /// popular music videos and other pop culture content across YouTube and
        /// Google video partners.
        LimitedInventory = 4,
    }
    impl BrandSafetySuitability {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ExpandedInventory => "EXPANDED_INVENTORY",
                Self::StandardInventory => "STANDARD_INVENTORY",
                Self::LimitedInventory => "LIMITED_INVENTORY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXPANDED_INVENTORY" => Some(Self::ExpandedInventory),
                "STANDARD_INVENTORY" => Some(Self::StandardInventory),
                "LIMITED_INVENTORY" => Some(Self::LimitedInventory),
                _ => None,
            }
        }
    }
}
/// Message describing Budget delivery methods. A delivery method determines the
/// rate at which the Budget is spent.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BudgetDeliveryMethodEnum {}
/// Nested message and enum types in `BudgetDeliveryMethodEnum`.
pub mod budget_delivery_method_enum {
    /// Possible delivery methods of a Budget.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BudgetDeliveryMethod {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The budget server will throttle serving evenly across
        /// the entire time period.
        Standard = 2,
        /// The budget server will not throttle serving,
        /// and ads will serve as fast as possible.
        Accelerated = 3,
    }
    impl BudgetDeliveryMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Standard => "STANDARD",
                Self::Accelerated => "ACCELERATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "STANDARD" => Some(Self::Standard),
                "ACCELERATED" => Some(Self::Accelerated),
                _ => None,
            }
        }
    }
}
/// Message describing Budget period.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BudgetPeriodEnum {}
/// Nested message and enum types in `BudgetPeriodEnum`.
pub mod budget_period_enum {
    /// Possible period of a Budget.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BudgetPeriod {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Daily budget.
        Daily = 2,
        /// Custom budget, added back in V5.
        /// Custom budget can be used with total_amount to specify lifetime budget
        /// limit. See: <https://support.google.com/google-ads/answer/6385083> for more
        /// info.
        CustomPeriod = 5,
    }
    impl BudgetPeriod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Daily => "DAILY",
                Self::CustomPeriod => "CUSTOM_PERIOD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DAILY" => Some(Self::Daily),
                "CUSTOM_PERIOD" => Some(Self::CustomPeriod),
                _ => None,
            }
        }
    }
}
/// Message describing a Budget status
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BudgetStatusEnum {}
/// Nested message and enum types in `BudgetStatusEnum`.
pub mod budget_status_enum {
    /// Possible statuses of a Budget.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BudgetStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Budget is enabled.
        Enabled = 2,
        /// Budget is removed.
        Removed = 3,
    }
    impl BudgetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Describes Budget types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BudgetTypeEnum {}
/// Nested message and enum types in `BudgetTypeEnum`.
pub mod budget_type_enum {
    /// Possible Budget types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BudgetType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Budget type for standard Google Ads usage.
        /// Caps daily spend at two times the specified budget amount.
        /// Full details: <https://support.google.com/google-ads/answer/6385083>
        Standard = 2,
        /// Budget type with a fixed cost-per-acquisition (conversion).
        /// Full details: <https://support.google.com/google-ads/answer/7528254>
        ///
        /// This type is only supported by campaigns with
        /// AdvertisingChannelType.DISPLAY (excluding
        /// AdvertisingChannelSubType.DISPLAY_GMAIL),
        /// BiddingStrategyType.TARGET_CPA and PaymentMode.CONVERSIONS.
        FixedCpa = 4,
        /// Budget type for Smart Campaign.
        /// Full details: <https://support.google.com/google-ads/answer/7653509>
        ///
        /// This type is only supported by campaigns with
        /// AdvertisingChannelType.SMART and
        /// AdvertisingChannelSubType.SMART_CAMPAIGN.
        SmartCampaign = 5,
        /// Budget type for Local Services Campaign.
        /// Full details: <https://support.google.com/localservices/answer/7434558>
        ///
        /// This type is only supported by campaigns with
        /// AdvertisingChannelType.LOCAL_SERVICES.
        LocalServices = 6,
    }
    impl BudgetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Standard => "STANDARD",
                Self::FixedCpa => "FIXED_CPA",
                Self::SmartCampaign => "SMART_CAMPAIGN",
                Self::LocalServices => "LOCAL_SERVICES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "STANDARD" => Some(Self::Standard),
                "FIXED_CPA" => Some(Self::FixedCpa),
                "SMART_CAMPAIGN" => Some(Self::SmartCampaign),
                "LOCAL_SERVICES" => Some(Self::LocalServices),
                _ => None,
            }
        }
    }
}
/// Values for Call placeholder fields.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CallPlaceholderFieldEnum {}
/// Nested message and enum types in `CallPlaceholderFieldEnum`.
pub mod call_placeholder_field_enum {
    /// Possible values for Call placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallPlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. The advertiser's phone number to append to the ad.
        PhoneNumber = 2,
        /// Data Type: STRING. Uppercase two-letter country code of the advertiser's
        /// phone number.
        CountryCode = 3,
        /// Data Type: BOOLEAN. Indicates whether call tracking is enabled. Default:
        /// true.
        Tracked = 4,
        /// Data Type: INT64. The ID of an AdCallMetricsConversion object. This
        /// object contains the phoneCallDurationfield which is the minimum duration
        /// (in seconds) of a call to be considered a conversion.
        ConversionTypeId = 5,
        /// Data Type: STRING. Indicates whether this call extension uses its own
        /// call conversion setting or follows the account level setting.
        /// Valid values are: USE_ACCOUNT_LEVEL_CALL_CONVERSION_ACTION and
        /// USE_RESOURCE_LEVEL_CALL_CONVERSION_ACTION.
        ConversionReportingState = 6,
    }
    impl CallPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::PhoneNumber => "PHONE_NUMBER",
                Self::CountryCode => "COUNTRY_CODE",
                Self::Tracked => "TRACKED",
                Self::ConversionTypeId => "CONVERSION_TYPE_ID",
                Self::ConversionReportingState => "CONVERSION_REPORTING_STATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PHONE_NUMBER" => Some(Self::PhoneNumber),
                "COUNTRY_CODE" => Some(Self::CountryCode),
                "TRACKED" => Some(Self::Tracked),
                "CONVERSION_TYPE_ID" => Some(Self::ConversionTypeId),
                "CONVERSION_REPORTING_STATE" => Some(Self::ConversionReportingState),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible call tracking display locations.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CallTrackingDisplayLocationEnum {}
/// Nested message and enum types in `CallTrackingDisplayLocationEnum`.
pub mod call_tracking_display_location_enum {
    /// Possible call tracking display locations.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallTrackingDisplayLocation {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The phone call placed from the ad.
        Ad = 2,
        /// The phone call placed from the landing page ad points to.
        LandingPage = 3,
    }
    impl CallTrackingDisplayLocation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Ad => "AD",
                Self::LandingPage => "LANDING_PAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD" => Some(Self::Ad),
                "LANDING_PAGE" => Some(Self::LandingPage),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible types of property from where the call
/// was made.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CallTypeEnum {}
/// Nested message and enum types in `CallTypeEnum`.
pub mod call_type_enum {
    /// Possible types of property from where the call was made.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The phone call was manually dialed.
        ManuallyDialed = 2,
        /// The phone call was a mobile click-to-call.
        HighEndMobileSearch = 3,
    }
    impl CallType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ManuallyDialed => "MANUALLY_DIALED",
                Self::HighEndMobileSearch => "HIGH_END_MOBILE_SEARCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MANUALLY_DIALED" => Some(Self::ManuallyDialed),
                "HIGH_END_MOBILE_SEARCH" => Some(Self::HighEndMobileSearch),
                _ => None,
            }
        }
    }
}
/// Values for Callout placeholder fields.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CalloutPlaceholderFieldEnum {}
/// Nested message and enum types in `CalloutPlaceholderFieldEnum`.
pub mod callout_placeholder_field_enum {
    /// Possible values for Callout placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CalloutPlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. Callout text.
        CalloutText = 2,
    }
    impl CalloutPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CalloutText => "CALLOUT_TEXT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CALLOUT_TEXT" => Some(Self::CalloutText),
                _ => None,
            }
        }
    }
}
/// Message describing CampaignCriterion statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignCriterionStatusEnum {}
/// Nested message and enum types in `CampaignCriterionStatusEnum`.
pub mod campaign_criterion_status_enum {
    /// The possible statuses of a CampaignCriterion.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignCriterionStatus {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// The campaign criterion is enabled.
        Enabled = 2,
        /// The campaign criterion is paused.
        Paused = 3,
        /// The campaign criterion is removed.
        Removed = 4,
    }
    impl CampaignCriterionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Paused => "PAUSED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a campaign draft.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignDraftStatusEnum {}
/// Nested message and enum types in `CampaignDraftStatusEnum`.
pub mod campaign_draft_status_enum {
    /// Possible statuses of a campaign draft.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignDraftStatus {
        /// The status has not been specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Initial state of the draft, the advertiser can start adding changes with
        /// no effect on serving.
        Proposed = 2,
        /// The campaign draft is removed.
        Removed = 3,
        /// Advertiser requested to promote draft's changes back into the original
        /// campaign. Advertiser can poll the long running operation returned by
        /// the promote action to see the status of the promotion.
        Promoting = 5,
        /// The process to merge changes in the draft back to the original campaign
        /// has completed successfully.
        Promoted = 4,
        /// The promotion failed after it was partially applied. Promote cannot be
        /// attempted again safely, so the issue must be corrected in the original
        /// campaign.
        PromoteFailed = 6,
    }
    impl CampaignDraftStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Proposed => "PROPOSED",
                Self::Removed => "REMOVED",
                Self::Promoting => "PROMOTING",
                Self::Promoted => "PROMOTED",
                Self::PromoteFailed => "PROMOTE_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PROPOSED" => Some(Self::Proposed),
                "REMOVED" => Some(Self::Removed),
                "PROMOTING" => Some(Self::Promoting),
                "PROMOTED" => Some(Self::Promoted),
                "PROMOTE_FAILED" => Some(Self::PromoteFailed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing campaign experiment type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignExperimentTypeEnum {}
/// Nested message and enum types in `CampaignExperimentTypeEnum`.
pub mod campaign_experiment_type_enum {
    /// Indicates if this campaign is a normal campaign,
    /// a draft campaign, or an experiment campaign.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignExperimentType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// This is a regular campaign.
        Base = 2,
        /// This is a draft version of a campaign.
        /// It has some modifications from a base campaign,
        /// but it does not serve or accrue metrics.
        Draft = 3,
        /// This is an experiment version of a campaign.
        /// It has some modifications from a base campaign,
        /// and a percentage of traffic is being diverted
        /// from the BASE campaign to this experiment campaign.
        Experiment = 4,
    }
    impl CampaignExperimentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Base => "BASE",
                Self::Draft => "DRAFT",
                Self::Experiment => "EXPERIMENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BASE" => Some(Self::Base),
                "DRAFT" => Some(Self::Draft),
                "EXPERIMENT" => Some(Self::Experiment),
                _ => None,
            }
        }
    }
}
/// Message describing CampaignGroup statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignGroupStatusEnum {}
/// Nested message and enum types in `CampaignGroupStatusEnum`.
pub mod campaign_group_status_enum {
    /// Possible statuses of a CampaignGroup.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignGroupStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The campaign group is active.
        Enabled = 2,
        /// The campaign group has been removed.
        Removed = 3,
    }
    impl CampaignGroupStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible campaign primary status.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignPrimaryStatusEnum {}
/// Nested message and enum types in `CampaignPrimaryStatusEnum`.
pub mod campaign_primary_status_enum {
    /// Enum describing the possible campaign primary status. Provides insight into
    /// why a campaign is not serving or not serving optimally. Modification to the
    /// campaign and its related entities might take a while to be reflected in
    /// this status.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignPrimaryStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The campaign is eligible to serve.
        Eligible = 2,
        /// The user-specified campaign status is paused.
        Paused = 3,
        /// The user-specified campaign status is removed.
        Removed = 4,
        /// The user-specified time for this campaign to end has passed.
        Ended = 5,
        /// The campaign may serve in the future.
        Pending = 6,
        /// The campaign or its associated entities have incorrect user-specified
        /// settings.
        Misconfigured = 7,
        /// The campaign or its associated entities are limited by user-specified
        /// settings.
        Limited = 8,
        /// The automated bidding system is adjusting to user-specified changes to
        /// the campaign or associated entities.
        Learning = 9,
        /// The campaign is not eligible to serve.
        NotEligible = 10,
    }
    impl CampaignPrimaryStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Eligible => "ELIGIBLE",
                Self::Paused => "PAUSED",
                Self::Removed => "REMOVED",
                Self::Ended => "ENDED",
                Self::Pending => "PENDING",
                Self::Misconfigured => "MISCONFIGURED",
                Self::Limited => "LIMITED",
                Self::Learning => "LEARNING",
                Self::NotEligible => "NOT_ELIGIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ELIGIBLE" => Some(Self::Eligible),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                "ENDED" => Some(Self::Ended),
                "PENDING" => Some(Self::Pending),
                "MISCONFIGURED" => Some(Self::Misconfigured),
                "LIMITED" => Some(Self::Limited),
                "LEARNING" => Some(Self::Learning),
                "NOT_ELIGIBLE" => Some(Self::NotEligible),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible campaign primary status reasons.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignPrimaryStatusReasonEnum {}
/// Nested message and enum types in `CampaignPrimaryStatusReasonEnum`.
pub mod campaign_primary_status_reason_enum {
    /// Enum describing the possible campaign primary status reasons.  Provides
    /// insight into why a campaign is not serving or not serving optimally. These
    /// reasons are aggregated to determine an overall campaign primary status.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignPrimaryStatusReason {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The user-specified campaign status is removed.
        CampaignRemoved = 2,
        /// The user-specified campaign status is paused.
        CampaignPaused = 3,
        /// The user-specified time for this campaign to start is in the future.
        CampaignPending = 4,
        /// The user-specified time for this campaign to end has passed.
        CampaignEnded = 5,
        /// The campaign is a draft.
        CampaignDraft = 6,
        /// The bidding strategy has incorrect user-specified settings.
        BiddingStrategyMisconfigured = 7,
        /// The bidding strategy is limited by user-specified settings such as lack
        /// of data or similar.
        BiddingStrategyLimited = 8,
        /// The automated bidding system is adjusting to user-specified changes to
        /// the bidding strategy.
        BiddingStrategyLearning = 9,
        /// Campaign could capture more conversion value by adjusting CPA/ROAS
        /// targets.
        BiddingStrategyConstrained = 10,
        /// The budget is limiting the campaign's ability to serve.
        BudgetConstrained = 11,
        /// The budget has incorrect user-specified settings.
        BudgetMisconfigured = 12,
        /// Campaign is not targeting all relevant queries.
        SearchVolumeLimited = 13,
        /// The user-specified ad group statuses are all paused.
        AdGroupsPaused = 14,
        /// No eligible ad groups exist in this campaign.
        NoAdGroups = 15,
        /// The user-specified keyword statuses are all paused.
        KeywordsPaused = 16,
        /// No eligible keywords exist in this campaign.
        NoKeywords = 17,
        /// The user-specified ad group ad statuses are all paused.
        AdGroupAdsPaused = 18,
        /// No eligible ad group ads exist in this campaign.
        NoAdGroupAds = 19,
        /// At least one ad in this campaign is limited by policy.
        HasAdsLimitedByPolicy = 20,
        /// At least one ad in this campaign is disapproved.
        HasAdsDisapproved = 21,
        /// Most ads in this campaign are pending review.
        MostAdsUnderReview = 22,
        /// The campaign has a lead form goal, and the lead form extension is
        /// missing.
        MissingLeadFormExtension = 23,
        /// The campaign has a call goal, and the call extension is missing.
        MissingCallExtension = 24,
        /// The lead form extension is under review.
        LeadFormExtensionUnderReview = 25,
        /// The lead extension is disapproved.
        LeadFormExtensionDisapproved = 26,
        /// The call extension is under review.
        CallExtensionUnderReview = 27,
        /// The call extension is disapproved.
        CallExtensionDisapproved = 28,
        /// No eligible mobile application ad group criteria exist in this campaign.
        NoMobileApplicationAdGroupCriteria = 29,
        /// The user-specified campaign group status is paused.
        CampaignGroupPaused = 30,
        /// The user-specified times of all group budgets associated with the parent
        /// campaign group has passed.
        CampaignGroupAllGroupBudgetsEnded = 31,
        /// The app associated with this ACi campaign is not released in the target
        /// countries of the campaign.
        AppNotReleased = 32,
        /// The app associated with this ACi campaign is partially released in the
        /// target countries of the campaign.
        AppPartiallyReleased = 33,
        /// At least one asset group in this campaign is disapproved.
        HasAssetGroupsDisapproved = 34,
        /// At least one asset group in this campaign is limited by policy.
        HasAssetGroupsLimitedByPolicy = 35,
        /// Most asset groups in this campaign are pending review.
        MostAssetGroupsUnderReview = 36,
        /// No eligible asset groups exist in this campaign.
        NoAssetGroups = 37,
        /// All asset groups in this campaign are paused.
        AssetGroupsPaused = 38,
    }
    impl CampaignPrimaryStatusReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CampaignRemoved => "CAMPAIGN_REMOVED",
                Self::CampaignPaused => "CAMPAIGN_PAUSED",
                Self::CampaignPending => "CAMPAIGN_PENDING",
                Self::CampaignEnded => "CAMPAIGN_ENDED",
                Self::CampaignDraft => "CAMPAIGN_DRAFT",
                Self::BiddingStrategyMisconfigured => "BIDDING_STRATEGY_MISCONFIGURED",
                Self::BiddingStrategyLimited => "BIDDING_STRATEGY_LIMITED",
                Self::BiddingStrategyLearning => "BIDDING_STRATEGY_LEARNING",
                Self::BiddingStrategyConstrained => "BIDDING_STRATEGY_CONSTRAINED",
                Self::BudgetConstrained => "BUDGET_CONSTRAINED",
                Self::BudgetMisconfigured => "BUDGET_MISCONFIGURED",
                Self::SearchVolumeLimited => "SEARCH_VOLUME_LIMITED",
                Self::AdGroupsPaused => "AD_GROUPS_PAUSED",
                Self::NoAdGroups => "NO_AD_GROUPS",
                Self::KeywordsPaused => "KEYWORDS_PAUSED",
                Self::NoKeywords => "NO_KEYWORDS",
                Self::AdGroupAdsPaused => "AD_GROUP_ADS_PAUSED",
                Self::NoAdGroupAds => "NO_AD_GROUP_ADS",
                Self::HasAdsLimitedByPolicy => "HAS_ADS_LIMITED_BY_POLICY",
                Self::HasAdsDisapproved => "HAS_ADS_DISAPPROVED",
                Self::MostAdsUnderReview => "MOST_ADS_UNDER_REVIEW",
                Self::MissingLeadFormExtension => "MISSING_LEAD_FORM_EXTENSION",
                Self::MissingCallExtension => "MISSING_CALL_EXTENSION",
                Self::LeadFormExtensionUnderReview => "LEAD_FORM_EXTENSION_UNDER_REVIEW",
                Self::LeadFormExtensionDisapproved => "LEAD_FORM_EXTENSION_DISAPPROVED",
                Self::CallExtensionUnderReview => "CALL_EXTENSION_UNDER_REVIEW",
                Self::CallExtensionDisapproved => "CALL_EXTENSION_DISAPPROVED",
                Self::NoMobileApplicationAdGroupCriteria => {
                    "NO_MOBILE_APPLICATION_AD_GROUP_CRITERIA"
                }
                Self::CampaignGroupPaused => "CAMPAIGN_GROUP_PAUSED",
                Self::CampaignGroupAllGroupBudgetsEnded => {
                    "CAMPAIGN_GROUP_ALL_GROUP_BUDGETS_ENDED"
                }
                Self::AppNotReleased => "APP_NOT_RELEASED",
                Self::AppPartiallyReleased => "APP_PARTIALLY_RELEASED",
                Self::HasAssetGroupsDisapproved => "HAS_ASSET_GROUPS_DISAPPROVED",
                Self::HasAssetGroupsLimitedByPolicy => {
                    "HAS_ASSET_GROUPS_LIMITED_BY_POLICY"
                }
                Self::MostAssetGroupsUnderReview => "MOST_ASSET_GROUPS_UNDER_REVIEW",
                Self::NoAssetGroups => "NO_ASSET_GROUPS",
                Self::AssetGroupsPaused => "ASSET_GROUPS_PAUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_REMOVED" => Some(Self::CampaignRemoved),
                "CAMPAIGN_PAUSED" => Some(Self::CampaignPaused),
                "CAMPAIGN_PENDING" => Some(Self::CampaignPending),
                "CAMPAIGN_ENDED" => Some(Self::CampaignEnded),
                "CAMPAIGN_DRAFT" => Some(Self::CampaignDraft),
                "BIDDING_STRATEGY_MISCONFIGURED" => {
                    Some(Self::BiddingStrategyMisconfigured)
                }
                "BIDDING_STRATEGY_LIMITED" => Some(Self::BiddingStrategyLimited),
                "BIDDING_STRATEGY_LEARNING" => Some(Self::BiddingStrategyLearning),
                "BIDDING_STRATEGY_CONSTRAINED" => Some(Self::BiddingStrategyConstrained),
                "BUDGET_CONSTRAINED" => Some(Self::BudgetConstrained),
                "BUDGET_MISCONFIGURED" => Some(Self::BudgetMisconfigured),
                "SEARCH_VOLUME_LIMITED" => Some(Self::SearchVolumeLimited),
                "AD_GROUPS_PAUSED" => Some(Self::AdGroupsPaused),
                "NO_AD_GROUPS" => Some(Self::NoAdGroups),
                "KEYWORDS_PAUSED" => Some(Self::KeywordsPaused),
                "NO_KEYWORDS" => Some(Self::NoKeywords),
                "AD_GROUP_ADS_PAUSED" => Some(Self::AdGroupAdsPaused),
                "NO_AD_GROUP_ADS" => Some(Self::NoAdGroupAds),
                "HAS_ADS_LIMITED_BY_POLICY" => Some(Self::HasAdsLimitedByPolicy),
                "HAS_ADS_DISAPPROVED" => Some(Self::HasAdsDisapproved),
                "MOST_ADS_UNDER_REVIEW" => Some(Self::MostAdsUnderReview),
                "MISSING_LEAD_FORM_EXTENSION" => Some(Self::MissingLeadFormExtension),
                "MISSING_CALL_EXTENSION" => Some(Self::MissingCallExtension),
                "LEAD_FORM_EXTENSION_UNDER_REVIEW" => {
                    Some(Self::LeadFormExtensionUnderReview)
                }
                "LEAD_FORM_EXTENSION_DISAPPROVED" => {
                    Some(Self::LeadFormExtensionDisapproved)
                }
                "CALL_EXTENSION_UNDER_REVIEW" => Some(Self::CallExtensionUnderReview),
                "CALL_EXTENSION_DISAPPROVED" => Some(Self::CallExtensionDisapproved),
                "NO_MOBILE_APPLICATION_AD_GROUP_CRITERIA" => {
                    Some(Self::NoMobileApplicationAdGroupCriteria)
                }
                "CAMPAIGN_GROUP_PAUSED" => Some(Self::CampaignGroupPaused),
                "CAMPAIGN_GROUP_ALL_GROUP_BUDGETS_ENDED" => {
                    Some(Self::CampaignGroupAllGroupBudgetsEnded)
                }
                "APP_NOT_RELEASED" => Some(Self::AppNotReleased),
                "APP_PARTIALLY_RELEASED" => Some(Self::AppPartiallyReleased),
                "HAS_ASSET_GROUPS_DISAPPROVED" => Some(Self::HasAssetGroupsDisapproved),
                "HAS_ASSET_GROUPS_LIMITED_BY_POLICY" => {
                    Some(Self::HasAssetGroupsLimitedByPolicy)
                }
                "MOST_ASSET_GROUPS_UNDER_REVIEW" => {
                    Some(Self::MostAssetGroupsUnderReview)
                }
                "NO_ASSET_GROUPS" => Some(Self::NoAssetGroups),
                "ASSET_GROUPS_PAUSED" => Some(Self::AssetGroupsPaused),
                _ => None,
            }
        }
    }
}
/// Message describing Campaign serving statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignServingStatusEnum {}
/// Nested message and enum types in `CampaignServingStatusEnum`.
pub mod campaign_serving_status_enum {
    /// Possible serving statuses of a campaign.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignServingStatus {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// Serving.
        Serving = 2,
        /// None.
        None = 3,
        /// Ended.
        Ended = 4,
        /// Pending.
        Pending = 5,
        /// Suspended.
        Suspended = 6,
    }
    impl CampaignServingStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Serving => "SERVING",
                Self::None => "NONE",
                Self::Ended => "ENDED",
                Self::Pending => "PENDING",
                Self::Suspended => "SUSPENDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SERVING" => Some(Self::Serving),
                "NONE" => Some(Self::None),
                "ENDED" => Some(Self::Ended),
                "PENDING" => Some(Self::Pending),
                "SUSPENDED" => Some(Self::Suspended),
                _ => None,
            }
        }
    }
}
/// Container for enum describing types of campaign shared set statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignSharedSetStatusEnum {}
/// Nested message and enum types in `CampaignSharedSetStatusEnum`.
pub mod campaign_shared_set_status_enum {
    /// Enum listing the possible campaign shared set statuses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignSharedSetStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The campaign shared set is enabled.
        Enabled = 2,
        /// The campaign shared set is removed and can no longer be used.
        Removed = 3,
    }
    impl CampaignSharedSetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a campaign.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignStatusEnum {}
/// Nested message and enum types in `CampaignStatusEnum`.
pub mod campaign_status_enum {
    /// Possible statuses of a campaign.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Campaign is active and can show ads.
        Enabled = 2,
        /// Campaign has been paused by the user.
        Paused = 3,
        /// Campaign has been removed.
        Removed = 4,
    }
    impl CampaignStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Paused => "PAUSED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the sources that the change event resource
/// was made through.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeClientTypeEnum {}
/// Nested message and enum types in `ChangeClientTypeEnum`.
pub mod change_client_type_enum {
    /// The source that the change_event resource was made through.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChangeClientType {
        /// No value has been specified.
        Unspecified = 0,
        /// Used for return value only. Represents an unclassified client type
        /// unknown in this version.
        Unknown = 1,
        /// Changes made through the "ads.google.com".
        /// For example, changes made through campaign management.
        GoogleAdsWebClient = 2,
        /// Changes made through Google Ads automated rules.
        GoogleAdsAutomatedRule = 3,
        /// Changes made through Google Ads scripts.
        GoogleAdsScripts = 4,
        /// Changes made by Google Ads bulk upload.
        GoogleAdsBulkUpload = 5,
        /// Changes made by Google Ads API.
        GoogleAdsApi = 6,
        /// Changes made by Google Ads Editor. This value is a placeholder.
        /// The API does not return these changes.
        GoogleAdsEditor = 7,
        /// Changes made by Google Ads mobile app.
        GoogleAdsMobileApp = 8,
        /// Changes made through Google Ads recommendations.
        GoogleAdsRecommendations = 9,
        /// Changes made through Search Ads 360 Sync.
        SearchAds360Sync = 10,
        /// Changes made through Search Ads 360 Post.
        SearchAds360Post = 11,
        /// Changes made through internal tools.
        /// For example, when a user sets a URL template on an entity like a
        /// Campaign, it's automatically wrapped with the SA360 Clickserver URL.
        InternalTool = 12,
        /// Types of changes that are not categorized, for example,
        /// changes made by coupon redemption through Google Ads.
        Other = 13,
        /// Changes made by subscribing to Google Ads recommendations.
        GoogleAdsRecommendationsSubscription = 14,
    }
    impl ChangeClientType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::GoogleAdsWebClient => "GOOGLE_ADS_WEB_CLIENT",
                Self::GoogleAdsAutomatedRule => "GOOGLE_ADS_AUTOMATED_RULE",
                Self::GoogleAdsScripts => "GOOGLE_ADS_SCRIPTS",
                Self::GoogleAdsBulkUpload => "GOOGLE_ADS_BULK_UPLOAD",
                Self::GoogleAdsApi => "GOOGLE_ADS_API",
                Self::GoogleAdsEditor => "GOOGLE_ADS_EDITOR",
                Self::GoogleAdsMobileApp => "GOOGLE_ADS_MOBILE_APP",
                Self::GoogleAdsRecommendations => "GOOGLE_ADS_RECOMMENDATIONS",
                Self::SearchAds360Sync => "SEARCH_ADS_360_SYNC",
                Self::SearchAds360Post => "SEARCH_ADS_360_POST",
                Self::InternalTool => "INTERNAL_TOOL",
                Self::Other => "OTHER",
                Self::GoogleAdsRecommendationsSubscription => {
                    "GOOGLE_ADS_RECOMMENDATIONS_SUBSCRIPTION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "GOOGLE_ADS_WEB_CLIENT" => Some(Self::GoogleAdsWebClient),
                "GOOGLE_ADS_AUTOMATED_RULE" => Some(Self::GoogleAdsAutomatedRule),
                "GOOGLE_ADS_SCRIPTS" => Some(Self::GoogleAdsScripts),
                "GOOGLE_ADS_BULK_UPLOAD" => Some(Self::GoogleAdsBulkUpload),
                "GOOGLE_ADS_API" => Some(Self::GoogleAdsApi),
                "GOOGLE_ADS_EDITOR" => Some(Self::GoogleAdsEditor),
                "GOOGLE_ADS_MOBILE_APP" => Some(Self::GoogleAdsMobileApp),
                "GOOGLE_ADS_RECOMMENDATIONS" => Some(Self::GoogleAdsRecommendations),
                "SEARCH_ADS_360_SYNC" => Some(Self::SearchAds360Sync),
                "SEARCH_ADS_360_POST" => Some(Self::SearchAds360Post),
                "INTERNAL_TOOL" => Some(Self::InternalTool),
                "OTHER" => Some(Self::Other),
                "GOOGLE_ADS_RECOMMENDATIONS_SUBSCRIPTION" => {
                    Some(Self::GoogleAdsRecommendationsSubscription)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing supported resource types for the ChangeEvent
/// resource.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeEventResourceTypeEnum {}
/// Nested message and enum types in `ChangeEventResourceTypeEnum`.
pub mod change_event_resource_type_enum {
    /// Enum listing the resource types support by the ChangeEvent resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChangeEventResourceType {
        /// No value has been specified.
        Unspecified = 0,
        /// Used for return value only. Represents an unclassified resource unknown
        /// in this version.
        Unknown = 1,
        /// An Ad resource change.
        Ad = 2,
        /// An AdGroup resource change.
        AdGroup = 3,
        /// An AdGroupCriterion resource change.
        AdGroupCriterion = 4,
        /// A Campaign resource change.
        Campaign = 5,
        /// A CampaignBudget resource change.
        CampaignBudget = 6,
        /// An AdGroupBidModifier resource change.
        AdGroupBidModifier = 7,
        /// A CampaignCriterion resource change.
        CampaignCriterion = 8,
        /// A Feed resource change.
        Feed = 9,
        /// A FeedItem resource change.
        FeedItem = 10,
        /// A CampaignFeed resource change.
        CampaignFeed = 11,
        /// An AdGroupFeed resource change.
        AdGroupFeed = 12,
        /// An AdGroupAd resource change.
        AdGroupAd = 13,
        /// An Asset resource change.
        Asset = 14,
        /// A CustomerAsset resource change.
        CustomerAsset = 15,
        /// A CampaignAsset resource change.
        CampaignAsset = 16,
        /// An AdGroupAsset resource change.
        AdGroupAsset = 17,
        /// An AssetSet resource change.
        AssetSet = 18,
        /// An AssetSetAsset resource change.
        AssetSetAsset = 19,
        /// A CampaignAssetSet resource change.
        CampaignAssetSet = 20,
    }
    impl ChangeEventResourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Ad => "AD",
                Self::AdGroup => "AD_GROUP",
                Self::AdGroupCriterion => "AD_GROUP_CRITERION",
                Self::Campaign => "CAMPAIGN",
                Self::CampaignBudget => "CAMPAIGN_BUDGET",
                Self::AdGroupBidModifier => "AD_GROUP_BID_MODIFIER",
                Self::CampaignCriterion => "CAMPAIGN_CRITERION",
                Self::Feed => "FEED",
                Self::FeedItem => "FEED_ITEM",
                Self::CampaignFeed => "CAMPAIGN_FEED",
                Self::AdGroupFeed => "AD_GROUP_FEED",
                Self::AdGroupAd => "AD_GROUP_AD",
                Self::Asset => "ASSET",
                Self::CustomerAsset => "CUSTOMER_ASSET",
                Self::CampaignAsset => "CAMPAIGN_ASSET",
                Self::AdGroupAsset => "AD_GROUP_ASSET",
                Self::AssetSet => "ASSET_SET",
                Self::AssetSetAsset => "ASSET_SET_ASSET",
                Self::CampaignAssetSet => "CAMPAIGN_ASSET_SET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD" => Some(Self::Ad),
                "AD_GROUP" => Some(Self::AdGroup),
                "AD_GROUP_CRITERION" => Some(Self::AdGroupCriterion),
                "CAMPAIGN" => Some(Self::Campaign),
                "CAMPAIGN_BUDGET" => Some(Self::CampaignBudget),
                "AD_GROUP_BID_MODIFIER" => Some(Self::AdGroupBidModifier),
                "CAMPAIGN_CRITERION" => Some(Self::CampaignCriterion),
                "FEED" => Some(Self::Feed),
                "FEED_ITEM" => Some(Self::FeedItem),
                "CAMPAIGN_FEED" => Some(Self::CampaignFeed),
                "AD_GROUP_FEED" => Some(Self::AdGroupFeed),
                "AD_GROUP_AD" => Some(Self::AdGroupAd),
                "ASSET" => Some(Self::Asset),
                "CUSTOMER_ASSET" => Some(Self::CustomerAsset),
                "CAMPAIGN_ASSET" => Some(Self::CampaignAsset),
                "AD_GROUP_ASSET" => Some(Self::AdGroupAsset),
                "ASSET_SET" => Some(Self::AssetSet),
                "ASSET_SET_ASSET" => Some(Self::AssetSetAsset),
                "CAMPAIGN_ASSET_SET" => Some(Self::CampaignAssetSet),
                _ => None,
            }
        }
    }
}
/// Container for enum describing operations for the ChangeStatus resource.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeStatusOperationEnum {}
/// Nested message and enum types in `ChangeStatusOperationEnum`.
pub mod change_status_operation_enum {
    /// Status of the changed resource
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChangeStatusOperation {
        /// No value has been specified.
        Unspecified = 0,
        /// Used for return value only. Represents an unclassified resource unknown
        /// in this version.
        Unknown = 1,
        /// The resource was created.
        Added = 2,
        /// The resource was modified.
        Changed = 3,
        /// The resource was removed.
        Removed = 4,
    }
    impl ChangeStatusOperation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Added => "ADDED",
                Self::Changed => "CHANGED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADDED" => Some(Self::Added),
                "CHANGED" => Some(Self::Changed),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing supported resource types for the ChangeStatus
/// resource.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeStatusResourceTypeEnum {}
/// Nested message and enum types in `ChangeStatusResourceTypeEnum`.
pub mod change_status_resource_type_enum {
    /// Enum listing the resource types support by the ChangeStatus resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChangeStatusResourceType {
        /// No value has been specified.
        Unspecified = 0,
        /// Used for return value only. Represents an unclassified resource unknown
        /// in this version.
        Unknown = 1,
        /// An AdGroup resource change.
        AdGroup = 3,
        /// An AdGroupAd resource change.
        AdGroupAd = 4,
        /// An AdGroupCriterion resource change.
        AdGroupCriterion = 5,
        /// A Campaign resource change.
        Campaign = 6,
        /// A CampaignCriterion resource change.
        CampaignCriterion = 7,
        /// A Feed resource change.
        Feed = 9,
        /// A FeedItem resource change.
        FeedItem = 10,
        /// An AdGroupFeed resource change.
        AdGroupFeed = 11,
        /// A CampaignFeed resource change.
        CampaignFeed = 12,
        /// An AdGroupBidModifier resource change.
        AdGroupBidModifier = 13,
        /// A SharedSet resource change.
        SharedSet = 14,
        /// A CampaignSharedSet resource change.
        CampaignSharedSet = 15,
        /// An Asset resource change.
        Asset = 16,
        /// A CustomerAsset resource change.
        CustomerAsset = 17,
        /// A CampaignAsset resource change.
        CampaignAsset = 18,
        /// An AdGroupAsset resource change.
        AdGroupAsset = 19,
        /// A CombinedAudience resource change.
        CombinedAudience = 20,
    }
    impl ChangeStatusResourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AdGroup => "AD_GROUP",
                Self::AdGroupAd => "AD_GROUP_AD",
                Self::AdGroupCriterion => "AD_GROUP_CRITERION",
                Self::Campaign => "CAMPAIGN",
                Self::CampaignCriterion => "CAMPAIGN_CRITERION",
                Self::Feed => "FEED",
                Self::FeedItem => "FEED_ITEM",
                Self::AdGroupFeed => "AD_GROUP_FEED",
                Self::CampaignFeed => "CAMPAIGN_FEED",
                Self::AdGroupBidModifier => "AD_GROUP_BID_MODIFIER",
                Self::SharedSet => "SHARED_SET",
                Self::CampaignSharedSet => "CAMPAIGN_SHARED_SET",
                Self::Asset => "ASSET",
                Self::CustomerAsset => "CUSTOMER_ASSET",
                Self::CampaignAsset => "CAMPAIGN_ASSET",
                Self::AdGroupAsset => "AD_GROUP_ASSET",
                Self::CombinedAudience => "COMBINED_AUDIENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_GROUP" => Some(Self::AdGroup),
                "AD_GROUP_AD" => Some(Self::AdGroupAd),
                "AD_GROUP_CRITERION" => Some(Self::AdGroupCriterion),
                "CAMPAIGN" => Some(Self::Campaign),
                "CAMPAIGN_CRITERION" => Some(Self::CampaignCriterion),
                "FEED" => Some(Self::Feed),
                "FEED_ITEM" => Some(Self::FeedItem),
                "AD_GROUP_FEED" => Some(Self::AdGroupFeed),
                "CAMPAIGN_FEED" => Some(Self::CampaignFeed),
                "AD_GROUP_BID_MODIFIER" => Some(Self::AdGroupBidModifier),
                "SHARED_SET" => Some(Self::SharedSet),
                "CAMPAIGN_SHARED_SET" => Some(Self::CampaignSharedSet),
                "ASSET" => Some(Self::Asset),
                "CUSTOMER_ASSET" => Some(Self::CustomerAsset),
                "CAMPAIGN_ASSET" => Some(Self::CampaignAsset),
                "AD_GROUP_ASSET" => Some(Self::AdGroupAsset),
                "COMBINED_AUDIENCE" => Some(Self::CombinedAudience),
                _ => None,
            }
        }
    }
}
/// The status of combined audience.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CombinedAudienceStatusEnum {}
/// Nested message and enum types in `CombinedAudienceStatusEnum`.
pub mod combined_audience_status_enum {
    /// Enum containing possible combined audience status types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CombinedAudienceStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Enabled status - combined audience is enabled and can be targeted.
        Enabled = 2,
        /// Removed status - combined audience is removed and cannot be used for
        /// targeting.
        Removed = 3,
    }
    impl CombinedAudienceStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the conversion deduplication mode for
/// conversion optimizer.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionActionCountingTypeEnum {}
/// Nested message and enum types in `ConversionActionCountingTypeEnum`.
pub mod conversion_action_counting_type_enum {
    /// Indicates how conversions for this action will be counted. For more
    /// information, see <https://support.google.com/google-ads/answer/3438531.>
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionActionCountingType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Count only one conversion per click.
        OnePerClick = 2,
        /// Count all conversions per click.
        ManyPerClick = 3,
    }
    impl ConversionActionCountingType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::OnePerClick => "ONE_PER_CLICK",
                Self::ManyPerClick => "MANY_PER_CLICK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ONE_PER_CLICK" => Some(Self::OnePerClick),
                "MANY_PER_CLICK" => Some(Self::ManyPerClick),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a conversion action.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionActionStatusEnum {}
/// Nested message and enum types in `ConversionActionStatusEnum`.
pub mod conversion_action_status_enum {
    /// Possible statuses of a conversion action.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionActionStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Conversions will be recorded.
        Enabled = 2,
        /// Conversions will not be recorded.
        Removed = 3,
        /// Conversions will not be recorded and the conversion action will not
        /// appear in the UI.
        Hidden = 4,
    }
    impl ConversionActionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
                Self::Hidden => "HIDDEN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                "HIDDEN" => Some(Self::Hidden),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible types of a conversion action.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionActionTypeEnum {}
/// Nested message and enum types in `ConversionActionTypeEnum`.
pub mod conversion_action_type_enum {
    /// Possible types of a conversion action.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionActionType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Conversions that occur when a user clicks on an ad's call extension.
        AdCall = 2,
        /// Conversions that occur when a user on a mobile device clicks a phone
        /// number.
        ClickToCall = 3,
        /// Conversions that occur when a user downloads a mobile app from the Google
        /// Play Store.
        GooglePlayDownload = 4,
        /// Conversions that occur when a user makes a purchase in an app through
        /// Android billing.
        GooglePlayInAppPurchase = 5,
        /// Call conversions that are tracked by the advertiser and uploaded.
        UploadCalls = 6,
        /// Conversions that are tracked by the advertiser and uploaded with
        /// attributed clicks.
        UploadClicks = 7,
        /// Conversions that occur on a webpage.
        Webpage = 8,
        /// Conversions that occur when a user calls a dynamically-generated phone
        /// number from an advertiser's website.
        WebsiteCall = 9,
        /// Store Sales conversion based on first-party or third-party merchant
        /// data uploads.
        /// Only customers on the allowlist can use store sales direct upload types.
        StoreSalesDirectUpload = 10,
        /// Store Sales conversion based on first-party or third-party merchant
        /// data uploads and/or from in-store purchases using cards from payment
        /// networks.
        /// Only customers on the allowlist can use store sales types.
        /// Read only.
        StoreSales = 11,
        /// Android app first open conversions tracked through Firebase.
        FirebaseAndroidFirstOpen = 12,
        /// Android app in app purchase conversions tracked through Firebase.
        FirebaseAndroidInAppPurchase = 13,
        /// Android app custom conversions tracked through Firebase.
        FirebaseAndroidCustom = 14,
        /// iOS app first open conversions tracked through Firebase.
        FirebaseIosFirstOpen = 15,
        /// iOS app in app purchase conversions tracked through Firebase.
        FirebaseIosInAppPurchase = 16,
        /// iOS app custom conversions tracked through Firebase.
        FirebaseIosCustom = 17,
        /// Android app first open conversions tracked through Third Party App
        /// Analytics.
        ThirdPartyAppAnalyticsAndroidFirstOpen = 18,
        /// Android app in app purchase conversions tracked through Third Party App
        /// Analytics.
        ThirdPartyAppAnalyticsAndroidInAppPurchase = 19,
        /// Android app custom conversions tracked through Third Party App Analytics.
        ThirdPartyAppAnalyticsAndroidCustom = 20,
        /// iOS app first open conversions tracked through Third Party App Analytics.
        ThirdPartyAppAnalyticsIosFirstOpen = 21,
        /// iOS app in app purchase conversions tracked through Third Party App
        /// Analytics.
        ThirdPartyAppAnalyticsIosInAppPurchase = 22,
        /// iOS app custom conversions tracked through Third Party App Analytics.
        ThirdPartyAppAnalyticsIosCustom = 23,
        /// Conversions that occur when a user pre-registers a mobile app from the
        /// Google Play Store. Read only.
        AndroidAppPreRegistration = 24,
        /// Conversions that track all Google Play downloads which aren't tracked
        /// by an app-specific type. Read only.
        AndroidInstallsAllOtherApps = 25,
        /// Floodlight activity that counts the number of times that users have
        /// visited a particular webpage after seeing or clicking on one of
        /// an advertiser's ads. Read only.
        FloodlightAction = 26,
        /// Floodlight activity that tracks the number of sales made or the number
        /// of items purchased. Can also capture the total value of each sale.
        /// Read only.
        FloodlightTransaction = 27,
        /// Conversions that track local actions from Google's products and
        /// services after interacting with an ad. Read only.
        GoogleHosted = 28,
        /// Conversions reported when a user submits a lead form. Read only.
        LeadFormSubmit = 29,
        /// Conversions that come from Salesforce. Read only.
        Salesforce = 30,
        /// Conversions imported from Search Ads 360 Floodlight data. Read only.
        SearchAds360 = 31,
        /// Call conversions that occur on Smart campaign Ads without call tracking
        /// setup, using Smart campaign custom criteria. Read only.
        SmartCampaignAdClicksToCall = 32,
        /// The user clicks on a call element within Google Maps. Smart campaign
        /// only. Read only.
        SmartCampaignMapClicksToCall = 33,
        /// The user requests directions to a business location within Google Maps.
        /// Smart campaign only. Read only.
        SmartCampaignMapDirections = 34,
        /// Call conversions that occur on Smart campaign Ads with call tracking
        /// setup, using Smart campaign custom criteria. Read only.
        SmartCampaignTrackedCalls = 35,
        /// Conversions that occur when a user visits an advertiser's retail store.
        /// Read only.
        StoreVisits = 36,
        /// Conversions created from website events (such as form submissions or page
        /// loads), that don't use individually coded event snippets. Read only.
        WebpageCodeless = 37,
        /// Conversions that come from linked Universal Analytics goals.
        UniversalAnalyticsGoal = 38,
        /// Conversions that come from linked Universal Analytics transactions.
        UniversalAnalyticsTransaction = 39,
        /// Conversions that come from linked Google Analytics 4 custom event
        /// conversions.
        GoogleAnalytics4Custom = 40,
        /// Conversions that come from linked Google Analytics 4 purchase
        /// conversions.
        GoogleAnalytics4Purchase = 41,
    }
    impl ConversionActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AdCall => "AD_CALL",
                Self::ClickToCall => "CLICK_TO_CALL",
                Self::GooglePlayDownload => "GOOGLE_PLAY_DOWNLOAD",
                Self::GooglePlayInAppPurchase => "GOOGLE_PLAY_IN_APP_PURCHASE",
                Self::UploadCalls => "UPLOAD_CALLS",
                Self::UploadClicks => "UPLOAD_CLICKS",
                Self::Webpage => "WEBPAGE",
                Self::WebsiteCall => "WEBSITE_CALL",
                Self::StoreSalesDirectUpload => "STORE_SALES_DIRECT_UPLOAD",
                Self::StoreSales => "STORE_SALES",
                Self::FirebaseAndroidFirstOpen => "FIREBASE_ANDROID_FIRST_OPEN",
                Self::FirebaseAndroidInAppPurchase => "FIREBASE_ANDROID_IN_APP_PURCHASE",
                Self::FirebaseAndroidCustom => "FIREBASE_ANDROID_CUSTOM",
                Self::FirebaseIosFirstOpen => "FIREBASE_IOS_FIRST_OPEN",
                Self::FirebaseIosInAppPurchase => "FIREBASE_IOS_IN_APP_PURCHASE",
                Self::FirebaseIosCustom => "FIREBASE_IOS_CUSTOM",
                Self::ThirdPartyAppAnalyticsAndroidFirstOpen => {
                    "THIRD_PARTY_APP_ANALYTICS_ANDROID_FIRST_OPEN"
                }
                Self::ThirdPartyAppAnalyticsAndroidInAppPurchase => {
                    "THIRD_PARTY_APP_ANALYTICS_ANDROID_IN_APP_PURCHASE"
                }
                Self::ThirdPartyAppAnalyticsAndroidCustom => {
                    "THIRD_PARTY_APP_ANALYTICS_ANDROID_CUSTOM"
                }
                Self::ThirdPartyAppAnalyticsIosFirstOpen => {
                    "THIRD_PARTY_APP_ANALYTICS_IOS_FIRST_OPEN"
                }
                Self::ThirdPartyAppAnalyticsIosInAppPurchase => {
                    "THIRD_PARTY_APP_ANALYTICS_IOS_IN_APP_PURCHASE"
                }
                Self::ThirdPartyAppAnalyticsIosCustom => {
                    "THIRD_PARTY_APP_ANALYTICS_IOS_CUSTOM"
                }
                Self::AndroidAppPreRegistration => "ANDROID_APP_PRE_REGISTRATION",
                Self::AndroidInstallsAllOtherApps => "ANDROID_INSTALLS_ALL_OTHER_APPS",
                Self::FloodlightAction => "FLOODLIGHT_ACTION",
                Self::FloodlightTransaction => "FLOODLIGHT_TRANSACTION",
                Self::GoogleHosted => "GOOGLE_HOSTED",
                Self::LeadFormSubmit => "LEAD_FORM_SUBMIT",
                Self::Salesforce => "SALESFORCE",
                Self::SearchAds360 => "SEARCH_ADS_360",
                Self::SmartCampaignAdClicksToCall => "SMART_CAMPAIGN_AD_CLICKS_TO_CALL",
                Self::SmartCampaignMapClicksToCall => "SMART_CAMPAIGN_MAP_CLICKS_TO_CALL",
                Self::SmartCampaignMapDirections => "SMART_CAMPAIGN_MAP_DIRECTIONS",
                Self::SmartCampaignTrackedCalls => "SMART_CAMPAIGN_TRACKED_CALLS",
                Self::StoreVisits => "STORE_VISITS",
                Self::WebpageCodeless => "WEBPAGE_CODELESS",
                Self::UniversalAnalyticsGoal => "UNIVERSAL_ANALYTICS_GOAL",
                Self::UniversalAnalyticsTransaction => "UNIVERSAL_ANALYTICS_TRANSACTION",
                Self::GoogleAnalytics4Custom => "GOOGLE_ANALYTICS_4_CUSTOM",
                Self::GoogleAnalytics4Purchase => "GOOGLE_ANALYTICS_4_PURCHASE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_CALL" => Some(Self::AdCall),
                "CLICK_TO_CALL" => Some(Self::ClickToCall),
                "GOOGLE_PLAY_DOWNLOAD" => Some(Self::GooglePlayDownload),
                "GOOGLE_PLAY_IN_APP_PURCHASE" => Some(Self::GooglePlayInAppPurchase),
                "UPLOAD_CALLS" => Some(Self::UploadCalls),
                "UPLOAD_CLICKS" => Some(Self::UploadClicks),
                "WEBPAGE" => Some(Self::Webpage),
                "WEBSITE_CALL" => Some(Self::WebsiteCall),
                "STORE_SALES_DIRECT_UPLOAD" => Some(Self::StoreSalesDirectUpload),
                "STORE_SALES" => Some(Self::StoreSales),
                "FIREBASE_ANDROID_FIRST_OPEN" => Some(Self::FirebaseAndroidFirstOpen),
                "FIREBASE_ANDROID_IN_APP_PURCHASE" => {
                    Some(Self::FirebaseAndroidInAppPurchase)
                }
                "FIREBASE_ANDROID_CUSTOM" => Some(Self::FirebaseAndroidCustom),
                "FIREBASE_IOS_FIRST_OPEN" => Some(Self::FirebaseIosFirstOpen),
                "FIREBASE_IOS_IN_APP_PURCHASE" => Some(Self::FirebaseIosInAppPurchase),
                "FIREBASE_IOS_CUSTOM" => Some(Self::FirebaseIosCustom),
                "THIRD_PARTY_APP_ANALYTICS_ANDROID_FIRST_OPEN" => {
                    Some(Self::ThirdPartyAppAnalyticsAndroidFirstOpen)
                }
                "THIRD_PARTY_APP_ANALYTICS_ANDROID_IN_APP_PURCHASE" => {
                    Some(Self::ThirdPartyAppAnalyticsAndroidInAppPurchase)
                }
                "THIRD_PARTY_APP_ANALYTICS_ANDROID_CUSTOM" => {
                    Some(Self::ThirdPartyAppAnalyticsAndroidCustom)
                }
                "THIRD_PARTY_APP_ANALYTICS_IOS_FIRST_OPEN" => {
                    Some(Self::ThirdPartyAppAnalyticsIosFirstOpen)
                }
                "THIRD_PARTY_APP_ANALYTICS_IOS_IN_APP_PURCHASE" => {
                    Some(Self::ThirdPartyAppAnalyticsIosInAppPurchase)
                }
                "THIRD_PARTY_APP_ANALYTICS_IOS_CUSTOM" => {
                    Some(Self::ThirdPartyAppAnalyticsIosCustom)
                }
                "ANDROID_APP_PRE_REGISTRATION" => Some(Self::AndroidAppPreRegistration),
                "ANDROID_INSTALLS_ALL_OTHER_APPS" => {
                    Some(Self::AndroidInstallsAllOtherApps)
                }
                "FLOODLIGHT_ACTION" => Some(Self::FloodlightAction),
                "FLOODLIGHT_TRANSACTION" => Some(Self::FloodlightTransaction),
                "GOOGLE_HOSTED" => Some(Self::GoogleHosted),
                "LEAD_FORM_SUBMIT" => Some(Self::LeadFormSubmit),
                "SALESFORCE" => Some(Self::Salesforce),
                "SEARCH_ADS_360" => Some(Self::SearchAds360),
                "SMART_CAMPAIGN_AD_CLICKS_TO_CALL" => {
                    Some(Self::SmartCampaignAdClicksToCall)
                }
                "SMART_CAMPAIGN_MAP_CLICKS_TO_CALL" => {
                    Some(Self::SmartCampaignMapClicksToCall)
                }
                "SMART_CAMPAIGN_MAP_DIRECTIONS" => Some(Self::SmartCampaignMapDirections),
                "SMART_CAMPAIGN_TRACKED_CALLS" => Some(Self::SmartCampaignTrackedCalls),
                "STORE_VISITS" => Some(Self::StoreVisits),
                "WEBPAGE_CODELESS" => Some(Self::WebpageCodeless),
                "UNIVERSAL_ANALYTICS_GOAL" => Some(Self::UniversalAnalyticsGoal),
                "UNIVERSAL_ANALYTICS_TRANSACTION" => {
                    Some(Self::UniversalAnalyticsTransaction)
                }
                "GOOGLE_ANALYTICS_4_CUSTOM" => Some(Self::GoogleAnalytics4Custom),
                "GOOGLE_ANALYTICS_4_PURCHASE" => Some(Self::GoogleAnalytics4Purchase),
                _ => None,
            }
        }
    }
}
/// Container for enum describing conversion adjustment types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionAdjustmentTypeEnum {}
/// Nested message and enum types in `ConversionAdjustmentTypeEnum`.
pub mod conversion_adjustment_type_enum {
    /// The different actions advertisers can take to adjust the conversions that
    /// they already reported. Retractions negate a conversion. Restatements change
    /// the value of a conversion.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionAdjustmentType {
        /// Not specified.
        Unspecified = 0,
        /// Represents value unknown in this version.
        Unknown = 1,
        /// Negates a conversion so that its total value and count are both zero.
        Retraction = 2,
        /// Changes the value of a conversion.
        Restatement = 3,
        /// Supplements an existing conversion with provided user identifiers and
        /// user agent, which can be used by Google to enhance the conversion count.
        Enhancement = 4,
    }
    impl ConversionAdjustmentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Retraction => "RETRACTION",
                Self::Restatement => "RESTATEMENT",
                Self::Enhancement => "ENHANCEMENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RETRACTION" => Some(Self::Retraction),
                "RESTATEMENT" => Some(Self::Restatement),
                "ENHANCEMENT" => Some(Self::Enhancement),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a conversion custom
/// variable.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionCustomVariableStatusEnum {}
/// Nested message and enum types in `ConversionCustomVariableStatusEnum`.
pub mod conversion_custom_variable_status_enum {
    /// Possible statuses of a conversion custom variable.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionCustomVariableStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The conversion custom variable is pending activation and will not
        /// accrue stats until set to ENABLED.
        ///
        /// This status can't be used in CREATE and UPDATE requests.
        ActivationNeeded = 2,
        /// The conversion custom variable is enabled and will accrue stats.
        Enabled = 3,
        /// The conversion custom variable is paused and will not accrue stats
        /// until set to ENABLED again.
        Paused = 4,
    }
    impl ConversionCustomVariableStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ActivationNeeded => "ACTIVATION_NEEDED",
                Self::Enabled => "ENABLED",
                Self::Paused => "PAUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACTIVATION_NEEDED" => Some(Self::ActivationNeeded),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                _ => None,
            }
        }
    }
}
/// Container for enum representing the conversion environment an uploaded
/// conversion was recorded on, for example, App or Web.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionEnvironmentEnum {}
/// Nested message and enum types in `ConversionEnvironmentEnum`.
pub mod conversion_environment_enum {
    /// Conversion environment of the uploaded conversion.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionEnvironment {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The conversion was recorded on an app.
        App = 2,
        /// The conversion was recorded on a website.
        Web = 3,
    }
    impl ConversionEnvironment {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::App => "APP",
                Self::Web => "WEB",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APP" => Some(Self::App),
                "WEB" => Some(Self::Web),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible conversion origins.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionOriginEnum {}
/// Nested message and enum types in `ConversionOriginEnum`.
pub mod conversion_origin_enum {
    /// The possible places where a conversion can occur.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionOrigin {
        /// The conversion origin has not been specified.
        Unspecified = 0,
        /// The conversion origin is not known in this version.
        Unknown = 1,
        /// Conversion that occurs when a user visits a website or takes an action
        /// there after viewing an ad.
        Website = 2,
        /// Conversions reported by an offline pipeline which collects local actions
        /// from Google-hosted pages (for example, Google Maps, Google Place Page,
        /// etc) and attributes them to relevant ad events.
        GoogleHosted = 3,
        /// Conversion that occurs when a user performs an action through any app
        /// platforms.
        App = 4,
        /// Conversion that occurs when a user makes a call from ads.
        CallFromAds = 5,
        /// Conversion that occurs when a user visits or makes a purchase at a
        /// physical store.
        Store = 6,
        /// Conversion that occurs on YouTube.
        YoutubeHosted = 7,
    }
    impl ConversionOrigin {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Website => "WEBSITE",
                Self::GoogleHosted => "GOOGLE_HOSTED",
                Self::App => "APP",
                Self::CallFromAds => "CALL_FROM_ADS",
                Self::Store => "STORE",
                Self::YoutubeHosted => "YOUTUBE_HOSTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "WEBSITE" => Some(Self::Website),
                "GOOGLE_HOSTED" => Some(Self::GoogleHosted),
                "APP" => Some(Self::App),
                "CALL_FROM_ADS" => Some(Self::CallFromAds),
                "STORE" => Some(Self::Store),
                "YOUTUBE_HOSTED" => Some(Self::YoutubeHosted),
                _ => None,
            }
        }
    }
}
/// Container for enum representing the conversion tracking status of the
/// customer.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionTrackingStatusEnum {}
/// Nested message and enum types in `ConversionTrackingStatusEnum`.
pub mod conversion_tracking_status_enum {
    /// Conversion Tracking status of the customer.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionTrackingStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Customer does not use any conversion tracking.
        NotConversionTracked = 2,
        /// The conversion actions are created and managed by this customer.
        ConversionTrackingManagedBySelf = 3,
        /// The conversion actions are created and managed by the manager specified
        /// in the request's `login-customer-id`.
        ConversionTrackingManagedByThisManager = 4,
        /// The conversion actions are created and managed by a manager different
        /// from the customer or manager specified in the request's
        /// `login-customer-id`.
        ConversionTrackingManagedByAnotherManager = 5,
    }
    impl ConversionTrackingStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NotConversionTracked => "NOT_CONVERSION_TRACKED",
                Self::ConversionTrackingManagedBySelf => {
                    "CONVERSION_TRACKING_MANAGED_BY_SELF"
                }
                Self::ConversionTrackingManagedByThisManager => {
                    "CONVERSION_TRACKING_MANAGED_BY_THIS_MANAGER"
                }
                Self::ConversionTrackingManagedByAnotherManager => {
                    "CONVERSION_TRACKING_MANAGED_BY_ANOTHER_MANAGER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOT_CONVERSION_TRACKED" => Some(Self::NotConversionTracked),
                "CONVERSION_TRACKING_MANAGED_BY_SELF" => {
                    Some(Self::ConversionTrackingManagedBySelf)
                }
                "CONVERSION_TRACKING_MANAGED_BY_THIS_MANAGER" => {
                    Some(Self::ConversionTrackingManagedByThisManager)
                }
                "CONVERSION_TRACKING_MANAGED_BY_ANOTHER_MANAGER" => {
                    Some(Self::ConversionTrackingManagedByAnotherManager)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a conversion value rule
/// set.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionValueRuleSetStatusEnum {}
/// Nested message and enum types in `ConversionValueRuleSetStatusEnum`.
pub mod conversion_value_rule_set_status_enum {
    /// Possible statuses of a conversion value rule set.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionValueRuleSetStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Conversion Value Rule Set is enabled and can be applied.
        Enabled = 2,
        /// Conversion Value Rule Set is permanently deleted and can't be applied.
        Removed = 3,
        /// Conversion Value Rule Set is paused and won't be applied. It can be
        /// enabled again.
        Paused = 4,
    }
    impl ConversionValueRuleSetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
                Self::Paused => "PAUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                "PAUSED" => Some(Self::Paused),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a conversion value rule.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionValueRuleStatusEnum {}
/// Nested message and enum types in `ConversionValueRuleStatusEnum`.
pub mod conversion_value_rule_status_enum {
    /// Possible statuses of a conversion value rule.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionValueRuleStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Conversion Value Rule is enabled and can be applied.
        Enabled = 2,
        /// Conversion Value Rule is permanently deleted and can't be applied.
        Removed = 3,
        /// Conversion Value Rule is paused, but can be re-enabled.
        Paused = 4,
    }
    impl ConversionValueRuleStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
                Self::Paused => "PAUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                "PAUSED" => Some(Self::Paused),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible criterion system serving statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CriterionSystemServingStatusEnum {}
/// Nested message and enum types in `CriterionSystemServingStatusEnum`.
pub mod criterion_system_serving_status_enum {
    /// Enumerates criterion system serving statuses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CriterionSystemServingStatus {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Eligible.
        Eligible = 2,
        /// Low search volume.
        RarelyServed = 3,
    }
    impl CriterionSystemServingStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Eligible => "ELIGIBLE",
                Self::RarelyServed => "RARELY_SERVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ELIGIBLE" => Some(Self::Eligible),
                "RARELY_SERVED" => Some(Self::RarelyServed),
                _ => None,
            }
        }
    }
}
/// The possible types of a criterion.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CriterionTypeEnum {}
/// Nested message and enum types in `CriterionTypeEnum`.
pub mod criterion_type_enum {
    /// Enum describing possible criterion types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CriterionType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Keyword, for example, 'mars cruise'.
        Keyword = 2,
        /// Placement, also known as Website, for example, 'www.flowers4sale.com'
        Placement = 3,
        /// Mobile application categories to target.
        MobileAppCategory = 4,
        /// Mobile applications to target.
        MobileApplication = 5,
        /// Devices to target.
        Device = 6,
        /// Locations to target.
        Location = 7,
        /// Listing groups to target.
        ListingGroup = 8,
        /// Ad Schedule.
        AdSchedule = 9,
        /// Age range.
        AgeRange = 10,
        /// Gender.
        Gender = 11,
        /// Income Range.
        IncomeRange = 12,
        /// Parental status.
        ParentalStatus = 13,
        /// YouTube Video.
        YoutubeVideo = 14,
        /// YouTube Channel.
        YoutubeChannel = 15,
        /// User list.
        UserList = 16,
        /// Proximity.
        Proximity = 17,
        /// A topic target on the display network (for example, "Pets & Animals").
        Topic = 18,
        /// Listing scope to target.
        ListingScope = 19,
        /// Language.
        Language = 20,
        /// IpBlock.
        IpBlock = 21,
        /// Content Label for category exclusion.
        ContentLabel = 22,
        /// Carrier.
        Carrier = 23,
        /// A category the user is interested in.
        UserInterest = 24,
        /// Webpage criterion for dynamic search ads.
        Webpage = 25,
        /// Operating system version.
        OperatingSystemVersion = 26,
        /// App payment model.
        AppPaymentModel = 27,
        /// Mobile device.
        MobileDevice = 28,
        /// Custom affinity.
        CustomAffinity = 29,
        /// Custom intent.
        CustomIntent = 30,
        /// Location group.
        LocationGroup = 31,
        /// Custom audience
        CustomAudience = 32,
        /// Combined audience
        CombinedAudience = 33,
        /// Smart Campaign keyword theme
        KeywordTheme = 34,
        /// Audience
        Audience = 35,
        /// Negative Keyword List
        NegativeKeywordList = 36,
        /// Local Services Ads Service ID.
        LocalServiceId = 37,
        /// Search Theme.
        SearchTheme = 38,
        /// Brand
        Brand = 39,
        /// Brand List
        BrandList = 40,
        /// Life Event
        LifeEvent = 41,
    }
    impl CriterionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Keyword => "KEYWORD",
                Self::Placement => "PLACEMENT",
                Self::MobileAppCategory => "MOBILE_APP_CATEGORY",
                Self::MobileApplication => "MOBILE_APPLICATION",
                Self::Device => "DEVICE",
                Self::Location => "LOCATION",
                Self::ListingGroup => "LISTING_GROUP",
                Self::AdSchedule => "AD_SCHEDULE",
                Self::AgeRange => "AGE_RANGE",
                Self::Gender => "GENDER",
                Self::IncomeRange => "INCOME_RANGE",
                Self::ParentalStatus => "PARENTAL_STATUS",
                Self::YoutubeVideo => "YOUTUBE_VIDEO",
                Self::YoutubeChannel => "YOUTUBE_CHANNEL",
                Self::UserList => "USER_LIST",
                Self::Proximity => "PROXIMITY",
                Self::Topic => "TOPIC",
                Self::ListingScope => "LISTING_SCOPE",
                Self::Language => "LANGUAGE",
                Self::IpBlock => "IP_BLOCK",
                Self::ContentLabel => "CONTENT_LABEL",
                Self::Carrier => "CARRIER",
                Self::UserInterest => "USER_INTEREST",
                Self::Webpage => "WEBPAGE",
                Self::OperatingSystemVersion => "OPERATING_SYSTEM_VERSION",
                Self::AppPaymentModel => "APP_PAYMENT_MODEL",
                Self::MobileDevice => "MOBILE_DEVICE",
                Self::CustomAffinity => "CUSTOM_AFFINITY",
                Self::CustomIntent => "CUSTOM_INTENT",
                Self::LocationGroup => "LOCATION_GROUP",
                Self::CustomAudience => "CUSTOM_AUDIENCE",
                Self::CombinedAudience => "COMBINED_AUDIENCE",
                Self::KeywordTheme => "KEYWORD_THEME",
                Self::Audience => "AUDIENCE",
                Self::NegativeKeywordList => "NEGATIVE_KEYWORD_LIST",
                Self::LocalServiceId => "LOCAL_SERVICE_ID",
                Self::SearchTheme => "SEARCH_THEME",
                Self::Brand => "BRAND",
                Self::BrandList => "BRAND_LIST",
                Self::LifeEvent => "LIFE_EVENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "KEYWORD" => Some(Self::Keyword),
                "PLACEMENT" => Some(Self::Placement),
                "MOBILE_APP_CATEGORY" => Some(Self::MobileAppCategory),
                "MOBILE_APPLICATION" => Some(Self::MobileApplication),
                "DEVICE" => Some(Self::Device),
                "LOCATION" => Some(Self::Location),
                "LISTING_GROUP" => Some(Self::ListingGroup),
                "AD_SCHEDULE" => Some(Self::AdSchedule),
                "AGE_RANGE" => Some(Self::AgeRange),
                "GENDER" => Some(Self::Gender),
                "INCOME_RANGE" => Some(Self::IncomeRange),
                "PARENTAL_STATUS" => Some(Self::ParentalStatus),
                "YOUTUBE_VIDEO" => Some(Self::YoutubeVideo),
                "YOUTUBE_CHANNEL" => Some(Self::YoutubeChannel),
                "USER_LIST" => Some(Self::UserList),
                "PROXIMITY" => Some(Self::Proximity),
                "TOPIC" => Some(Self::Topic),
                "LISTING_SCOPE" => Some(Self::ListingScope),
                "LANGUAGE" => Some(Self::Language),
                "IP_BLOCK" => Some(Self::IpBlock),
                "CONTENT_LABEL" => Some(Self::ContentLabel),
                "CARRIER" => Some(Self::Carrier),
                "USER_INTEREST" => Some(Self::UserInterest),
                "WEBPAGE" => Some(Self::Webpage),
                "OPERATING_SYSTEM_VERSION" => Some(Self::OperatingSystemVersion),
                "APP_PAYMENT_MODEL" => Some(Self::AppPaymentModel),
                "MOBILE_DEVICE" => Some(Self::MobileDevice),
                "CUSTOM_AFFINITY" => Some(Self::CustomAffinity),
                "CUSTOM_INTENT" => Some(Self::CustomIntent),
                "LOCATION_GROUP" => Some(Self::LocationGroup),
                "CUSTOM_AUDIENCE" => Some(Self::CustomAudience),
                "COMBINED_AUDIENCE" => Some(Self::CombinedAudience),
                "KEYWORD_THEME" => Some(Self::KeywordTheme),
                "AUDIENCE" => Some(Self::Audience),
                "NEGATIVE_KEYWORD_LIST" => Some(Self::NegativeKeywordList),
                "LOCAL_SERVICE_ID" => Some(Self::LocalServiceId),
                "SEARCH_THEME" => Some(Self::SearchTheme),
                "BRAND" => Some(Self::Brand),
                "BRAND_LIST" => Some(Self::BrandList),
                "LIFE_EVENT" => Some(Self::LifeEvent),
                _ => None,
            }
        }
    }
}
/// The type of custom audience member.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomAudienceMemberTypeEnum {}
/// Nested message and enum types in `CustomAudienceMemberTypeEnum`.
pub mod custom_audience_member_type_enum {
    /// Enum containing possible custom audience member types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomAudienceMemberType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Users whose interests or actions are described by a keyword.
        Keyword = 2,
        /// Users who have interests related to the website's content.
        Url = 3,
        /// Users who visit place types described by a place category.
        PlaceCategory = 4,
        /// Users who have installed a mobile app.
        App = 5,
    }
    impl CustomAudienceMemberType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Keyword => "KEYWORD",
                Self::Url => "URL",
                Self::PlaceCategory => "PLACE_CATEGORY",
                Self::App => "APP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "KEYWORD" => Some(Self::Keyword),
                "URL" => Some(Self::Url),
                "PLACE_CATEGORY" => Some(Self::PlaceCategory),
                "APP" => Some(Self::App),
                _ => None,
            }
        }
    }
}
/// The status of custom audience.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomAudienceStatusEnum {}
/// Nested message and enum types in `CustomAudienceStatusEnum`.
pub mod custom_audience_status_enum {
    /// Enum containing possible custom audience statuses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomAudienceStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Enabled status - custom audience is enabled and can be targeted.
        Enabled = 2,
        /// Removed status - custom audience is removed and cannot be used for
        /// targeting.
        Removed = 3,
    }
    impl CustomAudienceStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// The types of custom audience.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomAudienceTypeEnum {}
/// Nested message and enum types in `CustomAudienceTypeEnum`.
pub mod custom_audience_type_enum {
    /// Enum containing possible custom audience types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomAudienceType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Google Ads will auto-select the best interpretation at serving
        /// time.
        Auto = 2,
        /// Matches users by their interests.
        Interest = 3,
        /// Matches users by topics they are researching or products they are
        /// considering for purchase.
        PurchaseIntent = 4,
        /// Matches users by what they searched on Google Search.
        Search = 5,
    }
    impl CustomAudienceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Auto => "AUTO",
                Self::Interest => "INTEREST",
                Self::PurchaseIntent => "PURCHASE_INTENT",
                Self::Search => "SEARCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AUTO" => Some(Self::Auto),
                "INTEREST" => Some(Self::Interest),
                "PURCHASE_INTENT" => Some(Self::PurchaseIntent),
                "SEARCH" => Some(Self::Search),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a custom conversion goal.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomConversionGoalStatusEnum {}
/// Nested message and enum types in `CustomConversionGoalStatusEnum`.
pub mod custom_conversion_goal_status_enum {
    /// The possible statuses of a custom conversion goal.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomConversionGoalStatus {
        /// The status has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        Unknown = 1,
        /// The custom conversion goal is enabled.
        Enabled = 2,
        /// The custom conversion goal is removed.
        Removed = 3,
    }
    impl CustomConversionGoalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// The types of custom interest member, either KEYWORD or URL.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomInterestMemberTypeEnum {}
/// Nested message and enum types in `CustomInterestMemberTypeEnum`.
pub mod custom_interest_member_type_enum {
    /// Enum containing possible custom interest member types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomInterestMemberType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Custom interest member type KEYWORD.
        Keyword = 2,
        /// Custom interest member type URL.
        Url = 3,
    }
    impl CustomInterestMemberType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Keyword => "KEYWORD",
                Self::Url => "URL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "KEYWORD" => Some(Self::Keyword),
                "URL" => Some(Self::Url),
                _ => None,
            }
        }
    }
}
/// The status of custom interest.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomInterestStatusEnum {}
/// Nested message and enum types in `CustomInterestStatusEnum`.
pub mod custom_interest_status_enum {
    /// Enum containing possible custom interest types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomInterestStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Enabled status - custom interest is enabled and can be targeted to.
        Enabled = 2,
        /// Removed status - custom interest is removed and cannot be used for
        /// targeting.
        Removed = 3,
    }
    impl CustomInterestStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// The types of custom interest.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomInterestTypeEnum {}
/// Nested message and enum types in `CustomInterestTypeEnum`.
pub mod custom_interest_type_enum {
    /// Enum containing possible custom interest types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomInterestType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Allows brand advertisers to define custom affinity audience lists.
        CustomAffinity = 2,
        /// Allows advertisers to define custom intent audience lists.
        CustomIntent = 3,
    }
    impl CustomInterestType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CustomAffinity => "CUSTOM_AFFINITY",
                Self::CustomIntent => "CUSTOM_INTENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOM_AFFINITY" => Some(Self::CustomAffinity),
                "CUSTOM_INTENT" => Some(Self::CustomIntent),
                _ => None,
            }
        }
    }
}
/// Values for Custom placeholder fields.
/// For more information about dynamic remarketing feeds, see
/// <https://support.google.com/google-ads/answer/6053288.>
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomPlaceholderFieldEnum {}
/// Nested message and enum types in `CustomPlaceholderFieldEnum`.
pub mod custom_placeholder_field_enum {
    /// Possible values for Custom placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomPlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. Required. Combination ID and ID2 must be unique per
        /// offer.
        Id = 2,
        /// Data Type: STRING. Combination ID and ID2 must be unique per offer.
        Id2 = 3,
        /// Data Type: STRING. Required. Main headline with product name to be shown
        /// in dynamic ad.
        ItemTitle = 4,
        /// Data Type: STRING. Optional text to be shown in the image ad.
        ItemSubtitle = 5,
        /// Data Type: STRING. Optional description of the product to be shown in the
        /// ad.
        ItemDescription = 6,
        /// Data Type: STRING. Full address of your offer or service, including
        /// postal code. This will be used to identify the closest product to the
        /// user when there are multiple offers in the feed that are relevant to the
        /// user.
        ItemAddress = 7,
        /// Data Type: STRING. Price to be shown in the ad.
        /// Example: "100.00 USD"
        Price = 8,
        /// Data Type: STRING. Formatted price to be shown in the ad.
        /// Example: "Starting at $100.00 USD", "$80 - $100"
        FormattedPrice = 9,
        /// Data Type: STRING. Sale price to be shown in the ad.
        /// Example: "80.00 USD"
        SalePrice = 10,
        /// Data Type: STRING. Formatted sale price to be shown in the ad.
        /// Example: "On sale for $80.00", "$60 - $80"
        FormattedSalePrice = 11,
        /// Data Type: URL. Image to be displayed in the ad. Highly recommended for
        /// image ads.
        ImageUrl = 12,
        /// Data Type: STRING. Used as a recommendation engine signal to serve items
        /// in the same category.
        ItemCategory = 13,
        /// Data Type: URL_LIST. Final URLs for the ad when using Upgraded
        /// URLs. User will be redirected to these URLs when they click on an ad, or
        /// when they click on a specific product for ads that have multiple
        /// products.
        FinalUrls = 14,
        /// Data Type: URL_LIST. Final mobile URLs for the ad when using Upgraded
        /// URLs.
        FinalMobileUrls = 15,
        /// Data Type: URL. Tracking template for the ad when using Upgraded URLs.
        TrackingUrl = 16,
        /// Data Type: STRING_LIST. Keywords used for product retrieval.
        ContextualKeywords = 17,
        /// Data Type: STRING. Android app link. Must be formatted as:
        /// android-app://{package_id}/{scheme}/{host_path}.
        /// The components are defined as follows:
        /// package_id: app ID as specified in Google Play.
        /// scheme: the scheme to pass to the application. Can be HTTP, or a custom
        ///    scheme.
        /// host_path: identifies the specific content within your application.
        AndroidAppLink = 18,
        /// Data Type: STRING_LIST. List of recommended IDs to show together with
        /// this item.
        SimilarIds = 19,
        /// Data Type: STRING. iOS app link.
        IosAppLink = 20,
        /// Data Type: INT64. iOS app store ID.
        IosAppStoreId = 21,
    }
    impl CustomPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Id => "ID",
                Self::Id2 => "ID2",
                Self::ItemTitle => "ITEM_TITLE",
                Self::ItemSubtitle => "ITEM_SUBTITLE",
                Self::ItemDescription => "ITEM_DESCRIPTION",
                Self::ItemAddress => "ITEM_ADDRESS",
                Self::Price => "PRICE",
                Self::FormattedPrice => "FORMATTED_PRICE",
                Self::SalePrice => "SALE_PRICE",
                Self::FormattedSalePrice => "FORMATTED_SALE_PRICE",
                Self::ImageUrl => "IMAGE_URL",
                Self::ItemCategory => "ITEM_CATEGORY",
                Self::FinalUrls => "FINAL_URLS",
                Self::FinalMobileUrls => "FINAL_MOBILE_URLS",
                Self::TrackingUrl => "TRACKING_URL",
                Self::ContextualKeywords => "CONTEXTUAL_KEYWORDS",
                Self::AndroidAppLink => "ANDROID_APP_LINK",
                Self::SimilarIds => "SIMILAR_IDS",
                Self::IosAppLink => "IOS_APP_LINK",
                Self::IosAppStoreId => "IOS_APP_STORE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ID" => Some(Self::Id),
                "ID2" => Some(Self::Id2),
                "ITEM_TITLE" => Some(Self::ItemTitle),
                "ITEM_SUBTITLE" => Some(Self::ItemSubtitle),
                "ITEM_DESCRIPTION" => Some(Self::ItemDescription),
                "ITEM_ADDRESS" => Some(Self::ItemAddress),
                "PRICE" => Some(Self::Price),
                "FORMATTED_PRICE" => Some(Self::FormattedPrice),
                "SALE_PRICE" => Some(Self::SalePrice),
                "FORMATTED_SALE_PRICE" => Some(Self::FormattedSalePrice),
                "IMAGE_URL" => Some(Self::ImageUrl),
                "ITEM_CATEGORY" => Some(Self::ItemCategory),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "CONTEXTUAL_KEYWORDS" => Some(Self::ContextualKeywords),
                "ANDROID_APP_LINK" => Some(Self::AndroidAppLink),
                "SIMILAR_IDS" => Some(Self::SimilarIds),
                "IOS_APP_LINK" => Some(Self::IosAppLink),
                "IOS_APP_STORE_ID" => Some(Self::IosAppStoreId),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible optimization mode of a customer
/// acquisition goal of a campaign.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerAcquisitionOptimizationModeEnum {}
/// Nested message and enum types in `CustomerAcquisitionOptimizationModeEnum`.
pub mod customer_acquisition_optimization_mode_enum {
    /// Possible optimization mode of a customer acquisition goal.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerAcquisitionOptimizationMode {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The mode is used when campaign is optimizing equally for existing and new
        /// customers, which is the default value.
        TargetAllEqually = 2,
        /// The mode is used when campaign is bidding higher for new customers than
        /// existing customer.
        BidHigherForNewCustomer = 3,
        /// The mode is used when campaign is only optimizing for new customers.
        TargetNewCustomer = 4,
    }
    impl CustomerAcquisitionOptimizationMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::TargetAllEqually => "TARGET_ALL_EQUALLY",
                Self::BidHigherForNewCustomer => "BID_HIGHER_FOR_NEW_CUSTOMER",
                Self::TargetNewCustomer => "TARGET_NEW_CUSTOMER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TARGET_ALL_EQUALLY" => Some(Self::TargetAllEqually),
                "BID_HIGHER_FOR_NEW_CUSTOMER" => Some(Self::BidHigherForNewCustomer),
                "TARGET_NEW_CUSTOMER" => Some(Self::TargetNewCustomer),
                _ => None,
            }
        }
    }
}
/// Container for enum describing reasons why a customer is not eligible to use
/// PaymentMode.CONVERSIONS.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerPayPerConversionEligibilityFailureReasonEnum {}
/// Nested message and enum types in `CustomerPayPerConversionEligibilityFailureReasonEnum`.
pub mod customer_pay_per_conversion_eligibility_failure_reason_enum {
    /// Enum describing possible reasons a customer is not eligible to use
    /// PaymentMode.CONVERSIONS.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerPayPerConversionEligibilityFailureReason {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Customer does not have enough conversions.
        NotEnoughConversions = 2,
        /// Customer's conversion lag is too high.
        ConversionLagTooHigh = 3,
        /// Customer uses shared budgets.
        HasCampaignWithSharedBudget = 4,
        /// Customer has conversions with ConversionActionType.UPLOAD_CLICKS.
        HasUploadClicksConversion = 5,
        /// Customer's average daily spend is too high.
        AverageDailySpendTooHigh = 6,
        /// Customer's eligibility has not yet been calculated by the Google Ads
        /// backend. Check back soon.
        AnalysisNotComplete = 7,
        /// Customer is not eligible due to other reasons.
        Other = 8,
    }
    impl CustomerPayPerConversionEligibilityFailureReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NotEnoughConversions => "NOT_ENOUGH_CONVERSIONS",
                Self::ConversionLagTooHigh => "CONVERSION_LAG_TOO_HIGH",
                Self::HasCampaignWithSharedBudget => "HAS_CAMPAIGN_WITH_SHARED_BUDGET",
                Self::HasUploadClicksConversion => "HAS_UPLOAD_CLICKS_CONVERSION",
                Self::AverageDailySpendTooHigh => "AVERAGE_DAILY_SPEND_TOO_HIGH",
                Self::AnalysisNotComplete => "ANALYSIS_NOT_COMPLETE",
                Self::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOT_ENOUGH_CONVERSIONS" => Some(Self::NotEnoughConversions),
                "CONVERSION_LAG_TOO_HIGH" => Some(Self::ConversionLagTooHigh),
                "HAS_CAMPAIGN_WITH_SHARED_BUDGET" => {
                    Some(Self::HasCampaignWithSharedBudget)
                }
                "HAS_UPLOAD_CLICKS_CONVERSION" => Some(Self::HasUploadClicksConversion),
                "AVERAGE_DAILY_SPEND_TOO_HIGH" => Some(Self::AverageDailySpendTooHigh),
                "ANALYSIS_NOT_COMPLETE" => Some(Self::AnalysisNotComplete),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a customer.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerStatusEnum {}
/// Nested message and enum types in `CustomerStatusEnum`.
pub mod customer_status_enum {
    /// Possible statuses of a customer.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Indicates an active account able to serve ads.
        Enabled = 2,
        /// Indicates a canceled account unable to serve ads.
        /// Can be reactivated by an admin user.
        Canceled = 3,
        /// Indicates a suspended account unable to serve ads.
        /// May only be activated by Google support.
        Suspended = 4,
        /// Indicates a closed account unable to serve ads.
        /// Test account will also have CLOSED status.
        /// Status is permanent and may not be reopened.
        Closed = 5,
    }
    impl CustomerStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Canceled => "CANCELED",
                Self::Suspended => "SUSPENDED",
                Self::Closed => "CLOSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "CANCELED" => Some(Self::Canceled),
                "SUSPENDED" => Some(Self::Suspended),
                "CLOSED" => Some(Self::Closed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a customizer attribute.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomizerAttributeStatusEnum {}
/// Nested message and enum types in `CustomizerAttributeStatusEnum`.
pub mod customizer_attribute_status_enum {
    /// The possible statuses of a customizer attribute.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomizerAttributeStatus {
        /// The status has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        Unknown = 1,
        /// The customizer attribute is enabled.
        Enabled = 2,
        /// The customizer attribute is removed.
        Removed = 3,
    }
    impl CustomizerAttributeStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a customizer value.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomizerValueStatusEnum {}
/// Nested message and enum types in `CustomizerValueStatusEnum`.
pub mod customizer_value_status_enum {
    /// The possible statuses of a customizer value.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomizerValueStatus {
        /// The status has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        Unknown = 1,
        /// The customizer value is enabled.
        Enabled = 2,
        /// The customizer value is removed.
        Removed = 3,
    }
    impl CustomizerValueStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum indicating data driven model status.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DataDrivenModelStatusEnum {}
/// Nested message and enum types in `DataDrivenModelStatusEnum`.
pub mod data_driven_model_status_enum {
    /// Enumerates data driven model statuses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataDrivenModelStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The data driven model is available.
        Available = 2,
        /// The data driven model is stale. It hasn't been updated for at least 7
        /// days. It is still being used, but will become expired if it does not get
        /// updated for 30 days.
        Stale = 3,
        /// The data driven model expired. It hasn't been updated for at least 30
        /// days and cannot be used. Most commonly this is because there hasn't been
        /// the required number of events in a recent 30-day period.
        Expired = 4,
        /// The data driven model has never been generated. Most commonly this is
        /// because there has never been the required number of events in any 30-day
        /// period.
        NeverGenerated = 5,
    }
    impl DataDrivenModelStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Available => "AVAILABLE",
                Self::Stale => "STALE",
                Self::Expired => "EXPIRED",
                Self::NeverGenerated => "NEVER_GENERATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AVAILABLE" => Some(Self::Available),
                "STALE" => Some(Self::Stale),
                "EXPIRED" => Some(Self::Expired),
                "NEVER_GENERATED" => Some(Self::NeverGenerated),
                _ => None,
            }
        }
    }
}
/// Container for distance buckets of a user's distance from an advertiser's
/// location extension.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DistanceBucketEnum {}
/// Nested message and enum types in `DistanceBucketEnum`.
pub mod distance_bucket_enum {
    /// The distance bucket for a user's distance from an advertiser's location
    /// extension.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DistanceBucket {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// User was within 700m of the location.
        Within700m = 2,
        /// User was within 1KM of the location.
        Within1km = 3,
        /// User was within 5KM of the location.
        Within5km = 4,
        /// User was within 10KM of the location.
        Within10km = 5,
        /// User was within 15KM of the location.
        Within15km = 6,
        /// User was within 20KM of the location.
        Within20km = 7,
        /// User was within 25KM of the location.
        Within25km = 8,
        /// User was within 30KM of the location.
        Within30km = 9,
        /// User was within 35KM of the location.
        Within35km = 10,
        /// User was within 40KM of the location.
        Within40km = 11,
        /// User was within 45KM of the location.
        Within45km = 12,
        /// User was within 50KM of the location.
        Within50km = 13,
        /// User was within 55KM of the location.
        Within55km = 14,
        /// User was within 60KM of the location.
        Within60km = 15,
        /// User was within 65KM of the location.
        Within65km = 16,
        /// User was beyond 65KM of the location.
        Beyond65km = 17,
        /// User was within 0.7 miles of the location.
        Within07miles = 18,
        /// User was within 1 mile of the location.
        Within1mile = 19,
        /// User was within 5 miles of the location.
        Within5miles = 20,
        /// User was within 10 miles of the location.
        Within10miles = 21,
        /// User was within 15 miles of the location.
        Within15miles = 22,
        /// User was within 20 miles of the location.
        Within20miles = 23,
        /// User was within 25 miles of the location.
        Within25miles = 24,
        /// User was within 30 miles of the location.
        Within30miles = 25,
        /// User was within 35 miles of the location.
        Within35miles = 26,
        /// User was within 40 miles of the location.
        Within40miles = 27,
        /// User was beyond 40 miles of the location.
        Beyond40miles = 28,
    }
    impl DistanceBucket {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Within700m => "WITHIN_700M",
                Self::Within1km => "WITHIN_1KM",
                Self::Within5km => "WITHIN_5KM",
                Self::Within10km => "WITHIN_10KM",
                Self::Within15km => "WITHIN_15KM",
                Self::Within20km => "WITHIN_20KM",
                Self::Within25km => "WITHIN_25KM",
                Self::Within30km => "WITHIN_30KM",
                Self::Within35km => "WITHIN_35KM",
                Self::Within40km => "WITHIN_40KM",
                Self::Within45km => "WITHIN_45KM",
                Self::Within50km => "WITHIN_50KM",
                Self::Within55km => "WITHIN_55KM",
                Self::Within60km => "WITHIN_60KM",
                Self::Within65km => "WITHIN_65KM",
                Self::Beyond65km => "BEYOND_65KM",
                Self::Within07miles => "WITHIN_0_7MILES",
                Self::Within1mile => "WITHIN_1MILE",
                Self::Within5miles => "WITHIN_5MILES",
                Self::Within10miles => "WITHIN_10MILES",
                Self::Within15miles => "WITHIN_15MILES",
                Self::Within20miles => "WITHIN_20MILES",
                Self::Within25miles => "WITHIN_25MILES",
                Self::Within30miles => "WITHIN_30MILES",
                Self::Within35miles => "WITHIN_35MILES",
                Self::Within40miles => "WITHIN_40MILES",
                Self::Beyond40miles => "BEYOND_40MILES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "WITHIN_700M" => Some(Self::Within700m),
                "WITHIN_1KM" => Some(Self::Within1km),
                "WITHIN_5KM" => Some(Self::Within5km),
                "WITHIN_10KM" => Some(Self::Within10km),
                "WITHIN_15KM" => Some(Self::Within15km),
                "WITHIN_20KM" => Some(Self::Within20km),
                "WITHIN_25KM" => Some(Self::Within25km),
                "WITHIN_30KM" => Some(Self::Within30km),
                "WITHIN_35KM" => Some(Self::Within35km),
                "WITHIN_40KM" => Some(Self::Within40km),
                "WITHIN_45KM" => Some(Self::Within45km),
                "WITHIN_50KM" => Some(Self::Within50km),
                "WITHIN_55KM" => Some(Self::Within55km),
                "WITHIN_60KM" => Some(Self::Within60km),
                "WITHIN_65KM" => Some(Self::Within65km),
                "BEYOND_65KM" => Some(Self::Beyond65km),
                "WITHIN_0_7MILES" => Some(Self::Within07miles),
                "WITHIN_1MILE" => Some(Self::Within1mile),
                "WITHIN_5MILES" => Some(Self::Within5miles),
                "WITHIN_10MILES" => Some(Self::Within10miles),
                "WITHIN_15MILES" => Some(Self::Within15miles),
                "WITHIN_20MILES" => Some(Self::Within20miles),
                "WITHIN_25MILES" => Some(Self::Within25miles),
                "WITHIN_30MILES" => Some(Self::Within30miles),
                "WITHIN_35MILES" => Some(Self::Within35miles),
                "WITHIN_40MILES" => Some(Self::Within40miles),
                "BEYOND_40MILES" => Some(Self::Beyond40miles),
                _ => None,
            }
        }
    }
}
/// Values for Dynamic Search Ad Page Feed criterion fields.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DsaPageFeedCriterionFieldEnum {}
/// Nested message and enum types in `DsaPageFeedCriterionFieldEnum`.
pub mod dsa_page_feed_criterion_field_enum {
    /// Possible values for Dynamic Search Ad Page Feed criterion fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DsaPageFeedCriterionField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: URL or URL_LIST. URL of the web page you want to target.
        PageUrl = 2,
        /// Data Type: STRING_LIST. The labels that will help you target ads within
        /// your page feed.
        Label = 3,
    }
    impl DsaPageFeedCriterionField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::PageUrl => "PAGE_URL",
                Self::Label => "LABEL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PAGE_URL" => Some(Self::PageUrl),
                "LABEL" => Some(Self::Label),
                _ => None,
            }
        }
    }
}
/// Values for Education placeholder fields.
/// For more information about dynamic remarketing feeds, see
/// <https://support.google.com/google-ads/answer/6053288.>
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EducationPlaceholderFieldEnum {}
/// Nested message and enum types in `EducationPlaceholderFieldEnum`.
pub mod education_placeholder_field_enum {
    /// Possible values for Education placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EducationPlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. Required. Combination of PROGRAM ID and LOCATION ID
        /// must be unique per offer.
        ProgramId = 2,
        /// Data Type: STRING. Combination of PROGRAM ID and LOCATION ID must be
        /// unique per offer.
        LocationId = 3,
        /// Data Type: STRING. Required. Main headline with program name to be shown
        /// in dynamic ad.
        ProgramName = 4,
        /// Data Type: STRING. Area of study that can be shown in dynamic ad.
        AreaOfStudy = 5,
        /// Data Type: STRING. Description of program that can be shown in dynamic
        /// ad.
        ProgramDescription = 6,
        /// Data Type: STRING. Name of school that can be shown in dynamic ad.
        SchoolName = 7,
        /// Data Type: STRING. Complete school address, including postal code.
        Address = 8,
        /// Data Type: URL. Image to be displayed in ads.
        ThumbnailImageUrl = 9,
        /// Data Type: URL. Alternative hosted file of image to be used in the ad.
        AlternativeThumbnailImageUrl = 10,
        /// Data Type: URL_LIST. Required. Final URLs to be used in ad when using
        /// Upgraded URLs; the more specific the better (for example, the individual
        /// URL of a specific program and its location).
        FinalUrls = 11,
        /// Data Type: URL_LIST. Final mobile URLs for the ad when using Upgraded
        /// URLs.
        FinalMobileUrls = 12,
        /// Data Type: URL. Tracking template for the ad when using Upgraded URLs.
        TrackingUrl = 13,
        /// Data Type: STRING_LIST. Keywords used for product retrieval.
        ContextualKeywords = 14,
        /// Data Type: STRING. Android app link. Must be formatted as:
        /// android-app://{package_id}/{scheme}/{host_path}.
        /// The components are defined as follows:
        /// package_id: app ID as specified in Google Play.
        /// scheme: the scheme to pass to the application. Can be HTTP, or a custom
        ///    scheme.
        /// host_path: identifies the specific content within your application.
        AndroidAppLink = 15,
        /// Data Type: STRING_LIST. List of recommended program IDs to show together
        /// with this item.
        SimilarProgramIds = 16,
        /// Data Type: STRING. iOS app link.
        IosAppLink = 17,
        /// Data Type: INT64. iOS app store ID.
        IosAppStoreId = 18,
    }
    impl EducationPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ProgramId => "PROGRAM_ID",
                Self::LocationId => "LOCATION_ID",
                Self::ProgramName => "PROGRAM_NAME",
                Self::AreaOfStudy => "AREA_OF_STUDY",
                Self::ProgramDescription => "PROGRAM_DESCRIPTION",
                Self::SchoolName => "SCHOOL_NAME",
                Self::Address => "ADDRESS",
                Self::ThumbnailImageUrl => "THUMBNAIL_IMAGE_URL",
                Self::AlternativeThumbnailImageUrl => "ALTERNATIVE_THUMBNAIL_IMAGE_URL",
                Self::FinalUrls => "FINAL_URLS",
                Self::FinalMobileUrls => "FINAL_MOBILE_URLS",
                Self::TrackingUrl => "TRACKING_URL",
                Self::ContextualKeywords => "CONTEXTUAL_KEYWORDS",
                Self::AndroidAppLink => "ANDROID_APP_LINK",
                Self::SimilarProgramIds => "SIMILAR_PROGRAM_IDS",
                Self::IosAppLink => "IOS_APP_LINK",
                Self::IosAppStoreId => "IOS_APP_STORE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PROGRAM_ID" => Some(Self::ProgramId),
                "LOCATION_ID" => Some(Self::LocationId),
                "PROGRAM_NAME" => Some(Self::ProgramName),
                "AREA_OF_STUDY" => Some(Self::AreaOfStudy),
                "PROGRAM_DESCRIPTION" => Some(Self::ProgramDescription),
                "SCHOOL_NAME" => Some(Self::SchoolName),
                "ADDRESS" => Some(Self::Address),
                "THUMBNAIL_IMAGE_URL" => Some(Self::ThumbnailImageUrl),
                "ALTERNATIVE_THUMBNAIL_IMAGE_URL" => {
                    Some(Self::AlternativeThumbnailImageUrl)
                }
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "CONTEXTUAL_KEYWORDS" => Some(Self::ContextualKeywords),
                "ANDROID_APP_LINK" => Some(Self::AndroidAppLink),
                "SIMILAR_PROGRAM_IDS" => Some(Self::SimilarProgramIds),
                "IOS_APP_LINK" => Some(Self::IosAppLink),
                "IOS_APP_STORE_ID" => Some(Self::IosAppStoreId),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the experiment status.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExperimentStatusEnum {}
/// Nested message and enum types in `ExperimentStatusEnum`.
pub mod experiment_status_enum {
    /// The status of the experiment.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExperimentStatus {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// The experiment is enabled.
        Enabled = 2,
        /// The experiment has been removed.
        Removed = 3,
        /// The experiment has been halted.
        /// This status can be set from ENABLED status through API.
        Halted = 4,
        /// The experiment will be promoted out of experimental status.
        Promoted = 5,
        /// Initial status of the experiment.
        Setup = 6,
        /// The experiment's campaigns are pending materialization.
        /// This status can be set from SETUP status through API.
        Initiated = 7,
        /// The experiment has been graduated.
        Graduated = 8,
    }
    impl ExperimentStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
                Self::Halted => "HALTED",
                Self::Promoted => "PROMOTED",
                Self::Setup => "SETUP",
                Self::Initiated => "INITIATED",
                Self::Graduated => "GRADUATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                "HALTED" => Some(Self::Halted),
                "PROMOTED" => Some(Self::Promoted),
                "SETUP" => Some(Self::Setup),
                "INITIATED" => Some(Self::Initiated),
                "GRADUATED" => Some(Self::Graduated),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of experiment.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExperimentTypeEnum {}
/// Nested message and enum types in `ExperimentTypeEnum`.
pub mod experiment_type_enum {
    /// The type of the experiment.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExperimentType {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// This is a DISPLAY_AND_VIDEO_360 experiment.
        DisplayAndVideo360 = 2,
        /// This is an ad variation experiment.
        AdVariation = 3,
        /// A custom experiment consisting of Video campaigns.
        YoutubeCustom = 5,
        /// A custom experiment consisting of display campaigns.
        DisplayCustom = 6,
        /// A custom experiment consisting of search campaigns.
        SearchCustom = 7,
        /// An experiment that compares bidding strategies for display campaigns.
        DisplayAutomatedBiddingStrategy = 8,
        /// An experiment that compares bidding strategies for search campaigns."
        SearchAutomatedBiddingStrategy = 9,
        /// An experiment that compares bidding strategies for shopping campaigns.
        ShoppingAutomatedBiddingStrategy = 10,
        /// DEPRECATED. A smart matching experiment with search campaigns.
        SmartMatching = 11,
        /// A custom experiment consisting of hotel campaigns.
        HotelCustom = 12,
    }
    impl ExperimentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DisplayAndVideo360 => "DISPLAY_AND_VIDEO_360",
                Self::AdVariation => "AD_VARIATION",
                Self::YoutubeCustom => "YOUTUBE_CUSTOM",
                Self::DisplayCustom => "DISPLAY_CUSTOM",
                Self::SearchCustom => "SEARCH_CUSTOM",
                Self::DisplayAutomatedBiddingStrategy => {
                    "DISPLAY_AUTOMATED_BIDDING_STRATEGY"
                }
                Self::SearchAutomatedBiddingStrategy => {
                    "SEARCH_AUTOMATED_BIDDING_STRATEGY"
                }
                Self::ShoppingAutomatedBiddingStrategy => {
                    "SHOPPING_AUTOMATED_BIDDING_STRATEGY"
                }
                Self::SmartMatching => "SMART_MATCHING",
                Self::HotelCustom => "HOTEL_CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DISPLAY_AND_VIDEO_360" => Some(Self::DisplayAndVideo360),
                "AD_VARIATION" => Some(Self::AdVariation),
                "YOUTUBE_CUSTOM" => Some(Self::YoutubeCustom),
                "DISPLAY_CUSTOM" => Some(Self::DisplayCustom),
                "SEARCH_CUSTOM" => Some(Self::SearchCustom),
                "DISPLAY_AUTOMATED_BIDDING_STRATEGY" => {
                    Some(Self::DisplayAutomatedBiddingStrategy)
                }
                "SEARCH_AUTOMATED_BIDDING_STRATEGY" => {
                    Some(Self::SearchAutomatedBiddingStrategy)
                }
                "SHOPPING_AUTOMATED_BIDDING_STRATEGY" => {
                    Some(Self::ShoppingAutomatedBiddingStrategy)
                }
                "SMART_MATCHING" => Some(Self::SmartMatching),
                "HOTEL_CUSTOM" => Some(Self::HotelCustom),
                _ => None,
            }
        }
    }
}
/// Container for enum describing extension setting device types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExtensionSettingDeviceEnum {}
/// Nested message and enum types in `ExtensionSettingDeviceEnum`.
pub mod extension_setting_device_enum {
    /// Possible device types for an extension setting.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExtensionSettingDevice {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Mobile. The extensions in the extension setting will only serve on
        /// mobile devices.
        Mobile = 2,
        /// Desktop. The extensions in the extension setting will only serve on
        /// desktop devices.
        Desktop = 3,
    }
    impl ExtensionSettingDevice {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Mobile => "MOBILE",
                Self::Desktop => "DESKTOP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MOBILE" => Some(Self::Mobile),
                "DESKTOP" => Some(Self::Desktop),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible data types for an extension in an
/// extension setting.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExtensionTypeEnum {}
/// Nested message and enum types in `ExtensionTypeEnum`.
pub mod extension_type_enum {
    /// Possible data types for an extension in an extension setting.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExtensionType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// None.
        None = 2,
        /// App.
        App = 3,
        /// Call.
        Call = 4,
        /// Callout.
        Callout = 5,
        /// Message.
        Message = 6,
        /// Price.
        Price = 7,
        /// Promotion.
        Promotion = 8,
        /// Sitelink.
        Sitelink = 10,
        /// Structured snippet.
        StructuredSnippet = 11,
        /// Location.
        Location = 12,
        /// Affiliate location.
        AffiliateLocation = 13,
        /// Hotel callout
        HotelCallout = 15,
        /// Image.
        Image = 16,
    }
    impl ExtensionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::None => "NONE",
                Self::App => "APP",
                Self::Call => "CALL",
                Self::Callout => "CALLOUT",
                Self::Message => "MESSAGE",
                Self::Price => "PRICE",
                Self::Promotion => "PROMOTION",
                Self::Sitelink => "SITELINK",
                Self::StructuredSnippet => "STRUCTURED_SNIPPET",
                Self::Location => "LOCATION",
                Self::AffiliateLocation => "AFFILIATE_LOCATION",
                Self::HotelCallout => "HOTEL_CALLOUT",
                Self::Image => "IMAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NONE" => Some(Self::None),
                "APP" => Some(Self::App),
                "CALL" => Some(Self::Call),
                "CALLOUT" => Some(Self::Callout),
                "MESSAGE" => Some(Self::Message),
                "PRICE" => Some(Self::Price),
                "PROMOTION" => Some(Self::Promotion),
                "SITELINK" => Some(Self::Sitelink),
                "STRUCTURED_SNIPPET" => Some(Self::StructuredSnippet),
                "LOCATION" => Some(Self::Location),
                "AFFILIATE_LOCATION" => Some(Self::AffiliateLocation),
                "HOTEL_CALLOUT" => Some(Self::HotelCallout),
                "IMAGE" => Some(Self::Image),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible data types for a feed attribute.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedAttributeTypeEnum {}
/// Nested message and enum types in `FeedAttributeTypeEnum`.
pub mod feed_attribute_type_enum {
    /// Possible data types for a feed attribute.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedAttributeType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Int64.
        Int64 = 2,
        /// Double.
        Double = 3,
        /// String.
        String = 4,
        /// Boolean.
        Boolean = 5,
        /// Url.
        Url = 6,
        /// Datetime.
        DateTime = 7,
        /// Int64 list.
        Int64List = 8,
        /// Double (8 bytes) list.
        DoubleList = 9,
        /// String list.
        StringList = 10,
        /// Boolean list.
        BooleanList = 11,
        /// Url list.
        UrlList = 12,
        /// Datetime list.
        DateTimeList = 13,
        /// Price.
        Price = 14,
    }
    impl FeedAttributeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Int64 => "INT64",
                Self::Double => "DOUBLE",
                Self::String => "STRING",
                Self::Boolean => "BOOLEAN",
                Self::Url => "URL",
                Self::DateTime => "DATE_TIME",
                Self::Int64List => "INT64_LIST",
                Self::DoubleList => "DOUBLE_LIST",
                Self::StringList => "STRING_LIST",
                Self::BooleanList => "BOOLEAN_LIST",
                Self::UrlList => "URL_LIST",
                Self::DateTimeList => "DATE_TIME_LIST",
                Self::Price => "PRICE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INT64" => Some(Self::Int64),
                "DOUBLE" => Some(Self::Double),
                "STRING" => Some(Self::String),
                "BOOLEAN" => Some(Self::Boolean),
                "URL" => Some(Self::Url),
                "DATE_TIME" => Some(Self::DateTime),
                "INT64_LIST" => Some(Self::Int64List),
                "DOUBLE_LIST" => Some(Self::DoubleList),
                "STRING_LIST" => Some(Self::StringList),
                "BOOLEAN_LIST" => Some(Self::BooleanList),
                "URL_LIST" => Some(Self::UrlList),
                "DATE_TIME_LIST" => Some(Self::DateTimeList),
                "PRICE" => Some(Self::Price),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible quality evaluation approval statuses
/// of a feed item.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemQualityApprovalStatusEnum {}
/// Nested message and enum types in `FeedItemQualityApprovalStatusEnum`.
pub mod feed_item_quality_approval_status_enum {
    /// The possible quality evaluation approval statuses of a feed item.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemQualityApprovalStatus {
        /// No value has been specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Meets all quality expectations.
        Approved = 2,
        /// Does not meet some quality expectations. The specific reason is found in
        /// the quality_disapproval_reasons field.
        Disapproved = 3,
    }
    impl FeedItemQualityApprovalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Approved => "APPROVED",
                Self::Disapproved => "DISAPPROVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APPROVED" => Some(Self::Approved),
                "DISAPPROVED" => Some(Self::Disapproved),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible quality evaluation disapproval reasons
/// of a feed item.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemQualityDisapprovalReasonEnum {}
/// Nested message and enum types in `FeedItemQualityDisapprovalReasonEnum`.
pub mod feed_item_quality_disapproval_reason_enum {
    /// The possible quality evaluation disapproval reasons of a feed item.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemQualityDisapprovalReason {
        /// No value has been specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Price contains repetitive headers.
        PriceTableRepetitiveHeaders = 2,
        /// Price contains repetitive description.
        PriceTableRepetitiveDescription = 3,
        /// Price contains inconsistent items.
        PriceTableInconsistentRows = 4,
        /// Price contains qualifiers in description.
        PriceDescriptionHasPriceQualifiers = 5,
        /// Price contains an unsupported language.
        PriceUnsupportedLanguage = 6,
        /// Price item header is not relevant to the price type.
        PriceTableRowHeaderTableTypeMismatch = 7,
        /// Price item header has promotional text.
        PriceTableRowHeaderHasPromotionalText = 8,
        /// Price item description is not relevant to the item header.
        PriceTableRowDescriptionNotRelevant = 9,
        /// Price item description contains promotional text.
        PriceTableRowDescriptionHasPromotionalText = 10,
        /// Price item header and description are repetitive.
        PriceTableRowHeaderDescriptionRepetitive = 11,
        /// Price item is in a foreign language, nonsense, or can't be rated.
        PriceTableRowUnrateable = 12,
        /// Price item price is invalid or inaccurate.
        PriceTableRowPriceInvalid = 13,
        /// Price item URL is invalid or irrelevant.
        PriceTableRowUrlInvalid = 14,
        /// Price item header or description has price.
        PriceHeaderOrDescriptionHasPrice = 15,
        /// Structured snippet values do not match the header.
        StructuredSnippetsHeaderPolicyViolated = 16,
        /// Structured snippet values are repeated.
        StructuredSnippetsRepeatedValues = 17,
        /// Structured snippet values violate editorial guidelines like punctuation.
        StructuredSnippetsEditorialGuidelines = 18,
        /// Structured snippet contain promotional text.
        StructuredSnippetsHasPromotionalText = 19,
    }
    impl FeedItemQualityDisapprovalReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::PriceTableRepetitiveHeaders => "PRICE_TABLE_REPETITIVE_HEADERS",
                Self::PriceTableRepetitiveDescription => {
                    "PRICE_TABLE_REPETITIVE_DESCRIPTION"
                }
                Self::PriceTableInconsistentRows => "PRICE_TABLE_INCONSISTENT_ROWS",
                Self::PriceDescriptionHasPriceQualifiers => {
                    "PRICE_DESCRIPTION_HAS_PRICE_QUALIFIERS"
                }
                Self::PriceUnsupportedLanguage => "PRICE_UNSUPPORTED_LANGUAGE",
                Self::PriceTableRowHeaderTableTypeMismatch => {
                    "PRICE_TABLE_ROW_HEADER_TABLE_TYPE_MISMATCH"
                }
                Self::PriceTableRowHeaderHasPromotionalText => {
                    "PRICE_TABLE_ROW_HEADER_HAS_PROMOTIONAL_TEXT"
                }
                Self::PriceTableRowDescriptionNotRelevant => {
                    "PRICE_TABLE_ROW_DESCRIPTION_NOT_RELEVANT"
                }
                Self::PriceTableRowDescriptionHasPromotionalText => {
                    "PRICE_TABLE_ROW_DESCRIPTION_HAS_PROMOTIONAL_TEXT"
                }
                Self::PriceTableRowHeaderDescriptionRepetitive => {
                    "PRICE_TABLE_ROW_HEADER_DESCRIPTION_REPETITIVE"
                }
                Self::PriceTableRowUnrateable => "PRICE_TABLE_ROW_UNRATEABLE",
                Self::PriceTableRowPriceInvalid => "PRICE_TABLE_ROW_PRICE_INVALID",
                Self::PriceTableRowUrlInvalid => "PRICE_TABLE_ROW_URL_INVALID",
                Self::PriceHeaderOrDescriptionHasPrice => {
                    "PRICE_HEADER_OR_DESCRIPTION_HAS_PRICE"
                }
                Self::StructuredSnippetsHeaderPolicyViolated => {
                    "STRUCTURED_SNIPPETS_HEADER_POLICY_VIOLATED"
                }
                Self::StructuredSnippetsRepeatedValues => {
                    "STRUCTURED_SNIPPETS_REPEATED_VALUES"
                }
                Self::StructuredSnippetsEditorialGuidelines => {
                    "STRUCTURED_SNIPPETS_EDITORIAL_GUIDELINES"
                }
                Self::StructuredSnippetsHasPromotionalText => {
                    "STRUCTURED_SNIPPETS_HAS_PROMOTIONAL_TEXT"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PRICE_TABLE_REPETITIVE_HEADERS" => {
                    Some(Self::PriceTableRepetitiveHeaders)
                }
                "PRICE_TABLE_REPETITIVE_DESCRIPTION" => {
                    Some(Self::PriceTableRepetitiveDescription)
                }
                "PRICE_TABLE_INCONSISTENT_ROWS" => Some(Self::PriceTableInconsistentRows),
                "PRICE_DESCRIPTION_HAS_PRICE_QUALIFIERS" => {
                    Some(Self::PriceDescriptionHasPriceQualifiers)
                }
                "PRICE_UNSUPPORTED_LANGUAGE" => Some(Self::PriceUnsupportedLanguage),
                "PRICE_TABLE_ROW_HEADER_TABLE_TYPE_MISMATCH" => {
                    Some(Self::PriceTableRowHeaderTableTypeMismatch)
                }
                "PRICE_TABLE_ROW_HEADER_HAS_PROMOTIONAL_TEXT" => {
                    Some(Self::PriceTableRowHeaderHasPromotionalText)
                }
                "PRICE_TABLE_ROW_DESCRIPTION_NOT_RELEVANT" => {
                    Some(Self::PriceTableRowDescriptionNotRelevant)
                }
                "PRICE_TABLE_ROW_DESCRIPTION_HAS_PROMOTIONAL_TEXT" => {
                    Some(Self::PriceTableRowDescriptionHasPromotionalText)
                }
                "PRICE_TABLE_ROW_HEADER_DESCRIPTION_REPETITIVE" => {
                    Some(Self::PriceTableRowHeaderDescriptionRepetitive)
                }
                "PRICE_TABLE_ROW_UNRATEABLE" => Some(Self::PriceTableRowUnrateable),
                "PRICE_TABLE_ROW_PRICE_INVALID" => Some(Self::PriceTableRowPriceInvalid),
                "PRICE_TABLE_ROW_URL_INVALID" => Some(Self::PriceTableRowUrlInvalid),
                "PRICE_HEADER_OR_DESCRIPTION_HAS_PRICE" => {
                    Some(Self::PriceHeaderOrDescriptionHasPrice)
                }
                "STRUCTURED_SNIPPETS_HEADER_POLICY_VIOLATED" => {
                    Some(Self::StructuredSnippetsHeaderPolicyViolated)
                }
                "STRUCTURED_SNIPPETS_REPEATED_VALUES" => {
                    Some(Self::StructuredSnippetsRepeatedValues)
                }
                "STRUCTURED_SNIPPETS_EDITORIAL_GUIDELINES" => {
                    Some(Self::StructuredSnippetsEditorialGuidelines)
                }
                "STRUCTURED_SNIPPETS_HAS_PROMOTIONAL_TEXT" => {
                    Some(Self::StructuredSnippetsHasPromotionalText)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a feed item set.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemSetStatusEnum {}
/// Nested message and enum types in `FeedItemSetStatusEnum`.
pub mod feed_item_set_status_enum {
    /// Possible statuses of a feed item set.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemSetStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Feed item set is enabled.
        Enabled = 2,
        /// Feed item set has been removed.
        Removed = 3,
    }
    impl FeedItemSetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a feed item.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemStatusEnum {}
/// Nested message and enum types in `FeedItemStatusEnum`.
pub mod feed_item_status_enum {
    /// Possible statuses of a feed item.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Feed item is enabled.
        Enabled = 2,
        /// Feed item has been removed.
        Removed = 3,
    }
    impl FeedItemStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible data types for a feed item target
/// device.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemTargetDeviceEnum {}
/// Nested message and enum types in `FeedItemTargetDeviceEnum`.
pub mod feed_item_target_device_enum {
    /// Possible data types for a feed item target device.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemTargetDevice {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Mobile.
        Mobile = 2,
    }
    impl FeedItemTargetDevice {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Mobile => "MOBILE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MOBILE" => Some(Self::Mobile),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a feed item target.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemTargetStatusEnum {}
/// Nested message and enum types in `FeedItemTargetStatusEnum`.
pub mod feed_item_target_status_enum {
    /// Possible statuses of a feed item target.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemTargetStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Feed item target is enabled.
        Enabled = 2,
        /// Feed item target has been removed.
        Removed = 3,
    }
    impl FeedItemTargetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible types of a feed item target.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemTargetTypeEnum {}
/// Nested message and enum types in `FeedItemTargetTypeEnum`.
pub mod feed_item_target_type_enum {
    /// Possible type of a feed item target.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemTargetType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Feed item targets a campaign.
        Campaign = 2,
        /// Feed item targets an ad group.
        AdGroup = 3,
        /// Feed item targets a criterion.
        Criterion = 4,
    }
    impl FeedItemTargetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Campaign => "CAMPAIGN",
                Self::AdGroup => "AD_GROUP",
                Self::Criterion => "CRITERION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN" => Some(Self::Campaign),
                "AD_GROUP" => Some(Self::AdGroup),
                "CRITERION" => Some(Self::Criterion),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible validation statuses of a feed item.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemValidationStatusEnum {}
/// Nested message and enum types in `FeedItemValidationStatusEnum`.
pub mod feed_item_validation_status_enum {
    /// The possible validation statuses of a feed item.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemValidationStatus {
        /// No value has been specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Validation pending.
        Pending = 2,
        /// An error was found.
        Invalid = 3,
        /// Feed item is semantically well-formed.
        Valid = 4,
    }
    impl FeedItemValidationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Pending => "PENDING",
                Self::Invalid => "INVALID",
                Self::Valid => "VALID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "INVALID" => Some(Self::Invalid),
                "VALID" => Some(Self::Valid),
                _ => None,
            }
        }
    }
}
/// Container for an enum describing possible statuses of a feed link.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedLinkStatusEnum {}
/// Nested message and enum types in `FeedLinkStatusEnum`.
pub mod feed_link_status_enum {
    /// Possible statuses of a feed link.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedLinkStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Feed link is enabled.
        Enabled = 2,
        /// Feed link has been removed.
        Removed = 3,
    }
    impl FeedLinkStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible criterion types for a feed mapping.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedMappingCriterionTypeEnum {}
/// Nested message and enum types in `FeedMappingCriterionTypeEnum`.
pub mod feed_mapping_criterion_type_enum {
    /// Possible placeholder types for a feed mapping.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedMappingCriterionType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Allows campaign targeting at locations within a location feed.
        LocationExtensionTargeting = 4,
        /// Allows url targeting for your dynamic search ads within a page feed.
        DsaPageFeed = 3,
    }
    impl FeedMappingCriterionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::LocationExtensionTargeting => "LOCATION_EXTENSION_TARGETING",
                Self::DsaPageFeed => "DSA_PAGE_FEED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LOCATION_EXTENSION_TARGETING" => Some(Self::LocationExtensionTargeting),
                "DSA_PAGE_FEED" => Some(Self::DsaPageFeed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a feed mapping.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedMappingStatusEnum {}
/// Nested message and enum types in `FeedMappingStatusEnum`.
pub mod feed_mapping_status_enum {
    /// Possible statuses of a feed mapping.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedMappingStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Feed mapping is enabled.
        Enabled = 2,
        /// Feed mapping has been removed.
        Removed = 3,
    }
    impl FeedMappingStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible values for a feed origin.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedOriginEnum {}
/// Nested message and enum types in `FeedOriginEnum`.
pub mod feed_origin_enum {
    /// Possible values for a feed origin.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedOrigin {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The FeedAttributes for this Feed are managed by the
        /// user. Users can add FeedAttributes to this Feed.
        User = 2,
        /// The FeedAttributes for a GOOGLE Feed are created by Google. A feed of
        /// this type is maintained by Google and will have the correct attributes
        /// for the placeholder type of the feed.
        Google = 3,
    }
    impl FeedOrigin {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::User => "USER",
                Self::Google => "GOOGLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "USER" => Some(Self::User),
                "GOOGLE" => Some(Self::Google),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a feed.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedStatusEnum {}
/// Nested message and enum types in `FeedStatusEnum`.
pub mod feed_status_enum {
    /// Possible statuses of a feed.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Feed is enabled.
        Enabled = 2,
        /// Feed has been removed.
        Removed = 3,
    }
    impl FeedStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Values for Flight placeholder fields.
/// For more information about dynamic remarketing feeds, see
/// <https://support.google.com/google-ads/answer/6053288.>
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FlightPlaceholderFieldEnum {}
/// Nested message and enum types in `FlightPlaceholderFieldEnum`.
pub mod flight_placeholder_field_enum {
    /// Possible values for Flight placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FlightPlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. Required. Destination id. Example: PAR, LON.
        /// For feed items that only have destination id, destination id must be a
        /// unique key. For feed items that have both destination id and origin id,
        /// then the combination must be a unique key.
        DestinationId = 2,
        /// Data Type: STRING. Origin id. Example: PAR, LON.
        /// Optional. Combination of destination id and origin id must be unique per
        /// offer.
        OriginId = 3,
        /// Data Type: STRING. Required. Main headline with product name to be shown
        /// in dynamic ad.
        FlightDescription = 4,
        /// Data Type: STRING. Shorter names are recommended.
        OriginName = 5,
        /// Data Type: STRING. Shorter names are recommended.
        DestinationName = 6,
        /// Data Type: STRING. Price to be shown in the ad.
        /// Example: "100.00 USD"
        FlightPrice = 7,
        /// Data Type: STRING. Formatted price to be shown in the ad.
        /// Example: "Starting at $100.00 USD", "$80 - $100"
        FormattedPrice = 8,
        /// Data Type: STRING. Sale price to be shown in the ad.
        /// Example: "80.00 USD"
        FlightSalePrice = 9,
        /// Data Type: STRING. Formatted sale price to be shown in the ad.
        /// Example: "On sale for $80.00", "$60 - $80"
        FormattedSalePrice = 10,
        /// Data Type: URL. Image to be displayed in the ad.
        ImageUrl = 11,
        /// Data Type: URL_LIST. Required. Final URLs for the ad when using Upgraded
        /// URLs. User will be redirected to these URLs when they click on an ad, or
        /// when they click on a specific flight for ads that show multiple
        /// flights.
        FinalUrls = 12,
        /// Data Type: URL_LIST. Final mobile URLs for the ad when using Upgraded
        /// URLs.
        FinalMobileUrls = 13,
        /// Data Type: URL. Tracking template for the ad when using Upgraded URLs.
        TrackingUrl = 14,
        /// Data Type: STRING. Android app link. Must be formatted as:
        /// android-app://{package_id}/{scheme}/{host_path}.
        /// The components are defined as follows:
        /// package_id: app ID as specified in Google Play.
        /// scheme: the scheme to pass to the application. Can be HTTP, or a custom
        ///    scheme.
        /// host_path: identifies the specific content within your application.
        AndroidAppLink = 15,
        /// Data Type: STRING_LIST. List of recommended destination IDs to show
        /// together with this item.
        SimilarDestinationIds = 16,
        /// Data Type: STRING. iOS app link.
        IosAppLink = 17,
        /// Data Type: INT64. iOS app store ID.
        IosAppStoreId = 18,
    }
    impl FlightPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DestinationId => "DESTINATION_ID",
                Self::OriginId => "ORIGIN_ID",
                Self::FlightDescription => "FLIGHT_DESCRIPTION",
                Self::OriginName => "ORIGIN_NAME",
                Self::DestinationName => "DESTINATION_NAME",
                Self::FlightPrice => "FLIGHT_PRICE",
                Self::FormattedPrice => "FORMATTED_PRICE",
                Self::FlightSalePrice => "FLIGHT_SALE_PRICE",
                Self::FormattedSalePrice => "FORMATTED_SALE_PRICE",
                Self::ImageUrl => "IMAGE_URL",
                Self::FinalUrls => "FINAL_URLS",
                Self::FinalMobileUrls => "FINAL_MOBILE_URLS",
                Self::TrackingUrl => "TRACKING_URL",
                Self::AndroidAppLink => "ANDROID_APP_LINK",
                Self::SimilarDestinationIds => "SIMILAR_DESTINATION_IDS",
                Self::IosAppLink => "IOS_APP_LINK",
                Self::IosAppStoreId => "IOS_APP_STORE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DESTINATION_ID" => Some(Self::DestinationId),
                "ORIGIN_ID" => Some(Self::OriginId),
                "FLIGHT_DESCRIPTION" => Some(Self::FlightDescription),
                "ORIGIN_NAME" => Some(Self::OriginName),
                "DESTINATION_NAME" => Some(Self::DestinationName),
                "FLIGHT_PRICE" => Some(Self::FlightPrice),
                "FORMATTED_PRICE" => Some(Self::FormattedPrice),
                "FLIGHT_SALE_PRICE" => Some(Self::FlightSalePrice),
                "FORMATTED_SALE_PRICE" => Some(Self::FormattedSalePrice),
                "IMAGE_URL" => Some(Self::ImageUrl),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "ANDROID_APP_LINK" => Some(Self::AndroidAppLink),
                "SIMILAR_DESTINATION_IDS" => Some(Self::SimilarDestinationIds),
                "IOS_APP_LINK" => Some(Self::IosAppLink),
                "IOS_APP_STORE_ID" => Some(Self::IosAppStoreId),
                _ => None,
            }
        }
    }
}
/// Container for describing the status of a geo target constant.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GeoTargetConstantStatusEnum {}
/// Nested message and enum types in `GeoTargetConstantStatusEnum`.
pub mod geo_target_constant_status_enum {
    /// The possible statuses of a geo target constant.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GeoTargetConstantStatus {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// The geo target constant is valid.
        Enabled = 2,
        /// The geo target constant is obsolete and will be removed.
        RemovalPlanned = 3,
    }
    impl GeoTargetConstantStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::RemovalPlanned => "REMOVAL_PLANNED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVAL_PLANNED" => Some(Self::RemovalPlanned),
                _ => None,
            }
        }
    }
}
/// Message describing feed item geo targeting restriction.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GeoTargetingRestrictionEnum {}
/// Nested message and enum types in `GeoTargetingRestrictionEnum`.
pub mod geo_targeting_restriction_enum {
    /// A restriction used to determine if the request context's
    /// geo should be matched.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GeoTargetingRestriction {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Indicates that request context should match the physical location of
        /// the user.
        LocationOfPresence = 2,
    }
    impl GeoTargetingRestriction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::LocationOfPresence => "LOCATION_OF_PRESENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LOCATION_OF_PRESENCE" => Some(Self::LocationOfPresence),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible geo targeting types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GeoTargetingTypeEnum {}
/// Nested message and enum types in `GeoTargetingTypeEnum`.
pub mod geo_targeting_type_enum {
    /// The possible geo targeting types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GeoTargetingType {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Location the user is interested in while making the query.
        AreaOfInterest = 2,
        /// Location of the user issuing the query.
        LocationOfPresence = 3,
    }
    impl GeoTargetingType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AreaOfInterest => "AREA_OF_INTEREST",
                Self::LocationOfPresence => "LOCATION_OF_PRESENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AREA_OF_INTEREST" => Some(Self::AreaOfInterest),
                "LOCATION_OF_PRESENCE" => Some(Self::LocationOfPresence),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible goal config levels.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GoalConfigLevelEnum {}
/// Nested message and enum types in `GoalConfigLevelEnum`.
pub mod goal_config_level_enum {
    /// The possible goal config levels. Campaigns automatically inherit the
    /// effective conversion account's customer goals unless they have been
    /// configured with their own set of campaign goals.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GoalConfigLevel {
        /// The goal config level has not been specified.
        Unspecified = 0,
        /// The goal config level is not known in this version.
        Unknown = 1,
        /// The goal config is defined at the customer level.
        Customer = 2,
        /// The goal config is defined at the campaign level.
        Campaign = 3,
    }
    impl GoalConfigLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Customer => "CUSTOMER",
                Self::Campaign => "CAMPAIGN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOMER" => Some(Self::Customer),
                "CAMPAIGN" => Some(Self::Campaign),
                _ => None,
            }
        }
    }
}
/// Container for enum that determines if the described artifact is a resource
/// or a field, and if it is a field, when it segments search queries.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GoogleAdsFieldCategoryEnum {}
/// Nested message and enum types in `GoogleAdsFieldCategoryEnum`.
pub mod google_ads_field_category_enum {
    /// The category of the artifact.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GoogleAdsFieldCategory {
        /// Unspecified
        Unspecified = 0,
        /// Unknown
        Unknown = 1,
        /// The described artifact is a resource.
        Resource = 2,
        /// The described artifact is a field and is an attribute of a resource.
        /// Including a resource attribute field in a query may segment the query if
        /// the resource to which it is attributed segments the resource found in
        /// the FROM clause.
        Attribute = 3,
        /// The described artifact is a field and always segments search queries.
        Segment = 5,
        /// The described artifact is a field and is a metric. It never segments
        /// search queries.
        Metric = 6,
    }
    impl GoogleAdsFieldCategory {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Resource => "RESOURCE",
                Self::Attribute => "ATTRIBUTE",
                Self::Segment => "SEGMENT",
                Self::Metric => "METRIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RESOURCE" => Some(Self::Resource),
                "ATTRIBUTE" => Some(Self::Attribute),
                "SEGMENT" => Some(Self::Segment),
                "METRIC" => Some(Self::Metric),
                _ => None,
            }
        }
    }
}
/// Container holding the various data types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GoogleAdsFieldDataTypeEnum {}
/// Nested message and enum types in `GoogleAdsFieldDataTypeEnum`.
pub mod google_ads_field_data_type_enum {
    /// These are the various types a GoogleAdsService artifact may take on.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GoogleAdsFieldDataType {
        /// Unspecified
        Unspecified = 0,
        /// Unknown
        Unknown = 1,
        /// Maps to google.protobuf.BoolValue
        ///
        /// Applicable operators:  =, !=
        Boolean = 2,
        /// Maps to google.protobuf.StringValue. It can be compared using the set of
        /// operators specific to dates however.
        ///
        /// Applicable operators:  =, <, >, <=, >=, BETWEEN, DURING, and IN
        Date = 3,
        /// Maps to google.protobuf.DoubleValue
        ///
        /// Applicable operators:  =, !=, <, >, IN, NOT IN
        Double = 4,
        /// Maps to an enum. It's specific definition can be found at type_url.
        ///
        /// Applicable operators:  =, !=, IN, NOT IN
        Enum = 5,
        /// Maps to google.protobuf.FloatValue
        ///
        /// Applicable operators:  =, !=, <, >, IN, NOT IN
        Float = 6,
        /// Maps to google.protobuf.Int32Value
        ///
        /// Applicable operators:  =, !=, <, >, <=, >=, BETWEEN, IN, NOT IN
        Int32 = 7,
        /// Maps to google.protobuf.Int64Value
        ///
        /// Applicable operators:  =, !=, <, >, <=, >=, BETWEEN, IN, NOT IN
        Int64 = 8,
        /// Maps to a protocol buffer message type. The data type's details can be
        /// found in type_url.
        ///
        /// No operators work with MESSAGE fields.
        Message = 9,
        /// Maps to google.protobuf.StringValue. Represents the resource name
        /// (unique id) of a resource or one of its foreign keys.
        ///
        /// No operators work with RESOURCE_NAME fields.
        ResourceName = 10,
        /// Maps to google.protobuf.StringValue.
        ///
        /// Applicable operators:  =, !=, LIKE, NOT LIKE, IN, NOT IN
        String = 11,
        /// Maps to google.protobuf.UInt64Value
        ///
        /// Applicable operators:  =, !=, <, >, <=, >=, BETWEEN, IN, NOT IN
        Uint64 = 12,
    }
    impl GoogleAdsFieldDataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Boolean => "BOOLEAN",
                Self::Date => "DATE",
                Self::Double => "DOUBLE",
                Self::Enum => "ENUM",
                Self::Float => "FLOAT",
                Self::Int32 => "INT32",
                Self::Int64 => "INT64",
                Self::Message => "MESSAGE",
                Self::ResourceName => "RESOURCE_NAME",
                Self::String => "STRING",
                Self::Uint64 => "UINT64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BOOLEAN" => Some(Self::Boolean),
                "DATE" => Some(Self::Date),
                "DOUBLE" => Some(Self::Double),
                "ENUM" => Some(Self::Enum),
                "FLOAT" => Some(Self::Float),
                "INT32" => Some(Self::Int32),
                "INT64" => Some(Self::Int64),
                "MESSAGE" => Some(Self::Message),
                "RESOURCE_NAME" => Some(Self::ResourceName),
                "STRING" => Some(Self::String),
                "UINT64" => Some(Self::Uint64),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a google voice call.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GoogleVoiceCallStatusEnum {}
/// Nested message and enum types in `GoogleVoiceCallStatusEnum`.
pub mod google_voice_call_status_enum {
    /// Possible statuses of a google voice call.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GoogleVoiceCallStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The call was missed.
        Missed = 2,
        /// The call was received.
        Received = 3,
    }
    impl GoogleVoiceCallStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Missed => "MISSED",
                Self::Received => "RECEIVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MISSED" => Some(Self::Missed),
                "RECEIVED" => Some(Self::Received),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a hotel asset suggestion.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HotelAssetSuggestionStatusEnum {}
/// Nested message and enum types in `HotelAssetSuggestionStatusEnum`.
pub mod hotel_asset_suggestion_status_enum {
    /// Possible statuses of a hotel asset suggestion.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HotelAssetSuggestionStatus {
        /// Enum unspecified.
        Unspecified = 0,
        /// The received error code is not known in this version.
        Unknown = 1,
        /// The hotel asset suggestion was successfully retrieved.
        Success = 2,
        /// A hotel look up returns nothing.
        HotelNotFound = 3,
        /// A Google Places ID is invalid and cannot be decoded.
        InvalidPlaceId = 4,
    }
    impl HotelAssetSuggestionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Success => "SUCCESS",
                Self::HotelNotFound => "HOTEL_NOT_FOUND",
                Self::InvalidPlaceId => "INVALID_PLACE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SUCCESS" => Some(Self::Success),
                "HOTEL_NOT_FOUND" => Some(Self::HotelNotFound),
                "INVALID_PLACE_ID" => Some(Self::InvalidPlaceId),
                _ => None,
            }
        }
    }
}
/// Values for Hotel placeholder fields.
/// For more information about dynamic remarketing feeds, see
/// <https://support.google.com/google-ads/answer/6053288.>
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HotelPlaceholderFieldEnum {}
/// Nested message and enum types in `HotelPlaceholderFieldEnum`.
pub mod hotel_placeholder_field_enum {
    /// Possible values for Hotel placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HotelPlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. Required. Unique ID.
        PropertyId = 2,
        /// Data Type: STRING. Required. Main headline with property name to be shown
        /// in dynamic ad.
        PropertyName = 3,
        /// Data Type: STRING. Name of destination to be shown in dynamic ad.
        DestinationName = 4,
        /// Data Type: STRING. Description of destination to be shown in dynamic ad.
        Description = 5,
        /// Data Type: STRING. Complete property address, including postal code.
        Address = 6,
        /// Data Type: STRING. Price to be shown in the ad.
        /// Example: "100.00 USD"
        Price = 7,
        /// Data Type: STRING. Formatted price to be shown in the ad.
        /// Example: "Starting at $100.00 USD", "$80 - $100"
        FormattedPrice = 8,
        /// Data Type: STRING. Sale price to be shown in the ad.
        /// Example: "80.00 USD"
        SalePrice = 9,
        /// Data Type: STRING. Formatted sale price to be shown in the ad.
        /// Example: "On sale for $80.00", "$60 - $80"
        FormattedSalePrice = 10,
        /// Data Type: URL. Image to be displayed in the ad.
        ImageUrl = 11,
        /// Data Type: STRING. Category of property used to group like items together
        /// for recommendation engine.
        Category = 12,
        /// Data Type: INT64. Star rating (1 to 5) used to group like items
        /// together for recommendation engine.
        StarRating = 13,
        /// Data Type: STRING_LIST. Keywords used for product retrieval.
        ContextualKeywords = 14,
        /// Data Type: URL_LIST. Required. Final URLs for the ad when using Upgraded
        /// URLs. User will be redirected to these URLs when they click on an ad, or
        /// when they click on a specific flight for ads that show multiple
        /// flights.
        FinalUrls = 15,
        /// Data Type: URL_LIST. Final mobile URLs for the ad when using Upgraded
        /// URLs.
        FinalMobileUrls = 16,
        /// Data Type: URL. Tracking template for the ad when using Upgraded URLs.
        TrackingUrl = 17,
        /// Data Type: STRING. Android app link. Must be formatted as:
        /// android-app://{package_id}/{scheme}/{host_path}.
        /// The components are defined as follows:
        /// package_id: app ID as specified in Google Play.
        /// scheme: the scheme to pass to the application. Can be HTTP, or a custom
        ///    scheme.
        /// host_path: identifies the specific content within your application.
        AndroidAppLink = 18,
        /// Data Type: STRING_LIST. List of recommended property IDs to show together
        /// with this item.
        SimilarPropertyIds = 19,
        /// Data Type: STRING. iOS app link.
        IosAppLink = 20,
        /// Data Type: INT64. iOS app store ID.
        IosAppStoreId = 21,
    }
    impl HotelPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::PropertyId => "PROPERTY_ID",
                Self::PropertyName => "PROPERTY_NAME",
                Self::DestinationName => "DESTINATION_NAME",
                Self::Description => "DESCRIPTION",
                Self::Address => "ADDRESS",
                Self::Price => "PRICE",
                Self::FormattedPrice => "FORMATTED_PRICE",
                Self::SalePrice => "SALE_PRICE",
                Self::FormattedSalePrice => "FORMATTED_SALE_PRICE",
                Self::ImageUrl => "IMAGE_URL",
                Self::Category => "CATEGORY",
                Self::StarRating => "STAR_RATING",
                Self::ContextualKeywords => "CONTEXTUAL_KEYWORDS",
                Self::FinalUrls => "FINAL_URLS",
                Self::FinalMobileUrls => "FINAL_MOBILE_URLS",
                Self::TrackingUrl => "TRACKING_URL",
                Self::AndroidAppLink => "ANDROID_APP_LINK",
                Self::SimilarPropertyIds => "SIMILAR_PROPERTY_IDS",
                Self::IosAppLink => "IOS_APP_LINK",
                Self::IosAppStoreId => "IOS_APP_STORE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PROPERTY_ID" => Some(Self::PropertyId),
                "PROPERTY_NAME" => Some(Self::PropertyName),
                "DESTINATION_NAME" => Some(Self::DestinationName),
                "DESCRIPTION" => Some(Self::Description),
                "ADDRESS" => Some(Self::Address),
                "PRICE" => Some(Self::Price),
                "FORMATTED_PRICE" => Some(Self::FormattedPrice),
                "SALE_PRICE" => Some(Self::SalePrice),
                "FORMATTED_SALE_PRICE" => Some(Self::FormattedSalePrice),
                "IMAGE_URL" => Some(Self::ImageUrl),
                "CATEGORY" => Some(Self::Category),
                "STAR_RATING" => Some(Self::StarRating),
                "CONTEXTUAL_KEYWORDS" => Some(Self::ContextualKeywords),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "ANDROID_APP_LINK" => Some(Self::AndroidAppLink),
                "SIMILAR_PROPERTY_IDS" => Some(Self::SimilarPropertyIds),
                "IOS_APP_LINK" => Some(Self::IosAppLink),
                "IOS_APP_STORE_ID" => Some(Self::IosAppStoreId),
                _ => None,
            }
        }
    }
}
/// Container for HotelReconciliationStatus.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HotelReconciliationStatusEnum {}
/// Nested message and enum types in `HotelReconciliationStatusEnum`.
pub mod hotel_reconciliation_status_enum {
    /// Status of the hotel booking reconciliation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HotelReconciliationStatus {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Bookings are for a future date, or a stay is underway but the check-out
        /// date hasn't passed. An active reservation can't be reconciled.
        ReservationEnabled = 2,
        /// Check-out has already taken place, or the booked dates have passed
        /// without cancellation. Bookings that are not reconciled within 45 days of
        /// the check-out date are billed based on the original booking price.
        ReconciliationNeeded = 3,
        /// These bookings have been reconciled. Reconciled bookings are billed 45
        /// days after the check-out date.
        Reconciled = 4,
        /// This booking was marked as canceled. Canceled stays with a value greater
        /// than zero (due to minimum stay rules or cancellation fees) are billed 45
        /// days after the check-out date.
        Canceled = 5,
    }
    impl HotelReconciliationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ReservationEnabled => "RESERVATION_ENABLED",
                Self::ReconciliationNeeded => "RECONCILIATION_NEEDED",
                Self::Reconciled => "RECONCILED",
                Self::Canceled => "CANCELED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RESERVATION_ENABLED" => Some(Self::ReservationEnabled),
                "RECONCILIATION_NEEDED" => Some(Self::ReconciliationNeeded),
                "RECONCILED" => Some(Self::Reconciled),
                "CANCELED" => Some(Self::Canceled),
                _ => None,
            }
        }
    }
}
/// Container for IdentityVerificationProgram.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IdentityVerificationProgramEnum {}
/// Nested message and enum types in `IdentityVerificationProgramEnum`.
pub mod identity_verification_program_enum {
    /// Type of identity verification program.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IdentityVerificationProgram {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Advertiser submits documents to verify their identity.
        AdvertiserIdentityVerification = 2,
    }
    impl IdentityVerificationProgram {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AdvertiserIdentityVerification => {
                    "ADVERTISER_IDENTITY_VERIFICATION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADVERTISER_IDENTITY_VERIFICATION" => {
                    Some(Self::AdvertiserIdentityVerification)
                }
                _ => None,
            }
        }
    }
}
/// Container for IdentityVerificationProgramStatus.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IdentityVerificationProgramStatusEnum {}
/// Nested message and enum types in `IdentityVerificationProgramStatusEnum`.
pub mod identity_verification_program_status_enum {
    /// Program status of identity verification.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IdentityVerificationProgramStatus {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Verification is pending on user action to proceed.
        PendingUserAction = 2,
        /// Verification is pending on review.
        PendingReview = 3,
        /// Verification succeeded.
        Success = 4,
        /// Verification failed.
        Failure = 5,
    }
    impl IdentityVerificationProgramStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::PendingUserAction => "PENDING_USER_ACTION",
                Self::PendingReview => "PENDING_REVIEW",
                Self::Success => "SUCCESS",
                Self::Failure => "FAILURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING_USER_ACTION" => Some(Self::PendingUserAction),
                "PENDING_REVIEW" => Some(Self::PendingReview),
                "SUCCESS" => Some(Self::Success),
                "FAILURE" => Some(Self::Failure),
                _ => None,
            }
        }
    }
}
/// Values for Advertiser Provided Image placeholder fields.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImagePlaceholderFieldEnum {}
/// Nested message and enum types in `ImagePlaceholderFieldEnum`.
pub mod image_placeholder_field_enum {
    /// Possible values for Advertiser Provided Image placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ImagePlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: INT64. The asset ID of the image.
        AssetId = 2,
    }
    impl ImagePlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AssetId => "ASSET_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ASSET_ID" => Some(Self::AssetId),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of invoices.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InvoiceTypeEnum {}
/// Nested message and enum types in `InvoiceTypeEnum`.
pub mod invoice_type_enum {
    /// The possible type of invoices.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InvoiceType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// An invoice with a negative amount. The account receives a credit.
        CreditMemo = 2,
        /// An invoice with a positive amount. The account owes a balance.
        Invoice = 3,
    }
    impl InvoiceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CreditMemo => "CREDIT_MEMO",
                Self::Invoice => "INVOICE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CREDIT_MEMO" => Some(Self::CreditMemo),
                "INVOICE" => Some(Self::Invoice),
                _ => None,
            }
        }
    }
}
/// Values for Job placeholder fields.
/// For more information about dynamic remarketing feeds, see
/// <https://support.google.com/google-ads/answer/6053288.>
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JobPlaceholderFieldEnum {}
/// Nested message and enum types in `JobPlaceholderFieldEnum`.
pub mod job_placeholder_field_enum {
    /// Possible values for Job placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum JobPlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. Required. If only JOB_ID is specified, then it must be
        /// unique. If both JOB_ID and LOCATION_ID are specified, then the
        /// pair must be unique.
        /// ID) pair must be unique.
        JobId = 2,
        /// Data Type: STRING. Combination of JOB_ID and LOCATION_ID must be unique
        /// per offer.
        LocationId = 3,
        /// Data Type: STRING. Required. Main headline with job title to be shown in
        /// dynamic ad.
        Title = 4,
        /// Data Type: STRING. Job subtitle to be shown in dynamic ad.
        Subtitle = 5,
        /// Data Type: STRING. Description of job to be shown in dynamic ad.
        Description = 6,
        /// Data Type: URL. Image to be displayed in the ad. Highly recommended for
        /// image ads.
        ImageUrl = 7,
        /// Data Type: STRING. Category of property used to group like items together
        /// for recommendation engine.
        Category = 8,
        /// Data Type: STRING_LIST. Keywords used for product retrieval.
        ContextualKeywords = 9,
        /// Data Type: STRING. Complete property address, including postal code.
        Address = 10,
        /// Data Type: STRING. Salary or salary range of job to be shown in dynamic
        /// ad.
        Salary = 11,
        /// Data Type: URL_LIST. Required. Final URLs to be used in ad when using
        /// Upgraded URLs; the more specific the better (for example, the individual
        /// URL of a specific job and its location).
        FinalUrls = 12,
        /// Data Type: URL_LIST. Final mobile URLs for the ad when using Upgraded
        /// URLs.
        FinalMobileUrls = 14,
        /// Data Type: URL. Tracking template for the ad when using Upgraded URLs.
        TrackingUrl = 15,
        /// Data Type: STRING. Android app link. Must be formatted as:
        /// android-app://{package_id}/{scheme}/{host_path}.
        /// The components are defined as follows:
        /// package_id: app ID as specified in Google Play.
        /// scheme: the scheme to pass to the application. Can be HTTP, or a custom
        ///    scheme.
        /// host_path: identifies the specific content within your application.
        AndroidAppLink = 16,
        /// Data Type: STRING_LIST. List of recommended job IDs to show together with
        /// this item.
        SimilarJobIds = 17,
        /// Data Type: STRING. iOS app link.
        IosAppLink = 18,
        /// Data Type: INT64. iOS app store ID.
        IosAppStoreId = 19,
    }
    impl JobPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::JobId => "JOB_ID",
                Self::LocationId => "LOCATION_ID",
                Self::Title => "TITLE",
                Self::Subtitle => "SUBTITLE",
                Self::Description => "DESCRIPTION",
                Self::ImageUrl => "IMAGE_URL",
                Self::Category => "CATEGORY",
                Self::ContextualKeywords => "CONTEXTUAL_KEYWORDS",
                Self::Address => "ADDRESS",
                Self::Salary => "SALARY",
                Self::FinalUrls => "FINAL_URLS",
                Self::FinalMobileUrls => "FINAL_MOBILE_URLS",
                Self::TrackingUrl => "TRACKING_URL",
                Self::AndroidAppLink => "ANDROID_APP_LINK",
                Self::SimilarJobIds => "SIMILAR_JOB_IDS",
                Self::IosAppLink => "IOS_APP_LINK",
                Self::IosAppStoreId => "IOS_APP_STORE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "JOB_ID" => Some(Self::JobId),
                "LOCATION_ID" => Some(Self::LocationId),
                "TITLE" => Some(Self::Title),
                "SUBTITLE" => Some(Self::Subtitle),
                "DESCRIPTION" => Some(Self::Description),
                "IMAGE_URL" => Some(Self::ImageUrl),
                "CATEGORY" => Some(Self::Category),
                "CONTEXTUAL_KEYWORDS" => Some(Self::ContextualKeywords),
                "ADDRESS" => Some(Self::Address),
                "SALARY" => Some(Self::Salary),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "ANDROID_APP_LINK" => Some(Self::AndroidAppLink),
                "SIMILAR_JOB_IDS" => Some(Self::SimilarJobIds),
                "IOS_APP_LINK" => Some(Self::IosAppLink),
                "IOS_APP_STORE_ID" => Some(Self::IosAppStoreId),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of forecast intervals.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanForecastIntervalEnum {}
/// Nested message and enum types in `KeywordPlanForecastIntervalEnum`.
pub mod keyword_plan_forecast_interval_enum {
    /// Forecast intervals.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanForecastInterval {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// The next week date range for keyword plan. The next week is based
        /// on the default locale of the user's account and is mostly SUN-SAT or
        /// MON-SUN.
        /// This can be different from next-7 days.
        NextWeek = 3,
        /// The next month date range for keyword plan.
        NextMonth = 4,
        /// The next quarter date range for keyword plan.
        NextQuarter = 5,
    }
    impl KeywordPlanForecastInterval {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NextWeek => "NEXT_WEEK",
                Self::NextMonth => "NEXT_MONTH",
                Self::NextQuarter => "NEXT_QUARTER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEXT_WEEK" => Some(Self::NextWeek),
                "NEXT_MONTH" => Some(Self::NextMonth),
                "NEXT_QUARTER" => Some(Self::NextQuarter),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of keyword plan keyword annotations.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanKeywordAnnotationEnum {}
/// Nested message and enum types in `KeywordPlanKeywordAnnotationEnum`.
pub mod keyword_plan_keyword_annotation_enum {
    /// Enumerates keyword plan annotations that can be requested.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanKeywordAnnotation {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Return the keyword concept and concept group data.
        KeywordConcept = 2,
    }
    impl KeywordPlanKeywordAnnotation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::KeywordConcept => "KEYWORD_CONCEPT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "KEYWORD_CONCEPT" => Some(Self::KeywordConcept),
                _ => None,
            }
        }
    }
}
/// Container for enumeration of keyword plan forecastable network types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanNetworkEnum {}
/// Nested message and enum types in `KeywordPlanNetworkEnum`.
pub mod keyword_plan_network_enum {
    /// Enumerates keyword plan forecastable network types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanNetwork {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Google Search.
        GoogleSearch = 2,
        /// Google Search + Search partners.
        GoogleSearchAndPartners = 3,
    }
    impl KeywordPlanNetwork {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::GoogleSearch => "GOOGLE_SEARCH",
                Self::GoogleSearchAndPartners => "GOOGLE_SEARCH_AND_PARTNERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "GOOGLE_SEARCH" => Some(Self::GoogleSearch),
                "GOOGLE_SEARCH_AND_PARTNERS" => Some(Self::GoogleSearchAndPartners),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible status of a label.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LabelStatusEnum {}
/// Nested message and enum types in `LabelStatusEnum`.
pub mod label_status_enum {
    /// Possible statuses of a label.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LabelStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Label is enabled.
        Enabled = 2,
        /// Label is removed.
        Removed = 3,
    }
    impl LabelStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing different types of Linked accounts.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LinkedAccountTypeEnum {}
/// Nested message and enum types in `LinkedAccountTypeEnum`.
pub mod linked_account_type_enum {
    /// Describes the possible link types between a Google Ads customer
    /// and another account.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LinkedAccountType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// A link to provide third party app analytics data.
        ThirdPartyAppAnalytics = 2,
    }
    impl LinkedAccountType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ThirdPartyAppAnalytics => "THIRD_PARTY_APP_ANALYTICS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "THIRD_PARTY_APP_ANALYTICS" => Some(Self::ThirdPartyAppAnalytics),
                _ => None,
            }
        }
    }
}
/// Container for enum describing different types of linked products.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LinkedProductTypeEnum {}
/// Nested message and enum types in `LinkedProductTypeEnum`.
pub mod linked_product_type_enum {
    /// Describes the possible link types for a link between a Google
    /// Ads customer and another product.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LinkedProductType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// A link to Data partner.
        DataPartner = 2,
        /// A link to Google Ads.
        GoogleAds = 3,
        /// A link to Hotel Center.
        HotelCenter = 7,
        /// A link to Google Merchant Center.
        MerchantCenter = 8,
        /// A link to the Google Ads account of the advertising partner.
        AdvertisingPartner = 9,
    }
    impl LinkedProductType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DataPartner => "DATA_PARTNER",
                Self::GoogleAds => "GOOGLE_ADS",
                Self::HotelCenter => "HOTEL_CENTER",
                Self::MerchantCenter => "MERCHANT_CENTER",
                Self::AdvertisingPartner => "ADVERTISING_PARTNER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DATA_PARTNER" => Some(Self::DataPartner),
                "GOOGLE_ADS" => Some(Self::GoogleAds),
                "HOTEL_CENTER" => Some(Self::HotelCenter),
                "MERCHANT_CENTER" => Some(Self::MerchantCenter),
                "ADVERTISING_PARTNER" => Some(Self::AdvertisingPartner),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the indexes of custom attribute used in
/// ListingGroupFilterDimension.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterCustomAttributeIndexEnum {}
/// Nested message and enum types in `ListingGroupFilterCustomAttributeIndexEnum`.
pub mod listing_group_filter_custom_attribute_index_enum {
    /// The index of customer attributes.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterCustomAttributeIndex {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// First listing group filter custom attribute.
        Index0 = 2,
        /// Second listing group filter custom attribute.
        Index1 = 3,
        /// Third listing group filter custom attribute.
        Index2 = 4,
        /// Fourth listing group filter custom attribute.
        Index3 = 5,
        /// Fifth listing group filter custom attribute.
        Index4 = 6,
    }
    impl ListingGroupFilterCustomAttributeIndex {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Index0 => "INDEX0",
                Self::Index1 => "INDEX1",
                Self::Index2 => "INDEX2",
                Self::Index3 => "INDEX3",
                Self::Index4 => "INDEX4",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INDEX0" => Some(Self::Index0),
                "INDEX1" => Some(Self::Index1),
                "INDEX2" => Some(Self::Index2),
                "INDEX3" => Some(Self::Index3),
                "INDEX4" => Some(Self::Index4),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the source of listings filtered by a listing
/// group filter node.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterListingSourceEnum {}
/// Nested message and enum types in `ListingGroupFilterListingSourceEnum`.
pub mod listing_group_filter_listing_source_enum {
    /// The source of listings filtered by a listing group filter node.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterListingSource {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Listings from a Shopping source, like products from Google Merchant
        /// Center.
        Shopping = 2,
        /// Listings from a webpage source, like URLs from a page feed or from the
        /// advertiser web domain.
        Webpage = 3,
    }
    impl ListingGroupFilterListingSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Shopping => "SHOPPING",
                Self::Webpage => "WEBPAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SHOPPING" => Some(Self::Shopping),
                "WEBPAGE" => Some(Self::Webpage),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the levels of product category used in
/// ListingGroupFilterDimension.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterProductCategoryLevelEnum {}
/// Nested message and enum types in `ListingGroupFilterProductCategoryLevelEnum`.
pub mod listing_group_filter_product_category_level_enum {
    /// The level of the listing group filter product category.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterProductCategoryLevel {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Level 1.
        Level1 = 2,
        /// Level 2.
        Level2 = 3,
        /// Level 3.
        Level3 = 4,
        /// Level 4.
        Level4 = 5,
        /// Level 5.
        Level5 = 6,
    }
    impl ListingGroupFilterProductCategoryLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Level1 => "LEVEL1",
                Self::Level2 => "LEVEL2",
                Self::Level3 => "LEVEL3",
                Self::Level4 => "LEVEL4",
                Self::Level5 => "LEVEL5",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LEVEL1" => Some(Self::Level1),
                "LEVEL2" => Some(Self::Level2),
                "LEVEL3" => Some(Self::Level3),
                "LEVEL4" => Some(Self::Level4),
                "LEVEL5" => Some(Self::Level5),
                _ => None,
            }
        }
    }
}
/// Locality of a product offer.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterProductChannelEnum {}
/// Nested message and enum types in `ListingGroupFilterProductChannelEnum`.
pub mod listing_group_filter_product_channel_enum {
    /// Enum describing the locality of a product offer.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterProductChannel {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The item is sold online.
        Online = 2,
        /// The item is sold in local stores.
        Local = 3,
    }
    impl ListingGroupFilterProductChannel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Online => "ONLINE",
                Self::Local => "LOCAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ONLINE" => Some(Self::Online),
                "LOCAL" => Some(Self::Local),
                _ => None,
            }
        }
    }
}
/// Condition of a product offer.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterProductConditionEnum {}
/// Nested message and enum types in `ListingGroupFilterProductConditionEnum`.
pub mod listing_group_filter_product_condition_enum {
    /// Enum describing the condition of a product offer.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterProductCondition {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The product condition is new.
        New = 2,
        /// The product condition is refurbished.
        Refurbished = 3,
        /// The product condition is used.
        Used = 4,
    }
    impl ListingGroupFilterProductCondition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::New => "NEW",
                Self::Refurbished => "REFURBISHED",
                Self::Used => "USED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEW" => Some(Self::New),
                "REFURBISHED" => Some(Self::Refurbished),
                "USED" => Some(Self::Used),
                _ => None,
            }
        }
    }
}
/// Level of the type of a product offer.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterProductTypeLevelEnum {}
/// Nested message and enum types in `ListingGroupFilterProductTypeLevelEnum`.
pub mod listing_group_filter_product_type_level_enum {
    /// Enum describing the level of the type of a product offer.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterProductTypeLevel {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Level 1.
        Level1 = 2,
        /// Level 2.
        Level2 = 3,
        /// Level 3.
        Level3 = 4,
        /// Level 4.
        Level4 = 5,
        /// Level 5.
        Level5 = 6,
    }
    impl ListingGroupFilterProductTypeLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Level1 => "LEVEL1",
                Self::Level2 => "LEVEL2",
                Self::Level3 => "LEVEL3",
                Self::Level4 => "LEVEL4",
                Self::Level5 => "LEVEL5",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LEVEL1" => Some(Self::Level1),
                "LEVEL2" => Some(Self::Level2),
                "LEVEL3" => Some(Self::Level3),
                "LEVEL4" => Some(Self::Level4),
                "LEVEL5" => Some(Self::Level5),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of the listing group filter node.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterTypeEnum {}
/// Nested message and enum types in `ListingGroupFilterTypeEnum`.
pub mod listing_group_filter_type_enum {
    /// The type of the listing group filter.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Subdivision of products along some listing dimensions.
        Subdivision = 2,
        /// An included listing group filter leaf node.
        UnitIncluded = 3,
        /// An excluded listing group filter leaf node.
        UnitExcluded = 4,
    }
    impl ListingGroupFilterType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Subdivision => "SUBDIVISION",
                Self::UnitIncluded => "UNIT_INCLUDED",
                Self::UnitExcluded => "UNIT_EXCLUDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SUBDIVISION" => Some(Self::Subdivision),
                "UNIT_INCLUDED" => Some(Self::UnitIncluded),
                "UNIT_EXCLUDED" => Some(Self::UnitExcluded),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible listing types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingTypeEnum {}
/// Nested message and enum types in `ListingTypeEnum`.
pub mod listing_type_enum {
    /// Possible listing types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// This campaign serves vehicle ads.
        Vehicles = 2,
    }
    impl ListingType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Vehicles => "VEHICLES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "VEHICLES" => Some(Self::Vehicles),
                _ => None,
            }
        }
    }
}
/// Values for Local placeholder fields.
/// For more information about dynamic remarketing feeds, see
/// <https://support.google.com/google-ads/answer/6053288.>
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalPlaceholderFieldEnum {}
/// Nested message and enum types in `LocalPlaceholderFieldEnum`.
pub mod local_placeholder_field_enum {
    /// Possible values for Local placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalPlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. Required. Unique ID.
        DealId = 2,
        /// Data Type: STRING. Required. Main headline with local deal title to be
        /// shown in dynamic ad.
        DealName = 3,
        /// Data Type: STRING. Local deal subtitle to be shown in dynamic ad.
        Subtitle = 4,
        /// Data Type: STRING. Description of local deal to be shown in dynamic ad.
        Description = 5,
        /// Data Type: STRING. Price to be shown in the ad. Highly recommended for
        /// dynamic ads. Example: "100.00 USD"
        Price = 6,
        /// Data Type: STRING. Formatted price to be shown in the ad.
        /// Example: "Starting at $100.00 USD", "$80 - $100"
        FormattedPrice = 7,
        /// Data Type: STRING. Sale price to be shown in the ad.
        /// Example: "80.00 USD"
        SalePrice = 8,
        /// Data Type: STRING. Formatted sale price to be shown in the ad.
        /// Example: "On sale for $80.00", "$60 - $80"
        FormattedSalePrice = 9,
        /// Data Type: URL. Image to be displayed in the ad.
        ImageUrl = 10,
        /// Data Type: STRING. Complete property address, including postal code.
        Address = 11,
        /// Data Type: STRING. Category of local deal used to group like items
        /// together for recommendation engine.
        Category = 12,
        /// Data Type: STRING_LIST. Keywords used for product retrieval.
        ContextualKeywords = 13,
        /// Data Type: URL_LIST. Required. Final URLs to be used in ad when using
        /// Upgraded URLs; the more specific the better (for example, the individual
        /// URL of a specific local deal and its location).
        FinalUrls = 14,
        /// Data Type: URL_LIST. Final mobile URLs for the ad when using Upgraded
        /// URLs.
        FinalMobileUrls = 15,
        /// Data Type: URL. Tracking template for the ad when using Upgraded URLs.
        TrackingUrl = 16,
        /// Data Type: STRING. Android app link. Must be formatted as:
        /// android-app://{package_id}/{scheme}/{host_path}.
        /// The components are defined as follows:
        /// package_id: app ID as specified in Google Play.
        /// scheme: the scheme to pass to the application. Can be HTTP, or a custom
        ///    scheme.
        /// host_path: identifies the specific content within your application.
        AndroidAppLink = 17,
        /// Data Type: STRING_LIST. List of recommended local deal IDs to show
        /// together with this item.
        SimilarDealIds = 18,
        /// Data Type: STRING. iOS app link.
        IosAppLink = 19,
        /// Data Type: INT64. iOS app store ID.
        IosAppStoreId = 20,
    }
    impl LocalPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DealId => "DEAL_ID",
                Self::DealName => "DEAL_NAME",
                Self::Subtitle => "SUBTITLE",
                Self::Description => "DESCRIPTION",
                Self::Price => "PRICE",
                Self::FormattedPrice => "FORMATTED_PRICE",
                Self::SalePrice => "SALE_PRICE",
                Self::FormattedSalePrice => "FORMATTED_SALE_PRICE",
                Self::ImageUrl => "IMAGE_URL",
                Self::Address => "ADDRESS",
                Self::Category => "CATEGORY",
                Self::ContextualKeywords => "CONTEXTUAL_KEYWORDS",
                Self::FinalUrls => "FINAL_URLS",
                Self::FinalMobileUrls => "FINAL_MOBILE_URLS",
                Self::TrackingUrl => "TRACKING_URL",
                Self::AndroidAppLink => "ANDROID_APP_LINK",
                Self::SimilarDealIds => "SIMILAR_DEAL_IDS",
                Self::IosAppLink => "IOS_APP_LINK",
                Self::IosAppStoreId => "IOS_APP_STORE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DEAL_ID" => Some(Self::DealId),
                "DEAL_NAME" => Some(Self::DealName),
                "SUBTITLE" => Some(Self::Subtitle),
                "DESCRIPTION" => Some(Self::Description),
                "PRICE" => Some(Self::Price),
                "FORMATTED_PRICE" => Some(Self::FormattedPrice),
                "SALE_PRICE" => Some(Self::SalePrice),
                "FORMATTED_SALE_PRICE" => Some(Self::FormattedSalePrice),
                "IMAGE_URL" => Some(Self::ImageUrl),
                "ADDRESS" => Some(Self::Address),
                "CATEGORY" => Some(Self::Category),
                "CONTEXTUAL_KEYWORDS" => Some(Self::ContextualKeywords),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "ANDROID_APP_LINK" => Some(Self::AndroidAppLink),
                "SIMILAR_DEAL_IDS" => Some(Self::SimilarDealIds),
                "IOS_APP_LINK" => Some(Self::IosAppLink),
                "IOS_APP_STORE_ID" => Some(Self::IosAppStoreId),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the rejection reason of a local services
/// business registration check verification artifact.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesBusinessRegistrationCheckRejectionReasonEnum {}
/// Nested message and enum types in `LocalServicesBusinessRegistrationCheckRejectionReasonEnum`.
pub mod local_services_business_registration_check_rejection_reason_enum {
    /// Enums describing possible rejection reasons of a local services business
    /// registration check verification artifact.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesBusinessRegistrationCheckRejectionReason {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Business name doesn't match business name for the Local Services Ad.
        BusinessNameMismatch = 2,
        /// Business details mismatch.
        BusinessDetailsMismatch = 3,
        /// Business registration ID not found.
        IdNotFound = 4,
        /// Uploaded document not clear, blurry, etc.
        PoorDocumentImageQuality = 5,
        /// Uploaded document has expired.
        DocumentExpired = 6,
        /// Document revoked or annuled.
        DocumentInvalid = 7,
        /// Document type mismatch.
        DocumentTypeMismatch = 8,
        /// Uploaded document could not be verified as legitimate.
        DocumentUnverifiable = 9,
        /// The business registration process could not be completed due to an issue.
        /// Contact <https://support.google.com/localservices> to learn more.
        Other = 10,
    }
    impl LocalServicesBusinessRegistrationCheckRejectionReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::BusinessNameMismatch => "BUSINESS_NAME_MISMATCH",
                Self::BusinessDetailsMismatch => "BUSINESS_DETAILS_MISMATCH",
                Self::IdNotFound => "ID_NOT_FOUND",
                Self::PoorDocumentImageQuality => "POOR_DOCUMENT_IMAGE_QUALITY",
                Self::DocumentExpired => "DOCUMENT_EXPIRED",
                Self::DocumentInvalid => "DOCUMENT_INVALID",
                Self::DocumentTypeMismatch => "DOCUMENT_TYPE_MISMATCH",
                Self::DocumentUnverifiable => "DOCUMENT_UNVERIFIABLE",
                Self::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_NAME_MISMATCH" => Some(Self::BusinessNameMismatch),
                "BUSINESS_DETAILS_MISMATCH" => Some(Self::BusinessDetailsMismatch),
                "ID_NOT_FOUND" => Some(Self::IdNotFound),
                "POOR_DOCUMENT_IMAGE_QUALITY" => Some(Self::PoorDocumentImageQuality),
                "DOCUMENT_EXPIRED" => Some(Self::DocumentExpired),
                "DOCUMENT_INVALID" => Some(Self::DocumentInvalid),
                "DOCUMENT_TYPE_MISMATCH" => Some(Self::DocumentTypeMismatch),
                "DOCUMENT_UNVERIFIABLE" => Some(Self::DocumentUnverifiable),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of business registration check
/// verification artifact.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesBusinessRegistrationTypeEnum {}
/// Nested message and enum types in `LocalServicesBusinessRegistrationTypeEnum`.
pub mod local_services_business_registration_type_enum {
    /// Enums describing possible registration types of a local services business
    /// registration check verification artifact.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesBusinessRegistrationType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Registration number check type.
        Number = 2,
        /// Registration document check type.
        Document = 3,
    }
    impl LocalServicesBusinessRegistrationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Number => "NUMBER",
                Self::Document => "DOCUMENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NUMBER" => Some(Self::Number),
                "DOCUMENT" => Some(Self::Document),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible types of lead conversation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesLeadConversationTypeEnum {}
/// Nested message and enum types in `LocalServicesLeadConversationTypeEnum`.
pub mod local_services_lead_conversation_type_enum {
    /// Possible types of lead conversation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversationType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Email lead conversation.
        Email = 2,
        /// Message lead conversation.
        Message = 3,
        /// Phone call lead conversation.
        PhoneCall = 4,
        /// SMS lead conversation.
        Sms = 5,
        /// Booking lead conversation.
        Booking = 6,
    }
    impl ConversationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Email => "EMAIL",
                Self::Message => "MESSAGE",
                Self::PhoneCall => "PHONE_CALL",
                Self::Sms => "SMS",
                Self::Booking => "BOOKING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EMAIL" => Some(Self::Email),
                "MESSAGE" => Some(Self::Message),
                "PHONE_CALL" => Some(Self::PhoneCall),
                "SMS" => Some(Self::Sms),
                "BOOKING" => Some(Self::Booking),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the status of local services employee.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesEmployeeStatusEnum {}
/// Nested message and enum types in `LocalServicesEmployeeStatusEnum`.
pub mod local_services_employee_status_enum {
    /// Enums describing statuses of a local services employee.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesEmployeeStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Employee is not removed, and employee status is active.
        Enabled = 2,
        /// Employee is removed. Used to delete an employee from the business.
        Removed = 3,
    }
    impl LocalServicesEmployeeStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the types of local services employee.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesEmployeeTypeEnum {}
/// Nested message and enum types in `LocalServicesEmployeeTypeEnum`.
pub mod local_services_employee_type_enum {
    /// Enums describing types of a local services employee.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesEmployeeType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Represents the owner of the business.
        BusinessOwner = 2,
        /// Represents an employee of the business.
        Employee = 3,
    }
    impl LocalServicesEmployeeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::BusinessOwner => "BUSINESS_OWNER",
                Self::Employee => "EMPLOYEE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_OWNER" => Some(Self::BusinessOwner),
                "EMPLOYEE" => Some(Self::Employee),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the rejection reason of a local services
/// insurance verification artifact.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesInsuranceRejectionReasonEnum {}
/// Nested message and enum types in `LocalServicesInsuranceRejectionReasonEnum`.
pub mod local_services_insurance_rejection_reason_enum {
    /// Enums describing possible rejection reasons of a local services insurance
    /// verification artifact.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesInsuranceRejectionReason {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Business name doesn't match business name for the Local Services Ad.
        BusinessNameMismatch = 2,
        /// Insurance amount doesn't meet requirement listed in the legal summaries
        /// documentation for that geographic + category ID combination.
        InsuranceAmountInsufficient = 3,
        /// Insurance document is expired.
        Expired = 4,
        /// Insurance document is missing a signature.
        NoSignature = 5,
        /// Insurance document is missing a policy number.
        NoPolicyNumber = 6,
        /// Commercial General Liability(CGL) box is not marked in the insurance
        /// document.
        NoCommercialGeneralLiability = 7,
        /// Insurance document is in an editable format.
        EditableFormat = 8,
        /// Insurance document does not cover insurance for a particular category.
        CategoryMismatch = 9,
        /// Insurance document is missing an expiration date.
        MissingExpirationDate = 10,
        /// Insurance document is poor quality - blurry images, illegible, etc...
        PoorQuality = 11,
        /// Insurance document is suspected of being edited.
        PotentiallyEdited = 12,
        /// Insurance document not accepted. For example, documents of insurance
        /// proposals, but missing coverages are not accepted.
        WrongDocumentType = 13,
        /// Insurance document is not final.
        NonFinal = 14,
        /// Insurance document has another flaw not listed explicitly.
        Other = 15,
    }
    impl LocalServicesInsuranceRejectionReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::BusinessNameMismatch => "BUSINESS_NAME_MISMATCH",
                Self::InsuranceAmountInsufficient => "INSURANCE_AMOUNT_INSUFFICIENT",
                Self::Expired => "EXPIRED",
                Self::NoSignature => "NO_SIGNATURE",
                Self::NoPolicyNumber => "NO_POLICY_NUMBER",
                Self::NoCommercialGeneralLiability => "NO_COMMERCIAL_GENERAL_LIABILITY",
                Self::EditableFormat => "EDITABLE_FORMAT",
                Self::CategoryMismatch => "CATEGORY_MISMATCH",
                Self::MissingExpirationDate => "MISSING_EXPIRATION_DATE",
                Self::PoorQuality => "POOR_QUALITY",
                Self::PotentiallyEdited => "POTENTIALLY_EDITED",
                Self::WrongDocumentType => "WRONG_DOCUMENT_TYPE",
                Self::NonFinal => "NON_FINAL",
                Self::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_NAME_MISMATCH" => Some(Self::BusinessNameMismatch),
                "INSURANCE_AMOUNT_INSUFFICIENT" => {
                    Some(Self::InsuranceAmountInsufficient)
                }
                "EXPIRED" => Some(Self::Expired),
                "NO_SIGNATURE" => Some(Self::NoSignature),
                "NO_POLICY_NUMBER" => Some(Self::NoPolicyNumber),
                "NO_COMMERCIAL_GENERAL_LIABILITY" => {
                    Some(Self::NoCommercialGeneralLiability)
                }
                "EDITABLE_FORMAT" => Some(Self::EditableFormat),
                "CATEGORY_MISMATCH" => Some(Self::CategoryMismatch),
                "MISSING_EXPIRATION_DATE" => Some(Self::MissingExpirationDate),
                "POOR_QUALITY" => Some(Self::PoorQuality),
                "POTENTIALLY_EDITED" => Some(Self::PotentiallyEdited),
                "WRONG_DOCUMENT_TYPE" => Some(Self::WrongDocumentType),
                "NON_FINAL" => Some(Self::NonFinal),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible credit states of a lead.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesCreditStateEnum {}
/// Nested message and enum types in `LocalServicesCreditStateEnum`.
pub mod local_services_credit_state_enum {
    /// Possible credit states of a lead.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CreditState {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Credit is pending.
        Pending = 2,
        /// Credit request is complete.
        Credited = 3,
    }
    impl CreditState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Pending => "PENDING",
                Self::Credited => "CREDITED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "CREDITED" => Some(Self::Credited),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of lead.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesLeadStatusEnum {}
/// Nested message and enum types in `LocalServicesLeadStatusEnum`.
pub mod local_services_lead_status_enum {
    /// Possible statuses of lead.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LeadStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// New lead which hasn't yet been seen by advertiser.
        New = 2,
        /// Lead that thas been interacted by advertiser.
        Active = 3,
        /// Lead has been booked.
        Booked = 4,
        /// Lead was declined by advertiser.
        Declined = 5,
        /// Lead has expired due to inactivity.
        Expired = 6,
        /// Disabled due to spam or dispute.
        Disabled = 7,
        /// Consumer declined the lead.
        ConsumerDeclined = 8,
        /// Personally Identifiable Information of the lead is wiped out.
        WipedOut = 9,
    }
    impl LeadStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::New => "NEW",
                Self::Active => "ACTIVE",
                Self::Booked => "BOOKED",
                Self::Declined => "DECLINED",
                Self::Expired => "EXPIRED",
                Self::Disabled => "DISABLED",
                Self::ConsumerDeclined => "CONSUMER_DECLINED",
                Self::WipedOut => "WIPED_OUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEW" => Some(Self::New),
                "ACTIVE" => Some(Self::Active),
                "BOOKED" => Some(Self::Booked),
                "DECLINED" => Some(Self::Declined),
                "EXPIRED" => Some(Self::Expired),
                "DISABLED" => Some(Self::Disabled),
                "CONSUMER_DECLINED" => Some(Self::ConsumerDeclined),
                "WIPED_OUT" => Some(Self::WipedOut),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible types of lead.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesLeadTypeEnum {}
/// Nested message and enum types in `LocalServicesLeadTypeEnum`.
pub mod local_services_lead_type_enum {
    /// Possible types of lead.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LeadType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Message lead.
        Message = 2,
        /// Lead created by phone call.
        PhoneCall = 3,
        /// Booking lead.
        Booking = 4,
    }
    impl LeadType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Message => "MESSAGE",
                Self::PhoneCall => "PHONE_CALL",
                Self::Booking => "BOOKING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MESSAGE" => Some(Self::Message),
                "PHONE_CALL" => Some(Self::PhoneCall),
                "BOOKING" => Some(Self::Booking),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the rejection reason of a local services
/// license verification artifact.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesLicenseRejectionReasonEnum {}
/// Nested message and enum types in `LocalServicesLicenseRejectionReasonEnum`.
pub mod local_services_license_rejection_reason_enum {
    /// Enums describing possible rejection reasons of a local services license
    /// verification artifact.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesLicenseRejectionReason {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Business name doesn't match business name for the Local Services Ad.
        BusinessNameMismatch = 2,
        /// License is unauthorized or been revoked.
        Unauthorized = 3,
        /// License is expired.
        Expired = 4,
        /// License is poor quality - blurry images, illegible, etc...
        PoorQuality = 5,
        /// License cannot be verified due to a not legitimate image.
        Unverifiable = 6,
        /// License is not the requested document type or contains an invalid ID.
        WrongDocumentOrId = 7,
        /// License has another flaw not listed explicitly.
        Other = 8,
    }
    impl LocalServicesLicenseRejectionReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::BusinessNameMismatch => "BUSINESS_NAME_MISMATCH",
                Self::Unauthorized => "UNAUTHORIZED",
                Self::Expired => "EXPIRED",
                Self::PoorQuality => "POOR_QUALITY",
                Self::Unverifiable => "UNVERIFIABLE",
                Self::WrongDocumentOrId => "WRONG_DOCUMENT_OR_ID",
                Self::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_NAME_MISMATCH" => Some(Self::BusinessNameMismatch),
                "UNAUTHORIZED" => Some(Self::Unauthorized),
                "EXPIRED" => Some(Self::Expired),
                "POOR_QUALITY" => Some(Self::PoorQuality),
                "UNVERIFIABLE" => Some(Self::Unverifiable),
                "WRONG_DOCUMENT_OR_ID" => Some(Self::WrongDocumentOrId),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible types of lead conversation
/// participants.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesParticipantTypeEnum {}
/// Nested message and enum types in `LocalServicesParticipantTypeEnum`.
pub mod local_services_participant_type_enum {
    /// Possible types of lead conversation participant.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ParticipantType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Local Services Ads Provider participant.
        Advertiser = 2,
        /// Local Services Ads Consumer participant.
        Consumer = 3,
    }
    impl ParticipantType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Advertiser => "ADVERTISER",
                Self::Consumer => "CONSUMER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADVERTISER" => Some(Self::Advertiser),
                "CONSUMER" => Some(Self::Consumer),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the status of local services verification
/// artifact.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesVerificationArtifactStatusEnum {}
/// Nested message and enum types in `LocalServicesVerificationArtifactStatusEnum`.
pub mod local_services_verification_artifact_status_enum {
    /// Enums describing statuses of a local services verification artifact.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesVerificationArtifactStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Artifact has passed verification.
        Passed = 2,
        /// Artifact has failed verification.
        Failed = 3,
        /// Artifact is in the process of verification.
        Pending = 4,
        /// Artifact needs user to upload information before it is verified.
        NoSubmission = 5,
        /// Artifact has been cancelled by the user.
        Cancelled = 6,
    }
    impl LocalServicesVerificationArtifactStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Passed => "PASSED",
                Self::Failed => "FAILED",
                Self::Pending => "PENDING",
                Self::NoSubmission => "NO_SUBMISSION",
                Self::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PASSED" => Some(Self::Passed),
                "FAILED" => Some(Self::Failed),
                "PENDING" => Some(Self::Pending),
                "NO_SUBMISSION" => Some(Self::NoSubmission),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of local services verification
/// artifact.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesVerificationArtifactTypeEnum {}
/// Nested message and enum types in `LocalServicesVerificationArtifactTypeEnum`.
pub mod local_services_verification_artifact_type_enum {
    /// Enums describing possible types of local services verification artifact.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesVerificationArtifactType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Background check verification artifact.
        BackgroundCheck = 2,
        /// Insurance verification artifact.
        Insurance = 3,
        /// License verification artifact.
        License = 4,
        /// Business registration check verification artifact.
        BusinessRegistrationCheck = 5,
    }
    impl LocalServicesVerificationArtifactType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::BackgroundCheck => "BACKGROUND_CHECK",
                Self::Insurance => "INSURANCE",
                Self::License => "LICENSE",
                Self::BusinessRegistrationCheck => "BUSINESS_REGISTRATION_CHECK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BACKGROUND_CHECK" => Some(Self::BackgroundCheck),
                "INSURANCE" => Some(Self::Insurance),
                "LICENSE" => Some(Self::License),
                "BUSINESS_REGISTRATION_CHECK" => Some(Self::BusinessRegistrationCheck),
                _ => None,
            }
        }
    }
}
/// Container for enum describing status of a particular Local Services Ads
/// verification category.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesVerificationStatusEnum {}
/// Nested message and enum types in `LocalServicesVerificationStatusEnum`.
pub mod local_services_verification_status_enum {
    /// Enum describing status of a particular Local Services Ads verification
    /// category.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesVerificationStatus {
        /// Not specified.
        Unspecified = 0,
        /// Unknown verification status.
        Unknown = 1,
        /// Verification has started, but has not finished.
        NeedsReview = 2,
        /// Verification has failed.
        Failed = 3,
        /// Verification has passed.
        Passed = 4,
        /// Verification is not applicable.
        NotApplicable = 5,
        /// Verification is required but pending submission.
        NoSubmission = 6,
        /// Not all required verification has been submitted.
        PartialSubmission = 7,
        /// Verification needs review by Local Services Ads Ops Specialist.
        PendingEscalation = 8,
    }
    impl LocalServicesVerificationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NeedsReview => "NEEDS_REVIEW",
                Self::Failed => "FAILED",
                Self::Passed => "PASSED",
                Self::NotApplicable => "NOT_APPLICABLE",
                Self::NoSubmission => "NO_SUBMISSION",
                Self::PartialSubmission => "PARTIAL_SUBMISSION",
                Self::PendingEscalation => "PENDING_ESCALATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEEDS_REVIEW" => Some(Self::NeedsReview),
                "FAILED" => Some(Self::Failed),
                "PASSED" => Some(Self::Passed),
                "NOT_APPLICABLE" => Some(Self::NotApplicable),
                "NO_SUBMISSION" => Some(Self::NoSubmission),
                "PARTIAL_SUBMISSION" => Some(Self::PartialSubmission),
                "PENDING_ESCALATION" => Some(Self::PendingEscalation),
                _ => None,
            }
        }
    }
}
/// Values for Location Extension Targeting criterion fields.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationExtensionTargetingCriterionFieldEnum {}
/// Nested message and enum types in `LocationExtensionTargetingCriterionFieldEnum`.
pub mod location_extension_targeting_criterion_field_enum {
    /// Possible values for Location Extension Targeting criterion fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationExtensionTargetingCriterionField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. Line 1 of the business address.
        AddressLine1 = 2,
        /// Data Type: STRING. Line 2 of the business address.
        AddressLine2 = 3,
        /// Data Type: STRING. City of the business address.
        City = 4,
        /// Data Type: STRING. Province of the business address.
        Province = 5,
        /// Data Type: STRING. Postal code of the business address.
        PostalCode = 6,
        /// Data Type: STRING. Country code of the business address.
        CountryCode = 7,
    }
    impl LocationExtensionTargetingCriterionField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AddressLine1 => "ADDRESS_LINE_1",
                Self::AddressLine2 => "ADDRESS_LINE_2",
                Self::City => "CITY",
                Self::Province => "PROVINCE",
                Self::PostalCode => "POSTAL_CODE",
                Self::CountryCode => "COUNTRY_CODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADDRESS_LINE_1" => Some(Self::AddressLine1),
                "ADDRESS_LINE_2" => Some(Self::AddressLine2),
                "CITY" => Some(Self::City),
                "PROVINCE" => Some(Self::Province),
                "POSTAL_CODE" => Some(Self::PostalCode),
                "COUNTRY_CODE" => Some(Self::CountryCode),
                _ => None,
            }
        }
    }
}
/// Values for Location placeholder fields.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationPlaceholderFieldEnum {}
/// Nested message and enum types in `LocationPlaceholderFieldEnum`.
pub mod location_placeholder_field_enum {
    /// Possible values for Location placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationPlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. The name of the business.
        BusinessName = 2,
        /// Data Type: STRING. Line 1 of the business address.
        AddressLine1 = 3,
        /// Data Type: STRING. Line 2 of the business address.
        AddressLine2 = 4,
        /// Data Type: STRING. City of the business address.
        City = 5,
        /// Data Type: STRING. Province of the business address.
        Province = 6,
        /// Data Type: STRING. Postal code of the business address.
        PostalCode = 7,
        /// Data Type: STRING. Country code of the business address.
        CountryCode = 8,
        /// Data Type: STRING. Phone number of the business.
        PhoneNumber = 9,
    }
    impl LocationPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::BusinessName => "BUSINESS_NAME",
                Self::AddressLine1 => "ADDRESS_LINE_1",
                Self::AddressLine2 => "ADDRESS_LINE_2",
                Self::City => "CITY",
                Self::Province => "PROVINCE",
                Self::PostalCode => "POSTAL_CODE",
                Self::CountryCode => "COUNTRY_CODE",
                Self::PhoneNumber => "PHONE_NUMBER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_NAME" => Some(Self::BusinessName),
                "ADDRESS_LINE_1" => Some(Self::AddressLine1),
                "ADDRESS_LINE_2" => Some(Self::AddressLine2),
                "CITY" => Some(Self::City),
                "PROVINCE" => Some(Self::Province),
                "POSTAL_CODE" => Some(Self::PostalCode),
                "COUNTRY_CODE" => Some(Self::CountryCode),
                "PHONE_NUMBER" => Some(Self::PhoneNumber),
                _ => None,
            }
        }
    }
}
/// Used to distinguish the location source type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationSourceTypeEnum {}
/// Nested message and enum types in `LocationSourceTypeEnum`.
pub mod location_source_type_enum {
    /// The possible types of a location source.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationSourceType {
        /// No value has been specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Locations associated with the customer's linked Business Profile.
        GoogleMyBusiness = 2,
        /// Affiliate (chain) store locations. For example, Best Buy store locations.
        Affiliate = 3,
    }
    impl LocationSourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::GoogleMyBusiness => "GOOGLE_MY_BUSINESS",
                Self::Affiliate => "AFFILIATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "GOOGLE_MY_BUSINESS" => Some(Self::GoogleMyBusiness),
                "AFFILIATE" => Some(Self::Affiliate),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible status of a manager and client link.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ManagerLinkStatusEnum {}
/// Nested message and enum types in `ManagerLinkStatusEnum`.
pub mod manager_link_status_enum {
    /// Possible statuses of a link.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ManagerLinkStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Indicates current in-effect relationship
        Active = 2,
        /// Indicates terminated relationship
        Inactive = 3,
        /// Indicates relationship has been requested by manager, but the client
        /// hasn't accepted yet.
        Pending = 4,
        /// Relationship was requested by the manager, but the client has refused.
        Refused = 5,
        /// Indicates relationship has been requested by manager, but manager
        /// canceled it.
        Canceled = 6,
    }
    impl ManagerLinkStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
                Self::Pending => "PENDING",
                Self::Refused => "REFUSED",
                Self::Canceled => "CANCELED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                "PENDING" => Some(Self::Pending),
                "REFUSED" => Some(Self::Refused),
                "CANCELED" => Some(Self::Canceled),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the types of media.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MediaTypeEnum {}
/// Nested message and enum types in `MediaTypeEnum`.
pub mod media_type_enum {
    /// The type of media.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MediaType {
        /// The media type has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// Static image, used for image ad.
        Image = 2,
        /// Small image, used for map ad.
        Icon = 3,
        /// ZIP file, used in fields of template ads.
        MediaBundle = 4,
        /// Audio file.
        Audio = 5,
        /// Video file.
        Video = 6,
        /// Animated image, such as animated GIF.
        DynamicImage = 7,
    }
    impl MediaType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Image => "IMAGE",
                Self::Icon => "ICON",
                Self::MediaBundle => "MEDIA_BUNDLE",
                Self::Audio => "AUDIO",
                Self::Video => "VIDEO",
                Self::DynamicImage => "DYNAMIC_IMAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "IMAGE" => Some(Self::Image),
                "ICON" => Some(Self::Icon),
                "MEDIA_BUNDLE" => Some(Self::MediaBundle),
                "AUDIO" => Some(Self::Audio),
                "VIDEO" => Some(Self::Video),
                "DYNAMIC_IMAGE" => Some(Self::DynamicImage),
                _ => None,
            }
        }
    }
}
/// Values for Message placeholder fields.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MessagePlaceholderFieldEnum {}
/// Nested message and enum types in `MessagePlaceholderFieldEnum`.
pub mod message_placeholder_field_enum {
    /// Possible values for Message placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MessagePlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. The name of your business.
        BusinessName = 2,
        /// Data Type: STRING. Country code of phone number.
        CountryCode = 3,
        /// Data Type: STRING. A phone number that's capable of sending and receiving
        /// text messages.
        PhoneNumber = 4,
        /// Data Type: STRING. The text that will go in your click-to-message ad.
        MessageExtensionText = 5,
        /// Data Type: STRING. The message text automatically shows in people's
        /// messaging apps when they tap to send you a message.
        MessageText = 6,
    }
    impl MessagePlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::BusinessName => "BUSINESS_NAME",
                Self::CountryCode => "COUNTRY_CODE",
                Self::PhoneNumber => "PHONE_NUMBER",
                Self::MessageExtensionText => "MESSAGE_EXTENSION_TEXT",
                Self::MessageText => "MESSAGE_TEXT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_NAME" => Some(Self::BusinessName),
                "COUNTRY_CODE" => Some(Self::CountryCode),
                "PHONE_NUMBER" => Some(Self::PhoneNumber),
                "MESSAGE_EXTENSION_TEXT" => Some(Self::MessageExtensionText),
                "MESSAGE_TEXT" => Some(Self::MessageText),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the types of mobile device.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MobileDeviceTypeEnum {}
/// Nested message and enum types in `MobileDeviceTypeEnum`.
pub mod mobile_device_type_enum {
    /// The type of mobile device.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MobileDeviceType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Mobile phones.
        Mobile = 2,
        /// Tablets.
        Tablet = 3,
    }
    impl MobileDeviceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Mobile => "MOBILE",
                Self::Tablet => "TABLET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MOBILE" => Some(Self::Mobile),
                "TABLET" => Some(Self::Tablet),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible negative geo target types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NegativeGeoTargetTypeEnum {}
/// Nested message and enum types in `NegativeGeoTargetTypeEnum`.
pub mod negative_geo_target_type_enum {
    /// The possible negative geo target types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NegativeGeoTargetType {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Specifies that a user is excluded from seeing the ad if they
        /// are in, or show interest in, advertiser's excluded locations.
        PresenceOrInterest = 4,
        /// Specifies that a user is excluded from seeing the ad if they
        /// are in advertiser's excluded locations.
        Presence = 5,
    }
    impl NegativeGeoTargetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::PresenceOrInterest => "PRESENCE_OR_INTEREST",
                Self::Presence => "PRESENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PRESENCE_OR_INTEREST" => Some(Self::PresenceOrInterest),
                "PRESENCE" => Some(Self::Presence),
                _ => None,
            }
        }
    }
}
/// All possible statuses for oci diagnostics.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfflineConversionDiagnosticStatusEnum {}
/// Nested message and enum types in `OfflineConversionDiagnosticStatusEnum`.
pub mod offline_conversion_diagnostic_status_enum {
    /// Possible statuses of the offline ingestion setup.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OfflineConversionDiagnosticStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Your offline data ingestion setup is active and optimal for downstream
        /// processing.
        Excellent = 2,
        /// Your offline ingestion setup is active, but there are further
        /// improvements you could make. See alerts.
        Good = 3,
        /// Your offline ingestion setup is active, but there are errors that require
        /// your attention. See alerts.
        NeedsAttention = 4,
        /// Your offline ingestion setup has not received data in the last 28 days,
        /// there may be something wrong.
        NoRecentUpload = 6,
    }
    impl OfflineConversionDiagnosticStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Excellent => "EXCELLENT",
                Self::Good => "GOOD",
                Self::NeedsAttention => "NEEDS_ATTENTION",
                Self::NoRecentUpload => "NO_RECENT_UPLOAD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXCELLENT" => Some(Self::Excellent),
                "GOOD" => Some(Self::Good),
                "NEEDS_ATTENTION" => Some(Self::NeedsAttention),
                "NO_RECENT_UPLOAD" => Some(Self::NoRecentUpload),
                _ => None,
            }
        }
    }
}
/// All possible clients for an offline upload event.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfflineEventUploadClientEnum {}
/// Nested message and enum types in `OfflineEventUploadClientEnum`.
pub mod offline_event_upload_client_enum {
    /// Type of client.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OfflineEventUploadClient {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Google Ads API.
        GoogleAdsApi = 2,
        /// Google Ads web client, which could include multiple sources like Ads UI,
        /// SFTP, etc.
        GoogleAdsWebClient = 3,
        /// Connection platform.
        AdsDataConnector = 4,
    }
    impl OfflineEventUploadClient {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::GoogleAdsApi => "GOOGLE_ADS_API",
                Self::GoogleAdsWebClient => "GOOGLE_ADS_WEB_CLIENT",
                Self::AdsDataConnector => "ADS_DATA_CONNECTOR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "GOOGLE_ADS_API" => Some(Self::GoogleAdsApi),
                "GOOGLE_ADS_WEB_CLIENT" => Some(Self::GoogleAdsWebClient),
                "ADS_DATA_CONNECTOR" => Some(Self::AdsDataConnector),
                _ => None,
            }
        }
    }
}
/// Container for enum describing reasons why an offline user data job
/// failed to be processed.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfflineUserDataJobFailureReasonEnum {}
/// Nested message and enum types in `OfflineUserDataJobFailureReasonEnum`.
pub mod offline_user_data_job_failure_reason_enum {
    /// The failure reason of an offline user data job.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OfflineUserDataJobFailureReason {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The matched transactions are insufficient.
        InsufficientMatchedTransactions = 2,
        /// The uploaded transactions are insufficient.
        InsufficientTransactions = 3,
        /// The average transaction value is unusually high for your account. If this
        ///   is intended, contact support to request an exception. Learn more at
        ///   <https://support.google.com/google-ads/answer/10018944#transaction_value>
        HighAverageTransactionValue = 4,
        /// The average transaction value is unusually low for your account. If this
        /// is intended, contact support to request an exception. Learn more at
        /// <https://support.google.com/google-ads/answer/10018944#transaction_value>
        LowAverageTransactionValue = 5,
        /// There's a currency code that you haven't used before in your uploads. If
        /// this is intended, contact support to request an exception. Learn more at
        /// <https://support.google.com/google-ads/answer/10018944#Unrecognized_currency>
        NewlyObservedCurrencyCode = 6,
    }
    impl OfflineUserDataJobFailureReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InsufficientMatchedTransactions => {
                    "INSUFFICIENT_MATCHED_TRANSACTIONS"
                }
                Self::InsufficientTransactions => "INSUFFICIENT_TRANSACTIONS",
                Self::HighAverageTransactionValue => "HIGH_AVERAGE_TRANSACTION_VALUE",
                Self::LowAverageTransactionValue => "LOW_AVERAGE_TRANSACTION_VALUE",
                Self::NewlyObservedCurrencyCode => "NEWLY_OBSERVED_CURRENCY_CODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INSUFFICIENT_MATCHED_TRANSACTIONS" => {
                    Some(Self::InsufficientMatchedTransactions)
                }
                "INSUFFICIENT_TRANSACTIONS" => Some(Self::InsufficientTransactions),
                "HIGH_AVERAGE_TRANSACTION_VALUE" => {
                    Some(Self::HighAverageTransactionValue)
                }
                "LOW_AVERAGE_TRANSACTION_VALUE" => Some(Self::LowAverageTransactionValue),
                "NEWLY_OBSERVED_CURRENCY_CODE" => Some(Self::NewlyObservedCurrencyCode),
                _ => None,
            }
        }
    }
}
/// Container for enum describing reasons match rate ranges for a customer match
/// list upload.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfflineUserDataJobMatchRateRangeEnum {}
/// Nested message and enum types in `OfflineUserDataJobMatchRateRangeEnum`.
pub mod offline_user_data_job_match_rate_range_enum {
    /// The match rate range of an offline user data job.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OfflineUserDataJobMatchRateRange {
        /// Not specified.
        Unspecified = 0,
        /// Default value for match rate range.
        Unknown = 1,
        /// Match rate range for offline data upload entity is between 0% and 19%.
        MatchRangeLessThan20 = 2,
        /// Match rate range for offline data upload entity is between 20% and 30%.
        MatchRange20To30 = 3,
        /// Match rate range for offline data upload entity is between 31% and 40%.
        MatchRange31To40 = 4,
        /// Match rate range for offline data upload entity is between 41% and 50%.
        MatchRange41To50 = 5,
        /// Match rate range for offline data upload entity is between 51% and 60%.
        MatchRange51To60 = 6,
        /// Match rate range for offline data upload entity is between 61% and 70%.
        MatchRange61To70 = 7,
        /// Match rate range for offline data upload entity is between 71% and 80%.
        MatchRange71To80 = 8,
        /// Match rate range for offline data upload entity is between 81% and 90%.
        MatchRange81To90 = 9,
        /// Match rate range for offline data upload entity is more than or equal to
        /// 91%.
        MatchRange91To100 = 10,
    }
    impl OfflineUserDataJobMatchRateRange {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::MatchRangeLessThan20 => "MATCH_RANGE_LESS_THAN_20",
                Self::MatchRange20To30 => "MATCH_RANGE_20_TO_30",
                Self::MatchRange31To40 => "MATCH_RANGE_31_TO_40",
                Self::MatchRange41To50 => "MATCH_RANGE_41_TO_50",
                Self::MatchRange51To60 => "MATCH_RANGE_51_TO_60",
                Self::MatchRange61To70 => "MATCH_RANGE_61_TO_70",
                Self::MatchRange71To80 => "MATCH_RANGE_71_TO_80",
                Self::MatchRange81To90 => "MATCH_RANGE_81_TO_90",
                Self::MatchRange91To100 => "MATCH_RANGE_91_TO_100",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MATCH_RANGE_LESS_THAN_20" => Some(Self::MatchRangeLessThan20),
                "MATCH_RANGE_20_TO_30" => Some(Self::MatchRange20To30),
                "MATCH_RANGE_31_TO_40" => Some(Self::MatchRange31To40),
                "MATCH_RANGE_41_TO_50" => Some(Self::MatchRange41To50),
                "MATCH_RANGE_51_TO_60" => Some(Self::MatchRange51To60),
                "MATCH_RANGE_61_TO_70" => Some(Self::MatchRange61To70),
                "MATCH_RANGE_71_TO_80" => Some(Self::MatchRange71To80),
                "MATCH_RANGE_81_TO_90" => Some(Self::MatchRange81To90),
                "MATCH_RANGE_91_TO_100" => Some(Self::MatchRange91To100),
                _ => None,
            }
        }
    }
}
/// Container for enum describing status of an offline user data job.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfflineUserDataJobStatusEnum {}
/// Nested message and enum types in `OfflineUserDataJobStatusEnum`.
pub mod offline_user_data_job_status_enum {
    /// The status of an offline user data job.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OfflineUserDataJobStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The job has been successfully created and pending for uploading.
        Pending = 2,
        /// Upload(s) have been accepted and data is being processed.
        Running = 3,
        /// Uploaded data has been successfully processed.
        Success = 4,
        /// Uploaded data has failed to be processed.
        Failed = 5,
    }
    impl OfflineUserDataJobStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Pending => "PENDING",
                Self::Running => "RUNNING",
                Self::Success => "SUCCESS",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "RUNNING" => Some(Self::Running),
                "SUCCESS" => Some(Self::Success),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing types of an offline user data job.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfflineUserDataJobTypeEnum {}
/// Nested message and enum types in `OfflineUserDataJobTypeEnum`.
pub mod offline_user_data_job_type_enum {
    /// The type of an offline user data job.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OfflineUserDataJobType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Store Sales Direct data for self service.
        StoreSalesUploadFirstParty = 2,
        /// Store Sales Direct data for third party.
        StoreSalesUploadThirdParty = 3,
        /// Customer Match user list data.
        CustomerMatchUserList = 4,
        /// Customer Match with attribute data.
        CustomerMatchWithAttributes = 5,
    }
    impl OfflineUserDataJobType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::StoreSalesUploadFirstParty => "STORE_SALES_UPLOAD_FIRST_PARTY",
                Self::StoreSalesUploadThirdParty => "STORE_SALES_UPLOAD_THIRD_PARTY",
                Self::CustomerMatchUserList => "CUSTOMER_MATCH_USER_LIST",
                Self::CustomerMatchWithAttributes => "CUSTOMER_MATCH_WITH_ATTRIBUTES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "STORE_SALES_UPLOAD_FIRST_PARTY" => {
                    Some(Self::StoreSalesUploadFirstParty)
                }
                "STORE_SALES_UPLOAD_THIRD_PARTY" => {
                    Some(Self::StoreSalesUploadThirdParty)
                }
                "CUSTOMER_MATCH_USER_LIST" => Some(Self::CustomerMatchUserList),
                "CUSTOMER_MATCH_WITH_ATTRIBUTES" => {
                    Some(Self::CustomerMatchWithAttributes)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of OS operators.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OperatingSystemVersionOperatorTypeEnum {}
/// Nested message and enum types in `OperatingSystemVersionOperatorTypeEnum`.
pub mod operating_system_version_operator_type_enum {
    /// The type of operating system version.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OperatingSystemVersionOperatorType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Equals to the specified version.
        EqualsTo = 2,
        /// Greater than or equals to the specified version.
        GreaterThanEqualsTo = 4,
    }
    impl OperatingSystemVersionOperatorType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::EqualsTo => "EQUALS_TO",
                Self::GreaterThanEqualsTo => "GREATER_THAN_EQUALS_TO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EQUALS_TO" => Some(Self::EqualsTo),
                "GREATER_THAN_EQUALS_TO" => Some(Self::GreaterThanEqualsTo),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the type of optimization goal.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OptimizationGoalTypeEnum {}
/// Nested message and enum types in `OptimizationGoalTypeEnum`.
pub mod optimization_goal_type_enum {
    /// The type of optimization goal
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OptimizationGoalType {
        /// Not specified.
        Unspecified = 0,
        /// Used as a return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Optimize for call clicks. Call click conversions are times people
        /// selected 'Call' to contact a store after viewing an ad.
        CallClicks = 2,
        /// Optimize for driving directions. Driving directions conversions are
        /// times people selected 'Get directions' to navigate to a store after
        /// viewing an ad.
        DrivingDirections = 3,
        /// Optimize for pre-registration. Pre-registration conversions are the
        /// number of pre-registration signups to receive a notification when the app
        /// is released.
        AppPreRegistration = 4,
    }
    impl OptimizationGoalType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CallClicks => "CALL_CLICKS",
                Self::DrivingDirections => "DRIVING_DIRECTIONS",
                Self::AppPreRegistration => "APP_PRE_REGISTRATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CALL_CLICKS" => Some(Self::CallClicks),
                "DRIVING_DIRECTIONS" => Some(Self::DrivingDirections),
                "APP_PRE_REGISTRATION" => Some(Self::AppPreRegistration),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible payment modes.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PaymentModeEnum {}
/// Nested message and enum types in `PaymentModeEnum`.
pub mod payment_mode_enum {
    /// Enum describing possible payment modes.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PaymentMode {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Pay per interaction.
        Clicks = 4,
        /// Pay per conversion value. This mode is only supported by campaigns with
        /// AdvertisingChannelType.HOTEL, BiddingStrategyType.COMMISSION, and
        /// BudgetType.STANDARD.
        ConversionValue = 5,
        /// Pay per conversion. This mode is only supported by campaigns with
        /// AdvertisingChannelType.DISPLAY (excluding
        /// AdvertisingChannelSubType.DISPLAY_GMAIL), BiddingStrategyType.TARGET_CPA,
        /// and BudgetType.FIXED_CPA. The customer must also be eligible for this
        /// mode. See Customer.eligibility_failure_reasons for details.
        Conversions = 6,
        /// Pay per guest stay value. This mode is only supported by campaigns with
        /// AdvertisingChannelType.HOTEL, BiddingStrategyType.COMMISSION, and
        /// BudgetType.STANDARD.
        GuestStay = 7,
    }
    impl PaymentMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Clicks => "CLICKS",
                Self::ConversionValue => "CONVERSION_VALUE",
                Self::Conversions => "CONVERSIONS",
                Self::GuestStay => "GUEST_STAY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CLICKS" => Some(Self::Clicks),
                "CONVERSION_VALUE" => Some(Self::ConversionValue),
                "CONVERSIONS" => Some(Self::Conversions),
                "GUEST_STAY" => Some(Self::GuestStay),
                _ => None,
            }
        }
    }
}
/// Performance Max Upgrade status for campaign.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PerformanceMaxUpgradeStatusEnum {}
/// Nested message and enum types in `PerformanceMaxUpgradeStatusEnum`.
pub mod performance_max_upgrade_status_enum {
    /// Performance Max Upgrade status enum for campaign.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PerformanceMaxUpgradeStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The upgrade to a Performance Max campaign is in progress.
        UpgradeInProgress = 3,
        /// The upgrade to a Performance Max campaign is complete.
        UpgradeComplete = 4,
        /// The upgrade to a Performance Max campaign failed.
        /// The campaign will still serve as it was before upgrade was attempted.
        UpgradeFailed = 5,
        /// The campaign is eligible for upgrade to a Performance Max campaign.
        UpgradeEligible = 6,
    }
    impl PerformanceMaxUpgradeStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::UpgradeInProgress => "UPGRADE_IN_PROGRESS",
                Self::UpgradeComplete => "UPGRADE_COMPLETE",
                Self::UpgradeFailed => "UPGRADE_FAILED",
                Self::UpgradeEligible => "UPGRADE_ELIGIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UPGRADE_IN_PROGRESS" => Some(Self::UpgradeInProgress),
                "UPGRADE_COMPLETE" => Some(Self::UpgradeComplete),
                "UPGRADE_FAILED" => Some(Self::UpgradeFailed),
                "UPGRADE_ELIGIBLE" => Some(Self::UpgradeEligible),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible placement types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlacementTypeEnum {}
/// Nested message and enum types in `PlacementTypeEnum`.
pub mod placement_type_enum {
    /// Possible placement types for a feed mapping.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PlacementType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Websites(for example, 'www.flowers4sale.com').
        Website = 2,
        /// Mobile application categories(for example, 'Games').
        MobileAppCategory = 3,
        /// mobile applications(for example, 'mobileapp::2-com.whatsthewordanswers').
        MobileApplication = 4,
        /// YouTube videos(for example, 'youtube.com/video/wtLJPvx7-ys').
        YoutubeVideo = 5,
        /// YouTube channels(for example, 'youtube.com::L8ZULXASCc1I_oaOT0NaOQ').
        YoutubeChannel = 6,
        /// Surfaces owned and operated by Google(for example, 'tv.google.com').
        GoogleProducts = 7,
    }
    impl PlacementType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Website => "WEBSITE",
                Self::MobileAppCategory => "MOBILE_APP_CATEGORY",
                Self::MobileApplication => "MOBILE_APPLICATION",
                Self::YoutubeVideo => "YOUTUBE_VIDEO",
                Self::YoutubeChannel => "YOUTUBE_CHANNEL",
                Self::GoogleProducts => "GOOGLE_PRODUCTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "WEBSITE" => Some(Self::Website),
                "MOBILE_APP_CATEGORY" => Some(Self::MobileAppCategory),
                "MOBILE_APPLICATION" => Some(Self::MobileApplication),
                "YOUTUBE_VIDEO" => Some(Self::YoutubeVideo),
                "YOUTUBE_CHANNEL" => Some(Self::YoutubeChannel),
                "GOOGLE_PRODUCTS" => Some(Self::GoogleProducts),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible positive geo target types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PositiveGeoTargetTypeEnum {}
/// Nested message and enum types in `PositiveGeoTargetTypeEnum`.
pub mod positive_geo_target_type_enum {
    /// The possible positive geo target types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PositiveGeoTargetType {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Specifies that an ad is triggered if the user is in,
        /// or shows interest in, advertiser's targeted locations.
        PresenceOrInterest = 5,
        /// Specifies that an ad is triggered if the user
        /// searches for advertiser's targeted locations.
        /// This can only be used with Search and standard
        /// Shopping campaigns.
        SearchInterest = 6,
        /// Specifies that an ad is triggered if the user is in
        /// or regularly in advertiser's targeted locations.
        Presence = 7,
    }
    impl PositiveGeoTargetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::PresenceOrInterest => "PRESENCE_OR_INTEREST",
                Self::SearchInterest => "SEARCH_INTEREST",
                Self::Presence => "PRESENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PRESENCE_OR_INTEREST" => Some(Self::PresenceOrInterest),
                "SEARCH_INTEREST" => Some(Self::SearchInterest),
                "PRESENCE" => Some(Self::Presence),
                _ => None,
            }
        }
    }
}
/// Values for Price placeholder fields.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PricePlaceholderFieldEnum {}
/// Nested message and enum types in `PricePlaceholderFieldEnum`.
pub mod price_placeholder_field_enum {
    /// Possible values for Price placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PricePlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. The type of your price feed. Must match one of the
        /// predefined price feed type exactly.
        Type = 2,
        /// Data Type: STRING. The qualifier of each price. Must match one of the
        /// predefined price qualifiers exactly.
        PriceQualifier = 3,
        /// Data Type: URL. Tracking template for the price feed when using Upgraded
        /// URLs.
        TrackingTemplate = 4,
        /// Data Type: STRING. Language of the price feed. Must match one of the
        /// available available locale codes exactly.
        Language = 5,
        /// Data Type: STRING. Final URL suffix for the price feed when using
        /// parallel tracking.
        FinalUrlSuffix = 6,
        /// Data Type: STRING. The header of item 1 of the table.
        Item1Header = 100,
        /// Data Type: STRING. The description of item 1 of the table.
        Item1Description = 101,
        /// Data Type: MONEY. The price (money with currency) of item 1 of the table,
        /// for example, 30 USD. The currency must match one of the available
        /// currencies.
        Item1Price = 102,
        /// Data Type: STRING. The price unit of item 1 of the table. Must match one
        /// of the predefined price units.
        Item1Unit = 103,
        /// Data Type: URL_LIST. The final URLs of item 1 of the table when using
        /// Upgraded URLs.
        Item1FinalUrls = 104,
        /// Data Type: URL_LIST. The final mobile URLs of item 1 of the table when
        /// using Upgraded URLs.
        Item1FinalMobileUrls = 105,
        /// Data Type: STRING. The header of item 2 of the table.
        Item2Header = 200,
        /// Data Type: STRING. The description of item 2 of the table.
        Item2Description = 201,
        /// Data Type: MONEY. The price (money with currency) of item 2 of the table,
        /// for example, 30 USD. The currency must match one of the available
        /// currencies.
        Item2Price = 202,
        /// Data Type: STRING. The price unit of item 2 of the table. Must match one
        /// of the predefined price units.
        Item2Unit = 203,
        /// Data Type: URL_LIST. The final URLs of item 2 of the table when using
        /// Upgraded URLs.
        Item2FinalUrls = 204,
        /// Data Type: URL_LIST. The final mobile URLs of item 2 of the table when
        /// using Upgraded URLs.
        Item2FinalMobileUrls = 205,
        /// Data Type: STRING. The header of item 3 of the table.
        Item3Header = 300,
        /// Data Type: STRING. The description of item 3 of the table.
        Item3Description = 301,
        /// Data Type: MONEY. The price (money with currency) of item 3 of the table,
        /// for example, 30 USD. The currency must match one of the available
        /// currencies.
        Item3Price = 302,
        /// Data Type: STRING. The price unit of item 3 of the table. Must match one
        /// of the predefined price units.
        Item3Unit = 303,
        /// Data Type: URL_LIST. The final URLs of item 3 of the table when using
        /// Upgraded URLs.
        Item3FinalUrls = 304,
        /// Data Type: URL_LIST. The final mobile URLs of item 3 of the table when
        /// using Upgraded URLs.
        Item3FinalMobileUrls = 305,
        /// Data Type: STRING. The header of item 4 of the table.
        Item4Header = 400,
        /// Data Type: STRING. The description of item 4 of the table.
        Item4Description = 401,
        /// Data Type: MONEY. The price (money with currency) of item 4 of the table,
        /// for example, 30 USD. The currency must match one of the available
        /// currencies.
        Item4Price = 402,
        /// Data Type: STRING. The price unit of item 4 of the table. Must match one
        /// of the predefined price units.
        Item4Unit = 403,
        /// Data Type: URL_LIST. The final URLs of item 4 of the table when using
        /// Upgraded URLs.
        Item4FinalUrls = 404,
        /// Data Type: URL_LIST. The final mobile URLs of item 4 of the table when
        /// using Upgraded URLs.
        Item4FinalMobileUrls = 405,
        /// Data Type: STRING. The header of item 5 of the table.
        Item5Header = 500,
        /// Data Type: STRING. The description of item 5 of the table.
        Item5Description = 501,
        /// Data Type: MONEY. The price (money with currency) of item 5 of the table,
        /// for example, 30 USD. The currency must match one of the available
        /// currencies.
        Item5Price = 502,
        /// Data Type: STRING. The price unit of item 5 of the table. Must match one
        /// of the predefined price units.
        Item5Unit = 503,
        /// Data Type: URL_LIST. The final URLs of item 5 of the table when using
        /// Upgraded URLs.
        Item5FinalUrls = 504,
        /// Data Type: URL_LIST. The final mobile URLs of item 5 of the table when
        /// using Upgraded URLs.
        Item5FinalMobileUrls = 505,
        /// Data Type: STRING. The header of item 6 of the table.
        Item6Header = 600,
        /// Data Type: STRING. The description of item 6 of the table.
        Item6Description = 601,
        /// Data Type: MONEY. The price (money with currency) of item 6 of the table,
        /// for example, 30 USD. The currency must match one of the available
        /// currencies.
        Item6Price = 602,
        /// Data Type: STRING. The price unit of item 6 of the table. Must match one
        /// of the predefined price units.
        Item6Unit = 603,
        /// Data Type: URL_LIST. The final URLs of item 6 of the table when using
        /// Upgraded URLs.
        Item6FinalUrls = 604,
        /// Data Type: URL_LIST. The final mobile URLs of item 6 of the table when
        /// using Upgraded URLs.
        Item6FinalMobileUrls = 605,
        /// Data Type: STRING. The header of item 7 of the table.
        Item7Header = 700,
        /// Data Type: STRING. The description of item 7 of the table.
        Item7Description = 701,
        /// Data Type: MONEY. The price (money with currency) of item 7 of the table,
        /// for example, 30 USD. The currency must match one of the available
        /// currencies.
        Item7Price = 702,
        /// Data Type: STRING. The price unit of item 7 of the table. Must match one
        /// of the predefined price units.
        Item7Unit = 703,
        /// Data Type: URL_LIST. The final URLs of item 7 of the table when using
        /// Upgraded URLs.
        Item7FinalUrls = 704,
        /// Data Type: URL_LIST. The final mobile URLs of item 7 of the table when
        /// using Upgraded URLs.
        Item7FinalMobileUrls = 705,
        /// Data Type: STRING. The header of item 8 of the table.
        Item8Header = 800,
        /// Data Type: STRING. The description of item 8 of the table.
        Item8Description = 801,
        /// Data Type: MONEY. The price (money with currency) of item 8 of the table,
        /// for example, 30 USD. The currency must match one of the available
        /// currencies.
        Item8Price = 802,
        /// Data Type: STRING. The price unit of item 8 of the table. Must match one
        /// of the predefined price units.
        Item8Unit = 803,
        /// Data Type: URL_LIST. The final URLs of item 8 of the table when using
        /// Upgraded URLs.
        Item8FinalUrls = 804,
        /// Data Type: URL_LIST. The final mobile URLs of item 8 of the table when
        /// using Upgraded URLs.
        Item8FinalMobileUrls = 805,
    }
    impl PricePlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Type => "TYPE",
                Self::PriceQualifier => "PRICE_QUALIFIER",
                Self::TrackingTemplate => "TRACKING_TEMPLATE",
                Self::Language => "LANGUAGE",
                Self::FinalUrlSuffix => "FINAL_URL_SUFFIX",
                Self::Item1Header => "ITEM_1_HEADER",
                Self::Item1Description => "ITEM_1_DESCRIPTION",
                Self::Item1Price => "ITEM_1_PRICE",
                Self::Item1Unit => "ITEM_1_UNIT",
                Self::Item1FinalUrls => "ITEM_1_FINAL_URLS",
                Self::Item1FinalMobileUrls => "ITEM_1_FINAL_MOBILE_URLS",
                Self::Item2Header => "ITEM_2_HEADER",
                Self::Item2Description => "ITEM_2_DESCRIPTION",
                Self::Item2Price => "ITEM_2_PRICE",
                Self::Item2Unit => "ITEM_2_UNIT",
                Self::Item2FinalUrls => "ITEM_2_FINAL_URLS",
                Self::Item2FinalMobileUrls => "ITEM_2_FINAL_MOBILE_URLS",
                Self::Item3Header => "ITEM_3_HEADER",
                Self::Item3Description => "ITEM_3_DESCRIPTION",
                Self::Item3Price => "ITEM_3_PRICE",
                Self::Item3Unit => "ITEM_3_UNIT",
                Self::Item3FinalUrls => "ITEM_3_FINAL_URLS",
                Self::Item3FinalMobileUrls => "ITEM_3_FINAL_MOBILE_URLS",
                Self::Item4Header => "ITEM_4_HEADER",
                Self::Item4Description => "ITEM_4_DESCRIPTION",
                Self::Item4Price => "ITEM_4_PRICE",
                Self::Item4Unit => "ITEM_4_UNIT",
                Self::Item4FinalUrls => "ITEM_4_FINAL_URLS",
                Self::Item4FinalMobileUrls => "ITEM_4_FINAL_MOBILE_URLS",
                Self::Item5Header => "ITEM_5_HEADER",
                Self::Item5Description => "ITEM_5_DESCRIPTION",
                Self::Item5Price => "ITEM_5_PRICE",
                Self::Item5Unit => "ITEM_5_UNIT",
                Self::Item5FinalUrls => "ITEM_5_FINAL_URLS",
                Self::Item5FinalMobileUrls => "ITEM_5_FINAL_MOBILE_URLS",
                Self::Item6Header => "ITEM_6_HEADER",
                Self::Item6Description => "ITEM_6_DESCRIPTION",
                Self::Item6Price => "ITEM_6_PRICE",
                Self::Item6Unit => "ITEM_6_UNIT",
                Self::Item6FinalUrls => "ITEM_6_FINAL_URLS",
                Self::Item6FinalMobileUrls => "ITEM_6_FINAL_MOBILE_URLS",
                Self::Item7Header => "ITEM_7_HEADER",
                Self::Item7Description => "ITEM_7_DESCRIPTION",
                Self::Item7Price => "ITEM_7_PRICE",
                Self::Item7Unit => "ITEM_7_UNIT",
                Self::Item7FinalUrls => "ITEM_7_FINAL_URLS",
                Self::Item7FinalMobileUrls => "ITEM_7_FINAL_MOBILE_URLS",
                Self::Item8Header => "ITEM_8_HEADER",
                Self::Item8Description => "ITEM_8_DESCRIPTION",
                Self::Item8Price => "ITEM_8_PRICE",
                Self::Item8Unit => "ITEM_8_UNIT",
                Self::Item8FinalUrls => "ITEM_8_FINAL_URLS",
                Self::Item8FinalMobileUrls => "ITEM_8_FINAL_MOBILE_URLS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TYPE" => Some(Self::Type),
                "PRICE_QUALIFIER" => Some(Self::PriceQualifier),
                "TRACKING_TEMPLATE" => Some(Self::TrackingTemplate),
                "LANGUAGE" => Some(Self::Language),
                "FINAL_URL_SUFFIX" => Some(Self::FinalUrlSuffix),
                "ITEM_1_HEADER" => Some(Self::Item1Header),
                "ITEM_1_DESCRIPTION" => Some(Self::Item1Description),
                "ITEM_1_PRICE" => Some(Self::Item1Price),
                "ITEM_1_UNIT" => Some(Self::Item1Unit),
                "ITEM_1_FINAL_URLS" => Some(Self::Item1FinalUrls),
                "ITEM_1_FINAL_MOBILE_URLS" => Some(Self::Item1FinalMobileUrls),
                "ITEM_2_HEADER" => Some(Self::Item2Header),
                "ITEM_2_DESCRIPTION" => Some(Self::Item2Description),
                "ITEM_2_PRICE" => Some(Self::Item2Price),
                "ITEM_2_UNIT" => Some(Self::Item2Unit),
                "ITEM_2_FINAL_URLS" => Some(Self::Item2FinalUrls),
                "ITEM_2_FINAL_MOBILE_URLS" => Some(Self::Item2FinalMobileUrls),
                "ITEM_3_HEADER" => Some(Self::Item3Header),
                "ITEM_3_DESCRIPTION" => Some(Self::Item3Description),
                "ITEM_3_PRICE" => Some(Self::Item3Price),
                "ITEM_3_UNIT" => Some(Self::Item3Unit),
                "ITEM_3_FINAL_URLS" => Some(Self::Item3FinalUrls),
                "ITEM_3_FINAL_MOBILE_URLS" => Some(Self::Item3FinalMobileUrls),
                "ITEM_4_HEADER" => Some(Self::Item4Header),
                "ITEM_4_DESCRIPTION" => Some(Self::Item4Description),
                "ITEM_4_PRICE" => Some(Self::Item4Price),
                "ITEM_4_UNIT" => Some(Self::Item4Unit),
                "ITEM_4_FINAL_URLS" => Some(Self::Item4FinalUrls),
                "ITEM_4_FINAL_MOBILE_URLS" => Some(Self::Item4FinalMobileUrls),
                "ITEM_5_HEADER" => Some(Self::Item5Header),
                "ITEM_5_DESCRIPTION" => Some(Self::Item5Description),
                "ITEM_5_PRICE" => Some(Self::Item5Price),
                "ITEM_5_UNIT" => Some(Self::Item5Unit),
                "ITEM_5_FINAL_URLS" => Some(Self::Item5FinalUrls),
                "ITEM_5_FINAL_MOBILE_URLS" => Some(Self::Item5FinalMobileUrls),
                "ITEM_6_HEADER" => Some(Self::Item6Header),
                "ITEM_6_DESCRIPTION" => Some(Self::Item6Description),
                "ITEM_6_PRICE" => Some(Self::Item6Price),
                "ITEM_6_UNIT" => Some(Self::Item6Unit),
                "ITEM_6_FINAL_URLS" => Some(Self::Item6FinalUrls),
                "ITEM_6_FINAL_MOBILE_URLS" => Some(Self::Item6FinalMobileUrls),
                "ITEM_7_HEADER" => Some(Self::Item7Header),
                "ITEM_7_DESCRIPTION" => Some(Self::Item7Description),
                "ITEM_7_PRICE" => Some(Self::Item7Price),
                "ITEM_7_UNIT" => Some(Self::Item7Unit),
                "ITEM_7_FINAL_URLS" => Some(Self::Item7FinalUrls),
                "ITEM_7_FINAL_MOBILE_URLS" => Some(Self::Item7FinalMobileUrls),
                "ITEM_8_HEADER" => Some(Self::Item8Header),
                "ITEM_8_DESCRIPTION" => Some(Self::Item8Description),
                "ITEM_8_PRICE" => Some(Self::Item8Price),
                "ITEM_8_UNIT" => Some(Self::Item8Unit),
                "ITEM_8_FINAL_URLS" => Some(Self::Item8FinalUrls),
                "ITEM_8_FINAL_MOBILE_URLS" => Some(Self::Item8FinalMobileUrls),
                _ => None,
            }
        }
    }
}
/// State of the product category.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductCategoryStateEnum {}
/// Nested message and enum types in `ProductCategoryStateEnum`.
pub mod product_category_state_enum {
    /// Enum describing the state of the product category.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductCategoryState {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The category is enabled.
        Enabled = 2,
        /// The category is obsolete. Used only for reporting purposes.
        Obsolete = 3,
    }
    impl ProductCategoryState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Obsolete => "OBSOLETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "OBSOLETE" => Some(Self::Obsolete),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible statuses of a product link
/// invitation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductLinkInvitationStatusEnum {}
/// Nested message and enum types in `ProductLinkInvitationStatusEnum`.
pub mod product_link_invitation_status_enum {
    /// Describes the possible statuses for an invitation between a Google Ads
    /// customer and another account.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductLinkInvitationStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The invitation is accepted.
        Accepted = 2,
        /// An invitation has been sent to the other account. A user on the other
        /// account may now accept the invitation by setting the status to ACCEPTED.
        Requested = 3,
        /// This invitation has been sent by a user on the other account. It may be
        /// accepted by a user on this account by setting the status to ACCEPTED.
        PendingApproval = 4,
        /// The invitation is revoked by the user who sent the invitation.
        Revoked = 5,
        /// The invitation has been rejected by the invitee.
        Rejected = 6,
        /// The invitation has timed out before being accepted by the
        /// invitee.
        Expired = 7,
    }
    impl ProductLinkInvitationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Accepted => "ACCEPTED",
                Self::Requested => "REQUESTED",
                Self::PendingApproval => "PENDING_APPROVAL",
                Self::Revoked => "REVOKED",
                Self::Rejected => "REJECTED",
                Self::Expired => "EXPIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACCEPTED" => Some(Self::Accepted),
                "REQUESTED" => Some(Self::Requested),
                "PENDING_APPROVAL" => Some(Self::PendingApproval),
                "REVOKED" => Some(Self::Revoked),
                "REJECTED" => Some(Self::Rejected),
                "EXPIRED" => Some(Self::Expired),
                _ => None,
            }
        }
    }
}
/// Values for Promotion placeholder fields.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PromotionPlaceholderFieldEnum {}
/// Nested message and enum types in `PromotionPlaceholderFieldEnum`.
pub mod promotion_placeholder_field_enum {
    /// Possible values for Promotion placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PromotionPlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. The text that appears on the ad when the extension is
        /// shown.
        PromotionTarget = 2,
        /// Data Type: STRING. Lets you add "up to" phrase to the promotion,
        /// in case you have variable promotion rates.
        DiscountModifier = 3,
        /// Data Type: INT64. Takes a value in micros, where 1 million micros
        /// represents 1%, and is shown as a percentage when rendered.
        PercentOff = 4,
        /// Data Type: MONEY. Requires a currency and an amount of money.
        MoneyAmountOff = 5,
        /// Data Type: STRING. A string that the user enters to get the discount.
        PromotionCode = 6,
        /// Data Type: MONEY. A minimum spend before the user qualifies for the
        /// promotion.
        OrdersOverAmount = 7,
        /// Data Type: DATE. The start date of the promotion.
        PromotionStart = 8,
        /// Data Type: DATE. The end date of the promotion.
        PromotionEnd = 9,
        /// Data Type: STRING. Describes the associated event for the promotion using
        /// one of the PromotionExtensionOccasion enum values, for example NEW_YEARS.
        Occasion = 10,
        /// Data Type: URL_LIST. Final URLs to be used in the ad when using Upgraded
        /// URLs.
        FinalUrls = 11,
        /// Data Type: URL_LIST. Final mobile URLs for the ad when using Upgraded
        /// URLs.
        FinalMobileUrls = 12,
        /// Data Type: URL. Tracking template for the ad when using Upgraded URLs.
        TrackingUrl = 13,
        /// Data Type: STRING. A string represented by a language code for the
        /// promotion.
        Language = 14,
        /// Data Type: STRING. Final URL suffix for the ad when using parallel
        /// tracking.
        FinalUrlSuffix = 15,
    }
    impl PromotionPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::PromotionTarget => "PROMOTION_TARGET",
                Self::DiscountModifier => "DISCOUNT_MODIFIER",
                Self::PercentOff => "PERCENT_OFF",
                Self::MoneyAmountOff => "MONEY_AMOUNT_OFF",
                Self::PromotionCode => "PROMOTION_CODE",
                Self::OrdersOverAmount => "ORDERS_OVER_AMOUNT",
                Self::PromotionStart => "PROMOTION_START",
                Self::PromotionEnd => "PROMOTION_END",
                Self::Occasion => "OCCASION",
                Self::FinalUrls => "FINAL_URLS",
                Self::FinalMobileUrls => "FINAL_MOBILE_URLS",
                Self::TrackingUrl => "TRACKING_URL",
                Self::Language => "LANGUAGE",
                Self::FinalUrlSuffix => "FINAL_URL_SUFFIX",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PROMOTION_TARGET" => Some(Self::PromotionTarget),
                "DISCOUNT_MODIFIER" => Some(Self::DiscountModifier),
                "PERCENT_OFF" => Some(Self::PercentOff),
                "MONEY_AMOUNT_OFF" => Some(Self::MoneyAmountOff),
                "PROMOTION_CODE" => Some(Self::PromotionCode),
                "ORDERS_OVER_AMOUNT" => Some(Self::OrdersOverAmount),
                "PROMOTION_START" => Some(Self::PromotionStart),
                "PROMOTION_END" => Some(Self::PromotionEnd),
                "OCCASION" => Some(Self::Occasion),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "LANGUAGE" => Some(Self::Language),
                "FINAL_URL_SUFFIX" => Some(Self::FinalUrlSuffix),
                _ => None,
            }
        }
    }
}
/// Message describing plannable age ranges.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReachPlanAgeRangeEnum {}
/// Nested message and enum types in `ReachPlanAgeRangeEnum`.
pub mod reach_plan_age_range_enum {
    /// Possible plannable age range values.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReachPlanAgeRange {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// Between 18 and 24 years old.
        AgeRange1824 = 503001,
        /// Between 18 and 34 years old.
        AgeRange1834 = 2,
        /// Between 18 and 44 years old.
        AgeRange1844 = 3,
        /// Between 18 and 49 years old.
        AgeRange1849 = 4,
        /// Between 18 and 54 years old.
        AgeRange1854 = 5,
        /// Between 18 and 64 years old.
        AgeRange1864 = 6,
        /// Between 18 and 65+ years old.
        AgeRange1865Up = 7,
        /// Between 21 and 34 years old.
        AgeRange2134 = 8,
        /// Between 25 and 34 years old.
        AgeRange2534 = 503002,
        /// Between 25 and 44 years old.
        AgeRange2544 = 9,
        /// Between 25 and 49 years old.
        AgeRange2549 = 10,
        /// Between 25 and 54 years old.
        AgeRange2554 = 11,
        /// Between 25 and 64 years old.
        AgeRange2564 = 12,
        /// Between 25 and 65+ years old.
        AgeRange2565Up = 13,
        /// Between 35 and 44 years old.
        AgeRange3544 = 503003,
        /// Between 35 and 49 years old.
        AgeRange3549 = 14,
        /// Between 35 and 54 years old.
        AgeRange3554 = 15,
        /// Between 35 and 64 years old.
        AgeRange3564 = 16,
        /// Between 35 and 65+ years old.
        AgeRange3565Up = 17,
        /// Between 45 and 54 years old.
        AgeRange4554 = 503004,
        /// Between 45 and 64 years old.
        AgeRange4564 = 18,
        /// Between 45 and 65+ years old.
        AgeRange4565Up = 19,
        /// Between 50 and 65+ years old.
        AgeRange5065Up = 20,
        /// Between 55 and 64 years old.
        AgeRange5564 = 503005,
        /// Between 55 and 65+ years old.
        AgeRange5565Up = 21,
        /// 65 years old and beyond.
        AgeRange65Up = 503006,
    }
    impl ReachPlanAgeRange {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AgeRange1824 => "AGE_RANGE_18_24",
                Self::AgeRange1834 => "AGE_RANGE_18_34",
                Self::AgeRange1844 => "AGE_RANGE_18_44",
                Self::AgeRange1849 => "AGE_RANGE_18_49",
                Self::AgeRange1854 => "AGE_RANGE_18_54",
                Self::AgeRange1864 => "AGE_RANGE_18_64",
                Self::AgeRange1865Up => "AGE_RANGE_18_65_UP",
                Self::AgeRange2134 => "AGE_RANGE_21_34",
                Self::AgeRange2534 => "AGE_RANGE_25_34",
                Self::AgeRange2544 => "AGE_RANGE_25_44",
                Self::AgeRange2549 => "AGE_RANGE_25_49",
                Self::AgeRange2554 => "AGE_RANGE_25_54",
                Self::AgeRange2564 => "AGE_RANGE_25_64",
                Self::AgeRange2565Up => "AGE_RANGE_25_65_UP",
                Self::AgeRange3544 => "AGE_RANGE_35_44",
                Self::AgeRange3549 => "AGE_RANGE_35_49",
                Self::AgeRange3554 => "AGE_RANGE_35_54",
                Self::AgeRange3564 => "AGE_RANGE_35_64",
                Self::AgeRange3565Up => "AGE_RANGE_35_65_UP",
                Self::AgeRange4554 => "AGE_RANGE_45_54",
                Self::AgeRange4564 => "AGE_RANGE_45_64",
                Self::AgeRange4565Up => "AGE_RANGE_45_65_UP",
                Self::AgeRange5065Up => "AGE_RANGE_50_65_UP",
                Self::AgeRange5564 => "AGE_RANGE_55_64",
                Self::AgeRange5565Up => "AGE_RANGE_55_65_UP",
                Self::AgeRange65Up => "AGE_RANGE_65_UP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AGE_RANGE_18_24" => Some(Self::AgeRange1824),
                "AGE_RANGE_18_34" => Some(Self::AgeRange1834),
                "AGE_RANGE_18_44" => Some(Self::AgeRange1844),
                "AGE_RANGE_18_49" => Some(Self::AgeRange1849),
                "AGE_RANGE_18_54" => Some(Self::AgeRange1854),
                "AGE_RANGE_18_64" => Some(Self::AgeRange1864),
                "AGE_RANGE_18_65_UP" => Some(Self::AgeRange1865Up),
                "AGE_RANGE_21_34" => Some(Self::AgeRange2134),
                "AGE_RANGE_25_34" => Some(Self::AgeRange2534),
                "AGE_RANGE_25_44" => Some(Self::AgeRange2544),
                "AGE_RANGE_25_49" => Some(Self::AgeRange2549),
                "AGE_RANGE_25_54" => Some(Self::AgeRange2554),
                "AGE_RANGE_25_64" => Some(Self::AgeRange2564),
                "AGE_RANGE_25_65_UP" => Some(Self::AgeRange2565Up),
                "AGE_RANGE_35_44" => Some(Self::AgeRange3544),
                "AGE_RANGE_35_49" => Some(Self::AgeRange3549),
                "AGE_RANGE_35_54" => Some(Self::AgeRange3554),
                "AGE_RANGE_35_64" => Some(Self::AgeRange3564),
                "AGE_RANGE_35_65_UP" => Some(Self::AgeRange3565Up),
                "AGE_RANGE_45_54" => Some(Self::AgeRange4554),
                "AGE_RANGE_45_64" => Some(Self::AgeRange4564),
                "AGE_RANGE_45_65_UP" => Some(Self::AgeRange4565Up),
                "AGE_RANGE_50_65_UP" => Some(Self::AgeRange5065Up),
                "AGE_RANGE_55_64" => Some(Self::AgeRange5564),
                "AGE_RANGE_55_65_UP" => Some(Self::AgeRange5565Up),
                "AGE_RANGE_65_UP" => Some(Self::AgeRange65Up),
                _ => None,
            }
        }
    }
}
/// Container for enum describing plannable networks.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReachPlanNetworkEnum {}
/// Nested message and enum types in `ReachPlanNetworkEnum`.
pub mod reach_plan_network_enum {
    /// Possible plannable network values.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReachPlanNetwork {
        /// Not specified.
        Unspecified = 0,
        /// Used as a return value only. Represents value unknown in this version.
        Unknown = 1,
        /// YouTube network.
        Youtube = 2,
        /// Google Video Partners (GVP) network.
        GoogleVideoPartners = 3,
        /// A combination of the YouTube network and the Google Video Partners
        /// network.
        YoutubeAndGoogleVideoPartners = 4,
    }
    impl ReachPlanNetwork {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Youtube => "YOUTUBE",
                Self::GoogleVideoPartners => "GOOGLE_VIDEO_PARTNERS",
                Self::YoutubeAndGoogleVideoPartners => {
                    "YOUTUBE_AND_GOOGLE_VIDEO_PARTNERS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "YOUTUBE" => Some(Self::Youtube),
                "GOOGLE_VIDEO_PARTNERS" => Some(Self::GoogleVideoPartners),
                "YOUTUBE_AND_GOOGLE_VIDEO_PARTNERS" => {
                    Some(Self::YoutubeAndGoogleVideoPartners)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing surfaces available for targeting in forecasts.
/// Surfaces refer to the available types of ad inventories such as In-Feed,
/// In-Stream, and Shorts.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReachPlanSurfaceEnum {}
/// Nested message and enum types in `ReachPlanSurfaceEnum`.
pub mod reach_plan_surface_enum {
    /// Surfaces available to target in reach forecasts.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReachPlanSurface {
        /// Not specified.
        Unspecified = 0,
        /// The value is unknown in this version.
        Unknown = 1,
        /// In-Feed ad surface.
        InFeed = 2,
        /// In-Stream bumper ad surface.
        InStreamBumper = 3,
        /// In-Stream non-skippable ad surface.
        InStreamNonSkippable = 4,
        /// In-Stream skippable ad surface.
        InStreamSkippable = 5,
        /// Shorts ad surface.
        Shorts = 6,
    }
    impl ReachPlanSurface {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::InFeed => "IN_FEED",
                Self::InStreamBumper => "IN_STREAM_BUMPER",
                Self::InStreamNonSkippable => "IN_STREAM_NON_SKIPPABLE",
                Self::InStreamSkippable => "IN_STREAM_SKIPPABLE",
                Self::Shorts => "SHORTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "IN_FEED" => Some(Self::InFeed),
                "IN_STREAM_BUMPER" => Some(Self::InStreamBumper),
                "IN_STREAM_NON_SKIPPABLE" => Some(Self::InStreamNonSkippable),
                "IN_STREAM_SKIPPABLE" => Some(Self::InStreamSkippable),
                "SHORTS" => Some(Self::Shorts),
                _ => None,
            }
        }
    }
}
/// Values for Real Estate placeholder fields.
/// For more information about dynamic remarketing feeds, see
/// <https://support.google.com/google-ads/answer/6053288.>
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RealEstatePlaceholderFieldEnum {}
/// Nested message and enum types in `RealEstatePlaceholderFieldEnum`.
pub mod real_estate_placeholder_field_enum {
    /// Possible values for Real Estate placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RealEstatePlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. Unique ID.
        ListingId = 2,
        /// Data Type: STRING. Main headline with listing name to be shown in dynamic
        /// ad.
        ListingName = 3,
        /// Data Type: STRING. City name to be shown in dynamic ad.
        CityName = 4,
        /// Data Type: STRING. Description of listing to be shown in dynamic ad.
        Description = 5,
        /// Data Type: STRING. Complete listing address, including postal code.
        Address = 6,
        /// Data Type: STRING. Price to be shown in the ad.
        /// Example: "100.00 USD"
        Price = 7,
        /// Data Type: STRING. Formatted price to be shown in the ad.
        /// Example: "Starting at $100.00 USD", "$80 - $100"
        FormattedPrice = 8,
        /// Data Type: URL. Image to be displayed in the ad.
        ImageUrl = 9,
        /// Data Type: STRING. Type of property (house, condo, apartment, etc.) used
        /// to group like items together for recommendation engine.
        PropertyType = 10,
        /// Data Type: STRING. Type of listing (resale, rental, foreclosure, etc.)
        /// used to group like items together for recommendation engine.
        ListingType = 11,
        /// Data Type: STRING_LIST. Keywords used for product retrieval.
        ContextualKeywords = 12,
        /// Data Type: URL_LIST. Final URLs to be used in ad when using Upgraded
        /// URLs; the more specific the better (for example, the individual URL of a
        /// specific listing and its location).
        FinalUrls = 13,
        /// Data Type: URL_LIST. Final mobile URLs for the ad when using Upgraded
        /// URLs.
        FinalMobileUrls = 14,
        /// Data Type: URL. Tracking template for the ad when using Upgraded URLs.
        TrackingUrl = 15,
        /// Data Type: STRING. Android app link. Must be formatted as:
        /// android-app://{package_id}/{scheme}/{host_path}.
        /// The components are defined as follows:
        /// package_id: app ID as specified in Google Play.
        /// scheme: the scheme to pass to the application. Can be HTTP, or a custom
        ///    scheme.
        /// host_path: identifies the specific content within your application.
        AndroidAppLink = 16,
        /// Data Type: STRING_LIST. List of recommended listing IDs to show together
        /// with this item.
        SimilarListingIds = 17,
        /// Data Type: STRING. iOS app link.
        IosAppLink = 18,
        /// Data Type: INT64. iOS app store ID.
        IosAppStoreId = 19,
    }
    impl RealEstatePlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ListingId => "LISTING_ID",
                Self::ListingName => "LISTING_NAME",
                Self::CityName => "CITY_NAME",
                Self::Description => "DESCRIPTION",
                Self::Address => "ADDRESS",
                Self::Price => "PRICE",
                Self::FormattedPrice => "FORMATTED_PRICE",
                Self::ImageUrl => "IMAGE_URL",
                Self::PropertyType => "PROPERTY_TYPE",
                Self::ListingType => "LISTING_TYPE",
                Self::ContextualKeywords => "CONTEXTUAL_KEYWORDS",
                Self::FinalUrls => "FINAL_URLS",
                Self::FinalMobileUrls => "FINAL_MOBILE_URLS",
                Self::TrackingUrl => "TRACKING_URL",
                Self::AndroidAppLink => "ANDROID_APP_LINK",
                Self::SimilarListingIds => "SIMILAR_LISTING_IDS",
                Self::IosAppLink => "IOS_APP_LINK",
                Self::IosAppStoreId => "IOS_APP_STORE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LISTING_ID" => Some(Self::ListingId),
                "LISTING_NAME" => Some(Self::ListingName),
                "CITY_NAME" => Some(Self::CityName),
                "DESCRIPTION" => Some(Self::Description),
                "ADDRESS" => Some(Self::Address),
                "PRICE" => Some(Self::Price),
                "FORMATTED_PRICE" => Some(Self::FormattedPrice),
                "IMAGE_URL" => Some(Self::ImageUrl),
                "PROPERTY_TYPE" => Some(Self::PropertyType),
                "LISTING_TYPE" => Some(Self::ListingType),
                "CONTEXTUAL_KEYWORDS" => Some(Self::ContextualKeywords),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "ANDROID_APP_LINK" => Some(Self::AndroidAppLink),
                "SIMILAR_LISTING_IDS" => Some(Self::SimilarListingIds),
                "IOS_APP_LINK" => Some(Self::IosAppLink),
                "IOS_APP_STORE_ID" => Some(Self::IosAppStoreId),
                _ => None,
            }
        }
    }
}
/// Container for enum describing recommendation subscription statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecommendationSubscriptionStatusEnum {}
/// Nested message and enum types in `RecommendationSubscriptionStatusEnum`.
pub mod recommendation_subscription_status_enum {
    /// Enum describing recommendation subscription statuses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RecommendationSubscriptionStatus {
        /// Not specified.
        Unspecified = 0,
        /// Output-only. Represents a format not yet defined in this enum.
        Unknown = 1,
        /// A subscription in the enabled state will automatically
        /// apply any recommendations of that type.
        Enabled = 2,
        /// Recommendations of the relevant type will not be
        /// automatically applied. Subscriptions cannot be deleted. Once
        /// created, they can only move between enabled and paused states.
        Paused = 3,
    }
    impl RecommendationSubscriptionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Paused => "PAUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                _ => None,
            }
        }
    }
}
/// Container for enum describing resource change operations
/// in the ChangeEvent resource.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourceChangeOperationEnum {}
/// Nested message and enum types in `ResourceChangeOperationEnum`.
pub mod resource_change_operation_enum {
    /// The operation on the changed resource in change_event resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResourceChangeOperation {
        /// No value has been specified.
        Unspecified = 0,
        /// Used for return value only. Represents an unclassified operation unknown
        /// in this version.
        Unknown = 1,
        /// The resource was created.
        Create = 2,
        /// The resource was modified.
        Update = 3,
        /// The resource was removed.
        Remove = 4,
    }
    impl ResourceChangeOperation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Create => "CREATE",
                Self::Update => "UPDATE",
                Self::Remove => "REMOVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CREATE" => Some(Self::Create),
                "UPDATE" => Some(Self::Update),
                "REMOVE" => Some(Self::Remove),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible resource limit types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourceLimitTypeEnum {}
/// Nested message and enum types in `ResourceLimitTypeEnum`.
pub mod resource_limit_type_enum {
    /// Resource limit type.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResourceLimitType {
        /// No value has been specified.
        Unspecified = 0,
        /// Used for return value only. Represents an unclassified operation unknown
        /// in this version.
        Unknown = 1,
        /// Number of ENABLED and PAUSED campaigns per customer.
        CampaignsPerCustomer = 2,
        /// Number of ENABLED and PAUSED base campaigns per customer.
        BaseCampaignsPerCustomer = 3,
        /// Number of ENABLED and PAUSED experiment campaigns per customer.
        ExperimentCampaignsPerCustomer = 105,
        /// Number of ENABLED and PAUSED Hotel campaigns per customer.
        HotelCampaignsPerCustomer = 4,
        /// Number of ENABLED and PAUSED Smart Shopping campaigns per customer.
        SmartShoppingCampaignsPerCustomer = 5,
        /// Number of ENABLED ad groups per campaign.
        AdGroupsPerCampaign = 6,
        /// Number of ENABLED ad groups per Shopping campaign.
        AdGroupsPerShoppingCampaign = 8,
        /// Number of ENABLED ad groups per Hotel campaign.
        AdGroupsPerHotelCampaign = 9,
        /// Number of ENABLED reporting ad groups per local campaign.
        ReportingAdGroupsPerLocalCampaign = 10,
        /// Number of ENABLED reporting ad groups per App campaign. It includes app
        /// campaign and app campaign for engagement.
        ReportingAdGroupsPerAppCampaign = 11,
        /// Number of ENABLED managed ad groups per smart campaign.
        ManagedAdGroupsPerSmartCampaign = 52,
        /// Number of ENABLED ad group criteria per customer.
        /// An ad group criterion is considered as ENABLED if:
        /// 1. it's not REMOVED
        /// 2. its ad group is not REMOVED
        /// 3. its campaign is not REMOVED.
        AdGroupCriteriaPerCustomer = 12,
        /// Number of ad group criteria across all base campaigns for a customer.
        BaseAdGroupCriteriaPerCustomer = 13,
        /// Number of ad group criteria across all experiment campaigns for a
        /// customer.
        ExperimentAdGroupCriteriaPerCustomer = 107,
        /// Number of ENABLED ad group criteria per campaign.
        /// An ad group criterion is considered as ENABLED if:
        /// 1. it's not REMOVED
        /// 2. its ad group is not REMOVED.
        AdGroupCriteriaPerCampaign = 14,
        /// Number of ENABLED campaign criteria per customer.
        CampaignCriteriaPerCustomer = 15,
        /// Number of ENABLED campaign criteria across all base campaigns for a
        /// customer.
        BaseCampaignCriteriaPerCustomer = 16,
        /// Number of ENABLED campaign criteria across all experiment campaigns for a
        /// customer.
        ExperimentCampaignCriteriaPerCustomer = 108,
        /// Number of ENABLED webpage criteria per customer, including
        /// campaign level and ad group level.
        WebpageCriteriaPerCustomer = 17,
        /// Number of ENABLED webpage criteria across all base campaigns for
        /// a customer.
        BaseWebpageCriteriaPerCustomer = 18,
        /// Meximum number of ENABLED webpage criteria across all experiment
        /// campaigns for a customer.
        ExperimentWebpageCriteriaPerCustomer = 19,
        /// Number of combined audience criteria per ad group.
        CombinedAudienceCriteriaPerAdGroup = 20,
        /// Limit for placement criterion type group in customer negative criterion.
        CustomerNegativePlacementCriteriaPerCustomer = 21,
        /// Limit for YouTube TV channels in customer negative criterion.
        CustomerNegativeYoutubeChannelCriteriaPerCustomer = 22,
        /// Number of ENABLED criteria per ad group.
        CriteriaPerAdGroup = 23,
        /// Number of listing group criteria per ad group.
        ListingGroupsPerAdGroup = 24,
        /// Number of ENABLED explicitly shared budgets per customer.
        ExplicitlySharedBudgetsPerCustomer = 25,
        /// Number of ENABLED implicitly shared budgets per customer.
        ImplicitlySharedBudgetsPerCustomer = 26,
        /// Number of combined audience criteria per campaign.
        CombinedAudienceCriteriaPerCampaign = 27,
        /// Number of negative keywords per campaign.
        NegativeKeywordsPerCampaign = 28,
        /// Number of excluded campaign criteria in placement dimension, for example,
        /// placement, mobile application, YouTube channel, etc. The API criterion
        /// type is NOT limited to placement only, and this does not include
        /// exclusions at the ad group or other levels.
        NegativePlacementsPerCampaign = 29,
        /// Number of geo targets per campaign.
        GeoTargetsPerCampaign = 30,
        /// Number of negative IP blocks per campaign.
        NegativeIpBlocksPerCampaign = 32,
        /// Number of proximity targets per campaign.
        ProximitiesPerCampaign = 33,
        /// Number of listing scopes per Shopping campaign.
        ListingScopesPerShoppingCampaign = 34,
        /// Number of listing scopes per non-Shopping campaign.
        ListingScopesPerNonShoppingCampaign = 35,
        /// Number of criteria per negative keyword shared set.
        NegativeKeywordsPerSharedSet = 36,
        /// Number of criteria per negative placement shared set.
        NegativePlacementsPerSharedSet = 37,
        /// Default number of shared sets allowed per type per customer.
        SharedSetsPerCustomerForTypeDefault = 40,
        /// Number of shared sets of negative placement list type for a
        /// manager customer.
        SharedSetsPerCustomerForNegativePlacementListLower = 41,
        /// Number of hotel_advance_booking_window bid modifiers per ad group.
        HotelAdvanceBookingWindowBidModifiersPerAdGroup = 44,
        /// Number of ENABLED shared bidding strategies per customer.
        BiddingStrategiesPerCustomer = 45,
        /// Number of open basic user lists per customer.
        BasicUserListsPerCustomer = 47,
        /// Number of open logical user lists per customer.
        LogicalUserListsPerCustomer = 48,
        /// Number of open rule based user lists per customer.
        RuleBasedUserListsPerCustomer = 153,
        /// Number of ENABLED and PAUSED ad group ads across all base campaigns for a
        /// customer.
        BaseAdGroupAdsPerCustomer = 53,
        /// Number of ENABLED and PAUSED ad group ads across all experiment campaigns
        /// for a customer.
        ExperimentAdGroupAdsPerCustomer = 54,
        /// Number of ENABLED and PAUSED ad group ads per campaign.
        AdGroupAdsPerCampaign = 55,
        /// Number of ENABLED ads per ad group that do not fall in to other buckets.
        /// Includes text and many other types.
        TextAndOtherAdsPerAdGroup = 56,
        /// Number of ENABLED image ads per ad group.
        ImageAdsPerAdGroup = 57,
        /// Number of ENABLED shopping smart ads per ad group.
        ShoppingSmartAdsPerAdGroup = 58,
        /// Number of ENABLED responsive search ads per ad group.
        ResponsiveSearchAdsPerAdGroup = 59,
        /// Number of ENABLED app ads per ad group.
        AppAdsPerAdGroup = 60,
        /// Number of ENABLED app engagement ads per ad group.
        AppEngagementAdsPerAdGroup = 61,
        /// Number of ENABLED local ads per ad group.
        LocalAdsPerAdGroup = 62,
        /// Number of ENABLED video ads per ad group.
        VideoAdsPerAdGroup = 63,
        /// Number of ENABLED lead form CampaignAssets per campaign.
        LeadFormCampaignAssetsPerCampaign = 143,
        /// Number of ENABLED promotion CustomerAssets per customer.
        PromotionCustomerAssetsPerCustomer = 79,
        /// Number of ENABLED promotion CampaignAssets per campaign.
        PromotionCampaignAssetsPerCampaign = 80,
        /// Number of ENABLED promotion AdGroupAssets per ad group.
        PromotionAdGroupAssetsPerAdGroup = 81,
        /// Number of ENABLED callout CustomerAssets per customer.
        CalloutCustomerAssetsPerCustomer = 134,
        /// Number of ENABLED callout CampaignAssets per campaign.
        CalloutCampaignAssetsPerCampaign = 135,
        /// Number of ENABLED callout AdGroupAssets per ad group.
        CalloutAdGroupAssetsPerAdGroup = 136,
        /// Number of ENABLED sitelink CustomerAssets per customer.
        SitelinkCustomerAssetsPerCustomer = 137,
        /// Number of ENABLED sitelink CampaignAssets per campaign.
        SitelinkCampaignAssetsPerCampaign = 138,
        /// Number of ENABLED sitelink AdGroupAssets per ad group.
        SitelinkAdGroupAssetsPerAdGroup = 139,
        /// Number of ENABLED structured snippet CustomerAssets per customer.
        StructuredSnippetCustomerAssetsPerCustomer = 140,
        /// Number of ENABLED structured snippet CampaignAssets per campaign.
        StructuredSnippetCampaignAssetsPerCampaign = 141,
        /// Number of ENABLED structured snippet AdGroupAssets per ad group.
        StructuredSnippetAdGroupAssetsPerAdGroup = 142,
        /// Number of ENABLED mobile app CustomerAssets per customer.
        MobileAppCustomerAssetsPerCustomer = 144,
        /// Number of ENABLED mobile app CampaignAssets per campaign.
        MobileAppCampaignAssetsPerCampaign = 145,
        /// Number of ENABLED mobile app AdGroupAssets per ad group.
        MobileAppAdGroupAssetsPerAdGroup = 146,
        /// Number of ENABLED hotel callout CustomerAssets per customer.
        HotelCalloutCustomerAssetsPerCustomer = 147,
        /// Number of ENABLED hotel callout CampaignAssets per campaign.
        HotelCalloutCampaignAssetsPerCampaign = 148,
        /// Number of ENABLED hotel callout AdGroupAssets per ad group.
        HotelCalloutAdGroupAssetsPerAdGroup = 149,
        /// Number of ENABLED call CustomerAssets per customer.
        CallCustomerAssetsPerCustomer = 150,
        /// Number of ENABLED call CampaignAssets per campaign.
        CallCampaignAssetsPerCampaign = 151,
        /// Number of ENABLED call AdGroupAssets per ad group.
        CallAdGroupAssetsPerAdGroup = 152,
        /// Number of ENABLED price CustomerAssets per customer.
        PriceCustomerAssetsPerCustomer = 154,
        /// Number of ENABLED price CampaignAssets per campaign.
        PriceCampaignAssetsPerCampaign = 155,
        /// Number of ENABLED price AdGroupAssets per ad group.
        PriceAdGroupAssetsPerAdGroup = 156,
        /// Number of ENABLED ad image CampaignAssets per campaign.
        AdImageCampaignAssetsPerCampaign = 175,
        /// Number of ENABLED ad image AdGroupAssets per ad group.
        AdImageAdGroupAssetsPerAdGroup = 176,
        /// Number of ENABLED page feed asset sets per customer.
        PageFeedAssetSetsPerCustomer = 157,
        /// Number of ENABLED dynamic education feed asset sets per customer.
        DynamicEducationFeedAssetSetsPerCustomer = 158,
        /// Number of ENABLED assets per page feed asset set.
        AssetsPerPageFeedAssetSet = 159,
        /// Number of ENABLED assets per dynamic education asset set.
        AssetsPerDynamicEducationFeedAssetSet = 160,
        /// Number of ENABLED dynamic real estate asset sets per customer.
        DynamicRealEstateAssetSetsPerCustomer = 161,
        /// Number of ENABLED assets per dynamic real estate asset set.
        AssetsPerDynamicRealEstateAssetSet = 162,
        /// Number of ENABLED dynamic custom asset sets per customer.
        DynamicCustomAssetSetsPerCustomer = 163,
        /// Number of ENABLED assets per dynamic custom asset set.
        AssetsPerDynamicCustomAssetSet = 164,
        /// Number of ENABLED dynamic hotels and rentals asset sets per
        /// customer.
        DynamicHotelsAndRentalsAssetSetsPerCustomer = 165,
        /// Number of ENABLED assets per dynamic hotels and rentals asset set.
        AssetsPerDynamicHotelsAndRentalsAssetSet = 166,
        /// Number of ENABLED dynamic local asset sets per customer.
        DynamicLocalAssetSetsPerCustomer = 167,
        /// Number of ENABLED assets per dynamic local asset set.
        AssetsPerDynamicLocalAssetSet = 168,
        /// Number of ENABLED dynamic flights asset sets per customer.
        DynamicFlightsAssetSetsPerCustomer = 169,
        /// Number of ENABLED assets per dynamic flights asset set.
        AssetsPerDynamicFlightsAssetSet = 170,
        /// Number of ENABLED dynamic travel asset sets per customer.
        DynamicTravelAssetSetsPerCustomer = 171,
        /// Number of ENABLED assets per dynamic travel asset set.
        AssetsPerDynamicTravelAssetSet = 172,
        /// Number of ENABLED dynamic jobs asset sets per customer.
        DynamicJobsAssetSetsPerCustomer = 173,
        /// Number of ENABLED assets per dynamic jobs asset set.
        AssetsPerDynamicJobsAssetSet = 174,
        /// Number of ENABLED business name CampaignAssets per campaign.
        BusinessNameCampaignAssetsPerCampaign = 179,
        /// Number of ENABLED business logo CampaignAssets per campaign.
        BusinessLogoCampaignAssetsPerCampaign = 180,
        /// Number of versions per ad.
        VersionsPerAd = 82,
        /// Number of ENABLED user feeds per customer.
        UserFeedsPerCustomer = 90,
        /// Number of ENABLED system feeds per customer.
        SystemFeedsPerCustomer = 91,
        /// Number of feed attributes per feed.
        FeedAttributesPerFeed = 92,
        /// Number of ENABLED feed items per customer.
        FeedItemsPerCustomer = 94,
        /// Number of ENABLED campaign feeds per customer.
        CampaignFeedsPerCustomer = 95,
        /// Number of ENABLED campaign feeds across all base campaigns for a
        /// customer.
        BaseCampaignFeedsPerCustomer = 96,
        /// Number of ENABLED campaign feeds across all experiment campaigns for a
        /// customer.
        ExperimentCampaignFeedsPerCustomer = 109,
        /// Number of ENABLED ad group feeds per customer.
        AdGroupFeedsPerCustomer = 97,
        /// Number of ENABLED ad group feeds across all base campaigns for a
        /// customer.
        BaseAdGroupFeedsPerCustomer = 98,
        /// Number of ENABLED ad group feeds across all experiment campaigns for a
        /// customer.
        ExperimentAdGroupFeedsPerCustomer = 110,
        /// Number of ENABLED ad group feeds per campaign.
        AdGroupFeedsPerCampaign = 99,
        /// Number of ENABLED feed items per customer.
        FeedItemSetsPerCustomer = 100,
        /// Number of feed items per feed item set.
        FeedItemsPerFeedItemSet = 101,
        /// Number of ENABLED campaign experiments per customer.
        CampaignExperimentsPerCustomer = 112,
        /// Number of video experiment arms per experiment.
        ExperimentArmsPerVideoExperiment = 113,
        /// Number of owned labels per customer.
        OwnedLabelsPerCustomer = 115,
        /// Number of applied labels per campaign.
        LabelsPerCampaign = 117,
        /// Number of applied labels per ad group.
        LabelsPerAdGroup = 118,
        /// Number of applied labels per ad group ad.
        LabelsPerAdGroupAd = 119,
        /// Number of applied labels per ad group criterion.
        LabelsPerAdGroupCriterion = 120,
        /// Number of customers with a single label applied.
        TargetCustomersPerLabel = 121,
        /// Number of ENABLED keyword plans per user per customer.
        /// The limit is applied per <user, customer> pair because by default a plan
        /// is private to a user of a customer. Each user of a customer has their own
        /// independent limit.
        KeywordPlansPerUserPerCustomer = 122,
        /// Number of keyword plan ad group keywords per keyword plan.
        KeywordPlanAdGroupKeywordsPerKeywordPlan = 123,
        /// Number of keyword plan ad groups per keyword plan.
        KeywordPlanAdGroupsPerKeywordPlan = 124,
        /// Number of keyword plan negative keywords (both campaign and ad group) per
        /// keyword plan.
        KeywordPlanNegativeKeywordsPerKeywordPlan = 125,
        /// Number of keyword plan campaigns per keyword plan.
        KeywordPlanCampaignsPerKeywordPlan = 126,
        /// Number of ENABLED conversion actions per customer.
        ConversionActionsPerCustomer = 128,
        /// Number of operations in a single batch job.
        BatchJobOperationsPerJob = 130,
        /// Number of PENDING or ENABLED batch jobs per customer.
        BatchJobsPerCustomer = 131,
        /// Number of hotel check-in date range bid modifiers per ad agroup.
        HotelCheckInDateRangeBidModifiersPerAdGroup = 132,
        /// Number of shared sets of type ACCOUNT_LEVEL_NEGATIVE_KEYWORDS per
        /// account.
        SharedSetsPerAccountForAccountLevelNegativeKeywords = 177,
        /// Number of keywords per ACCOUNT_LEVEL_NEGATIVE_KEYWORDS shared set.
        AccountLevelNegativeKeywordsPerSharedSet = 178,
        /// Maximum number of asset per hotel property asset set.
        EnabledAssetPerHotelPropertyAssetSet = 181,
        /// Maximum number of enabled hotel property assets per asset group.
        EnabledHotelPropertyAssetLinksPerAssetGroup = 182,
        /// Number of criteria per brand shared set.
        BrandsPerSharedSet = 183,
        /// Number of active brand list criteria per campaign.
        EnabledBrandListCriteriaPerCampaign = 184,
        /// Maximum number of shared sets of brand type for an account.
        SharedSetsPerAccountForBrand = 185,
        /// Maximum number of lookalike lists per customer.
        LookalikeUserListsPerCustomer = 186,
    }
    impl ResourceLimitType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CampaignsPerCustomer => "CAMPAIGNS_PER_CUSTOMER",
                Self::BaseCampaignsPerCustomer => "BASE_CAMPAIGNS_PER_CUSTOMER",
                Self::ExperimentCampaignsPerCustomer => {
                    "EXPERIMENT_CAMPAIGNS_PER_CUSTOMER"
                }
                Self::HotelCampaignsPerCustomer => "HOTEL_CAMPAIGNS_PER_CUSTOMER",
                Self::SmartShoppingCampaignsPerCustomer => {
                    "SMART_SHOPPING_CAMPAIGNS_PER_CUSTOMER"
                }
                Self::AdGroupsPerCampaign => "AD_GROUPS_PER_CAMPAIGN",
                Self::AdGroupsPerShoppingCampaign => "AD_GROUPS_PER_SHOPPING_CAMPAIGN",
                Self::AdGroupsPerHotelCampaign => "AD_GROUPS_PER_HOTEL_CAMPAIGN",
                Self::ReportingAdGroupsPerLocalCampaign => {
                    "REPORTING_AD_GROUPS_PER_LOCAL_CAMPAIGN"
                }
                Self::ReportingAdGroupsPerAppCampaign => {
                    "REPORTING_AD_GROUPS_PER_APP_CAMPAIGN"
                }
                Self::ManagedAdGroupsPerSmartCampaign => {
                    "MANAGED_AD_GROUPS_PER_SMART_CAMPAIGN"
                }
                Self::AdGroupCriteriaPerCustomer => "AD_GROUP_CRITERIA_PER_CUSTOMER",
                Self::BaseAdGroupCriteriaPerCustomer => {
                    "BASE_AD_GROUP_CRITERIA_PER_CUSTOMER"
                }
                Self::ExperimentAdGroupCriteriaPerCustomer => {
                    "EXPERIMENT_AD_GROUP_CRITERIA_PER_CUSTOMER"
                }
                Self::AdGroupCriteriaPerCampaign => "AD_GROUP_CRITERIA_PER_CAMPAIGN",
                Self::CampaignCriteriaPerCustomer => "CAMPAIGN_CRITERIA_PER_CUSTOMER",
                Self::BaseCampaignCriteriaPerCustomer => {
                    "BASE_CAMPAIGN_CRITERIA_PER_CUSTOMER"
                }
                Self::ExperimentCampaignCriteriaPerCustomer => {
                    "EXPERIMENT_CAMPAIGN_CRITERIA_PER_CUSTOMER"
                }
                Self::WebpageCriteriaPerCustomer => "WEBPAGE_CRITERIA_PER_CUSTOMER",
                Self::BaseWebpageCriteriaPerCustomer => {
                    "BASE_WEBPAGE_CRITERIA_PER_CUSTOMER"
                }
                Self::ExperimentWebpageCriteriaPerCustomer => {
                    "EXPERIMENT_WEBPAGE_CRITERIA_PER_CUSTOMER"
                }
                Self::CombinedAudienceCriteriaPerAdGroup => {
                    "COMBINED_AUDIENCE_CRITERIA_PER_AD_GROUP"
                }
                Self::CustomerNegativePlacementCriteriaPerCustomer => {
                    "CUSTOMER_NEGATIVE_PLACEMENT_CRITERIA_PER_CUSTOMER"
                }
                Self::CustomerNegativeYoutubeChannelCriteriaPerCustomer => {
                    "CUSTOMER_NEGATIVE_YOUTUBE_CHANNEL_CRITERIA_PER_CUSTOMER"
                }
                Self::CriteriaPerAdGroup => "CRITERIA_PER_AD_GROUP",
                Self::ListingGroupsPerAdGroup => "LISTING_GROUPS_PER_AD_GROUP",
                Self::ExplicitlySharedBudgetsPerCustomer => {
                    "EXPLICITLY_SHARED_BUDGETS_PER_CUSTOMER"
                }
                Self::ImplicitlySharedBudgetsPerCustomer => {
                    "IMPLICITLY_SHARED_BUDGETS_PER_CUSTOMER"
                }
                Self::CombinedAudienceCriteriaPerCampaign => {
                    "COMBINED_AUDIENCE_CRITERIA_PER_CAMPAIGN"
                }
                Self::NegativeKeywordsPerCampaign => "NEGATIVE_KEYWORDS_PER_CAMPAIGN",
                Self::NegativePlacementsPerCampaign => "NEGATIVE_PLACEMENTS_PER_CAMPAIGN",
                Self::GeoTargetsPerCampaign => "GEO_TARGETS_PER_CAMPAIGN",
                Self::NegativeIpBlocksPerCampaign => "NEGATIVE_IP_BLOCKS_PER_CAMPAIGN",
                Self::ProximitiesPerCampaign => "PROXIMITIES_PER_CAMPAIGN",
                Self::ListingScopesPerShoppingCampaign => {
                    "LISTING_SCOPES_PER_SHOPPING_CAMPAIGN"
                }
                Self::ListingScopesPerNonShoppingCampaign => {
                    "LISTING_SCOPES_PER_NON_SHOPPING_CAMPAIGN"
                }
                Self::NegativeKeywordsPerSharedSet => "NEGATIVE_KEYWORDS_PER_SHARED_SET",
                Self::NegativePlacementsPerSharedSet => {
                    "NEGATIVE_PLACEMENTS_PER_SHARED_SET"
                }
                Self::SharedSetsPerCustomerForTypeDefault => {
                    "SHARED_SETS_PER_CUSTOMER_FOR_TYPE_DEFAULT"
                }
                Self::SharedSetsPerCustomerForNegativePlacementListLower => {
                    "SHARED_SETS_PER_CUSTOMER_FOR_NEGATIVE_PLACEMENT_LIST_LOWER"
                }
                Self::HotelAdvanceBookingWindowBidModifiersPerAdGroup => {
                    "HOTEL_ADVANCE_BOOKING_WINDOW_BID_MODIFIERS_PER_AD_GROUP"
                }
                Self::BiddingStrategiesPerCustomer => "BIDDING_STRATEGIES_PER_CUSTOMER",
                Self::BasicUserListsPerCustomer => "BASIC_USER_LISTS_PER_CUSTOMER",
                Self::LogicalUserListsPerCustomer => "LOGICAL_USER_LISTS_PER_CUSTOMER",
                Self::RuleBasedUserListsPerCustomer => {
                    "RULE_BASED_USER_LISTS_PER_CUSTOMER"
                }
                Self::BaseAdGroupAdsPerCustomer => "BASE_AD_GROUP_ADS_PER_CUSTOMER",
                Self::ExperimentAdGroupAdsPerCustomer => {
                    "EXPERIMENT_AD_GROUP_ADS_PER_CUSTOMER"
                }
                Self::AdGroupAdsPerCampaign => "AD_GROUP_ADS_PER_CAMPAIGN",
                Self::TextAndOtherAdsPerAdGroup => "TEXT_AND_OTHER_ADS_PER_AD_GROUP",
                Self::ImageAdsPerAdGroup => "IMAGE_ADS_PER_AD_GROUP",
                Self::ShoppingSmartAdsPerAdGroup => "SHOPPING_SMART_ADS_PER_AD_GROUP",
                Self::ResponsiveSearchAdsPerAdGroup => {
                    "RESPONSIVE_SEARCH_ADS_PER_AD_GROUP"
                }
                Self::AppAdsPerAdGroup => "APP_ADS_PER_AD_GROUP",
                Self::AppEngagementAdsPerAdGroup => "APP_ENGAGEMENT_ADS_PER_AD_GROUP",
                Self::LocalAdsPerAdGroup => "LOCAL_ADS_PER_AD_GROUP",
                Self::VideoAdsPerAdGroup => "VIDEO_ADS_PER_AD_GROUP",
                Self::LeadFormCampaignAssetsPerCampaign => {
                    "LEAD_FORM_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                Self::PromotionCustomerAssetsPerCustomer => {
                    "PROMOTION_CUSTOMER_ASSETS_PER_CUSTOMER"
                }
                Self::PromotionCampaignAssetsPerCampaign => {
                    "PROMOTION_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                Self::PromotionAdGroupAssetsPerAdGroup => {
                    "PROMOTION_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                Self::CalloutCustomerAssetsPerCustomer => {
                    "CALLOUT_CUSTOMER_ASSETS_PER_CUSTOMER"
                }
                Self::CalloutCampaignAssetsPerCampaign => {
                    "CALLOUT_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                Self::CalloutAdGroupAssetsPerAdGroup => {
                    "CALLOUT_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                Self::SitelinkCustomerAssetsPerCustomer => {
                    "SITELINK_CUSTOMER_ASSETS_PER_CUSTOMER"
                }
                Self::SitelinkCampaignAssetsPerCampaign => {
                    "SITELINK_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                Self::SitelinkAdGroupAssetsPerAdGroup => {
                    "SITELINK_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                Self::StructuredSnippetCustomerAssetsPerCustomer => {
                    "STRUCTURED_SNIPPET_CUSTOMER_ASSETS_PER_CUSTOMER"
                }
                Self::StructuredSnippetCampaignAssetsPerCampaign => {
                    "STRUCTURED_SNIPPET_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                Self::StructuredSnippetAdGroupAssetsPerAdGroup => {
                    "STRUCTURED_SNIPPET_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                Self::MobileAppCustomerAssetsPerCustomer => {
                    "MOBILE_APP_CUSTOMER_ASSETS_PER_CUSTOMER"
                }
                Self::MobileAppCampaignAssetsPerCampaign => {
                    "MOBILE_APP_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                Self::MobileAppAdGroupAssetsPerAdGroup => {
                    "MOBILE_APP_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                Self::HotelCalloutCustomerAssetsPerCustomer => {
                    "HOTEL_CALLOUT_CUSTOMER_ASSETS_PER_CUSTOMER"
                }
                Self::HotelCalloutCampaignAssetsPerCampaign => {
                    "HOTEL_CALLOUT_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                Self::HotelCalloutAdGroupAssetsPerAdGroup => {
                    "HOTEL_CALLOUT_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                Self::CallCustomerAssetsPerCustomer => {
                    "CALL_CUSTOMER_ASSETS_PER_CUSTOMER"
                }
                Self::CallCampaignAssetsPerCampaign => {
                    "CALL_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                Self::CallAdGroupAssetsPerAdGroup => "CALL_AD_GROUP_ASSETS_PER_AD_GROUP",
                Self::PriceCustomerAssetsPerCustomer => {
                    "PRICE_CUSTOMER_ASSETS_PER_CUSTOMER"
                }
                Self::PriceCampaignAssetsPerCampaign => {
                    "PRICE_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                Self::PriceAdGroupAssetsPerAdGroup => {
                    "PRICE_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                Self::AdImageCampaignAssetsPerCampaign => {
                    "AD_IMAGE_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                Self::AdImageAdGroupAssetsPerAdGroup => {
                    "AD_IMAGE_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                Self::PageFeedAssetSetsPerCustomer => "PAGE_FEED_ASSET_SETS_PER_CUSTOMER",
                Self::DynamicEducationFeedAssetSetsPerCustomer => {
                    "DYNAMIC_EDUCATION_FEED_ASSET_SETS_PER_CUSTOMER"
                }
                Self::AssetsPerPageFeedAssetSet => "ASSETS_PER_PAGE_FEED_ASSET_SET",
                Self::AssetsPerDynamicEducationFeedAssetSet => {
                    "ASSETS_PER_DYNAMIC_EDUCATION_FEED_ASSET_SET"
                }
                Self::DynamicRealEstateAssetSetsPerCustomer => {
                    "DYNAMIC_REAL_ESTATE_ASSET_SETS_PER_CUSTOMER"
                }
                Self::AssetsPerDynamicRealEstateAssetSet => {
                    "ASSETS_PER_DYNAMIC_REAL_ESTATE_ASSET_SET"
                }
                Self::DynamicCustomAssetSetsPerCustomer => {
                    "DYNAMIC_CUSTOM_ASSET_SETS_PER_CUSTOMER"
                }
                Self::AssetsPerDynamicCustomAssetSet => {
                    "ASSETS_PER_DYNAMIC_CUSTOM_ASSET_SET"
                }
                Self::DynamicHotelsAndRentalsAssetSetsPerCustomer => {
                    "DYNAMIC_HOTELS_AND_RENTALS_ASSET_SETS_PER_CUSTOMER"
                }
                Self::AssetsPerDynamicHotelsAndRentalsAssetSet => {
                    "ASSETS_PER_DYNAMIC_HOTELS_AND_RENTALS_ASSET_SET"
                }
                Self::DynamicLocalAssetSetsPerCustomer => {
                    "DYNAMIC_LOCAL_ASSET_SETS_PER_CUSTOMER"
                }
                Self::AssetsPerDynamicLocalAssetSet => {
                    "ASSETS_PER_DYNAMIC_LOCAL_ASSET_SET"
                }
                Self::DynamicFlightsAssetSetsPerCustomer => {
                    "DYNAMIC_FLIGHTS_ASSET_SETS_PER_CUSTOMER"
                }
                Self::AssetsPerDynamicFlightsAssetSet => {
                    "ASSETS_PER_DYNAMIC_FLIGHTS_ASSET_SET"
                }
                Self::DynamicTravelAssetSetsPerCustomer => {
                    "DYNAMIC_TRAVEL_ASSET_SETS_PER_CUSTOMER"
                }
                Self::AssetsPerDynamicTravelAssetSet => {
                    "ASSETS_PER_DYNAMIC_TRAVEL_ASSET_SET"
                }
                Self::DynamicJobsAssetSetsPerCustomer => {
                    "DYNAMIC_JOBS_ASSET_SETS_PER_CUSTOMER"
                }
                Self::AssetsPerDynamicJobsAssetSet => "ASSETS_PER_DYNAMIC_JOBS_ASSET_SET",
                Self::BusinessNameCampaignAssetsPerCampaign => {
                    "BUSINESS_NAME_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                Self::BusinessLogoCampaignAssetsPerCampaign => {
                    "BUSINESS_LOGO_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                Self::VersionsPerAd => "VERSIONS_PER_AD",
                Self::UserFeedsPerCustomer => "USER_FEEDS_PER_CUSTOMER",
                Self::SystemFeedsPerCustomer => "SYSTEM_FEEDS_PER_CUSTOMER",
                Self::FeedAttributesPerFeed => "FEED_ATTRIBUTES_PER_FEED",
                Self::FeedItemsPerCustomer => "FEED_ITEMS_PER_CUSTOMER",
                Self::CampaignFeedsPerCustomer => "CAMPAIGN_FEEDS_PER_CUSTOMER",
                Self::BaseCampaignFeedsPerCustomer => "BASE_CAMPAIGN_FEEDS_PER_CUSTOMER",
                Self::ExperimentCampaignFeedsPerCustomer => {
                    "EXPERIMENT_CAMPAIGN_FEEDS_PER_CUSTOMER"
                }
                Self::AdGroupFeedsPerCustomer => "AD_GROUP_FEEDS_PER_CUSTOMER",
                Self::BaseAdGroupFeedsPerCustomer => "BASE_AD_GROUP_FEEDS_PER_CUSTOMER",
                Self::ExperimentAdGroupFeedsPerCustomer => {
                    "EXPERIMENT_AD_GROUP_FEEDS_PER_CUSTOMER"
                }
                Self::AdGroupFeedsPerCampaign => "AD_GROUP_FEEDS_PER_CAMPAIGN",
                Self::FeedItemSetsPerCustomer => "FEED_ITEM_SETS_PER_CUSTOMER",
                Self::FeedItemsPerFeedItemSet => "FEED_ITEMS_PER_FEED_ITEM_SET",
                Self::CampaignExperimentsPerCustomer => {
                    "CAMPAIGN_EXPERIMENTS_PER_CUSTOMER"
                }
                Self::ExperimentArmsPerVideoExperiment => {
                    "EXPERIMENT_ARMS_PER_VIDEO_EXPERIMENT"
                }
                Self::OwnedLabelsPerCustomer => "OWNED_LABELS_PER_CUSTOMER",
                Self::LabelsPerCampaign => "LABELS_PER_CAMPAIGN",
                Self::LabelsPerAdGroup => "LABELS_PER_AD_GROUP",
                Self::LabelsPerAdGroupAd => "LABELS_PER_AD_GROUP_AD",
                Self::LabelsPerAdGroupCriterion => "LABELS_PER_AD_GROUP_CRITERION",
                Self::TargetCustomersPerLabel => "TARGET_CUSTOMERS_PER_LABEL",
                Self::KeywordPlansPerUserPerCustomer => {
                    "KEYWORD_PLANS_PER_USER_PER_CUSTOMER"
                }
                Self::KeywordPlanAdGroupKeywordsPerKeywordPlan => {
                    "KEYWORD_PLAN_AD_GROUP_KEYWORDS_PER_KEYWORD_PLAN"
                }
                Self::KeywordPlanAdGroupsPerKeywordPlan => {
                    "KEYWORD_PLAN_AD_GROUPS_PER_KEYWORD_PLAN"
                }
                Self::KeywordPlanNegativeKeywordsPerKeywordPlan => {
                    "KEYWORD_PLAN_NEGATIVE_KEYWORDS_PER_KEYWORD_PLAN"
                }
                Self::KeywordPlanCampaignsPerKeywordPlan => {
                    "KEYWORD_PLAN_CAMPAIGNS_PER_KEYWORD_PLAN"
                }
                Self::ConversionActionsPerCustomer => "CONVERSION_ACTIONS_PER_CUSTOMER",
                Self::BatchJobOperationsPerJob => "BATCH_JOB_OPERATIONS_PER_JOB",
                Self::BatchJobsPerCustomer => "BATCH_JOBS_PER_CUSTOMER",
                Self::HotelCheckInDateRangeBidModifiersPerAdGroup => {
                    "HOTEL_CHECK_IN_DATE_RANGE_BID_MODIFIERS_PER_AD_GROUP"
                }
                Self::SharedSetsPerAccountForAccountLevelNegativeKeywords => {
                    "SHARED_SETS_PER_ACCOUNT_FOR_ACCOUNT_LEVEL_NEGATIVE_KEYWORDS"
                }
                Self::AccountLevelNegativeKeywordsPerSharedSet => {
                    "ACCOUNT_LEVEL_NEGATIVE_KEYWORDS_PER_SHARED_SET"
                }
                Self::EnabledAssetPerHotelPropertyAssetSet => {
                    "ENABLED_ASSET_PER_HOTEL_PROPERTY_ASSET_SET"
                }
                Self::EnabledHotelPropertyAssetLinksPerAssetGroup => {
                    "ENABLED_HOTEL_PROPERTY_ASSET_LINKS_PER_ASSET_GROUP"
                }
                Self::BrandsPerSharedSet => "BRANDS_PER_SHARED_SET",
                Self::EnabledBrandListCriteriaPerCampaign => {
                    "ENABLED_BRAND_LIST_CRITERIA_PER_CAMPAIGN"
                }
                Self::SharedSetsPerAccountForBrand => "SHARED_SETS_PER_ACCOUNT_FOR_BRAND",
                Self::LookalikeUserListsPerCustomer => {
                    "LOOKALIKE_USER_LISTS_PER_CUSTOMER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGNS_PER_CUSTOMER" => Some(Self::CampaignsPerCustomer),
                "BASE_CAMPAIGNS_PER_CUSTOMER" => Some(Self::BaseCampaignsPerCustomer),
                "EXPERIMENT_CAMPAIGNS_PER_CUSTOMER" => {
                    Some(Self::ExperimentCampaignsPerCustomer)
                }
                "HOTEL_CAMPAIGNS_PER_CUSTOMER" => Some(Self::HotelCampaignsPerCustomer),
                "SMART_SHOPPING_CAMPAIGNS_PER_CUSTOMER" => {
                    Some(Self::SmartShoppingCampaignsPerCustomer)
                }
                "AD_GROUPS_PER_CAMPAIGN" => Some(Self::AdGroupsPerCampaign),
                "AD_GROUPS_PER_SHOPPING_CAMPAIGN" => {
                    Some(Self::AdGroupsPerShoppingCampaign)
                }
                "AD_GROUPS_PER_HOTEL_CAMPAIGN" => Some(Self::AdGroupsPerHotelCampaign),
                "REPORTING_AD_GROUPS_PER_LOCAL_CAMPAIGN" => {
                    Some(Self::ReportingAdGroupsPerLocalCampaign)
                }
                "REPORTING_AD_GROUPS_PER_APP_CAMPAIGN" => {
                    Some(Self::ReportingAdGroupsPerAppCampaign)
                }
                "MANAGED_AD_GROUPS_PER_SMART_CAMPAIGN" => {
                    Some(Self::ManagedAdGroupsPerSmartCampaign)
                }
                "AD_GROUP_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::AdGroupCriteriaPerCustomer)
                }
                "BASE_AD_GROUP_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::BaseAdGroupCriteriaPerCustomer)
                }
                "EXPERIMENT_AD_GROUP_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::ExperimentAdGroupCriteriaPerCustomer)
                }
                "AD_GROUP_CRITERIA_PER_CAMPAIGN" => {
                    Some(Self::AdGroupCriteriaPerCampaign)
                }
                "CAMPAIGN_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::CampaignCriteriaPerCustomer)
                }
                "BASE_CAMPAIGN_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::BaseCampaignCriteriaPerCustomer)
                }
                "EXPERIMENT_CAMPAIGN_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::ExperimentCampaignCriteriaPerCustomer)
                }
                "WEBPAGE_CRITERIA_PER_CUSTOMER" => Some(Self::WebpageCriteriaPerCustomer),
                "BASE_WEBPAGE_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::BaseWebpageCriteriaPerCustomer)
                }
                "EXPERIMENT_WEBPAGE_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::ExperimentWebpageCriteriaPerCustomer)
                }
                "COMBINED_AUDIENCE_CRITERIA_PER_AD_GROUP" => {
                    Some(Self::CombinedAudienceCriteriaPerAdGroup)
                }
                "CUSTOMER_NEGATIVE_PLACEMENT_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::CustomerNegativePlacementCriteriaPerCustomer)
                }
                "CUSTOMER_NEGATIVE_YOUTUBE_CHANNEL_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::CustomerNegativeYoutubeChannelCriteriaPerCustomer)
                }
                "CRITERIA_PER_AD_GROUP" => Some(Self::CriteriaPerAdGroup),
                "LISTING_GROUPS_PER_AD_GROUP" => Some(Self::ListingGroupsPerAdGroup),
                "EXPLICITLY_SHARED_BUDGETS_PER_CUSTOMER" => {
                    Some(Self::ExplicitlySharedBudgetsPerCustomer)
                }
                "IMPLICITLY_SHARED_BUDGETS_PER_CUSTOMER" => {
                    Some(Self::ImplicitlySharedBudgetsPerCustomer)
                }
                "COMBINED_AUDIENCE_CRITERIA_PER_CAMPAIGN" => {
                    Some(Self::CombinedAudienceCriteriaPerCampaign)
                }
                "NEGATIVE_KEYWORDS_PER_CAMPAIGN" => {
                    Some(Self::NegativeKeywordsPerCampaign)
                }
                "NEGATIVE_PLACEMENTS_PER_CAMPAIGN" => {
                    Some(Self::NegativePlacementsPerCampaign)
                }
                "GEO_TARGETS_PER_CAMPAIGN" => Some(Self::GeoTargetsPerCampaign),
                "NEGATIVE_IP_BLOCKS_PER_CAMPAIGN" => {
                    Some(Self::NegativeIpBlocksPerCampaign)
                }
                "PROXIMITIES_PER_CAMPAIGN" => Some(Self::ProximitiesPerCampaign),
                "LISTING_SCOPES_PER_SHOPPING_CAMPAIGN" => {
                    Some(Self::ListingScopesPerShoppingCampaign)
                }
                "LISTING_SCOPES_PER_NON_SHOPPING_CAMPAIGN" => {
                    Some(Self::ListingScopesPerNonShoppingCampaign)
                }
                "NEGATIVE_KEYWORDS_PER_SHARED_SET" => {
                    Some(Self::NegativeKeywordsPerSharedSet)
                }
                "NEGATIVE_PLACEMENTS_PER_SHARED_SET" => {
                    Some(Self::NegativePlacementsPerSharedSet)
                }
                "SHARED_SETS_PER_CUSTOMER_FOR_TYPE_DEFAULT" => {
                    Some(Self::SharedSetsPerCustomerForTypeDefault)
                }
                "SHARED_SETS_PER_CUSTOMER_FOR_NEGATIVE_PLACEMENT_LIST_LOWER" => {
                    Some(Self::SharedSetsPerCustomerForNegativePlacementListLower)
                }
                "HOTEL_ADVANCE_BOOKING_WINDOW_BID_MODIFIERS_PER_AD_GROUP" => {
                    Some(Self::HotelAdvanceBookingWindowBidModifiersPerAdGroup)
                }
                "BIDDING_STRATEGIES_PER_CUSTOMER" => {
                    Some(Self::BiddingStrategiesPerCustomer)
                }
                "BASIC_USER_LISTS_PER_CUSTOMER" => Some(Self::BasicUserListsPerCustomer),
                "LOGICAL_USER_LISTS_PER_CUSTOMER" => {
                    Some(Self::LogicalUserListsPerCustomer)
                }
                "RULE_BASED_USER_LISTS_PER_CUSTOMER" => {
                    Some(Self::RuleBasedUserListsPerCustomer)
                }
                "BASE_AD_GROUP_ADS_PER_CUSTOMER" => Some(Self::BaseAdGroupAdsPerCustomer),
                "EXPERIMENT_AD_GROUP_ADS_PER_CUSTOMER" => {
                    Some(Self::ExperimentAdGroupAdsPerCustomer)
                }
                "AD_GROUP_ADS_PER_CAMPAIGN" => Some(Self::AdGroupAdsPerCampaign),
                "TEXT_AND_OTHER_ADS_PER_AD_GROUP" => {
                    Some(Self::TextAndOtherAdsPerAdGroup)
                }
                "IMAGE_ADS_PER_AD_GROUP" => Some(Self::ImageAdsPerAdGroup),
                "SHOPPING_SMART_ADS_PER_AD_GROUP" => {
                    Some(Self::ShoppingSmartAdsPerAdGroup)
                }
                "RESPONSIVE_SEARCH_ADS_PER_AD_GROUP" => {
                    Some(Self::ResponsiveSearchAdsPerAdGroup)
                }
                "APP_ADS_PER_AD_GROUP" => Some(Self::AppAdsPerAdGroup),
                "APP_ENGAGEMENT_ADS_PER_AD_GROUP" => {
                    Some(Self::AppEngagementAdsPerAdGroup)
                }
                "LOCAL_ADS_PER_AD_GROUP" => Some(Self::LocalAdsPerAdGroup),
                "VIDEO_ADS_PER_AD_GROUP" => Some(Self::VideoAdsPerAdGroup),
                "LEAD_FORM_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::LeadFormCampaignAssetsPerCampaign)
                }
                "PROMOTION_CUSTOMER_ASSETS_PER_CUSTOMER" => {
                    Some(Self::PromotionCustomerAssetsPerCustomer)
                }
                "PROMOTION_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::PromotionCampaignAssetsPerCampaign)
                }
                "PROMOTION_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::PromotionAdGroupAssetsPerAdGroup)
                }
                "CALLOUT_CUSTOMER_ASSETS_PER_CUSTOMER" => {
                    Some(Self::CalloutCustomerAssetsPerCustomer)
                }
                "CALLOUT_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::CalloutCampaignAssetsPerCampaign)
                }
                "CALLOUT_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::CalloutAdGroupAssetsPerAdGroup)
                }
                "SITELINK_CUSTOMER_ASSETS_PER_CUSTOMER" => {
                    Some(Self::SitelinkCustomerAssetsPerCustomer)
                }
                "SITELINK_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::SitelinkCampaignAssetsPerCampaign)
                }
                "SITELINK_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::SitelinkAdGroupAssetsPerAdGroup)
                }
                "STRUCTURED_SNIPPET_CUSTOMER_ASSETS_PER_CUSTOMER" => {
                    Some(Self::StructuredSnippetCustomerAssetsPerCustomer)
                }
                "STRUCTURED_SNIPPET_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::StructuredSnippetCampaignAssetsPerCampaign)
                }
                "STRUCTURED_SNIPPET_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::StructuredSnippetAdGroupAssetsPerAdGroup)
                }
                "MOBILE_APP_CUSTOMER_ASSETS_PER_CUSTOMER" => {
                    Some(Self::MobileAppCustomerAssetsPerCustomer)
                }
                "MOBILE_APP_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::MobileAppCampaignAssetsPerCampaign)
                }
                "MOBILE_APP_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::MobileAppAdGroupAssetsPerAdGroup)
                }
                "HOTEL_CALLOUT_CUSTOMER_ASSETS_PER_CUSTOMER" => {
                    Some(Self::HotelCalloutCustomerAssetsPerCustomer)
                }
                "HOTEL_CALLOUT_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::HotelCalloutCampaignAssetsPerCampaign)
                }
                "HOTEL_CALLOUT_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::HotelCalloutAdGroupAssetsPerAdGroup)
                }
                "CALL_CUSTOMER_ASSETS_PER_CUSTOMER" => {
                    Some(Self::CallCustomerAssetsPerCustomer)
                }
                "CALL_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::CallCampaignAssetsPerCampaign)
                }
                "CALL_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::CallAdGroupAssetsPerAdGroup)
                }
                "PRICE_CUSTOMER_ASSETS_PER_CUSTOMER" => {
                    Some(Self::PriceCustomerAssetsPerCustomer)
                }
                "PRICE_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::PriceCampaignAssetsPerCampaign)
                }
                "PRICE_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::PriceAdGroupAssetsPerAdGroup)
                }
                "AD_IMAGE_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::AdImageCampaignAssetsPerCampaign)
                }
                "AD_IMAGE_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::AdImageAdGroupAssetsPerAdGroup)
                }
                "PAGE_FEED_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::PageFeedAssetSetsPerCustomer)
                }
                "DYNAMIC_EDUCATION_FEED_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::DynamicEducationFeedAssetSetsPerCustomer)
                }
                "ASSETS_PER_PAGE_FEED_ASSET_SET" => Some(Self::AssetsPerPageFeedAssetSet),
                "ASSETS_PER_DYNAMIC_EDUCATION_FEED_ASSET_SET" => {
                    Some(Self::AssetsPerDynamicEducationFeedAssetSet)
                }
                "DYNAMIC_REAL_ESTATE_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::DynamicRealEstateAssetSetsPerCustomer)
                }
                "ASSETS_PER_DYNAMIC_REAL_ESTATE_ASSET_SET" => {
                    Some(Self::AssetsPerDynamicRealEstateAssetSet)
                }
                "DYNAMIC_CUSTOM_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::DynamicCustomAssetSetsPerCustomer)
                }
                "ASSETS_PER_DYNAMIC_CUSTOM_ASSET_SET" => {
                    Some(Self::AssetsPerDynamicCustomAssetSet)
                }
                "DYNAMIC_HOTELS_AND_RENTALS_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::DynamicHotelsAndRentalsAssetSetsPerCustomer)
                }
                "ASSETS_PER_DYNAMIC_HOTELS_AND_RENTALS_ASSET_SET" => {
                    Some(Self::AssetsPerDynamicHotelsAndRentalsAssetSet)
                }
                "DYNAMIC_LOCAL_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::DynamicLocalAssetSetsPerCustomer)
                }
                "ASSETS_PER_DYNAMIC_LOCAL_ASSET_SET" => {
                    Some(Self::AssetsPerDynamicLocalAssetSet)
                }
                "DYNAMIC_FLIGHTS_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::DynamicFlightsAssetSetsPerCustomer)
                }
                "ASSETS_PER_DYNAMIC_FLIGHTS_ASSET_SET" => {
                    Some(Self::AssetsPerDynamicFlightsAssetSet)
                }
                "DYNAMIC_TRAVEL_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::DynamicTravelAssetSetsPerCustomer)
                }
                "ASSETS_PER_DYNAMIC_TRAVEL_ASSET_SET" => {
                    Some(Self::AssetsPerDynamicTravelAssetSet)
                }
                "DYNAMIC_JOBS_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::DynamicJobsAssetSetsPerCustomer)
                }
                "ASSETS_PER_DYNAMIC_JOBS_ASSET_SET" => {
                    Some(Self::AssetsPerDynamicJobsAssetSet)
                }
                "BUSINESS_NAME_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::BusinessNameCampaignAssetsPerCampaign)
                }
                "BUSINESS_LOGO_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::BusinessLogoCampaignAssetsPerCampaign)
                }
                "VERSIONS_PER_AD" => Some(Self::VersionsPerAd),
                "USER_FEEDS_PER_CUSTOMER" => Some(Self::UserFeedsPerCustomer),
                "SYSTEM_FEEDS_PER_CUSTOMER" => Some(Self::SystemFeedsPerCustomer),
                "FEED_ATTRIBUTES_PER_FEED" => Some(Self::FeedAttributesPerFeed),
                "FEED_ITEMS_PER_CUSTOMER" => Some(Self::FeedItemsPerCustomer),
                "CAMPAIGN_FEEDS_PER_CUSTOMER" => Some(Self::CampaignFeedsPerCustomer),
                "BASE_CAMPAIGN_FEEDS_PER_CUSTOMER" => {
                    Some(Self::BaseCampaignFeedsPerCustomer)
                }
                "EXPERIMENT_CAMPAIGN_FEEDS_PER_CUSTOMER" => {
                    Some(Self::ExperimentCampaignFeedsPerCustomer)
                }
                "AD_GROUP_FEEDS_PER_CUSTOMER" => Some(Self::AdGroupFeedsPerCustomer),
                "BASE_AD_GROUP_FEEDS_PER_CUSTOMER" => {
                    Some(Self::BaseAdGroupFeedsPerCustomer)
                }
                "EXPERIMENT_AD_GROUP_FEEDS_PER_CUSTOMER" => {
                    Some(Self::ExperimentAdGroupFeedsPerCustomer)
                }
                "AD_GROUP_FEEDS_PER_CAMPAIGN" => Some(Self::AdGroupFeedsPerCampaign),
                "FEED_ITEM_SETS_PER_CUSTOMER" => Some(Self::FeedItemSetsPerCustomer),
                "FEED_ITEMS_PER_FEED_ITEM_SET" => Some(Self::FeedItemsPerFeedItemSet),
                "CAMPAIGN_EXPERIMENTS_PER_CUSTOMER" => {
                    Some(Self::CampaignExperimentsPerCustomer)
                }
                "EXPERIMENT_ARMS_PER_VIDEO_EXPERIMENT" => {
                    Some(Self::ExperimentArmsPerVideoExperiment)
                }
                "OWNED_LABELS_PER_CUSTOMER" => Some(Self::OwnedLabelsPerCustomer),
                "LABELS_PER_CAMPAIGN" => Some(Self::LabelsPerCampaign),
                "LABELS_PER_AD_GROUP" => Some(Self::LabelsPerAdGroup),
                "LABELS_PER_AD_GROUP_AD" => Some(Self::LabelsPerAdGroupAd),
                "LABELS_PER_AD_GROUP_CRITERION" => Some(Self::LabelsPerAdGroupCriterion),
                "TARGET_CUSTOMERS_PER_LABEL" => Some(Self::TargetCustomersPerLabel),
                "KEYWORD_PLANS_PER_USER_PER_CUSTOMER" => {
                    Some(Self::KeywordPlansPerUserPerCustomer)
                }
                "KEYWORD_PLAN_AD_GROUP_KEYWORDS_PER_KEYWORD_PLAN" => {
                    Some(Self::KeywordPlanAdGroupKeywordsPerKeywordPlan)
                }
                "KEYWORD_PLAN_AD_GROUPS_PER_KEYWORD_PLAN" => {
                    Some(Self::KeywordPlanAdGroupsPerKeywordPlan)
                }
                "KEYWORD_PLAN_NEGATIVE_KEYWORDS_PER_KEYWORD_PLAN" => {
                    Some(Self::KeywordPlanNegativeKeywordsPerKeywordPlan)
                }
                "KEYWORD_PLAN_CAMPAIGNS_PER_KEYWORD_PLAN" => {
                    Some(Self::KeywordPlanCampaignsPerKeywordPlan)
                }
                "CONVERSION_ACTIONS_PER_CUSTOMER" => {
                    Some(Self::ConversionActionsPerCustomer)
                }
                "BATCH_JOB_OPERATIONS_PER_JOB" => Some(Self::BatchJobOperationsPerJob),
                "BATCH_JOBS_PER_CUSTOMER" => Some(Self::BatchJobsPerCustomer),
                "HOTEL_CHECK_IN_DATE_RANGE_BID_MODIFIERS_PER_AD_GROUP" => {
                    Some(Self::HotelCheckInDateRangeBidModifiersPerAdGroup)
                }
                "SHARED_SETS_PER_ACCOUNT_FOR_ACCOUNT_LEVEL_NEGATIVE_KEYWORDS" => {
                    Some(Self::SharedSetsPerAccountForAccountLevelNegativeKeywords)
                }
                "ACCOUNT_LEVEL_NEGATIVE_KEYWORDS_PER_SHARED_SET" => {
                    Some(Self::AccountLevelNegativeKeywordsPerSharedSet)
                }
                "ENABLED_ASSET_PER_HOTEL_PROPERTY_ASSET_SET" => {
                    Some(Self::EnabledAssetPerHotelPropertyAssetSet)
                }
                "ENABLED_HOTEL_PROPERTY_ASSET_LINKS_PER_ASSET_GROUP" => {
                    Some(Self::EnabledHotelPropertyAssetLinksPerAssetGroup)
                }
                "BRANDS_PER_SHARED_SET" => Some(Self::BrandsPerSharedSet),
                "ENABLED_BRAND_LIST_CRITERIA_PER_CAMPAIGN" => {
                    Some(Self::EnabledBrandListCriteriaPerCampaign)
                }
                "SHARED_SETS_PER_ACCOUNT_FOR_BRAND" => {
                    Some(Self::SharedSetsPerAccountForBrand)
                }
                "LOOKALIKE_USER_LISTS_PER_CUSTOMER" => {
                    Some(Self::LookalikeUserListsPerCustomer)
                }
                _ => None,
            }
        }
    }
}
/// Container for possible response content types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseContentTypeEnum {}
/// Nested message and enum types in `ResponseContentTypeEnum`.
pub mod response_content_type_enum {
    /// Possible response content types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResponseContentType {
        /// Not specified. Will return the resource name only in the response.
        Unspecified = 0,
        /// The mutate response will be the resource name.
        ResourceNameOnly = 1,
        /// The mutate response will contain the resource name and the resource with
        /// mutable fields if possible. Otherwise, only the resource name will be
        /// returned.
        MutableResource = 2,
    }
    impl ResponseContentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::ResourceNameOnly => "RESOURCE_NAME_ONLY",
                Self::MutableResource => "MUTABLE_RESOURCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "RESOURCE_NAME_ONLY" => Some(Self::ResourceNameOnly),
                "MUTABLE_RESOURCE" => Some(Self::MutableResource),
                _ => None,
            }
        }
    }
}
/// Container for enum indicating whether a search term is one of your targeted
/// or excluded keywords.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SearchTermTargetingStatusEnum {}
/// Nested message and enum types in `SearchTermTargetingStatusEnum`.
pub mod search_term_targeting_status_enum {
    /// Indicates whether the search term is one of your targeted or excluded
    /// keywords.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SearchTermTargetingStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Search term is added to targeted keywords.
        Added = 2,
        /// Search term matches a negative keyword.
        Excluded = 3,
        /// Search term has been both added and excluded.
        AddedExcluded = 4,
        /// Search term is neither targeted nor excluded.
        None = 5,
    }
    impl SearchTermTargetingStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Added => "ADDED",
                Self::Excluded => "EXCLUDED",
                Self::AddedExcluded => "ADDED_EXCLUDED",
                Self::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADDED" => Some(Self::Added),
                "EXCLUDED" => Some(Self::Excluded),
                "ADDED_EXCLUDED" => Some(Self::AddedExcluded),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
/// Message describing seasonality event scopes. The two types of seasonality
/// events are BiddingSeasonalityAdjustments and BiddingDataExclusions.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeasonalityEventScopeEnum {}
/// Nested message and enum types in `SeasonalityEventScopeEnum`.
pub mod seasonality_event_scope_enum {
    /// The possible scopes of a Seasonality Event.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SeasonalityEventScope {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// The seasonality event is applied to all the customer's traffic for
        /// supported advertising channel types and device types. The CUSTOMER scope
        /// cannot be used in mutates.
        Customer = 2,
        /// The seasonality event is applied to all specified campaigns.
        Campaign = 4,
        /// The seasonality event is applied to all campaigns that belong to
        /// specified channel types.
        Channel = 5,
    }
    impl SeasonalityEventScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Customer => "CUSTOMER",
                Self::Campaign => "CAMPAIGN",
                Self::Channel => "CHANNEL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOMER" => Some(Self::Customer),
                "CAMPAIGN" => Some(Self::Campaign),
                "CHANNEL" => Some(Self::Channel),
                _ => None,
            }
        }
    }
}
/// Message describing seasonality event statuses. The two types of seasonality
/// events are BiddingSeasonalityAdjustments and BiddingDataExclusions.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeasonalityEventStatusEnum {}
/// Nested message and enum types in `SeasonalityEventStatusEnum`.
pub mod seasonality_event_status_enum {
    /// The possible statuses of a Seasonality Event.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SeasonalityEventStatus {
        /// No value has been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// The seasonality event is enabled.
        Enabled = 2,
        /// The seasonality event is removed.
        Removed = 4,
    }
    impl SeasonalityEventStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing types of shared set statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SharedSetStatusEnum {}
/// Nested message and enum types in `SharedSetStatusEnum`.
pub mod shared_set_status_enum {
    /// Enum listing the possible shared set statuses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SharedSetStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The shared set is enabled.
        Enabled = 2,
        /// The shared set is removed and can no longer be used.
        Removed = 3,
    }
    impl SharedSetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
/// Container for enum describing types of shared sets.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SharedSetTypeEnum {}
/// Nested message and enum types in `SharedSetTypeEnum`.
pub mod shared_set_type_enum {
    /// Enum listing the possible shared set types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SharedSetType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// A set of keywords that can be excluded from targeting.
        NegativeKeywords = 2,
        /// A set of placements that can be excluded from targeting.
        NegativePlacements = 3,
        /// An account-level set of keywords that can be excluded from targeting.
        AccountLevelNegativeKeywords = 4,
        /// A set of brands can be included or excluded from targeting.
        Brands = 5,
    }
    impl SharedSetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NegativeKeywords => "NEGATIVE_KEYWORDS",
                Self::NegativePlacements => "NEGATIVE_PLACEMENTS",
                Self::AccountLevelNegativeKeywords => "ACCOUNT_LEVEL_NEGATIVE_KEYWORDS",
                Self::Brands => "BRANDS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEGATIVE_KEYWORDS" => Some(Self::NegativeKeywords),
                "NEGATIVE_PLACEMENTS" => Some(Self::NegativePlacements),
                "ACCOUNT_LEVEL_NEGATIVE_KEYWORDS" => {
                    Some(Self::AccountLevelNegativeKeywords)
                }
                "BRANDS" => Some(Self::Brands),
                _ => None,
            }
        }
    }
}
/// Indicates the key issue that results in a shopping campaign targeting zero
/// products.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShoppingAddProductsToCampaignRecommendationEnum {}
/// Nested message and enum types in `ShoppingAddProductsToCampaignRecommendationEnum`.
pub mod shopping_add_products_to_campaign_recommendation_enum {
    /// Issues that results in a shopping campaign targeting zero products.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Reason {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The Merchant Center account does not have any submitted products.
        MerchantCenterAccountHasNoSubmittedProducts = 2,
        /// The Merchant Center account does not have any submitted products in the
        /// feed.
        MerchantCenterAccountHasNoSubmittedProductsInFeed = 3,
        /// The Google Ads account has active campaign filters that prevents
        /// inclusion of offers in the campaign.
        AdsAccountExcludesOffersFromCampaign = 4,
        /// All products available have been explicitly excluded from
        /// being targeted by the campaign.
        AllProductsAreExcludedFromCampaign = 5,
    }
    impl Reason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::MerchantCenterAccountHasNoSubmittedProducts => {
                    "MERCHANT_CENTER_ACCOUNT_HAS_NO_SUBMITTED_PRODUCTS"
                }
                Self::MerchantCenterAccountHasNoSubmittedProductsInFeed => {
                    "MERCHANT_CENTER_ACCOUNT_HAS_NO_SUBMITTED_PRODUCTS_IN_FEED"
                }
                Self::AdsAccountExcludesOffersFromCampaign => {
                    "ADS_ACCOUNT_EXCLUDES_OFFERS_FROM_CAMPAIGN"
                }
                Self::AllProductsAreExcludedFromCampaign => {
                    "ALL_PRODUCTS_ARE_EXCLUDED_FROM_CAMPAIGN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MERCHANT_CENTER_ACCOUNT_HAS_NO_SUBMITTED_PRODUCTS" => {
                    Some(Self::MerchantCenterAccountHasNoSubmittedProducts)
                }
                "MERCHANT_CENTER_ACCOUNT_HAS_NO_SUBMITTED_PRODUCTS_IN_FEED" => {
                    Some(Self::MerchantCenterAccountHasNoSubmittedProductsInFeed)
                }
                "ADS_ACCOUNT_EXCLUDES_OFFERS_FROM_CAMPAIGN" => {
                    Some(Self::AdsAccountExcludesOffersFromCampaign)
                }
                "ALL_PRODUCTS_ARE_EXCLUDED_FROM_CAMPAIGN" => {
                    Some(Self::AllProductsAreExcludedFromCampaign)
                }
                _ => None,
            }
        }
    }
}
/// Container for enum describing the method by which a simulation modifies
/// a field.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SimulationModificationMethodEnum {}
/// Nested message and enum types in `SimulationModificationMethodEnum`.
pub mod simulation_modification_method_enum {
    /// Enum describing the method by which a simulation modifies a field.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SimulationModificationMethod {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The values in a simulation were applied to all children of a given
        /// resource uniformly. Overrides on child resources were not respected.
        Uniform = 2,
        /// The values in a simulation were applied to the given resource.
        /// Overrides on child resources were respected, and traffic estimates
        /// do not include these resources.
        Default = 3,
        /// The values in a simulation were all scaled by the same factor.
        /// For example, in a simulated TargetCpa campaign, the campaign target and
        /// all ad group targets were scaled by a factor of X.
        Scaling = 4,
    }
    impl SimulationModificationMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Uniform => "UNIFORM",
                Self::Default => "DEFAULT",
                Self::Scaling => "SCALING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNIFORM" => Some(Self::Uniform),
                "DEFAULT" => Some(Self::Default),
                "SCALING" => Some(Self::Scaling),
                _ => None,
            }
        }
    }
}
/// Container for enum describing the field a simulation modifies.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SimulationTypeEnum {}
/// Nested message and enum types in `SimulationTypeEnum`.
pub mod simulation_type_enum {
    /// Enum describing the field a simulation modifies.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SimulationType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The simulation is for a CPC bid.
        CpcBid = 2,
        /// The simulation is for a CPV bid.
        CpvBid = 3,
        /// The simulation is for a CPA target.
        TargetCpa = 4,
        /// The simulation is for a bid modifier.
        BidModifier = 5,
        /// The simulation is for a ROAS target.
        TargetRoas = 6,
        /// The simulation is for a percent CPC bid.
        PercentCpcBid = 7,
        /// The simulation is for an impression share target.
        TargetImpressionShare = 8,
        /// The simulation is for a budget.
        Budget = 9,
    }
    impl SimulationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::CpcBid => "CPC_BID",
                Self::CpvBid => "CPV_BID",
                Self::TargetCpa => "TARGET_CPA",
                Self::BidModifier => "BID_MODIFIER",
                Self::TargetRoas => "TARGET_ROAS",
                Self::PercentCpcBid => "PERCENT_CPC_BID",
                Self::TargetImpressionShare => "TARGET_IMPRESSION_SHARE",
                Self::Budget => "BUDGET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CPC_BID" => Some(Self::CpcBid),
                "CPV_BID" => Some(Self::CpvBid),
                "TARGET_CPA" => Some(Self::TargetCpa),
                "BID_MODIFIER" => Some(Self::BidModifier),
                "TARGET_ROAS" => Some(Self::TargetRoas),
                "PERCENT_CPC_BID" => Some(Self::PercentCpcBid),
                "TARGET_IMPRESSION_SHARE" => Some(Self::TargetImpressionShare),
                "BUDGET" => Some(Self::Budget),
                _ => None,
            }
        }
    }
}
/// Values for Sitelink placeholder fields.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SitelinkPlaceholderFieldEnum {}
/// Nested message and enum types in `SitelinkPlaceholderFieldEnum`.
pub mod sitelink_placeholder_field_enum {
    /// Possible values for Sitelink placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SitelinkPlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. The link text for your sitelink.
        Text = 2,
        /// Data Type: STRING. First line of the sitelink description.
        Line1 = 3,
        /// Data Type: STRING. Second line of the sitelink description.
        Line2 = 4,
        /// Data Type: URL_LIST. Final URLs for the sitelink when using Upgraded
        /// URLs.
        FinalUrls = 5,
        /// Data Type: URL_LIST. Final Mobile URLs for the sitelink when using
        /// Upgraded URLs.
        FinalMobileUrls = 6,
        /// Data Type: URL. Tracking template for the sitelink when using Upgraded
        /// URLs.
        TrackingUrl = 7,
        /// Data Type: STRING. Final URL suffix for sitelink when using parallel
        /// tracking.
        FinalUrlSuffix = 8,
    }
    impl SitelinkPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Text => "TEXT",
                Self::Line1 => "LINE_1",
                Self::Line2 => "LINE_2",
                Self::FinalUrls => "FINAL_URLS",
                Self::FinalMobileUrls => "FINAL_MOBILE_URLS",
                Self::TrackingUrl => "TRACKING_URL",
                Self::FinalUrlSuffix => "FINAL_URL_SUFFIX",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TEXT" => Some(Self::Text),
                "LINE_1" => Some(Self::Line1),
                "LINE_2" => Some(Self::Line2),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "FINAL_URL_SUFFIX" => Some(Self::FinalUrlSuffix),
                _ => None,
            }
        }
    }
}
/// A container for an enum that describes reasons for why a Smart campaign
/// is not eligible to serve.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SmartCampaignNotEligibleReasonEnum {}
/// Nested message and enum types in `SmartCampaignNotEligibleReasonEnum`.
pub mod smart_campaign_not_eligible_reason_enum {
    /// Reasons for why a Smart campaign is not eligible to serve.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SmartCampaignNotEligibleReason {
        /// The status has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// The campaign is not eligible to serve because of an issue with the
        /// account.
        AccountIssue = 2,
        /// The campaign is not eligible to serve because of a payment issue.
        BillingIssue = 3,
        /// The business profile location associated with the campaign has been
        /// removed.
        BusinessProfileLocationRemoved = 4,
        /// All system-generated ads have been disapproved. Consult the
        /// policy_summary field in the AdGroupAd resource for more details.
        AllAdsDisapproved = 5,
    }
    impl SmartCampaignNotEligibleReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AccountIssue => "ACCOUNT_ISSUE",
                Self::BillingIssue => "BILLING_ISSUE",
                Self::BusinessProfileLocationRemoved => {
                    "BUSINESS_PROFILE_LOCATION_REMOVED"
                }
                Self::AllAdsDisapproved => "ALL_ADS_DISAPPROVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACCOUNT_ISSUE" => Some(Self::AccountIssue),
                "BILLING_ISSUE" => Some(Self::BillingIssue),
                "BUSINESS_PROFILE_LOCATION_REMOVED" => {
                    Some(Self::BusinessProfileLocationRemoved)
                }
                "ALL_ADS_DISAPPROVED" => Some(Self::AllAdsDisapproved),
                _ => None,
            }
        }
    }
}
/// A container for an enum that describes Smart campaign statuses.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SmartCampaignStatusEnum {}
/// Nested message and enum types in `SmartCampaignStatusEnum`.
pub mod smart_campaign_status_enum {
    /// Smart campaign statuses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SmartCampaignStatus {
        /// The status has not been specified.
        Unspecified = 0,
        /// The received value is not known in this version.
        ///
        /// This is a response-only value.
        Unknown = 1,
        /// The campaign was paused.
        Paused = 2,
        /// The campaign is not eligible to serve and has issues that may require
        /// intervention.
        NotEligible = 3,
        /// The campaign is pending the approval of at least one ad.
        Pending = 4,
        /// The campaign is eligible to serve.
        Eligible = 5,
        /// The campaign has been removed.
        Removed = 6,
        /// The campaign has ended.
        Ended = 7,
    }
    impl SmartCampaignStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Paused => "PAUSED",
                Self::NotEligible => "NOT_ELIGIBLE",
                Self::Pending => "PENDING",
                Self::Eligible => "ELIGIBLE",
                Self::Removed => "REMOVED",
                Self::Ended => "ENDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PAUSED" => Some(Self::Paused),
                "NOT_ELIGIBLE" => Some(Self::NotEligible),
                "PENDING" => Some(Self::Pending),
                "ELIGIBLE" => Some(Self::Eligible),
                "REMOVED" => Some(Self::Removed),
                "ENDED" => Some(Self::Ended),
                _ => None,
            }
        }
    }
}
/// Message describing spending limit types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SpendingLimitTypeEnum {}
/// Nested message and enum types in `SpendingLimitTypeEnum`.
pub mod spending_limit_type_enum {
    /// The possible spending limit types used by certain resources as an
    /// alternative to absolute money values in micros.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SpendingLimitType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Infinite, indicates unlimited spending power.
        Infinite = 2,
    }
    impl SpendingLimitType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Infinite => "INFINITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INFINITE" => Some(Self::Infinite),
                _ => None,
            }
        }
    }
}
/// Values for Structured Snippet placeholder fields.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StructuredSnippetPlaceholderFieldEnum {}
/// Nested message and enum types in `StructuredSnippetPlaceholderFieldEnum`.
pub mod structured_snippet_placeholder_field_enum {
    /// Possible values for Structured Snippet placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StructuredSnippetPlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. The category of snippet of your products/services.
        /// Must match exactly one of the predefined structured snippets headers.
        /// For a list, visit
        /// <https://developers.google.com/google-ads/api/reference/data/structured-snippet-headers>
        Header = 2,
        /// Data Type: STRING_LIST. Text values that describe your products/services.
        /// All text must be family safe. Special or non-ASCII characters are not
        /// permitted. A snippet can be at most 25 characters.
        Snippets = 3,
    }
    impl StructuredSnippetPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Header => "HEADER",
                Self::Snippets => "SNIPPETS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "HEADER" => Some(Self::Header),
                "SNIPPETS" => Some(Self::Snippets),
                _ => None,
            }
        }
    }
}
/// Indicates summary row setting in request parameter.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummaryRowSettingEnum {}
/// Nested message and enum types in `SummaryRowSettingEnum`.
pub mod summary_row_setting_enum {
    /// Enum describing return summary row settings.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SummaryRowSetting {
        /// Not specified.
        Unspecified = 0,
        /// Represent unknown values of return summary row.
        Unknown = 1,
        /// Do not return summary row.
        NoSummaryRow = 2,
        /// Return summary row along with results. The summary row will be returned
        /// in the last batch alone (last batch will contain no results).
        SummaryRowWithResults = 3,
        /// Return summary row only and return no results.
        SummaryRowOnly = 4,
    }
    impl SummaryRowSetting {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::NoSummaryRow => "NO_SUMMARY_ROW",
                Self::SummaryRowWithResults => "SUMMARY_ROW_WITH_RESULTS",
                Self::SummaryRowOnly => "SUMMARY_ROW_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NO_SUMMARY_ROW" => Some(Self::NoSummaryRow),
                "SUMMARY_ROW_WITH_RESULTS" => Some(Self::SummaryRowWithResults),
                "SUMMARY_ROW_ONLY" => Some(Self::SummaryRowOnly),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible system managed entity sources.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SystemManagedResourceSourceEnum {}
/// Nested message and enum types in `SystemManagedResourceSourceEnum`.
pub mod system_managed_resource_source_enum {
    /// Enum listing the possible system managed entity sources.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SystemManagedResourceSource {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Generated ad variations experiment ad.
        AdVariations = 2,
    }
    impl SystemManagedResourceSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::AdVariations => "AD_VARIATIONS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_VARIATIONS" => Some(Self::AdVariations),
                _ => None,
            }
        }
    }
}
/// Container for enum describing goals for TargetCpaOptIn recommendation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TargetCpaOptInRecommendationGoalEnum {}
/// Nested message and enum types in `TargetCpaOptInRecommendationGoalEnum`.
pub mod target_cpa_opt_in_recommendation_goal_enum {
    /// Goal of TargetCpaOptIn recommendation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetCpaOptInRecommendationGoal {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Recommendation to set Target CPA to maintain the same cost.
        SameCost = 2,
        /// Recommendation to set Target CPA to maintain the same conversions.
        SameConversions = 3,
        /// Recommendation to set Target CPA to maintain the same CPA.
        SameCpa = 4,
        /// Recommendation to set Target CPA to a value that is as close as possible
        /// to, yet lower than, the actual CPA (computed for past 28 days).
        ClosestCpa = 5,
    }
    impl TargetCpaOptInRecommendationGoal {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::SameCost => "SAME_COST",
                Self::SameConversions => "SAME_CONVERSIONS",
                Self::SameCpa => "SAME_CPA",
                Self::ClosestCpa => "CLOSEST_CPA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SAME_COST" => Some(Self::SameCost),
                "SAME_CONVERSIONS" => Some(Self::SameConversions),
                "SAME_CPA" => Some(Self::SameCpa),
                "CLOSEST_CPA" => Some(Self::ClosestCpa),
                _ => None,
            }
        }
    }
}
/// Message describing time types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeTypeEnum {}
/// Nested message and enum types in `TimeTypeEnum`.
pub mod time_type_enum {
    /// The possible time types used by certain resources as an alternative to
    /// absolute timestamps.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimeType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// As soon as possible.
        Now = 2,
        /// An infinite point in the future.
        Forever = 3,
    }
    impl TimeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Now => "NOW",
                Self::Forever => "FOREVER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOW" => Some(Self::Now),
                "FOREVER" => Some(Self::Forever),
                _ => None,
            }
        }
    }
}
/// Values for Travel placeholder fields.
/// For more information about dynamic remarketing feeds, see
/// <https://support.google.com/google-ads/answer/6053288.>
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TravelPlaceholderFieldEnum {}
/// Nested message and enum types in `TravelPlaceholderFieldEnum`.
pub mod travel_placeholder_field_enum {
    /// Possible values for Travel placeholder fields.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TravelPlaceholderField {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Data Type: STRING. Required. Destination id. Example: PAR, LON.
        /// For feed items that only have destination id, destination id must be a
        /// unique key. For feed items that have both destination id and origin id,
        /// then the combination must be a unique key.
        DestinationId = 2,
        /// Data Type: STRING. Origin id. Example: PAR, LON.
        /// Combination of DESTINATION_ID and ORIGIN_ID must be
        /// unique per offer.
        OriginId = 3,
        /// Data Type: STRING. Required. Main headline with name to be shown in
        /// dynamic ad.
        Title = 4,
        /// Data Type: STRING. The destination name. Shorter names are recommended.
        DestinationName = 5,
        /// Data Type: STRING. Origin name. Shorter names are recommended.
        OriginName = 6,
        /// Data Type: STRING. Price to be shown in the ad. Highly recommended for
        /// dynamic ads.
        /// Example: "100.00 USD"
        Price = 7,
        /// Data Type: STRING. Formatted price to be shown in the ad.
        /// Example: "Starting at $100.00 USD", "$80 - $100"
        FormattedPrice = 8,
        /// Data Type: STRING. Sale price to be shown in the ad.
        /// Example: "80.00 USD"
        SalePrice = 9,
        /// Data Type: STRING. Formatted sale price to be shown in the ad.
        /// Example: "On sale for $80.00", "$60 - $80"
        FormattedSalePrice = 10,
        /// Data Type: URL. Image to be displayed in the ad.
        ImageUrl = 11,
        /// Data Type: STRING. Category of travel offer used to group like items
        /// together for recommendation engine.
        Category = 12,
        /// Data Type: STRING_LIST. Keywords used for product retrieval.
        ContextualKeywords = 13,
        /// Data Type: STRING. Address of travel offer, including postal code.
        DestinationAddress = 14,
        /// Data Type: URL_LIST. Required. Final URLs to be used in ad, when using
        /// Upgraded URLs; the more specific the better (for example, the individual
        /// URL of a specific travel offer and its location).
        FinalUrl = 15,
        /// Data Type: URL_LIST. Final mobile URLs for the ad when using Upgraded
        /// URLs.
        FinalMobileUrls = 16,
        /// Data Type: URL. Tracking template for the ad when using Upgraded URLs.
        TrackingUrl = 17,
        /// Data Type: STRING. Android app link. Must be formatted as:
        /// android-app://{package_id}/{scheme}/{host_path}.
        /// The components are defined as follows:
        /// package_id: app ID as specified in Google Play.
        /// scheme: the scheme to pass to the application. Can be HTTP, or a custom
        ///    scheme.
        /// host_path: identifies the specific content within your application.
        AndroidAppLink = 18,
        /// Data Type: STRING_LIST. List of recommended destination IDs to show
        /// together with this item.
        SimilarDestinationIds = 19,
        /// Data Type: STRING. iOS app link.
        IosAppLink = 20,
        /// Data Type: INT64. iOS app store ID.
        IosAppStoreId = 21,
    }
    impl TravelPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::DestinationId => "DESTINATION_ID",
                Self::OriginId => "ORIGIN_ID",
                Self::Title => "TITLE",
                Self::DestinationName => "DESTINATION_NAME",
                Self::OriginName => "ORIGIN_NAME",
                Self::Price => "PRICE",
                Self::FormattedPrice => "FORMATTED_PRICE",
                Self::SalePrice => "SALE_PRICE",
                Self::FormattedSalePrice => "FORMATTED_SALE_PRICE",
                Self::ImageUrl => "IMAGE_URL",
                Self::Category => "CATEGORY",
                Self::ContextualKeywords => "CONTEXTUAL_KEYWORDS",
                Self::DestinationAddress => "DESTINATION_ADDRESS",
                Self::FinalUrl => "FINAL_URL",
                Self::FinalMobileUrls => "FINAL_MOBILE_URLS",
                Self::TrackingUrl => "TRACKING_URL",
                Self::AndroidAppLink => "ANDROID_APP_LINK",
                Self::SimilarDestinationIds => "SIMILAR_DESTINATION_IDS",
                Self::IosAppLink => "IOS_APP_LINK",
                Self::IosAppStoreId => "IOS_APP_STORE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DESTINATION_ID" => Some(Self::DestinationId),
                "ORIGIN_ID" => Some(Self::OriginId),
                "TITLE" => Some(Self::Title),
                "DESTINATION_NAME" => Some(Self::DestinationName),
                "ORIGIN_NAME" => Some(Self::OriginName),
                "PRICE" => Some(Self::Price),
                "FORMATTED_PRICE" => Some(Self::FormattedPrice),
                "SALE_PRICE" => Some(Self::SalePrice),
                "FORMATTED_SALE_PRICE" => Some(Self::FormattedSalePrice),
                "IMAGE_URL" => Some(Self::ImageUrl),
                "CATEGORY" => Some(Self::Category),
                "CONTEXTUAL_KEYWORDS" => Some(Self::ContextualKeywords),
                "DESTINATION_ADDRESS" => Some(Self::DestinationAddress),
                "FINAL_URL" => Some(Self::FinalUrl),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "ANDROID_APP_LINK" => Some(Self::AndroidAppLink),
                "SIMILAR_DESTINATION_IDS" => Some(Self::SimilarDestinationIds),
                "IOS_APP_LINK" => Some(Self::IosAppLink),
                "IOS_APP_STORE_ID" => Some(Self::IosAppStoreId),
                _ => None,
            }
        }
    }
}
/// Message describing a UserInterestTaxonomyType.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserInterestTaxonomyTypeEnum {}
/// Nested message and enum types in `UserInterestTaxonomyTypeEnum`.
pub mod user_interest_taxonomy_type_enum {
    /// Enum containing the possible UserInterestTaxonomyTypes.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserInterestTaxonomyType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The affinity for this user interest.
        Affinity = 2,
        /// The market for this user interest.
        InMarket = 3,
        /// Users known to have installed applications in the specified categories.
        MobileAppInstallUser = 4,
        /// The geographical location of the interest-based vertical.
        VerticalGeo = 5,
        /// User interest criteria for new smart phone users.
        NewSmartPhoneUser = 6,
    }
    impl UserInterestTaxonomyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Affinity => "AFFINITY",
                Self::InMarket => "IN_MARKET",
                Self::MobileAppInstallUser => "MOBILE_APP_INSTALL_USER",
                Self::VerticalGeo => "VERTICAL_GEO",
                Self::NewSmartPhoneUser => "NEW_SMART_PHONE_USER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AFFINITY" => Some(Self::Affinity),
                "IN_MARKET" => Some(Self::InMarket),
                "MOBILE_APP_INSTALL_USER" => Some(Self::MobileAppInstallUser),
                "VERTICAL_GEO" => Some(Self::VerticalGeo),
                "NEW_SMART_PHONE_USER" => Some(Self::NewSmartPhoneUser),
                _ => None,
            }
        }
    }
}
/// Indicates if this client still has access to the list.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListAccessStatusEnum {}
/// Nested message and enum types in `UserListAccessStatusEnum`.
pub mod user_list_access_status_enum {
    /// Enum containing possible user list access statuses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListAccessStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The access is enabled.
        Enabled = 2,
        /// The access is disabled.
        Disabled = 3,
    }
    impl UserListAccessStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Enabled => "ENABLED",
                Self::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
/// Indicates the reason why the userlist was closed.
/// This enum is only used when a list is auto-closed by the system.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListClosingReasonEnum {}
/// Nested message and enum types in `UserListClosingReasonEnum`.
pub mod user_list_closing_reason_enum {
    /// Enum describing possible user list closing reasons.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListClosingReason {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// The userlist was closed because of not being used for over one year.
        Unused = 2,
    }
    impl UserListClosingReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Unused => "UNUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNUSED" => Some(Self::Unused),
                _ => None,
            }
        }
    }
}
/// Membership status of this user list. Indicates whether a user list is open
/// or active. Only open user lists can accumulate more users and can be used for
/// targeting.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListMembershipStatusEnum {}
/// Nested message and enum types in `UserListMembershipStatusEnum`.
pub mod user_list_membership_status_enum {
    /// Enum containing possible user list membership statuses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListMembershipStatus {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Open status - List is accruing members and can be targeted to.
        Open = 2,
        /// Closed status - No new members being added. Cannot be used for targeting.
        Closed = 3,
    }
    impl UserListMembershipStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Open => "OPEN",
                Self::Closed => "CLOSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPEN" => Some(Self::Open),
                "CLOSED" => Some(Self::Closed),
                _ => None,
            }
        }
    }
}
/// Size range in terms of number of users of a UserList.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListSizeRangeEnum {}
/// Nested message and enum types in `UserListSizeRangeEnum`.
pub mod user_list_size_range_enum {
    /// Enum containing possible user list size ranges.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListSizeRange {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// User list has less than 500 users.
        LessThanFiveHundred = 2,
        /// User list has number of users in range of 500 to 1000.
        LessThanOneThousand = 3,
        /// User list has number of users in range of 1000 to 10000.
        OneThousandToTenThousand = 4,
        /// User list has number of users in range of 10000 to 50000.
        TenThousandToFiftyThousand = 5,
        /// User list has number of users in range of 50000 to 100000.
        FiftyThousandToOneHundredThousand = 6,
        /// User list has number of users in range of 100000 to 300000.
        OneHundredThousandToThreeHundredThousand = 7,
        /// User list has number of users in range of 300000 to 500000.
        ThreeHundredThousandToFiveHundredThousand = 8,
        /// User list has number of users in range of 500000 to 1 million.
        FiveHundredThousandToOneMillion = 9,
        /// User list has number of users in range of 1 to 2 millions.
        OneMillionToTwoMillion = 10,
        /// User list has number of users in range of 2 to 3 millions.
        TwoMillionToThreeMillion = 11,
        /// User list has number of users in range of 3 to 5 millions.
        ThreeMillionToFiveMillion = 12,
        /// User list has number of users in range of 5 to 10 millions.
        FiveMillionToTenMillion = 13,
        /// User list has number of users in range of 10 to 20 millions.
        TenMillionToTwentyMillion = 14,
        /// User list has number of users in range of 20 to 30 millions.
        TwentyMillionToThirtyMillion = 15,
        /// User list has number of users in range of 30 to 50 millions.
        ThirtyMillionToFiftyMillion = 16,
        /// User list has over 50 million users.
        OverFiftyMillion = 17,
    }
    impl UserListSizeRange {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::LessThanFiveHundred => "LESS_THAN_FIVE_HUNDRED",
                Self::LessThanOneThousand => "LESS_THAN_ONE_THOUSAND",
                Self::OneThousandToTenThousand => "ONE_THOUSAND_TO_TEN_THOUSAND",
                Self::TenThousandToFiftyThousand => "TEN_THOUSAND_TO_FIFTY_THOUSAND",
                Self::FiftyThousandToOneHundredThousand => {
                    "FIFTY_THOUSAND_TO_ONE_HUNDRED_THOUSAND"
                }
                Self::OneHundredThousandToThreeHundredThousand => {
                    "ONE_HUNDRED_THOUSAND_TO_THREE_HUNDRED_THOUSAND"
                }
                Self::ThreeHundredThousandToFiveHundredThousand => {
                    "THREE_HUNDRED_THOUSAND_TO_FIVE_HUNDRED_THOUSAND"
                }
                Self::FiveHundredThousandToOneMillion => {
                    "FIVE_HUNDRED_THOUSAND_TO_ONE_MILLION"
                }
                Self::OneMillionToTwoMillion => "ONE_MILLION_TO_TWO_MILLION",
                Self::TwoMillionToThreeMillion => "TWO_MILLION_TO_THREE_MILLION",
                Self::ThreeMillionToFiveMillion => "THREE_MILLION_TO_FIVE_MILLION",
                Self::FiveMillionToTenMillion => "FIVE_MILLION_TO_TEN_MILLION",
                Self::TenMillionToTwentyMillion => "TEN_MILLION_TO_TWENTY_MILLION",
                Self::TwentyMillionToThirtyMillion => "TWENTY_MILLION_TO_THIRTY_MILLION",
                Self::ThirtyMillionToFiftyMillion => "THIRTY_MILLION_TO_FIFTY_MILLION",
                Self::OverFiftyMillion => "OVER_FIFTY_MILLION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LESS_THAN_FIVE_HUNDRED" => Some(Self::LessThanFiveHundred),
                "LESS_THAN_ONE_THOUSAND" => Some(Self::LessThanOneThousand),
                "ONE_THOUSAND_TO_TEN_THOUSAND" => Some(Self::OneThousandToTenThousand),
                "TEN_THOUSAND_TO_FIFTY_THOUSAND" => {
                    Some(Self::TenThousandToFiftyThousand)
                }
                "FIFTY_THOUSAND_TO_ONE_HUNDRED_THOUSAND" => {
                    Some(Self::FiftyThousandToOneHundredThousand)
                }
                "ONE_HUNDRED_THOUSAND_TO_THREE_HUNDRED_THOUSAND" => {
                    Some(Self::OneHundredThousandToThreeHundredThousand)
                }
                "THREE_HUNDRED_THOUSAND_TO_FIVE_HUNDRED_THOUSAND" => {
                    Some(Self::ThreeHundredThousandToFiveHundredThousand)
                }
                "FIVE_HUNDRED_THOUSAND_TO_ONE_MILLION" => {
                    Some(Self::FiveHundredThousandToOneMillion)
                }
                "ONE_MILLION_TO_TWO_MILLION" => Some(Self::OneMillionToTwoMillion),
                "TWO_MILLION_TO_THREE_MILLION" => Some(Self::TwoMillionToThreeMillion),
                "THREE_MILLION_TO_FIVE_MILLION" => Some(Self::ThreeMillionToFiveMillion),
                "FIVE_MILLION_TO_TEN_MILLION" => Some(Self::FiveMillionToTenMillion),
                "TEN_MILLION_TO_TWENTY_MILLION" => Some(Self::TenMillionToTwentyMillion),
                "TWENTY_MILLION_TO_THIRTY_MILLION" => {
                    Some(Self::TwentyMillionToThirtyMillion)
                }
                "THIRTY_MILLION_TO_FIFTY_MILLION" => {
                    Some(Self::ThirtyMillionToFiftyMillion)
                }
                "OVER_FIFTY_MILLION" => Some(Self::OverFiftyMillion),
                _ => None,
            }
        }
    }
}
/// The user list types.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListTypeEnum {}
/// Nested message and enum types in `UserListTypeEnum`.
pub mod user_list_type_enum {
    /// Enum containing possible user list types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// UserList represented as a collection of conversion types.
        Remarketing = 2,
        /// UserList represented as a combination of other user lists/interests.
        Logical = 3,
        /// UserList created in the Google Ad Manager platform.
        ExternalRemarketing = 4,
        /// UserList associated with a rule.
        RuleBased = 5,
        /// UserList with users similar to users of another UserList.
        Similar = 6,
        /// UserList of first-party CRM data provided by advertiser in the form of
        /// emails or other formats.
        CrmBased = 7,
        /// LookalikeUserlist, composed of users similar to those
        /// of a configurable seed (set of UserLists)
        Lookalike = 9,
    }
    impl UserListType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Remarketing => "REMARKETING",
                Self::Logical => "LOGICAL",
                Self::ExternalRemarketing => "EXTERNAL_REMARKETING",
                Self::RuleBased => "RULE_BASED",
                Self::Similar => "SIMILAR",
                Self::CrmBased => "CRM_BASED",
                Self::Lookalike => "LOOKALIKE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "REMARKETING" => Some(Self::Remarketing),
                "LOGICAL" => Some(Self::Logical),
                "EXTERNAL_REMARKETING" => Some(Self::ExternalRemarketing),
                "RULE_BASED" => Some(Self::RuleBased),
                "SIMILAR" => Some(Self::Similar),
                "CRM_BASED" => Some(Self::CrmBased),
                "LOOKALIKE" => Some(Self::Lookalike),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible device types used in a conversion
/// value rule.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValueRuleDeviceTypeEnum {}
/// Nested message and enum types in `ValueRuleDeviceTypeEnum`.
pub mod value_rule_device_type_enum {
    /// Possible device types used in conversion value rule.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValueRuleDeviceType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Mobile device.
        Mobile = 2,
        /// Desktop device.
        Desktop = 3,
        /// Tablet device.
        Tablet = 4,
    }
    impl ValueRuleDeviceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Mobile => "MOBILE",
                Self::Desktop => "DESKTOP",
                Self::Tablet => "TABLET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MOBILE" => Some(Self::Mobile),
                "DESKTOP" => Some(Self::Desktop),
                "TABLET" => Some(Self::Tablet),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible geographic location matching types
/// used in a conversion value rule.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValueRuleGeoLocationMatchTypeEnum {}
/// Nested message and enum types in `ValueRuleGeoLocationMatchTypeEnum`.
pub mod value_rule_geo_location_match_type_enum {
    /// Possible geographic location matching types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValueRuleGeoLocationMatchType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Either Area of Interest or Location of Presence can be used to match.
        Any = 2,
        /// Only Location of Presence can be used to match.
        LocationOfPresence = 3,
    }
    impl ValueRuleGeoLocationMatchType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Any => "ANY",
                Self::LocationOfPresence => "LOCATION_OF_PRESENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ANY" => Some(Self::Any),
                "LOCATION_OF_PRESENCE" => Some(Self::LocationOfPresence),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible operations for value rules which are
/// executed when rules are triggered.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValueRuleOperationEnum {}
/// Nested message and enum types in `ValueRuleOperationEnum`.
pub mod value_rule_operation_enum {
    /// Possible operations of the action of a conversion value rule.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValueRuleOperation {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Add provided value to conversion value.
        Add = 2,
        /// Multiply conversion value by provided value.
        Multiply = 3,
        /// Set conversion value to provided value.
        Set = 4,
    }
    impl ValueRuleOperation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Add => "ADD",
                Self::Multiply => "MULTIPLY",
                Self::Set => "SET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADD" => Some(Self::Add),
                "MULTIPLY" => Some(Self::Multiply),
                "SET" => Some(Self::Set),
                _ => None,
            }
        }
    }
}
/// Container for enum describing where a value rule set is attached.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValueRuleSetAttachmentTypeEnum {}
/// Nested message and enum types in `ValueRuleSetAttachmentTypeEnum`.
pub mod value_rule_set_attachment_type_enum {
    /// Possible level where a value rule set is attached.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValueRuleSetAttachmentType {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Attached to the customer.
        Customer = 2,
        /// Attached to a campaign.
        Campaign = 3,
    }
    impl ValueRuleSetAttachmentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::Customer => "CUSTOMER",
                Self::Campaign => "CAMPAIGN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOMER" => Some(Self::Customer),
                "CAMPAIGN" => Some(Self::Campaign),
                _ => None,
            }
        }
    }
}
/// Container for enum describing possible dimensions of a conversion value rule
/// set.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValueRuleSetDimensionEnum {}
/// Nested message and enum types in `ValueRuleSetDimensionEnum`.
pub mod value_rule_set_dimension_enum {
    /// Possible dimensions of a conversion value rule set.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValueRuleSetDimension {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Dimension for geo location.
        GeoLocation = 2,
        /// Dimension for device type.
        Device = 3,
        /// Dimension for audience.
        Audience = 4,
        /// This dimension implies the rule will always apply.
        NoCondition = 5,
    }
    impl ValueRuleSetDimension {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::GeoLocation => "GEO_LOCATION",
                Self::Device => "DEVICE",
                Self::Audience => "AUDIENCE",
                Self::NoCondition => "NO_CONDITION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "GEO_LOCATION" => Some(Self::GeoLocation),
                "DEVICE" => Some(Self::Device),
                "AUDIENCE" => Some(Self::Audience),
                "NO_CONDITION" => Some(Self::NoCondition),
                _ => None,
            }
        }
    }
}
/// The display mode for vanity pharma URLs.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VanityPharmaDisplayUrlModeEnum {}
/// Nested message and enum types in `VanityPharmaDisplayUrlModeEnum`.
pub mod vanity_pharma_display_url_mode_enum {
    /// Enum describing possible display modes for vanity pharma URLs.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VanityPharmaDisplayUrlMode {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Replace vanity pharma URL with manufacturer website url.
        ManufacturerWebsiteUrl = 2,
        /// Replace vanity pharma URL with description of the website.
        WebsiteDescription = 3,
    }
    impl VanityPharmaDisplayUrlMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::ManufacturerWebsiteUrl => "MANUFACTURER_WEBSITE_URL",
                Self::WebsiteDescription => "WEBSITE_DESCRIPTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MANUFACTURER_WEBSITE_URL" => Some(Self::ManufacturerWebsiteUrl),
                "WEBSITE_DESCRIPTION" => Some(Self::WebsiteDescription),
                _ => None,
            }
        }
    }
}
/// The text that will be displayed in display URL of the text ad when website
/// description is the selected display mode for vanity pharma URLs.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VanityPharmaTextEnum {}
/// Nested message and enum types in `VanityPharmaTextEnum`.
pub mod vanity_pharma_text_enum {
    /// Enum describing possible text.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VanityPharmaText {
        /// Not specified.
        Unspecified = 0,
        /// Used for return value only. Represents value unknown in this version.
        Unknown = 1,
        /// Prescription treatment website with website content in English.
        PrescriptionTreatmentWebsiteEn = 2,
        /// Prescription treatment website with website content in Spanish
        /// (Sitio de tratamientos con receta).
        PrescriptionTreatmentWebsiteEs = 3,
        /// Prescription device website with website content in English.
        PrescriptionDeviceWebsiteEn = 4,
        /// Prescription device website with website content in Spanish (Sitio de
        /// dispositivos con receta).
        PrescriptionDeviceWebsiteEs = 5,
        /// Medical device website with website content in English.
        MedicalDeviceWebsiteEn = 6,
        /// Medical device website with website content in Spanish (Sitio de
        /// dispositivos médicos).
        MedicalDeviceWebsiteEs = 7,
        /// Preventative treatment website with website content in English.
        PreventativeTreatmentWebsiteEn = 8,
        /// Preventative treatment website with website content in Spanish (Sitio de
        /// tratamientos preventivos).
        PreventativeTreatmentWebsiteEs = 9,
        /// Prescription contraception website with website content in English.
        PrescriptionContraceptionWebsiteEn = 10,
        /// Prescription contraception website with website content in Spanish (Sitio
        /// de anticonceptivos con receta).
        PrescriptionContraceptionWebsiteEs = 11,
        /// Prescription vaccine website with website content in English.
        PrescriptionVaccineWebsiteEn = 12,
        /// Prescription vaccine website with website content in Spanish (Sitio de
        /// vacunas con receta).
        PrescriptionVaccineWebsiteEs = 13,
    }
    impl VanityPharmaText {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Unknown => "UNKNOWN",
                Self::PrescriptionTreatmentWebsiteEn => {
                    "PRESCRIPTION_TREATMENT_WEBSITE_EN"
                }
                Self::PrescriptionTreatmentWebsiteEs => {
                    "PRESCRIPTION_TREATMENT_WEBSITE_ES"
                }
                Self::PrescriptionDeviceWebsiteEn => "PRESCRIPTION_DEVICE_WEBSITE_EN",
                Self::PrescriptionDeviceWebsiteEs => "PRESCRIPTION_DEVICE_WEBSITE_ES",
                Self::MedicalDeviceWebsiteEn => "MEDICAL_DEVICE_WEBSITE_EN",
                Self::MedicalDeviceWebsiteEs => "MEDICAL_DEVICE_WEBSITE_ES",
                Self::PreventativeTreatmentWebsiteEn => {
                    "PREVENTATIVE_TREATMENT_WEBSITE_EN"
                }
                Self::PreventativeTreatmentWebsiteEs => {
                    "PREVENTATIVE_TREATMENT_WEBSITE_ES"
                }
                Self::PrescriptionContraceptionWebsiteEn => {
                    "PRESCRIPTION_CONTRACEPTION_WEBSITE_EN"
                }
                Self::PrescriptionContraceptionWebsiteEs => {
                    "PRESCRIPTION_CONTRACEPTION_WEBSITE_ES"
                }
                Self::PrescriptionVaccineWebsiteEn => "PRESCRIPTION_VACCINE_WEBSITE_EN",
                Self::PrescriptionVaccineWebsiteEs => "PRESCRIPTION_VACCINE_WEBSITE_ES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PRESCRIPTION_TREATMENT_WEBSITE_EN" => {
                    Some(Self::PrescriptionTreatmentWebsiteEn)
                }
                "PRESCRIPTION_TREATMENT_WEBSITE_ES" => {
                    Some(Self::PrescriptionTreatmentWebsiteEs)
                }
                "PRESCRIPTION_DEVICE_WEBSITE_EN" => {
                    Some(Self::PrescriptionDeviceWebsiteEn)
                }
                "PRESCRIPTION_DEVICE_WEBSITE_ES" => {
                    Some(Self::PrescriptionDeviceWebsiteEs)
                }
                "MEDICAL_DEVICE_WEBSITE_EN" => Some(Self::MedicalDeviceWebsiteEn),
                "MEDICAL_DEVICE_WEBSITE_ES" => Some(Self::MedicalDeviceWebsiteEs),
                "PREVENTATIVE_TREATMENT_WEBSITE_EN" => {
                    Some(Self::PreventativeTreatmentWebsiteEn)
                }
                "PREVENTATIVE_TREATMENT_WEBSITE_ES" => {
                    Some(Self::PreventativeTreatmentWebsiteEs)
                }
                "PRESCRIPTION_CONTRACEPTION_WEBSITE_EN" => {
                    Some(Self::PrescriptionContraceptionWebsiteEn)
                }
                "PRESCRIPTION_CONTRACEPTION_WEBSITE_ES" => {
                    Some(Self::PrescriptionContraceptionWebsiteEs)
                }
                "PRESCRIPTION_VACCINE_WEBSITE_EN" => {
                    Some(Self::PrescriptionVaccineWebsiteEn)
                }
                "PRESCRIPTION_VACCINE_WEBSITE_ES" => {
                    Some(Self::PrescriptionVaccineWebsiteEs)
                }
                _ => None,
            }
        }
    }
}
