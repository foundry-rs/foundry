// This file is @generated by prost-build.
/// Volume describes a volume and parameters for it to be mounted to a VM.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Volume {
    /// The mount path for the volume, e.g. /mnt/disks/share.
    #[prost(string, tag = "4")]
    pub mount_path: ::prost::alloc::string::String,
    /// Mount options vary based on the type of storage volume:
    ///
    /// * For a Cloud Storage bucket, all the mount options provided
    /// by
    ///    the [`gcsfuse` tool](<https://cloud.google.com/storage/docs/gcsfuse-cli>)
    ///    are supported.
    /// * For an existing persistent disk, all mount options provided by the
    ///    [`mount` command](<https://man7.org/linux/man-pages/man8/mount.8.html>)
    ///    except writing are supported. This is due to restrictions of
    ///    [multi-writer
    ///    mode](<https://cloud.google.com/compute/docs/disks/sharing-disks-between-vms>).
    /// * For any other disk or a Network File System (NFS), all the
    ///    mount options provided by the `mount` command are supported.
    #[prost(string, repeated, tag = "5")]
    pub mount_options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The source for the volume.
    #[prost(oneof = "volume::Source", tags = "1, 2, 3, 6")]
    pub source: ::core::option::Option<volume::Source>,
}
/// Nested message and enum types in `Volume`.
pub mod volume {
    /// The source for the volume.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// A Network File System (NFS) volume. For example, a
        /// Filestore file share.
        #[prost(message, tag = "1")]
        Nfs(super::Nfs),
        /// Deprecated: please use device_name instead.
        #[prost(message, tag = "2")]
        Pd(super::Pd),
        /// A Google Cloud Storage (GCS) volume.
        #[prost(message, tag = "3")]
        Gcs(super::Gcs),
        /// Device name of an attached disk volume, which should align with a
        /// device_name specified by
        /// job.allocation_policy.instances\[0\].policy.disks\[i\].device_name or
        /// defined by the given instance template in
        /// job.allocation_policy.instances\[0\].instance_template.
        #[prost(string, tag = "6")]
        DeviceName(::prost::alloc::string::String),
    }
}
/// Represents an NFS volume.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Nfs {
    /// The IP address of the NFS.
    #[prost(string, tag = "1")]
    pub server: ::prost::alloc::string::String,
    /// Remote source path exported from the NFS, e.g., "/share".
    #[prost(string, tag = "2")]
    pub remote_path: ::prost::alloc::string::String,
}
/// Deprecated: please use device_name instead.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pd {
    /// PD disk name, e.g. pd-1.
    #[prost(string, tag = "1")]
    pub disk: ::prost::alloc::string::String,
    /// PD device name, e.g. persistent-disk-1.
    #[prost(string, tag = "2")]
    pub device: ::prost::alloc::string::String,
    /// Whether this is an existing PD. Default is false. If false, i.e., new
    /// PD, we will format it into ext4 and mount to the given path. If true, i.e.,
    /// existing PD, it should be in ext4 format and we will mount it to the given
    /// path.
    #[deprecated]
    #[prost(bool, tag = "3")]
    pub existing: bool,
}
/// Represents a Google Cloud Storage volume.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Gcs {
    /// Remote path, either a bucket name or a subdirectory of a bucket, e.g.:
    /// bucket_name, bucket_name/subdirectory/
    #[prost(string, tag = "1")]
    pub remote_path: ::prost::alloc::string::String,
}
/// Compute resource requirements.
///
/// ComputeResource defines the amount of resources required for each task.
/// Make sure your tasks have enough resources to successfully run.
/// If you also define the types of resources for a job to use with the
/// [InstancePolicyOrTemplate](<https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate>)
/// field, make sure both fields are compatible with each other.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ComputeResource {
    /// The milliCPU count.
    ///
    /// `cpuMilli` defines the amount of CPU resources per task in milliCPU units.
    /// For example, `1000` corresponds to 1 vCPU per task. If undefined, the
    /// default value is `2000`.
    ///
    /// If you also define the VM's machine type using the `machineType` in
    /// [InstancePolicy](<https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy>)
    /// field or inside the `instanceTemplate` in the
    /// [InstancePolicyOrTemplate](<https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate>)
    /// field, make sure the CPU resources for both fields are compatible with each
    /// other and with how many tasks you want to allow to run on the same VM at
    /// the same time.
    ///
    /// For example, if you specify the `n2-standard-2` machine type, which has 2
    /// vCPUs each, you are recommended to set `cpuMilli` no more than `2000`, or
    /// you are recommended to run two tasks on the same VM if you set `cpuMilli`
    /// to `1000` or less.
    #[prost(int64, tag = "1")]
    pub cpu_milli: i64,
    /// Memory in MiB.
    ///
    /// `memoryMib` defines the amount of memory per task in MiB units.
    /// If undefined, the default value is `2000`.
    /// If you also define the VM's machine type using the `machineType` in
    /// [InstancePolicy](<https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy>)
    /// field or inside the `instanceTemplate` in the
    /// [InstancePolicyOrTemplate](<https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate>)
    /// field, make sure the memory resources for both fields are compatible with
    /// each other and with how many tasks you want to allow to run on the same VM
    /// at the same time.
    ///
    /// For example, if you specify the `n2-standard-2` machine type, which has 8
    /// GiB each, you are recommended to set `memoryMib` to no more than `8192`,
    /// or you are recommended to run two tasks on the same VM if you set
    /// `memoryMib` to `4096` or less.
    #[prost(int64, tag = "2")]
    pub memory_mib: i64,
    /// The GPU count.
    ///
    /// Not yet implemented.
    #[prost(int64, tag = "3")]
    pub gpu_count: i64,
    /// Extra boot disk size in MiB for each task.
    #[prost(int64, tag = "4")]
    pub boot_disk_mib: i64,
}
/// Status event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatusEvent {
    /// Type of the event.
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    /// Description of the event.
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    /// The time this event occurred.
    #[prost(message, optional, tag = "2")]
    pub event_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Task Execution.
    /// This field is only defined for task-level status events where the task
    /// fails.
    #[prost(message, optional, tag = "4")]
    pub task_execution: ::core::option::Option<TaskExecution>,
    /// Task State.
    /// This field is only defined for task-level status events.
    #[prost(enumeration = "task_status::State", tag = "5")]
    pub task_state: i32,
}
/// This Task Execution field includes detail information for
/// task execution procedures, based on StatusEvent types.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskExecution {
    /// The exit code of a finished task.
    ///
    /// If the task succeeded, the exit code will be 0. If the task failed but not
    /// due to the following reasons, the exit code will be 50000.
    ///
    /// Otherwise, it can be from different sources:
    /// * Batch known failures:
    /// <https://cloud.google.com/batch/docs/troubleshooting#reserved-exit-codes.>
    /// * Batch runnable execution failures; you can rely on Batch logs to further
    /// diagnose: <https://cloud.google.com/batch/docs/analyze-job-using-logs.> If
    /// there are multiple runnables failures, Batch only exposes the first error.
    #[prost(int32, tag = "1")]
    pub exit_code: i32,
    /// Optional. The tail end of any content written to standard error by the task
    /// execution. This field will be populated only when the execution failed.
    #[prost(string, tag = "2")]
    pub stderr_snippet: ::prost::alloc::string::String,
}
/// Status of a task.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskStatus {
    /// Task state.
    #[prost(enumeration = "task_status::State", tag = "1")]
    pub state: i32,
    /// Detailed info about why the state is reached.
    #[prost(message, repeated, tag = "2")]
    pub status_events: ::prost::alloc::vec::Vec<StatusEvent>,
    /// The resource usage of the task.
    #[prost(message, optional, tag = "3")]
    pub resource_usage: ::core::option::Option<TaskResourceUsage>,
}
/// Nested message and enum types in `TaskStatus`.
pub mod task_status {
    /// Task states.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unknown state.
        Unspecified = 0,
        /// The Task is created and waiting for resources.
        Pending = 1,
        /// The Task is assigned to at least one VM.
        Assigned = 2,
        /// The Task is running.
        Running = 3,
        /// The Task has failed.
        Failed = 4,
        /// The Task has succeeded.
        Succeeded = 5,
        /// The Task has not been executed when the Job finishes.
        Unexecuted = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Assigned => "ASSIGNED",
                Self::Running => "RUNNING",
                Self::Failed => "FAILED",
                Self::Succeeded => "SUCCEEDED",
                Self::Unexecuted => "UNEXECUTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "ASSIGNED" => Some(Self::Assigned),
                "RUNNING" => Some(Self::Running),
                "FAILED" => Some(Self::Failed),
                "SUCCEEDED" => Some(Self::Succeeded),
                "UNEXECUTED" => Some(Self::Unexecuted),
                _ => None,
            }
        }
    }
}
/// TaskResourceUsage describes the resource usage of the task.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TaskResourceUsage {
    /// The CPU core hours the task consumes based on task requirement and run
    /// time.
    #[prost(double, tag = "1")]
    pub core_hours: f64,
}
/// Runnable describes instructions for executing a specific script or container
/// as part of a Task.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Runnable {
    /// Optional. DisplayName is an optional field that can be provided by the
    /// caller. If provided, it will be used in logs and other outputs to identify
    /// the script, making it easier for users to understand the logs. If not
    /// provided the index of the runnable will be used for outputs.
    #[prost(string, tag = "10")]
    pub display_name: ::prost::alloc::string::String,
    /// Normally, a runnable that returns a non-zero exit status fails and causes
    /// the task to fail. However, you can set this field to `true` to allow the
    /// task to continue executing its other runnables even if this runnable
    /// fails.
    #[prost(bool, tag = "3")]
    pub ignore_exit_status: bool,
    /// Normally, a runnable that doesn't exit causes its task to fail. However,
    /// you can set this field to `true` to configure a background runnable.
    /// Background runnables are allowed continue running in the background while
    /// the task executes subsequent runnables. For example, background runnables
    /// are useful for providing services to other runnables or providing
    /// debugging-support tools like SSH servers.
    ///
    /// Specifically, background runnables are killed automatically (if they have
    /// not already exited) a short time after all foreground runnables have
    /// completed. Even though this is likely to result in a non-zero exit status
    /// for the background runnable, these automatic kills are not treated as task
    /// failures.
    #[prost(bool, tag = "4")]
    pub background: bool,
    /// By default, after a Runnable fails, no further Runnable are executed. This
    /// flag indicates that this Runnable must be run even if the Task has already
    /// failed. This is useful for Runnables that copy output files off of the VM
    /// or for debugging.
    ///
    /// The always_run flag does not override the Task's overall max_run_duration.
    /// If the max_run_duration has expired then no further Runnables will execute,
    /// not even always_run Runnables.
    #[prost(bool, tag = "5")]
    pub always_run: bool,
    /// Environment variables for this Runnable (overrides variables set for the
    /// whole Task or TaskGroup).
    #[prost(message, optional, tag = "7")]
    pub environment: ::core::option::Option<Environment>,
    /// Timeout for this Runnable.
    #[prost(message, optional, tag = "8")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    /// Labels for this Runnable.
    #[prost(map = "string, string", tag = "9")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. The script, container, or barrier for this runnable to execute.
    #[prost(oneof = "runnable::Executable", tags = "1, 2, 6")]
    pub executable: ::core::option::Option<runnable::Executable>,
}
/// Nested message and enum types in `Runnable`.
pub mod runnable {
    /// Container runnable.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Container {
        /// Required. The URI to pull the container image from.
        #[prost(string, tag = "1")]
        pub image_uri: ::prost::alloc::string::String,
        /// Required for some container images. Overrides the `CMD` specified in the
        /// container. If there is an `ENTRYPOINT` (either in the container image or
        /// with the `entrypoint` field below) then these commands are appended as
        /// arguments to the `ENTRYPOINT`.
        #[prost(string, repeated, tag = "2")]
        pub commands: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Required for some container images. Overrides the `ENTRYPOINT` specified
        /// in the container.
        #[prost(string, tag = "3")]
        pub entrypoint: ::prost::alloc::string::String,
        /// Volumes to mount (bind mount) from the host machine files or directories
        /// into the container, formatted to match `--volume` option for the
        /// `docker run` command&mdash;for example, `/foo:/bar` or `/foo:/bar:ro`.
        ///
        /// If the `TaskSpec.Volumes` field is specified but this field is not, Batch
        /// will mount each volume from the host machine to the container with the
        /// same mount path by default. In this case, the default mount option for
        /// containers will be read-only (`ro`) for existing persistent disks and
        /// read-write (`rw`) for other volume types, regardless of the original
        /// mount options specified in `TaskSpec.Volumes`. If you need different
        /// mount settings, you can explicitly configure them in this field.
        #[prost(string, repeated, tag = "7")]
        pub volumes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Required for some container images. Arbitrary additional options to
        /// include in the `docker run` command when running this container&mdash;for
        /// example, `--network host`. For the `--volume` option, use the `volumes`
        /// field for the container.
        #[prost(string, tag = "8")]
        pub options: ::prost::alloc::string::String,
        /// If set to true, external network access to and from container will be
        /// blocked, containers that are with block_external_network as true can
        /// still communicate with each other, network cannot be specified in the
        /// `container.options` field.
        #[prost(bool, tag = "9")]
        pub block_external_network: bool,
        /// Required if the container image is from a private Docker registry. The
        /// username to login to the Docker registry that contains the image.
        ///
        /// You can either specify the username directly by using plain text or
        /// specify an encrypted username by using a Secret Manager secret:
        /// `projects/*/secrets/*/versions/*`. However, using a secret is
        /// recommended for enhanced security.
        ///
        /// Caution: If you specify the username using plain text, you risk the
        /// username being exposed to any users who can view the job or its logs.
        /// To avoid this risk, specify a secret that contains the username instead.
        ///
        /// Learn more about [Secret
        /// Manager](<https://cloud.google.com/secret-manager/docs/>) and [using
        /// Secret Manager with
        /// Batch](<https://cloud.google.com/batch/docs/create-run-job-secret-manager>).
        #[prost(string, tag = "10")]
        pub username: ::prost::alloc::string::String,
        /// Required if the container image is from a private Docker registry. The
        /// password to login to the Docker registry that contains the image.
        ///
        /// For security, it is strongly recommended to specify an
        /// encrypted password by using a Secret Manager secret:
        /// `projects/*/secrets/*/versions/*`.
        ///
        /// Warning: If you specify the password using plain text, you risk the
        /// password being exposed to any users who can view the job or its logs.
        /// To avoid this risk, specify a secret that contains the password instead.
        ///
        /// Learn more about [Secret
        /// Manager](<https://cloud.google.com/secret-manager/docs/>) and [using
        /// Secret Manager with
        /// Batch](<https://cloud.google.com/batch/docs/create-run-job-secret-manager>).
        #[prost(string, tag = "11")]
        pub password: ::prost::alloc::string::String,
        /// Optional. If set to true, this container runnable uses Image streaming.
        ///
        /// Use Image streaming to allow the runnable to initialize without
        /// waiting for the entire container image to download, which can
        /// significantly reduce startup time for large container images.
        ///
        /// When `enableImageStreaming` is set to true, the container
        /// runtime is [containerd](<https://containerd.io/>) instead of Docker.
        /// Additionally, this container runnable only supports the following
        /// `container` subfields: `imageUri`,
        /// `commands\[\]`, `entrypoint`, and
        /// `volumes\[\]`; any other `container` subfields are ignored.
        ///
        /// For more information about the requirements and limitations for using
        /// Image streaming with Batch, see the [`image-streaming`
        /// sample on
        /// GitHub](<https://github.com/GoogleCloudPlatform/batch-samples/tree/main/api-samples/image-streaming>).
        #[prost(bool, tag = "12")]
        pub enable_image_streaming: bool,
    }
    /// Script runnable.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Script {
        /// Required. The source code for this script runnable.
        #[prost(oneof = "script::Command", tags = "1, 2")]
        pub command: ::core::option::Option<script::Command>,
    }
    /// Nested message and enum types in `Script`.
    pub mod script {
        /// Required. The source code for this script runnable.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Command {
            /// The path to a script file that is accessible from the host VM(s).
            ///
            /// Unless the script file supports the default `#!/bin/sh` shell
            /// interpreter, you must specify an interpreter by including a
            /// [shebang line](<https://en.wikipedia.org/wiki/Shebang_(Unix>) as the
            /// first line of the file. For example, to execute the script using bash,
            /// include `#!/bin/bash` as the first line of the file. Alternatively,
            /// to execute the script using Python3, include `#!/usr/bin/env python3`
            /// as the first line of the file.
            #[prost(string, tag = "1")]
            Path(::prost::alloc::string::String),
            /// The text for a script.
            ///
            /// Unless the script text supports the default `#!/bin/sh` shell
            /// interpreter, you must specify an interpreter by including a
            /// [shebang line](<https://en.wikipedia.org/wiki/Shebang_(Unix>) at the
            /// beginning of the text. For example, to execute the script using bash,
            /// include `#!/bin/bash\n` at the beginning of the text. Alternatively,
            /// to execute the script using Python3, include `#!/usr/bin/env python3\n`
            /// at the beginning of the text.
            #[prost(string, tag = "2")]
            Text(::prost::alloc::string::String),
        }
    }
    /// A barrier runnable automatically blocks the execution of subsequent
    /// runnables until all the tasks in the task group reach the barrier.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Barrier {
        /// Barriers are identified by their index in runnable list.
        /// Names are not required, but if present should be an identifier.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
    }
    /// Required. The script, container, or barrier for this runnable to execute.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Executable {
        /// Container runnable.
        #[prost(message, tag = "1")]
        Container(Container),
        /// Script runnable.
        #[prost(message, tag = "2")]
        Script(Script),
        /// Barrier runnable.
        #[prost(message, tag = "6")]
        Barrier(Barrier),
    }
}
/// Spec of a task
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskSpec {
    /// Required. The sequence of one or more runnables (executable scripts,
    /// executable containers, and/or barriers) for each task in this task group to
    /// run. Each task runs this list of runnables in order. For a task to succeed,
    /// all of its script and container runnables each must meet at least one of
    /// the following conditions:
    ///
    /// + The runnable exited with a zero status.
    /// + The runnable didn't finish, but you enabled its `background` subfield.
    /// + The runnable exited with a non-zero status, but you enabled its
    ///    `ignore_exit_status` subfield.
    #[prost(message, repeated, tag = "8")]
    pub runnables: ::prost::alloc::vec::Vec<Runnable>,
    /// ComputeResource requirements.
    #[prost(message, optional, tag = "3")]
    pub compute_resource: ::core::option::Option<ComputeResource>,
    /// Maximum duration the task should run before being automatically retried
    /// (if enabled) or automatically failed. Format the value of this field
    /// as a time limit in seconds followed by `s`&mdash;for example, `3600s`
    /// for 1 hour. The field accepts any value between 0 and the maximum listed
    /// for the `Duration` field type at
    /// <https://protobuf.dev/reference/protobuf/google.protobuf/#duration;> however,
    /// the actual maximum run time for a job will be limited to the maximum run
    /// time for a job listed at
    /// <https://cloud.google.com/batch/quotas#max-job-duration.>
    #[prost(message, optional, tag = "4")]
    pub max_run_duration: ::core::option::Option<::prost_types::Duration>,
    /// Maximum number of retries on failures.
    /// The default, 0, which means never retry.
    /// The valid value range is \[0, 10\].
    #[prost(int32, tag = "5")]
    pub max_retry_count: i32,
    /// Lifecycle management schema when any task in a task group is failed.
    /// Currently we only support one lifecycle policy.
    /// When the lifecycle policy condition is met,
    /// the action in the policy will execute.
    /// If task execution result does not meet with the defined lifecycle
    /// policy, we consider it as the default policy.
    /// Default policy means if the exit code is 0, exit task.
    /// If task ends with non-zero exit code, retry the task with max_retry_count.
    #[prost(message, repeated, tag = "9")]
    pub lifecycle_policies: ::prost::alloc::vec::Vec<LifecyclePolicy>,
    /// Deprecated: please use environment(non-plural) instead.
    #[prost(map = "string, string", tag = "6")]
    pub environments: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Volumes to mount before running Tasks using this TaskSpec.
    #[prost(message, repeated, tag = "7")]
    pub volumes: ::prost::alloc::vec::Vec<Volume>,
    /// Environment variables to set before running the Task.
    #[prost(message, optional, tag = "10")]
    pub environment: ::core::option::Option<Environment>,
}
/// LifecyclePolicy describes how to deal with task failures
/// based on different conditions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LifecyclePolicy {
    /// Action to execute when ActionCondition is true.
    /// When RETRY_TASK is specified, we will retry failed tasks
    /// if we notice any exit code match and fail tasks if no match is found.
    /// Likewise, when FAIL_TASK is specified, we will fail tasks
    /// if we notice any exit code match and retry tasks if no match is found.
    #[prost(enumeration = "lifecycle_policy::Action", tag = "1")]
    pub action: i32,
    /// Conditions that decide why a task failure is dealt with a specific action.
    #[prost(message, optional, tag = "2")]
    pub action_condition: ::core::option::Option<lifecycle_policy::ActionCondition>,
}
/// Nested message and enum types in `LifecyclePolicy`.
pub mod lifecycle_policy {
    /// Conditions for actions to deal with task failures.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ActionCondition {
        /// Exit codes of a task execution.
        /// If there are more than 1 exit codes,
        /// when task executes with any of the exit code in the list,
        /// the condition is met and the action will be executed.
        #[prost(int32, repeated, tag = "1")]
        pub exit_codes: ::prost::alloc::vec::Vec<i32>,
    }
    /// Action on task failures based on different conditions.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        /// Action unspecified.
        Unspecified = 0,
        /// Action that tasks in the group will be scheduled to re-execute.
        RetryTask = 1,
        /// Action that tasks in the group will be stopped immediately.
        FailTask = 2,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ACTION_UNSPECIFIED",
                Self::RetryTask => "RETRY_TASK",
                Self::FailTask => "FAIL_TASK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "RETRY_TASK" => Some(Self::RetryTask),
                "FAIL_TASK" => Some(Self::FailTask),
                _ => None,
            }
        }
    }
}
/// A Cloud Batch task.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Task {
    /// Task name.
    /// The name is generated from the parent TaskGroup name and 'id' field.
    /// For example:
    /// "projects/123456/locations/us-west1/jobs/job01/taskGroups/group01/tasks/task01".
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Task Status.
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<TaskStatus>,
}
/// An Environment describes a collection of environment variables to set when
/// executing Tasks.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Environment {
    /// A map of environment variable names to values.
    #[prost(map = "string, string", tag = "1")]
    pub variables: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// A map of environment variable names to Secret Manager secret names.
    /// The VM will access the named secrets to set the value of each environment
    /// variable.
    #[prost(map = "string, string", tag = "2")]
    pub secret_variables: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// An encrypted JSON dictionary where the key/value pairs correspond to
    /// environment variable names and their values.
    #[prost(message, optional, tag = "3")]
    pub encrypted_variables: ::core::option::Option<environment::KmsEnvMap>,
}
/// Nested message and enum types in `Environment`.
pub mod environment {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KmsEnvMap {
        /// The name of the KMS key that will be used to decrypt the cipher text.
        #[prost(string, tag = "1")]
        pub key_name: ::prost::alloc::string::String,
        /// The value of the cipherText response from the `encrypt` method.
        #[prost(string, tag = "2")]
        pub cipher_text: ::prost::alloc::string::String,
    }
}
/// The Cloud Batch Job description.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Job {
    /// Output only. Job name.
    /// For example: "projects/123456/locations/us-central1/jobs/job01".
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. A system generated unique ID for the Job.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Priority of the Job.
    /// The valid value range is [0, 100). Default value is 0.
    /// Higher value indicates higher priority.
    /// A job with higher priority value is more likely to run earlier if all other
    /// requirements are satisfied.
    #[prost(int64, tag = "3")]
    pub priority: i64,
    /// Required. TaskGroups in the Job. Only one TaskGroup is supported now.
    #[prost(message, repeated, tag = "4")]
    pub task_groups: ::prost::alloc::vec::Vec<TaskGroup>,
    /// Scheduling policy for TaskGroups in the job.
    #[prost(enumeration = "job::SchedulingPolicy", tag = "5")]
    pub scheduling_policy: i32,
    /// At least one of the dependencies must be satisfied before the Job is
    /// scheduled to run.
    /// Only one JobDependency is supported now.
    /// Not yet implemented.
    #[prost(message, repeated, tag = "6")]
    pub dependencies: ::prost::alloc::vec::Vec<JobDependency>,
    /// Compute resource allocation for all TaskGroups in the Job.
    #[prost(message, optional, tag = "7")]
    pub allocation_policy: ::core::option::Option<AllocationPolicy>,
    /// Custom labels to apply to the job and any Cloud Logging
    /// [LogEntry](<https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry>)
    /// that it generates.
    ///
    /// Use labels to group and describe the resources they are applied to. Batch
    /// automatically applies predefined labels and supports multiple `labels`
    /// fields for each job, which each let you apply custom labels to various
    /// resources. Label names that start with "goog-" or "google-" are
    /// reserved for predefined labels. For more information about labels with
    /// Batch, see
    /// [Organize resources using
    /// labels](<https://cloud.google.com/batch/docs/organize-resources-using-labels>).
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Job status. It is read only for users.
    #[prost(message, optional, tag = "9")]
    pub status: ::core::option::Option<JobStatus>,
    /// Deprecated: please use notifications instead.
    #[deprecated]
    #[prost(message, optional, tag = "10")]
    pub notification: ::core::option::Option<JobNotification>,
    /// Output only. When the Job was created.
    #[prost(message, optional, tag = "11")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The last time the Job was updated.
    #[prost(message, optional, tag = "12")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Log preservation policy for the Job.
    #[prost(message, optional, tag = "13")]
    pub logs_policy: ::core::option::Option<LogsPolicy>,
    /// Notification configurations.
    #[prost(message, repeated, tag = "14")]
    pub notifications: ::prost::alloc::vec::Vec<JobNotification>,
}
/// Nested message and enum types in `Job`.
pub mod job {
    /// The order that TaskGroups are scheduled relative to each other.
    ///
    /// Not yet implemented.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SchedulingPolicy {
        /// Unspecified.
        Unspecified = 0,
        /// Run all TaskGroups as soon as possible.
        AsSoonAsPossible = 1,
    }
    impl SchedulingPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SCHEDULING_POLICY_UNSPECIFIED",
                Self::AsSoonAsPossible => "AS_SOON_AS_POSSIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCHEDULING_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "AS_SOON_AS_POSSIBLE" => Some(Self::AsSoonAsPossible),
                _ => None,
            }
        }
    }
}
/// LogsPolicy describes if and how a job's logs are preserved. Logs include
/// information that is automatically written by the Batch service agent and any
/// information that you configured the job's runnables to write to the `stdout`
/// or `stderr` streams.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogsPolicy {
    /// If and where logs should be saved.
    #[prost(enumeration = "logs_policy::Destination", tag = "1")]
    pub destination: i32,
    /// When `destination` is set to `PATH`, you must set this field to the path
    /// where you want logs to be saved. This path can point to a local directory
    /// on the VM or (if congifured) a directory under the mount path of any
    /// Cloud Storage bucket, network file system (NFS), or writable persistent
    /// disk that is mounted to the job. For example, if the job has a bucket with
    /// `mountPath` set to `/mnt/disks/my-bucket`, you can write logs to the
    /// root directory of the `remotePath` of that bucket by setting this field to
    /// `/mnt/disks/my-bucket/`.
    #[prost(string, tag = "2")]
    pub logs_path: ::prost::alloc::string::String,
    /// Optional. When `destination` is set to `CLOUD_LOGGING`, you can optionally
    /// set this field to configure additional settings for Cloud Logging.
    #[prost(message, optional, tag = "3")]
    pub cloud_logging_option: ::core::option::Option<logs_policy::CloudLoggingOption>,
}
/// Nested message and enum types in `LogsPolicy`.
pub mod logs_policy {
    /// `CloudLoggingOption` contains additional settings for Cloud Logging logs
    /// generated by Batch job.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CloudLoggingOption {
        /// Optional. Set this field to `true` to change the [monitored resource
        /// type](<https://cloud.google.com/monitoring/api/resources>) for
        /// Cloud Logging logs generated by this Batch job from
        /// the
        /// [`batch.googleapis.com/Job`](<https://cloud.google.com/monitoring/api/resources#tag_batch.googleapis.com/Job>)
        /// type to the formerly used
        /// [`generic_task`](<https://cloud.google.com/monitoring/api/resources#tag_generic_task>)
        /// type.
        #[prost(bool, tag = "1")]
        pub use_generic_task_monitored_resource: bool,
    }
    /// The destination (if any) for logs.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Destination {
        /// (Default) Logs are not preserved.
        Unspecified = 0,
        /// Logs are streamed to Cloud Logging. Optionally, you can configure
        /// additional settings in the `cloudLoggingOption` field.
        CloudLogging = 1,
        /// Logs are saved to the file path specified in the `logsPath` field.
        Path = 2,
    }
    impl Destination {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DESTINATION_UNSPECIFIED",
                Self::CloudLogging => "CLOUD_LOGGING",
                Self::Path => "PATH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DESTINATION_UNSPECIFIED" => Some(Self::Unspecified),
                "CLOUD_LOGGING" => Some(Self::CloudLogging),
                "PATH" => Some(Self::Path),
                _ => None,
            }
        }
    }
}
/// JobDependency describes the state of other Jobs that the start of this Job
/// depends on.
/// All dependent Jobs must have been submitted in the same region.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobDependency {
    /// Each item maps a Job name to a Type.
    /// All items must be satisfied for the JobDependency to be satisfied (the AND
    /// operation).
    /// Once a condition for one item becomes true, it won't go back to false
    /// even the dependent Job state changes again.
    #[prost(map = "string, enumeration(job_dependency::Type)", tag = "1")]
    pub items: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
}
/// Nested message and enum types in `JobDependency`.
pub mod job_dependency {
    /// Dependency type.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Unspecified.
        Unspecified = 0,
        /// The dependent Job has succeeded.
        Succeeded = 1,
        /// The dependent Job has failed.
        Failed = 2,
        /// SUCCEEDED or FAILED.
        Finished = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::Finished => "FINISHED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "FINISHED" => Some(Self::Finished),
                _ => None,
            }
        }
    }
}
/// Job status.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobStatus {
    /// Job state
    #[prost(enumeration = "job_status::State", tag = "1")]
    pub state: i32,
    /// Job status events
    #[prost(message, repeated, tag = "2")]
    pub status_events: ::prost::alloc::vec::Vec<StatusEvent>,
    /// Aggregated task status for each TaskGroup in the Job.
    /// The map key is TaskGroup ID.
    #[prost(map = "string, message", tag = "4")]
    pub task_groups: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        job_status::TaskGroupStatus,
    >,
    /// The duration of time that the Job spent in status RUNNING.
    #[prost(message, optional, tag = "5")]
    pub run_duration: ::core::option::Option<::prost_types::Duration>,
    /// The resource usage of the job.
    #[prost(message, optional, tag = "6")]
    pub resource_usage: ::core::option::Option<ResourceUsage>,
}
/// Nested message and enum types in `JobStatus`.
pub mod job_status {
    /// VM instance status.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InstanceStatus {
        /// The Compute Engine machine type.
        #[prost(string, tag = "1")]
        pub machine_type: ::prost::alloc::string::String,
        /// The VM instance provisioning model.
        #[prost(enumeration = "super::allocation_policy::ProvisioningModel", tag = "2")]
        pub provisioning_model: i32,
        /// The max number of tasks can be assigned to this instance type.
        #[prost(int64, tag = "3")]
        pub task_pack: i64,
        /// The VM boot disk.
        #[prost(message, optional, tag = "4")]
        pub boot_disk: ::core::option::Option<super::allocation_policy::Disk>,
    }
    /// Aggregated task status for a TaskGroup.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TaskGroupStatus {
        /// Count of task in each state in the TaskGroup.
        /// The map key is task state name.
        #[prost(map = "string, int64", tag = "1")]
        pub counts: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
        /// Status of instances allocated for the TaskGroup.
        #[prost(message, repeated, tag = "2")]
        pub instances: ::prost::alloc::vec::Vec<InstanceStatus>,
    }
    /// Valid Job states.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Job state unspecified.
        Unspecified = 0,
        /// Job is admitted (validated and persisted) and waiting for resources.
        Queued = 1,
        /// Job is scheduled to run as soon as resource allocation is ready.
        /// The resource allocation may happen at a later time but with a high
        /// chance to succeed.
        Scheduled = 2,
        /// Resource allocation has been successful. At least one Task in the Job is
        /// RUNNING.
        Running = 3,
        /// All Tasks in the Job have finished successfully.
        Succeeded = 4,
        /// At least one Task in the Job has failed.
        Failed = 5,
        /// The Job will be deleted, but has not been deleted yet. Typically this is
        /// because resources used by the Job are still being cleaned up.
        DeletionInProgress = 6,
        /// The Job cancellation is in progress, this is because the resources used
        /// by the Job are still being cleaned up.
        CancellationInProgress = 7,
        /// The Job has been cancelled, the task executions were stopped and the
        /// resources were cleaned up.
        Cancelled = 8,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Queued => "QUEUED",
                Self::Scheduled => "SCHEDULED",
                Self::Running => "RUNNING",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::DeletionInProgress => "DELETION_IN_PROGRESS",
                Self::CancellationInProgress => "CANCELLATION_IN_PROGRESS",
                Self::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "QUEUED" => Some(Self::Queued),
                "SCHEDULED" => Some(Self::Scheduled),
                "RUNNING" => Some(Self::Running),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "DELETION_IN_PROGRESS" => Some(Self::DeletionInProgress),
                "CANCELLATION_IN_PROGRESS" => Some(Self::CancellationInProgress),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
/// ResourceUsage describes the resource usage of the job.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourceUsage {
    /// The CPU core hours that the job consumes.
    #[prost(double, tag = "1")]
    pub core_hours: f64,
}
/// Notification configurations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobNotification {
    /// The Pub/Sub topic where notifications for the job, like state
    /// changes, will be published. If undefined, no Pub/Sub notifications
    /// are sent for this job.
    ///
    /// Specify the topic using the following format:
    /// `projects/{project}/topics/{topic}`.
    /// Notably, if you want to specify a Pub/Sub topic that is in a
    /// different project than the job, your administrator must grant your
    /// project's Batch service agent permission to publish to that topic.
    ///
    /// For more information about configuring Pub/Sub notifications for
    /// a job, see
    /// <https://cloud.google.com/batch/docs/enable-notifications.>
    #[prost(string, tag = "1")]
    pub pubsub_topic: ::prost::alloc::string::String,
    /// The attribute requirements of messages to be sent to this Pub/Sub topic.
    /// Without this field, no message will be sent.
    #[prost(message, optional, tag = "2")]
    pub message: ::core::option::Option<job_notification::Message>,
}
/// Nested message and enum types in `JobNotification`.
pub mod job_notification {
    /// Message details.
    /// Describe the conditions under which messages will be sent.
    /// If no attribute is defined, no message will be sent by default.
    /// One message should specify either the job or the task level attributes,
    /// but not both. For example,
    /// job level: JOB_STATE_CHANGED and/or a specified new_job_state;
    /// task level: TASK_STATE_CHANGED and/or a specified new_task_state.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Message {
        /// The message type.
        #[prost(enumeration = "Type", tag = "1")]
        pub r#type: i32,
        /// The new job state.
        #[prost(enumeration = "super::job_status::State", tag = "2")]
        pub new_job_state: i32,
        /// The new task state.
        #[prost(enumeration = "super::task_status::State", tag = "3")]
        pub new_task_state: i32,
    }
    /// The message type.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Unspecified.
        Unspecified = 0,
        /// Notify users that the job state has changed.
        JobStateChanged = 1,
        /// Notify users that the task state has changed.
        TaskStateChanged = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::JobStateChanged => "JOB_STATE_CHANGED",
                Self::TaskStateChanged => "TASK_STATE_CHANGED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "JOB_STATE_CHANGED" => Some(Self::JobStateChanged),
                "TASK_STATE_CHANGED" => Some(Self::TaskStateChanged),
                _ => None,
            }
        }
    }
}
/// A Job's resource allocation policy describes when, where, and how compute
/// resources should be allocated for the Job.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationPolicy {
    /// Location where compute resources should be allocated for the Job.
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<allocation_policy::LocationPolicy>,
    /// Deprecated: please use instances\[0\].policy instead.
    #[deprecated]
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<allocation_policy::InstancePolicy>,
    /// Describe instances that can be created by this AllocationPolicy.
    /// Only instances\[0\] is supported now.
    #[prost(message, repeated, tag = "8")]
    pub instances: ::prost::alloc::vec::Vec<allocation_policy::InstancePolicyOrTemplate>,
    /// Deprecated: please use instances\[0\].template instead.
    #[deprecated]
    #[prost(string, repeated, tag = "3")]
    pub instance_templates: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Deprecated: please use instances\[0\].policy.provisioning_model instead.
    #[deprecated]
    #[prost(
        enumeration = "allocation_policy::ProvisioningModel",
        repeated,
        packed = "false",
        tag = "4"
    )]
    pub provisioning_models: ::prost::alloc::vec::Vec<i32>,
    /// Deprecated: please use service_account instead.
    #[deprecated]
    #[prost(string, tag = "5")]
    pub service_account_email: ::prost::alloc::string::String,
    /// Defines the service account for Batch-created VMs. If omitted, the [default
    /// Compute Engine service
    /// account](<https://cloud.google.com/compute/docs/access/service-accounts#default_service_account>)
    /// is used. Must match the service account specified in any used instance
    /// template configured in the Batch job.
    ///
    /// Includes the following fields:
    ///   * email: The service account's email address. If not set, the default
    ///   Compute Engine service account is used.
    ///   * scopes: Additional OAuth scopes to grant the service account, beyond the
    ///   default cloud-platform scope. (list of strings)
    #[prost(message, optional, tag = "9")]
    pub service_account: ::core::option::Option<ServiceAccount>,
    /// Custom labels to apply to the job and all the Compute Engine resources
    /// that both are created by this allocation policy and support labels.
    ///
    /// Use labels to group and describe the resources they are applied to. Batch
    /// automatically applies predefined labels and supports multiple `labels`
    /// fields for each job, which each let you apply custom labels to various
    /// resources. Label names that start with "goog-" or "google-" are
    /// reserved for predefined labels. For more information about labels with
    /// Batch, see
    /// [Organize resources using
    /// labels](<https://cloud.google.com/batch/docs/organize-resources-using-labels>).
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The network policy.
    ///
    /// If you define an instance template in the `InstancePolicyOrTemplate` field,
    /// Batch will use the network settings in the instance template instead of
    /// this field.
    #[prost(message, optional, tag = "7")]
    pub network: ::core::option::Option<allocation_policy::NetworkPolicy>,
    /// The placement policy.
    #[prost(message, optional, tag = "10")]
    pub placement: ::core::option::Option<allocation_policy::PlacementPolicy>,
    /// Optional. Tags applied to the VM instances.
    ///
    /// The tags identify valid sources or targets for network firewalls.
    /// Each tag must be 1-63 characters long, and comply with
    /// [RFC1035](<https://www.ietf.org/rfc/rfc1035.txt>).
    #[prost(string, repeated, tag = "11")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `AllocationPolicy`.
pub mod allocation_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LocationPolicy {
        /// A list of allowed location names represented by internal URLs.
        ///
        /// Each location can be a region or a zone.
        /// Only one region or multiple zones in one region is supported now.
        /// For example,
        /// \["regions/us-central1"\] allow VMs in any zones in region us-central1.
        /// \["zones/us-central1-a", "zones/us-central1-c"\] only allow VMs
        /// in zones us-central1-a and us-central1-c.
        ///
        /// Mixing locations from different regions would cause errors.
        /// For example,
        /// ["regions/us-central1", "zones/us-central1-a", "zones/us-central1-b",
        /// "zones/us-west1-a"] contains locations from two distinct regions:
        /// us-central1 and us-west1. This combination will trigger an error.
        #[prost(string, repeated, tag = "1")]
        pub allowed_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// A list of denied location names.
        ///
        /// Not yet implemented.
        #[prost(string, repeated, tag = "2")]
        pub denied_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// A new persistent disk or a local ssd.
    /// A VM can only have one local SSD setting but multiple local SSD partitions.
    /// See <https://cloud.google.com/compute/docs/disks#pdspecs> and
    /// <https://cloud.google.com/compute/docs/disks#localssds.>
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Disk {
        /// Disk type as shown in `gcloud compute disk-types list`.
        /// For example, local SSD uses type "local-ssd".
        /// Persistent disks and boot disks use "pd-balanced", "pd-extreme", "pd-ssd"
        /// or "pd-standard". If not specified, "pd-standard" will be used as the
        /// default type for non-boot disks, "pd-balanced" will be used as the
        /// default type for boot disks.
        #[prost(string, tag = "1")]
        pub r#type: ::prost::alloc::string::String,
        /// Disk size in GB.
        ///
        /// **Non-Boot Disk**:
        /// If the `type` specifies a persistent disk, this field
        /// is ignored if `data_source` is set as `image` or `snapshot`.
        /// If the `type` specifies a local SSD, this field should be a multiple of
        /// 375 GB, otherwise, the final size will be the next greater multiple of
        /// 375 GB.
        ///
        /// **Boot Disk**:
        /// Batch will calculate the boot disk size based on source
        /// image and task requirements if you do not speicify the size.
        /// If both this field and the `boot_disk_mib` field in task spec's
        /// `compute_resource` are defined, Batch will only honor this field.
        /// Also, this field should be no smaller than the source disk's
        /// size when the `data_source` is set as `snapshot` or `image`.
        /// For example, if you set an image as the `data_source` field and the
        /// image's default disk size 30 GB, you can only use this field to make the
        /// disk larger or equal to 30 GB.
        #[prost(int64, tag = "2")]
        pub size_gb: i64,
        /// Local SSDs are available through both "SCSI" and "NVMe" interfaces.
        /// If not indicated, "NVMe" will be the default one for local ssds.
        /// This field is ignored for persistent disks as the interface is chosen
        /// automatically. See
        /// <https://cloud.google.com/compute/docs/disks/persistent-disks#choose_an_interface.>
        #[prost(string, tag = "6")]
        pub disk_interface: ::prost::alloc::string::String,
        /// A data source from which a PD will be created.
        #[prost(oneof = "disk::DataSource", tags = "4, 5")]
        pub data_source: ::core::option::Option<disk::DataSource>,
    }
    /// Nested message and enum types in `Disk`.
    pub mod disk {
        /// A data source from which a PD will be created.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum DataSource {
            /// URL for a VM image to use as the data source for this disk.
            /// For example, the following are all valid URLs:
            ///
            /// * Specify the image by its family name:
            /// projects/{project}/global/images/family/{image_family}
            /// * Specify the image version:
            /// projects/{project}/global/images/{image_version}
            ///
            /// You can also use Batch customized image in short names.
            /// The following image values are supported for a boot disk:
            ///
            /// * `batch-debian`: use Batch Debian images.
            /// * `batch-cos`: use Batch Container-Optimized images.
            /// * `batch-hpc-rocky`: use Batch HPC Rocky Linux images.
            #[prost(string, tag = "4")]
            Image(::prost::alloc::string::String),
            /// Name of a snapshot used as the data source.
            /// Snapshot is not supported as boot disk now.
            #[prost(string, tag = "5")]
            Snapshot(::prost::alloc::string::String),
        }
    }
    /// A new or an existing persistent disk (PD) or a local ssd attached to a VM
    /// instance.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AttachedDisk {
        /// Device name that the guest operating system will see.
        /// It is used by Runnable.volumes field to mount disks. So please specify
        /// the device_name if you want Batch to help mount the disk, and it should
        /// match the device_name field in volumes.
        #[prost(string, tag = "3")]
        pub device_name: ::prost::alloc::string::String,
        #[prost(oneof = "attached_disk::Attached", tags = "1, 2")]
        pub attached: ::core::option::Option<attached_disk::Attached>,
    }
    /// Nested message and enum types in `AttachedDisk`.
    pub mod attached_disk {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Attached {
            #[prost(message, tag = "1")]
            NewDisk(super::Disk),
            /// Name of an existing PD.
            #[prost(string, tag = "2")]
            ExistingDisk(::prost::alloc::string::String),
        }
    }
    /// Accelerator describes Compute Engine accelerators to be attached to the VM.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Accelerator {
        /// The accelerator type. For example, "nvidia-tesla-t4".
        /// See `gcloud compute accelerator-types list`.
        #[prost(string, tag = "1")]
        pub r#type: ::prost::alloc::string::String,
        /// The number of accelerators of this type.
        #[prost(int64, tag = "2")]
        pub count: i64,
        /// Deprecated: please use instances\[0\].install_gpu_drivers instead.
        #[deprecated]
        #[prost(bool, tag = "3")]
        pub install_gpu_drivers: bool,
        /// Optional. The NVIDIA GPU driver version that should be installed for this
        /// type.
        ///
        /// You can define the specific driver version such as "470.103.01",
        /// following the driver version requirements in
        /// <https://cloud.google.com/compute/docs/gpus/install-drivers-gpu#minimum-driver.>
        /// Batch will install the specific accelerator driver if qualified.
        #[prost(string, tag = "4")]
        pub driver_version: ::prost::alloc::string::String,
    }
    /// InstancePolicy describes an instance type and resources attached to each VM
    /// created by this InstancePolicy.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InstancePolicy {
        /// Deprecated: please use machine_type instead.
        #[deprecated]
        #[prost(string, repeated, tag = "1")]
        pub allowed_machine_types: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        /// The Compute Engine machine type.
        #[prost(string, tag = "2")]
        pub machine_type: ::prost::alloc::string::String,
        /// The minimum CPU platform.
        /// See
        /// <https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform.>
        #[prost(string, tag = "3")]
        pub min_cpu_platform: ::prost::alloc::string::String,
        /// The provisioning model.
        #[prost(enumeration = "ProvisioningModel", tag = "4")]
        pub provisioning_model: i32,
        /// The accelerators attached to each VM instance.
        #[prost(message, repeated, tag = "5")]
        pub accelerators: ::prost::alloc::vec::Vec<Accelerator>,
        /// Boot disk to be created and attached to each VM by this InstancePolicy.
        /// Boot disk will be deleted when the VM is deleted.
        /// Batch API now only supports booting from image.
        #[prost(message, optional, tag = "8")]
        pub boot_disk: ::core::option::Option<Disk>,
        /// Non-boot disks to be attached for each VM created by this InstancePolicy.
        /// New disks will be deleted when the VM is deleted.
        /// A non-boot disk is a disk that can be of a device with a
        /// file system or a raw storage drive that is not ready for data
        /// storage and accessing.
        #[prost(message, repeated, tag = "6")]
        pub disks: ::prost::alloc::vec::Vec<AttachedDisk>,
        /// Optional. If not specified (default), VMs will consume any applicable
        /// reservation. If "NO_RESERVATION" is specified, VMs will not consume any
        /// reservation. Otherwise, if specified, VMs will consume only the specified
        /// reservation.
        #[prost(string, tag = "7")]
        pub reservation: ::prost::alloc::string::String,
    }
    /// InstancePolicyOrTemplate lets you define the type of resources to use for
    /// this job either with an InstancePolicy or an instance template.
    /// If undefined, Batch picks the type of VM to use and doesn't include
    /// optional VM resources such as GPUs and extra disks.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InstancePolicyOrTemplate {
        /// Set this field true if you want Batch to help fetch drivers from a third
        /// party location and install them for GPUs specified in
        /// `policy.accelerators` or `instance_template` on your behalf. Default is
        /// false.
        ///
        /// For Container-Optimized Image cases, Batch will install the
        /// accelerator driver following milestones of
        /// <https://cloud.google.com/container-optimized-os/docs/release-notes.> For
        /// non Container-Optimized Image cases, following
        /// <https://github.com/GoogleCloudPlatform/compute-gpu-installation/blob/main/linux/install_gpu_driver.py.>
        #[prost(bool, tag = "3")]
        pub install_gpu_drivers: bool,
        /// Optional. Set this field true if you want Batch to install Ops Agent on
        /// your behalf. Default is false.
        #[prost(bool, tag = "4")]
        pub install_ops_agent: bool,
        /// Optional. Set this field to `true` if you want Batch to block
        /// project-level SSH keys from accessing this job's VMs.  Alternatively, you
        /// can configure the job to specify a VM instance template that blocks
        /// project-level SSH keys. In either case, Batch blocks project-level SSH
        /// keys while creating the VMs for this job.
        ///
        /// Batch allows project-level SSH keys for a job's VMs only if all
        /// the following are true:
        ///
        /// + This field is undefined or set to `false`.
        /// + The job's VM instance template (if any) doesn't block project-level
        ///    SSH keys.
        ///
        /// Notably, you can override this behavior by manually updating a VM to
        /// block or allow project-level SSH keys. For more information about
        /// blocking project-level SSH keys, see the Compute Engine documentation:
        /// <https://cloud.google.com/compute/docs/connect/restrict-ssh-keys#block-keys>
        #[prost(bool, tag = "5")]
        pub block_project_ssh_keys: bool,
        #[prost(oneof = "instance_policy_or_template::PolicyTemplate", tags = "1, 2")]
        pub policy_template: ::core::option::Option<
            instance_policy_or_template::PolicyTemplate,
        >,
    }
    /// Nested message and enum types in `InstancePolicyOrTemplate`.
    pub mod instance_policy_or_template {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum PolicyTemplate {
            /// InstancePolicy.
            #[prost(message, tag = "1")]
            Policy(super::InstancePolicy),
            /// Name of an instance template used to create VMs.
            /// Named the field as 'instance_template' instead of 'template' to avoid
            /// C++ keyword conflict.
            ///
            /// Batch only supports global instance templates from the same project as
            /// the job.
            /// You can specify the global instance template as a full or partial URL.
            #[prost(string, tag = "2")]
            InstanceTemplate(::prost::alloc::string::String),
        }
    }
    /// A network interface.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NetworkInterface {
        /// The URL of an existing network resource.
        /// You can specify the network as a full or partial URL.
        ///
        /// For example, the following are all valid URLs:
        ///
        /// * <https://www.googleapis.com/compute/v1/projects/{project}/global/networks/{network}>
        /// * projects/{project}/global/networks/{network}
        /// * global/networks/{network}
        #[prost(string, tag = "1")]
        pub network: ::prost::alloc::string::String,
        /// The URL of an existing subnetwork resource in the network.
        /// You can specify the subnetwork as a full or partial URL.
        ///
        /// For example, the following are all valid URLs:
        ///
        /// * <https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/subnetworks/{subnetwork}>
        /// * projects/{project}/regions/{region}/subnetworks/{subnetwork}
        /// * regions/{region}/subnetworks/{subnetwork}
        #[prost(string, tag = "2")]
        pub subnetwork: ::prost::alloc::string::String,
        /// Default is false (with an external IP address). Required if
        /// no external public IP address is attached to the VM. If no external
        /// public IP address, additional configuration is required to allow the VM
        /// to access Google Services. See
        /// <https://cloud.google.com/vpc/docs/configure-private-google-access> and
        /// <https://cloud.google.com/nat/docs/gce-example#create-nat> for more
        /// information.
        #[prost(bool, tag = "3")]
        pub no_external_ip_address: bool,
    }
    /// NetworkPolicy describes VM instance network configurations.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NetworkPolicy {
        /// Network configurations.
        #[prost(message, repeated, tag = "1")]
        pub network_interfaces: ::prost::alloc::vec::Vec<NetworkInterface>,
    }
    /// PlacementPolicy describes a group placement policy for the VMs controlled
    /// by this AllocationPolicy.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PlacementPolicy {
        /// UNSPECIFIED vs. COLLOCATED (default UNSPECIFIED). Use COLLOCATED when you
        /// want VMs to be located close to each other for low network latency
        /// between the VMs. No placement policy will be generated when collocation
        /// is UNSPECIFIED.
        #[prost(string, tag = "1")]
        pub collocation: ::prost::alloc::string::String,
        /// When specified, causes the job to fail if more than max_distance logical
        /// switches are required between VMs. Batch uses the most compact possible
        /// placement of VMs even when max_distance is not specified. An explicit
        /// max_distance makes that level of compactness a strict requirement.
        /// Not yet implemented
        #[prost(int64, tag = "2")]
        pub max_distance: i64,
    }
    /// Compute Engine VM instance provisioning model.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProvisioningModel {
        /// Unspecified.
        Unspecified = 0,
        /// Standard VM.
        Standard = 1,
        /// SPOT VM.
        Spot = 2,
        /// Preemptible VM (PVM).
        ///
        /// Above SPOT VM is the preferable model for preemptible VM instances: the
        /// old preemptible VM model (indicated by this field) is the older model,
        /// and has been migrated to use the SPOT model as the underlying technology.
        /// This old model will still be supported.
        Preemptible = 3,
    }
    impl ProvisioningModel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROVISIONING_MODEL_UNSPECIFIED",
                Self::Standard => "STANDARD",
                Self::Spot => "SPOT",
                Self::Preemptible => "PREEMPTIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROVISIONING_MODEL_UNSPECIFIED" => Some(Self::Unspecified),
                "STANDARD" => Some(Self::Standard),
                "SPOT" => Some(Self::Spot),
                "PREEMPTIBLE" => Some(Self::Preemptible),
                _ => None,
            }
        }
    }
}
/// A TaskGroup defines one or more Tasks that all share the same TaskSpec.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskGroup {
    /// Output only. TaskGroup name.
    /// The system generates this field based on parent Job name.
    /// For example:
    /// "projects/123456/locations/us-west1/jobs/job01/taskGroups/group01".
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Tasks in the group share the same task spec.
    #[prost(message, optional, tag = "3")]
    pub task_spec: ::core::option::Option<TaskSpec>,
    /// Number of Tasks in the TaskGroup.
    /// Default is 1.
    #[prost(int64, tag = "4")]
    pub task_count: i64,
    /// Max number of tasks that can run in parallel.
    /// Default to min(task_count, parallel tasks per job limit).
    /// See: [Job Limits](<https://cloud.google.com/batch/quotas#job_limits>).
    /// Field parallelism must be 1 if the scheduling_policy is IN_ORDER.
    #[prost(int64, tag = "5")]
    pub parallelism: i64,
    /// Scheduling policy for Tasks in the TaskGroup.
    /// The default value is AS_SOON_AS_POSSIBLE.
    #[prost(enumeration = "task_group::SchedulingPolicy", tag = "6")]
    pub scheduling_policy: i32,
    /// Compute resource allocation for the TaskGroup.
    /// If specified, it overrides resources in Job.
    #[prost(message, optional, tag = "7")]
    pub allocation_policy: ::core::option::Option<AllocationPolicy>,
    /// Labels for the TaskGroup.
    /// Labels could be user provided or system generated.
    /// You can assign up to 64 labels.  [Google Compute Engine label
    /// restrictions](<https://cloud.google.com/compute/docs/labeling-resources#restrictions>)
    /// apply.
    /// Label names that start with "goog-" or "google-" are reserved.
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// An array of environment variable mappings, which are passed to Tasks with
    /// matching indices. If task_environments is used then task_count should
    /// not be specified in the request (and will be ignored). Task count will be
    /// the length of task_environments.
    ///
    /// Tasks get a BATCH_TASK_INDEX and BATCH_TASK_COUNT environment variable, in
    /// addition to any environment variables set in task_environments, specifying
    /// the number of Tasks in the Task's parent TaskGroup, and the specific Task's
    /// index in the TaskGroup (0 through BATCH_TASK_COUNT - 1).
    #[prost(message, repeated, tag = "9")]
    pub task_environments: ::prost::alloc::vec::Vec<Environment>,
    /// Max number of tasks that can be run on a VM at the same time.
    /// If not specified, the system will decide a value based on available
    /// compute resources on a VM and task requirements.
    #[prost(int64, tag = "10")]
    pub task_count_per_node: i64,
    /// When true, Batch will populate a file with a list of all VMs assigned to
    /// the TaskGroup and set the BATCH_HOSTS_FILE environment variable to the path
    /// of that file. Defaults to false. The host file supports up to 1000 VMs.
    #[prost(bool, tag = "11")]
    pub require_hosts_file: bool,
    /// When true, Batch will configure SSH to allow passwordless login between
    /// VMs running the Batch tasks in the same TaskGroup.
    #[prost(bool, tag = "12")]
    pub permissive_ssh: bool,
    /// Optional. If not set or set to false, Batch uses the root user to execute
    /// runnables. If set to true, Batch runs the runnables using a non-root user.
    /// Currently, the non-root user Batch used is generated by OS Login. For more
    /// information, see [About OS
    /// Login](<https://cloud.google.com/compute/docs/oslogin>).
    #[prost(bool, tag = "14")]
    pub run_as_non_root: bool,
    /// Optional. ServiceAccount used by tasks within the task group for the access
    /// to other Cloud resources. This allows tasks to operate with permissions
    /// distinct from the service account for the VM set at `AllocationPolicy`. Use
    /// this field when tasks require different access rights than those of the VM.
    ///
    /// Specify the service account's `email` field. Ensure `scopes`
    /// include any necessary permissions for tasks, in addition to the default
    /// 'cloud-platform' scope.
    #[prost(message, optional, tag = "15")]
    pub service_account: ::core::option::Option<ServiceAccount>,
}
/// Nested message and enum types in `TaskGroup`.
pub mod task_group {
    /// How Tasks in the TaskGroup should be scheduled relative to each other.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SchedulingPolicy {
        /// Unspecified.
        Unspecified = 0,
        /// Run Tasks as soon as resources are available.
        ///
        /// Tasks might be executed in parallel depending on parallelism and
        /// task_count values.
        AsSoonAsPossible = 1,
        /// Run Tasks sequentially with increased task index.
        InOrder = 2,
    }
    impl SchedulingPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SCHEDULING_POLICY_UNSPECIFIED",
                Self::AsSoonAsPossible => "AS_SOON_AS_POSSIBLE",
                Self::InOrder => "IN_ORDER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCHEDULING_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "AS_SOON_AS_POSSIBLE" => Some(Self::AsSoonAsPossible),
                "IN_ORDER" => Some(Self::InOrder),
                _ => None,
            }
        }
    }
}
/// Carries information about a Google Cloud service account.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAccount {
    /// Email address of the service account.
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
    /// List of scopes to be enabled for this service account.
    #[prost(string, repeated, tag = "2")]
    pub scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Notification on resource state change.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Notification {
    /// Required. The Pub/Sub topic where notifications like the resource allowance
    /// state changes will be published. The topic must exist in the same project
    /// as the job and billings will be charged to this project. If not specified,
    /// no Pub/Sub messages will be sent. Topic format:
    /// `projects/{project}/topics/{topic}`.
    #[prost(string, tag = "1")]
    pub pubsub_topic: ::prost::alloc::string::String,
}
/// The Resource Allowance description for Cloud Batch.
/// Only one Resource Allowance is supported now under a specific location and
/// project.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceAllowance {
    /// Identifier. ResourceAllowance name.
    /// For example:
    /// "projects/123456/locations/us-central1/resourceAllowances/resource-allowance-1".
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. A system generated unique ID (in UUID4 format) for the
    /// ResourceAllowance.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. Time when the ResourceAllowance was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels are attributes that can be set and used by both the
    /// user and by Batch. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    /// underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    /// allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be <= 128 bytes.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Notification configurations.
    #[prost(message, repeated, tag = "6")]
    pub notifications: ::prost::alloc::vec::Vec<Notification>,
    /// ResourceAllowance detail.
    #[prost(oneof = "resource_allowance::ResourceAllowance", tags = "4")]
    pub resource_allowance: ::core::option::Option<
        resource_allowance::ResourceAllowance,
    >,
}
/// Nested message and enum types in `ResourceAllowance`.
pub mod resource_allowance {
    /// ResourceAllowance detail.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResourceAllowance {
        /// The detail of usage resource allowance.
        #[prost(message, tag = "4")]
        UsageResourceAllowance(super::UsageResourceAllowance),
    }
}
/// UsageResourceAllowance describes the detail of usage resource allowance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsageResourceAllowance {
    /// Required. Spec of a usage ResourceAllowance.
    #[prost(message, optional, tag = "1")]
    pub spec: ::core::option::Option<UsageResourceAllowanceSpec>,
    /// Output only. Status of a usage ResourceAllowance.
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<UsageResourceAllowanceStatus>,
}
/// Spec of a usage ResourceAllowance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsageResourceAllowanceSpec {
    /// Required. Spec type is unique for each usage ResourceAllowance.
    /// Batch now only supports type as "cpu-core-hours" for CPU usage consumption
    /// tracking.
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// Required. Threshold of a UsageResourceAllowance limiting how many resources
    /// can be consumed for each type.
    #[prost(message, optional, tag = "2")]
    pub limit: ::core::option::Option<usage_resource_allowance_spec::Limit>,
}
/// Nested message and enum types in `UsageResourceAllowanceSpec`.
pub mod usage_resource_allowance_spec {
    /// UsageResourceAllowance limitation.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Limit {
        /// Required. Limit value of a UsageResourceAllowance within its one
        /// duration.
        ///
        /// Limit cannot be a negative value. Default is 0.
        /// For example, you can set `limit` as 10000.0 with duration of the current
        /// month by setting `calendar_period` field as monthly. That means in your
        /// current month, 10000.0 is the core hour limitation that your resources
        /// are allowed to consume.
        #[prost(double, optional, tag = "2")]
        pub limit: ::core::option::Option<f64>,
        #[prost(oneof = "limit::Duration", tags = "1")]
        pub duration: ::core::option::Option<limit::Duration>,
    }
    /// Nested message and enum types in `Limit`.
    pub mod limit {
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Duration {
            /// Optional. A CalendarPeriod represents the abstract concept of a time
            /// period that has a canonical start.
            #[prost(enumeration = "super::super::CalendarPeriod", tag = "1")]
            CalendarPeriod(i32),
        }
    }
}
/// Status of a usage ResourceAllowance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsageResourceAllowanceStatus {
    /// Output only. ResourceAllowance state.
    #[prost(enumeration = "ResourceAllowanceState", tag = "1")]
    pub state: i32,
    /// Output only. ResourceAllowance consumption status for usage resources.
    #[prost(message, optional, tag = "2")]
    pub limit_status: ::core::option::Option<
        usage_resource_allowance_status::LimitStatus,
    >,
    /// Output only. The report of ResourceAllowance consumptions in a time period.
    #[prost(message, optional, tag = "3")]
    pub report: ::core::option::Option<
        usage_resource_allowance_status::ConsumptionReport,
    >,
}
/// Nested message and enum types in `UsageResourceAllowanceStatus`.
pub mod usage_resource_allowance_status {
    /// UsageResourceAllowanceStatus detail about usage consumption.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct LimitStatus {
        /// Output only. The consumption interval.
        #[prost(message, optional, tag = "1")]
        pub consumption_interval: ::core::option::Option<
            super::super::super::super::r#type::Interval,
        >,
        /// Output only. Limit value of a UsageResourceAllowance within its one
        /// duration.
        #[prost(double, optional, tag = "2")]
        pub limit: ::core::option::Option<f64>,
        /// Output only. Accumulated consumption during `consumption_interval`.
        #[prost(double, optional, tag = "3")]
        pub consumed: ::core::option::Option<f64>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PeriodConsumption {
        /// Output only. The consumption interval.
        #[prost(message, optional, tag = "1")]
        pub consumption_interval: ::core::option::Option<
            super::super::super::super::r#type::Interval,
        >,
        /// Output only. Accumulated consumption during `consumption_interval`.
        #[prost(double, optional, tag = "2")]
        pub consumed: ::core::option::Option<f64>,
    }
    /// ConsumptionReport is the report of ResourceAllowance consumptions in a time
    /// period.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsumptionReport {
        /// Output only. ResourceAllowance consumptions in the latest calendar
        /// period. Key is the calendar period in string format. Batch currently
        /// supports HOUR, DAY, MONTH and YEAR.
        #[prost(map = "string, message", tag = "1")]
        pub latest_period_consumptions: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            PeriodConsumption,
        >,
    }
}
/// A `CalendarPeriod` represents the abstract concept of a time period that
/// has a canonical start. All calendar times begin at 12 AM US and Canadian
/// Pacific Time (UTC-8).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CalendarPeriod {
    /// Unspecified.
    Unspecified = 0,
    /// The month starts on the first date of the month and resets at the beginning
    /// of each month.
    Month = 1,
    /// The quarter starts on dates January 1, April 1, July 1, and October 1 of
    /// each year and resets at the beginning of the next quarter.
    Quarter = 2,
    /// The year starts on January 1 and resets at the beginning of the next year.
    Year = 3,
    /// The week period starts and resets every Monday.
    Week = 4,
    /// The day starts at 12:00am.
    Day = 5,
}
impl CalendarPeriod {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CALENDAR_PERIOD_UNSPECIFIED",
            Self::Month => "MONTH",
            Self::Quarter => "QUARTER",
            Self::Year => "YEAR",
            Self::Week => "WEEK",
            Self::Day => "DAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CALENDAR_PERIOD_UNSPECIFIED" => Some(Self::Unspecified),
            "MONTH" => Some(Self::Month),
            "QUARTER" => Some(Self::Quarter),
            "YEAR" => Some(Self::Year),
            "WEEK" => Some(Self::Week),
            "DAY" => Some(Self::Day),
            _ => None,
        }
    }
}
/// ResourceAllowance valid state.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResourceAllowanceState {
    /// Unspecified.
    Unspecified = 0,
    /// ResourceAllowance is active and in use.
    ResourceAllowanceActive = 1,
    /// ResourceAllowance limit is reached.
    ResourceAllowanceDepleted = 2,
}
impl ResourceAllowanceState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RESOURCE_ALLOWANCE_STATE_UNSPECIFIED",
            Self::ResourceAllowanceActive => "RESOURCE_ALLOWANCE_ACTIVE",
            Self::ResourceAllowanceDepleted => "RESOURCE_ALLOWANCE_DEPLETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESOURCE_ALLOWANCE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "RESOURCE_ALLOWANCE_ACTIVE" => Some(Self::ResourceAllowanceActive),
            "RESOURCE_ALLOWANCE_DEPLETED" => Some(Self::ResourceAllowanceDepleted),
            _ => None,
        }
    }
}
/// CreateJob Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateJobRequest {
    /// Required. The parent resource name where the Job will be created.
    /// Pattern: "projects/{project}/locations/{location}"
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// ID used to uniquely identify the Job within its parent scope.
    /// This field should contain at most 63 characters and must start with
    /// lowercase characters.
    /// Only lowercase characters, numbers and '-' are accepted.
    /// The '-' character cannot be the first or the last one.
    /// A system generated ID will be used if the field is not set.
    ///
    /// The job.name field in the request will be ignored and the created resource
    /// name of the Job will be "{parent}/jobs/{job_id}".
    #[prost(string, tag = "2")]
    pub job_id: ::prost::alloc::string::String,
    /// Required. The Job to create.
    #[prost(message, optional, tag = "3")]
    pub job: ::core::option::Option<Job>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// GetJob Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobRequest {
    /// Required. Job name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// DeleteJob Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteJobRequest {
    /// Job name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Reason for this deletion.
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// CancelJob Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelJobRequest {
    /// Required. Job name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Response to the CancelJob request.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CancelJobResponse {}
/// UpdateJob Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateJobRequest {
    /// Required. The Job to update.
    /// Only fields specified in `updateMask` are updated.
    #[prost(message, optional, tag = "1")]
    pub job: ::core::option::Option<Job>,
    /// Required. Mask of fields to update.
    ///
    /// The `jobs.patch` method can only be used while a job is in the `QUEUED`,
    /// `SCHEDULED`, or `RUNNING` state and currently only supports increasing the
    /// value of the first `taskCount` field in the job's `taskGroups` field.
    /// Therefore, you must set the value of `updateMask` to `taskGroups`. Any
    /// other job fields in the update request will be ignored.
    ///
    /// For example, to update a job's `taskCount` to `2`, set `updateMask` to
    /// `taskGroups` and use the following request body:
    /// ```
    /// {
    ///    "taskGroups":[{
    ///      "taskCount": 2
    ///    }]
    /// }
    /// ```
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// ListJob Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsRequest {
    /// Parent path.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// List filter.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Sort results. Supported are "name", "name desc", "create_time",
    /// and "create_time desc".
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Page size.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// ListJob Response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsResponse {
    /// Jobs.
    #[prost(message, repeated, tag = "1")]
    pub jobs: ::prost::alloc::vec::Vec<Job>,
    /// Next page token.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// ListTasks Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTasksRequest {
    /// Required. Name of a TaskGroup from which Tasks are being requested.
    /// Pattern:
    /// "projects/{project}/locations/{location}/jobs/{job}/taskGroups/{task_group}"
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Task filter, null filter matches all Tasks.
    /// Filter string should be of the format State=TaskStatus.State e.g.
    /// State=RUNNING
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Not implemented.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Page size.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Page token.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// ListTasks Response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTasksResponse {
    /// Tasks.
    #[prost(message, repeated, tag = "1")]
    pub tasks: ::prost::alloc::vec::Vec<Task>,
    /// Next page token.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request for a single Task by name.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTaskRequest {
    /// Required. Task name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// CreateResourceAllowance Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateResourceAllowanceRequest {
    /// Required. The parent resource name where the ResourceAllowance will be
    /// created. Pattern: "projects/{project}/locations/{location}"
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// ID used to uniquely identify the ResourceAllowance within its parent scope.
    /// This field should contain at most 63 characters and must start with
    /// lowercase characters.
    /// Only lowercase characters, numbers and '-' are accepted.
    /// The '-' character cannot be the first or the last one.
    /// A system generated ID will be used if the field is not set.
    ///
    /// The resource_allowance.name field in the request will be ignored and the
    /// created resource name of the ResourceAllowance will be
    /// "{parent}/resourceAllowances/{resource_allowance_id}".
    #[prost(string, tag = "2")]
    pub resource_allowance_id: ::prost::alloc::string::String,
    /// Required. The ResourceAllowance to create.
    #[prost(message, optional, tag = "3")]
    pub resource_allowance: ::core::option::Option<ResourceAllowance>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// GetResourceAllowance Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetResourceAllowanceRequest {
    /// Required. ResourceAllowance name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// DeleteResourceAllowance Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteResourceAllowanceRequest {
    /// Required. ResourceAllowance name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Reason for this deletion.
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// ListResourceAllowances Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListResourceAllowancesRequest {
    /// Required. Parent path.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Page size.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// ListResourceAllowances Response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListResourceAllowancesResponse {
    /// ResourceAllowances.
    #[prost(message, repeated, tag = "1")]
    pub resource_allowances: ::prost::alloc::vec::Vec<ResourceAllowance>,
    /// Next page token.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// UpdateResourceAllowance Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateResourceAllowanceRequest {
    /// Required. The ResourceAllowance to update.
    /// Update description.
    /// Only fields specified in `update_mask` are updated.
    #[prost(message, optional, tag = "1")]
    pub resource_allowance: ::core::option::Option<ResourceAllowance>,
    /// Required. Mask of fields to update.
    ///
    /// Field mask is used to specify the fields to be overwritten in the
    /// ResourceAllowance resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    ///
    /// UpdateResourceAllowance request now only supports update on `limit` field.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Represents the metadata of the long-running operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod batch_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Google Batch Service.
    /// The service manages user submitted batch jobs and allocates Google Compute
    /// Engine VM instances to run the jobs.
    #[derive(Debug, Clone)]
    pub struct BatchServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BatchServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BatchServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BatchServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            BatchServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a Job.
        pub async fn create_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateJobRequest>,
        ) -> std::result::Result<tonic::Response<super::Job>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1alpha.BatchService/CreateJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.batch.v1alpha.BatchService",
                        "CreateJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a Job specified by its resource name.
        pub async fn get_job(
            &mut self,
            request: impl tonic::IntoRequest<super::GetJobRequest>,
        ) -> std::result::Result<tonic::Response<super::Job>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1alpha.BatchService/GetJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.batch.v1alpha.BatchService", "GetJob"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a Job.
        pub async fn delete_job(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1alpha.BatchService/DeleteJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.batch.v1alpha.BatchService",
                        "DeleteJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Cancel a Job.
        pub async fn cancel_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1alpha.BatchService/CancelJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.batch.v1alpha.BatchService",
                        "CancelJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a Job.
        pub async fn update_job(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateJobRequest>,
        ) -> std::result::Result<tonic::Response<super::Job>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1alpha.BatchService/UpdateJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.batch.v1alpha.BatchService",
                        "UpdateJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all Jobs for a project within a region.
        pub async fn list_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListJobsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListJobsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1alpha.BatchService/ListJobs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.batch.v1alpha.BatchService",
                        "ListJobs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Return a single Task.
        pub async fn get_task(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTaskRequest>,
        ) -> std::result::Result<tonic::Response<super::Task>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1alpha.BatchService/GetTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.batch.v1alpha.BatchService", "GetTask"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List Tasks associated with a job.
        pub async fn list_tasks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTasksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTasksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1alpha.BatchService/ListTasks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.batch.v1alpha.BatchService",
                        "ListTasks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a Resource Allowance.
        pub async fn create_resource_allowance(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateResourceAllowanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ResourceAllowance>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1alpha.BatchService/CreateResourceAllowance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.batch.v1alpha.BatchService",
                        "CreateResourceAllowance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a ResourceAllowance specified by its resource name.
        pub async fn get_resource_allowance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetResourceAllowanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ResourceAllowance>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1alpha.BatchService/GetResourceAllowance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.batch.v1alpha.BatchService",
                        "GetResourceAllowance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a ResourceAllowance.
        pub async fn delete_resource_allowance(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteResourceAllowanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1alpha.BatchService/DeleteResourceAllowance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.batch.v1alpha.BatchService",
                        "DeleteResourceAllowance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all ResourceAllowances for a project within a region.
        pub async fn list_resource_allowances(
            &mut self,
            request: impl tonic::IntoRequest<super::ListResourceAllowancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListResourceAllowancesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1alpha.BatchService/ListResourceAllowances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.batch.v1alpha.BatchService",
                        "ListResourceAllowances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a Resource Allowance.
        pub async fn update_resource_allowance(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateResourceAllowanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ResourceAllowance>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.batch.v1alpha.BatchService/UpdateResourceAllowance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.batch.v1alpha.BatchService",
                        "UpdateResourceAllowance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
