// This file is @generated by prost-build.
/// A `BackupPlan` specifies some common fields, such as `description` as well
/// as one or more `BackupRule` messages. Each `BackupRule` has a retention
/// policy and defines a schedule by which the system is to perform backup
/// workloads.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupPlan {
    /// Output only. Identifier. The resource name of the `BackupPlan`.
    ///
    /// Format: `projects/{project}/locations/{location}/backupPlans/{backup_plan}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The description of the `BackupPlan` resource.
    ///
    /// The description allows for additional details about `BackupPlan` and its
    /// use cases to be provided. An example description is the following:  "This
    /// is a backup plan that performs a daily backup at 6pm and retains data for 3
    /// months". The description must be at most 2048 characters.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Optional. This collection of key/value pairs allows for custom labels to be
    /// supplied by the user.  Example, {"tag": "Weekly"}.
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. When the `BackupPlan` was created.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. When the `BackupPlan` was last updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. The backup rules for this `BackupPlan`. There must be at least
    /// one `BackupRule` message.
    #[prost(message, repeated, tag = "6")]
    pub backup_rules: ::prost::alloc::vec::Vec<BackupRule>,
    /// Output only. The `State` for the `BackupPlan`.
    #[prost(enumeration = "backup_plan::State", tag = "7")]
    pub state: i32,
    /// Required. The resource type to which the `BackupPlan` will be applied.
    /// Examples include, "compute.googleapis.com/Instance",
    /// "sqladmin.googleapis.com/Instance", or "alloydb.googleapis.com/Cluster".
    #[prost(string, tag = "8")]
    pub resource_type: ::prost::alloc::string::String,
    /// Optional. `etag` is returned from the service in the response. As a user of
    /// the service, you may provide an etag value in this field to prevent stale
    /// resources.
    #[prost(string, tag = "9")]
    pub etag: ::prost::alloc::string::String,
    /// Required. Resource name of backup vault which will be used as storage
    /// location for backups. Format:
    /// projects/{project}/locations/{location}/backupVaults/{backupvault}
    #[prost(string, tag = "10")]
    pub backup_vault: ::prost::alloc::string::String,
    /// Output only. The Google Cloud Platform Service Account to be used by the
    /// BackupVault for taking backups. Specify the email address of the Backup
    /// Vault Service Account.
    #[prost(string, tag = "11")]
    pub backup_vault_service_account: ::prost::alloc::string::String,
}
/// Nested message and enum types in `BackupPlan`.
pub mod backup_plan {
    /// `State` enumerates the possible states for a `BackupPlan`.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State not set.
        Unspecified = 0,
        /// The resource is being created.
        Creating = 1,
        /// The resource has been created and is fully usable.
        Active = 2,
        /// The resource is being deleted.
        Deleting = 3,
        /// The resource has been created but is not usable.
        Inactive = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Deleting => "DELETING",
                Self::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// `BackupRule` binds the backup schedule to a retention policy.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupRule {
    /// Required. Immutable. The unique id of this `BackupRule`. The `rule_id` is
    /// unique per `BackupPlan`.The `rule_id` must start with a lowercase letter
    /// followed by up to 62 lowercase letters, numbers, or hyphens. Pattern,
    /// /[a-z][a-z0-9-]{,62}/.
    #[prost(string, tag = "1")]
    pub rule_id: ::prost::alloc::string::String,
    /// Required. Configures the duration for which backup data will be kept. It is
    /// defined in “days”. The value should be greater than or equal to minimum
    /// enforced retention of the backup vault.
    ///
    /// Minimum value is 1 and maximum value is 90 for hourly backups.
    /// Minimum value is 1 and maximum value is 90 for daily backups.
    /// Minimum value is 7 and maximum value is 186 for weekly backups.
    /// Minimum value is 30 and maximum value is 732 for monthly backups.
    /// Minimum value is 365 and maximum value is 36159 for yearly backups.
    #[prost(int32, tag = "4")]
    pub backup_retention_days: i32,
    /// The schedule that defines the automated backup workloads for this
    /// `BackupRule`.
    #[prost(oneof = "backup_rule::BackupScheduleOneof", tags = "5")]
    pub backup_schedule_oneof: ::core::option::Option<backup_rule::BackupScheduleOneof>,
}
/// Nested message and enum types in `BackupRule`.
pub mod backup_rule {
    /// The schedule that defines the automated backup workloads for this
    /// `BackupRule`.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum BackupScheduleOneof {
        /// Required. Defines a schedule that runs within the confines of a defined
        /// window of time.
        #[prost(message, tag = "5")]
        StandardSchedule(super::StandardSchedule),
    }
}
/// `StandardSchedule` defines a schedule that run within the confines of a
/// defined window of days. We can define recurrence type for schedule as
/// HOURLY, DAILY, WEEKLY, MONTHLY or YEARLY.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StandardSchedule {
    /// Required. Specifies the `RecurrenceType` for the schedule.
    #[prost(enumeration = "standard_schedule::RecurrenceType", tag = "1")]
    pub recurrence_type: i32,
    /// Optional. Specifies frequency for hourly backups. A hourly frequency of 2
    /// means jobs will run every 2 hours from start time till end time defined.
    ///
    /// This is required for `recurrence_type`, `HOURLY` and is not applicable
    /// otherwise. A validation error will occur if a value is supplied and
    /// `recurrence_type` is not `HOURLY`.
    ///
    /// Value of hourly frequency should be between 6 and 23.
    ///
    /// Reason for limit : We found that there is bandwidth limitation of 3GB/S for
    /// GMI while taking a backup and 5GB/S while doing a restore. Given the amount
    /// of parallel backups and restore we are targeting, this will potentially
    /// take the backup time to mins and hours (in worst case scenario).
    #[prost(int32, tag = "2")]
    pub hourly_frequency: i32,
    /// Optional. Specifies days of week like, MONDAY or TUESDAY, on which jobs
    /// will run.
    ///
    /// This is required for `recurrence_type`, `WEEKLY` and is not applicable
    /// otherwise. A validation error will occur if a value is supplied and
    /// `recurrence_type` is not `WEEKLY`.
    #[prost(
        enumeration = "super::super::super::r#type::DayOfWeek",
        repeated,
        packed = "false",
        tag = "3"
    )]
    pub days_of_week: ::prost::alloc::vec::Vec<i32>,
    /// Optional. Specifies days of months like 1, 5, or 14 on which jobs will run.
    ///
    /// Values for `days_of_month` are only applicable for `recurrence_type`,
    /// `MONTHLY` and `YEARLY`. A validation error will occur if other values are
    /// supplied.
    #[prost(int32, repeated, packed = "false", tag = "4")]
    pub days_of_month: ::prost::alloc::vec::Vec<i32>,
    /// Optional. Specifies a week day of the month like, FIRST SUNDAY or LAST
    /// MONDAY, on which jobs will run. This will be specified by two fields in
    /// `WeekDayOfMonth`, one for the day, e.g. `MONDAY`, and one for the week,
    /// e.g. `LAST`.
    ///
    /// This field is only applicable for `recurrence_type`, `MONTHLY` and
    /// `YEARLY`. A validation error will occur if other values are supplied.
    #[prost(message, optional, tag = "5")]
    pub week_day_of_month: ::core::option::Option<WeekDayOfMonth>,
    /// Optional. Specifies the months of year, like `FEBRUARY` and/or `MAY`, on
    /// which jobs will run.
    ///
    /// This field is only applicable when `recurrence_type` is `YEARLY`. A
    /// validation error will occur if other values are supplied.
    #[prost(
        enumeration = "super::super::super::r#type::Month",
        repeated,
        packed = "false",
        tag = "6"
    )]
    pub months: ::prost::alloc::vec::Vec<i32>,
    /// Required. A BackupWindow defines the window of day during which backup jobs
    /// will run. Jobs are queued at the beginning of the window and will be marked
    /// as `NOT_RUN` if they do not start by the end of the window.
    ///
    /// Note: running jobs will not be cancelled at the end of the window.
    #[prost(message, optional, tag = "7")]
    pub backup_window: ::core::option::Option<BackupWindow>,
    /// Required. The time zone to be used when interpreting the schedule.
    /// The value of this field must be a time zone name from the IANA tz database.
    /// See <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones> for the
    /// list of valid timezone names. For e.g., Europe/Paris.
    #[prost(string, tag = "8")]
    pub time_zone: ::prost::alloc::string::String,
}
/// Nested message and enum types in `StandardSchedule`.
pub mod standard_schedule {
    /// `RecurrenceTypes` enumerates the applicable periodicity for the schedule.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RecurrenceType {
        /// recurrence type not set
        Unspecified = 0,
        /// The `BackupRule` is to be applied hourly.
        Hourly = 1,
        /// The `BackupRule` is to be applied daily.
        Daily = 2,
        /// The `BackupRule` is to be applied weekly.
        Weekly = 3,
        /// The `BackupRule` is to be applied monthly.
        Monthly = 4,
        /// The `BackupRule` is to be applied yearly.
        Yearly = 5,
    }
    impl RecurrenceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RECURRENCE_TYPE_UNSPECIFIED",
                Self::Hourly => "HOURLY",
                Self::Daily => "DAILY",
                Self::Weekly => "WEEKLY",
                Self::Monthly => "MONTHLY",
                Self::Yearly => "YEARLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RECURRENCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "HOURLY" => Some(Self::Hourly),
                "DAILY" => Some(Self::Daily),
                "WEEKLY" => Some(Self::Weekly),
                "MONTHLY" => Some(Self::Monthly),
                "YEARLY" => Some(Self::Yearly),
                _ => None,
            }
        }
    }
}
/// `BackupWindow` defines a window of the day during which backup jobs will run.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BackupWindow {
    /// Required. The hour of day (0-23) when the window starts for e.g. if value
    /// of start hour of day is 6 that mean backup window start at 6:00.
    #[prost(int32, tag = "1")]
    pub start_hour_of_day: i32,
    /// Required. The hour of day (1-24) when the window end for e.g. if value of
    /// end hour of day is 10 that mean backup window end time is 10:00.
    ///
    /// End hour of day should be greater than start hour of day.
    /// 0 <= start_hour_of_day < end_hour_of_day <= 24
    ///
    /// End hour of day is not include in backup window that mean if
    /// end_hour_of_day= 10 jobs should start before 10:00.
    #[prost(int32, tag = "2")]
    pub end_hour_of_day: i32,
}
/// `WeekDayOfMonth` defines the week day of the month on which the backups will
/// run. The message combines a `WeekOfMonth` and `DayOfWeek` to produce values
/// like `FIRST`/`MONDAY` or `LAST`/`FRIDAY`.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WeekDayOfMonth {
    /// Required. Specifies the week of the month.
    #[prost(enumeration = "week_day_of_month::WeekOfMonth", tag = "1")]
    pub week_of_month: i32,
    /// Required. Specifies the day of the week.
    #[prost(enumeration = "super::super::super::r#type::DayOfWeek", tag = "2")]
    pub day_of_week: i32,
}
/// Nested message and enum types in `WeekDayOfMonth`.
pub mod week_day_of_month {
    /// `WeekOfMonth` enumerates possible weeks in the month, e.g. the first,
    /// third, or last week of the month.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WeekOfMonth {
        /// The zero value. Do not use.
        Unspecified = 0,
        /// The first week of the month.
        First = 1,
        /// The second week of the month.
        Second = 2,
        /// The third week of the month.
        Third = 3,
        /// The fourth  week of the month.
        Fourth = 4,
        /// The last  week of the month.
        Last = 5,
    }
    impl WeekOfMonth {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "WEEK_OF_MONTH_UNSPECIFIED",
                Self::First => "FIRST",
                Self::Second => "SECOND",
                Self::Third => "THIRD",
                Self::Fourth => "FOURTH",
                Self::Last => "LAST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WEEK_OF_MONTH_UNSPECIFIED" => Some(Self::Unspecified),
                "FIRST" => Some(Self::First),
                "SECOND" => Some(Self::Second),
                "THIRD" => Some(Self::Third),
                "FOURTH" => Some(Self::Fourth),
                "LAST" => Some(Self::Last),
                _ => None,
            }
        }
    }
}
/// The request message for creating a `BackupPlan`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBackupPlanRequest {
    /// Required. The `BackupPlan` project and location in the format
    /// `projects/{project}/locations/{location}`. In Cloud BackupDR locations
    /// map to GCP regions, for example **us-central1**.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The name of the `BackupPlan` to create. The name must be unique
    /// for the specified project and location.The name must start with a lowercase
    /// letter followed by up to 62 lowercase letters, numbers, or hyphens.
    /// Pattern, /[a-z][a-z0-9-]{,62}/.
    #[prost(string, tag = "2")]
    pub backup_plan_id: ::prost::alloc::string::String,
    /// Required. The `BackupPlan` resource object to create.
    #[prost(message, optional, tag = "3")]
    pub backup_plan: ::core::option::Option<BackupPlan>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request message for getting a list `BackupPlan`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupPlansRequest {
    /// Required. The project and location for which to retrieve `BackupPlans`
    /// information. Format: `projects/{project}/locations/{location}`. In Cloud
    /// BackupDR, locations map to GCP regions, for e.g. **us-central1**. To
    /// retrieve backup plans for all locations, use "-" for the
    /// `{location}` value.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `BackupPlans` to return in a single
    /// response. If not specified, a default value will be chosen by the service.
    /// Note that the response may include a partial list and a caller should
    /// only rely on the response's
    /// [next_page_token][google.cloud.backupdr.v1.ListBackupPlansResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The value of
    /// [next_page_token][google.cloud.backupdr.v1.ListBackupPlansResponse.next_page_token]
    /// received from a previous `ListBackupPlans` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to
    /// `ListBackupPlans` must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Field match expression used to filter the results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Field by which to sort the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response message for getting a list of `BackupPlan`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupPlansResponse {
    /// The list of `BackupPlans` in the project for the specified
    /// location.
    ///
    /// If the `{location}` value in the request is "-", the response contains a
    /// list of resources from all locations. In case any location is unreachable,
    /// the response will only return backup plans in reachable locations and
    /// the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    /// BackupPlan
    #[prost(message, repeated, tag = "1")]
    pub backup_plans: ::prost::alloc::vec::Vec<BackupPlan>,
    /// A token which may be sent as
    /// [page_token][google.cloud.backupdr.v1.ListBackupPlansRequest.page_token] in
    /// a subsequent `ListBackupPlans` call to retrieve the next page of results.
    /// If this field is omitted or empty, then there are no more results to
    /// return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The request message for getting a `BackupPlan`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBackupPlanRequest {
    /// Required. The resource name of the `BackupPlan` to retrieve.
    ///
    /// Format: `projects/{project}/locations/{location}/backupPlans/{backup_plan}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request message for deleting a `BackupPlan`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBackupPlanRequest {
    /// Required. The resource name of the `BackupPlan` to delete.
    ///
    /// Format: `projects/{project}/locations/{location}/backupPlans/{backup_plan}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// A BackupPlanAssociation represents a single BackupPlanAssociation which
/// contains details like workload, backup plan etc
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupPlanAssociation {
    /// Output only. Identifier. The resource name of BackupPlanAssociation in
    /// below format Format :
    /// projects/{project}/locations/{location}/backupPlanAssociations/{backupPlanAssociationId}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Immutable. Resource type of workload on which backupplan is
    /// applied
    #[prost(string, tag = "2")]
    pub resource_type: ::prost::alloc::string::String,
    /// Required. Immutable. Resource name of workload on which backupplan is
    /// applied
    #[prost(string, tag = "3")]
    pub resource: ::prost::alloc::string::String,
    /// Required. Resource name of backup plan which needs to be applied on
    /// workload. Format:
    /// projects/{project}/locations/{location}/backupPlans/{backupPlanId}
    #[prost(string, tag = "4")]
    pub backup_plan: ::prost::alloc::string::String,
    /// Output only. The time when the instance was created.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the instance was updated.
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The BackupPlanAssociation resource state.
    #[prost(enumeration = "backup_plan_association::State", tag = "7")]
    pub state: i32,
    /// Output only. The config info related to backup rules.
    #[prost(message, repeated, tag = "8")]
    pub rules_config_info: ::prost::alloc::vec::Vec<RuleConfigInfo>,
    /// Output only. Resource name of data source which will be used as storage
    /// location for backups taken. Format :
    /// projects/{project}/locations/{location}/backupVaults/{backupvault}/dataSources/{datasource}
    #[prost(string, tag = "9")]
    pub data_source: ::prost::alloc::string::String,
}
/// Nested message and enum types in `BackupPlanAssociation`.
pub mod backup_plan_association {
    /// Enum for State of BackupPlan Association
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State not set.
        Unspecified = 0,
        /// The resource is being created.
        Creating = 1,
        /// The resource has been created and is fully usable.
        Active = 2,
        /// The resource is being deleted.
        Deleting = 3,
        /// The resource has been created but is not usable.
        Inactive = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Deleting => "DELETING",
                Self::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// Message for rules config info.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuleConfigInfo {
    /// Output only. Backup Rule id fetched from backup plan.
    #[prost(string, tag = "1")]
    pub rule_id: ::prost::alloc::string::String,
    /// Output only. The last backup state for rule.
    #[prost(enumeration = "rule_config_info::LastBackupState", tag = "3")]
    pub last_backup_state: i32,
    /// Output only. google.rpc.Status object to store the last backup error.
    #[prost(message, optional, tag = "4")]
    pub last_backup_error: ::core::option::Option<super::super::super::rpc::Status>,
    /// Output only. The point in time when the last successful backup was captured
    /// from the source.
    #[prost(message, optional, tag = "5")]
    pub last_successful_backup_consistency_time: ::core::option::Option<
        ::prost_types::Timestamp,
    >,
}
/// Nested message and enum types in `RuleConfigInfo`.
pub mod rule_config_info {
    /// Enum for LastBackupState
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LastBackupState {
        /// State not set.
        Unspecified = 0,
        /// The first backup is pending.
        FirstBackupPending = 1,
        /// The most recent backup could not be run/failed because of the lack of
        /// permissions.
        PermissionDenied = 2,
        /// The last backup operation succeeded.
        Succeeded = 3,
        /// The last backup operation failed.
        Failed = 4,
    }
    impl LastBackupState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LAST_BACKUP_STATE_UNSPECIFIED",
                Self::FirstBackupPending => "FIRST_BACKUP_PENDING",
                Self::PermissionDenied => "PERMISSION_DENIED",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LAST_BACKUP_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "FIRST_BACKUP_PENDING" => Some(Self::FirstBackupPending),
                "PERMISSION_DENIED" => Some(Self::PermissionDenied),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Request message for creating a backup plan.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBackupPlanAssociationRequest {
    /// Required. The backup plan association project and location in the format
    /// `projects/{project_id}/locations/{location}`. In Cloud BackupDR locations
    /// map to GCP regions, for example **us-central1**.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The name of the backup plan association to create. The name must
    /// be unique for the specified project and location.
    #[prost(string, tag = "2")]
    pub backup_plan_association_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub backup_plan_association: ::core::option::Option<BackupPlanAssociation>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for List BackupPlanAssociation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupPlanAssociationsRequest {
    /// Required. The project and location for which to retrieve backup Plan
    /// Associations information, in the format
    /// `projects/{project_id}/locations/{location}`. In Cloud BackupDR, locations
    /// map to GCP regions, for example **us-central1**. To retrieve backup plan
    /// associations for all locations, use "-" for the
    /// `{location}` value.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// Response message for List BackupPlanAssociation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupPlanAssociationsResponse {
    /// The list of Backup Plan Associations in the project for the specified
    /// location.
    ///
    /// If the `{location}` value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return backup plan associations in reachable
    /// locations and the 'unreachable' field will be populated with a list of
    /// unreachable locations.
    #[prost(message, repeated, tag = "1")]
    pub backup_plan_associations: ::prost::alloc::vec::Vec<BackupPlanAssociation>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request message for getting a BackupPlanAssociation resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBackupPlanAssociationRequest {
    /// Required. Name of the backup plan association resource, in the format
    /// `projects/{project}/locations/{location}/backupPlanAssociations/{backupPlanAssociationId}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for deleting a backup plan association.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBackupPlanAssociationRequest {
    /// Required. Name of the backup plan association resource, in the format
    /// `projects/{project}/locations/{location}/backupPlanAssociations/{backupPlanAssociationId}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for triggering a backup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TriggerBackupRequest {
    /// Required. Name of the backup plan association resource, in the format
    /// `projects/{project}/locations/{location}/backupPlanAssociations/{backupPlanAssociationId}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. backup rule_id for which a backup needs to be triggered.
    #[prost(string, tag = "2")]
    pub rule_id: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// BackupApplianceBackupProperties represents BackupDR backup appliance's
/// properties.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BackupApplianceBackupProperties {
    /// Output only. The numeric generation ID of the backup (monotonically
    /// increasing).
    #[prost(int32, optional, tag = "1")]
    pub generation_id: ::core::option::Option<i32>,
    /// Output only. The time when this backup object was finalized (if none,
    /// backup is not finalized).
    #[prost(message, optional, tag = "2")]
    pub finalize_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The earliest timestamp of data available in this Backup.
    #[prost(message, optional, tag = "3")]
    pub recovery_range_start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The latest timestamp of data available in this Backup.
    #[prost(message, optional, tag = "4")]
    pub recovery_range_end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// ComputeInstanceBackupProperties represents Compute Engine instance backup
/// properties.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeInstanceBackupProperties {
    /// An optional text description for the instances that are created from these
    /// properties.
    #[prost(string, optional, tag = "1")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// A list of tags to apply to the instances that are created from these
    /// properties. The tags identify valid sources or targets for network
    /// firewalls. The setTags method can modify this list of tags. Each tag within
    /// the list must comply with RFC1035 (<https://www.ietf.org/rfc/rfc1035.txt>).
    #[prost(message, optional, tag = "2")]
    pub tags: ::core::option::Option<Tags>,
    /// The machine type to use for instances that are created from these
    /// properties.
    #[prost(string, optional, tag = "3")]
    pub machine_type: ::core::option::Option<::prost::alloc::string::String>,
    /// Enables instances created based on these properties to send packets with
    /// source IP addresses other than their own and receive packets with
    /// destination IP addresses other than their own. If these instances will be
    /// used as an IP gateway or it will be set as the next-hop in a Route
    /// resource, specify `true`. If unsure, leave this set to `false`. See the
    /// <https://cloud.google.com/vpc/docs/using-routes#canipforward>
    /// documentation for more information.
    #[prost(bool, optional, tag = "4")]
    pub can_ip_forward: ::core::option::Option<bool>,
    /// An array of network access configurations for this interface.
    #[prost(message, repeated, tag = "5")]
    pub network_interface: ::prost::alloc::vec::Vec<NetworkInterface>,
    /// An array of disks that are associated with the instances that are created
    /// from these properties.
    #[prost(message, repeated, tag = "6")]
    pub disk: ::prost::alloc::vec::Vec<AttachedDisk>,
    /// The metadata key/value pairs to assign to instances that are created from
    /// these properties. These pairs can consist of custom metadata or predefined
    /// keys. See <https://cloud.google.com/compute/docs/metadata/overview> for more
    /// information.
    #[prost(message, optional, tag = "7")]
    pub metadata: ::core::option::Option<Metadata>,
    /// A list of service accounts with specified scopes. Access tokens for these
    /// service accounts are available to the instances that are created from
    /// these properties. Use metadata queries to obtain the access tokens for
    /// these instances.
    #[prost(message, repeated, tag = "8")]
    pub service_account: ::prost::alloc::vec::Vec<ServiceAccount>,
    /// Specifies the scheduling options for the instances that are created from
    /// these properties.
    #[prost(message, optional, tag = "9")]
    pub scheduling: ::core::option::Option<Scheduling>,
    /// A list of guest accelerator cards' type and count to use for instances
    /// created from these properties.
    #[prost(message, repeated, tag = "10")]
    pub guest_accelerator: ::prost::alloc::vec::Vec<AcceleratorConfig>,
    /// Minimum cpu/platform to be used by instances. The instance may be
    /// scheduled on the specified or newer cpu/platform. Applicable values are the
    /// friendly names of CPU platforms, such as
    /// `minCpuPlatform: Intel Haswell` or `minCpuPlatform: Intel Sandy Bridge`.
    /// For more information, read
    /// <https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform.>
    #[prost(string, optional, tag = "11")]
    pub min_cpu_platform: ::core::option::Option<::prost::alloc::string::String>,
    /// KeyRevocationActionType of the instance. Supported options are "STOP" and
    /// "NONE". The default value is "NONE" if it is not specified.
    #[prost(enumeration = "KeyRevocationActionType", optional, tag = "12")]
    pub key_revocation_action_type: ::core::option::Option<i32>,
    /// The source instance used to create this backup. This can be a partial or
    /// full URL to the resource. For example, the following are valid values:
    ///    -<https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance>
    ///    -projects/project/zones/zone/instances/instance
    #[prost(string, optional, tag = "13")]
    pub source_instance: ::core::option::Option<::prost::alloc::string::String>,
    /// Labels to apply to instances that are created from these properties.
    #[prost(map = "string, string", tag = "14")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// ComputeInstanceRestoreProperties represents Compute Engine instance
/// properties to be overridden during restore.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeInstanceRestoreProperties {
    /// Required. Name of the compute instance.
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Controls for advanced machine-related behavior features.
    #[prost(message, optional, tag = "2")]
    pub advanced_machine_features: ::core::option::Option<AdvancedMachineFeatures>,
    /// Optional. Allows this instance to send and receive packets with
    /// non-matching destination or source IPs.
    #[prost(bool, optional, tag = "3")]
    pub can_ip_forward: ::core::option::Option<bool>,
    /// Optional. Controls Confidential compute options on the instance
    #[prost(message, optional, tag = "4")]
    pub confidential_instance_config: ::core::option::Option<ConfidentialInstanceConfig>,
    /// Optional. Whether the resource should be protected against deletion.
    #[prost(bool, optional, tag = "5")]
    pub deletion_protection: ::core::option::Option<bool>,
    /// Optional. An optional description of this resource. Provide this property
    /// when you create the resource.
    #[prost(string, optional, tag = "6")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Array of disks associated with this instance. Persistent disks
    /// must be created before you can assign them.
    #[prost(message, repeated, tag = "7")]
    pub disks: ::prost::alloc::vec::Vec<AttachedDisk>,
    /// Optional. Enables display device for the instance.
    #[prost(message, optional, tag = "8")]
    pub display_device: ::core::option::Option<DisplayDevice>,
    /// Optional. A list of the type and count of accelerator cards attached to the
    /// instance.
    #[prost(message, repeated, tag = "9")]
    pub guest_accelerators: ::prost::alloc::vec::Vec<AcceleratorConfig>,
    /// Optional. Specifies the hostname of the instance. The specified hostname
    /// must be RFC1035 compliant. If hostname is not specified, the default
    /// hostname is \[INSTANCE_NAME\].c.\[PROJECT_ID\].internal when using the global
    /// DNS, and \[INSTANCE_NAME\].[ZONE].c.\[PROJECT_ID\].internal when using zonal
    /// DNS.
    #[prost(string, optional, tag = "10")]
    pub hostname: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Encrypts suspended data for an instance with a
    /// customer-managed encryption key.
    #[prost(message, optional, tag = "11")]
    pub instance_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    /// Optional. KeyRevocationActionType of the instance.
    #[prost(enumeration = "KeyRevocationActionType", optional, tag = "12")]
    pub key_revocation_action_type: ::core::option::Option<i32>,
    /// Optional. Labels to apply to this instance.
    #[prost(map = "string, string", tag = "13")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Full or partial URL of the machine type resource to use for this
    /// instance.
    #[prost(string, optional, tag = "14")]
    pub machine_type: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. This includes custom metadata and predefined keys.
    #[prost(message, optional, tag = "15")]
    pub metadata: ::core::option::Option<Metadata>,
    /// Optional. Minimum CPU platform to use for this instance.
    #[prost(string, optional, tag = "16")]
    pub min_cpu_platform: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. An array of network configurations for this instance. These
    /// specify how interfaces are configured to interact with other network
    /// services, such as connecting to the internet. Multiple interfaces are
    /// supported per instance.
    #[prost(message, repeated, tag = "17")]
    pub network_interfaces: ::prost::alloc::vec::Vec<NetworkInterface>,
    /// Optional. Configure network performance such as egress bandwidth tier.
    #[prost(message, optional, tag = "18")]
    pub network_performance_config: ::core::option::Option<NetworkPerformanceConfig>,
    /// Input only. Additional params passed with the request, but not persisted
    /// as part of resource payload.
    #[prost(message, optional, tag = "19")]
    pub params: ::core::option::Option<InstanceParams>,
    /// Optional. The private IPv6 google access type for the VM.
    /// If not specified, use INHERIT_FROM_SUBNETWORK as default.
    #[prost(
        enumeration = "compute_instance_restore_properties::InstancePrivateIpv6GoogleAccess",
        optional,
        tag = "20"
    )]
    pub private_ipv6_google_access: ::core::option::Option<i32>,
    /// Optional. Specifies the reservations that this instance can consume from.
    #[prost(message, optional, tag = "21")]
    pub allocation_affinity: ::core::option::Option<AllocationAffinity>,
    /// Optional. Resource policies applied to this instance.
    #[prost(string, repeated, tag = "22")]
    pub resource_policies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Sets the scheduling options for this instance.
    #[prost(message, optional, tag = "23")]
    pub scheduling: ::core::option::Option<Scheduling>,
    /// Optional. A list of service accounts, with their specified scopes,
    /// authorized for this instance. Only one service account per VM instance is
    /// supported.
    #[prost(message, repeated, tag = "24")]
    pub service_accounts: ::prost::alloc::vec::Vec<ServiceAccount>,
    /// Optional. Tags to apply to this instance. Tags are used to identify valid
    /// sources or targets for network firewalls and are specified by the client
    /// during instance creation.
    #[prost(message, optional, tag = "26")]
    pub tags: ::core::option::Option<Tags>,
}
/// Nested message and enum types in `ComputeInstanceRestoreProperties`.
pub mod compute_instance_restore_properties {
    /// The private IPv6 google access type for the VMs.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InstancePrivateIpv6GoogleAccess {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Each network interface inherits PrivateIpv6GoogleAccess from its
        /// subnetwork.
        InheritFromSubnetwork = 1,
        /// Outbound private IPv6 access from VMs in this subnet to Google services.
        /// If specified, the subnetwork who is attached to the instance's default
        /// network interface will be assigned an internal IPv6 prefix if it doesn't
        /// have before.
        EnableOutboundVmAccessToGoogle = 2,
        /// Bidirectional private IPv6 access to/from Google services. If
        /// specified, the subnetwork who is attached to the instance's default
        /// network interface will be assigned an internal IPv6 prefix if it doesn't
        /// have before.
        EnableBidirectionalAccessToGoogle = 3,
    }
    impl InstancePrivateIpv6GoogleAccess {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "INSTANCE_PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED",
                Self::InheritFromSubnetwork => "INHERIT_FROM_SUBNETWORK",
                Self::EnableOutboundVmAccessToGoogle => {
                    "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE"
                }
                Self::EnableBidirectionalAccessToGoogle => {
                    "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INSTANCE_PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED" => {
                    Some(Self::Unspecified)
                }
                "INHERIT_FROM_SUBNETWORK" => Some(Self::InheritFromSubnetwork),
                "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE" => {
                    Some(Self::EnableOutboundVmAccessToGoogle)
                }
                "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE" => {
                    Some(Self::EnableBidirectionalAccessToGoogle)
                }
                _ => None,
            }
        }
    }
}
/// ComputeInstanceTargetEnvironment represents Compute Engine target
/// environment to be used during restore.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeInstanceTargetEnvironment {
    /// Required. Target project for the Compute Engine instance.
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    /// Required. The zone of the Compute Engine instance.
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
}
/// ComputeInstanceDataSourceProperties represents the properties of a
/// ComputeEngine resource that are stored in the DataSource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeInstanceDataSourceProperties {
    /// Name of the compute instance backed up by the datasource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The description of the Compute Engine instance.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// The machine type of the instance.
    #[prost(string, tag = "3")]
    pub machine_type: ::prost::alloc::string::String,
    /// The total number of disks attached to the Instance.
    #[prost(int64, tag = "4")]
    pub total_disk_count: i64,
    /// The sum of all the disk sizes.
    #[prost(int64, tag = "5")]
    pub total_disk_size_gb: i64,
}
/// Specifies options for controlling advanced machine features.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdvancedMachineFeatures {
    /// Optional. Whether to enable nested virtualization or not (default is
    /// false).
    #[prost(bool, optional, tag = "1")]
    pub enable_nested_virtualization: ::core::option::Option<bool>,
    /// Optional. The number of threads per physical core. To disable simultaneous
    /// multithreading (SMT) set this to 1. If unset, the maximum number
    /// of threads supported per core by the underlying processor is
    /// assumed.
    #[prost(int32, optional, tag = "2")]
    pub threads_per_core: ::core::option::Option<i32>,
    /// Optional. The number of physical cores to expose to an instance. Multiply
    /// by the number of threads per core to compute the total number of virtual
    /// CPUs to expose to the instance. If unset, the number of cores is
    /// inferred from the instance's nominal CPU count and the underlying
    /// platform's SMT width.
    #[prost(int32, optional, tag = "3")]
    pub visible_core_count: ::core::option::Option<i32>,
    /// Optional. Whether to enable UEFI networking for instance creation.
    #[prost(bool, optional, tag = "4")]
    pub enable_uefi_networking: ::core::option::Option<bool>,
}
/// A set of Confidential Instance options.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConfidentialInstanceConfig {
    /// Optional. Defines whether the instance should have confidential compute
    /// enabled.
    #[prost(bool, optional, tag = "1")]
    pub enable_confidential_compute: ::core::option::Option<bool>,
}
/// A set of Display Device options
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisplayDevice {
    /// Optional. Enables display for the Compute Engine VM
    #[prost(bool, optional, tag = "1")]
    pub enable_display: ::core::option::Option<bool>,
}
/// A specification of the type and number of accelerator cards attached to the
/// instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceleratorConfig {
    /// Optional. Full or partial URL of the accelerator type resource to attach to
    /// this instance.
    #[prost(string, optional, tag = "1")]
    pub accelerator_type: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The number of the guest accelerator cards exposed to this
    /// instance.
    #[prost(int32, optional, tag = "2")]
    pub accelerator_count: ::core::option::Option<i32>,
}
/// A customer-supplied encryption key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerEncryptionKey {
    /// Optional. The service account being used for the encryption request for the
    /// given KMS key. If absent, the Compute Engine default service account is
    /// used.
    #[prost(string, optional, tag = "4")]
    pub kms_key_service_account: ::core::option::Option<::prost::alloc::string::String>,
    /// The key to use for encryption.
    #[prost(oneof = "customer_encryption_key::Key", tags = "1, 2, 3")]
    pub key: ::core::option::Option<customer_encryption_key::Key>,
}
/// Nested message and enum types in `CustomerEncryptionKey`.
pub mod customer_encryption_key {
    /// The key to use for encryption.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Key {
        /// Optional. Specifies a 256-bit customer-supplied
        /// encryption key.
        #[prost(string, tag = "1")]
        RawKey(::prost::alloc::string::String),
        /// Optional. RSA-wrapped 2048-bit
        /// customer-supplied encryption key to either encrypt or decrypt this
        /// resource.
        #[prost(string, tag = "2")]
        RsaEncryptedKey(::prost::alloc::string::String),
        /// Optional. The name of the encryption key that is stored in Google Cloud
        /// KMS.
        #[prost(string, tag = "3")]
        KmsKeyName(::prost::alloc::string::String),
    }
}
/// A key/value pair to be used for storing metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entry {
    /// Optional. Key for the metadata entry.
    #[prost(string, optional, tag = "1")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Value for the metadata entry. These are free-form strings, and
    /// only have meaning as interpreted by the image running in the instance. The
    /// only restriction placed on values is that their size must be less than
    /// or equal to 262144 bytes (256 KiB).
    #[prost(string, optional, tag = "2")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
/// A metadata key/value entry.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    /// Optional. Array of key/value pairs. The total size of all keys and values
    /// must be less than 512 KB.
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<Entry>,
}
/// A network interface resource attached to an instance.
/// s
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInterface {
    /// Optional. URL of the VPC network resource for this instance.
    #[prost(string, optional, tag = "1")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The URL of the Subnetwork resource for this instance.
    #[prost(string, optional, tag = "2")]
    pub subnetwork: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. An IPv4 internal IP address to assign to the instance for this
    /// network interface. If not specified by the user, an unused internal IP is
    /// assigned by the system.
    #[prost(string, optional, tag = "3")]
    pub ip_address: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. An IPv6 internal network address for this network interface. To
    /// use a static internal IP address, it must be unused and in the same region
    /// as the instance's zone. If not specified, Google Cloud will automatically
    /// assign an internal IPv6 address from the instance's subnetwork.
    #[prost(string, optional, tag = "4")]
    pub ipv6_address: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The prefix length of the primary internal IPv6 range.
    #[prost(int32, optional, tag = "5")]
    pub internal_ipv6_prefix_length: ::core::option::Option<i32>,
    /// Output only. \[Output Only\] The name of the network interface, which is
    /// generated by the server.
    #[prost(string, optional, tag = "6")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. An array of configurations for this interface. Currently, only
    /// one access config,ONE_TO_ONE_NAT is supported. If there are no
    /// accessConfigs specified, then this instance will have
    /// no external internet access.
    #[prost(message, repeated, tag = "7")]
    pub access_configs: ::prost::alloc::vec::Vec<AccessConfig>,
    /// Optional. An array of IPv6 access configurations for this interface.
    /// Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there
    /// is no ipv6AccessConfig specified, then this instance will
    /// have no external IPv6 Internet access.
    #[prost(message, repeated, tag = "8")]
    pub ipv6_access_configs: ::prost::alloc::vec::Vec<AccessConfig>,
    /// Optional. An array of alias IP ranges for this network interface.
    /// You can only specify this field for network interfaces in VPC networks.
    #[prost(message, repeated, tag = "9")]
    pub alias_ip_ranges: ::prost::alloc::vec::Vec<AliasIpRange>,
    /// The stack type for this network interface.
    #[prost(enumeration = "network_interface::StackType", optional, tag = "10")]
    pub stack_type: ::core::option::Option<i32>,
    /// Optional. \[Output Only\] One of EXTERNAL, INTERNAL to indicate whether the
    /// IP can be accessed from the Internet. This field is always inherited from
    /// its subnetwork.
    #[prost(enumeration = "network_interface::Ipv6AccessType", optional, tag = "11")]
    pub ipv6_access_type: ::core::option::Option<i32>,
    /// Optional. The networking queue count that's specified by users for the
    /// network interface. Both Rx and Tx queues will be set to this number. It'll
    /// be empty if not specified by the users.
    #[prost(int32, optional, tag = "12")]
    pub queue_count: ::core::option::Option<i32>,
    /// Optional. The type of vNIC to be used on this interface. This may be gVNIC
    /// or VirtioNet.
    #[prost(enumeration = "network_interface::NicType", optional, tag = "13")]
    pub nic_type: ::core::option::Option<i32>,
    /// Optional. The URL of the network attachment that this interface should
    /// connect to in the following format:
    /// projects/{project_number}/regions/{region_name}/networkAttachments/{network_attachment_name}.
    #[prost(string, optional, tag = "14")]
    pub network_attachment: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `NetworkInterface`.
pub mod network_interface {
    /// Stack type for this network interface.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StackType {
        /// Default should be STACK_TYPE_UNSPECIFIED.
        Unspecified = 0,
        /// The network interface will be assigned IPv4 address.
        Ipv4Only = 1,
        /// The network interface can have both IPv4 and IPv6 addresses.
        Ipv4Ipv6 = 2,
    }
    impl StackType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STACK_TYPE_UNSPECIFIED",
                Self::Ipv4Only => "IPV4_ONLY",
                Self::Ipv4Ipv6 => "IPV4_IPV6",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STACK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "IPV4_ONLY" => Some(Self::Ipv4Only),
                "IPV4_IPV6" => Some(Self::Ipv4Ipv6),
                _ => None,
            }
        }
    }
    /// IPv6 access type for this network interface.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Ipv6AccessType {
        /// IPv6 access type not set. Means this network interface hasn't been
        /// turned on IPv6 yet.
        UnspecifiedIpv6AccessType = 0,
        /// This network interface can have internal IPv6.
        Internal = 1,
        /// This network interface can have external IPv6.
        External = 2,
    }
    impl Ipv6AccessType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnspecifiedIpv6AccessType => "UNSPECIFIED_IPV6_ACCESS_TYPE",
                Self::Internal => "INTERNAL",
                Self::External => "EXTERNAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED_IPV6_ACCESS_TYPE" => Some(Self::UnspecifiedIpv6AccessType),
                "INTERNAL" => Some(Self::Internal),
                "EXTERNAL" => Some(Self::External),
                _ => None,
            }
        }
    }
    /// Nic type for this network interface.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NicType {
        /// Default should be NIC_TYPE_UNSPECIFIED.
        Unspecified = 0,
        /// VIRTIO
        VirtioNet = 1,
        /// GVNIC
        Gvnic = 2,
    }
    impl NicType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "NIC_TYPE_UNSPECIFIED",
                Self::VirtioNet => "VIRTIO_NET",
                Self::Gvnic => "GVNIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NIC_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "VIRTIO_NET" => Some(Self::VirtioNet),
                "GVNIC" => Some(Self::Gvnic),
                _ => None,
            }
        }
    }
}
/// Network performance configuration.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NetworkPerformanceConfig {
    /// Optional. The tier of the total egress bandwidth.
    #[prost(enumeration = "network_performance_config::Tier", optional, tag = "1")]
    pub total_egress_bandwidth_tier: ::core::option::Option<i32>,
}
/// Nested message and enum types in `NetworkPerformanceConfig`.
pub mod network_performance_config {
    /// Network performance tier.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Tier {
        /// This value is unused.
        Unspecified = 0,
        /// Default network performance config.
        Default = 1,
        /// Tier 1 network performance config.
        Tier1 = 2,
    }
    impl Tier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TIER_UNSPECIFIED",
                Self::Default => "DEFAULT",
                Self::Tier1 => "TIER_1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIER_UNSPECIFIED" => Some(Self::Unspecified),
                "DEFAULT" => Some(Self::Default),
                "TIER_1" => Some(Self::Tier1),
                _ => None,
            }
        }
    }
}
/// An access configuration attached to an instance's network interface.
/// Only one access config per instance is supported.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessConfig {
    /// Optional. In accessConfigs (IPv4), the
    ///   default and only option is ONE_TO_ONE_NAT. In
    ///   ipv6AccessConfigs, the default and only option is
    ///   DIRECT_IPV6.
    #[prost(enumeration = "access_config::AccessType", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    /// Optional. The name of this access configuration.
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The external IP address of this access configuration.
    #[prost(string, optional, tag = "3")]
    pub external_ip: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The external IPv6 address of this access configuration.
    #[prost(string, optional, tag = "4")]
    pub external_ipv6: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The prefix length of the external IPv6 range.
    #[prost(int32, optional, tag = "5")]
    pub external_ipv6_prefix_length: ::core::option::Option<i32>,
    /// Optional. Specifies whether a public DNS 'PTR' record should be created to
    /// map the external IP address of the instance to a DNS domain name.
    #[prost(bool, optional, tag = "6")]
    pub set_public_ptr: ::core::option::Option<bool>,
    /// Optional. The DNS domain name for the public PTR record.
    #[prost(string, optional, tag = "7")]
    pub public_ptr_domain_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. This signifies the networking tier used for configuring this
    /// access
    #[prost(enumeration = "access_config::NetworkTier", optional, tag = "8")]
    pub network_tier: ::core::option::Option<i32>,
}
/// Nested message and enum types in `AccessConfig`.
pub mod access_config {
    /// The type of configuration.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccessType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// ONE_TO_ONE_NAT
        OneToOneNat = 1,
        /// Direct IPv6 access.
        DirectIpv6 = 2,
    }
    impl AccessType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ACCESS_TYPE_UNSPECIFIED",
                Self::OneToOneNat => "ONE_TO_ONE_NAT",
                Self::DirectIpv6 => "DIRECT_IPV6",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACCESS_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ONE_TO_ONE_NAT" => Some(Self::OneToOneNat),
                "DIRECT_IPV6" => Some(Self::DirectIpv6),
                _ => None,
            }
        }
    }
    /// Network tier property used by addresses, instances and forwarding rules.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NetworkTier {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// High quality, Google-grade network tier, support for all networking
        /// products.
        Premium = 1,
        /// Public internet quality, only limited support for other networking
        /// products.
        Standard = 2,
    }
    impl NetworkTier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "NETWORK_TIER_UNSPECIFIED",
                Self::Premium => "PREMIUM",
                Self::Standard => "STANDARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NETWORK_TIER_UNSPECIFIED" => Some(Self::Unspecified),
                "PREMIUM" => Some(Self::Premium),
                "STANDARD" => Some(Self::Standard),
                _ => None,
            }
        }
    }
}
/// An alias IP range attached to an instance's network interface.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AliasIpRange {
    /// Optional. The IP alias ranges to allocate for this interface.
    #[prost(string, optional, tag = "1")]
    pub ip_cidr_range: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The name of a subnetwork secondary IP range from which to
    /// allocate an IP alias range. If not specified, the primary range of the
    /// subnetwork is used.
    #[prost(string, optional, tag = "2")]
    pub subnetwork_range_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Additional instance params.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceParams {
    /// Optional. Resource manager tags to be bound to the instance.
    #[prost(map = "string, string", tag = "1")]
    pub resource_manager_tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Specifies the reservations that this instance can consume from.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationAffinity {
    /// Optional. Specifies the type of reservation from which this instance can
    /// consume
    #[prost(enumeration = "allocation_affinity::Type", optional, tag = "1")]
    pub consume_allocation_type: ::core::option::Option<i32>,
    /// Optional. Corresponds to the label key of a reservation resource.
    #[prost(string, optional, tag = "2")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Corresponds to the label values of a reservation resource.
    #[prost(string, repeated, tag = "3")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `AllocationAffinity`.
pub mod allocation_affinity {
    /// Indicates whether to consume from a reservation or not.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Do not consume from any allocated capacity.
        NoReservation = 1,
        /// Consume any allocation available.
        AnyReservation = 2,
        /// Must consume from a specific reservation. Must specify key value fields
        /// for specifying the reservations.
        SpecificReservation = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::NoReservation => "NO_RESERVATION",
                Self::AnyReservation => "ANY_RESERVATION",
                Self::SpecificReservation => "SPECIFIC_RESERVATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NO_RESERVATION" => Some(Self::NoReservation),
                "ANY_RESERVATION" => Some(Self::AnyReservation),
                "SPECIFIC_RESERVATION" => Some(Self::SpecificReservation),
                _ => None,
            }
        }
    }
}
/// Sets the scheduling options for an Instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Scheduling {
    /// Optional. Defines the maintenance behavior for this instance.
    #[prost(enumeration = "scheduling::OnHostMaintenance", optional, tag = "1")]
    pub on_host_maintenance: ::core::option::Option<i32>,
    /// Optional. Specifies whether the instance should be automatically restarted
    /// if it is terminated by Compute Engine (not terminated by a user).
    #[prost(bool, optional, tag = "2")]
    pub automatic_restart: ::core::option::Option<bool>,
    /// Optional. Defines whether the instance is preemptible.
    #[prost(bool, optional, tag = "3")]
    pub preemptible: ::core::option::Option<bool>,
    /// Optional. A set of node affinity and anti-affinity configurations.
    /// Overrides reservationAffinity.
    #[prost(message, repeated, tag = "4")]
    pub node_affinities: ::prost::alloc::vec::Vec<scheduling::NodeAffinity>,
    /// Optional. The minimum number of virtual CPUs this instance will consume
    /// when running on a sole-tenant node.
    #[prost(int32, optional, tag = "5")]
    pub min_node_cpus: ::core::option::Option<i32>,
    /// Optional. Specifies the provisioning model of the instance.
    #[prost(enumeration = "scheduling::ProvisioningModel", optional, tag = "6")]
    pub provisioning_model: ::core::option::Option<i32>,
    /// Optional. Specifies the termination action for the instance.
    #[prost(enumeration = "scheduling::InstanceTerminationAction", optional, tag = "7")]
    pub instance_termination_action: ::core::option::Option<i32>,
    /// Optional. Specifies the maximum amount of time a Local Ssd Vm should wait
    /// while recovery of the Local Ssd state is attempted. Its value should be in
    /// between 0 and 168 hours with hour granularity and the default value being 1
    /// hour.
    #[prost(message, optional, tag = "10")]
    pub local_ssd_recovery_timeout: ::core::option::Option<SchedulingDuration>,
}
/// Nested message and enum types in `Scheduling`.
pub mod scheduling {
    /// Node Affinity: the configuration of desired nodes onto which this Instance
    /// could be scheduled.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NodeAffinity {
        /// Optional. Corresponds to the label key of Node resource.
        #[prost(string, optional, tag = "1")]
        pub key: ::core::option::Option<::prost::alloc::string::String>,
        /// Optional. Defines the operation of node selection.
        #[prost(enumeration = "node_affinity::Operator", optional, tag = "2")]
        pub operator: ::core::option::Option<i32>,
        /// Optional. Corresponds to the label values of Node resource.
        #[prost(string, repeated, tag = "3")]
        pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `NodeAffinity`.
    pub mod node_affinity {
        /// Defines the type of node selections.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Operator {
            /// Default value. This value is unused.
            Unspecified = 0,
            /// Requires Compute Engine to seek for matched nodes.
            In = 1,
            /// Requires Compute Engine to avoid certain nodes.
            NotIn = 2,
        }
        impl Operator {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "OPERATOR_UNSPECIFIED",
                    Self::In => "IN",
                    Self::NotIn => "NOT_IN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                    "IN" => Some(Self::In),
                    "NOT_IN" => Some(Self::NotIn),
                    _ => None,
                }
            }
        }
    }
    /// Defines the maintenance behavior for this instance=
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OnHostMaintenance {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Tells Compute Engine to terminate and (optionally) restart the instance
        /// away from the maintenance activity.
        Terminate = 1,
        /// Default, Allows Compute Engine to automatically migrate instances
        /// out of the way of maintenance events.
        Migrate = 1000,
    }
    impl OnHostMaintenance {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ON_HOST_MAINTENANCE_UNSPECIFIED",
                Self::Terminate => "TERMINATE",
                Self::Migrate => "MIGRATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ON_HOST_MAINTENANCE_UNSPECIFIED" => Some(Self::Unspecified),
                "TERMINATE" => Some(Self::Terminate),
                "MIGRATE" => Some(Self::Migrate),
                _ => None,
            }
        }
    }
    /// Defines the provisioning model for an instance.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProvisioningModel {
        /// Default value. This value is not used.
        Unspecified = 0,
        /// Standard provisioning with user controlled runtime, no discounts.
        Standard = 1,
        /// Heavily discounted, no guaranteed runtime.
        Spot = 2,
    }
    impl ProvisioningModel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROVISIONING_MODEL_UNSPECIFIED",
                Self::Standard => "STANDARD",
                Self::Spot => "SPOT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROVISIONING_MODEL_UNSPECIFIED" => Some(Self::Unspecified),
                "STANDARD" => Some(Self::Standard),
                "SPOT" => Some(Self::Spot),
                _ => None,
            }
        }
    }
    /// Defines the supported termination actions for an instance.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InstanceTerminationAction {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Delete the VM.
        Delete = 1,
        /// Stop the VM without storing in-memory content. default action.
        Stop = 2,
    }
    impl InstanceTerminationAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "INSTANCE_TERMINATION_ACTION_UNSPECIFIED",
                Self::Delete => "DELETE",
                Self::Stop => "STOP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INSTANCE_TERMINATION_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "DELETE" => Some(Self::Delete),
                "STOP" => Some(Self::Stop),
                _ => None,
            }
        }
    }
}
/// A SchedulingDuration represents a fixed-length span of time represented
/// as a count of seconds and fractions of seconds at nanosecond
/// resolution. It is independent of any calendar and concepts like "day"
/// or "month". Range is approximately 10,000 years.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SchedulingDuration {
    /// Optional. Span of time at a resolution of a second.
    #[prost(int64, optional, tag = "1")]
    pub seconds: ::core::option::Option<i64>,
    /// Optional. Span of time that's a fraction of a second at nanosecond
    /// resolution.
    #[prost(int32, optional, tag = "2")]
    pub nanos: ::core::option::Option<i32>,
}
/// A service account.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAccount {
    /// Optional. Email address of the service account.
    #[prost(string, optional, tag = "1")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The list of scopes to be made available for this service account.
    #[prost(string, repeated, tag = "2")]
    pub scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A set of instance tags.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tags {
    /// Optional. An array of tags. Each tag must be 1-63 characters long, and
    /// comply with RFC1035.
    #[prost(string, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// An instance-attached disk resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachedDisk {
    /// Optional. Specifies the parameters to initialize this disk.
    #[prost(message, optional, tag = "1")]
    pub initialize_params: ::core::option::Option<attached_disk::InitializeParams>,
    /// Optional. This is used as an identifier for the disks. This is the unique
    /// name has to provided to modify disk parameters like disk_name and
    /// replica_zones (in case of RePDs)
    #[prost(string, optional, tag = "4")]
    pub device_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Type of the resource.
    #[prost(string, optional, tag = "5")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    /// Specifies the type of the disk.
    #[deprecated]
    #[prost(enumeration = "attached_disk::DiskType", optional, tag = "6")]
    pub disk_type_deprecated: ::core::option::Option<i32>,
    /// Optional. The mode in which to attach this disk.
    #[prost(enumeration = "attached_disk::DiskMode", optional, tag = "7")]
    pub mode: ::core::option::Option<i32>,
    /// Optional. Specifies a valid partial or full URL to an existing Persistent
    /// Disk resource.
    #[prost(string, optional, tag = "8")]
    pub source: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. A zero-based index to this disk, where 0 is reserved for the
    /// boot disk.
    #[prost(int64, optional, tag = "9")]
    pub index: ::core::option::Option<i64>,
    /// Optional. Indicates that this is a boot disk. The virtual machine will use
    /// the first partition of the disk for its root filesystem.
    #[prost(bool, optional, tag = "10")]
    pub boot: ::core::option::Option<bool>,
    /// Optional. Specifies whether the disk will be auto-deleted when the instance
    /// is deleted (but not when the disk is detached from the instance).
    #[prost(bool, optional, tag = "11")]
    pub auto_delete: ::core::option::Option<bool>,
    /// Optional. Any valid publicly visible licenses.
    #[prost(string, repeated, tag = "12")]
    pub license: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Specifies the disk interface to use for attaching this disk.
    #[prost(enumeration = "attached_disk::DiskInterface", optional, tag = "13")]
    pub disk_interface: ::core::option::Option<i32>,
    /// Optional. A list of features to enable on the guest operating system.
    /// Applicable only for bootable images.
    #[prost(message, repeated, tag = "14")]
    pub guest_os_feature: ::prost::alloc::vec::Vec<GuestOsFeature>,
    /// Optional. Encrypts or decrypts a disk using a customer-supplied
    /// encryption key.
    #[prost(message, optional, tag = "15")]
    pub disk_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    /// Optional. The size of the disk in GB.
    #[prost(int64, optional, tag = "16")]
    pub disk_size_gb: ::core::option::Option<i64>,
    /// Optional. Output only. The state of the disk.
    #[prost(enumeration = "attached_disk::DiskSavedState", optional, tag = "17")]
    pub saved_state: ::core::option::Option<i32>,
    /// Optional. Output only. The URI of the disk type resource. For example:
    /// projects/project/zones/zone/diskTypes/pd-standard or pd-ssd
    #[prost(string, optional, tag = "18")]
    pub disk_type: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Specifies the type of the disk.
    #[prost(enumeration = "attached_disk::DiskType", optional, tag = "19")]
    pub r#type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `AttachedDisk`.
pub mod attached_disk {
    /// Specifies the parameters to initialize this disk.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InitializeParams {
        /// Optional. Specifies the disk name. If not specified, the default is to
        /// use the name of the instance.
        #[prost(string, optional, tag = "1")]
        pub disk_name: ::core::option::Option<::prost::alloc::string::String>,
        /// Optional. URL of the zone where the disk should be created.
        /// Required for each regional disk associated with the instance.
        #[prost(string, repeated, tag = "2")]
        pub replica_zones: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// List of the Disk Types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DiskType {
        /// Default value, which is unused.
        Unspecified = 0,
        /// A scratch disk type.
        Scratch = 1,
        /// A persistent disk type.
        Persistent = 2,
    }
    impl DiskType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DISK_TYPE_UNSPECIFIED",
                Self::Scratch => "SCRATCH",
                Self::Persistent => "PERSISTENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DISK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SCRATCH" => Some(Self::Scratch),
                "PERSISTENT" => Some(Self::Persistent),
                _ => None,
            }
        }
    }
    /// List of the Disk Modes.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DiskMode {
        /// Default value, which is unused.
        Unspecified = 0,
        /// Attaches this disk in read-write mode. Only one
        /// virtual machine at a time can be attached to a disk in read-write mode.
        ReadWrite = 1,
        /// Attaches this disk in read-only mode. Multiple virtual machines can use
        /// a disk in read-only mode at a time.
        ReadOnly = 2,
        /// The disk is locked for administrative reasons. Nobody else
        /// can use the disk. This mode is used (for example) when taking
        /// a snapshot of a disk to prevent mounting the disk while it is
        /// being snapshotted.
        Locked = 3,
    }
    impl DiskMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DISK_MODE_UNSPECIFIED",
                Self::ReadWrite => "READ_WRITE",
                Self::ReadOnly => "READ_ONLY",
                Self::Locked => "LOCKED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DISK_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "READ_WRITE" => Some(Self::ReadWrite),
                "READ_ONLY" => Some(Self::ReadOnly),
                "LOCKED" => Some(Self::Locked),
                _ => None,
            }
        }
    }
    /// List of the Disk Interfaces.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DiskInterface {
        /// Default value, which is unused.
        Unspecified = 0,
        /// SCSI Disk Interface.
        Scsi = 1,
        /// NVME Disk Interface.
        Nvme = 2,
        /// NVDIMM Disk Interface.
        Nvdimm = 3,
        /// ISCSI Disk Interface.
        Iscsi = 4,
    }
    impl DiskInterface {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DISK_INTERFACE_UNSPECIFIED",
                Self::Scsi => "SCSI",
                Self::Nvme => "NVME",
                Self::Nvdimm => "NVDIMM",
                Self::Iscsi => "ISCSI",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DISK_INTERFACE_UNSPECIFIED" => Some(Self::Unspecified),
                "SCSI" => Some(Self::Scsi),
                "NVME" => Some(Self::Nvme),
                "NVDIMM" => Some(Self::Nvdimm),
                "ISCSI" => Some(Self::Iscsi),
                _ => None,
            }
        }
    }
    /// List of the states of the Disk.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DiskSavedState {
        /// Default Disk state has not been preserved.
        Unspecified = 0,
        /// Disk state has been preserved.
        Preserved = 1,
    }
    impl DiskSavedState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DISK_SAVED_STATE_UNSPECIFIED",
                Self::Preserved => "PRESERVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DISK_SAVED_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PRESERVED" => Some(Self::Preserved),
                _ => None,
            }
        }
    }
}
/// Feature type of the Guest OS.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GuestOsFeature {
    /// The ID of a supported feature.
    #[prost(enumeration = "guest_os_feature::FeatureType", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `GuestOsFeature`.
pub mod guest_os_feature {
    /// List of the Feature Types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeatureType {
        /// Default value, which is unused.
        Unspecified = 0,
        /// VIRTIO_SCSI_MULTIQUEUE feature type.
        VirtioScsiMultiqueue = 1,
        /// WINDOWS feature type.
        Windows = 2,
        /// MULTI_IP_SUBNET feature type.
        MultiIpSubnet = 3,
        /// UEFI_COMPATIBLE feature type.
        UefiCompatible = 4,
        /// SECURE_BOOT feature type.
        SecureBoot = 5,
        /// GVNIC feature type.
        Gvnic = 6,
        /// SEV_CAPABLE feature type.
        SevCapable = 7,
        /// BARE_METAL_LINUX_COMPATIBLE feature type.
        BareMetalLinuxCompatible = 8,
        /// SUSPEND_RESUME_COMPATIBLE feature type.
        SuspendResumeCompatible = 9,
        /// SEV_LIVE_MIGRATABLE feature type.
        SevLiveMigratable = 10,
        /// SEV_SNP_CAPABLE feature type.
        SevSnpCapable = 11,
        /// TDX_CAPABLE feature type.
        TdxCapable = 12,
        /// IDPF feature type.
        Idpf = 13,
        /// SEV_LIVE_MIGRATABLE_V2 feature type.
        SevLiveMigratableV2 = 14,
    }
    impl FeatureType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FEATURE_TYPE_UNSPECIFIED",
                Self::VirtioScsiMultiqueue => "VIRTIO_SCSI_MULTIQUEUE",
                Self::Windows => "WINDOWS",
                Self::MultiIpSubnet => "MULTI_IP_SUBNET",
                Self::UefiCompatible => "UEFI_COMPATIBLE",
                Self::SecureBoot => "SECURE_BOOT",
                Self::Gvnic => "GVNIC",
                Self::SevCapable => "SEV_CAPABLE",
                Self::BareMetalLinuxCompatible => "BARE_METAL_LINUX_COMPATIBLE",
                Self::SuspendResumeCompatible => "SUSPEND_RESUME_COMPATIBLE",
                Self::SevLiveMigratable => "SEV_LIVE_MIGRATABLE",
                Self::SevSnpCapable => "SEV_SNP_CAPABLE",
                Self::TdxCapable => "TDX_CAPABLE",
                Self::Idpf => "IDPF",
                Self::SevLiveMigratableV2 => "SEV_LIVE_MIGRATABLE_V2",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FEATURE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "VIRTIO_SCSI_MULTIQUEUE" => Some(Self::VirtioScsiMultiqueue),
                "WINDOWS" => Some(Self::Windows),
                "MULTI_IP_SUBNET" => Some(Self::MultiIpSubnet),
                "UEFI_COMPATIBLE" => Some(Self::UefiCompatible),
                "SECURE_BOOT" => Some(Self::SecureBoot),
                "GVNIC" => Some(Self::Gvnic),
                "SEV_CAPABLE" => Some(Self::SevCapable),
                "BARE_METAL_LINUX_COMPATIBLE" => Some(Self::BareMetalLinuxCompatible),
                "SUSPEND_RESUME_COMPATIBLE" => Some(Self::SuspendResumeCompatible),
                "SEV_LIVE_MIGRATABLE" => Some(Self::SevLiveMigratable),
                "SEV_SNP_CAPABLE" => Some(Self::SevSnpCapable),
                "TDX_CAPABLE" => Some(Self::TdxCapable),
                "IDPF" => Some(Self::Idpf),
                "SEV_LIVE_MIGRATABLE_V2" => Some(Self::SevLiveMigratableV2),
                _ => None,
            }
        }
    }
}
/// Specifies whether the virtual machine instance will be shut down on key
/// revocation. It is currently used in instance, instance properties and GMI
/// protos
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeyRevocationActionType {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// Indicates user chose no operation.
    None = 1,
    /// Indicates user chose to opt for VM shutdown on key revocation.
    Stop = 2,
}
impl KeyRevocationActionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED",
            Self::None => "NONE",
            Self::Stop => "STOP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NONE" => Some(Self::None),
            "STOP" => Some(Self::Stop),
            _ => None,
        }
    }
}
/// Message describing a BackupVault object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupVault {
    /// Output only. Identifier. Name of the backup vault to create. It must have
    /// the
    /// format`"projects/{project}/locations/{location}/backupVaults/{backupvault}"`.
    /// `{backupvault}` cannot be changed after creation. It must be between 3-63
    /// characters long and must be unique within the project and location.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The description of the BackupVault instance (2048 characters or
    /// less).
    #[prost(string, optional, tag = "2")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Resource labels to represent user provided metadata.
    /// No labels currently defined:
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The time when the instance was created.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the instance was updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. The default and minimum enforced retention for each backup within
    /// the backup vault.  The enforced retention for each backup can be extended.
    #[prost(message, optional, tag = "20")]
    pub backup_minimum_enforced_retention_duration: ::core::option::Option<
        ::prost_types::Duration,
    >,
    /// Output only. Set to true when there are no backups nested under this
    /// resource.
    #[prost(bool, optional, tag = "8")]
    pub deletable: ::core::option::Option<bool>,
    /// Optional. Server specified ETag for the backup vault resource to
    /// prevent simultaneous updates from overwiting each other.
    #[prost(string, optional, tag = "9")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The BackupVault resource instance state.
    #[prost(enumeration = "backup_vault::State", tag = "10")]
    pub state: i32,
    /// Optional. Time after which the BackupVault resource is locked.
    #[prost(message, optional, tag = "12")]
    pub effective_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The number of backups in this backup vault.
    #[prost(int64, tag = "17")]
    pub backup_count: i64,
    /// Output only. Service account used by the BackupVault Service for this
    /// BackupVault.  The user should grant this account permissions in their
    /// workload project to enable the service to run backups and restores there.
    #[prost(string, tag = "18")]
    pub service_account: ::prost::alloc::string::String,
    /// Output only. Total size of the storage used by all backup resources.
    #[prost(int64, tag = "19")]
    pub total_stored_bytes: i64,
    /// Output only. Immutable after resource creation until resource deletion.
    #[prost(string, tag = "21")]
    pub uid: ::prost::alloc::string::String,
    /// Optional. User annotations. See <https://google.aip.dev/128#annotations>
    /// Stores small amounts of arbitrary data.
    #[prost(map = "string, string", tag = "22")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Note: This field is added for future use case and will not be
    /// supported in the current release.
    ///
    /// Access restriction for the backup vault.
    /// Default value is WITHIN_ORGANIZATION if not provided during creation.
    #[prost(enumeration = "backup_vault::AccessRestriction", tag = "24")]
    pub access_restriction: i32,
}
/// Nested message and enum types in `BackupVault`.
pub mod backup_vault {
    /// Holds the state of the backup vault resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State not set.
        Unspecified = 0,
        /// The backup vault is being created.
        Creating = 1,
        /// The backup vault has been created and is fully usable.
        Active = 2,
        /// The backup vault is being deleted.
        Deleting = 3,
        /// The backup vault is experiencing an issue and might be unusable.
        Error = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Deleting => "DELETING",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
    /// Holds the access restriction for the backup vault.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccessRestriction {
        /// Access restriction not set. If user does not provide any value or pass
        /// this value, it will be changed to WITHIN_ORGANIZATION.
        Unspecified = 0,
        /// Access to or from resources outside your current project will be denied.
        WithinProject = 1,
        /// Access to or from resources outside your current organization will be
        /// denied.
        WithinOrganization = 2,
        /// No access restriction.
        Unrestricted = 3,
        /// Access to or from resources outside your current organization will be
        /// denied except for backup appliance.
        WithinOrgButUnrestrictedForBa = 4,
    }
    impl AccessRestriction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ACCESS_RESTRICTION_UNSPECIFIED",
                Self::WithinProject => "WITHIN_PROJECT",
                Self::WithinOrganization => "WITHIN_ORGANIZATION",
                Self::Unrestricted => "UNRESTRICTED",
                Self::WithinOrgButUnrestrictedForBa => {
                    "WITHIN_ORG_BUT_UNRESTRICTED_FOR_BA"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACCESS_RESTRICTION_UNSPECIFIED" => Some(Self::Unspecified),
                "WITHIN_PROJECT" => Some(Self::WithinProject),
                "WITHIN_ORGANIZATION" => Some(Self::WithinOrganization),
                "UNRESTRICTED" => Some(Self::Unrestricted),
                "WITHIN_ORG_BUT_UNRESTRICTED_FOR_BA" => {
                    Some(Self::WithinOrgButUnrestrictedForBa)
                }
                _ => None,
            }
        }
    }
}
/// Message describing a DataSource object.
/// Datasource object used to represent Datasource details for both admin and
/// basic view.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataSource {
    /// Output only. Identifier. Name of the datasource to create.
    /// It must have the
    /// format`"projects/{project}/locations/{location}/backupVaults/{backupvault}/dataSources/{datasource}"`.
    /// `{datasource}` cannot be changed after creation. It must be between 3-63
    /// characters long and must be unique within the backup vault.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The DataSource resource instance state.
    #[prost(enumeration = "data_source::State", tag = "21")]
    pub state: i32,
    /// Optional. Resource labels to represent user provided metadata.
    /// No labels currently defined:
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The time when the instance was created.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the instance was updated.
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Number of backups in the data source.
    #[prost(int64, optional, tag = "7")]
    pub backup_count: ::core::option::Option<i64>,
    /// Server specified ETag for the ManagementServer resource to prevent
    /// simultaneous updates from overwiting each other.
    #[prost(string, optional, tag = "14")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    /// The number of bytes (metadata and data) stored in this datasource.
    #[prost(int64, optional, tag = "23")]
    pub total_stored_bytes: ::core::option::Option<i64>,
    /// Output only. The backup configuration state.
    #[prost(enumeration = "BackupConfigState", tag = "24")]
    pub config_state: i32,
    /// Output only. Details of how the resource is configured for backup.
    #[prost(message, optional, tag = "25")]
    pub backup_config_info: ::core::option::Option<BackupConfigInfo>,
    /// The source resource that is represented by this DataSource. It can be a
    /// Google Cloud resource, or one backed up by a Backup Appliance.
    #[prost(oneof = "data_source::SourceResource", tags = "26, 27")]
    pub source_resource: ::core::option::Option<data_source::SourceResource>,
}
/// Nested message and enum types in `DataSource`.
pub mod data_source {
    /// Holds the state of the data source resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State not set.
        Unspecified = 0,
        /// The data source is being created.
        Creating = 1,
        /// The data source has been created and is fully usable.
        Active = 2,
        /// The data source is being deleted.
        Deleting = 3,
        /// The data source is experiencing an issue and might be unusable.
        Error = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Deleting => "DELETING",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
    /// The source resource that is represented by this DataSource. It can be a
    /// Google Cloud resource, or one backed up by a Backup Appliance.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SourceResource {
        /// The backed up resource is a Google Cloud resource.
        /// The word 'DataSource' was included in the names to indicate that this is
        /// the representation of the Google Cloud resource used within the
        /// DataSource object.
        #[prost(message, tag = "26")]
        DataSourceGcpResource(super::DataSourceGcpResource),
        /// The backed up resource is a backup appliance application.
        #[prost(message, tag = "27")]
        DataSourceBackupApplianceApplication(
            super::DataSourceBackupApplianceApplication,
        ),
    }
}
/// BackupConfigInfo has information about how the resource is configured
/// for Backup and about the most recent backup to this vault.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupConfigInfo {
    /// Output only. The status of the last backup to this BackupVault
    #[prost(enumeration = "backup_config_info::LastBackupState", tag = "1")]
    pub last_backup_state: i32,
    /// Output only. If the last backup were successful, this field has the
    /// consistency date.
    #[prost(message, optional, tag = "2")]
    pub last_successful_backup_consistency_time: ::core::option::Option<
        ::prost_types::Timestamp,
    >,
    /// Output only. If the last backup failed, this field has the error message.
    #[prost(message, optional, tag = "3")]
    pub last_backup_error: ::core::option::Option<super::super::super::rpc::Status>,
    /// Configuration Info has the resource format-specific configuration.
    #[prost(oneof = "backup_config_info::BackupConfig", tags = "4, 5")]
    pub backup_config: ::core::option::Option<backup_config_info::BackupConfig>,
}
/// Nested message and enum types in `BackupConfigInfo`.
pub mod backup_config_info {
    /// LastBackupstate tracks whether the last backup was not yet started,
    /// successful, failed, or could not be run because of the lack of permissions.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LastBackupState {
        /// Status not set.
        Unspecified = 0,
        /// The first backup has not yet completed
        FirstBackupPending = 1,
        /// The most recent backup was successful
        Succeeded = 2,
        /// The most recent backup failed
        Failed = 3,
        /// The most recent backup could not be run/failed because of the lack of
        /// permissions
        PermissionDenied = 4,
    }
    impl LastBackupState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LAST_BACKUP_STATE_UNSPECIFIED",
                Self::FirstBackupPending => "FIRST_BACKUP_PENDING",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::PermissionDenied => "PERMISSION_DENIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LAST_BACKUP_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "FIRST_BACKUP_PENDING" => Some(Self::FirstBackupPending),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "PERMISSION_DENIED" => Some(Self::PermissionDenied),
                _ => None,
            }
        }
    }
    /// Configuration Info has the resource format-specific configuration.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum BackupConfig {
        /// Configuration for a Google Cloud resource.
        #[prost(message, tag = "4")]
        GcpBackupConfig(super::GcpBackupConfig),
        /// Configuration for an application backed up by a Backup Appliance.
        #[prost(message, tag = "5")]
        BackupApplianceBackupConfig(super::BackupApplianceBackupConfig),
    }
}
/// GcpBackupConfig captures the Backup configuration details for Google Cloud
/// resources. All Google Cloud resources regardless of type are protected with
/// backup plan associations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcpBackupConfig {
    /// The name of the backup plan.
    #[prost(string, tag = "1")]
    pub backup_plan: ::prost::alloc::string::String,
    /// The description of the backup plan.
    #[prost(string, tag = "2")]
    pub backup_plan_description: ::prost::alloc::string::String,
    /// The name of the backup plan association.
    #[prost(string, tag = "3")]
    pub backup_plan_association: ::prost::alloc::string::String,
    /// The names of the backup plan rules which point to this backupvault
    #[prost(string, repeated, tag = "4")]
    pub backup_plan_rules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// BackupApplianceBackupConfig captures the backup configuration for
/// applications that are protected by Backup Appliances.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupApplianceBackupConfig {
    /// The name of the backup appliance.
    #[prost(string, tag = "1")]
    pub backup_appliance_name: ::prost::alloc::string::String,
    /// The ID of the backup appliance.
    #[prost(int64, tag = "2")]
    pub backup_appliance_id: i64,
    /// The ID of the SLA of this application.
    #[prost(int64, tag = "3")]
    pub sla_id: i64,
    /// The name of the application.
    #[prost(string, tag = "4")]
    pub application_name: ::prost::alloc::string::String,
    /// The name of the host where the application is running.
    #[prost(string, tag = "5")]
    pub host_name: ::prost::alloc::string::String,
    /// The name of the SLT associated with the application.
    #[prost(string, tag = "6")]
    pub slt_name: ::prost::alloc::string::String,
    /// The name of the SLP associated with the application.
    #[prost(string, tag = "7")]
    pub slp_name: ::prost::alloc::string::String,
}
/// DataSourceGcpResource is used for protected resources that are Google Cloud
/// Resources. This name is easeier to understand than GcpResourceDataSource or
/// GcpDataSourceResource
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataSourceGcpResource {
    /// Output only. Full resource pathname URL of the source Google Cloud
    /// resource.
    #[prost(string, tag = "1")]
    pub gcp_resourcename: ::prost::alloc::string::String,
    /// Location of the resource: <region>/<zone>/"global"/"unspecified".
    #[prost(string, tag = "2")]
    pub location: ::prost::alloc::string::String,
    /// The type of the Google Cloud resource. Use the Unified Resource Type,
    /// eg. compute.googleapis.com/Instance.
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    /// gcp_Properties has properties of the Google Cloud Resource.
    #[prost(oneof = "data_source_gcp_resource::GcpResourceProperties", tags = "4")]
    pub gcp_resource_properties: ::core::option::Option<
        data_source_gcp_resource::GcpResourceProperties,
    >,
}
/// Nested message and enum types in `DataSourceGcpResource`.
pub mod data_source_gcp_resource {
    /// gcp_Properties has properties of the Google Cloud Resource.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum GcpResourceProperties {
        /// ComputeInstanceDataSourceProperties has a subset of Compute Instance
        /// properties that are useful at the Datasource level.
        #[prost(message, tag = "4")]
        ComputeInstanceDatasourceProperties(super::ComputeInstanceDataSourceProperties),
    }
}
/// BackupApplianceApplication describes a Source Resource when it is an
/// application backed up by a BackupAppliance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataSourceBackupApplianceApplication {
    /// The name of the Application as known to the Backup Appliance.
    #[prost(string, tag = "1")]
    pub application_name: ::prost::alloc::string::String,
    /// Appliance name.
    #[prost(string, tag = "2")]
    pub backup_appliance: ::prost::alloc::string::String,
    /// Appliance Id of the Backup Appliance.
    #[prost(int64, tag = "3")]
    pub appliance_id: i64,
    /// The type of the application. e.g. VMBackup
    #[prost(string, tag = "4")]
    pub r#type: ::prost::alloc::string::String,
    /// The appid field of the application within the Backup Appliance.
    #[prost(int64, tag = "8")]
    pub application_id: i64,
    /// Hostname of the host where the application is running.
    #[prost(string, tag = "6")]
    pub hostname: ::prost::alloc::string::String,
    /// Hostid of the application host.
    #[prost(int64, tag = "7")]
    pub host_id: i64,
}
/// ServiceLockInfo represents the details of a lock taken by the service on a
/// Backup resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceLockInfo {
    /// Output only. The name of the operation that created this lock.
    /// The lock will automatically be released when the operation completes.
    #[prost(string, tag = "1")]
    pub operation: ::prost::alloc::string::String,
}
/// BackupApplianceLockInfo contains metadata about the backupappliance that
/// created the lock.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupApplianceLockInfo {
    /// Required. The ID of the backup/recovery appliance that created this lock.
    #[prost(int64, tag = "1")]
    pub backup_appliance_id: i64,
    /// Required. The name of the backup/recovery appliance that created this lock.
    #[prost(string, tag = "2")]
    pub backup_appliance_name: ::prost::alloc::string::String,
    /// Required. The reason for the lock: e.g. MOUNT/RESTORE/BACKUP/etc.  The
    /// value of this string is only meaningful to the client and it is not
    /// interpreted by the BackupVault service.
    #[prost(string, tag = "5")]
    pub lock_reason: ::prost::alloc::string::String,
    /// The information about this lock.
    #[prost(oneof = "backup_appliance_lock_info::LockSource", tags = "6, 7, 8")]
    pub lock_source: ::core::option::Option<backup_appliance_lock_info::LockSource>,
}
/// Nested message and enum types in `BackupApplianceLockInfo`.
pub mod backup_appliance_lock_info {
    /// The information about this lock.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum LockSource {
        /// The job name on the backup/recovery appliance that created this lock.
        #[prost(string, tag = "6")]
        JobName(::prost::alloc::string::String),
        /// The image name that depends on this Backup.
        #[prost(string, tag = "7")]
        BackupImage(::prost::alloc::string::String),
        /// The SLA on the backup/recovery appliance that owns the lock.
        #[prost(int64, tag = "8")]
        SlaId(i64),
    }
}
/// BackupLock represents a single lock on a Backup resource.  An unexpired
/// lock on a Backup prevents the Backup from being deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupLock {
    /// Required. The time after which this lock is not considered valid and will
    /// no longer protect the Backup from deletion.
    #[prost(message, optional, tag = "1")]
    pub lock_until_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Metadata about the owner and reason for the lock.
    #[prost(oneof = "backup_lock::ClientLockInfo", tags = "3, 4")]
    pub client_lock_info: ::core::option::Option<backup_lock::ClientLockInfo>,
}
/// Nested message and enum types in `BackupLock`.
pub mod backup_lock {
    /// Metadata about the owner and reason for the lock.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ClientLockInfo {
        /// If the client is a backup and recovery appliance, this
        /// contains metadata about why the lock exists.
        #[prost(message, tag = "3")]
        BackupApplianceLockInfo(super::BackupApplianceLockInfo),
        /// Output only. Contains metadata about the lock exist for Google Cloud
        /// native backups.
        #[prost(message, tag = "4")]
        ServiceLockInfo(super::ServiceLockInfo),
    }
}
/// Message describing a Backup object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Backup {
    /// Output only. Identifier. Name of the backup to create. It must have the
    /// format`"projects/<project>/locations/<location>/backupVaults/<backupvault>/dataSources/{datasource}/backups/{backup}"`.
    /// `{backup}` cannot be changed after creation. It must be between 3-63
    /// characters long and must be unique within the datasource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The description of the Backup instance (2048 characters or
    /// less).
    #[prost(string, optional, tag = "2")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The time when the instance was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the instance was updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Resource labels to represent user provided metadata.
    /// No labels currently defined.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. The backup can not be deleted before this time.
    #[prost(message, optional, tag = "6")]
    pub enforced_retention_end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. When this backup is automatically expired.
    #[prost(message, optional, tag = "7")]
    pub expire_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The point in time when this backup was captured from the
    /// source.
    #[prost(message, optional, tag = "9")]
    pub consistency_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Server specified ETag to prevent updates from overwriting each
    /// other.
    #[prost(string, optional, tag = "11")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The Backup resource instance state.
    #[prost(enumeration = "backup::State", tag = "15")]
    pub state: i32,
    /// Output only. The list of BackupLocks taken by the service to prevent the
    /// deletion of the backup.
    #[prost(message, repeated, tag = "17")]
    pub service_locks: ::prost::alloc::vec::Vec<BackupLock>,
    /// Optional. The list of BackupLocks taken by the accessor Backup Appliance.
    #[prost(message, repeated, tag = "18")]
    pub backup_appliance_locks: ::prost::alloc::vec::Vec<BackupLock>,
    /// Output only. Type of the backup, unspecified, scheduled or ondemand.
    #[prost(enumeration = "backup::BackupType", tag = "20")]
    pub backup_type: i32,
    /// Output only. source resource size in bytes at the time of the backup.
    #[prost(int64, tag = "23")]
    pub resource_size_bytes: i64,
    /// Workload specific backup properties.
    #[prost(oneof = "backup::BackupProperties", tags = "19, 21")]
    pub backup_properties: ::core::option::Option<backup::BackupProperties>,
    /// Configuration Info has the resource format-specific configuration.
    #[prost(oneof = "backup::PlanInfo", tags = "22")]
    pub plan_info: ::core::option::Option<backup::PlanInfo>,
}
/// Nested message and enum types in `Backup`.
pub mod backup {
    /// GCPBackupPlanInfo captures the plan configuration details of Google Cloud
    /// resources at the time of backup.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GcpBackupPlanInfo {
        /// Resource name of backup plan by which workload is protected at the time
        /// of the backup.
        /// Format:
        /// projects/{project}/locations/{location}/backupPlans/{backupPlanId}
        #[prost(string, tag = "1")]
        pub backup_plan: ::prost::alloc::string::String,
        /// The rule id of the backup plan which triggered this backup in case of
        /// scheduled backup or used for
        #[prost(string, tag = "2")]
        pub backup_plan_rule_id: ::prost::alloc::string::String,
    }
    /// Holds the state of the backup resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State not set.
        Unspecified = 0,
        /// The backup is being created.
        Creating = 1,
        /// The backup has been created and is fully usable.
        Active = 2,
        /// The backup is being deleted.
        Deleting = 3,
        /// The backup is experiencing an issue and might be unusable.
        Error = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Deleting => "DELETING",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
    /// Type of the backup, scheduled or ondemand.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BackupType {
        /// Backup type is unspecified.
        Unspecified = 0,
        /// Scheduled backup.
        Scheduled = 1,
        /// On demand backup.
        OnDemand = 2,
    }
    impl BackupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BACKUP_TYPE_UNSPECIFIED",
                Self::Scheduled => "SCHEDULED",
                Self::OnDemand => "ON_DEMAND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BACKUP_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SCHEDULED" => Some(Self::Scheduled),
                "ON_DEMAND" => Some(Self::OnDemand),
                _ => None,
            }
        }
    }
    /// Workload specific backup properties.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum BackupProperties {
        /// Output only. Compute Engine specific backup properties.
        #[prost(message, tag = "19")]
        ComputeInstanceBackupProperties(super::ComputeInstanceBackupProperties),
        /// Output only. Backup Appliance specific backup properties.
        #[prost(message, tag = "21")]
        BackupApplianceBackupProperties(super::BackupApplianceBackupProperties),
    }
    /// Configuration Info has the resource format-specific configuration.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PlanInfo {
        /// Output only. Configuration for a Google Cloud resource.
        #[prost(message, tag = "22")]
        GcpBackupPlanInfo(GcpBackupPlanInfo),
    }
}
/// Message for creating a BackupVault.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBackupVaultRequest {
    /// Required. Value for parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. ID of the requesting object
    /// If auto-generating ID server-side, remove this field and
    /// backup_vault_id from the method_signature of Create RPC
    #[prost(string, tag = "2")]
    pub backup_vault_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub backup_vault: ::core::option::Option<BackupVault>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is 'false'.
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
}
/// Request message for listing backupvault stores.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupVaultsRequest {
    /// Required. The project and location for which to retrieve backupvault stores
    /// information, in the format 'projects/{project_id}/locations/{location}'. In
    /// Cloud Backup and DR, locations map to Google Cloud regions, for example
    /// **us-central1**.
    /// To retrieve backupvault stores for all locations, use "-" for the
    /// '{location}' value.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Reserved for future use to provide a BASIC & FULL view of Backup
    /// Vault.
    #[prost(enumeration = "BackupVaultView", tag = "6")]
    pub view: i32,
}
/// Response message for listing BackupVaults.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupVaultsResponse {
    /// The list of BackupVault instances in the project for the specified
    /// location.
    ///
    /// If the '{location}' value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return backup vaults in reachable locations and
    /// the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    #[prost(message, repeated, tag = "1")]
    pub backup_vaults: ::prost::alloc::vec::Vec<BackupVault>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request message for fetching usable BackupVaults.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchUsableBackupVaultsRequest {
    /// Required. The project and location for which to retrieve backupvault stores
    /// information, in the format 'projects/{project_id}/locations/{location}'. In
    /// Cloud Backup and DR, locations map to Google Cloud regions, for example
    /// **us-central1**.
    /// To retrieve backupvault stores for all locations, use "-" for the
    /// '{location}' value.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response message for fetching usable BackupVaults.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchUsableBackupVaultsResponse {
    /// The list of BackupVault instances in the project for the specified
    /// location.
    ///
    /// If the '{location}' value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return backup vaults in reachable locations and
    /// the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    #[prost(message, repeated, tag = "1")]
    pub backup_vaults: ::prost::alloc::vec::Vec<BackupVault>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request message for getting a BackupVault.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBackupVaultRequest {
    /// Required. Name of the backupvault store resource name, in the format
    /// 'projects/{project_id}/locations/{location}/backupVaults/{resource_name}'
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Reserved for future use to provide a BASIC & FULL view of Backup
    /// Vault
    #[prost(enumeration = "BackupVaultView", tag = "2")]
    pub view: i32,
}
/// Request message for updating a BackupVault.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBackupVaultRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// BackupVault resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then the request will fail.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated
    #[prost(message, optional, tag = "2")]
    pub backup_vault: ::core::option::Option<BackupVault>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is 'false'.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// Optional. If set to true, will not check plan duration against backup vault
    /// enforcement duration.
    #[prost(bool, tag = "5")]
    pub force: bool,
}
/// Message for deleting a BackupVault.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBackupVaultRequest {
    /// Required. Name of the resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional. If set to true, any data source from this backup vault will also
    /// be deleted.
    #[prost(bool, tag = "3")]
    pub force: bool,
    /// The current etag of the backup vault.
    /// If an etag is provided and does not match the current etag of the
    /// connection, deletion will be blocked.
    #[prost(string, tag = "4")]
    pub etag: ::prost::alloc::string::String,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is 'false'.
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
    /// Optional. If true and the BackupVault is not found, the request will
    /// succeed but no action will be taken.
    #[prost(bool, tag = "6")]
    pub allow_missing: bool,
    /// Optional. If set to true, backupvault deletion will proceed even if there
    /// are backup plans referencing the backupvault. The default is 'false'.
    #[prost(bool, tag = "7")]
    pub ignore_backup_plan_references: bool,
}
/// Request message for listing DataSources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataSourcesRequest {
    /// Required. The project and location for which to retrieve data
    /// sources information, in the format
    /// 'projects/{project_id}/locations/{location}'. In Cloud Backup and DR,
    /// locations map to Google Cloud regions, for example **us-central1**.
    /// To retrieve data sources for all locations, use "-" for the
    /// '{location}' value.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response message for listing DataSources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataSourcesResponse {
    /// The list of DataSource instances in the project for the specified
    /// location.
    ///
    /// If the '{location}' value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return data sources in reachable locations
    /// and the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    #[prost(message, repeated, tag = "1")]
    pub data_sources: ::prost::alloc::vec::Vec<DataSource>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request message for getting a DataSource instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataSourceRequest {
    /// Required. Name of the data source resource name, in the format
    /// 'projects/{project_id}/locations/{location}/backupVaults/{resource_name}/dataSource/{resource_name}'
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for updating a data source instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataSourceRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// DataSource resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then the request will fail.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated
    #[prost(message, optional, tag = "2")]
    pub data_source: ::core::option::Option<DataSource>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional. Enable upsert.
    #[prost(bool, tag = "4")]
    pub allow_missing: bool,
}
/// Request message for listing Backups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupsRequest {
    /// Required. The project and location for which to retrieve backup
    /// information, in the format
    /// 'projects/{project_id}/locations/{location}'. In Cloud Backup and DR,
    /// locations map to Google Cloud regions, for example **us-central1**.
    /// To retrieve data sources for all locations, use "-" for the
    /// '{location}' value.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Reserved for future use to provide a BASIC & FULL view of Backup
    /// resource.
    #[prost(enumeration = "BackupView", tag = "6")]
    pub view: i32,
}
/// Response message for listing Backups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupsResponse {
    /// The list of Backup instances in the project for the specified
    /// location.
    ///
    /// If the '{location}' value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return data sources in reachable locations
    /// and the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    #[prost(message, repeated, tag = "1")]
    pub backups: ::prost::alloc::vec::Vec<Backup>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request message for getting a Backup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBackupRequest {
    /// Required. Name of the data source resource name, in the format
    /// 'projects/{project_id}/locations/{location}/backupVaults/{backupVault}/dataSources/{datasource}/backups/{backup}'
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Reserved for future use to provide a BASIC & FULL view of Backup
    /// resource.
    #[prost(enumeration = "BackupView", tag = "2")]
    pub view: i32,
}
/// Request message for updating a Backup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBackupRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Backup resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then the request will fail.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated
    #[prost(message, optional, tag = "2")]
    pub backup: ::core::option::Option<Backup>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting a Backup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBackupRequest {
    /// Required. Name of the resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for restoring from a Backup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreBackupRequest {
    /// Required. The resource name of the Backup instance, in the format
    /// 'projects/*/locations/*/backupVaults/*/dataSources/*/backups/'.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    /// The target environment for the restore operation.
    #[prost(oneof = "restore_backup_request::TargetEnvironment", tags = "3")]
    pub target_environment: ::core::option::Option<
        restore_backup_request::TargetEnvironment,
    >,
    /// The property overrides for the instance being restored.
    #[prost(oneof = "restore_backup_request::InstanceProperties", tags = "4")]
    pub instance_properties: ::core::option::Option<
        restore_backup_request::InstanceProperties,
    >,
}
/// Nested message and enum types in `RestoreBackupRequest`.
pub mod restore_backup_request {
    /// The target environment for the restore operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TargetEnvironment {
        /// Compute Engine target environment to be used during restore.
        #[prost(message, tag = "3")]
        ComputeInstanceTargetEnvironment(super::ComputeInstanceTargetEnvironment),
    }
    /// The property overrides for the instance being restored.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum InstanceProperties {
        /// Compute Engine instance properties to be overridden during restore.
        #[prost(message, tag = "4")]
        ComputeInstanceRestoreProperties(super::ComputeInstanceRestoreProperties),
    }
}
/// Response message for restoring from a Backup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreBackupResponse {
    /// Details of the target resource created/modified as part of restore.
    #[prost(message, optional, tag = "1")]
    pub target_resource: ::core::option::Option<TargetResource>,
}
/// Details of the target resource created/modified as part of restore.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetResource {
    /// Minimum details to identify the restored resource.
    #[prost(oneof = "target_resource::TargetResourceInfo", tags = "1")]
    pub target_resource_info: ::core::option::Option<
        target_resource::TargetResourceInfo,
    >,
}
/// Nested message and enum types in `TargetResource`.
pub mod target_resource {
    /// Minimum details to identify the restored resource.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TargetResourceInfo {
        /// Details of the native Google Cloud resource created as part of restore.
        #[prost(message, tag = "1")]
        GcpResource(super::GcpResource),
    }
}
/// Minimum details to identify a Google Cloud resource
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcpResource {
    /// Name of the Google Cloud resource.
    #[prost(string, tag = "1")]
    pub gcp_resourcename: ::prost::alloc::string::String,
    /// Location of the resource: <region>/<zone>/"global"/"unspecified".
    #[prost(string, tag = "2")]
    pub location: ::prost::alloc::string::String,
    /// Type of the resource. Use the Unified Resource Type,
    /// eg. compute.googleapis.com/Instance.
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
}
/// Backup configuration state. Is the resource configured for backup?
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BackupConfigState {
    /// The possible states of backup configuration.
    /// Status not set.
    Unspecified = 0,
    /// The data source is actively protected (i.e. there is a
    /// BackupPlanAssociation or Appliance SLA pointing to it)
    Active = 1,
    /// The data source is no longer protected (but may have backups under it)
    Passive = 2,
}
impl BackupConfigState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BACKUP_CONFIG_STATE_UNSPECIFIED",
            Self::Active => "ACTIVE",
            Self::Passive => "PASSIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BACKUP_CONFIG_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "ACTIVE" => Some(Self::Active),
            "PASSIVE" => Some(Self::Passive),
            _ => None,
        }
    }
}
/// BackupView contains enum options for Partial and Full view.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BackupView {
    /// If the value is not set, the default 'FULL' view is used.
    Unspecified = 0,
    /// Includes basic data about the Backup, but not the full contents.
    Basic = 1,
    /// Includes all data about the Backup.
    /// This is the default value (for both ListBackups and GetBackup).
    Full = 2,
}
impl BackupView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BACKUP_VIEW_UNSPECIFIED",
            Self::Basic => "BACKUP_VIEW_BASIC",
            Self::Full => "BACKUP_VIEW_FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BACKUP_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "BACKUP_VIEW_BASIC" => Some(Self::Basic),
            "BACKUP_VIEW_FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
/// BackupVaultView contains enum options for Partial and Full view.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BackupVaultView {
    /// If the value is not set, the default 'FULL' view is used.
    Unspecified = 0,
    /// Includes basic data about the Backup Vault, but not the full contents.
    Basic = 1,
    /// Includes all data about the Backup Vault.
    /// This is the default value (for both ListBackupVaults and GetBackupVault).
    Full = 2,
}
impl BackupVaultView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BACKUP_VAULT_VIEW_UNSPECIFIED",
            Self::Basic => "BACKUP_VAULT_VIEW_BASIC",
            Self::Full => "BACKUP_VAULT_VIEW_FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BACKUP_VAULT_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "BACKUP_VAULT_VIEW_BASIC" => Some(Self::Basic),
            "BACKUP_VAULT_VIEW_FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
/// Network configuration for ManagementServer instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkConfig {
    /// Optional. The resource name of the Google Compute Engine VPC network to
    /// which the ManagementServer instance is connected.
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    /// Optional. The network connect mode of the ManagementServer instance. For
    /// this version, only PRIVATE_SERVICE_ACCESS is supported.
    #[prost(enumeration = "network_config::PeeringMode", tag = "2")]
    pub peering_mode: i32,
}
/// Nested message and enum types in `NetworkConfig`.
pub mod network_config {
    /// VPC peering modes supported by Cloud BackupDR.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PeeringMode {
        /// Peering mode not set.
        Unspecified = 0,
        /// Connect using Private Service Access to the Management Server. Private
        /// services access provides an IP address range for multiple Google Cloud
        /// services, including Cloud BackupDR.
        PrivateServiceAccess = 1,
    }
    impl PeeringMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PEERING_MODE_UNSPECIFIED",
                Self::PrivateServiceAccess => "PRIVATE_SERVICE_ACCESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PEERING_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "PRIVATE_SERVICE_ACCESS" => Some(Self::PrivateServiceAccess),
                _ => None,
            }
        }
    }
}
/// ManagementURI for the Management Server resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManagementUri {
    /// Output only. The ManagementServer AGM/RD WebUI URL.
    #[prost(string, tag = "1")]
    pub web_ui: ::prost::alloc::string::String,
    /// Output only. The ManagementServer AGM/RD API URL.
    #[prost(string, tag = "2")]
    pub api: ::prost::alloc::string::String,
}
/// ManagementURI depending on the Workforce Identity i.e. either 1p or 3p.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkforceIdentityBasedManagementUri {
    /// Output only. First party Management URI for Google Identities.
    #[prost(string, tag = "1")]
    pub first_party_management_uri: ::prost::alloc::string::String,
    /// Output only. Third party Management URI for External Identity Providers.
    #[prost(string, tag = "2")]
    pub third_party_management_uri: ::prost::alloc::string::String,
}
/// OAuth Client ID depending on the Workforce Identity i.e. either 1p or 3p,
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkforceIdentityBasedOAuth2ClientId {
    /// Output only. First party OAuth Client ID for Google Identities.
    #[prost(string, tag = "1")]
    pub first_party_oauth2_client_id: ::prost::alloc::string::String,
    /// Output only. Third party OAuth Client ID for External Identity Providers.
    #[prost(string, tag = "2")]
    pub third_party_oauth2_client_id: ::prost::alloc::string::String,
}
/// ManagementServer describes a single BackupDR ManagementServer instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManagementServer {
    /// Output only. Identifier. The resource name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The description of the ManagementServer instance (2048 characters
    /// or less).
    #[prost(string, tag = "9")]
    pub description: ::prost::alloc::string::String,
    /// Optional. Resource labels to represent user provided metadata.
    /// Labels currently defined:
    /// 1. migrate_from_go=<false|true>
    ///     If set to true, the MS is created in migration ready mode.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The time when the instance was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the instance was updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The type of the ManagementServer resource.
    #[prost(enumeration = "management_server::InstanceType", tag = "14")]
    pub r#type: i32,
    /// Output only. The hostname or ip address of the exposed AGM endpoints, used
    /// by clients to connect to AGM/RD graphical user interface and APIs.
    #[prost(message, optional, tag = "11")]
    pub management_uri: ::core::option::Option<ManagementUri>,
    /// Output only. The hostnames of the exposed AGM endpoints for both types of
    /// user i.e. 1p and 3p, used to connect AGM/RM UI.
    #[prost(message, optional, tag = "16")]
    pub workforce_identity_based_management_uri: ::core::option::Option<
        WorkforceIdentityBasedManagementUri,
    >,
    /// Output only. The ManagementServer state.
    #[prost(enumeration = "management_server::InstanceState", tag = "7")]
    pub state: i32,
    /// Optional. VPC networks to which the ManagementServer instance is connected.
    /// For this version, only a single network is supported. This field is
    /// optional if MS is created without PSA
    #[prost(message, repeated, tag = "8")]
    pub networks: ::prost::alloc::vec::Vec<NetworkConfig>,
    /// Optional. Server specified ETag for the ManagementServer resource to
    /// prevent simultaneous updates from overwiting each other.
    #[prost(string, tag = "13")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. The OAuth 2.0 client id is required to make API calls to the
    /// BackupDR instance API of this ManagementServer. This is the value that
    /// should be provided in the 'aud' field of the OIDC ID Token (see openid
    /// specification
    /// <https://openid.net/specs/openid-connect-core-1_0.html#IDToken>).
    #[prost(string, tag = "15")]
    pub oauth2_client_id: ::prost::alloc::string::String,
    /// Output only. The OAuth client IDs for both types of user i.e. 1p and 3p.
    #[prost(message, optional, tag = "17")]
    pub workforce_identity_based_oauth2_client_id: ::core::option::Option<
        WorkforceIdentityBasedOAuth2ClientId,
    >,
    /// Output only. The hostname or ip address of the exposed AGM endpoints, used
    /// by BAs to connect to BA proxy.
    #[prost(string, repeated, tag = "18")]
    pub ba_proxy_uri: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. Reserved for future use.
    #[prost(message, optional, tag = "19")]
    pub satisfies_pzs: ::core::option::Option<bool>,
    /// Output only. Reserved for future use.
    #[prost(bool, tag = "20")]
    pub satisfies_pzi: bool,
}
/// Nested message and enum types in `ManagementServer`.
pub mod management_server {
    /// Type of backup service resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InstanceType {
        /// Instance type is not mentioned.
        Unspecified = 0,
        /// Instance for backup and restore management (i.e., AGM).
        BackupRestore = 1,
    }
    impl InstanceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "INSTANCE_TYPE_UNSPECIFIED",
                Self::BackupRestore => "BACKUP_RESTORE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INSTANCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BACKUP_RESTORE" => Some(Self::BackupRestore),
                _ => None,
            }
        }
    }
    /// State of Management server instance.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InstanceState {
        /// State not set.
        Unspecified = 0,
        /// The instance is being created.
        Creating = 1,
        /// The instance has been created and is fully usable.
        Ready = 2,
        /// The instance configuration is being updated. Certain kinds of updates
        /// may cause the instance to become unusable while the update is in
        /// progress.
        Updating = 3,
        /// The instance is being deleted.
        Deleting = 4,
        /// The instance is being repaired and may be unstable.
        Repairing = 5,
        /// Maintenance is being performed on this instance.
        Maintenance = 6,
        /// The instance is experiencing an issue and might be unusable. You can get
        /// further details from the statusMessage field of Instance resource.
        Error = 7,
    }
    impl InstanceState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "INSTANCE_STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Ready => "READY",
                Self::Updating => "UPDATING",
                Self::Deleting => "DELETING",
                Self::Repairing => "REPAIRING",
                Self::Maintenance => "MAINTENANCE",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INSTANCE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "REPAIRING" => Some(Self::Repairing),
                "MAINTENANCE" => Some(Self::Maintenance),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
/// Request message for listing management servers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListManagementServersRequest {
    /// Required. The project and location for which to retrieve management servers
    /// information, in the format 'projects/{project_id}/locations/{location}'. In
    /// Cloud BackupDR, locations map to Google Cloud regions, for example
    /// **us-central1**. To retrieve management servers for all locations, use "-"
    /// for the
    /// '{location}' value.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results.
    #[prost(string, optional, tag = "4")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Hint for how to order the results.
    #[prost(string, optional, tag = "5")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
}
/// Response message for listing management servers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListManagementServersResponse {
    /// The list of ManagementServer instances in the project for the specified
    /// location.
    ///
    /// If the '{location}' value in the request is "-", the response contains a
    /// list of instances from all locations. In case any location is unreachable,
    /// the response will only return management servers in reachable locations and
    /// the 'unreachable' field will be populated with a list of unreachable
    /// locations.
    #[prost(message, repeated, tag = "1")]
    pub management_servers: ::prost::alloc::vec::Vec<ManagementServer>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request message for getting a management server instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetManagementServerRequest {
    /// Required. Name of the management server resource name, in the format
    /// 'projects/{project_id}/locations/{location}/managementServers/{resource_name}'
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for creating a management server instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateManagementServerRequest {
    /// Required. The management server project and location in the format
    /// 'projects/{project_id}/locations/{location}'. In Cloud Backup and DR
    /// locations map to Google Cloud regions, for example **us-central1**.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The name of the management server to create. The name must be
    /// unique for the specified project and location.
    #[prost(string, tag = "2")]
    pub management_server_id: ::prost::alloc::string::String,
    /// Required. A [management server
    /// resource][google.cloud.backupdr.v1.ManagementServer]
    #[prost(message, optional, tag = "3")]
    pub management_server: ::core::option::Option<ManagementServer>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for deleting a management server instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteManagementServerRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for initializing the service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitializeServiceRequest {
    /// Required. The resource name of the serviceConfig used to initialize the
    /// service. Format:
    /// `projects/{project_id}/locations/{location}/serviceConfig`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The resource type to which the default service config will be
    /// applied. Examples include, "compute.googleapis.com/Instance" and
    /// "storage.googleapis.com/Bucket".
    #[prost(string, tag = "2")]
    pub resource_type: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Response message for initializing the service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitializeServiceResponse {
    /// The resource name of the default `BackupVault` created.
    /// Format:
    /// `projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}`.
    #[prost(string, tag = "1")]
    pub backup_vault_name: ::prost::alloc::string::String,
    /// The resource name of the default `BackupPlan` created.
    /// Format:
    /// `projects/{project_id}/locations/{location}/backupPlans/{backup_plan_id}`.
    #[prost(string, tag = "2")]
    pub backup_plan_name: ::prost::alloc::string::String,
}
/// Represents the metadata of the long-running operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to 'Code.CANCELLED'.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
    /// Output only. AdditionalInfo contains additional Info related to backup plan
    /// association resource.
    #[prost(map = "string, string", tag = "8")]
    pub additional_info: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Generated client implementations.
pub mod backup_dr_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The BackupDR Service
    #[derive(Debug, Clone)]
    pub struct BackupDrClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BackupDrClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BackupDrClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BackupDrClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            BackupDrClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists ManagementServers in a given project and location.
        pub async fn list_management_servers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListManagementServersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListManagementServersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/ListManagementServers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "ListManagementServers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single ManagementServer.
        pub async fn get_management_server(
            &mut self,
            request: impl tonic::IntoRequest<super::GetManagementServerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ManagementServer>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/GetManagementServer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "GetManagementServer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new ManagementServer in a given project and location.
        pub async fn create_management_server(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateManagementServerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/CreateManagementServer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "CreateManagementServer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single ManagementServer.
        pub async fn delete_management_server(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteManagementServerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/DeleteManagementServer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "DeleteManagementServer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new BackupVault in a given project and location.
        pub async fn create_backup_vault(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBackupVaultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/CreateBackupVault",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "CreateBackupVault",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists BackupVaults in a given project and location.
        pub async fn list_backup_vaults(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBackupVaultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBackupVaultsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/ListBackupVaults",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "ListBackupVaults",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// FetchUsableBackupVaults lists usable BackupVaults in a given project and
        /// location. Usable BackupVault are the ones that user has
        /// backupdr.backupVaults.get permission.
        pub async fn fetch_usable_backup_vaults(
            &mut self,
            request: impl tonic::IntoRequest<super::FetchUsableBackupVaultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchUsableBackupVaultsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/FetchUsableBackupVaults",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "FetchUsableBackupVaults",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a BackupVault.
        pub async fn get_backup_vault(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBackupVaultRequest>,
        ) -> std::result::Result<tonic::Response<super::BackupVault>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/GetBackupVault",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "GetBackupVault",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the settings of a BackupVault.
        pub async fn update_backup_vault(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBackupVaultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/UpdateBackupVault",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "UpdateBackupVault",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a BackupVault.
        pub async fn delete_backup_vault(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBackupVaultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/DeleteBackupVault",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "DeleteBackupVault",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists DataSources in a given project and location.
        pub async fn list_data_sources(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataSourcesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataSourcesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/ListDataSources",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "ListDataSources",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a DataSource.
        pub async fn get_data_source(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataSourceRequest>,
        ) -> std::result::Result<tonic::Response<super::DataSource>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/GetDataSource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.backupdr.v1.BackupDR", "GetDataSource"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the settings of a DataSource.
        pub async fn update_data_source(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataSourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/UpdateDataSource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "UpdateDataSource",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Backups in a given project and location.
        pub async fn list_backups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBackupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBackupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/ListBackups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.backupdr.v1.BackupDR", "ListBackups"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a Backup.
        pub async fn get_backup(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBackupRequest>,
        ) -> std::result::Result<tonic::Response<super::Backup>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/GetBackup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.backupdr.v1.BackupDR", "GetBackup"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the settings of a Backup.
        pub async fn update_backup(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBackupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/UpdateBackup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.backupdr.v1.BackupDR", "UpdateBackup"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Backup.
        pub async fn delete_backup(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBackupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/DeleteBackup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.backupdr.v1.BackupDR", "DeleteBackup"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Restore from a Backup
        pub async fn restore_backup(
            &mut self,
            request: impl tonic::IntoRequest<super::RestoreBackupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/RestoreBackup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.backupdr.v1.BackupDR", "RestoreBackup"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a BackupPlan
        pub async fn create_backup_plan(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBackupPlanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/CreateBackupPlan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "CreateBackupPlan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single BackupPlan.
        pub async fn get_backup_plan(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBackupPlanRequest>,
        ) -> std::result::Result<tonic::Response<super::BackupPlan>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/GetBackupPlan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.backupdr.v1.BackupDR", "GetBackupPlan"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists BackupPlans in a given project and location.
        pub async fn list_backup_plans(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBackupPlansRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBackupPlansResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/ListBackupPlans",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "ListBackupPlans",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single BackupPlan.
        pub async fn delete_backup_plan(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBackupPlanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/DeleteBackupPlan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "DeleteBackupPlan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a BackupPlanAssociation
        pub async fn create_backup_plan_association(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBackupPlanAssociationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/CreateBackupPlanAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "CreateBackupPlanAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single BackupPlanAssociation.
        pub async fn get_backup_plan_association(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBackupPlanAssociationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BackupPlanAssociation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/GetBackupPlanAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "GetBackupPlanAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists BackupPlanAssociations in a given project and location.
        pub async fn list_backup_plan_associations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBackupPlanAssociationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBackupPlanAssociationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/ListBackupPlanAssociations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "ListBackupPlanAssociations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single BackupPlanAssociation.
        pub async fn delete_backup_plan_association(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBackupPlanAssociationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/DeleteBackupPlanAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "DeleteBackupPlanAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Triggers a new Backup.
        pub async fn trigger_backup(
            &mut self,
            request: impl tonic::IntoRequest<super::TriggerBackupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/TriggerBackup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.backupdr.v1.BackupDR", "TriggerBackup"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Initializes the service related config for a project.
        pub async fn initialize_service(
            &mut self,
            request: impl tonic::IntoRequest<super::InitializeServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.backupdr.v1.BackupDR/InitializeService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.backupdr.v1.BackupDR",
                        "InitializeService",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
