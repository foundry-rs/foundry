// This file is @generated by prost-build.
/// Attributes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerchantReviewAttributes {
    /// Required. Must be unique and stable across all requests. In other words, if
    /// a request today and another 90 days ago refer to the same merchant, they
    /// must have the same id.
    #[prost(string, optional, tag = "1")]
    pub merchant_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Human-readable display name for the merchant.
    #[prost(string, optional, tag = "2")]
    pub merchant_display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. URL to the merchant's main website. Do not use a redirect URL for
    /// this value. In other words, the value should point directly to the
    /// merchant's site.
    #[prost(string, optional, tag = "3")]
    pub merchant_link: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. URL to the landing page that hosts the reviews for this merchant.
    /// Do not use a redirect URL.
    #[prost(string, optional, tag = "4")]
    pub merchant_rating_link: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The minimum possible number for the rating. This should be the
    /// worst possible rating and should not be a value for no rating.
    #[prost(int64, optional, tag = "5")]
    pub min_rating: ::core::option::Option<i64>,
    /// Optional. The maximum possible number for the rating. The value of the max
    /// rating must be greater than the value of the min rating.
    #[prost(int64, optional, tag = "6")]
    pub max_rating: ::core::option::Option<i64>,
    /// Optional. The reviewer's overall rating of the merchant.
    #[prost(double, optional, tag = "7")]
    pub rating: ::core::option::Option<f64>,
    /// Optional. The title of the review.
    #[prost(string, optional, tag = "8")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. This should be any freeform text provided by the user and should
    /// not be truncated. If multiple responses to different questions are
    /// provided, all responses should be included, with the minimal context for
    /// the responses to make sense. Context should not be provided if questions
    /// were left unanswered.
    #[prost(string, optional, tag = "9")]
    pub content: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. A permanent, unique identifier for the author of the review in
    /// the publisher's system.
    #[prost(string, optional, tag = "10")]
    pub reviewer_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Display name of the review author.
    #[prost(string, optional, tag = "11")]
    pub reviewer_username: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Set to true if the reviewer should remain anonymous.
    #[prost(bool, optional, tag = "12")]
    pub is_anonymous: ::core::option::Option<bool>,
    /// Optional. The method used to collect the review.
    #[prost(
        enumeration = "merchant_review_attributes::CollectionMethod",
        optional,
        tag = "13"
    )]
    pub collection_method: ::core::option::Option<i32>,
    /// Required. The timestamp indicating when the review was written.
    #[prost(message, optional, tag = "14")]
    pub review_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. The language of the review defined by BCP-47 language code.
    #[prost(string, optional, tag = "15")]
    pub review_language: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The country where the reviewer made the order defined by ISO
    /// 3166-1 Alpha-2 Country Code.
    #[prost(string, optional, tag = "16")]
    pub review_country: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `MerchantReviewAttributes`.
pub mod merchant_review_attributes {
    /// The method used to collect the review.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CollectionMethod {
        /// Collection method unspecified.
        Unspecified = 0,
        /// The user was not responding to a specific solicitation when they
        /// submitted the review.
        MerchantUnsolicited = 1,
        /// The user submitted the review in response to a solicitation when the
        /// user placed an order.
        PointOfSale = 2,
        /// The user submitted the review in response to a solicitation after
        /// fulfillment of the user's order.
        AfterFulfillment = 3,
    }
    impl CollectionMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "COLLECTION_METHOD_UNSPECIFIED",
                Self::MerchantUnsolicited => "MERCHANT_UNSOLICITED",
                Self::PointOfSale => "POINT_OF_SALE",
                Self::AfterFulfillment => "AFTER_FULFILLMENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COLLECTION_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                "MERCHANT_UNSOLICITED" => Some(Self::MerchantUnsolicited),
                "POINT_OF_SALE" => Some(Self::PointOfSale),
                "AFTER_FULFILLMENT" => Some(Self::AfterFulfillment),
                _ => None,
            }
        }
    }
}
/// The status of a merchant review, data validation issues, that is, information
/// about a merchant review computed asynchronously.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerchantReviewStatus {
    /// Output only. The intended destinations for the merchant review.
    #[prost(message, repeated, tag = "3")]
    pub destination_statuses: ::prost::alloc::vec::Vec<
        merchant_review_status::MerchantReviewDestinationStatus,
    >,
    /// Output only. A list of all issues associated with the merchant review.
    #[prost(message, repeated, tag = "4")]
    pub item_level_issues: ::prost::alloc::vec::Vec<
        merchant_review_status::MerchantReviewItemLevelIssue,
    >,
    /// Output only. Date on which the item has been created, in [ISO
    /// 8601](<http://en.wikipedia.org/wiki/ISO_8601>) format.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Date on which the item has been last updated, in [ISO
    /// 8601](<http://en.wikipedia.org/wiki/ISO_8601>) format.
    #[prost(message, optional, tag = "6")]
    pub last_update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `MerchantReviewStatus`.
pub mod merchant_review_status {
    /// The destination status of the merchant review status.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MerchantReviewDestinationStatus {
        /// Output only. The name of the reporting context.
        #[prost(
            enumeration = "super::super::super::super::r#type::reporting_context::ReportingContextEnum",
            tag = "1"
        )]
        pub reporting_context: i32,
    }
    /// The ItemLevelIssue of the merchant review status.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MerchantReviewItemLevelIssue {
        /// Output only. The error code of the issue.
        #[prost(string, tag = "1")]
        pub code: ::prost::alloc::string::String,
        /// Output only. How this issue affects serving of the merchant review.
        #[prost(enumeration = "merchant_review_item_level_issue::Severity", tag = "2")]
        pub severity: i32,
        /// Output only. Whether the issue can be resolved by the merchant.
        #[prost(string, tag = "3")]
        pub resolution: ::prost::alloc::string::String,
        /// Output only. The attribute's name, if the issue is caused by a single
        /// attribute.
        #[prost(string, tag = "4")]
        pub attribute: ::prost::alloc::string::String,
        /// Output only. The reporting context the issue applies to.
        #[prost(
            enumeration = "super::super::super::super::r#type::reporting_context::ReportingContextEnum",
            tag = "5"
        )]
        pub reporting_context: i32,
        /// Output only. A short issue description in English.
        #[prost(string, tag = "6")]
        pub description: ::prost::alloc::string::String,
        /// Output only. A detailed issue description in English.
        #[prost(string, tag = "7")]
        pub detail: ::prost::alloc::string::String,
        /// Output only. The URL of a web page to help with resolving this issue.
        #[prost(string, tag = "8")]
        pub documentation: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `MerchantReviewItemLevelIssue`.
    pub mod merchant_review_item_level_issue {
        /// How the issue affects the serving of the merchant review.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Severity {
            /// Not specified.
            Unspecified = 0,
            /// This issue represents a warning and does not have a direct affect
            /// on the merchant review.
            NotImpacted = 1,
            /// Issue disapproves the merchant review.
            Disapproved = 2,
        }
        impl Severity {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SEVERITY_UNSPECIFIED",
                    Self::NotImpacted => "NOT_IMPACTED",
                    Self::Disapproved => "DISAPPROVED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
                    "NOT_IMPACTED" => Some(Self::NotImpacted),
                    "DISAPPROVED" => Some(Self::Disapproved),
                    _ => None,
                }
            }
        }
    }
}
/// Request message for the `GetMerchantReview` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMerchantReviewRequest {
    /// Required. The ID of the merchant review.
    /// Format: accounts/{account}/merchantReviews/{merchantReview}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `DeleteMerchantReview` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteMerchantReviewRequest {
    /// Required. The ID of the merchant review.
    /// Format: accounts/{account}/merchantReviews/{merchantReview}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `ListMerchantsReview` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMerchantReviewsRequest {
    /// Required. The account to list merchant reviews for.
    /// Format: accounts/{account}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of merchant reviews to return. The service can
    /// return fewer than this value. The maximum value is 1000; values above 1000
    /// are coerced to 1000. If unspecified, the maximum number of reviews is
    /// returned.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListMerchantReviews`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListMerchantReviews`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Request message for the `InsertMerchantReview` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertMerchantReviewRequest {
    /// Required. The account where the merchant review will be inserted.
    /// Format: accounts/{account}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The merchant review to insert.
    #[prost(message, optional, tag = "2")]
    pub merchant_review: ::core::option::Option<MerchantReview>,
    /// Required. The data source of the
    /// [merchantreview](<https://support.google.com/merchants/answer/7045996?sjid=5253581244217581976-EU>)
    /// Format:
    /// `accounts/{account}/dataSources/{datasource}`.
    #[prost(string, tag = "3")]
    pub data_source: ::prost::alloc::string::String,
}
/// Response message for the `ListMerchantsReview` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMerchantReviewsResponse {
    /// The merchant review.
    #[prost(message, repeated, tag = "1")]
    pub merchant_reviews: ::prost::alloc::vec::Vec<MerchantReview>,
    /// The token to retrieve the next page of results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// A review for a merchant. For more information, see
/// [Introduction to Merchant Review
/// Feeds](<https://developers.google.com/merchant-review-feeds>)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerchantReview {
    /// Identifier. The name of the merchant review.
    /// Format:
    /// `"{merchantreview.name=accounts/{account}/merchantReviews/{merchantReview}}"`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The user provided merchant review ID to uniquely identify the
    /// merchant review.
    #[prost(string, tag = "2")]
    pub merchant_review_id: ::prost::alloc::string::String,
    /// Optional. A list of merchant review attributes.
    #[prost(message, optional, tag = "3")]
    pub attributes: ::core::option::Option<MerchantReviewAttributes>,
    /// Required. A list of custom (merchant-provided) attributes. It can also be
    /// used for submitting any attribute of the data specification in its generic
    /// form (for example,
    /// `{ "name": "size type", "value": "regular" }`).
    /// This is useful for submitting attributes not explicitly exposed by the
    /// API, such as experimental attributes.
    /// Maximum allowed number of characters for each
    /// custom attribute is 10240 (represents sum of characters for name and
    /// value). Maximum 2500 custom attributes can be set per product, with total
    /// size of 102.4kB. Underscores in custom attribute names are replaced by
    /// spaces upon insertion.
    #[prost(message, repeated, tag = "4")]
    pub custom_attributes: ::prost::alloc::vec::Vec<
        super::super::super::r#type::CustomAttribute,
    >,
    /// Output only. The primary data source of the merchant review.
    #[prost(string, tag = "5")]
    pub data_source: ::prost::alloc::string::String,
    /// Output only. The status of a merchant review, data validation issues, that
    /// is, information about a merchant review computed asynchronously.
    #[prost(message, optional, tag = "6")]
    pub merchant_review_status: ::core::option::Option<MerchantReviewStatus>,
}
/// Generated client implementations.
pub mod merchant_reviews_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to manage merchant reviews.
    #[derive(Debug, Clone)]
    pub struct MerchantReviewsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MerchantReviewsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MerchantReviewsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MerchantReviewsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MerchantReviewsServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Gets a merchant review.
        pub async fn get_merchant_review(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMerchantReviewRequest>,
        ) -> std::result::Result<tonic::Response<super::MerchantReview>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.reviews.v1beta.MerchantReviewsService/GetMerchantReview",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.reviews.v1beta.MerchantReviewsService",
                        "GetMerchantReview",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists merchant reviews.
        pub async fn list_merchant_reviews(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMerchantReviewsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMerchantReviewsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.reviews.v1beta.MerchantReviewsService/ListMerchantReviews",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.reviews.v1beta.MerchantReviewsService",
                        "ListMerchantReviews",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Inserts a review for your Merchant Center account. If the review
        /// already exists, then the review is replaced with the new instance.
        pub async fn insert_merchant_review(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertMerchantReviewRequest>,
        ) -> std::result::Result<tonic::Response<super::MerchantReview>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.reviews.v1beta.MerchantReviewsService/InsertMerchantReview",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.reviews.v1beta.MerchantReviewsService",
                        "InsertMerchantReview",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes merchant review.
        pub async fn delete_merchant_review(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteMerchantReviewRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.reviews.v1beta.MerchantReviewsService/DeleteMerchantReview",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.reviews.v1beta.MerchantReviewsService",
                        "DeleteMerchantReview",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Attributes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductReviewAttributes {
    /// Optional. The name of the aggregator of the product reviews.
    ///
    /// A publisher may use a reviews aggregator to manage reviews and provide
    /// the feeds. This element indicates the use of an aggregator and contains
    /// information about the aggregator.
    #[prost(string, optional, tag = "1")]
    pub aggregator_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The name of the subclient of the product reviews.
    ///
    /// The subclient is an identifier of the product review source.
    /// It should be equivalent to the directory provided in the file data source
    /// path.
    #[prost(string, optional, tag = "2")]
    pub subclient_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The name of the publisher of the product reviews.
    ///
    /// The information about the publisher, which may be a retailer,
    /// manufacturer, reviews service company, or any entity that publishes
    /// product reviews.
    #[prost(string, optional, tag = "3")]
    pub publisher_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. A link to the company favicon of the publisher. The image
    /// dimensions should be favicon size: 16x16 pixels. The image format should be
    /// GIF, JPG or PNG.
    #[prost(string, optional, tag = "4")]
    pub publisher_favicon: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The author of the product review.
    ///
    /// A permanent, unique identifier for the author of the review in the
    /// publisher's system.
    #[prost(string, optional, tag = "5")]
    pub reviewer_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Set to true if the reviewer should remain anonymous.
    #[prost(bool, optional, tag = "6")]
    pub reviewer_is_anonymous: ::core::option::Option<bool>,
    /// Optional. The name of the reviewer of the product review.
    #[prost(string, optional, tag = "7")]
    pub reviewer_username: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The language of the review defined by BCP-47 language code.
    #[prost(string, optional, tag = "8")]
    pub review_language: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The country of the review defined by ISO 3166-1 Alpha-2 Country
    /// Code.
    #[prost(string, optional, tag = "9")]
    pub review_country: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. The timestamp indicating when the review was written.
    #[prost(message, optional, tag = "10")]
    pub review_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The title of the review.
    #[prost(string, optional, tag = "11")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. The content of the review.
    #[prost(string, optional, tag = "12")]
    pub content: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Contains the advantages based on the opinion of the reviewer.
    /// Omit boilerplate text like "pro:" unless it was written by the reviewer.
    #[prost(string, repeated, tag = "13")]
    pub pros: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Contains the disadvantages based on the opinion of the reviewer.
    /// Omit boilerplate text like "con:" unless it was written by the reviewer.
    #[prost(string, repeated, tag = "14")]
    pub cons: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The URI of the review landing page.
    #[prost(message, optional, tag = "15")]
    pub review_link: ::core::option::Option<product_review_attributes::ReviewLink>,
    /// Optional. A URI to an image of the reviewed product created by the review
    /// author. The URI does not have to end with an image file extension.
    #[prost(string, repeated, tag = "16")]
    pub reviewer_image_links: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Contains the ratings associated with the review.
    /// The minimum possible number for the rating. This should be the worst
    /// possible rating and should not be a value for no rating.
    #[prost(int64, optional, tag = "17")]
    pub min_rating: ::core::option::Option<i64>,
    /// Optional. The maximum possible number for the rating. The value of the max
    /// rating must be greater than the value of the min attribute.
    #[prost(int64, optional, tag = "18")]
    pub max_rating: ::core::option::Option<i64>,
    /// Optional. The reviewer's overall rating of the product.
    #[prost(double, optional, tag = "19")]
    pub rating: ::core::option::Option<f64>,
    /// Optional. Descriptive name of a product.
    #[prost(string, repeated, tag = "20")]
    pub product_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The URI of the product. This URI can have the same value as the
    /// `review_link` element, if the review URI and the product URI are the
    /// same.
    #[prost(string, repeated, tag = "21")]
    pub product_links: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Contains ASINs (Amazon Standard Identification Numbers)
    /// associated with a product.
    #[prost(string, repeated, tag = "22")]
    pub asins: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Contains GTINs (global trade item numbers) associated with a
    /// product. Sub-types of GTINs (e.g. UPC, EAN, ISBN, JAN) are supported.
    #[prost(string, repeated, tag = "23")]
    pub gtins: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Contains MPNs (manufacturer part numbers) associated with a
    /// product.
    #[prost(string, repeated, tag = "24")]
    pub mpns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Contains SKUs (stock keeping units) associated with a product.
    /// Often this matches the product Offer Id in the product feed.
    #[prost(string, repeated, tag = "25")]
    pub skus: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Contains brand names associated with a product.
    #[prost(string, repeated, tag = "26")]
    pub brands: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Indicates whether the review is marked as spam in the publisher's
    /// system.
    #[prost(bool, optional, tag = "27")]
    pub is_spam: ::core::option::Option<bool>,
    /// Optional. The method used to collect the review.
    #[prost(enumeration = "product_review_attributes::CollectionMethod", tag = "28")]
    pub collection_method: i32,
    /// Optional. A permanent, unique identifier for the transaction associated
    /// with the review in the publisher's system. This ID can be used to indicate
    /// that multiple reviews are associated with the same transaction.
    #[prost(string, tag = "29")]
    pub transaction_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ProductReviewAttributes`.
pub mod product_review_attributes {
    /// The URI of the review landing page.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReviewLink {
        /// Optional. Type of the review URI.
        #[prost(enumeration = "review_link::Type", tag = "1")]
        pub r#type: i32,
        /// Optional. The URI of the review landing page.
        /// For example: `<http://www.example.com/review_5.html`.>
        #[prost(string, tag = "2")]
        pub link: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `ReviewLink`.
    pub mod review_link {
        /// Type of the review URI.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            /// Type unspecified.
            Unspecified = 0,
            /// The review page contains only this single review.
            Singleton = 1,
            /// The review page contains a group of reviews including this review.
            Group = 2,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TYPE_UNSPECIFIED",
                    Self::Singleton => "SINGLETON",
                    Self::Group => "GROUP",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SINGLETON" => Some(Self::Singleton),
                    "GROUP" => Some(Self::Group),
                    _ => None,
                }
            }
        }
    }
    /// The method used to collect the review.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CollectionMethod {
        /// Collection method unspecified.
        Unspecified = 0,
        /// The user was not responding to a specific solicitation when they
        /// submitted the review.
        Unsolicited = 1,
        /// The user submitted the review in response to a solicitation after
        /// fulfillment of the user's order.
        PostFulfillment = 2,
    }
    impl CollectionMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "COLLECTION_METHOD_UNSPECIFIED",
                Self::Unsolicited => "UNSOLICITED",
                Self::PostFulfillment => "POST_FULFILLMENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COLLECTION_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                "UNSOLICITED" => Some(Self::Unsolicited),
                "POST_FULFILLMENT" => Some(Self::PostFulfillment),
                _ => None,
            }
        }
    }
}
/// Product review status.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductReviewStatus {
    /// Output only. The intended destinations for the product review.
    #[prost(message, repeated, tag = "3")]
    pub destination_statuses: ::prost::alloc::vec::Vec<
        product_review_status::ProductReviewDestinationStatus,
    >,
    /// Output only. A list of all issues associated with the product review.
    #[prost(message, repeated, tag = "4")]
    pub item_level_issues: ::prost::alloc::vec::Vec<
        product_review_status::ProductReviewItemLevelIssue,
    >,
    /// Output only. Date on which the item has been created, in [ISO
    /// 8601](<http://en.wikipedia.org/wiki/ISO_8601>) format.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Date on which the item has been last updated, in [ISO
    /// 8601](<http://en.wikipedia.org/wiki/ISO_8601>) format.
    #[prost(message, optional, tag = "6")]
    pub last_update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `ProductReviewStatus`.
pub mod product_review_status {
    /// The destination status of the product review status.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ProductReviewDestinationStatus {
        /// Output only. The name of the reporting context.
        #[prost(
            enumeration = "super::super::super::super::r#type::reporting_context::ReportingContextEnum",
            tag = "1"
        )]
        pub reporting_context: i32,
    }
    /// The ItemLevelIssue of the product review status.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProductReviewItemLevelIssue {
        /// Output only. The error code of the issue.
        #[prost(string, tag = "1")]
        pub code: ::prost::alloc::string::String,
        /// Output only. How this issue affects serving of the product review.
        #[prost(enumeration = "product_review_item_level_issue::Severity", tag = "2")]
        pub severity: i32,
        /// Output only. Whether the issue can be resolved by the merchant.
        #[prost(string, tag = "3")]
        pub resolution: ::prost::alloc::string::String,
        /// Output only. The attribute's name, if the issue is caused by a single
        /// attribute.
        #[prost(string, tag = "4")]
        pub attribute: ::prost::alloc::string::String,
        /// Output only. The reporting context the issue applies to.
        #[prost(
            enumeration = "super::super::super::super::r#type::reporting_context::ReportingContextEnum",
            tag = "5"
        )]
        pub reporting_context: i32,
        /// Output only. A short issue description in English.
        #[prost(string, tag = "6")]
        pub description: ::prost::alloc::string::String,
        /// Output only. A detailed issue description in English.
        #[prost(string, tag = "7")]
        pub detail: ::prost::alloc::string::String,
        /// Output only. The URL of a web page to help with resolving this issue.
        #[prost(string, tag = "8")]
        pub documentation: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `ProductReviewItemLevelIssue`.
    pub mod product_review_item_level_issue {
        /// How the issue affects the serving of the product review.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Severity {
            /// Not specified.
            Unspecified = 0,
            /// This issue represents a warning and does not have a direct affect
            /// on the product review.
            NotImpacted = 1,
            /// Issue disapproves the product review.
            Disapproved = 2,
        }
        impl Severity {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SEVERITY_UNSPECIFIED",
                    Self::NotImpacted => "NOT_IMPACTED",
                    Self::Disapproved => "DISAPPROVED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
                    "NOT_IMPACTED" => Some(Self::NotImpacted),
                    "DISAPPROVED" => Some(Self::Disapproved),
                    _ => None,
                }
            }
        }
    }
}
/// Request message for the GetProductReview method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProductReviewRequest {
    /// Required. The ID of the merchant review.
    /// Format: accounts/{account}/productReviews/{productReview}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the `DeleteProductReview` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteProductReviewRequest {
    /// Required. The ID of the Product review.
    /// Format: accounts/{account}/productReviews/{productReview}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for the ListProductReviews method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProductReviewsRequest {
    /// Required. The account to list product reviews for.
    /// Format: accounts/{account}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of products to return. The service may return
    /// fewer than this value.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListProductReviews` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListProductReviews`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Request message for the `InsertProductReview` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertProductReviewRequest {
    /// Required. The account where the product review will be inserted.
    /// Format: accounts/{account}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The product review to insert.
    #[prost(message, optional, tag = "2")]
    pub product_review: ::core::option::Option<ProductReview>,
    /// Required. Format:
    /// `accounts/{account}/dataSources/{datasource}`.
    #[prost(string, tag = "3")]
    pub data_source: ::prost::alloc::string::String,
}
/// response message for the ListProductReviews method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProductReviewsResponse {
    /// The product review.
    #[prost(message, repeated, tag = "1")]
    pub product_reviews: ::prost::alloc::vec::Vec<ProductReview>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// A review for a product. For more information, see
/// [Introduction to Product Review
/// Feeds](<https://developers.google.com/product-review-feeds>)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductReview {
    /// Identifier. The name of the product review.
    /// Format:
    /// `"{productreview.name=accounts/{account}/productReviews/{productReview}}"`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The permanent, unique identifier for the product review in the
    /// publisherâ€™s system.
    #[prost(string, tag = "2")]
    pub product_review_id: ::prost::alloc::string::String,
    /// Optional. A list of product review attributes.
    #[prost(message, optional, tag = "3")]
    pub attributes: ::core::option::Option<ProductReviewAttributes>,
    /// Optional. A list of custom (merchant-provided) attributes.
    #[prost(message, repeated, tag = "4")]
    pub custom_attributes: ::prost::alloc::vec::Vec<
        super::super::super::r#type::CustomAttribute,
    >,
    /// Output only. The primary data source of the product review.
    #[prost(string, tag = "5")]
    pub data_source: ::prost::alloc::string::String,
    /// Output only. The status of a product review, data validation issues, that
    /// is, information about a product review computed asynchronously.
    #[prost(message, optional, tag = "6")]
    pub product_review_status: ::core::option::Option<ProductReviewStatus>,
}
/// Generated client implementations.
pub mod product_reviews_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to manage product reviews.
    #[derive(Debug, Clone)]
    pub struct ProductReviewsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ProductReviewsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ProductReviewsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ProductReviewsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ProductReviewsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Gets a product review.
        pub async fn get_product_review(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProductReviewRequest>,
        ) -> std::result::Result<tonic::Response<super::ProductReview>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.reviews.v1beta.ProductReviewsService/GetProductReview",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.reviews.v1beta.ProductReviewsService",
                        "GetProductReview",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists product reviews.
        pub async fn list_product_reviews(
            &mut self,
            request: impl tonic::IntoRequest<super::ListProductReviewsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListProductReviewsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.reviews.v1beta.ProductReviewsService/ListProductReviews",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.reviews.v1beta.ProductReviewsService",
                        "ListProductReviews",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Inserts a product review.
        pub async fn insert_product_review(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertProductReviewRequest>,
        ) -> std::result::Result<tonic::Response<super::ProductReview>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.reviews.v1beta.ProductReviewsService/InsertProductReview",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.reviews.v1beta.ProductReviewsService",
                        "InsertProductReview",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a product review.
        pub async fn delete_product_review(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteProductReviewRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.reviews.v1beta.ProductReviewsService/DeleteProductReview",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.reviews.v1beta.ProductReviewsService",
                        "DeleteProductReview",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
