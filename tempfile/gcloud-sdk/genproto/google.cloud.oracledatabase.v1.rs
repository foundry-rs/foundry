// This file is @generated by prost-build.
/// The CustomerContact reference as defined by Oracle.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/CustomerContact>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerContact {
    /// Required. The email address used by Oracle to send notifications regarding
    /// databases and infrastructure.
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
}
/// Details of the Autonomous Database resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabase/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutonomousDatabase {
    /// Identifier. The name of the Autonomous Database resource in the following
    /// format:
    /// projects/{project}/locations/{region}/autonomousDatabases/{autonomous_database}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The name of the Autonomous Database. The database name must be
    /// unique in the project. The name must begin with a letter and can contain a
    /// maximum of 30 alphanumeric characters.
    #[prost(string, tag = "2")]
    pub database: ::prost::alloc::string::String,
    /// Optional. The display name for the Autonomous Database. The name does not
    /// have to be unique within your project.
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The ID of the subscription entitlement associated with the
    /// Autonomous Database.
    #[prost(string, tag = "5")]
    pub entitlement_id: ::prost::alloc::string::String,
    /// Optional. The password for the default ADMIN user.
    #[prost(string, tag = "6")]
    pub admin_password: ::prost::alloc::string::String,
    /// Optional. The properties of the Autonomous Database.
    #[prost(message, optional, tag = "7")]
    pub properties: ::core::option::Option<AutonomousDatabaseProperties>,
    /// Optional. The labels or tags associated with the Autonomous Database.
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. The name of the VPC network used by the Autonomous Database in
    /// the following format: projects/{project}/global/networks/{network}
    #[prost(string, tag = "9")]
    pub network: ::prost::alloc::string::String,
    /// Required. The subnet CIDR range for the Autonmous Database.
    #[prost(string, tag = "10")]
    pub cidr: ::prost::alloc::string::String,
    /// Output only. The date and time that the Autonomous Database was created.
    #[prost(message, optional, tag = "13")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// The properties of an Autonomous Database.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutonomousDatabaseProperties {
    /// Output only. OCID of the Autonomous Database.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    #[prost(string, tag = "1")]
    pub ocid: ::prost::alloc::string::String,
    /// Optional. The number of compute servers for the Autonomous Database.
    #[prost(float, tag = "2")]
    pub compute_count: f32,
    /// Optional. The number of CPU cores to be made available to the database.
    #[prost(int32, tag = "3")]
    pub cpu_core_count: i32,
    /// Optional. The size of the data stored in the database, in terabytes.
    #[prost(int32, tag = "4")]
    pub data_storage_size_tb: i32,
    /// Optional. The size of the data stored in the database, in gigabytes.
    #[prost(int32, tag = "63")]
    pub data_storage_size_gb: i32,
    /// Required. The workload type of the Autonomous Database.
    #[prost(enumeration = "DbWorkload", tag = "5")]
    pub db_workload: i32,
    /// Optional. The edition of the Autonomous Databases.
    #[prost(enumeration = "autonomous_database_properties::DatabaseEdition", tag = "6")]
    pub db_edition: i32,
    /// Optional. The character set for the Autonomous Database. The default is
    /// AL32UTF8.
    #[prost(string, tag = "8")]
    pub character_set: ::prost::alloc::string::String,
    /// Optional. The national character set for the Autonomous Database. The
    /// default is AL16UTF16.
    #[prost(string, tag = "9")]
    pub n_character_set: ::prost::alloc::string::String,
    /// Optional. The private endpoint IP address for the Autonomous Database.
    #[prost(string, tag = "10")]
    pub private_endpoint_ip: ::prost::alloc::string::String,
    /// Optional. The private endpoint label for the Autonomous Database.
    #[prost(string, tag = "11")]
    pub private_endpoint_label: ::prost::alloc::string::String,
    /// Optional. The Oracle Database version for the Autonomous Database.
    #[prost(string, tag = "12")]
    pub db_version: ::prost::alloc::string::String,
    /// Optional. This field indicates if auto scaling is enabled for the
    /// Autonomous Database CPU core count.
    #[prost(bool, tag = "14")]
    pub is_auto_scaling_enabled: bool,
    /// Optional. This field indicates if auto scaling is enabled for the
    /// Autonomous Database storage.
    #[prost(bool, tag = "15")]
    pub is_storage_auto_scaling_enabled: bool,
    /// Required. The license type used for the Autonomous Database.
    #[prost(enumeration = "autonomous_database_properties::LicenseType", tag = "16")]
    pub license_type: i32,
    /// Optional. The list of customer contacts.
    #[prost(message, repeated, tag = "17")]
    pub customer_contacts: ::prost::alloc::vec::Vec<CustomerContact>,
    /// Optional. The ID of the Oracle Cloud Infrastructure vault secret.
    #[prost(string, tag = "18")]
    pub secret_id: ::prost::alloc::string::String,
    /// Optional. The ID of the Oracle Cloud Infrastructure vault.
    #[prost(string, tag = "19")]
    pub vault_id: ::prost::alloc::string::String,
    /// Optional. The maintenance schedule of the Autonomous Database.
    #[prost(
        enumeration = "autonomous_database_properties::MaintenanceScheduleType",
        tag = "20"
    )]
    pub maintenance_schedule_type: i32,
    /// Optional. This field specifies if the Autonomous Database requires mTLS
    /// connections.
    #[prost(bool, tag = "34")]
    pub mtls_connection_required: bool,
    /// Optional. The retention period for the Autonomous Database. This field is
    /// specified in days, can range from 1 day to 60 days, and has a default value
    /// of 60 days.
    #[prost(int32, tag = "57")]
    pub backup_retention_period_days: i32,
    /// Output only. The amount of storage currently being used for user and system
    /// data, in terabytes.
    #[prost(double, tag = "21")]
    pub actual_used_data_storage_size_tb: f64,
    /// Output only. The amount of storage currently allocated for the database
    /// tables and billed for, rounded up in terabytes.
    #[prost(double, tag = "22")]
    pub allocated_storage_size_tb: f64,
    /// Output only. The details for the Oracle APEX Application Development.
    #[prost(message, optional, tag = "23")]
    pub apex_details: ::core::option::Option<AutonomousDatabaseApex>,
    /// Output only. This field indicates the status of Data Guard and Access
    /// control for the Autonomous Database. The field's value is null if Data
    /// Guard is disabled or Access Control is disabled. The field's value is TRUE
    /// if both Data Guard and Access Control are enabled, and the Autonomous
    /// Database is using primary IP access control list (ACL) for standby. The
    /// field's value is FALSE if both Data Guard and Access Control are enabled,
    /// and the Autonomous Database is using a different IP access control list
    /// (ACL) for standby compared to primary.
    #[prost(bool, optional, tag = "24")]
    pub are_primary_allowlisted_ips_used: ::core::option::Option<bool>,
    /// Output only. The details of the current lifestyle state of the Autonomous
    /// Database.
    #[prost(string, tag = "25")]
    pub lifecycle_details: ::prost::alloc::string::String,
    /// Output only. The current lifecycle state of the Autonomous Database.
    #[prost(enumeration = "State", tag = "26")]
    pub state: i32,
    /// Output only. The Autonomous Container Database OCID.
    #[prost(string, tag = "27")]
    pub autonomous_container_database_id: ::prost::alloc::string::String,
    /// Output only. The list of available Oracle Database upgrade versions for an
    /// Autonomous Database.
    #[prost(string, repeated, tag = "28")]
    pub available_upgrade_versions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Output only. The connection strings used to connect to an Autonomous
    /// Database.
    #[prost(message, optional, tag = "29")]
    pub connection_strings: ::core::option::Option<AutonomousDatabaseConnectionStrings>,
    /// Output only. The Oracle Connection URLs for an Autonomous Database.
    #[prost(message, optional, tag = "30")]
    pub connection_urls: ::core::option::Option<AutonomousDatabaseConnectionUrls>,
    /// Output only. This field indicates the number of seconds of data loss during
    /// a Data Guard failover.
    #[prost(message, optional, tag = "31")]
    pub failed_data_recovery_duration: ::core::option::Option<::prost_types::Duration>,
    /// Output only. The memory assigned to in-memory tables in an Autonomous
    /// Database.
    #[prost(int32, tag = "32")]
    pub memory_table_gbs: i32,
    /// Output only. This field indicates whether the Autonomous Database has local
    /// (in-region) Data Guard enabled.
    #[prost(bool, tag = "33")]
    pub is_local_data_guard_enabled: bool,
    /// Output only. This field indicates the maximum data loss limit for an
    /// Autonomous Database, in seconds.
    #[prost(int32, tag = "35")]
    pub local_adg_auto_failover_max_data_loss_limit: i32,
    /// Output only. The details of the Autonomous Data Guard standby database.
    #[prost(message, optional, tag = "36")]
    pub local_standby_db: ::core::option::Option<AutonomousDatabaseStandbySummary>,
    /// Output only. The amount of memory enabled per ECPU, in gigabytes.
    #[prost(int32, tag = "37")]
    pub memory_per_oracle_compute_unit_gbs: i32,
    /// Output only. This field indicates the local disaster recovery (DR) type of
    /// an Autonomous Database.
    #[prost(
        enumeration = "autonomous_database_properties::LocalDisasterRecoveryType",
        tag = "38"
    )]
    pub local_disaster_recovery_type: i32,
    /// Output only. The current state of the Data Safe registration for the
    /// Autonomous Database.
    #[prost(enumeration = "autonomous_database_properties::DataSafeState", tag = "39")]
    pub data_safe_state: i32,
    /// Output only. The current state of database management for the Autonomous
    /// Database.
    #[prost(
        enumeration = "autonomous_database_properties::DatabaseManagementState",
        tag = "40"
    )]
    pub database_management_state: i32,
    /// Output only. This field indicates the current mode of the Autonomous
    /// Database.
    #[prost(enumeration = "autonomous_database_properties::OpenMode", tag = "41")]
    pub open_mode: i32,
    /// Output only. This field indicates the state of Operations Insights for the
    /// Autonomous Database.
    #[prost(enumeration = "OperationsInsightsState", tag = "42")]
    pub operations_insights_state: i32,
    /// Output only. The list of OCIDs of standby databases located in Autonomous
    /// Data Guard remote regions that are associated with the source database.
    #[prost(string, repeated, tag = "43")]
    pub peer_db_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The permission level of the Autonomous Database.
    #[prost(enumeration = "autonomous_database_properties::PermissionLevel", tag = "44")]
    pub permission_level: i32,
    /// Output only. The private endpoint for the Autonomous Database.
    #[prost(string, tag = "45")]
    pub private_endpoint: ::prost::alloc::string::String,
    /// Output only. The refresh mode of the cloned Autonomous Database.
    #[prost(enumeration = "autonomous_database_properties::RefreshableMode", tag = "46")]
    pub refreshable_mode: i32,
    /// Output only. The refresh State of the clone.
    #[prost(
        enumeration = "autonomous_database_properties::RefreshableState",
        tag = "47"
    )]
    pub refreshable_state: i32,
    /// Output only. The Data Guard role of the Autonomous Database.
    #[prost(enumeration = "autonomous_database_properties::Role", tag = "48")]
    pub role: i32,
    /// Output only. The list and details of the scheduled operations of the
    /// Autonomous Database.
    #[prost(message, repeated, tag = "64")]
    pub scheduled_operation_details: ::prost::alloc::vec::Vec<ScheduledOperationDetails>,
    /// Output only. The SQL Web Developer URL for the Autonomous Database.
    #[prost(string, tag = "50")]
    pub sql_web_developer_url: ::prost::alloc::string::String,
    /// Output only. The list of available regions that can be used to create a
    /// clone for the Autonomous Database.
    #[prost(string, repeated, tag = "51")]
    pub supported_clone_regions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Output only. The storage space used by Autonomous Database, in gigabytes.
    #[prost(int32, tag = "53")]
    pub used_data_storage_size_tbs: i32,
    /// Output only. The Oracle Cloud Infrastructure link for the Autonomous
    /// Database.
    #[prost(string, tag = "54")]
    pub oci_url: ::prost::alloc::string::String,
    /// Output only. The storage space used by automatic backups of Autonomous
    /// Database, in gigabytes.
    #[prost(float, tag = "59")]
    pub total_auto_backup_storage_size_gbs: f32,
    /// Output only. The long term backup schedule of the Autonomous Database.
    #[prost(message, optional, tag = "60")]
    pub next_long_term_backup_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The date and time when maintenance will begin.
    #[prost(message, optional, tag = "65")]
    pub maintenance_begin_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The date and time when maintenance will end.
    #[prost(message, optional, tag = "66")]
    pub maintenance_end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `AutonomousDatabaseProperties`.
pub mod autonomous_database_properties {
    /// The editions available for the Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DatabaseEdition {
        /// Default unspecified value.
        Unspecified = 0,
        /// Standard Database Edition
        StandardEdition = 1,
        /// Enterprise Database Edition
        EnterpriseEdition = 2,
    }
    impl DatabaseEdition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DATABASE_EDITION_UNSPECIFIED",
                Self::StandardEdition => "STANDARD_EDITION",
                Self::EnterpriseEdition => "ENTERPRISE_EDITION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATABASE_EDITION_UNSPECIFIED" => Some(Self::Unspecified),
                "STANDARD_EDITION" => Some(Self::StandardEdition),
                "ENTERPRISE_EDITION" => Some(Self::EnterpriseEdition),
                _ => None,
            }
        }
    }
    /// The license types available for the Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LicenseType {
        /// Unspecified
        Unspecified = 0,
        /// License included part of offer
        LicenseIncluded = 1,
        /// Bring your own license
        BringYourOwnLicense = 2,
    }
    impl LicenseType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LICENSE_TYPE_UNSPECIFIED",
                Self::LicenseIncluded => "LICENSE_INCLUDED",
                Self::BringYourOwnLicense => "BRING_YOUR_OWN_LICENSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LICENSE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "LICENSE_INCLUDED" => Some(Self::LicenseIncluded),
                "BRING_YOUR_OWN_LICENSE" => Some(Self::BringYourOwnLicense),
                _ => None,
            }
        }
    }
    /// The available maintenance schedules for the Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MaintenanceScheduleType {
        /// Default unspecified value.
        Unspecified = 0,
        /// An EARLY maintenance schedule patches the database before
        /// the regular scheduled maintenance.
        Early = 1,
        /// A REGULAR maintenance schedule follows the normal maintenance cycle.
        Regular = 2,
    }
    impl MaintenanceScheduleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MAINTENANCE_SCHEDULE_TYPE_UNSPECIFIED",
                Self::Early => "EARLY",
                Self::Regular => "REGULAR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MAINTENANCE_SCHEDULE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "EARLY" => Some(Self::Early),
                "REGULAR" => Some(Self::Regular),
                _ => None,
            }
        }
    }
    /// The types of local disaster recovery available for an Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalDisasterRecoveryType {
        /// Default unspecified value.
        Unspecified = 0,
        /// Autonomous Data Guard recovery.
        Adg = 1,
        /// Backup based recovery.
        BackupBased = 2,
    }
    impl LocalDisasterRecoveryType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LOCAL_DISASTER_RECOVERY_TYPE_UNSPECIFIED",
                Self::Adg => "ADG",
                Self::BackupBased => "BACKUP_BASED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOCAL_DISASTER_RECOVERY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ADG" => Some(Self::Adg),
                "BACKUP_BASED" => Some(Self::BackupBased),
                _ => None,
            }
        }
    }
    /// Varies states of the Data Safe registration for the Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataSafeState {
        /// Default unspecified value.
        Unspecified = 0,
        /// Registering data safe state.
        Registering = 1,
        /// Registered data safe state.
        Registered = 2,
        /// Deregistering data safe state.
        Deregistering = 3,
        /// Not registered data safe state.
        NotRegistered = 4,
        /// Failed data safe state.
        Failed = 5,
    }
    impl DataSafeState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DATA_SAFE_STATE_UNSPECIFIED",
                Self::Registering => "REGISTERING",
                Self::Registered => "REGISTERED",
                Self::Deregistering => "DEREGISTERING",
                Self::NotRegistered => "NOT_REGISTERED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_SAFE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "REGISTERING" => Some(Self::Registering),
                "REGISTERED" => Some(Self::Registered),
                "DEREGISTERING" => Some(Self::Deregistering),
                "NOT_REGISTERED" => Some(Self::NotRegistered),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    /// The different states of database management for an Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DatabaseManagementState {
        /// Default unspecified value.
        Unspecified = 0,
        /// Enabling Database Management state
        Enabling = 1,
        /// Enabled Database Management state
        Enabled = 2,
        /// Disabling Database Management state
        Disabling = 3,
        /// Not Enabled Database Management state
        NotEnabled = 4,
        /// Failed enabling Database Management state
        FailedEnabling = 5,
        /// Failed disabling Database Management state
        FailedDisabling = 6,
    }
    impl DatabaseManagementState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DATABASE_MANAGEMENT_STATE_UNSPECIFIED",
                Self::Enabling => "ENABLING",
                Self::Enabled => "ENABLED",
                Self::Disabling => "DISABLING",
                Self::NotEnabled => "NOT_ENABLED",
                Self::FailedEnabling => "FAILED_ENABLING",
                Self::FailedDisabling => "FAILED_DISABLING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATABASE_MANAGEMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLING" => Some(Self::Enabling),
                "ENABLED" => Some(Self::Enabled),
                "DISABLING" => Some(Self::Disabling),
                "NOT_ENABLED" => Some(Self::NotEnabled),
                "FAILED_ENABLING" => Some(Self::FailedEnabling),
                "FAILED_DISABLING" => Some(Self::FailedDisabling),
                _ => None,
            }
        }
    }
    /// This field indicates the modes of an Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OpenMode {
        /// Default unspecified value.
        Unspecified = 0,
        /// Read Only Mode
        ReadOnly = 1,
        /// Read Write Mode
        ReadWrite = 2,
    }
    impl OpenMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OPEN_MODE_UNSPECIFIED",
                Self::ReadOnly => "READ_ONLY",
                Self::ReadWrite => "READ_WRITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPEN_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "READ_ONLY" => Some(Self::ReadOnly),
                "READ_WRITE" => Some(Self::ReadWrite),
                _ => None,
            }
        }
    }
    /// The types of permission levels for an Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PermissionLevel {
        /// Default unspecified value.
        Unspecified = 0,
        /// Restricted mode allows access only by admin users.
        Restricted = 1,
        /// Normal access.
        Unrestricted = 2,
    }
    impl PermissionLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PERMISSION_LEVEL_UNSPECIFIED",
                Self::Restricted => "RESTRICTED",
                Self::Unrestricted => "UNRESTRICTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PERMISSION_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
                "RESTRICTED" => Some(Self::Restricted),
                "UNRESTRICTED" => Some(Self::Unrestricted),
                _ => None,
            }
        }
    }
    /// The refresh mode of the cloned Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RefreshableMode {
        /// The default unspecified value.
        Unspecified = 0,
        /// AUTOMATIC indicates that the cloned database is automatically
        /// refreshed with data from the source Autonomous Database.
        Automatic = 1,
        /// MANUAL indicates that the cloned database is manually refreshed with
        /// data from the source Autonomous Database.
        Manual = 2,
    }
    impl RefreshableMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "REFRESHABLE_MODE_UNSPECIFIED",
                Self::Automatic => "AUTOMATIC",
                Self::Manual => "MANUAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REFRESHABLE_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "AUTOMATIC" => Some(Self::Automatic),
                "MANUAL" => Some(Self::Manual),
                _ => None,
            }
        }
    }
    /// The refresh state of the cloned Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RefreshableState {
        /// Default unspecified value.
        Unspecified = 0,
        /// Refreshing
        Refreshing = 1,
        /// Not refreshed
        NotRefreshing = 2,
    }
    impl RefreshableState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "REFRESHABLE_STATE_UNSPECIFIED",
                Self::Refreshing => "REFRESHING",
                Self::NotRefreshing => "NOT_REFRESHING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REFRESHABLE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "REFRESHING" => Some(Self::Refreshing),
                "NOT_REFRESHING" => Some(Self::NotRefreshing),
                _ => None,
            }
        }
    }
    /// The Data Guard role of the Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Role {
        /// Default unspecified value.
        Unspecified = 0,
        /// Primary role
        Primary = 1,
        /// Standby role
        Standby = 2,
        /// Disabled standby role
        DisabledStandby = 3,
        /// Backup copy role
        BackupCopy = 4,
        /// Snapshot standby role
        SnapshotStandby = 5,
    }
    impl Role {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ROLE_UNSPECIFIED",
                Self::Primary => "PRIMARY",
                Self::Standby => "STANDBY",
                Self::DisabledStandby => "DISABLED_STANDBY",
                Self::BackupCopy => "BACKUP_COPY",
                Self::SnapshotStandby => "SNAPSHOT_STANDBY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROLE_UNSPECIFIED" => Some(Self::Unspecified),
                "PRIMARY" => Some(Self::Primary),
                "STANDBY" => Some(Self::Standby),
                "DISABLED_STANDBY" => Some(Self::DisabledStandby),
                "BACKUP_COPY" => Some(Self::BackupCopy),
                "SNAPSHOT_STANDBY" => Some(Self::SnapshotStandby),
                _ => None,
            }
        }
    }
}
/// Oracle APEX Application Development.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseApex>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutonomousDatabaseApex {
    /// Output only. The Oracle APEX Application Development version.
    #[prost(string, tag = "1")]
    pub apex_version: ::prost::alloc::string::String,
    /// Output only. The Oracle REST Data Services (ORDS) version.
    #[prost(string, tag = "2")]
    pub ords_version: ::prost::alloc::string::String,
}
/// The connection string used to connect to the Autonomous Database.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseConnectionStrings>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutonomousDatabaseConnectionStrings {
    /// Output only. Returns all connection strings that can be used to connect to
    /// the Autonomous Database.
    #[prost(message, optional, tag = "1")]
    pub all_connection_strings: ::core::option::Option<AllConnectionStrings>,
    /// Output only. The database service provides the least level of resources to
    /// each SQL statement, but supports the most number of concurrent SQL
    /// statements.
    #[prost(string, tag = "2")]
    pub dedicated: ::prost::alloc::string::String,
    /// Output only. The database service provides the highest level of resources
    /// to each SQL statement.
    #[prost(string, tag = "3")]
    pub high: ::prost::alloc::string::String,
    /// Output only. The database service provides the least level of resources to
    /// each SQL statement.
    #[prost(string, tag = "4")]
    pub low: ::prost::alloc::string::String,
    /// Output only. The database service provides a lower level of resources to
    /// each SQL statement.
    #[prost(string, tag = "5")]
    pub medium: ::prost::alloc::string::String,
    /// Output only. A list of connection string profiles to allow clients to
    /// group, filter, and select values based on the structured metadata.
    #[prost(message, repeated, tag = "6")]
    pub profiles: ::prost::alloc::vec::Vec<DatabaseConnectionStringProfile>,
}
/// The connection string profile to allow clients to group.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/DatabaseConnectionStringProfile>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseConnectionStringProfile {
    /// Output only. The current consumer group being used by the connection.
    #[prost(
        enumeration = "database_connection_string_profile::ConsumerGroup",
        tag = "1"
    )]
    pub consumer_group: i32,
    /// Output only. The display name for the database connection.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The host name format being currently used in connection
    /// string.
    #[prost(enumeration = "database_connection_string_profile::HostFormat", tag = "3")]
    pub host_format: i32,
    /// Output only. This field indicates if the connection string is regional and
    /// is only applicable for cross-region Data Guard.
    #[prost(bool, tag = "4")]
    pub is_regional: bool,
    /// Output only. The protocol being used by the connection.
    #[prost(enumeration = "database_connection_string_profile::Protocol", tag = "5")]
    pub protocol: i32,
    /// Output only. The current session mode of the connection.
    #[prost(enumeration = "database_connection_string_profile::SessionMode", tag = "6")]
    pub session_mode: i32,
    /// Output only. The syntax of the connection string.
    #[prost(enumeration = "database_connection_string_profile::SyntaxFormat", tag = "7")]
    pub syntax_format: i32,
    /// Output only. This field indicates the TLS authentication type of the
    /// connection.
    #[prost(
        enumeration = "database_connection_string_profile::TlsAuthentication",
        tag = "8"
    )]
    pub tls_authentication: i32,
    /// Output only. The value of the connection string.
    #[prost(string, tag = "9")]
    pub value: ::prost::alloc::string::String,
}
/// Nested message and enum types in `DatabaseConnectionStringProfile`.
pub mod database_connection_string_profile {
    /// The various consumer groups available in the connection string profile.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConsumerGroup {
        /// Default unspecified value.
        Unspecified = 0,
        /// High consumer group.
        High = 1,
        /// Medium consumer group.
        Medium = 2,
        /// Low consumer group.
        Low = 3,
        /// TP consumer group.
        Tp = 4,
        /// TPURGENT consumer group.
        Tpurgent = 5,
    }
    impl ConsumerGroup {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CONSUMER_GROUP_UNSPECIFIED",
                Self::High => "HIGH",
                Self::Medium => "MEDIUM",
                Self::Low => "LOW",
                Self::Tp => "TP",
                Self::Tpurgent => "TPURGENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONSUMER_GROUP_UNSPECIFIED" => Some(Self::Unspecified),
                "HIGH" => Some(Self::High),
                "MEDIUM" => Some(Self::Medium),
                "LOW" => Some(Self::Low),
                "TP" => Some(Self::Tp),
                "TPURGENT" => Some(Self::Tpurgent),
                _ => None,
            }
        }
    }
    /// The host name format being used in the connection string.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HostFormat {
        /// Default unspecified value.
        Unspecified = 0,
        /// FQDN
        Fqdn = 1,
        /// IP
        Ip = 2,
    }
    impl HostFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "HOST_FORMAT_UNSPECIFIED",
                Self::Fqdn => "FQDN",
                Self::Ip => "IP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HOST_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "FQDN" => Some(Self::Fqdn),
                "IP" => Some(Self::Ip),
                _ => None,
            }
        }
    }
    /// The protocol being used by the connection.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Protocol {
        /// Default unspecified value.
        Unspecified = 0,
        /// Tcp
        Tcp = 1,
        /// Tcps
        Tcps = 2,
    }
    impl Protocol {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROTOCOL_UNSPECIFIED",
                Self::Tcp => "TCP",
                Self::Tcps => "TCPS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROTOCOL_UNSPECIFIED" => Some(Self::Unspecified),
                "TCP" => Some(Self::Tcp),
                "TCPS" => Some(Self::Tcps),
                _ => None,
            }
        }
    }
    /// The session mode of the connection.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SessionMode {
        /// Default unspecified value.
        Unspecified = 0,
        /// Direct
        Direct = 1,
        /// Indirect
        Indirect = 2,
    }
    impl SessionMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SESSION_MODE_UNSPECIFIED",
                Self::Direct => "DIRECT",
                Self::Indirect => "INDIRECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SESSION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "DIRECT" => Some(Self::Direct),
                "INDIRECT" => Some(Self::Indirect),
                _ => None,
            }
        }
    }
    /// Specifies syntax of the connection string.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SyntaxFormat {
        /// Default unspecified value.
        Unspecified = 0,
        /// Long
        Long = 1,
        /// Ezconnect
        Ezconnect = 2,
        /// Ezconnectplus
        Ezconnectplus = 3,
    }
    impl SyntaxFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SYNTAX_FORMAT_UNSPECIFIED",
                Self::Long => "LONG",
                Self::Ezconnect => "EZCONNECT",
                Self::Ezconnectplus => "EZCONNECTPLUS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SYNTAX_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "LONG" => Some(Self::Long),
                "EZCONNECT" => Some(Self::Ezconnect),
                "EZCONNECTPLUS" => Some(Self::Ezconnectplus),
                _ => None,
            }
        }
    }
    /// This field indicates the TLS authentication type of the connection.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TlsAuthentication {
        /// Default unspecified value.
        Unspecified = 0,
        /// Server
        Server = 1,
        /// Mutual
        Mutual = 2,
    }
    impl TlsAuthentication {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TLS_AUTHENTICATION_UNSPECIFIED",
                Self::Server => "SERVER",
                Self::Mutual => "MUTUAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TLS_AUTHENTICATION_UNSPECIFIED" => Some(Self::Unspecified),
                "SERVER" => Some(Self::Server),
                "MUTUAL" => Some(Self::Mutual),
                _ => None,
            }
        }
    }
}
/// A list of all connection strings that can be used to connect to the
/// Autonomous Database.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllConnectionStrings {
    /// Output only. The database service provides the highest level of resources
    /// to each SQL statement.
    #[prost(string, tag = "1")]
    pub high: ::prost::alloc::string::String,
    /// Output only. The database service provides the least level of resources to
    /// each SQL statement.
    #[prost(string, tag = "2")]
    pub low: ::prost::alloc::string::String,
    /// Output only. The database service provides a lower level of resources to
    /// each SQL statement.
    #[prost(string, tag = "3")]
    pub medium: ::prost::alloc::string::String,
}
/// The URLs for accessing Oracle Application Express (APEX) and SQL Developer
/// Web with a browser from a Compute instance.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseConnectionUrls>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutonomousDatabaseConnectionUrls {
    /// Output only. Oracle Application Express (APEX) URL.
    #[prost(string, tag = "1")]
    pub apex_uri: ::prost::alloc::string::String,
    /// Output only. The URL of the Database Transforms for the Autonomous
    /// Database.
    #[prost(string, tag = "2")]
    pub database_transforms_uri: ::prost::alloc::string::String,
    /// Output only. The URL of the Graph Studio for the Autonomous Database.
    #[prost(string, tag = "3")]
    pub graph_studio_uri: ::prost::alloc::string::String,
    /// Output only. The URL of the Oracle Machine Learning (OML) Notebook for the
    /// Autonomous Database.
    #[prost(string, tag = "4")]
    pub machine_learning_notebook_uri: ::prost::alloc::string::String,
    /// Output only. The URL of Machine Learning user management the Autonomous
    /// Database.
    #[prost(string, tag = "5")]
    pub machine_learning_user_management_uri: ::prost::alloc::string::String,
    /// Output only. The URL of the MongoDB API for the Autonomous Database.
    #[prost(string, tag = "6")]
    pub mongo_db_uri: ::prost::alloc::string::String,
    /// Output only. The Oracle REST Data Services (ORDS) URL of the Web Access for
    /// the Autonomous Database.
    #[prost(string, tag = "7")]
    pub ords_uri: ::prost::alloc::string::String,
    /// Output only. The URL of the Oracle SQL Developer Web for the Autonomous
    /// Database.
    #[prost(string, tag = "8")]
    pub sql_dev_web_uri: ::prost::alloc::string::String,
}
/// Autonomous Data Guard standby database details.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseStandbySummary>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutonomousDatabaseStandbySummary {
    /// Output only. The amount of time, in seconds, that the data of the standby
    /// database lags in comparison to the data of the primary database.
    #[prost(message, optional, tag = "1")]
    pub lag_time_duration: ::core::option::Option<::prost_types::Duration>,
    /// Output only. The additional details about the current lifecycle state of
    /// the Autonomous Database.
    #[prost(string, tag = "2")]
    pub lifecycle_details: ::prost::alloc::string::String,
    /// Output only. The current lifecycle state of the Autonomous Database.
    #[prost(enumeration = "State", tag = "3")]
    pub state: i32,
    /// Output only. The date and time the Autonomous Data Guard role was switched
    /// for the standby Autonomous Database.
    #[prost(message, optional, tag = "4")]
    pub data_guard_role_changed_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The date and time the Disaster Recovery role was switched for
    /// the standby Autonomous Database.
    #[prost(message, optional, tag = "5")]
    pub disaster_recovery_role_changed_time: ::core::option::Option<
        ::prost_types::Timestamp,
    >,
}
/// Details of scheduled operation.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/ScheduledOperationDetails>
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScheduledOperationDetails {
    /// Output only. Day of week.
    #[prost(enumeration = "super::super::super::r#type::DayOfWeek", tag = "1")]
    pub day_of_week: i32,
    /// Output only. Auto start time.
    #[prost(message, optional, tag = "4")]
    pub start_time: ::core::option::Option<super::super::super::r#type::TimeOfDay>,
    /// Output only. Auto stop time.
    #[prost(message, optional, tag = "5")]
    pub stop_time: ::core::option::Option<super::super::super::r#type::TimeOfDay>,
}
/// The type of wallet generation.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GenerateType {
    /// Default unspecified value.
    Unspecified = 0,
    /// Used to generate wallet for all databases in the region.
    All = 1,
    /// Used to generate wallet for a single database.
    Single = 2,
}
impl GenerateType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "GENERATE_TYPE_UNSPECIFIED",
            Self::All => "ALL",
            Self::Single => "SINGLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GENERATE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ALL" => Some(Self::All),
            "SINGLE" => Some(Self::Single),
            _ => None,
        }
    }
}
/// The various lifecycle states of the Autonomous Database.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
    /// Default unspecified value.
    Unspecified = 0,
    /// Indicates that the Autonomous Database is in provisioning state.
    Provisioning = 1,
    /// Indicates that the Autonomous Database is in available state.
    Available = 2,
    /// Indicates that the Autonomous Database is in stopping state.
    Stopping = 3,
    /// Indicates that the Autonomous Database is in stopped state.
    Stopped = 4,
    /// Indicates that the Autonomous Database is in starting state.
    Starting = 5,
    /// Indicates that the Autonomous Database is in terminating state.
    Terminating = 6,
    /// Indicates that the Autonomous Database is in terminated state.
    Terminated = 7,
    /// Indicates that the Autonomous Database is in unavailable state.
    Unavailable = 8,
    /// Indicates that the Autonomous Database restore is in progress.
    RestoreInProgress = 9,
    /// Indicates that the Autonomous Database failed to restore.
    RestoreFailed = 10,
    /// Indicates that the Autonomous Database backup is in progress.
    BackupInProgress = 11,
    /// Indicates that the Autonomous Database scale is in progress.
    ScaleInProgress = 12,
    /// Indicates that the Autonomous Database is available but needs attention
    /// state.
    AvailableNeedsAttention = 13,
    /// Indicates that the Autonomous Database is in updating state.
    Updating = 14,
    /// Indicates that the Autonomous Database's maintenance is in progress state.
    MaintenanceInProgress = 15,
    /// Indicates that the Autonomous Database is in restarting state.
    Restarting = 16,
    /// Indicates that the Autonomous Database is in recreating state.
    Recreating = 17,
    /// Indicates that the Autonomous Database's role change is in progress state.
    RoleChangeInProgress = 18,
    /// Indicates that the Autonomous Database is in upgrading state.
    Upgrading = 19,
    /// Indicates that the Autonomous Database is in inaccessible state.
    Inaccessible = 20,
    /// Indicates that the Autonomous Database is in standby state.
    Standby = 21,
}
impl State {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STATE_UNSPECIFIED",
            Self::Provisioning => "PROVISIONING",
            Self::Available => "AVAILABLE",
            Self::Stopping => "STOPPING",
            Self::Stopped => "STOPPED",
            Self::Starting => "STARTING",
            Self::Terminating => "TERMINATING",
            Self::Terminated => "TERMINATED",
            Self::Unavailable => "UNAVAILABLE",
            Self::RestoreInProgress => "RESTORE_IN_PROGRESS",
            Self::RestoreFailed => "RESTORE_FAILED",
            Self::BackupInProgress => "BACKUP_IN_PROGRESS",
            Self::ScaleInProgress => "SCALE_IN_PROGRESS",
            Self::AvailableNeedsAttention => "AVAILABLE_NEEDS_ATTENTION",
            Self::Updating => "UPDATING",
            Self::MaintenanceInProgress => "MAINTENANCE_IN_PROGRESS",
            Self::Restarting => "RESTARTING",
            Self::Recreating => "RECREATING",
            Self::RoleChangeInProgress => "ROLE_CHANGE_IN_PROGRESS",
            Self::Upgrading => "UPGRADING",
            Self::Inaccessible => "INACCESSIBLE",
            Self::Standby => "STANDBY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "PROVISIONING" => Some(Self::Provisioning),
            "AVAILABLE" => Some(Self::Available),
            "STOPPING" => Some(Self::Stopping),
            "STOPPED" => Some(Self::Stopped),
            "STARTING" => Some(Self::Starting),
            "TERMINATING" => Some(Self::Terminating),
            "TERMINATED" => Some(Self::Terminated),
            "UNAVAILABLE" => Some(Self::Unavailable),
            "RESTORE_IN_PROGRESS" => Some(Self::RestoreInProgress),
            "RESTORE_FAILED" => Some(Self::RestoreFailed),
            "BACKUP_IN_PROGRESS" => Some(Self::BackupInProgress),
            "SCALE_IN_PROGRESS" => Some(Self::ScaleInProgress),
            "AVAILABLE_NEEDS_ATTENTION" => Some(Self::AvailableNeedsAttention),
            "UPDATING" => Some(Self::Updating),
            "MAINTENANCE_IN_PROGRESS" => Some(Self::MaintenanceInProgress),
            "RESTARTING" => Some(Self::Restarting),
            "RECREATING" => Some(Self::Recreating),
            "ROLE_CHANGE_IN_PROGRESS" => Some(Self::RoleChangeInProgress),
            "UPGRADING" => Some(Self::Upgrading),
            "INACCESSIBLE" => Some(Self::Inaccessible),
            "STANDBY" => Some(Self::Standby),
            _ => None,
        }
    }
}
/// The state of the Operations Insights for this Autonomous Database.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperationsInsightsState {
    /// Default unspecified value.
    Unspecified = 0,
    /// Enabling status for operation insights.
    Enabling = 1,
    /// Enabled status for operation insights.
    Enabled = 2,
    /// Disabling status for operation insights.
    Disabling = 3,
    /// Not Enabled status for operation insights.
    NotEnabled = 4,
    /// Failed enabling status for operation insights.
    FailedEnabling = 5,
    /// Failed disabling status for operation insights.
    FailedDisabling = 6,
}
impl OperationsInsightsState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "OPERATIONS_INSIGHTS_STATE_UNSPECIFIED",
            Self::Enabling => "ENABLING",
            Self::Enabled => "ENABLED",
            Self::Disabling => "DISABLING",
            Self::NotEnabled => "NOT_ENABLED",
            Self::FailedEnabling => "FAILED_ENABLING",
            Self::FailedDisabling => "FAILED_DISABLING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPERATIONS_INSIGHTS_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "ENABLING" => Some(Self::Enabling),
            "ENABLED" => Some(Self::Enabled),
            "DISABLING" => Some(Self::Disabling),
            "NOT_ENABLED" => Some(Self::NotEnabled),
            "FAILED_ENABLING" => Some(Self::FailedEnabling),
            "FAILED_DISABLING" => Some(Self::FailedDisabling),
            _ => None,
        }
    }
}
/// The various states available for the Autonomous Database workload type.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DbWorkload {
    /// Default unspecified value.
    Unspecified = 0,
    /// Autonomous Transaction Processing database.
    Oltp = 1,
    /// Autonomous Data Warehouse database.
    Dw = 2,
    /// Autonomous JSON Database.
    Ajd = 3,
    /// Autonomous Database with the Oracle APEX Application Development workload
    /// type.
    Apex = 4,
}
impl DbWorkload {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DB_WORKLOAD_UNSPECIFIED",
            Self::Oltp => "OLTP",
            Self::Dw => "DW",
            Self::Ajd => "AJD",
            Self::Apex => "APEX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DB_WORKLOAD_UNSPECIFIED" => Some(Self::Unspecified),
            "OLTP" => Some(Self::Oltp),
            "DW" => Some(Self::Dw),
            "AJD" => Some(Self::Ajd),
            "APEX" => Some(Self::Apex),
            _ => None,
        }
    }
}
/// Details of the Autonomous Database character set resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseCharacterSets/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutonomousDatabaseCharacterSet {
    /// Identifier. The name of the Autonomous Database Character Set resource in
    /// the following format:
    /// projects/{project}/locations/{region}/autonomousDatabaseCharacterSets/{autonomous_database_character_set}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The character set type for the Autonomous Database.
    #[prost(
        enumeration = "autonomous_database_character_set::CharacterSetType",
        tag = "2"
    )]
    pub character_set_type: i32,
    /// Output only. The character set name for the Autonomous Database which is
    /// the ID in the resource name.
    #[prost(string, tag = "3")]
    pub character_set: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AutonomousDatabaseCharacterSet`.
pub mod autonomous_database_character_set {
    /// The type of character set an Autonomous Database can have.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CharacterSetType {
        /// Character set type is not specified.
        Unspecified = 0,
        /// Character set type is set to database.
        Database = 1,
        /// Character set type is set to national.
        National = 2,
    }
    impl CharacterSetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CHARACTER_SET_TYPE_UNSPECIFIED",
                Self::Database => "DATABASE",
                Self::National => "NATIONAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHARACTER_SET_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "DATABASE" => Some(Self::Database),
                "NATIONAL" => Some(Self::National),
                _ => None,
            }
        }
    }
}
/// Details of the Autonomous Database Backup resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseBackup/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutonomousDatabaseBackup {
    /// Identifier. The name of the Autonomous Database Backup resource with the
    /// format:
    /// projects/{project}/locations/{region}/autonomousDatabaseBackups/{autonomous_database_backup}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The name of the Autonomous Database resource for which the backup
    /// is being created. Format:
    /// projects/{project}/locations/{region}/autonomousDatabases/{autonomous_database}
    #[prost(string, tag = "2")]
    pub autonomous_database: ::prost::alloc::string::String,
    /// Optional. User friendly name for the Backup. The name does not have to be
    /// unique.
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. Various properties of the backup.
    #[prost(message, optional, tag = "4")]
    pub properties: ::core::option::Option<AutonomousDatabaseBackupProperties>,
    /// Optional. labels or tags associated with the resource.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Properties of the Autonomous Database Backup resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutonomousDatabaseBackupProperties {
    /// Output only. OCID of the Autonomous Database backup.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    #[prost(string, tag = "1")]
    pub ocid: ::prost::alloc::string::String,
    /// Optional. Retention period in days for the backup.
    #[prost(int32, tag = "2")]
    pub retention_period_days: i32,
    /// Output only. The OCID of the compartment.
    #[prost(string, tag = "3")]
    pub compartment_id: ::prost::alloc::string::String,
    /// Output only. The quantity of data in the database, in terabytes.
    #[prost(float, tag = "4")]
    pub database_size_tb: f32,
    /// Output only. A valid Oracle Database version for Autonomous Database.
    #[prost(string, tag = "5")]
    pub db_version: ::prost::alloc::string::String,
    /// Output only. Indicates if the backup is long term backup.
    #[prost(bool, tag = "6")]
    pub is_long_term_backup: bool,
    /// Output only. Indicates if the backup is automatic or user initiated.
    #[prost(bool, tag = "7")]
    pub is_automatic_backup: bool,
    /// Output only. Indicates if the backup can be used to restore the Autonomous
    /// Database.
    #[prost(bool, tag = "8")]
    pub is_restorable: bool,
    /// Optional. The OCID of the key store of Oracle Vault.
    #[prost(string, tag = "9")]
    pub key_store_id: ::prost::alloc::string::String,
    /// Optional. The wallet name for Oracle Key Vault.
    #[prost(string, tag = "10")]
    pub key_store_wallet: ::prost::alloc::string::String,
    /// Optional. The OCID of the key container that is used as the master
    /// encryption key in database transparent data encryption (TDE) operations.
    #[prost(string, tag = "11")]
    pub kms_key_id: ::prost::alloc::string::String,
    /// Optional. The OCID of the key container version that is used in database
    /// transparent data encryption (TDE) operations KMS Key can have multiple key
    /// versions. If none is specified, the current key version (latest) of the Key
    /// Id is used for the operation. Autonomous Database Serverless does not use
    /// key versions, hence is not applicable for Autonomous Database Serverless
    /// instances.
    #[prost(string, tag = "12")]
    pub kms_key_version_id: ::prost::alloc::string::String,
    /// Output only. Additional information about the current lifecycle state.
    #[prost(string, tag = "13")]
    pub lifecycle_details: ::prost::alloc::string::String,
    /// Output only. The lifecycle state of the backup.
    #[prost(enumeration = "autonomous_database_backup_properties::State", tag = "14")]
    pub lifecycle_state: i32,
    /// Output only. The backup size in terabytes.
    #[prost(float, tag = "15")]
    pub size_tb: f32,
    /// Output only. Timestamp until when the backup will be available.
    #[prost(message, optional, tag = "16")]
    pub available_till_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The date and time the backup completed.
    #[prost(message, optional, tag = "17")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The date and time the backup started.
    #[prost(message, optional, tag = "18")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The type of the backup.
    #[prost(enumeration = "autonomous_database_backup_properties::Type", tag = "19")]
    pub r#type: i32,
    /// Optional. The OCID of the vault.
    #[prost(string, tag = "20")]
    pub vault_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AutonomousDatabaseBackupProperties`.
pub mod autonomous_database_backup_properties {
    /// // The various lifecycle states of the Autonomous Database Backup.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default unspecified value.
        Unspecified = 0,
        /// Indicates that the resource is in creating state.
        Creating = 1,
        /// Indicates that the resource is in active state.
        Active = 2,
        /// Indicates that the resource is in deleting state.
        Deleting = 3,
        /// Indicates that the resource is in deleted state.
        Deleted = 4,
        /// Indicates that the resource is in failed state.
        Failed = 6,
        /// Indicates that the resource is in updating state.
        Updating = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Deleting => "DELETING",
                Self::Deleted => "DELETED",
                Self::Failed => "FAILED",
                Self::Updating => "UPDATING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "DELETED" => Some(Self::Deleted),
                "FAILED" => Some(Self::Failed),
                "UPDATING" => Some(Self::Updating),
                _ => None,
            }
        }
    }
    /// The type of the backup.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Default unspecified value.
        Unspecified = 0,
        /// Incremental backups.
        Incremental = 1,
        /// Full backups.
        Full = 2,
        /// Long term backups.
        LongTerm = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Incremental => "INCREMENTAL",
                Self::Full => "FULL",
                Self::LongTerm => "LONG_TERM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INCREMENTAL" => Some(Self::Incremental),
                "FULL" => Some(Self::Full),
                "LONG_TERM" => Some(Self::LongTerm),
                _ => None,
            }
        }
    }
}
/// Details of the Autonomous Database version.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDbVersionSummary/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutonomousDbVersion {
    /// Identifier. The name of the Autonomous Database Version resource with the
    /// format:
    /// projects/{project}/locations/{region}/autonomousDbVersions/{autonomous_db_version}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. An Oracle Database version for Autonomous Database.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// Output only. The Autonomous Database workload type.
    #[prost(enumeration = "DbWorkload", tag = "4")]
    pub db_workload: i32,
    /// Output only. A URL that points to a detailed description of the Autonomous
    /// Database version.
    #[prost(string, tag = "5")]
    pub workload_uri: ::prost::alloc::string::String,
}
/// Details of the database node resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbNode/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DbNode {
    /// Identifier. The name of the database node resource in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}/dbNodes/{db_node}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Various properties of the database node.
    #[prost(message, optional, tag = "3")]
    pub properties: ::core::option::Option<DbNodeProperties>,
}
/// Various properties and settings associated with Db node.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DbNodeProperties {
    /// Output only. OCID of database node.
    #[prost(string, tag = "1")]
    pub ocid: ::prost::alloc::string::String,
    /// Optional. OCPU count per database node.
    #[prost(int32, tag = "2")]
    pub ocpu_count: i32,
    /// Memory allocated in GBs.
    #[prost(int32, tag = "3")]
    pub memory_size_gb: i32,
    /// Optional. Local storage per database node.
    #[prost(int32, tag = "4")]
    pub db_node_storage_size_gb: i32,
    /// Optional. Database server OCID.
    #[prost(string, tag = "5")]
    pub db_server_ocid: ::prost::alloc::string::String,
    /// Optional. DNS
    #[prost(string, tag = "8")]
    pub hostname: ::prost::alloc::string::String,
    /// Output only. State of the database node.
    #[prost(enumeration = "db_node_properties::State", tag = "9")]
    pub state: i32,
    /// Total CPU core count of the database node.
    #[prost(int32, tag = "10")]
    pub total_cpu_core_count: i32,
}
/// Nested message and enum types in `DbNodeProperties`.
pub mod db_node_properties {
    /// The various lifecycle states of the database node.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default unspecified value.
        Unspecified = 0,
        /// Indicates that the resource is in provisioning state.
        Provisioning = 1,
        /// Indicates that the resource is in available state.
        Available = 2,
        /// Indicates that the resource is in updating state.
        Updating = 3,
        /// Indicates that the resource is in stopping state.
        Stopping = 4,
        /// Indicates that the resource is in stopped state.
        Stopped = 5,
        /// Indicates that the resource is in starting state.
        Starting = 6,
        /// Indicates that the resource is in terminating state.
        Terminating = 7,
        /// Indicates that the resource is in terminated state.
        Terminated = 8,
        /// Indicates that the resource is in failed state.
        Failed = 9,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Available => "AVAILABLE",
                Self::Updating => "UPDATING",
                Self::Stopping => "STOPPING",
                Self::Stopped => "STOPPED",
                Self::Starting => "STARTING",
                Self::Terminating => "TERMINATING",
                Self::Terminated => "TERMINATED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "AVAILABLE" => Some(Self::Available),
                "UPDATING" => Some(Self::Updating),
                "STOPPING" => Some(Self::Stopping),
                "STOPPED" => Some(Self::Stopped),
                "STARTING" => Some(Self::Starting),
                "TERMINATING" => Some(Self::Terminating),
                "TERMINATED" => Some(Self::Terminated),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Details of the database server resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbServer/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DbServer {
    /// Identifier. The name of the database server resource with the format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}/dbServers/{db_server}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User friendly name for this resource.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. Various properties of the database server.
    #[prost(message, optional, tag = "3")]
    pub properties: ::core::option::Option<DbServerProperties>,
}
/// Various properties and settings associated with Exadata database server.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DbServerProperties {
    /// Output only. OCID of database server.
    #[prost(string, tag = "1")]
    pub ocid: ::prost::alloc::string::String,
    /// Optional. OCPU count per database.
    #[prost(int32, tag = "2")]
    pub ocpu_count: i32,
    /// Optional. Maximum OCPU count per database.
    #[prost(int32, tag = "3")]
    pub max_ocpu_count: i32,
    /// Optional. Memory allocated in GBs.
    #[prost(int32, tag = "4")]
    pub memory_size_gb: i32,
    /// Optional. Maximum memory allocated in GBs.
    #[prost(int32, tag = "5")]
    pub max_memory_size_gb: i32,
    /// Optional. Local storage per VM.
    #[prost(int32, tag = "6")]
    pub db_node_storage_size_gb: i32,
    /// Optional. Maximum local storage per VM.
    #[prost(int32, tag = "7")]
    pub max_db_node_storage_size_gb: i32,
    /// Optional. Vm count per database.
    #[prost(int32, tag = "8")]
    pub vm_count: i32,
    /// Output only. State of the database server.
    #[prost(enumeration = "db_server_properties::State", tag = "9")]
    pub state: i32,
    /// Output only. OCID of database nodes associated with the database server.
    #[prost(string, repeated, tag = "10")]
    pub db_node_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `DbServerProperties`.
pub mod db_server_properties {
    /// The various lifecycle states of the database server.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default unspecified value.
        Unspecified = 0,
        /// Indicates that the resource is in creating state.
        Creating = 1,
        /// Indicates that the resource is in available state.
        Available = 2,
        /// Indicates that the resource is in unavailable state.
        Unavailable = 3,
        /// Indicates that the resource is in deleting state.
        Deleting = 4,
        /// Indicates that the resource is in deleted state.
        Deleted = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Available => "AVAILABLE",
                Self::Unavailable => "UNAVAILABLE",
                Self::Deleting => "DELETING",
                Self::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "AVAILABLE" => Some(Self::Available),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "DELETING" => Some(Self::Deleting),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
/// Details of the Database System Shapes resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbSystemShapeSummary/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DbSystemShape {
    /// Identifier. The name of the Database System Shape resource with the format:
    /// projects/{project}/locations/{region}/dbSystemShapes/{db_system_shape}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. shape
    #[prost(string, tag = "2")]
    pub shape: ::prost::alloc::string::String,
    /// Optional. Minimum number of database servers.
    #[prost(int32, tag = "3")]
    pub min_node_count: i32,
    /// Optional. Maximum number of database servers.
    #[prost(int32, tag = "4")]
    pub max_node_count: i32,
    /// Optional. Minimum number of storage servers.
    #[prost(int32, tag = "5")]
    pub min_storage_count: i32,
    /// Optional. Maximum number of storage servers.
    #[prost(int32, tag = "6")]
    pub max_storage_count: i32,
    /// Optional. Number of cores per node.
    #[prost(int32, tag = "7")]
    pub available_core_count_per_node: i32,
    /// Optional. Memory per database server node in gigabytes.
    #[prost(int32, tag = "8")]
    pub available_memory_per_node_gb: i32,
    /// Optional. Storage per storage server in terabytes.
    #[prost(int32, tag = "9")]
    pub available_data_storage_tb: i32,
    /// Optional. Minimum core count per node.
    #[prost(int32, tag = "10")]
    pub min_core_count_per_node: i32,
    /// Optional. Minimum memory per node in gigabytes.
    #[prost(int32, tag = "11")]
    pub min_memory_per_node_gb: i32,
    /// Optional. Minimum node storage per database server in gigabytes.
    #[prost(int32, tag = "12")]
    pub min_db_node_storage_per_node_gb: i32,
}
/// Details of the Entitlement resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entitlement {
    /// Identifier. The name of the Entitlement resource with the format:
    /// projects/{project}/locations/{region}/entitlements/{entitlement}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Details of the OCI Cloud Account.
    #[prost(message, optional, tag = "2")]
    pub cloud_account_details: ::core::option::Option<CloudAccountDetails>,
    /// Output only. Google Cloud Marketplace order ID (aka entitlement ID)
    #[prost(string, tag = "3")]
    pub entitlement_id: ::prost::alloc::string::String,
    /// Output only. Entitlement State.
    #[prost(enumeration = "entitlement::State", tag = "4")]
    pub state: i32,
}
/// Nested message and enum types in `Entitlement`.
pub mod entitlement {
    /// The various lifecycle states of the subscription.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default unspecified value.
        Unspecified = 0,
        /// Account not linked.
        AccountNotLinked = 1,
        /// Account is linked but not active.
        AccountNotActive = 2,
        /// Entitlement and Account are active.
        Active = 3,
        /// Account is suspended.
        AccountSuspended = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::AccountNotLinked => "ACCOUNT_NOT_LINKED",
                Self::AccountNotActive => "ACCOUNT_NOT_ACTIVE",
                Self::Active => "ACTIVE",
                Self::AccountSuspended => "ACCOUNT_SUSPENDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACCOUNT_NOT_LINKED" => Some(Self::AccountNotLinked),
                "ACCOUNT_NOT_ACTIVE" => Some(Self::AccountNotActive),
                "ACTIVE" => Some(Self::Active),
                "ACCOUNT_SUSPENDED" => Some(Self::AccountSuspended),
                _ => None,
            }
        }
    }
}
/// Details of the OCI Cloud Account.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudAccountDetails {
    /// Output only. OCI account name.
    #[prost(string, tag = "1")]
    pub cloud_account: ::prost::alloc::string::String,
    /// Output only. OCI account home region.
    #[prost(string, tag = "2")]
    pub cloud_account_home_region: ::prost::alloc::string::String,
    /// Output only. URL to link an existing account.
    #[prost(string, optional, tag = "3")]
    pub link_existing_account_uri: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// Output only. URL to create a new account and link.
    #[prost(string, optional, tag = "4")]
    pub account_creation_uri: ::core::option::Option<::prost::alloc::string::String>,
}
/// Represents CloudExadataInfrastructure resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/CloudExadataInfrastructure/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudExadataInfrastructure {
    /// Identifier. The name of the Exadata Infrastructure resource with the
    /// format:
    /// projects/{project}/locations/{region}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User friendly name for this resource.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. Google Cloud Platform location where Oracle Exadata is hosted.
    #[prost(string, tag = "8")]
    pub gcp_oracle_zone: ::prost::alloc::string::String,
    /// Output only. Entitlement ID of the private offer against which this
    /// infrastructure resource is provisioned.
    #[prost(string, tag = "4")]
    pub entitlement_id: ::prost::alloc::string::String,
    /// Optional. Various properties of the infra.
    #[prost(message, optional, tag = "5")]
    pub properties: ::core::option::Option<CloudExadataInfrastructureProperties>,
    /// Optional. Labels or tags associated with the resource.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The date and time that the Exadata Infrastructure was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Various properties of Exadata Infrastructure.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudExadataInfrastructureProperties {
    /// Output only. OCID of created infra.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    #[prost(string, tag = "1")]
    pub ocid: ::prost::alloc::string::String,
    /// Optional. The number of compute servers for the Exadata Infrastructure.
    #[prost(int32, tag = "2")]
    pub compute_count: i32,
    /// Optional. The number of Cloud Exadata storage servers for the Exadata
    /// Infrastructure.
    #[prost(int32, tag = "3")]
    pub storage_count: i32,
    /// Optional. The total storage allocated to the Exadata Infrastructure
    /// resource, in gigabytes (GB).
    #[prost(int32, tag = "4")]
    pub total_storage_size_gb: i32,
    /// Output only. The available storage can be allocated to the Exadata
    /// Infrastructure resource, in gigabytes (GB).
    #[prost(int32, tag = "5")]
    pub available_storage_size_gb: i32,
    /// Optional. Maintenance window for repair.
    #[prost(message, optional, tag = "6")]
    pub maintenance_window: ::core::option::Option<MaintenanceWindow>,
    /// Output only. The current lifecycle state of the Exadata Infrastructure.
    #[prost(enumeration = "cloud_exadata_infrastructure_properties::State", tag = "7")]
    pub state: i32,
    /// Required. The shape of the Exadata Infrastructure. The shape determines the
    /// amount of CPU, storage, and memory resources allocated to the instance.
    #[prost(string, tag = "8")]
    pub shape: ::prost::alloc::string::String,
    /// Output only. Deep link to the OCI console to view this resource.
    #[prost(string, tag = "9")]
    pub oci_url: ::prost::alloc::string::String,
    /// Output only. The number of enabled CPU cores.
    #[prost(int32, tag = "10")]
    pub cpu_count: i32,
    /// Output only. The total number of CPU cores available.
    #[prost(int32, tag = "11")]
    pub max_cpu_count: i32,
    /// Output only. The memory allocated in GBs.
    #[prost(int32, tag = "12")]
    pub memory_size_gb: i32,
    /// Output only. The total memory available in GBs.
    #[prost(int32, tag = "13")]
    pub max_memory_gb: i32,
    /// Output only. The local node storage allocated in GBs.
    #[prost(int32, tag = "14")]
    pub db_node_storage_size_gb: i32,
    /// Output only. The total local node storage available in GBs.
    #[prost(int32, tag = "15")]
    pub max_db_node_storage_size_gb: i32,
    /// Output only. Size, in terabytes, of the DATA disk group.
    #[prost(double, tag = "16")]
    pub data_storage_size_tb: f64,
    /// Output only. The total available DATA disk group size.
    #[prost(double, tag = "17")]
    pub max_data_storage_tb: f64,
    /// Output only. The requested number of additional storage servers activated
    /// for the Exadata Infrastructure.
    #[prost(int32, tag = "18")]
    pub activated_storage_count: i32,
    /// Output only. The requested number of additional storage servers for the
    /// Exadata Infrastructure.
    #[prost(int32, tag = "19")]
    pub additional_storage_count: i32,
    /// Output only. The software version of the database servers (dom0) in the
    /// Exadata Infrastructure.
    #[prost(string, tag = "20")]
    pub db_server_version: ::prost::alloc::string::String,
    /// Output only. The software version of the storage servers (cells) in the
    /// Exadata Infrastructure.
    #[prost(string, tag = "21")]
    pub storage_server_version: ::prost::alloc::string::String,
    /// Output only. The OCID of the next maintenance run.
    #[prost(string, tag = "22")]
    pub next_maintenance_run_id: ::prost::alloc::string::String,
    /// Output only. The time when the next maintenance run will occur.
    #[prost(message, optional, tag = "23")]
    pub next_maintenance_run_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the next security maintenance run will occur.
    #[prost(message, optional, tag = "24")]
    pub next_security_maintenance_run_time: ::core::option::Option<
        ::prost_types::Timestamp,
    >,
    /// Optional. The list of customer contacts.
    #[prost(message, repeated, tag = "25")]
    pub customer_contacts: ::prost::alloc::vec::Vec<CustomerContact>,
    /// Output only. The monthly software version of the storage servers (cells)
    /// in the Exadata Infrastructure. Example: 20.1.15
    #[prost(string, tag = "26")]
    pub monthly_storage_server_version: ::prost::alloc::string::String,
    /// Output only. The monthly software version of the database servers (dom0)
    /// in the Exadata Infrastructure. Example: 20.1.15
    #[prost(string, tag = "27")]
    pub monthly_db_server_version: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CloudExadataInfrastructureProperties`.
pub mod cloud_exadata_infrastructure_properties {
    /// The various lifecycle states of the Exadata Infrastructure.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default unspecified value.
        Unspecified = 0,
        /// The Exadata Infrastructure is being provisioned.
        Provisioning = 1,
        /// The Exadata Infrastructure is available for use.
        Available = 2,
        /// The Exadata Infrastructure is being updated.
        Updating = 3,
        /// The Exadata Infrastructure is being terminated.
        Terminating = 4,
        /// The Exadata Infrastructure is terminated.
        Terminated = 5,
        /// The Exadata Infrastructure is in failed state.
        Failed = 6,
        /// The Exadata Infrastructure is in maintenance.
        MaintenanceInProgress = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Available => "AVAILABLE",
                Self::Updating => "UPDATING",
                Self::Terminating => "TERMINATING",
                Self::Terminated => "TERMINATED",
                Self::Failed => "FAILED",
                Self::MaintenanceInProgress => "MAINTENANCE_IN_PROGRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "AVAILABLE" => Some(Self::Available),
                "UPDATING" => Some(Self::Updating),
                "TERMINATING" => Some(Self::Terminating),
                "TERMINATED" => Some(Self::Terminated),
                "FAILED" => Some(Self::Failed),
                "MAINTENANCE_IN_PROGRESS" => Some(Self::MaintenanceInProgress),
                _ => None,
            }
        }
    }
}
/// Maintenance window as defined by Oracle.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/MaintenanceWindow>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaintenanceWindow {
    /// Optional. The maintenance window scheduling preference.
    #[prost(enumeration = "maintenance_window::MaintenanceWindowPreference", tag = "1")]
    pub preference: i32,
    /// Optional. Months during the year when maintenance should be performed.
    #[prost(
        enumeration = "super::super::super::r#type::Month",
        repeated,
        packed = "false",
        tag = "2"
    )]
    pub months: ::prost::alloc::vec::Vec<i32>,
    /// Optional. Weeks during the month when maintenance should be performed.
    /// Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a
    /// duration of 7 days. Weeks start and end based on calendar dates, not days
    /// of the week.
    #[prost(int32, repeated, packed = "false", tag = "3")]
    pub weeks_of_month: ::prost::alloc::vec::Vec<i32>,
    /// Optional. Days during the week when maintenance should be performed.
    #[prost(
        enumeration = "super::super::super::r#type::DayOfWeek",
        repeated,
        packed = "false",
        tag = "4"
    )]
    pub days_of_week: ::prost::alloc::vec::Vec<i32>,
    /// Optional. The window of hours during the day when maintenance should be
    /// performed. The window is a 4 hour slot. Valid values are:
    ///    0 - represents time slot 0:00 - 3:59 UTC
    ///    4 - represents time slot 4:00 - 7:59 UTC
    ///    8 - represents time slot 8:00 - 11:59 UTC
    ///    12 - represents time slot 12:00 - 15:59 UTC
    ///    16 - represents time slot 16:00 - 19:59 UTC
    ///    20 - represents time slot 20:00 - 23:59 UTC
    #[prost(int32, repeated, packed = "false", tag = "5")]
    pub hours_of_day: ::prost::alloc::vec::Vec<i32>,
    /// Optional. Lead time window allows user to set a lead time to prepare for a
    /// down time. The lead time is in weeks and valid value is between 1 to 4.
    #[prost(int32, tag = "6")]
    pub lead_time_week: i32,
    /// Optional. Cloud CloudExadataInfrastructure node patching method, either
    /// "ROLLING"
    ///   or "NONROLLING". Default value is ROLLING.
    #[prost(enumeration = "maintenance_window::PatchingMode", tag = "7")]
    pub patching_mode: i32,
    /// Optional. Determines the amount of time the system will wait before the
    /// start of each database server patching operation. Custom action timeout is
    /// in minutes and valid value is between 15 to 120 (inclusive).
    #[prost(int32, tag = "8")]
    pub custom_action_timeout_mins: i32,
    /// Optional. If true, enables the configuration of a custom action timeout
    /// (waiting period) between database server patching operations.
    #[prost(bool, tag = "9")]
    pub is_custom_action_timeout_enabled: bool,
}
/// Nested message and enum types in `MaintenanceWindow`.
pub mod maintenance_window {
    /// Maintenance window preference.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MaintenanceWindowPreference {
        /// Default unspecified value.
        Unspecified = 0,
        /// Custom preference.
        CustomPreference = 1,
        /// No preference.
        NoPreference = 2,
    }
    impl MaintenanceWindowPreference {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MAINTENANCE_WINDOW_PREFERENCE_UNSPECIFIED",
                Self::CustomPreference => "CUSTOM_PREFERENCE",
                Self::NoPreference => "NO_PREFERENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MAINTENANCE_WINDOW_PREFERENCE_UNSPECIFIED" => Some(Self::Unspecified),
                "CUSTOM_PREFERENCE" => Some(Self::CustomPreference),
                "NO_PREFERENCE" => Some(Self::NoPreference),
                _ => None,
            }
        }
    }
    /// Patching mode.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PatchingMode {
        /// Default unspecified value.
        Unspecified = 0,
        /// Updates the Cloud Exadata database server hosts in a rolling fashion.
        Rolling = 1,
        /// The non-rolling maintenance method first updates your storage servers at
        /// the same time, then your database servers at the same time.
        NonRolling = 2,
    }
    impl PatchingMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PATCHING_MODE_UNSPECIFIED",
                Self::Rolling => "ROLLING",
                Self::NonRolling => "NON_ROLLING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PATCHING_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "ROLLING" => Some(Self::Rolling),
                "NON_ROLLING" => Some(Self::NonRolling),
                _ => None,
            }
        }
    }
}
/// Details of the Oracle Grid Infrastructure (GI) version resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/GiVersionSummary/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GiVersion {
    /// Identifier. The name of the Oracle Grid Infrastructure (GI) version
    /// resource with the format:
    /// projects/{project}/locations/{region}/giVersions/{gi_versions}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. version
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
/// Metadata for a given [Location][google.cloud.location.Location].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationMetadata {
    /// Output only. Google Cloud Platform Oracle zones in a location.
    #[prost(string, repeated, tag = "2")]
    pub gcp_oracle_zones: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Details of the Cloud VM Cluster resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/CloudVmCluster/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudVmCluster {
    /// Identifier. The name of the VM Cluster resource with the format:
    /// projects/{project}/locations/{region}/cloudVmClusters/{cloud_vm_cluster}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The name of the Exadata Infrastructure resource on which VM
    /// cluster resource is created, in the following format:
    /// projects/{project}/locations/{region}/cloudExadataInfrastuctures/{cloud_extradata_infrastructure}
    #[prost(string, tag = "2")]
    pub exadata_infrastructure: ::prost::alloc::string::String,
    /// Optional. User friendly name for this resource.
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Google Cloud Platform location where Oracle Exadata is hosted.
    /// It is same as Google Cloud Platform Oracle zone of Exadata infrastructure.
    #[prost(string, tag = "12")]
    pub gcp_oracle_zone: ::prost::alloc::string::String,
    /// Optional. Various properties of the VM Cluster.
    #[prost(message, optional, tag = "6")]
    pub properties: ::core::option::Option<CloudVmClusterProperties>,
    /// Optional. Labels or tags associated with the VM Cluster.
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The date and time that the VM cluster was created.
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. Network settings. CIDR to use for cluster IP allocation.
    #[prost(string, tag = "9")]
    pub cidr: ::prost::alloc::string::String,
    /// Required. CIDR range of the backup subnet.
    #[prost(string, tag = "10")]
    pub backup_subnet_cidr: ::prost::alloc::string::String,
    /// Required. The name of the VPC network.
    /// Format: projects/{project}/global/networks/{network}
    #[prost(string, tag = "11")]
    pub network: ::prost::alloc::string::String,
}
/// Various properties and settings associated with Exadata VM cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudVmClusterProperties {
    /// Output only. Oracle Cloud Infrastructure ID of VM Cluster.
    #[prost(string, tag = "1")]
    pub ocid: ::prost::alloc::string::String,
    /// Required. License type of VM Cluster.
    #[prost(enumeration = "cloud_vm_cluster_properties::LicenseType", tag = "2")]
    pub license_type: i32,
    /// Optional. Grid Infrastructure Version.
    #[prost(string, tag = "3")]
    pub gi_version: ::prost::alloc::string::String,
    /// Optional. Time zone of VM Cluster to set. Defaults to UTC if not specified.
    #[prost(message, optional, tag = "4")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
    /// Optional. SSH public keys to be stored with cluster.
    #[prost(string, repeated, tag = "5")]
    pub ssh_public_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Number of database servers.
    #[prost(int32, tag = "6")]
    pub node_count: i32,
    /// Output only. Shape of VM Cluster.
    #[prost(string, tag = "7")]
    pub shape: ::prost::alloc::string::String,
    /// Optional. OCPU count per VM. Minimum is 0.1.
    #[prost(float, tag = "8")]
    pub ocpu_count: f32,
    /// Optional. Memory allocated in GBs.
    #[prost(int32, tag = "9")]
    pub memory_size_gb: i32,
    /// Optional. Local storage per VM.
    #[prost(int32, tag = "10")]
    pub db_node_storage_size_gb: i32,
    /// Output only. The storage allocation for the disk group, in gigabytes (GB).
    #[prost(int32, tag = "11")]
    pub storage_size_gb: i32,
    /// Optional. The data disk group size to be allocated in TBs.
    #[prost(double, tag = "12")]
    pub data_storage_size_tb: f64,
    /// Optional. The type of redundancy.
    #[prost(enumeration = "cloud_vm_cluster_properties::DiskRedundancy", tag = "13")]
    pub disk_redundancy: i32,
    /// Optional. Use exadata sparse snapshots.
    #[prost(bool, tag = "14")]
    pub sparse_diskgroup_enabled: bool,
    /// Optional. Use local backup.
    #[prost(bool, tag = "15")]
    pub local_backup_enabled: bool,
    /// Optional. Prefix for VM cluster host names.
    #[prost(string, tag = "16")]
    pub hostname_prefix: ::prost::alloc::string::String,
    /// Optional. Data collection options for diagnostics.
    #[prost(message, optional, tag = "19")]
    pub diagnostics_data_collection_options: ::core::option::Option<
        DataCollectionOptions,
    >,
    /// Output only. State of the cluster.
    #[prost(enumeration = "cloud_vm_cluster_properties::State", tag = "20")]
    pub state: i32,
    /// Output only. SCAN listener port - TCP
    #[prost(int32, tag = "21")]
    pub scan_listener_port_tcp: i32,
    /// Output only. SCAN listener port - TLS
    #[prost(int32, tag = "22")]
    pub scan_listener_port_tcp_ssl: i32,
    /// Output only. Parent DNS domain where SCAN DNS and hosts names are
    /// qualified. ex: ocispdelegated.ocisp10jvnet.oraclevcn.com
    #[prost(string, tag = "23")]
    pub domain: ::prost::alloc::string::String,
    /// Output only. SCAN DNS name.
    /// ex: sp2-yi0xq-scan.ocispdelegated.ocisp10jvnet.oraclevcn.com
    #[prost(string, tag = "24")]
    pub scan_dns: ::prost::alloc::string::String,
    /// Output only. host name without domain.
    /// format: "<hostname_prefix>-" with some suffix.
    /// ex: sp2-yi0xq where "sp2" is the hostname_prefix.
    #[prost(string, tag = "25")]
    pub hostname: ::prost::alloc::string::String,
    /// Required. Number of enabled CPU cores.
    #[prost(int32, tag = "26")]
    pub cpu_core_count: i32,
    /// Optional. Operating system version of the image.
    #[prost(string, tag = "27")]
    pub system_version: ::prost::alloc::string::String,
    /// Output only. OCIDs of scan IPs.
    #[prost(string, repeated, tag = "28")]
    pub scan_ip_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. OCID of scan DNS record.
    #[prost(string, tag = "29")]
    pub scan_dns_record_id: ::prost::alloc::string::String,
    /// Output only. Deep link to the OCI console to view this resource.
    #[prost(string, tag = "30")]
    pub oci_url: ::prost::alloc::string::String,
    /// Optional. OCID of database servers.
    #[prost(string, repeated, tag = "31")]
    pub db_server_ocids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. Compartment ID of cluster.
    #[prost(string, tag = "32")]
    pub compartment_id: ::prost::alloc::string::String,
    /// Output only. DNS listener IP.
    #[prost(string, tag = "35")]
    pub dns_listener_ip: ::prost::alloc::string::String,
    /// Optional. OCI Cluster name.
    #[prost(string, tag = "36")]
    pub cluster_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CloudVmClusterProperties`.
pub mod cloud_vm_cluster_properties {
    /// Different licenses supported.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LicenseType {
        /// Unspecified
        Unspecified = 0,
        /// License included part of offer
        LicenseIncluded = 1,
        /// Bring your own license
        BringYourOwnLicense = 2,
    }
    impl LicenseType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LICENSE_TYPE_UNSPECIFIED",
                Self::LicenseIncluded => "LICENSE_INCLUDED",
                Self::BringYourOwnLicense => "BRING_YOUR_OWN_LICENSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LICENSE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "LICENSE_INCLUDED" => Some(Self::LicenseIncluded),
                "BRING_YOUR_OWN_LICENSE" => Some(Self::BringYourOwnLicense),
                _ => None,
            }
        }
    }
    /// Types of disk redundancy provided by Oracle.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DiskRedundancy {
        /// Unspecified.
        Unspecified = 0,
        /// High -  3 way mirror.
        High = 1,
        /// Normal - 2 way mirror.
        Normal = 2,
    }
    impl DiskRedundancy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DISK_REDUNDANCY_UNSPECIFIED",
                Self::High => "HIGH",
                Self::Normal => "NORMAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DISK_REDUNDANCY_UNSPECIFIED" => Some(Self::Unspecified),
                "HIGH" => Some(Self::High),
                "NORMAL" => Some(Self::Normal),
                _ => None,
            }
        }
    }
    /// The various lifecycle states of the VM cluster.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default unspecified value.
        Unspecified = 0,
        /// Indicates that the resource is in provisioning state.
        Provisioning = 1,
        /// Indicates that the resource is in available state.
        Available = 2,
        /// Indicates that the resource is in updating state.
        Updating = 3,
        /// Indicates that the resource is in terminating state.
        Terminating = 4,
        /// Indicates that the resource is in terminated state.
        Terminated = 5,
        /// Indicates that the resource is in failed state.
        Failed = 6,
        /// Indicates that the resource is in maintenance in progress state.
        MaintenanceInProgress = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Available => "AVAILABLE",
                Self::Updating => "UPDATING",
                Self::Terminating => "TERMINATING",
                Self::Terminated => "TERMINATED",
                Self::Failed => "FAILED",
                Self::MaintenanceInProgress => "MAINTENANCE_IN_PROGRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "AVAILABLE" => Some(Self::Available),
                "UPDATING" => Some(Self::Updating),
                "TERMINATING" => Some(Self::Terminating),
                "TERMINATED" => Some(Self::Terminated),
                "FAILED" => Some(Self::Failed),
                "MAINTENANCE_IN_PROGRESS" => Some(Self::MaintenanceInProgress),
                _ => None,
            }
        }
    }
}
/// Data collection options for diagnostics.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DataCollectionOptions {
    /// Optional. Indicates whether diagnostic collection is enabled for the VM
    /// cluster
    #[prost(bool, tag = "1")]
    pub diagnostics_events_enabled: bool,
    /// Optional. Indicates whether health monitoring is enabled for the VM cluster
    #[prost(bool, tag = "2")]
    pub health_monitoring_enabled: bool,
    /// Optional. Indicates whether incident logs and trace collection are enabled
    /// for the VM cluster
    #[prost(bool, tag = "3")]
    pub incident_logs_enabled: bool,
}
/// The request for `CloudExadataInfrastructures.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCloudExadataInfrastructuresRequest {
    /// Required. The parent value for CloudExadataInfrastructure in the following
    /// format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Exadata infrastructures will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for `CloudExadataInfrastructures.list`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCloudExadataInfrastructuresResponse {
    /// The list of Exadata Infrastructures.
    #[prost(message, repeated, tag = "1")]
    pub cloud_exadata_infrastructures: ::prost::alloc::vec::Vec<
        CloudExadataInfrastructure,
    >,
    /// A token for fetching next page of response.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `CloudExadataInfrastructure.Get`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCloudExadataInfrastructureRequest {
    /// Required. The name of the Cloud Exadata Infrastructure in the following
    /// format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for `CloudExadataInfrastructure.Create`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCloudExadataInfrastructureRequest {
    /// Required. The parent value for CloudExadataInfrastructure in the following
    /// format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID of the Exadata Infrastructure to create. This value is
    /// restricted to (^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    #[prost(string, tag = "2")]
    pub cloud_exadata_infrastructure_id: ::prost::alloc::string::String,
    /// Required. Details of the Exadata Infrastructure instance to create.
    #[prost(message, optional, tag = "3")]
    pub cloud_exadata_infrastructure: ::core::option::Option<CloudExadataInfrastructure>,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `CloudExadataInfrastructure.Delete`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCloudExadataInfrastructureRequest {
    /// Required. The name of the Cloud Exadata Infrastructure in the following
    /// format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional. If set to true, all VM clusters for this Exadata Infrastructure
    /// will be deleted. An Exadata Infrastructure can only be deleted once all its
    /// VM clusters have been deleted.
    #[prost(bool, tag = "3")]
    pub force: bool,
}
/// The request for `CloudVmCluster.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCloudVmClustersRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The number of VM clusters to return.
    /// If unspecified, at most 50 VM clusters will be returned.
    /// The maximum value is 1,000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying the page of results the server returns.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response for `CloudVmCluster.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCloudVmClustersResponse {
    /// The list of VM Clusters.
    #[prost(message, repeated, tag = "1")]
    pub cloud_vm_clusters: ::prost::alloc::vec::Vec<CloudVmCluster>,
    /// A token to fetch the next page of results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `CloudVmCluster.Get`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCloudVmClusterRequest {
    /// Required. The name of the Cloud VM Cluster in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for `CloudVmCluster.Create`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCloudVmClusterRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID of the VM Cluster to create. This value is restricted
    /// to (^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$) and must be a maximum of 63
    /// characters in length. The value must start with a letter and end with
    /// a letter or a number.
    #[prost(string, tag = "2")]
    pub cloud_vm_cluster_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub cloud_vm_cluster: ::core::option::Option<CloudVmCluster>,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `CloudVmCluster.Delete`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCloudVmClusterRequest {
    /// Required. The name of the Cloud VM Cluster in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional. If set to true, all child resources for the VM Cluster will be
    /// deleted. A VM Cluster can only be deleted once all its child resources have
    /// been deleted.
    #[prost(bool, tag = "3")]
    pub force: bool,
}
/// The request for `Entitlement.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntitlementsRequest {
    /// Required. The parent value for the entitlement in the following format:
    /// projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 entitlements will be returned.
    /// The maximum value is 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for `Entitlement.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntitlementsResponse {
    /// The list of Entitlements
    #[prost(message, repeated, tag = "1")]
    pub entitlements: ::prost::alloc::vec::Vec<Entitlement>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `DbServer.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDbServersRequest {
    /// Required. The parent value for database server in the following format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloudExadataInfrastructure}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 db servers will be returned.
    /// The maximum value is 1000; values above 1000 will be reset to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for `DbServer.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDbServersResponse {
    /// The list of database servers.
    #[prost(message, repeated, tag = "1")]
    pub db_servers: ::prost::alloc::vec::Vec<DbServer>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `DbNode.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDbNodesRequest {
    /// Required. The parent value for database node in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloudVmCluster}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 db nodes will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the node should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for `DbNode.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDbNodesResponse {
    /// The list of DB Nodes
    #[prost(message, repeated, tag = "1")]
    pub db_nodes: ::prost::alloc::vec::Vec<DbNode>,
    /// A token identifying a page of results the node should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `GiVersion.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGiVersionsRequest {
    /// Required. The parent value for Grid Infrastructure Version in the following
    /// format: Format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 Oracle Grid Infrastructure (GI) versions
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// reset to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for `GiVersion.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGiVersionsResponse {
    /// The list of Oracle Grid Infrastructure (GI) versions.
    #[prost(message, repeated, tag = "1")]
    pub gi_versions: ::prost::alloc::vec::Vec<GiVersion>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `DbSystemShape.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDbSystemShapesRequest {
    /// Required. The parent value for Database System Shapes in the following
    /// format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 database system shapes will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for `DbSystemShape.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDbSystemShapesResponse {
    /// The list of Database System shapes.
    #[prost(message, repeated, tag = "1")]
    pub db_system_shapes: ::prost::alloc::vec::Vec<DbSystemShape>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Represents the metadata of the long-running operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. The status of the operation.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
    /// Output only. An estimated percentage of the operation that has been
    /// completed at a given moment of time, between 0 and 100.
    #[prost(double, tag = "8")]
    pub percent_complete: f64,
}
/// The request for `AutonomousDatabase.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutonomousDatabasesRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous Database will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. An expression for ordering the results of the request.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response for `AutonomousDatabase.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutonomousDatabasesResponse {
    /// The list of Autonomous Databases.
    #[prost(message, repeated, tag = "1")]
    pub autonomous_databases: ::prost::alloc::vec::Vec<AutonomousDatabase>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `AutonomousDatabase.Get`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for `AutonomousDatabase.Create`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAutonomousDatabaseRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID of the Autonomous Database to create. This value is
    /// restricted to (^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    #[prost(string, tag = "2")]
    pub autonomous_database_id: ::prost::alloc::string::String,
    /// Required. The Autonomous Database being created.
    #[prost(message, optional, tag = "3")]
    pub autonomous_database: ::core::option::Option<AutonomousDatabase>,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `AutonomousDatabase.Delete`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAutonomousDatabaseRequest {
    /// Required. The name of the resource in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `AutonomousDatabase.Restore`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The time and date to restore the database to.
    #[prost(message, optional, tag = "2")]
    pub restore_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// The request for `AutonomousDatabase.GenerateWallet`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateAutonomousDatabaseWalletRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The type of wallet generation for the Autonomous Database. The
    /// default value is SINGLE.
    #[prost(enumeration = "GenerateType", tag = "2")]
    pub r#type: i32,
    /// Optional. True when requesting regional connection strings in PDB connect
    /// info, applicable to cross-region Data Guard only.
    #[prost(bool, tag = "3")]
    pub is_regional: bool,
    /// Required. The password used to encrypt the keys inside the wallet. The
    /// password must be a minimum of 8 characters.
    #[prost(string, tag = "4")]
    pub password: ::prost::alloc::string::String,
}
/// The response for `AutonomousDatabase.GenerateWallet`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateAutonomousDatabaseWalletResponse {
    /// Output only. The base64 encoded wallet files.
    #[prost(bytes = "vec", tag = "1")]
    pub archive_content: ::prost::alloc::vec::Vec<u8>,
}
/// The request for `AutonomousDbVersion.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutonomousDbVersionsRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Versions will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for `AutonomousDbVersion.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutonomousDbVersionsResponse {
    /// The list of Autonomous Database versions.
    #[prost(message, repeated, tag = "1")]
    pub autonomous_db_versions: ::prost::alloc::vec::Vec<AutonomousDbVersion>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `AutonomousDatabaseCharacterSet.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutonomousDatabaseCharacterSetsRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Character Sets will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request. Only the
    /// **character_set_type** field is supported in the following format:
    /// `character_set_type="{characterSetType}"`. Accepted values include
    /// `DATABASE` and `NATIONAL`.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response for `AutonomousDatabaseCharacterSet.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutonomousDatabaseCharacterSetsResponse {
    /// The list of Autonomous Database Character Sets.
    #[prost(message, repeated, tag = "1")]
    pub autonomous_database_character_sets: ::prost::alloc::vec::Vec<
        AutonomousDatabaseCharacterSet,
    >,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `AutonomousDatabaseBackup.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutonomousDatabaseBackupsRequest {
    /// Required. The parent value for ListAutonomousDatabaseBackups in the
    /// following format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request. Only the
    /// **autonomous_database_id** field is supported in the following format:
    /// `autonomous_database_id="{autonomous_database_id}"`. The accepted values
    /// must be a valid Autonomous Database ID, limited to the naming
    /// restrictions of the ID: ^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$).
    /// The ID must start with a letter, end with a letter or a number, and be
    /// a maximum of 63 characters.
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Backups will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for `AutonomousDatabaseBackup.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutonomousDatabaseBackupsResponse {
    /// The list of Autonomous Database Backups.
    #[prost(message, repeated, tag = "1")]
    pub autonomous_database_backups: ::prost::alloc::vec::Vec<AutonomousDatabaseBackup>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod oracle_database_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing handlers for resources
    #[derive(Debug, Clone)]
    pub struct OracleDatabaseClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl OracleDatabaseClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> OracleDatabaseClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> OracleDatabaseClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            OracleDatabaseClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists Exadata Infrastructures in a given project and location.
        pub async fn list_cloud_exadata_infrastructures(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListCloudExadataInfrastructuresRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListCloudExadataInfrastructuresResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListCloudExadataInfrastructures",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListCloudExadataInfrastructures",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Exadata Infrastructure.
        pub async fn get_cloud_exadata_infrastructure(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCloudExadataInfrastructureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CloudExadataInfrastructure>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/GetCloudExadataInfrastructure",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "GetCloudExadataInfrastructure",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Exadata Infrastructure in a given project and location.
        pub async fn create_cloud_exadata_infrastructure(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateCloudExadataInfrastructureRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/CreateCloudExadataInfrastructure",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "CreateCloudExadataInfrastructure",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Exadata Infrastructure.
        pub async fn delete_cloud_exadata_infrastructure(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteCloudExadataInfrastructureRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/DeleteCloudExadataInfrastructure",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "DeleteCloudExadataInfrastructure",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the VM Clusters in a given project and location.
        pub async fn list_cloud_vm_clusters(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCloudVmClustersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCloudVmClustersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListCloudVmClusters",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListCloudVmClusters",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single VM Cluster.
        pub async fn get_cloud_vm_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCloudVmClusterRequest>,
        ) -> std::result::Result<tonic::Response<super::CloudVmCluster>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/GetCloudVmCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "GetCloudVmCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new VM Cluster in a given project and location.
        pub async fn create_cloud_vm_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCloudVmClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/CreateCloudVmCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "CreateCloudVmCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single VM Cluster.
        pub async fn delete_cloud_vm_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCloudVmClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/DeleteCloudVmCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "DeleteCloudVmCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the entitlements in a given project.
        pub async fn list_entitlements(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEntitlementsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEntitlementsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListEntitlements",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListEntitlements",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the database servers of an Exadata Infrastructure instance.
        pub async fn list_db_servers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDbServersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDbServersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListDbServers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListDbServers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the database nodes of a VM Cluster.
        pub async fn list_db_nodes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDbNodesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDbNodesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListDbNodes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListDbNodes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the valid Oracle Grid Infrastructure (GI) versions for the given
        /// project and location.
        pub async fn list_gi_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListGiVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListGiVersionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListGiVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListGiVersions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the database system shapes available for the project and location.
        pub async fn list_db_system_shapes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDbSystemShapesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDbSystemShapesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListDbSystemShapes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListDbSystemShapes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the Autonomous Databases in a given project and location.
        pub async fn list_autonomous_databases(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAutonomousDatabasesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAutonomousDatabasesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListAutonomousDatabases",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListAutonomousDatabases",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the details of a single Autonomous Database.
        pub async fn get_autonomous_database(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAutonomousDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AutonomousDatabase>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/GetAutonomousDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "GetAutonomousDatabase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Autonomous Database in a given project and location.
        pub async fn create_autonomous_database(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAutonomousDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/CreateAutonomousDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "CreateAutonomousDatabase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Autonomous Database.
        pub async fn delete_autonomous_database(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAutonomousDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/DeleteAutonomousDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "DeleteAutonomousDatabase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Restores a single Autonomous Database.
        pub async fn restore_autonomous_database(
            &mut self,
            request: impl tonic::IntoRequest<super::RestoreAutonomousDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/RestoreAutonomousDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "RestoreAutonomousDatabase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generates a wallet for an Autonomous Database.
        pub async fn generate_autonomous_database_wallet(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GenerateAutonomousDatabaseWalletRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::GenerateAutonomousDatabaseWalletResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/GenerateAutonomousDatabaseWallet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "GenerateAutonomousDatabaseWallet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the available Autonomous Database versions for a project and
        /// location.
        pub async fn list_autonomous_db_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAutonomousDbVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAutonomousDbVersionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListAutonomousDbVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListAutonomousDbVersions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Autonomous Database Character Sets in a given project and location.
        pub async fn list_autonomous_database_character_sets(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListAutonomousDatabaseCharacterSetsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListAutonomousDatabaseCharacterSetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListAutonomousDatabaseCharacterSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListAutonomousDatabaseCharacterSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the long-term and automatic backups of an Autonomous Database.
        pub async fn list_autonomous_database_backups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAutonomousDatabaseBackupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAutonomousDatabaseBackupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListAutonomousDatabaseBackups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListAutonomousDatabaseBackups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
