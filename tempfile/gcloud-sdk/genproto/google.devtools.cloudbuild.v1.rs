// This file is @generated by prost-build.
/// Specifies a build to retry.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetryBuildRequest {
    /// The name of the `Build` to retry.
    /// Format: `projects/{project}/locations/{location}/builds/{build}`
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Required. ID of the project.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. Build ID of the original build.
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
}
/// Specifies a build trigger to run and the source to use.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunBuildTriggerRequest {
    /// The name of the `Trigger` to run.
    /// Format: `projects/{project}/locations/{location}/triggers/{trigger}`
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    /// Required. ID of the project.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. ID of the trigger.
    #[prost(string, tag = "2")]
    pub trigger_id: ::prost::alloc::string::String,
    /// Source to build against this trigger.
    /// Branch and tag names cannot consist of regular expressions.
    #[prost(message, optional, tag = "3")]
    pub source: ::core::option::Option<RepoSource>,
}
/// Location of the source in an archive file in Cloud Storage.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageSource {
    /// Cloud Storage bucket containing the source (see
    /// [Bucket Name
    /// Requirements](<https://cloud.google.com/storage/docs/bucket-naming#requirements>)).
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
    /// Cloud Storage object containing the source.
    ///
    /// This object must be a zipped (`.zip`) or gzipped archive file (`.tar.gz`)
    /// containing source to build.
    #[prost(string, tag = "2")]
    pub object: ::prost::alloc::string::String,
    /// Cloud Storage generation for the object. If the generation is
    /// omitted, the latest generation will be used.
    #[prost(int64, tag = "3")]
    pub generation: i64,
    /// Option to specify the tool to fetch the source file for the build.
    #[prost(enumeration = "storage_source::SourceFetcher", tag = "5")]
    pub source_fetcher: i32,
}
/// Nested message and enum types in `StorageSource`.
pub mod storage_source {
    /// Specifies the tool to fetch the source file for the build.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SourceFetcher {
        /// Unspecified. Defaults to GSUTIL.
        Unspecified = 0,
        /// Use the "gsutil" tool to download the source file.
        Gsutil = 1,
        /// Use the Cloud Storage Fetcher tool to download the source file.
        GcsFetcher = 2,
    }
    impl SourceFetcher {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SOURCE_FETCHER_UNSPECIFIED",
                Self::Gsutil => "GSUTIL",
                Self::GcsFetcher => "GCS_FETCHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SOURCE_FETCHER_UNSPECIFIED" => Some(Self::Unspecified),
                "GSUTIL" => Some(Self::Gsutil),
                "GCS_FETCHER" => Some(Self::GcsFetcher),
                _ => None,
            }
        }
    }
}
/// Location of the source in any accessible Git repository.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitSource {
    /// Location of the Git repo to build.
    ///
    /// This will be used as a `git remote`, see
    /// <https://git-scm.com/docs/git-remote.>
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// Directory, relative to the source root, in which to run the build.
    ///
    /// This must be a relative path. If a step's `dir` is specified and is an
    /// absolute path, this value is ignored for that step's execution.
    #[prost(string, tag = "5")]
    pub dir: ::prost::alloc::string::String,
    /// The revision to fetch from the Git repository such as a branch, a tag, a
    /// commit SHA, or any Git ref.
    ///
    /// Cloud Build uses `git fetch` to fetch the revision from the Git
    /// repository; therefore make sure that the string you provide for `revision`
    /// is parsable  by the command. For information on string values accepted by
    /// `git fetch`, see
    /// <https://git-scm.com/docs/gitrevisions#_specifying_revisions.> For
    /// information on `git fetch`, see <https://git-scm.com/docs/git-fetch.>
    #[prost(string, tag = "6")]
    pub revision: ::prost::alloc::string::String,
}
/// Location of the source in a Google Cloud Source Repository.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepoSource {
    /// ID of the project that owns the Cloud Source Repository. If omitted, the
    /// project ID requesting the build is assumed.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Name of the Cloud Source Repository.
    #[prost(string, tag = "2")]
    pub repo_name: ::prost::alloc::string::String,
    /// Directory, relative to the source root, in which to run the build.
    ///
    /// This must be a relative path. If a step's `dir` is specified and is an
    /// absolute path, this value is ignored for that step's execution.
    #[prost(string, tag = "7")]
    pub dir: ::prost::alloc::string::String,
    /// Only trigger a build if the revision regex does NOT match the revision
    /// regex.
    #[prost(bool, tag = "8")]
    pub invert_regex: bool,
    /// Substitutions to use in a triggered build.
    /// Should only be used with RunBuildTrigger
    #[prost(map = "string, string", tag = "9")]
    pub substitutions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// A revision within the Cloud Source Repository must be specified in
    /// one of these ways.
    #[prost(oneof = "repo_source::Revision", tags = "3, 4, 5")]
    pub revision: ::core::option::Option<repo_source::Revision>,
}
/// Nested message and enum types in `RepoSource`.
pub mod repo_source {
    /// A revision within the Cloud Source Repository must be specified in
    /// one of these ways.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Revision {
        /// Regex matching branches to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        #[prost(string, tag = "3")]
        BranchName(::prost::alloc::string::String),
        /// Regex matching tags to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        #[prost(string, tag = "4")]
        TagName(::prost::alloc::string::String),
        /// Explicit commit SHA to build.
        #[prost(string, tag = "5")]
        CommitSha(::prost::alloc::string::String),
    }
}
/// Location of the source manifest in Cloud Storage.
/// This feature is in Preview; see description
/// [here](<https://github.com/GoogleCloudPlatform/cloud-builders/tree/master/gcs-fetcher>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageSourceManifest {
    /// Cloud Storage bucket containing the source manifest (see [Bucket
    /// Name
    /// Requirements](<https://cloud.google.com/storage/docs/bucket-naming#requirements>)).
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
    /// Cloud Storage object containing the source manifest.
    ///
    /// This object must be a JSON file.
    #[prost(string, tag = "2")]
    pub object: ::prost::alloc::string::String,
    /// Cloud Storage generation for the object. If the generation is
    /// omitted, the latest generation will be used.
    #[prost(int64, tag = "3")]
    pub generation: i64,
}
/// Location of the source in a supported storage service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Source {
    /// Location of source.
    #[prost(oneof = "source::Source", tags = "2, 3, 5, 8")]
    pub source: ::core::option::Option<source::Source>,
}
/// Nested message and enum types in `Source`.
pub mod source {
    /// Location of source.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// If provided, get the source from this location in Cloud Storage.
        #[prost(message, tag = "2")]
        StorageSource(super::StorageSource),
        /// If provided, get the source from this location in a Cloud Source
        /// Repository.
        #[prost(message, tag = "3")]
        RepoSource(super::RepoSource),
        /// If provided, get the source from this Git repository.
        #[prost(message, tag = "5")]
        GitSource(super::GitSource),
        /// If provided, get the source from this manifest in Cloud Storage.
        /// This feature is in Preview; see description
        /// [here](<https://github.com/GoogleCloudPlatform/cloud-builders/tree/master/gcs-fetcher>).
        #[prost(message, tag = "8")]
        StorageSourceManifest(super::StorageSourceManifest),
    }
}
/// An image built by the pipeline.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuiltImage {
    /// Name used to push the container image to Google Container Registry, as
    /// presented to `docker push`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Docker Registry 2.0 digest.
    #[prost(string, tag = "3")]
    pub digest: ::prost::alloc::string::String,
    /// Output only. Stores timing information for pushing the specified image.
    #[prost(message, optional, tag = "4")]
    pub push_timing: ::core::option::Option<TimeSpan>,
}
/// Artifact uploaded using the PythonPackage directive.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadedPythonPackage {
    /// URI of the uploaded artifact.
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    /// Hash types and values of the Python Artifact.
    #[prost(message, optional, tag = "2")]
    pub file_hashes: ::core::option::Option<FileHashes>,
    /// Output only. Stores timing information for pushing the specified artifact.
    #[prost(message, optional, tag = "3")]
    pub push_timing: ::core::option::Option<TimeSpan>,
}
/// A Maven artifact uploaded using the MavenArtifact directive.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadedMavenArtifact {
    /// URI of the uploaded artifact.
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    /// Hash types and values of the Maven Artifact.
    #[prost(message, optional, tag = "2")]
    pub file_hashes: ::core::option::Option<FileHashes>,
    /// Output only. Stores timing information for pushing the specified artifact.
    #[prost(message, optional, tag = "3")]
    pub push_timing: ::core::option::Option<TimeSpan>,
}
/// A Go module artifact uploaded to Artifact Registry using the GoModule
/// directive.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadedGoModule {
    /// URI of the uploaded artifact.
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    /// Hash types and values of the Go Module Artifact.
    #[prost(message, optional, tag = "2")]
    pub file_hashes: ::core::option::Option<FileHashes>,
    /// Output only. Stores timing information for pushing the specified artifact.
    #[prost(message, optional, tag = "3")]
    pub push_timing: ::core::option::Option<TimeSpan>,
}
/// An npm package uploaded to Artifact Registry using the NpmPackage
/// directive.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadedNpmPackage {
    /// URI of the uploaded npm package.
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    /// Hash types and values of the npm package.
    #[prost(message, optional, tag = "2")]
    pub file_hashes: ::core::option::Option<FileHashes>,
    /// Output only. Stores timing information for pushing the specified artifact.
    #[prost(message, optional, tag = "3")]
    pub push_timing: ::core::option::Option<TimeSpan>,
}
/// A step in the build pipeline.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildStep {
    /// Required. The name of the container image that will run this particular
    /// build step.
    ///
    /// If the image is available in the host's Docker daemon's cache, it
    /// will be run directly. If not, the host will attempt to pull the image
    /// first, using the builder service account's credentials if necessary.
    ///
    /// The Docker daemon's cache will already have the latest versions of all of
    /// the officially supported build steps
    /// ([<https://github.com/GoogleCloudPlatform/cloud-builders](https://github.com/GoogleCloudPlatform/cloud-builders>)).
    /// The Docker daemon will also have cached many of the layers for some popular
    /// images, like "ubuntu", "debian", but they will be refreshed at the time you
    /// attempt to use them.
    ///
    /// If you built an image in a previous build step, it will be stored in the
    /// host's Docker daemon's cache and is available to use as the name for a
    /// later build step.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// A list of environment variable definitions to be used when running a step.
    ///
    /// The elements are of the form "KEY=VALUE" for the environment variable "KEY"
    /// being given the value "VALUE".
    #[prost(string, repeated, tag = "2")]
    pub env: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A list of arguments that will be presented to the step when it is started.
    ///
    /// If the image used to run the step's container has an entrypoint, the `args`
    /// are used as arguments to that entrypoint. If the image does not define
    /// an entrypoint, the first element in args is used as the entrypoint,
    /// and the remainder will be used as arguments.
    #[prost(string, repeated, tag = "3")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Working directory to use when running this step's container.
    ///
    /// If this value is a relative path, it is relative to the build's working
    /// directory. If this value is absolute, it may be outside the build's working
    /// directory, in which case the contents of the path may not be persisted
    /// across build step executions, unless a `volume` for that path is specified.
    ///
    /// If the build specifies a `RepoSource` with `dir` and a step with a `dir`,
    /// which specifies an absolute path, the `RepoSource` `dir` is ignored for
    /// the step's execution.
    #[prost(string, tag = "4")]
    pub dir: ::prost::alloc::string::String,
    /// Unique identifier for this build step, used in `wait_for` to
    /// reference this build step as a dependency.
    #[prost(string, tag = "5")]
    pub id: ::prost::alloc::string::String,
    /// The ID(s) of the step(s) that this build step depends on.
    /// This build step will not start until all the build steps in `wait_for`
    /// have completed successfully. If `wait_for` is empty, this build step will
    /// start when all previous build steps in the `Build.Steps` list have
    /// completed successfully.
    #[prost(string, repeated, tag = "6")]
    pub wait_for: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Entrypoint to be used instead of the build step image's default entrypoint.
    /// If unset, the image's default entrypoint is used.
    #[prost(string, tag = "7")]
    pub entrypoint: ::prost::alloc::string::String,
    /// A list of environment variables which are encrypted using a Cloud Key
    /// Management Service crypto key. These values must be specified in the
    /// build's `Secret`.
    #[prost(string, repeated, tag = "8")]
    pub secret_env: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of volumes to mount into the build step.
    ///
    /// Each volume is created as an empty volume prior to execution of the
    /// build step. Upon completion of the build, volumes and their contents are
    /// discarded.
    ///
    /// Using a named volume in only one step is not valid as it is indicative
    /// of a build request with an incorrect configuration.
    #[prost(message, repeated, tag = "9")]
    pub volumes: ::prost::alloc::vec::Vec<Volume>,
    /// Output only. Stores timing information for executing this build step.
    #[prost(message, optional, tag = "10")]
    pub timing: ::core::option::Option<TimeSpan>,
    /// Output only. Stores timing information for pulling this build step's
    /// builder image only.
    #[prost(message, optional, tag = "13")]
    pub pull_timing: ::core::option::Option<TimeSpan>,
    /// Time limit for executing this build step. If not defined, the step has no
    /// time limit and will be allowed to continue to run until either it completes
    /// or the build itself times out.
    #[prost(message, optional, tag = "11")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    /// Output only. Status of the build step. At this time, build step status is
    /// only updated on build completion; step status is not updated in real-time
    /// as the build progresses.
    #[prost(enumeration = "build::Status", tag = "12")]
    pub status: i32,
    /// Allow this build step to fail without failing the entire build.
    ///
    /// If false, the entire build will fail if this step fails. Otherwise, the
    /// build will succeed, but this step will still have a failure status.
    /// Error information will be reported in the failure_detail field.
    #[prost(bool, tag = "14")]
    pub allow_failure: bool,
    /// Output only. Return code from running the step.
    #[prost(int32, tag = "16")]
    pub exit_code: i32,
    /// Allow this build step to fail without failing the entire build if and
    /// only if the exit code is one of the specified codes. If allow_failure
    /// is also specified, this field will take precedence.
    #[prost(int32, repeated, tag = "18")]
    pub allow_exit_codes: ::prost::alloc::vec::Vec<i32>,
    /// A shell script to be executed in the step.
    ///
    /// When script is provided, the user cannot specify the entrypoint or args.
    #[prost(string, tag = "19")]
    pub script: ::prost::alloc::string::String,
    /// Option to include built-in and custom substitutions as env variables
    /// for this build step. This option will override the global option
    /// in BuildOption.
    #[prost(bool, optional, tag = "20")]
    pub automap_substitutions: ::core::option::Option<bool>,
}
/// Volume describes a Docker container volume which is mounted into build steps
/// in order to persist files across build step execution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Volume {
    /// Name of the volume to mount.
    ///
    /// Volume names must be unique per build step and must be valid names for
    /// Docker volumes. Each named volume must be used by at least two build steps.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Path at which to mount the volume.
    ///
    /// Paths must be absolute and cannot conflict with other volume paths on the
    /// same build step or with certain reserved volume paths.
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
}
/// Artifacts created by the build pipeline.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Results {
    /// Container images that were built as a part of the build.
    #[prost(message, repeated, tag = "2")]
    pub images: ::prost::alloc::vec::Vec<BuiltImage>,
    /// List of build step digests, in the order corresponding to build step
    /// indices.
    #[prost(string, repeated, tag = "3")]
    pub build_step_images: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Path to the artifact manifest for non-container artifacts uploaded to Cloud
    /// Storage. Only populated when artifacts are uploaded to Cloud Storage.
    #[prost(string, tag = "4")]
    pub artifact_manifest: ::prost::alloc::string::String,
    /// Number of non-container artifacts uploaded to Cloud Storage. Only populated
    /// when artifacts are uploaded to Cloud Storage.
    #[prost(int64, tag = "5")]
    pub num_artifacts: i64,
    /// List of build step outputs, produced by builder images, in the order
    /// corresponding to build step indices.
    ///
    /// [Cloud Builders](<https://cloud.google.com/cloud-build/docs/cloud-builders>)
    /// can produce this output by writing to `$BUILDER_OUTPUT/output`.
    /// Only the first 4KB of data is stored.
    #[prost(bytes = "vec", repeated, tag = "6")]
    pub build_step_outputs: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Time to push all non-container artifacts to Cloud Storage.
    #[prost(message, optional, tag = "7")]
    pub artifact_timing: ::core::option::Option<TimeSpan>,
    /// Python artifacts uploaded to Artifact Registry at the end of the build.
    #[prost(message, repeated, tag = "8")]
    pub python_packages: ::prost::alloc::vec::Vec<UploadedPythonPackage>,
    /// Maven artifacts uploaded to Artifact Registry at the end of the build.
    #[prost(message, repeated, tag = "9")]
    pub maven_artifacts: ::prost::alloc::vec::Vec<UploadedMavenArtifact>,
    /// Optional. Go module artifacts uploaded to Artifact Registry at the end of
    /// the build.
    #[prost(message, repeated, tag = "10")]
    pub go_modules: ::prost::alloc::vec::Vec<UploadedGoModule>,
    /// Npm packages uploaded to Artifact Registry at the end of the build.
    #[prost(message, repeated, tag = "12")]
    pub npm_packages: ::prost::alloc::vec::Vec<UploadedNpmPackage>,
}
/// An artifact that was uploaded during a build. This
/// is a single record in the artifact manifest JSON file.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArtifactResult {
    /// The path of an artifact in a Cloud Storage bucket, with the
    /// generation number. For example,
    /// `gs://mybucket/path/to/output.jar#generation`.
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
    /// The file hash of the artifact.
    #[prost(message, repeated, tag = "2")]
    pub file_hash: ::prost::alloc::vec::Vec<FileHashes>,
}
/// A build resource in the Cloud Build API.
///
/// At a high level, a `Build` describes where to find source code, how to build
/// it (for example, the builder image to run on the source), and where to store
/// the built artifacts.
///
/// Fields can include the following variables, which will be expanded when the
/// build is created:
///
/// - $PROJECT_ID: the project ID of the build.
/// - $PROJECT_NUMBER: the project number of the build.
/// - $LOCATION: the location/region of the build.
/// - $BUILD_ID: the autogenerated ID of the build.
/// - $REPO_NAME: the source repository name specified by RepoSource.
/// - $BRANCH_NAME: the branch name specified by RepoSource.
/// - $TAG_NAME: the tag name specified by RepoSource.
/// - $REVISION_ID or $COMMIT_SHA: the commit SHA specified by RepoSource or
///    resolved from the specified branch or tag.
/// - $SHORT_SHA: first 7 characters of $REVISION_ID or $COMMIT_SHA.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Build {
    /// Output only. The 'Build' name with format:
    /// `projects/{project}/locations/{location}/builds/{build}`, where {build}
    /// is a unique identifier generated by the service.
    #[prost(string, tag = "45")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Unique identifier of the build.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Output only. ID of the project.
    #[prost(string, tag = "16")]
    pub project_id: ::prost::alloc::string::String,
    /// Output only. Status of the build.
    #[prost(enumeration = "build::Status", tag = "2")]
    pub status: i32,
    /// Output only. Customer-readable message about the current status.
    #[prost(string, tag = "24")]
    pub status_detail: ::prost::alloc::string::String,
    /// The location of the source files to build.
    #[prost(message, optional, tag = "3")]
    pub source: ::core::option::Option<Source>,
    /// Required. The operations to be performed on the workspace.
    #[prost(message, repeated, tag = "11")]
    pub steps: ::prost::alloc::vec::Vec<BuildStep>,
    /// Output only. Results of the build.
    #[prost(message, optional, tag = "10")]
    pub results: ::core::option::Option<Results>,
    /// Output only. Time at which the request to create the build was received.
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time at which execution of the build was started.
    #[prost(message, optional, tag = "7")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time at which execution of the build was finished.
    ///
    /// The difference between finish_time and start_time is the duration of the
    /// build's execution.
    #[prost(message, optional, tag = "8")]
    pub finish_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Amount of time that this build should be allowed to run, to second
    /// granularity. If this amount of time elapses, work on the build will cease
    /// and the build status will be `TIMEOUT`.
    ///
    /// `timeout` starts ticking from `startTime`.
    ///
    /// Default time is 60 minutes.
    #[prost(message, optional, tag = "12")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    /// A list of images to be pushed upon the successful completion of all build
    /// steps.
    ///
    /// The images are pushed using the builder service account's credentials.
    ///
    /// The digests of the pushed images will be stored in the `Build` resource's
    /// results field.
    ///
    /// If any of the images fail to be pushed, the build status is marked
    /// `FAILURE`.
    #[prost(string, repeated, tag = "13")]
    pub images: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// TTL in queue for this build. If provided and the build is enqueued longer
    /// than this value, the build will expire and the build status will be
    /// `EXPIRED`.
    ///
    /// The TTL starts ticking from create_time.
    #[prost(message, optional, tag = "40")]
    pub queue_ttl: ::core::option::Option<::prost_types::Duration>,
    /// Artifacts produced by the build that should be uploaded upon
    /// successful completion of all build steps.
    #[prost(message, optional, tag = "37")]
    pub artifacts: ::core::option::Option<Artifacts>,
    /// Cloud Storage bucket where logs should be written (see
    /// [Bucket Name
    /// Requirements](<https://cloud.google.com/storage/docs/bucket-naming#requirements>)).
    /// Logs file names will be of the format `${logs_bucket}/log-${build_id}.txt`.
    #[prost(string, tag = "19")]
    pub logs_bucket: ::prost::alloc::string::String,
    /// Output only. A permanent fixed identifier for source.
    #[prost(message, optional, tag = "21")]
    pub source_provenance: ::core::option::Option<SourceProvenance>,
    /// Output only. The ID of the `BuildTrigger` that triggered this build, if it
    /// was triggered automatically.
    #[prost(string, tag = "22")]
    pub build_trigger_id: ::prost::alloc::string::String,
    /// Special options for this build.
    #[prost(message, optional, tag = "23")]
    pub options: ::core::option::Option<BuildOptions>,
    /// Output only. URL to logs for this build in Google Cloud Console.
    #[prost(string, tag = "25")]
    pub log_url: ::prost::alloc::string::String,
    /// Substitutions data for `Build` resource.
    #[prost(map = "string, string", tag = "29")]
    pub substitutions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Tags for annotation of a `Build`. These are not docker tags.
    #[prost(string, repeated, tag = "31")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Secrets to decrypt using Cloud Key Management Service.
    /// Note: Secret Manager is the recommended technique
    /// for managing sensitive data with Cloud Build. Use `available_secrets` to
    /// configure builds to access secrets from Secret Manager. For instructions,
    /// see: <https://cloud.google.com/cloud-build/docs/securing-builds/use-secrets>
    #[prost(message, repeated, tag = "32")]
    pub secrets: ::prost::alloc::vec::Vec<Secret>,
    /// Output only. Stores timing information for phases of the build. Valid keys
    /// are:
    ///
    /// * BUILD: time to execute all build steps.
    /// * PUSH: time to push all artifacts including docker images and non docker
    /// artifacts.
    /// * FETCHSOURCE: time to fetch source.
    /// * SETUPBUILD: time to set up build.
    ///
    /// If the build does not specify source or images,
    /// these keys will not be included.
    #[prost(map = "string, message", tag = "33")]
    pub timing: ::std::collections::HashMap<::prost::alloc::string::String, TimeSpan>,
    /// Output only. Describes this build's approval configuration, status,
    /// and result.
    #[prost(message, optional, tag = "44")]
    pub approval: ::core::option::Option<BuildApproval>,
    /// IAM service account whose credentials will be used at build runtime.
    /// Must be of the format `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
    /// ACCOUNT can be email address or uniqueId of the service account.
    ///
    #[prost(string, tag = "42")]
    pub service_account: ::prost::alloc::string::String,
    /// Secrets and secret environment variables.
    #[prost(message, optional, tag = "47")]
    pub available_secrets: ::core::option::Option<Secrets>,
    /// Output only. Non-fatal problems encountered during the execution of the
    /// build.
    #[prost(message, repeated, tag = "49")]
    pub warnings: ::prost::alloc::vec::Vec<build::Warning>,
    /// Output only. Contains information about the build when status=FAILURE.
    #[prost(message, optional, tag = "51")]
    pub failure_info: ::core::option::Option<build::FailureInfo>,
}
/// Nested message and enum types in `Build`.
pub mod build {
    /// A non-fatal problem encountered during the execution of the build.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Warning {
        /// Explanation of the warning generated.
        #[prost(string, tag = "1")]
        pub text: ::prost::alloc::string::String,
        /// The priority for this warning.
        #[prost(enumeration = "warning::Priority", tag = "2")]
        pub priority: i32,
    }
    /// Nested message and enum types in `Warning`.
    pub mod warning {
        /// The relative importance of this warning.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Priority {
            /// Should not be used.
            Unspecified = 0,
            /// e.g. deprecation warnings and alternative feature highlights.
            Info = 1,
            /// e.g. automated detection of possible issues with the build.
            Warning = 2,
            /// e.g. alerts that a feature used in the build is pending removal
            Alert = 3,
        }
        impl Priority {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "PRIORITY_UNSPECIFIED",
                    Self::Info => "INFO",
                    Self::Warning => "WARNING",
                    Self::Alert => "ALERT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PRIORITY_UNSPECIFIED" => Some(Self::Unspecified),
                    "INFO" => Some(Self::Info),
                    "WARNING" => Some(Self::Warning),
                    "ALERT" => Some(Self::Alert),
                    _ => None,
                }
            }
        }
    }
    /// A fatal problem encountered during the execution of the build.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FailureInfo {
        /// The name of the failure.
        #[prost(enumeration = "failure_info::FailureType", tag = "1")]
        pub r#type: i32,
        /// Explains the failure issue in more detail using hard-coded text.
        #[prost(string, tag = "2")]
        pub detail: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `FailureInfo`.
    pub mod failure_info {
        /// The name of a fatal problem encountered during the execution of the
        /// build.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum FailureType {
            /// Type unspecified
            Unspecified = 0,
            /// Unable to push the image to the repository.
            PushFailed = 1,
            /// Final image not found.
            PushImageNotFound = 2,
            /// Unauthorized push of the final image.
            PushNotAuthorized = 3,
            /// Backend logging failures. Should retry.
            LoggingFailure = 4,
            /// A build step has failed.
            UserBuildStep = 5,
            /// The source fetching has failed.
            FetchSourceFailed = 6,
        }
        impl FailureType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "FAILURE_TYPE_UNSPECIFIED",
                    Self::PushFailed => "PUSH_FAILED",
                    Self::PushImageNotFound => "PUSH_IMAGE_NOT_FOUND",
                    Self::PushNotAuthorized => "PUSH_NOT_AUTHORIZED",
                    Self::LoggingFailure => "LOGGING_FAILURE",
                    Self::UserBuildStep => "USER_BUILD_STEP",
                    Self::FetchSourceFailed => "FETCH_SOURCE_FAILED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FAILURE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "PUSH_FAILED" => Some(Self::PushFailed),
                    "PUSH_IMAGE_NOT_FOUND" => Some(Self::PushImageNotFound),
                    "PUSH_NOT_AUTHORIZED" => Some(Self::PushNotAuthorized),
                    "LOGGING_FAILURE" => Some(Self::LoggingFailure),
                    "USER_BUILD_STEP" => Some(Self::UserBuildStep),
                    "FETCH_SOURCE_FAILED" => Some(Self::FetchSourceFailed),
                    _ => None,
                }
            }
        }
    }
    /// Possible status of a build or build step.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Status of the build is unknown.
        Unknown = 0,
        /// Build has been created and is pending execution and queuing. It has not
        /// been queued.
        Pending = 10,
        /// Build or step is queued; work has not yet begun.
        Queued = 1,
        /// Build or step is being executed.
        Working = 2,
        /// Build or step finished successfully.
        Success = 3,
        /// Build or step failed to complete successfully.
        Failure = 4,
        /// Build or step failed due to an internal cause.
        InternalError = 5,
        /// Build or step took longer than was allowed.
        Timeout = 6,
        /// Build or step was canceled by a user.
        Cancelled = 7,
        /// Build was enqueued for longer than the value of `queue_ttl`.
        Expired = 9,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "STATUS_UNKNOWN",
                Self::Pending => "PENDING",
                Self::Queued => "QUEUED",
                Self::Working => "WORKING",
                Self::Success => "SUCCESS",
                Self::Failure => "FAILURE",
                Self::InternalError => "INTERNAL_ERROR",
                Self::Timeout => "TIMEOUT",
                Self::Cancelled => "CANCELLED",
                Self::Expired => "EXPIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "QUEUED" => Some(Self::Queued),
                "WORKING" => Some(Self::Working),
                "SUCCESS" => Some(Self::Success),
                "FAILURE" => Some(Self::Failure),
                "INTERNAL_ERROR" => Some(Self::InternalError),
                "TIMEOUT" => Some(Self::Timeout),
                "CANCELLED" => Some(Self::Cancelled),
                "EXPIRED" => Some(Self::Expired),
                _ => None,
            }
        }
    }
}
/// Artifacts produced by a build that should be uploaded upon
/// successful completion of all build steps.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Artifacts {
    /// A list of images to be pushed upon the successful completion of all build
    /// steps.
    ///
    /// The images will be pushed using the builder service account's credentials.
    ///
    /// The digests of the pushed images will be stored in the Build resource's
    /// results field.
    ///
    /// If any of the images fail to be pushed, the build is marked FAILURE.
    #[prost(string, repeated, tag = "1")]
    pub images: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A list of objects to be uploaded to Cloud Storage upon successful
    /// completion of all build steps.
    ///
    /// Files in the workspace matching specified paths globs will be uploaded to
    /// the specified Cloud Storage location using the builder service account's
    /// credentials.
    ///
    /// The location and generation of the uploaded objects will be stored in the
    /// Build resource's results field.
    ///
    /// If any objects fail to be pushed, the build is marked FAILURE.
    #[prost(message, optional, tag = "2")]
    pub objects: ::core::option::Option<artifacts::ArtifactObjects>,
    /// A list of Maven artifacts to be uploaded to Artifact Registry upon
    /// successful completion of all build steps.
    ///
    /// Artifacts in the workspace matching specified paths globs will be uploaded
    /// to the specified Artifact Registry repository using the builder service
    /// account's credentials.
    ///
    /// If any artifacts fail to be pushed, the build is marked FAILURE.
    #[prost(message, repeated, tag = "3")]
    pub maven_artifacts: ::prost::alloc::vec::Vec<artifacts::MavenArtifact>,
    /// Optional. A list of Go modules to be uploaded to Artifact Registry upon
    /// successful completion of all build steps.
    ///
    /// If any objects fail to be pushed, the build is marked FAILURE.
    #[prost(message, repeated, tag = "4")]
    pub go_modules: ::prost::alloc::vec::Vec<artifacts::GoModule>,
    /// A list of Python packages to be uploaded to Artifact Registry upon
    /// successful completion of all build steps.
    ///
    /// The build service account credentials will be used to perform the upload.
    ///
    /// If any objects fail to be pushed, the build is marked FAILURE.
    #[prost(message, repeated, tag = "5")]
    pub python_packages: ::prost::alloc::vec::Vec<artifacts::PythonPackage>,
    /// A list of npm packages to be uploaded to Artifact Registry upon
    /// successful completion of all build steps.
    ///
    /// Npm packages in the specified paths will be uploaded
    /// to the specified Artifact Registry repository using the builder service
    /// account's credentials.
    ///
    /// If any packages fail to be pushed, the build is marked FAILURE.
    #[prost(message, repeated, tag = "6")]
    pub npm_packages: ::prost::alloc::vec::Vec<artifacts::NpmPackage>,
}
/// Nested message and enum types in `Artifacts`.
pub mod artifacts {
    /// Files in the workspace to upload to Cloud Storage upon successful
    /// completion of all build steps.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ArtifactObjects {
        /// Cloud Storage bucket and optional object path, in the form
        /// "gs://bucket/path/to/somewhere/". (see [Bucket Name
        /// Requirements](<https://cloud.google.com/storage/docs/bucket-naming#requirements>)).
        ///
        /// Files in the workspace matching any path pattern will be uploaded to
        /// Cloud Storage with this location as a prefix.
        #[prost(string, tag = "1")]
        pub location: ::prost::alloc::string::String,
        /// Path globs used to match files in the build's workspace.
        #[prost(string, repeated, tag = "2")]
        pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Output only. Stores timing information for pushing all artifact objects.
        #[prost(message, optional, tag = "3")]
        pub timing: ::core::option::Option<super::TimeSpan>,
    }
    /// A Maven artifact to upload to Artifact Registry upon successful completion
    /// of all build steps.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MavenArtifact {
        /// Artifact Registry repository, in the form
        /// "<https://$REGION-maven.pkg.dev/$PROJECT/$REPOSITORY">
        ///
        /// Artifact in the workspace specified by path will be uploaded to
        /// Artifact Registry with this location as a prefix.
        #[prost(string, tag = "1")]
        pub repository: ::prost::alloc::string::String,
        /// Path to an artifact in the build's workspace to be uploaded to
        /// Artifact Registry.
        /// This can be either an absolute path,
        /// e.g. /workspace/my-app/target/my-app-1.0.SNAPSHOT.jar
        /// or a relative path from /workspace,
        /// e.g. my-app/target/my-app-1.0.SNAPSHOT.jar.
        #[prost(string, tag = "2")]
        pub path: ::prost::alloc::string::String,
        /// Maven `artifactId` value used when uploading the artifact to Artifact
        /// Registry.
        #[prost(string, tag = "3")]
        pub artifact_id: ::prost::alloc::string::String,
        /// Maven `groupId` value used when uploading the artifact to Artifact
        /// Registry.
        #[prost(string, tag = "4")]
        pub group_id: ::prost::alloc::string::String,
        /// Maven `version` value used when uploading the artifact to Artifact
        /// Registry.
        #[prost(string, tag = "5")]
        pub version: ::prost::alloc::string::String,
    }
    /// Go module to upload to Artifact Registry upon successful completion of all
    /// build steps. A module refers to all dependencies in a go.mod file.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GoModule {
        /// Optional. Artifact Registry repository name.
        ///
        /// Specified Go modules will be zipped and uploaded to Artifact Registry
        /// with this location as a prefix.
        /// e.g. my-go-repo
        #[prost(string, tag = "1")]
        pub repository_name: ::prost::alloc::string::String,
        /// Optional. Location of the Artifact Registry repository. i.e. us-east1
        /// Defaults to the buildâ€™s location.
        #[prost(string, tag = "2")]
        pub repository_location: ::prost::alloc::string::String,
        /// Optional. Project ID of the Artifact Registry repository.
        /// Defaults to the build project.
        #[prost(string, tag = "3")]
        pub repository_project_id: ::prost::alloc::string::String,
        /// Optional. Source path of the go.mod file in the build's workspace. If not
        /// specified, this will default to the current directory.
        /// e.g. ~/code/go/mypackage
        #[prost(string, tag = "4")]
        pub source_path: ::prost::alloc::string::String,
        /// Optional. The Go module's "module path".
        /// e.g. example.com/foo/v2
        #[prost(string, tag = "5")]
        pub module_path: ::prost::alloc::string::String,
        /// Optional. The Go module's semantic version in the form vX.Y.Z. e.g.
        /// v0.1.1 Pre-release identifiers can also be added by appending a dash and
        /// dot separated ASCII alphanumeric characters and hyphens.
        /// e.g. v0.2.3-alpha.x.12m.5
        #[prost(string, tag = "6")]
        pub module_version: ::prost::alloc::string::String,
    }
    /// Python package to upload to Artifact Registry upon successful completion
    /// of all build steps. A package can encapsulate multiple objects to be
    /// uploaded to a single repository.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PythonPackage {
        /// Artifact Registry repository, in the form
        /// "<https://$REGION-python.pkg.dev/$PROJECT/$REPOSITORY">
        ///
        /// Files in the workspace matching any path pattern will be uploaded to
        /// Artifact Registry with this location as a prefix.
        #[prost(string, tag = "1")]
        pub repository: ::prost::alloc::string::String,
        /// Path globs used to match files in the build's workspace. For Python/
        /// Twine, this is usually `dist/*`, and sometimes additionally an `.asc`
        /// file.
        #[prost(string, repeated, tag = "2")]
        pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Npm package to upload to Artifact Registry upon successful completion
    /// of all build steps.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NpmPackage {
        /// Artifact Registry repository, in the form
        /// "<https://$REGION-npm.pkg.dev/$PROJECT/$REPOSITORY">
        ///
        /// Npm package in the workspace specified by path will be zipped and
        /// uploaded to Artifact Registry with this location as a prefix.
        #[prost(string, tag = "1")]
        pub repository: ::prost::alloc::string::String,
        /// Path to the package.json.
        /// e.g. workspace/path/to/package
        #[prost(string, tag = "2")]
        pub package_path: ::prost::alloc::string::String,
    }
}
/// Start and end times for a build execution phase.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeSpan {
    /// Start of time span.
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// End of time span.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Metadata for build operations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildOperationMetadata {
    /// The build that the operation is tracking.
    #[prost(message, optional, tag = "1")]
    pub build: ::core::option::Option<Build>,
}
/// Provenance of the source. Ways to find the original source, or verify that
/// some source was used for this build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceProvenance {
    /// A copy of the build's `source.storage_source`, if exists, with any
    /// generations resolved.
    #[prost(message, optional, tag = "3")]
    pub resolved_storage_source: ::core::option::Option<StorageSource>,
    /// A copy of the build's `source.repo_source`, if exists, with any
    /// revisions resolved.
    #[prost(message, optional, tag = "6")]
    pub resolved_repo_source: ::core::option::Option<RepoSource>,
    /// A copy of the build's `source.storage_source_manifest`, if exists, with any
    /// revisions resolved.
    /// This feature is in Preview.
    #[prost(message, optional, tag = "9")]
    pub resolved_storage_source_manifest: ::core::option::Option<StorageSourceManifest>,
    /// Output only. Hash(es) of the build source, which can be used to verify that
    /// the original source integrity was maintained in the build. Note that
    /// `FileHashes` will only be populated if `BuildOptions` has requested a
    /// `SourceProvenanceHash`.
    ///
    /// The keys to this map are file paths used as build source and the values
    /// contain the hash values for those files.
    ///
    /// If the build source came in a single package such as a gzipped tarfile
    /// (`.tar.gz`), the `FileHash` will be for the single path to that file.
    #[prost(map = "string, message", tag = "4")]
    pub file_hashes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        FileHashes,
    >,
}
/// Container message for hashes of byte content of files, used in
/// SourceProvenance messages to verify integrity of source input to the build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileHashes {
    /// Collection of file hashes.
    #[prost(message, repeated, tag = "1")]
    pub file_hash: ::prost::alloc::vec::Vec<Hash>,
}
/// Container message for hash values.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hash {
    /// The type of hash that was performed.
    #[prost(enumeration = "hash::HashType", tag = "1")]
    pub r#type: i32,
    /// The hash value.
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `Hash`.
pub mod hash {
    /// Specifies the hash algorithm, if any.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HashType {
        /// No hash requested.
        None = 0,
        /// Use a sha256 hash.
        Sha256 = 1,
        /// Use a md5 hash.
        Md5 = 2,
        /// Dirhash of a Go module's source code which is then hex-encoded.
        GoModuleH1 = 3,
        /// Use a sha512 hash.
        Sha512 = 4,
    }
    impl HashType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Sha256 => "SHA256",
                Self::Md5 => "MD5",
                Self::GoModuleH1 => "GO_MODULE_H1",
                Self::Sha512 => "SHA512",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "SHA256" => Some(Self::Sha256),
                "MD5" => Some(Self::Md5),
                "GO_MODULE_H1" => Some(Self::GoModuleH1),
                "SHA512" => Some(Self::Sha512),
                _ => None,
            }
        }
    }
}
/// Secrets and secret environment variables.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Secrets {
    /// Secrets in Secret Manager and associated secret environment variable.
    #[prost(message, repeated, tag = "1")]
    pub secret_manager: ::prost::alloc::vec::Vec<SecretManagerSecret>,
    /// Secrets encrypted with KMS key and the associated secret environment
    /// variable.
    #[prost(message, repeated, tag = "2")]
    pub inline: ::prost::alloc::vec::Vec<InlineSecret>,
}
/// Pairs a set of secret environment variables mapped to encrypted
/// values with the Cloud KMS key to use to decrypt the value.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InlineSecret {
    /// Resource name of Cloud KMS crypto key to decrypt the encrypted value.
    /// In format: projects/*/locations/*/keyRings/*/cryptoKeys/*
    #[prost(string, tag = "1")]
    pub kms_key_name: ::prost::alloc::string::String,
    /// Map of environment variable name to its encrypted value.
    ///
    /// Secret environment variables must be unique across all of a build's
    /// secrets, and must be used by at least one build step. Values can be at most
    /// 64 KB in size. There can be at most 100 secret values across all of a
    /// build's secrets.
    #[prost(map = "string, bytes", tag = "2")]
    pub env_map: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
}
/// Pairs a secret environment variable with a SecretVersion in Secret Manager.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecretManagerSecret {
    /// Resource name of the SecretVersion. In format:
    /// projects/*/secrets/*/versions/*
    #[prost(string, tag = "1")]
    pub version_name: ::prost::alloc::string::String,
    /// Environment variable name to associate with the secret.
    /// Secret environment variables must be unique across all of a build's
    /// secrets, and must be used by at least one build step.
    #[prost(string, tag = "2")]
    pub env: ::prost::alloc::string::String,
}
/// Pairs a set of secret environment variables containing encrypted
/// values with the Cloud KMS key to use to decrypt the value.
/// Note: Use `kmsKeyName` with  `available_secrets` instead of using
/// `kmsKeyName` with `secret`. For instructions see:
/// <https://cloud.google.com/cloud-build/docs/securing-builds/use-encrypted-credentials.>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Secret {
    /// Cloud KMS key name to use to decrypt these envs.
    #[prost(string, tag = "1")]
    pub kms_key_name: ::prost::alloc::string::String,
    /// Map of environment variable name to its encrypted value.
    ///
    /// Secret environment variables must be unique across all of a build's
    /// secrets, and must be used by at least one build step. Values can be at most
    /// 64 KB in size. There can be at most 100 secret values across all of a
    /// build's secrets.
    #[prost(map = "string, bytes", tag = "3")]
    pub secret_env: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
}
/// Request to create a new build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBuildRequest {
    /// The parent resource where this build will be created.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "4")]
    pub parent: ::prost::alloc::string::String,
    /// Required. ID of the project.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. Build resource to create.
    #[prost(message, optional, tag = "2")]
    pub build: ::core::option::Option<Build>,
}
/// Request to get a build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBuildRequest {
    /// The name of the `Build` to retrieve.
    /// Format: `projects/{project}/locations/{location}/builds/{build}`
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    /// Required. ID of the project.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. ID of the build.
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
}
/// Request to list builds.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBuildsRequest {
    /// The parent of the collection of `Builds`.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "9")]
    pub parent: ::prost::alloc::string::String,
    /// Required. ID of the project.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Number of results to return in the list.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The page token for the next page of Builds.
    ///
    /// If unspecified, the first page of results is returned.
    ///
    /// If the token is rejected for any reason, INVALID_ARGUMENT will be thrown.
    /// In this case, the token should be discarded, and pagination should be
    /// restarted from the first page of results.
    ///
    /// See <https://google.aip.dev/158> for more.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// The raw filter text to constrain the results.
    #[prost(string, tag = "8")]
    pub filter: ::prost::alloc::string::String,
}
/// Response including listed builds.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBuildsResponse {
    /// Builds will be sorted by `create_time`, descending.
    #[prost(message, repeated, tag = "1")]
    pub builds: ::prost::alloc::vec::Vec<Build>,
    /// Token to receive the next page of results.
    /// This will be absent if the end of the response list has been reached.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request to cancel an ongoing build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelBuildRequest {
    /// The name of the `Build` to cancel.
    /// Format: `projects/{project}/locations/{location}/builds/{build}`
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    /// Required. ID of the project.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. ID of the build.
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
}
/// Request to approve or reject a pending build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApproveBuildRequest {
    /// Required. Name of the target build.
    /// For example: "projects/{$project_id}/builds/{$build_id}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Approval decision and metadata.
    #[prost(message, optional, tag = "2")]
    pub approval_result: ::core::option::Option<ApprovalResult>,
}
/// BuildApproval describes a build's approval configuration, state, and
/// result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildApproval {
    /// Output only. The state of this build's approval.
    #[prost(enumeration = "build_approval::State", tag = "1")]
    pub state: i32,
    /// Output only. Configuration for manual approval of this build.
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<ApprovalConfig>,
    /// Output only. Result of manual approval for this Build.
    #[prost(message, optional, tag = "3")]
    pub result: ::core::option::Option<ApprovalResult>,
}
/// Nested message and enum types in `BuildApproval`.
pub mod build_approval {
    /// Specifies the current state of a build's approval.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default enum type. This should not be used.
        Unspecified = 0,
        /// Build approval is pending.
        Pending = 1,
        /// Build approval has been approved.
        Approved = 2,
        /// Build approval has been rejected.
        Rejected = 3,
        /// Build was cancelled while it was still pending approval.
        Cancelled = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Approved => "APPROVED",
                Self::Rejected => "REJECTED",
                Self::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "APPROVED" => Some(Self::Approved),
                "REJECTED" => Some(Self::Rejected),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
/// ApprovalConfig describes configuration for manual approval of a build.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ApprovalConfig {
    /// Whether or not approval is needed. If this is set on a build, it will
    /// become pending when created, and will need to be explicitly approved
    /// to start.
    #[prost(bool, tag = "1")]
    pub approval_required: bool,
}
/// ApprovalResult describes the decision and associated metadata of a manual
/// approval of a build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApprovalResult {
    /// Output only. Email of the user that called the ApproveBuild API to
    /// approve or reject a build at the time that the API was called.
    #[prost(string, tag = "2")]
    pub approver_account: ::prost::alloc::string::String,
    /// Output only. The time when the approval decision was made.
    #[prost(message, optional, tag = "3")]
    pub approval_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. The decision of this manual approval.
    #[prost(enumeration = "approval_result::Decision", tag = "4")]
    pub decision: i32,
    /// Optional. An optional comment for this manual approval result.
    #[prost(string, tag = "5")]
    pub comment: ::prost::alloc::string::String,
    /// Optional. An optional URL tied to this manual approval result. This field
    /// is essentially the same as comment, except that it will be rendered by the
    /// UI differently. An example use case is a link to an external job that
    /// approved this Build.
    #[prost(string, tag = "6")]
    pub url: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ApprovalResult`.
pub mod approval_result {
    /// Specifies whether or not this manual approval result is to approve
    /// or reject a build.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Decision {
        /// Default enum type. This should not be used.
        Unspecified = 0,
        /// Build is approved.
        Approved = 1,
        /// Build is rejected.
        Rejected = 2,
    }
    impl Decision {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DECISION_UNSPECIFIED",
                Self::Approved => "APPROVED",
                Self::Rejected => "REJECTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DECISION_UNSPECIFIED" => Some(Self::Unspecified),
                "APPROVED" => Some(Self::Approved),
                "REJECTED" => Some(Self::Rejected),
                _ => None,
            }
        }
    }
}
/// GitRepoSource describes a repo and ref of a code repository.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitRepoSource {
    /// The URI of the repo (e.g. <https://github.com/user/repo.git>).
    /// Either `uri` or `repository` can be specified and is required.
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    /// The branch or tag to use. Must start with "refs/" (required).
    #[prost(string, tag = "2")]
    pub r#ref: ::prost::alloc::string::String,
    /// See RepoType below.
    #[prost(enumeration = "git_file_source::RepoType", tag = "3")]
    pub repo_type: i32,
    /// The source of the SCM repo.
    #[prost(oneof = "git_repo_source::Source", tags = "6")]
    pub source: ::core::option::Option<git_repo_source::Source>,
    /// The resource name of the enterprise config that should be applied
    /// to this source.
    #[prost(oneof = "git_repo_source::EnterpriseConfig", tags = "4")]
    pub enterprise_config: ::core::option::Option<git_repo_source::EnterpriseConfig>,
}
/// Nested message and enum types in `GitRepoSource`.
pub mod git_repo_source {
    /// The source of the SCM repo.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// The connected repository resource name, in the format
        /// `projects/*/locations/*/connections/*/repositories/*`. Either `uri` or
        /// `repository` can be specified and is required.
        #[prost(string, tag = "6")]
        Repository(::prost::alloc::string::String),
    }
    /// The resource name of the enterprise config that should be applied
    /// to this source.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EnterpriseConfig {
        /// The full resource name of the github enterprise config.
        /// Format:
        /// `projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}`.
        /// `projects/{project}/githubEnterpriseConfigs/{id}`.
        #[prost(string, tag = "4")]
        GithubEnterpriseConfig(::prost::alloc::string::String),
    }
}
/// GitFileSource describes a file within a (possibly remote) code repository.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitFileSource {
    /// The path of the file, with the repo root as the root of the path.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// The URI of the repo.
    /// Either uri or repository can be specified.
    /// If unspecified, the repo from which the trigger invocation originated is
    /// assumed to be the repo from which to read the specified path.
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    /// See RepoType above.
    #[prost(enumeration = "git_file_source::RepoType", tag = "3")]
    pub repo_type: i32,
    /// The branch, tag, arbitrary ref, or SHA version of the repo to use when
    /// resolving the filename (optional).
    /// This field respects the same syntax/resolution as described here:
    /// <https://git-scm.com/docs/gitrevisions>
    /// If unspecified, the revision from which the trigger invocation originated
    /// is assumed to be the revision from which to read the specified path.
    #[prost(string, tag = "4")]
    pub revision: ::prost::alloc::string::String,
    /// The source of the SCM repo.
    #[prost(oneof = "git_file_source::Source", tags = "7")]
    pub source: ::core::option::Option<git_file_source::Source>,
    /// The resource name of the enterprise config that should be applied
    /// to this source.
    #[prost(oneof = "git_file_source::EnterpriseConfig", tags = "5")]
    pub enterprise_config: ::core::option::Option<git_file_source::EnterpriseConfig>,
}
/// Nested message and enum types in `GitFileSource`.
pub mod git_file_source {
    /// The type of the repo, since it may not be explicit from the `repo` field
    /// (e.g from a URL).
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RepoType {
        /// The default, unknown repo type. Don't use it, instead use one of
        /// the other repo types.
        Unknown = 0,
        /// A Google Cloud Source Repositories-hosted repo.
        CloudSourceRepositories = 1,
        /// A GitHub-hosted repo not necessarily on "github.com" (i.e. GitHub
        /// Enterprise).
        Github = 2,
        /// A Bitbucket Server-hosted repo.
        BitbucketServer = 3,
        /// A GitLab-hosted repo.
        Gitlab = 4,
    }
    impl RepoType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::CloudSourceRepositories => "CLOUD_SOURCE_REPOSITORIES",
                Self::Github => "GITHUB",
                Self::BitbucketServer => "BITBUCKET_SERVER",
                Self::Gitlab => "GITLAB",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "CLOUD_SOURCE_REPOSITORIES" => Some(Self::CloudSourceRepositories),
                "GITHUB" => Some(Self::Github),
                "BITBUCKET_SERVER" => Some(Self::BitbucketServer),
                "GITLAB" => Some(Self::Gitlab),
                _ => None,
            }
        }
    }
    /// The source of the SCM repo.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// The fully qualified resource name of the Repos API repository.
        /// Either URI or repository can be specified.
        /// If unspecified, the repo from which the trigger invocation originated is
        /// assumed to be the repo from which to read the specified path.
        #[prost(string, tag = "7")]
        Repository(::prost::alloc::string::String),
    }
    /// The resource name of the enterprise config that should be applied
    /// to this source.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EnterpriseConfig {
        /// The full resource name of the github enterprise config.
        /// Format:
        /// `projects/{project}/locations/{location}/githubEnterpriseConfigs/{id}`.
        /// `projects/{project}/githubEnterpriseConfigs/{id}`.
        #[prost(string, tag = "5")]
        GithubEnterpriseConfig(::prost::alloc::string::String),
    }
}
/// Configuration for an automated build in response to source repository
/// changes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildTrigger {
    /// The `Trigger` name with format:
    /// `projects/{project}/locations/{location}/triggers/{trigger}`, where
    /// {trigger} is a unique identifier generated by the service.
    #[prost(string, tag = "34")]
    pub resource_name: ::prost::alloc::string::String,
    /// Output only. Unique identifier of the trigger.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Human-readable description of this trigger.
    #[prost(string, tag = "10")]
    pub description: ::prost::alloc::string::String,
    /// User-assigned name of the trigger. Must be unique within the project.
    /// Trigger names must meet the following requirements:
    ///
    /// + They must contain only alphanumeric characters and dashes.
    /// + They can be 1-64 characters long.
    /// + They must begin and end with an alphanumeric character.
    #[prost(string, tag = "21")]
    pub name: ::prost::alloc::string::String,
    /// Tags for annotation of a `BuildTrigger`
    #[prost(string, repeated, tag = "19")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Template describing the types of source changes to trigger a build.
    ///
    /// Branch and tag names in trigger templates are interpreted as regular
    /// expressions. Any branch or tag change that matches that regular expression
    /// will trigger a build.
    ///
    /// Mutually exclusive with `github`.
    #[prost(message, optional, tag = "7")]
    pub trigger_template: ::core::option::Option<RepoSource>,
    /// GitHubEventsConfig describes the configuration of a trigger that creates
    /// a build whenever a GitHub event is received.
    ///
    /// Mutually exclusive with `trigger_template`.
    #[prost(message, optional, tag = "13")]
    pub github: ::core::option::Option<GitHubEventsConfig>,
    /// PubsubConfig describes the configuration of a trigger that
    /// creates a build whenever a Pub/Sub message is published.
    #[prost(message, optional, tag = "29")]
    pub pubsub_config: ::core::option::Option<PubsubConfig>,
    /// WebhookConfig describes the configuration of a trigger that
    /// creates a build whenever a webhook is sent to a trigger's webhook URL.
    #[prost(message, optional, tag = "31")]
    pub webhook_config: ::core::option::Option<WebhookConfig>,
    /// Output only. Time when the trigger was created.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// If true, the trigger will never automatically execute a build.
    #[prost(bool, tag = "9")]
    pub disabled: bool,
    /// Substitutions for Build resource. The keys must match the following
    /// regular expression: `^_\[A-Z0-9_\]+$`.
    #[prost(map = "string, string", tag = "11")]
    pub substitutions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// ignored_files and included_files are file glob matches using
    /// <https://golang.org/pkg/path/filepath/#Match> extended with support for "**".
    ///
    /// If ignored_files and changed files are both empty, then they are
    /// not used to determine whether or not to trigger a build.
    ///
    /// If ignored_files is not empty, then we ignore any files that match
    /// any of the ignored_file globs. If the change has no files that are
    /// outside of the ignored_files globs, then we do not trigger a build.
    #[prost(string, repeated, tag = "15")]
    pub ignored_files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If any of the files altered in the commit pass the ignored_files
    /// filter and included_files is empty, then as far as this filter is
    /// concerned, we should trigger the build.
    ///
    /// If any of the files altered in the commit pass the ignored_files
    /// filter and included_files is not empty, then we make sure that at
    /// least one of those files matches a included_files glob. If not,
    /// then we do not trigger a build.
    #[prost(string, repeated, tag = "16")]
    pub included_files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. A Common Expression Language string.
    #[prost(string, tag = "30")]
    pub filter: ::prost::alloc::string::String,
    /// The repo and ref of the repository from which to build. This field
    /// is used only for those triggers that do not respond to SCM events.
    /// Triggers that respond to such events build source at whatever commit
    /// caused the event.
    /// This field is currently only used by Webhook, Pub/Sub, Manual, and Cron
    /// triggers.
    #[prost(message, optional, tag = "26")]
    pub source_to_build: ::core::option::Option<GitRepoSource>,
    /// The service account used for all user-controlled operations including
    /// UpdateBuildTrigger, RunBuildTrigger, CreateBuild, and CancelBuild.
    /// If no service account is set, then the standard Cloud Build service account
    /// (\[PROJECT_NUM\]@system.gserviceaccount.com) will be used instead.
    /// Format: `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}`
    #[prost(string, tag = "33")]
    pub service_account: ::prost::alloc::string::String,
    /// The configuration of a trigger that creates a build whenever an event from
    /// Repo API is received.
    #[prost(message, optional, tag = "39")]
    pub repository_event_config: ::core::option::Option<RepositoryEventConfig>,
    /// Template describing the Build request to make when the trigger is matched.
    /// At least one of the template fields must be provided.
    #[prost(oneof = "build_trigger::BuildTemplate", tags = "18, 4, 8, 24")]
    pub build_template: ::core::option::Option<build_trigger::BuildTemplate>,
}
/// Nested message and enum types in `BuildTrigger`.
pub mod build_trigger {
    /// Template describing the Build request to make when the trigger is matched.
    /// At least one of the template fields must be provided.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum BuildTemplate {
        /// Autodetect build configuration.  The following precedence is used (case
        /// insensitive):
        ///
        /// 1. cloudbuild.yaml
        /// 2. cloudbuild.yml
        /// 3. cloudbuild.json
        /// 4. Dockerfile
        ///
        /// Currently only available for GitHub App Triggers.
        #[prost(bool, tag = "18")]
        Autodetect(bool),
        /// Contents of the build template.
        #[prost(message, tag = "4")]
        Build(super::Build),
        /// Path, from the source root, to the build configuration file
        /// (i.e. cloudbuild.yaml).
        #[prost(string, tag = "8")]
        Filename(::prost::alloc::string::String),
        /// The file source describing the local or remote Build template.
        #[prost(message, tag = "24")]
        GitFileSource(super::GitFileSource),
    }
}
/// The configuration of a trigger that creates a build whenever an event from
/// Repo API is received.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RepositoryEventConfig {
    /// The resource name of the Repo API resource.
    #[prost(string, tag = "1")]
    pub repository: ::prost::alloc::string::String,
    /// Output only. The type of the SCM vendor the repository points to.
    #[prost(enumeration = "repository_event_config::RepositoryType", tag = "2")]
    pub repository_type: i32,
    /// The types of filter to trigger a build.
    #[prost(oneof = "repository_event_config::Filter", tags = "3, 4")]
    pub filter: ::core::option::Option<repository_event_config::Filter>,
}
/// Nested message and enum types in `RepositoryEventConfig`.
pub mod repository_event_config {
    /// All possible SCM repo types from Repo API.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RepositoryType {
        /// If unspecified, RepositoryType defaults to GITHUB.
        Unspecified = 0,
        /// The SCM repo is GITHUB.
        Github = 1,
        /// The SCM repo is GITHUB Enterprise.
        GithubEnterprise = 2,
        /// The SCM repo is GITLAB Enterprise.
        GitlabEnterprise = 3,
    }
    impl RepositoryType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "REPOSITORY_TYPE_UNSPECIFIED",
                Self::Github => "GITHUB",
                Self::GithubEnterprise => "GITHUB_ENTERPRISE",
                Self::GitlabEnterprise => "GITLAB_ENTERPRISE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REPOSITORY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "GITHUB" => Some(Self::Github),
                "GITHUB_ENTERPRISE" => Some(Self::GithubEnterprise),
                "GITLAB_ENTERPRISE" => Some(Self::GitlabEnterprise),
                _ => None,
            }
        }
    }
    /// The types of filter to trigger a build.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Filter {
        /// Filter to match changes in pull requests.
        #[prost(message, tag = "3")]
        PullRequest(super::PullRequestFilter),
        /// Filter to match changes in refs like branches, tags.
        #[prost(message, tag = "4")]
        Push(super::PushFilter),
    }
}
/// GitHubEventsConfig describes the configuration of a trigger that creates a
/// build whenever a GitHub event is received.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubEventsConfig {
    /// The installationID that emits the GitHub event.
    #[deprecated]
    #[prost(int64, tag = "1")]
    pub installation_id: i64,
    /// Owner of the repository. For example: The owner for
    /// <https://github.com/googlecloudplatform/cloud-builders> is
    /// "googlecloudplatform".
    #[prost(string, tag = "6")]
    pub owner: ::prost::alloc::string::String,
    /// Name of the repository. For example: The name for
    /// <https://github.com/googlecloudplatform/cloud-builders> is "cloud-builders".
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
    /// Filter describing the types of events to trigger a build.
    /// Currently supported event types: push, pull_request.
    #[prost(oneof = "git_hub_events_config::Event", tags = "4, 5")]
    pub event: ::core::option::Option<git_hub_events_config::Event>,
}
/// Nested message and enum types in `GitHubEventsConfig`.
pub mod git_hub_events_config {
    /// Filter describing the types of events to trigger a build.
    /// Currently supported event types: push, pull_request.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        /// filter to match changes in pull requests.
        #[prost(message, tag = "4")]
        PullRequest(super::PullRequestFilter),
        /// filter to match changes in refs like branches, tags.
        #[prost(message, tag = "5")]
        Push(super::PushFilter),
    }
}
/// PubsubConfig describes the configuration of a trigger that
/// creates a build whenever a Pub/Sub message is published.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PubsubConfig {
    /// Output only. Name of the subscription. Format is
    /// `projects/{project}/subscriptions/{subscription}`.
    #[prost(string, tag = "1")]
    pub subscription: ::prost::alloc::string::String,
    /// The name of the topic from which this subscription is receiving messages.
    /// Format is `projects/{project}/topics/{topic}`.
    #[prost(string, tag = "2")]
    pub topic: ::prost::alloc::string::String,
    /// Service account that will make the push request.
    #[prost(string, tag = "3")]
    pub service_account_email: ::prost::alloc::string::String,
    /// Potential issues with the underlying Pub/Sub subscription configuration.
    /// Only populated on get requests.
    #[prost(enumeration = "pubsub_config::State", tag = "4")]
    pub state: i32,
}
/// Nested message and enum types in `PubsubConfig`.
pub mod pubsub_config {
    /// Enumerates potential issues with the underlying Pub/Sub subscription
    /// configuration.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The subscription configuration has not been checked.
        Unspecified = 0,
        /// The Pub/Sub subscription is properly configured.
        Ok = 1,
        /// The subscription has been deleted.
        SubscriptionDeleted = 2,
        /// The topic has been deleted.
        TopicDeleted = 3,
        /// Some of the subscription's field are misconfigured.
        SubscriptionMisconfigured = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Ok => "OK",
                Self::SubscriptionDeleted => "SUBSCRIPTION_DELETED",
                Self::TopicDeleted => "TOPIC_DELETED",
                Self::SubscriptionMisconfigured => "SUBSCRIPTION_MISCONFIGURED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "OK" => Some(Self::Ok),
                "SUBSCRIPTION_DELETED" => Some(Self::SubscriptionDeleted),
                "TOPIC_DELETED" => Some(Self::TopicDeleted),
                "SUBSCRIPTION_MISCONFIGURED" => Some(Self::SubscriptionMisconfigured),
                _ => None,
            }
        }
    }
}
/// WebhookConfig describes the configuration of a trigger that
/// creates a build whenever a webhook is sent to a trigger's webhook URL.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebhookConfig {
    /// Potential issues with the underlying Pub/Sub subscription configuration.
    /// Only populated on get requests.
    #[prost(enumeration = "webhook_config::State", tag = "4")]
    pub state: i32,
    /// Auth method specifies how the webhook authenticates with GCP.
    #[prost(oneof = "webhook_config::AuthMethod", tags = "3")]
    pub auth_method: ::core::option::Option<webhook_config::AuthMethod>,
}
/// Nested message and enum types in `WebhookConfig`.
pub mod webhook_config {
    /// Enumerates potential issues with the Secret Manager secret provided by the
    /// user.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The webhook auth configuration not been checked.
        Unspecified = 0,
        /// The auth configuration is properly setup.
        Ok = 1,
        /// The secret provided in auth_method has been deleted.
        SecretDeleted = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Ok => "OK",
                Self::SecretDeleted => "SECRET_DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "OK" => Some(Self::Ok),
                "SECRET_DELETED" => Some(Self::SecretDeleted),
                _ => None,
            }
        }
    }
    /// Auth method specifies how the webhook authenticates with GCP.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AuthMethod {
        /// Required. Resource name for the secret required as a URL parameter.
        #[prost(string, tag = "3")]
        Secret(::prost::alloc::string::String),
    }
}
/// PullRequestFilter contains filter properties for matching GitHub Pull
/// Requests.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullRequestFilter {
    /// Configure builds to run whether a repository owner or collaborator need to
    /// comment `/gcbrun`.
    #[prost(enumeration = "pull_request_filter::CommentControl", tag = "5")]
    pub comment_control: i32,
    /// If true, branches that do NOT match the git_ref will trigger a build.
    #[prost(bool, tag = "6")]
    pub invert_regex: bool,
    /// Target refs to match.
    /// A target ref is the git reference where the pull request will be applied.
    #[prost(oneof = "pull_request_filter::GitRef", tags = "2")]
    pub git_ref: ::core::option::Option<pull_request_filter::GitRef>,
}
/// Nested message and enum types in `PullRequestFilter`.
pub mod pull_request_filter {
    /// Controls behavior of Pull Request comments.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CommentControl {
        /// Do not require comments on Pull Requests before builds are triggered.
        CommentsDisabled = 0,
        /// Enforce that repository owners or collaborators must comment on Pull
        /// Requests before builds are triggered.
        CommentsEnabled = 1,
        /// Enforce that repository owners or collaborators must comment on external
        /// contributors' Pull Requests before builds are triggered.
        CommentsEnabledForExternalContributorsOnly = 2,
    }
    impl CommentControl {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::CommentsDisabled => "COMMENTS_DISABLED",
                Self::CommentsEnabled => "COMMENTS_ENABLED",
                Self::CommentsEnabledForExternalContributorsOnly => {
                    "COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMMENTS_DISABLED" => Some(Self::CommentsDisabled),
                "COMMENTS_ENABLED" => Some(Self::CommentsEnabled),
                "COMMENTS_ENABLED_FOR_EXTERNAL_CONTRIBUTORS_ONLY" => {
                    Some(Self::CommentsEnabledForExternalContributorsOnly)
                }
                _ => None,
            }
        }
    }
    /// Target refs to match.
    /// A target ref is the git reference where the pull request will be applied.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum GitRef {
        /// Regex of branches to match.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        #[prost(string, tag = "2")]
        Branch(::prost::alloc::string::String),
    }
}
/// Push contains filter properties for matching GitHub git pushes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushFilter {
    /// When true, only trigger a build if the revision regex does NOT match the
    /// git_ref regex.
    #[prost(bool, tag = "4")]
    pub invert_regex: bool,
    /// Modified refs to match.
    /// A modified refs are the refs modified by a git push operation.
    #[prost(oneof = "push_filter::GitRef", tags = "2, 3")]
    pub git_ref: ::core::option::Option<push_filter::GitRef>,
}
/// Nested message and enum types in `PushFilter`.
pub mod push_filter {
    /// Modified refs to match.
    /// A modified refs are the refs modified by a git push operation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum GitRef {
        /// Regexes matching branches to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        #[prost(string, tag = "2")]
        Branch(::prost::alloc::string::String),
        /// Regexes matching tags to build.
        ///
        /// The syntax of the regular expressions accepted is the syntax accepted by
        /// RE2 and described at <https://github.com/google/re2/wiki/Syntax>
        #[prost(string, tag = "3")]
        Tag(::prost::alloc::string::String),
    }
}
/// Request to create a new `BuildTrigger`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBuildTriggerRequest {
    /// The parent resource where this trigger will be created.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "3")]
    pub parent: ::prost::alloc::string::String,
    /// Required. ID of the project for which to configure automatic builds.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. `BuildTrigger` to create.
    #[prost(message, optional, tag = "2")]
    pub trigger: ::core::option::Option<BuildTrigger>,
}
/// Returns the `BuildTrigger` with the specified ID.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBuildTriggerRequest {
    /// The name of the `Trigger` to retrieve.
    /// Format: `projects/{project}/locations/{location}/triggers/{trigger}`
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Required. ID of the project that owns the trigger.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. Identifier (`id` or `name`) of the `BuildTrigger` to get.
    #[prost(string, tag = "2")]
    pub trigger_id: ::prost::alloc::string::String,
}
/// Request to list existing `BuildTriggers`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBuildTriggersRequest {
    /// The parent of the collection of `Triggers`.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "4")]
    pub parent: ::prost::alloc::string::String,
    /// Required. ID of the project for which to list BuildTriggers.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Number of results to return in the list.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Token to provide to skip to a particular spot in the list.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response containing existing `BuildTriggers`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBuildTriggersResponse {
    /// `BuildTriggers` for the project, sorted by `create_time` descending.
    #[prost(message, repeated, tag = "1")]
    pub triggers: ::prost::alloc::vec::Vec<BuildTrigger>,
    /// Token to receive the next page of results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request to delete a `BuildTrigger`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBuildTriggerRequest {
    /// The name of the `Trigger` to delete.
    /// Format: `projects/{project}/locations/{location}/triggers/{trigger}`
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Required. ID of the project that owns the trigger.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. ID of the `BuildTrigger` to delete.
    #[prost(string, tag = "2")]
    pub trigger_id: ::prost::alloc::string::String,
}
/// Request to update an existing `BuildTrigger`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBuildTriggerRequest {
    /// Required. ID of the project that owns the trigger.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. ID of the `BuildTrigger` to update.
    #[prost(string, tag = "2")]
    pub trigger_id: ::prost::alloc::string::String,
    /// Required. `BuildTrigger` to update.
    #[prost(message, optional, tag = "3")]
    pub trigger: ::core::option::Option<BuildTrigger>,
    /// Update mask for the resource. If this is set,
    /// the server will only update the fields specified in the field mask.
    /// Otherwise, a full update of the mutable resource fields will be performed.
    #[prost(message, optional, tag = "5")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Optional arguments to enable specific features of builds.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildOptions {
    /// Requested hash for SourceProvenance.
    #[prost(enumeration = "hash::HashType", repeated, tag = "1")]
    pub source_provenance_hash: ::prost::alloc::vec::Vec<i32>,
    /// Requested verifiability options.
    #[prost(enumeration = "build_options::VerifyOption", tag = "2")]
    pub requested_verify_option: i32,
    /// Compute Engine machine type on which to run the build.
    #[prost(enumeration = "build_options::MachineType", tag = "3")]
    pub machine_type: i32,
    /// Requested disk size for the VM that runs the build. Note that this is *NOT*
    /// "disk free"; some of the space will be used by the operating system and
    /// build utilities. Also note that this is the minimum disk size that will be
    /// allocated for the build -- the build may run with a larger disk than
    /// requested. At present, the maximum disk size is 2000GB; builds that request
    /// more than the maximum are rejected with an error.
    #[prost(int64, tag = "6")]
    pub disk_size_gb: i64,
    /// Option to specify behavior when there is an error in the substitution
    /// checks.
    ///
    /// NOTE: this is always set to ALLOW_LOOSE for triggered builds and cannot
    /// be overridden in the build configuration file.
    #[prost(enumeration = "build_options::SubstitutionOption", tag = "4")]
    pub substitution_option: i32,
    /// Option to specify whether or not to apply bash style string
    /// operations to the substitutions.
    ///
    /// NOTE: this is always enabled for triggered builds and cannot be
    /// overridden in the build configuration file.
    #[prost(bool, tag = "17")]
    pub dynamic_substitutions: bool,
    /// Option to include built-in and custom substitutions as env variables
    /// for all build steps.
    #[prost(bool, tag = "22")]
    pub automap_substitutions: bool,
    /// Option to define build log streaming behavior to Cloud
    /// Storage.
    #[prost(enumeration = "build_options::LogStreamingOption", tag = "5")]
    pub log_streaming_option: i32,
    /// This field deprecated; please use `pool.name` instead.
    #[deprecated]
    #[prost(string, tag = "7")]
    pub worker_pool: ::prost::alloc::string::String,
    /// Optional. Specification for execution on a `WorkerPool`.
    ///
    /// See [running builds in a private
    /// pool](<https://cloud.google.com/build/docs/private-pools/run-builds-in-private-pool>)
    /// for more information.
    #[prost(message, optional, tag = "19")]
    pub pool: ::core::option::Option<build_options::PoolOption>,
    /// Option to specify the logging mode, which determines if and where build
    /// logs are stored.
    #[prost(enumeration = "build_options::LoggingMode", tag = "11")]
    pub logging: i32,
    /// A list of global environment variable definitions that will exist for all
    /// build steps in this build. If a variable is defined in both globally and in
    /// a build step, the variable will use the build step value.
    ///
    /// The elements are of the form "KEY=VALUE" for the environment variable "KEY"
    /// being given the value "VALUE".
    #[prost(string, repeated, tag = "12")]
    pub env: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A list of global environment variables, which are encrypted using a Cloud
    /// Key Management Service crypto key. These values must be specified in the
    /// build's `Secret`. These variables will be available to all build steps
    /// in this build.
    #[prost(string, repeated, tag = "13")]
    pub secret_env: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Global list of volumes to mount for ALL build steps
    ///
    /// Each volume is created as an empty volume prior to starting the build
    /// process. Upon completion of the build, volumes and their contents are
    /// discarded. Global volume names and paths cannot conflict with the volumes
    /// defined a build step.
    ///
    /// Using a global volume in a build with only one step is not valid as
    /// it is indicative of a build request with an incorrect configuration.
    #[prost(message, repeated, tag = "14")]
    pub volumes: ::prost::alloc::vec::Vec<Volume>,
    /// Optional. Option to specify how default logs buckets are setup.
    #[prost(enumeration = "build_options::DefaultLogsBucketBehavior", tag = "21")]
    pub default_logs_bucket_behavior: i32,
    /// Optional. Option to specify whether structured logging is enabled.
    ///
    /// If true, JSON-formatted logs are parsed as structured logs.
    #[prost(bool, tag = "23")]
    pub enable_structured_logging: bool,
}
/// Nested message and enum types in `BuildOptions`.
pub mod build_options {
    /// Details about how a build should be executed on a `WorkerPool`.
    ///
    /// See [running builds in a private
    /// pool](<https://cloud.google.com/build/docs/private-pools/run-builds-in-private-pool>)
    /// for more information.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PoolOption {
        /// The `WorkerPool` resource to execute the build on.
        /// You must have `cloudbuild.workerpools.use` on the project hosting the
        /// WorkerPool.
        ///
        /// Format projects/{project}/locations/{location}/workerPools/{workerPoolId}
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
    }
    /// Specifies the manner in which the build should be verified, if at all.
    ///
    /// If a verified build is requested, and any part of the process to generate
    /// and upload provenance fails, the build will also fail.
    ///
    /// If the build does not request verification then that process may occur, but
    /// is not guaranteed to. If it does occur and fails, the build will not fail.
    ///
    /// For more information, see [Viewing Build
    /// Provenance](<https://cloud.google.com/build/docs/securing-builds/view-build-provenance>).
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VerifyOption {
        /// Not a verifiable build (the default).
        NotVerified = 0,
        /// Build must be verified.
        Verified = 1,
    }
    impl VerifyOption {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::NotVerified => "NOT_VERIFIED",
                Self::Verified => "VERIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NOT_VERIFIED" => Some(Self::NotVerified),
                "VERIFIED" => Some(Self::Verified),
                _ => None,
            }
        }
    }
    /// Supported Compute Engine machine types.
    /// For more information, see [Machine
    /// types](<https://cloud.google.com/compute/docs/machine-types>).
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MachineType {
        /// Standard machine type.
        Unspecified = 0,
        /// Highcpu machine with 8 CPUs.
        N1Highcpu8 = 1,
        /// Highcpu machine with 32 CPUs.
        N1Highcpu32 = 2,
        /// Highcpu e2 machine with 8 CPUs.
        E2Highcpu8 = 5,
        /// Highcpu e2 machine with 32 CPUs.
        E2Highcpu32 = 6,
        /// E2 machine with 1 CPU.
        E2Medium = 7,
    }
    impl MachineType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::N1Highcpu8 => "N1_HIGHCPU_8",
                Self::N1Highcpu32 => "N1_HIGHCPU_32",
                Self::E2Highcpu8 => "E2_HIGHCPU_8",
                Self::E2Highcpu32 => "E2_HIGHCPU_32",
                Self::E2Medium => "E2_MEDIUM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "N1_HIGHCPU_8" => Some(Self::N1Highcpu8),
                "N1_HIGHCPU_32" => Some(Self::N1Highcpu32),
                "E2_HIGHCPU_8" => Some(Self::E2Highcpu8),
                "E2_HIGHCPU_32" => Some(Self::E2Highcpu32),
                "E2_MEDIUM" => Some(Self::E2Medium),
                _ => None,
            }
        }
    }
    /// Specifies the behavior when there is an error in the substitution checks.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SubstitutionOption {
        /// Fails the build if error in substitutions checks, like missing
        /// a substitution in the template or in the map.
        MustMatch = 0,
        /// Do not fail the build if error in substitutions checks.
        AllowLoose = 1,
    }
    impl SubstitutionOption {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::MustMatch => "MUST_MATCH",
                Self::AllowLoose => "ALLOW_LOOSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MUST_MATCH" => Some(Self::MustMatch),
                "ALLOW_LOOSE" => Some(Self::AllowLoose),
                _ => None,
            }
        }
    }
    /// Specifies the behavior when writing build logs to Cloud Storage.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LogStreamingOption {
        /// Service may automatically determine build log streaming behavior.
        StreamDefault = 0,
        /// Build logs should be streamed to Cloud Storage.
        StreamOn = 1,
        /// Build logs should not be streamed to Cloud Storage; they will be
        /// written when the build is completed.
        StreamOff = 2,
    }
    impl LogStreamingOption {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::StreamDefault => "STREAM_DEFAULT",
                Self::StreamOn => "STREAM_ON",
                Self::StreamOff => "STREAM_OFF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STREAM_DEFAULT" => Some(Self::StreamDefault),
                "STREAM_ON" => Some(Self::StreamOn),
                "STREAM_OFF" => Some(Self::StreamOff),
                _ => None,
            }
        }
    }
    /// Specifies the logging mode.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LoggingMode {
        /// The service determines the logging mode. The default is `LEGACY`. Do not
        /// rely on the default logging behavior as it may change in the future.
        LoggingUnspecified = 0,
        /// Build logs are stored in Cloud Logging and Cloud Storage.
        Legacy = 1,
        /// Build logs are stored in Cloud Storage.
        GcsOnly = 2,
        /// This option is the same as CLOUD_LOGGING_ONLY.
        StackdriverOnly = 3,
        /// Build logs are stored in Cloud Logging. Selecting this option will not
        /// allow [logs
        /// streaming](<https://cloud.google.com/sdk/gcloud/reference/builds/log>).
        CloudLoggingOnly = 5,
        /// Turn off all logging. No build logs will be captured.
        None = 4,
    }
    impl LoggingMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::LoggingUnspecified => "LOGGING_UNSPECIFIED",
                Self::Legacy => "LEGACY",
                Self::GcsOnly => "GCS_ONLY",
                Self::StackdriverOnly => "STACKDRIVER_ONLY",
                Self::CloudLoggingOnly => "CLOUD_LOGGING_ONLY",
                Self::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOGGING_UNSPECIFIED" => Some(Self::LoggingUnspecified),
                "LEGACY" => Some(Self::Legacy),
                "GCS_ONLY" => Some(Self::GcsOnly),
                "STACKDRIVER_ONLY" => Some(Self::StackdriverOnly),
                "CLOUD_LOGGING_ONLY" => Some(Self::CloudLoggingOnly),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
    /// Default Cloud Storage log bucket behavior options.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DefaultLogsBucketBehavior {
        /// Unspecified.
        Unspecified = 0,
        /// Bucket is located in user-owned project in the same region as the
        /// build. The builder service account must have access to create and write
        /// to Cloud Storage buckets in the build project.
        RegionalUserOwnedBucket = 1,
        /// Bucket is located in a Google-owned project and is not regionalized.
        LegacyBucket = 2,
    }
    impl DefaultLogsBucketBehavior {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DEFAULT_LOGS_BUCKET_BEHAVIOR_UNSPECIFIED",
                Self::RegionalUserOwnedBucket => "REGIONAL_USER_OWNED_BUCKET",
                Self::LegacyBucket => "LEGACY_BUCKET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFAULT_LOGS_BUCKET_BEHAVIOR_UNSPECIFIED" => Some(Self::Unspecified),
                "REGIONAL_USER_OWNED_BUCKET" => Some(Self::RegionalUserOwnedBucket),
                "LEGACY_BUCKET" => Some(Self::LegacyBucket),
                _ => None,
            }
        }
    }
}
/// ReceiveTriggerWebhookRequest \[Experimental\] is the request object accepted by
/// the ReceiveTriggerWebhook method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReceiveTriggerWebhookRequest {
    /// The name of the `ReceiveTriggerWebhook` to retrieve.
    /// Format: `projects/{project}/locations/{location}/triggers/{trigger}`
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    /// HTTP request body.
    #[prost(message, optional, tag = "1")]
    pub body: ::core::option::Option<super::super::super::api::HttpBody>,
    /// Project in which the specified trigger lives
    #[prost(string, tag = "2")]
    pub project_id: ::prost::alloc::string::String,
    /// Name of the trigger to run the payload against
    #[prost(string, tag = "3")]
    pub trigger: ::prost::alloc::string::String,
    /// Secret token used for authorization if an OAuth token isn't provided.
    #[prost(string, tag = "4")]
    pub secret: ::prost::alloc::string::String,
}
/// ReceiveTriggerWebhookResponse \[Experimental\] is the response object for the
/// ReceiveTriggerWebhook method.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReceiveTriggerWebhookResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubEnterpriseConfig {
    /// Optional. The full resource name for the GitHubEnterpriseConfig
    /// For example:
    /// "projects/{$project_id}/locations/{$location_id}/githubEnterpriseConfigs/{$config_id}"
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
    /// The URL of the github enterprise host the configuration is for.
    #[prost(string, tag = "3")]
    pub host_url: ::prost::alloc::string::String,
    /// Required. The GitHub app id of the Cloud Build app on the GitHub Enterprise
    /// server.
    #[prost(int64, tag = "4")]
    pub app_id: i64,
    /// Output only. Time when the installation was associated with the project.
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The key that should be attached to webhook calls to the ReceiveWebhook
    /// endpoint.
    #[prost(string, tag = "8")]
    pub webhook_key: ::prost::alloc::string::String,
    /// Optional. The network to be used when reaching out to the GitHub
    /// Enterprise server. The VPC network must be enabled for private
    /// service connection. This should be set if the GitHub Enterprise server is
    /// hosted on-premises and not reachable by public internet.
    /// If this field is left empty, no network peering will occur and calls to
    /// the GitHub Enterprise server will be made over the public internet.
    /// Must be in the format
    /// `projects/{project}/global/networks/{network}`, where {project}
    /// is a project number or id and {network} is the name of a
    /// VPC network in the project.
    #[prost(string, tag = "9")]
    pub peered_network: ::prost::alloc::string::String,
    /// Names of secrets in Secret Manager.
    #[prost(message, optional, tag = "10")]
    pub secrets: ::core::option::Option<GitHubEnterpriseSecrets>,
    /// Name to display for this config.
    #[prost(string, tag = "11")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. SSL certificate to use for requests to GitHub Enterprise.
    #[prost(string, tag = "12")]
    pub ssl_ca: ::prost::alloc::string::String,
}
/// GitHubEnterpriseSecrets represents the names of all necessary secrets in
/// Secret Manager for a GitHub Enterprise server.
/// Format is: projects/<project number>/secrets/<secret name>.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubEnterpriseSecrets {
    /// The resource name for the private key secret version.
    #[prost(string, tag = "5")]
    pub private_key_version_name: ::prost::alloc::string::String,
    /// The resource name for the webhook secret secret version in Secret Manager.
    #[prost(string, tag = "6")]
    pub webhook_secret_version_name: ::prost::alloc::string::String,
    /// The resource name for the OAuth secret secret version in Secret Manager.
    #[prost(string, tag = "7")]
    pub oauth_secret_version_name: ::prost::alloc::string::String,
    /// The resource name for the OAuth client ID secret version in Secret Manager.
    #[prost(string, tag = "8")]
    pub oauth_client_id_version_name: ::prost::alloc::string::String,
}
/// Configuration for a `WorkerPool`.
///
/// Cloud Build owns and maintains a pool of workers for general use and have no
/// access to a project's private network. By default, builds submitted to
/// Cloud Build will use a worker from this pool.
///
/// If your build needs access to resources on a private network,
/// create and use a `WorkerPool` to run your builds. Private `WorkerPool`s give
/// your builds access to any single VPC network that you
/// administer, including any on-prem resources connected to that VPC
/// network. For an overview of private pools, see
/// [Private pools
/// overview](<https://cloud.google.com/build/docs/private-pools/private-pools-overview>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerPool {
    /// Output only. The resource name of the `WorkerPool`, with format
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    /// The value of `{worker_pool}` is provided by `worker_pool_id` in
    /// `CreateWorkerPool` request and the value of `{location}` is determined by
    /// the endpoint accessed.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// A user-specified, human-readable name for the `WorkerPool`. If provided,
    /// this value must be 1-63 characters.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. A unique identifier for the `WorkerPool`.
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    /// User specified annotations. See <https://google.aip.dev/128#annotations>
    /// for more details such as format and size limitations.
    #[prost(map = "string, string", tag = "4")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Time at which the request to create the `WorkerPool` was
    /// received.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time at which the request to update the `WorkerPool` was
    /// received.
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time at which the request to delete the `WorkerPool` was
    /// received.
    #[prost(message, optional, tag = "7")]
    pub delete_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. `WorkerPool` state.
    #[prost(enumeration = "worker_pool::State", tag = "8")]
    pub state: i32,
    /// Output only. Checksum computed by the server. May be sent on update and
    /// delete requests to ensure that the client has an up-to-date value before
    /// proceeding.
    #[prost(string, tag = "11")]
    pub etag: ::prost::alloc::string::String,
    /// Configuration for the `WorkerPool`.
    #[prost(oneof = "worker_pool::Config", tags = "12")]
    pub config: ::core::option::Option<worker_pool::Config>,
}
/// Nested message and enum types in `WorkerPool`.
pub mod worker_pool {
    /// State of the `WorkerPool`.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State of the `WorkerPool` is unknown.
        Unspecified = 0,
        /// `WorkerPool` is being created.
        Creating = 1,
        /// `WorkerPool` is running.
        Running = 2,
        /// `WorkerPool` is being deleted: cancelling builds and draining workers.
        Deleting = 3,
        /// `WorkerPool` is deleted.
        Deleted = 4,
        /// `WorkerPool` is being updated; new builds cannot be run.
        Updating = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Running => "RUNNING",
                Self::Deleting => "DELETING",
                Self::Deleted => "DELETED",
                Self::Updating => "UPDATING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "RUNNING" => Some(Self::Running),
                "DELETING" => Some(Self::Deleting),
                "DELETED" => Some(Self::Deleted),
                "UPDATING" => Some(Self::Updating),
                _ => None,
            }
        }
    }
    /// Configuration for the `WorkerPool`.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Config {
        /// Legacy Private Pool configuration.
        #[prost(message, tag = "12")]
        PrivatePoolV1Config(super::PrivatePoolV1Config),
    }
}
/// Configuration for a V1 `PrivatePool`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivatePoolV1Config {
    /// Machine configuration for the workers in the pool.
    #[prost(message, optional, tag = "1")]
    pub worker_config: ::core::option::Option<private_pool_v1_config::WorkerConfig>,
    /// Network configuration for the pool.
    #[prost(message, optional, tag = "2")]
    pub network_config: ::core::option::Option<private_pool_v1_config::NetworkConfig>,
    /// Immutable. Private Service Connect(PSC) Network configuration for the pool.
    #[prost(message, optional, tag = "5")]
    pub private_service_connect: ::core::option::Option<
        private_pool_v1_config::PrivateServiceConnect,
    >,
}
/// Nested message and enum types in `PrivatePoolV1Config`.
pub mod private_pool_v1_config {
    /// Defines the configuration to be used for creating workers in
    /// the pool.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WorkerConfig {
        /// Machine type of a worker, such as `e2-medium`.
        /// See [Worker pool config
        /// file](<https://cloud.google.com/build/docs/private-pools/worker-pool-config-file-schema>).
        /// If left blank, Cloud Build will use a sensible default.
        #[prost(string, tag = "1")]
        pub machine_type: ::prost::alloc::string::String,
        /// Size of the disk attached to the worker, in GB.
        /// See [Worker pool config
        /// file](<https://cloud.google.com/build/docs/private-pools/worker-pool-config-file-schema>).
        /// Specify a value of up to 2000. If `0` is specified, Cloud Build will use
        /// a standard disk size.
        #[prost(int64, tag = "2")]
        pub disk_size_gb: i64,
    }
    /// Defines the network configuration for the pool.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NetworkConfig {
        /// Required. Immutable. The network definition that the workers are peered
        /// to. If this section is left empty, the workers will be peered to
        /// `WorkerPool.project_id` on the service producer network. Must be in the
        /// format `projects/{project}/global/networks/{network}`, where `{project}`
        /// is a project number, such as `12345`, and `{network}` is the name of a
        /// VPC network in the project. See
        /// [Understanding network configuration
        /// options](<https://cloud.google.com/build/docs/private-pools/set-up-private-pool-environment>)
        #[prost(string, tag = "1")]
        pub peered_network: ::prost::alloc::string::String,
        /// Option to configure network egress for the workers.
        #[prost(enumeration = "network_config::EgressOption", tag = "2")]
        pub egress_option: i32,
        /// Immutable. Subnet IP range within the peered network. This is specified
        /// in CIDR notation with a slash and the subnet prefix size. You can
        /// optionally specify an IP address before the subnet prefix value. e.g.
        /// `192.168.0.0/29` would specify an IP range starting at 192.168.0.0 with a
        /// prefix size of 29 bits.
        /// `/16` would specify a prefix size of 16 bits, with an automatically
        /// determined IP within the peered VPC.
        /// If unspecified, a value of `/24` will be used.
        #[prost(string, tag = "3")]
        pub peered_network_ip_range: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `NetworkConfig`.
    pub mod network_config {
        /// Defines the egress option for the pool.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum EgressOption {
            /// If set, defaults to PUBLIC_EGRESS.
            Unspecified = 0,
            /// If set, workers are created without any public address, which prevents
            /// network egress to public IPs unless a network proxy is configured.
            NoPublicEgress = 1,
            /// If set, workers are created with a public address which allows for
            /// public internet egress.
            PublicEgress = 2,
        }
        impl EgressOption {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "EGRESS_OPTION_UNSPECIFIED",
                    Self::NoPublicEgress => "NO_PUBLIC_EGRESS",
                    Self::PublicEgress => "PUBLIC_EGRESS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "EGRESS_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
                    "NO_PUBLIC_EGRESS" => Some(Self::NoPublicEgress),
                    "PUBLIC_EGRESS" => Some(Self::PublicEgress),
                    _ => None,
                }
            }
        }
    }
    /// Defines the Private Service Connect network configuration for the pool.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PrivateServiceConnect {
        /// Required. Immutable. The network attachment that the worker network
        /// interface is peered to. Must be in the format
        /// `projects/{project}/regions/{region}/networkAttachments/{networkAttachment}`.
        /// The region of network attachment must be the same as the worker pool.
        /// See [Network
        /// Attachments](<https://cloud.google.com/vpc/docs/about-network-attachments>)
        #[prost(string, tag = "1")]
        pub network_attachment: ::prost::alloc::string::String,
        /// Required. Immutable. Disable public IP on the primary network interface.
        ///
        /// If true, workers are created without any public address, which prevents
        /// network egress to public IPs unless a network proxy is configured.
        /// If false, workers are created with a public address which allows for
        /// public internet egress. The public address only applies to traffic
        /// through the primary network interface.
        /// If `route_all_traffic` is set to true, all traffic will go through the
        /// non-primary network interface, this boolean has no effect.
        #[prost(bool, tag = "2")]
        pub public_ip_address_disabled: bool,
        /// Immutable. Route all traffic through PSC interface. Enable this if you
        /// want full control of traffic in the private pool. Configure Cloud NAT for
        /// the subnet of network attachment if you need to access public Internet.
        ///
        /// If false, Only route private IPs, e.g. 10.0.0.0/8, 172.16.0.0/12, and
        /// 192.168.0.0/16 through PSC interface.
        #[prost(bool, tag = "3")]
        pub route_all_traffic: bool,
    }
}
/// Request to create a new `WorkerPool`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateWorkerPoolRequest {
    /// Required. The parent resource where this worker pool will be created.
    /// Format: `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. `WorkerPool` resource to create.
    #[prost(message, optional, tag = "2")]
    pub worker_pool: ::core::option::Option<WorkerPool>,
    /// Required. Immutable. The ID to use for the `WorkerPool`, which will become
    /// the final component of the resource name.
    ///
    /// This value should be 1-63 characters, and valid characters
    /// are /[a-z][0-9]-/.
    #[prost(string, tag = "3")]
    pub worker_pool_id: ::prost::alloc::string::String,
    /// If set, validate the request and preview the response, but do not actually
    /// post it.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Request to get a `WorkerPool` with the specified name.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkerPoolRequest {
    /// Required. The name of the `WorkerPool` to retrieve.
    /// Format: `projects/{project}/locations/{location}/workerPools/{workerPool}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request to delete a `WorkerPool`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteWorkerPoolRequest {
    /// Required. The name of the `WorkerPool` to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/workerPools/{workerPool}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If provided, it must match the server's etag on the workerpool
    /// for the request to be processed.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
    /// If set to true, and the `WorkerPool` is not found, the request will succeed
    /// but no action will be taken on the server.
    #[prost(bool, tag = "3")]
    pub allow_missing: bool,
    /// If set, validate the request and preview the response, but do not actually
    /// post it.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Request to update a `WorkerPool`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkerPoolRequest {
    /// Required. The `WorkerPool` to update.
    ///
    /// The `name` field is used to identify the `WorkerPool` to update.
    /// Format: `projects/{project}/locations/{location}/workerPools/{workerPool}`.
    #[prost(message, optional, tag = "1")]
    pub worker_pool: ::core::option::Option<WorkerPool>,
    /// A mask specifying which fields in `worker_pool` to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// If set, validate the request and preview the response, but do not actually
    /// post it.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Request to list `WorkerPool`s.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkerPoolsRequest {
    /// Required. The parent of the collection of `WorkerPools`.
    /// Format: `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of `WorkerPool`s to return. The service may return
    /// fewer than this value. If omitted, the server will use a sensible default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListWorkerPools` call. Provide this
    /// to retrieve the subsequent page.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response containing existing `WorkerPools`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkerPoolsResponse {
    /// `WorkerPools` for the specified project.
    #[prost(message, repeated, tag = "1")]
    pub worker_pools: ::prost::alloc::vec::Vec<WorkerPool>,
    /// Continuation token used to page through large result sets. Provide this
    /// value in a subsequent ListWorkerPoolsRequest to return the next page of
    /// results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Metadata for the `CreateWorkerPool` operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateWorkerPoolOperationMetadata {
    /// The resource name of the `WorkerPool` to create.
    /// Format:
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    #[prost(string, tag = "1")]
    pub worker_pool: ::prost::alloc::string::String,
    /// Time the operation was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Time the operation was completed.
    #[prost(message, optional, tag = "3")]
    pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Metadata for the `UpdateWorkerPool` operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkerPoolOperationMetadata {
    /// The resource name of the `WorkerPool` being updated.
    /// Format:
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    #[prost(string, tag = "1")]
    pub worker_pool: ::prost::alloc::string::String,
    /// Time the operation was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Time the operation was completed.
    #[prost(message, optional, tag = "3")]
    pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Metadata for the `DeleteWorkerPool` operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteWorkerPoolOperationMetadata {
    /// The resource name of the `WorkerPool` being deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
    #[prost(string, tag = "1")]
    pub worker_pool: ::prost::alloc::string::String,
    /// Time the operation was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Time the operation was completed.
    #[prost(message, optional, tag = "3")]
    pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod cloud_build_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Creates and manages builds on Google Cloud Platform.
    ///
    /// The main concept used by this API is a `Build`, which describes the location
    /// of the source to build, how to build the source, and where to store the
    /// built artifacts, if any.
    ///
    /// A user can list previously-requested builds or get builds by their ID to
    /// determine the status of the build.
    #[derive(Debug, Clone)]
    pub struct CloudBuildClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CloudBuildClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CloudBuildClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CloudBuildClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CloudBuildClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Starts a build with the specified configuration.
        ///
        /// This method returns a long-running `Operation`, which includes the build
        /// ID. Pass the build ID to `GetBuild` to determine the build status (such as
        /// `SUCCESS` or `FAILURE`).
        pub async fn create_build(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBuildRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/CreateBuild",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "CreateBuild",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns information about a previously requested build.
        ///
        /// The `Build` that is returned includes its status (such as `SUCCESS`,
        /// `FAILURE`, or `WORKING`), and timing information.
        pub async fn get_build(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBuildRequest>,
        ) -> std::result::Result<tonic::Response<super::Build>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/GetBuild",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "GetBuild",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists previously requested builds.
        ///
        /// Previously requested builds may still be in-progress, or may have finished
        /// successfully or unsuccessfully.
        pub async fn list_builds(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBuildsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBuildsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/ListBuilds",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "ListBuilds",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Cancels a build in progress.
        pub async fn cancel_build(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelBuildRequest>,
        ) -> std::result::Result<tonic::Response<super::Build>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/CancelBuild",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "CancelBuild",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new build based on the specified build.
        ///
        /// This method creates a new build using the original build request, which may
        /// or may not result in an identical build.
        ///
        /// For triggered builds:
        ///
        /// * Triggered builds resolve to a precise revision; therefore a retry of a
        /// triggered build will result in a build that uses the same revision.
        ///
        /// For non-triggered builds that specify `RepoSource`:
        ///
        /// * If the original build built from the tip of a branch, the retried build
        /// will build from the tip of that branch, which may not be the same revision
        /// as the original build.
        /// * If the original build specified a commit sha or revision ID, the retried
        /// build will use the identical source.
        ///
        /// For builds that specify `StorageSource`:
        ///
        /// * If the original build pulled source from Cloud Storage without
        /// specifying the generation of the object, the new build will use the current
        /// object, which may be different from the original build source.
        /// * If the original build pulled source from Cloud Storage and specified the
        /// generation of the object, the new build will attempt to use the same
        /// object, which may or may not be available depending on the bucket's
        /// lifecycle management settings.
        pub async fn retry_build(
            &mut self,
            request: impl tonic::IntoRequest<super::RetryBuildRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/RetryBuild",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "RetryBuild",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Approves or rejects a pending build.
        ///
        /// If approved, the returned LRO will be analogous to the LRO returned from
        /// a CreateBuild call.
        ///
        /// If rejected, the returned LRO will be immediately done.
        pub async fn approve_build(
            &mut self,
            request: impl tonic::IntoRequest<super::ApproveBuildRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/ApproveBuild",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "ApproveBuild",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new `BuildTrigger`.
        ///
        /// This API is experimental.
        pub async fn create_build_trigger(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBuildTriggerRequest>,
        ) -> std::result::Result<tonic::Response<super::BuildTrigger>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/CreateBuildTrigger",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "CreateBuildTrigger",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns information about a `BuildTrigger`.
        ///
        /// This API is experimental.
        pub async fn get_build_trigger(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBuildTriggerRequest>,
        ) -> std::result::Result<tonic::Response<super::BuildTrigger>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/GetBuildTrigger",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "GetBuildTrigger",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists existing `BuildTrigger`s.
        ///
        /// This API is experimental.
        pub async fn list_build_triggers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBuildTriggersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBuildTriggersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/ListBuildTriggers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "ListBuildTriggers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a `BuildTrigger` by its project ID and trigger ID.
        ///
        /// This API is experimental.
        pub async fn delete_build_trigger(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBuildTriggerRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/DeleteBuildTrigger",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "DeleteBuildTrigger",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a `BuildTrigger` by its project ID and trigger ID.
        ///
        /// This API is experimental.
        pub async fn update_build_trigger(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBuildTriggerRequest>,
        ) -> std::result::Result<tonic::Response<super::BuildTrigger>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/UpdateBuildTrigger",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "UpdateBuildTrigger",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Runs a `BuildTrigger` at a particular source revision.
        ///
        /// To run a regional or global trigger, use the POST request
        /// that includes the location endpoint in the path (ex.
        /// v1/projects/{projectId}/locations/{region}/triggers/{triggerId}:run). The
        /// POST request that does not include the location endpoint in the path can
        /// only be used when running global triggers.
        pub async fn run_build_trigger(
            &mut self,
            request: impl tonic::IntoRequest<super::RunBuildTriggerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/RunBuildTrigger",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "RunBuildTrigger",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ReceiveTriggerWebhook [Experimental] is called when the API receives a
        /// webhook request targeted at a specific trigger.
        pub async fn receive_trigger_webhook(
            &mut self,
            request: impl tonic::IntoRequest<super::ReceiveTriggerWebhookRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReceiveTriggerWebhookResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/ReceiveTriggerWebhook",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "ReceiveTriggerWebhook",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a `WorkerPool`.
        pub async fn create_worker_pool(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateWorkerPoolRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/CreateWorkerPool",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "CreateWorkerPool",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns details of a `WorkerPool`.
        pub async fn get_worker_pool(
            &mut self,
            request: impl tonic::IntoRequest<super::GetWorkerPoolRequest>,
        ) -> std::result::Result<tonic::Response<super::WorkerPool>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/GetWorkerPool",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "GetWorkerPool",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a `WorkerPool`.
        pub async fn delete_worker_pool(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteWorkerPoolRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/DeleteWorkerPool",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "DeleteWorkerPool",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a `WorkerPool`.
        pub async fn update_worker_pool(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateWorkerPoolRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/UpdateWorkerPool",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "UpdateWorkerPool",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists `WorkerPool`s.
        pub async fn list_worker_pools(
            &mut self,
            request: impl tonic::IntoRequest<super::ListWorkerPoolsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListWorkerPoolsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.devtools.cloudbuild.v1.CloudBuild/ListWorkerPools",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.devtools.cloudbuild.v1.CloudBuild",
                        "ListWorkerPools",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
