// This file is @generated by prost-build.
/// Transcoding job resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Job {
    /// The resource name of the job.
    /// Format: `projects/{project_number}/locations/{location}/jobs/{job}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Input only. Specify the `input_uri` to populate empty `uri` fields in each
    /// element of `Job.config.inputs` or `JobTemplate.config.inputs` when using
    /// template. URI of the media. Input files must be at least 5 seconds in
    /// duration and stored in Cloud Storage (for example,
    /// `gs://bucket/inputs/file.mp4`). See [Supported input and output
    /// formats](<https://cloud.google.com/transcoder/docs/concepts/supported-input-and-output-formats>).
    #[prost(string, tag = "2")]
    pub input_uri: ::prost::alloc::string::String,
    /// Input only. Specify the `output_uri` to populate an empty
    /// `Job.config.output.uri` or `JobTemplate.config.output.uri` when using
    /// template. URI for the output file(s). For example,
    /// `gs://my-bucket/outputs/`. See [Supported input and output
    /// formats](<https://cloud.google.com/transcoder/docs/concepts/supported-input-and-output-formats>).
    #[prost(string, tag = "3")]
    pub output_uri: ::prost::alloc::string::String,
    /// Output only. The current state of the job.
    #[prost(enumeration = "job::ProcessingState", tag = "8")]
    pub state: i32,
    /// Output only. The time the job was created.
    #[prost(message, optional, tag = "12")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the transcoding started.
    #[prost(message, optional, tag = "13")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the transcoding finished.
    #[prost(message, optional, tag = "14")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Job time to live value in days, which will be effective after job
    /// completion. Job should be deleted automatically after the given TTL. Enter
    /// a value between 1 and 90. The default is 30.
    #[prost(int32, tag = "15")]
    pub ttl_after_completion_days: i32,
    /// The labels associated with this job. You can use these to organize and
    /// group your jobs.
    #[prost(map = "string, string", tag = "16")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. An error object that describes the reason for the failure.
    /// This property is always present when `state` is `FAILED`.
    #[prost(message, optional, tag = "17")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
    /// The processing mode of the job.
    /// The default is `PROCESSING_MODE_INTERACTIVE`.
    #[prost(enumeration = "job::ProcessingMode", tag = "20")]
    pub mode: i32,
    /// The processing priority of a batch job.
    /// This field can only be set for batch mode jobs. The default value is 0.
    /// This value cannot be negative. Higher values correspond to higher
    /// priorities for the job.
    #[prost(int32, tag = "21")]
    pub batch_mode_priority: i32,
    /// Optional. The optimization strategy of the job. The default is
    /// `AUTODETECT`.
    #[prost(enumeration = "job::OptimizationStrategy", tag = "22")]
    pub optimization: i32,
    /// Specify the `job_config` for the transcoding job. If you don't specify the
    /// `job_config`, the API selects `templateId`; this template ID is set to
    /// `preset/web-hd` by default. When you use a `template_id` to create a job,
    /// the `Job.config` is populated by the `JobTemplate.config`.<br>
    #[prost(oneof = "job::JobConfig", tags = "4, 5")]
    pub job_config: ::core::option::Option<job::JobConfig>,
}
/// Nested message and enum types in `Job`.
pub mod job {
    /// The current state of the job.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProcessingState {
        /// The processing state is not specified.
        Unspecified = 0,
        /// The job is enqueued and will be picked up for processing soon.
        Pending = 1,
        /// The job is being processed.
        Running = 2,
        /// The job has been completed successfully.
        Succeeded = 3,
        /// The job has failed. For additional information, see `failure_reason` and
        /// `failure_details`
        Failed = 4,
    }
    impl ProcessingState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROCESSING_STATE_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Running => "RUNNING",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROCESSING_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "RUNNING" => Some(Self::Running),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    /// The processing mode of the job.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProcessingMode {
        /// The job processing mode is not specified.
        Unspecified = 0,
        /// The job processing mode is interactive mode.
        /// Interactive job will either be ran or rejected if quota does not allow
        /// for it.
        Interactive = 1,
        /// The job processing mode is batch mode.
        /// Batch mode allows queuing of jobs.
        Batch = 2,
    }
    impl ProcessingMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROCESSING_MODE_UNSPECIFIED",
                Self::Interactive => "PROCESSING_MODE_INTERACTIVE",
                Self::Batch => "PROCESSING_MODE_BATCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROCESSING_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROCESSING_MODE_INTERACTIVE" => Some(Self::Interactive),
                "PROCESSING_MODE_BATCH" => Some(Self::Batch),
                _ => None,
            }
        }
    }
    /// The optimization strategy of the job. The default is `AUTODETECT`.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OptimizationStrategy {
        /// The optimization strategy is not specified.
        Unspecified = 0,
        /// Prioritize job processing speed.
        Autodetect = 1,
        /// Disable all optimizations.
        Disabled = 2,
    }
    impl OptimizationStrategy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OPTIMIZATION_STRATEGY_UNSPECIFIED",
                Self::Autodetect => "AUTODETECT",
                Self::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPTIMIZATION_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
                "AUTODETECT" => Some(Self::Autodetect),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
    /// Specify the `job_config` for the transcoding job. If you don't specify the
    /// `job_config`, the API selects `templateId`; this template ID is set to
    /// `preset/web-hd` by default. When you use a `template_id` to create a job,
    /// the `Job.config` is populated by the `JobTemplate.config`.<br>
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum JobConfig {
        /// Input only. Specify the `template_id` to use for populating `Job.config`.
        /// The default is `preset/web-hd`, which is the only supported preset.
        ///
        /// User defined JobTemplate: `{job_template_id}`
        #[prost(string, tag = "4")]
        TemplateId(::prost::alloc::string::String),
        /// The configuration for this job.
        #[prost(message, tag = "5")]
        Config(super::JobConfig),
    }
}
/// Transcoding job template resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobTemplate {
    /// The resource name of the job template.
    /// Format:
    /// `projects/{project_number}/locations/{location}/jobTemplates/{job_template}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The configuration for this template.
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<JobConfig>,
    /// The labels associated with this job template. You can use these to organize
    /// and group your job templates.
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Job configuration
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobConfig {
    /// List of input assets stored in Cloud Storage.
    #[prost(message, repeated, tag = "1")]
    pub inputs: ::prost::alloc::vec::Vec<Input>,
    /// List of `Edit atom`s. Defines the ultimate timeline of the resulting
    /// file or manifest.
    #[prost(message, repeated, tag = "2")]
    pub edit_list: ::prost::alloc::vec::Vec<EditAtom>,
    /// List of elementary streams.
    #[prost(message, repeated, tag = "3")]
    pub elementary_streams: ::prost::alloc::vec::Vec<ElementaryStream>,
    /// List of multiplexing settings for output streams.
    #[prost(message, repeated, tag = "4")]
    pub mux_streams: ::prost::alloc::vec::Vec<MuxStream>,
    /// List of output manifests.
    #[prost(message, repeated, tag = "5")]
    pub manifests: ::prost::alloc::vec::Vec<Manifest>,
    /// Output configuration.
    #[prost(message, optional, tag = "6")]
    pub output: ::core::option::Option<Output>,
    /// List of ad breaks. Specifies where to insert ad break tags in the output
    /// manifests.
    #[prost(message, repeated, tag = "7")]
    pub ad_breaks: ::prost::alloc::vec::Vec<AdBreak>,
    /// Destination on Pub/Sub.
    #[prost(message, optional, tag = "8")]
    pub pubsub_destination: ::core::option::Option<PubsubDestination>,
    /// List of output sprite sheets.
    /// Spritesheets require at least one VideoStream in the Jobconfig.
    #[prost(message, repeated, tag = "9")]
    pub sprite_sheets: ::prost::alloc::vec::Vec<SpriteSheet>,
    /// List of overlays on the output video, in descending Z-order.
    #[prost(message, repeated, tag = "10")]
    pub overlays: ::prost::alloc::vec::Vec<Overlay>,
    /// List of encryption configurations for the content.
    /// Each configuration has an ID. Specify this ID in the
    /// [MuxStream.encryption_id][google.cloud.video.transcoder.v1.MuxStream.encryption_id]
    /// field to indicate the configuration to use for that `MuxStream` output.
    #[prost(message, repeated, tag = "11")]
    pub encryptions: ::prost::alloc::vec::Vec<Encryption>,
}
/// Input asset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Input {
    /// A unique key for this input. Must be specified when using advanced
    /// mapping and edit lists.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// URI of the media. Input files must be at least 5 seconds in duration and
    /// stored in Cloud Storage (for example, `gs://bucket/inputs/file.mp4`).
    /// If empty, the value is populated from `Job.input_uri`. See
    /// [Supported input and output
    /// formats](<https://cloud.google.com/transcoder/docs/concepts/supported-input-and-output-formats>).
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    /// Preprocessing configurations.
    #[prost(message, optional, tag = "3")]
    pub preprocessing_config: ::core::option::Option<PreprocessingConfig>,
}
/// Location of output file(s) in a Cloud Storage bucket.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Output {
    /// URI for the output file(s). For example, `gs://my-bucket/outputs/`.
    /// If empty, the value is populated from `Job.output_uri`. See
    /// [Supported input and output
    /// formats](<https://cloud.google.com/transcoder/docs/concepts/supported-input-and-output-formats>).
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
}
/// Edit atom.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EditAtom {
    /// A unique key for this atom. Must be specified when using advanced
    /// mapping.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// List of `Input.key`s identifying files that should be used in this atom.
    /// The listed `inputs` must have the same timeline.
    #[prost(string, repeated, tag = "2")]
    pub inputs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// End time in seconds for the atom, relative to the input file timeline.
    /// When `end_time_offset` is not specified, the `inputs` are used until
    /// the end of the atom.
    #[prost(message, optional, tag = "3")]
    pub end_time_offset: ::core::option::Option<::prost_types::Duration>,
    /// Start time in seconds for the atom, relative to the input file timeline.
    /// The default is `0s`.
    #[prost(message, optional, tag = "4")]
    pub start_time_offset: ::core::option::Option<::prost_types::Duration>,
}
/// Ad break.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdBreak {
    /// Start time in seconds for the ad break, relative to the output file
    /// timeline. The default is `0s`.
    #[prost(message, optional, tag = "1")]
    pub start_time_offset: ::core::option::Option<::prost_types::Duration>,
}
/// Encoding of an input file such as an audio, video, or text track.
/// Elementary streams must be packaged before
/// mapping and sharing between different output formats.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ElementaryStream {
    /// A unique key for this elementary stream.
    #[prost(string, tag = "4")]
    pub key: ::prost::alloc::string::String,
    /// Encoding of an audio, video, or text track.
    #[prost(oneof = "elementary_stream::ElementaryStream", tags = "1, 2, 3")]
    pub elementary_stream: ::core::option::Option<elementary_stream::ElementaryStream>,
}
/// Nested message and enum types in `ElementaryStream`.
pub mod elementary_stream {
    /// Encoding of an audio, video, or text track.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ElementaryStream {
        /// Encoding of a video stream.
        #[prost(message, tag = "1")]
        VideoStream(super::VideoStream),
        /// Encoding of an audio stream.
        #[prost(message, tag = "2")]
        AudioStream(super::AudioStream),
        /// Encoding of a text stream. For example, closed captions or subtitles.
        #[prost(message, tag = "3")]
        TextStream(super::TextStream),
    }
}
/// Multiplexing settings for output stream.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MuxStream {
    /// A unique key for this multiplexed stream. HLS media manifests will be
    /// named `MuxStream.key` with the `.m3u8` extension suffix.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// The name of the generated file. The default is `MuxStream.key` with the
    /// extension suffix corresponding to the `MuxStream.container`.
    ///
    /// Individual segments also have an incremental 10-digit zero-padded suffix
    /// starting from 0 before the extension, such as `mux_stream0000000123.ts`.
    #[prost(string, tag = "2")]
    pub file_name: ::prost::alloc::string::String,
    /// The container format. The default is `mp4`
    ///
    /// Supported container formats:
    ///
    /// - `ts`
    /// - `fmp4`- the corresponding file extension is `.m4s`
    /// - `mp4`
    /// - `vtt`
    ///
    /// See also:
    /// [Supported input and output
    /// formats](<https://cloud.google.com/transcoder/docs/concepts/supported-input-and-output-formats>)
    #[prost(string, tag = "3")]
    pub container: ::prost::alloc::string::String,
    /// List of `ElementaryStream.key`s multiplexed in this stream.
    #[prost(string, repeated, tag = "4")]
    pub elementary_streams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Segment settings for `ts`, `fmp4` and `vtt`.
    #[prost(message, optional, tag = "5")]
    pub segment_settings: ::core::option::Option<SegmentSettings>,
    /// Identifier of the encryption configuration to use. If omitted, output will
    /// be unencrypted.
    #[prost(string, tag = "7")]
    pub encryption_id: ::prost::alloc::string::String,
}
/// Manifest configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Manifest {
    /// The name of the generated file. The default is `manifest` with the
    /// extension suffix corresponding to the `Manifest.type`.
    #[prost(string, tag = "1")]
    pub file_name: ::prost::alloc::string::String,
    /// Required. Type of the manifest.
    #[prost(enumeration = "manifest::ManifestType", tag = "2")]
    pub r#type: i32,
    /// Required. List of user given `MuxStream.key`s that should appear in this
    /// manifest.
    ///
    /// When `Manifest.type` is `HLS`, a media manifest with name `MuxStream.key`
    /// and `.m3u8` extension is generated for each element of the
    /// `Manifest.mux_streams`.
    #[prost(string, repeated, tag = "3")]
    pub mux_streams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Specifies the manifest configuration.
    #[prost(oneof = "manifest::ManifestConfig", tags = "4")]
    pub manifest_config: ::core::option::Option<manifest::ManifestConfig>,
}
/// Nested message and enum types in `Manifest`.
pub mod manifest {
    /// `DASH` manifest configuration.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DashConfig {
        /// The segment reference scheme for a `DASH` manifest. The default is
        /// `SEGMENT_LIST`.
        #[prost(enumeration = "dash_config::SegmentReferenceScheme", tag = "1")]
        pub segment_reference_scheme: i32,
    }
    /// Nested message and enum types in `DashConfig`.
    pub mod dash_config {
        /// The segment reference scheme for a `DASH` manifest.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SegmentReferenceScheme {
            /// The segment reference scheme is not specified.
            Unspecified = 0,
            /// Lists the URLs of media files for each segment.
            SegmentList = 1,
            /// Lists each segment from a template with $Number$ variable.
            SegmentTemplateNumber = 2,
        }
        impl SegmentReferenceScheme {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SEGMENT_REFERENCE_SCHEME_UNSPECIFIED",
                    Self::SegmentList => "SEGMENT_LIST",
                    Self::SegmentTemplateNumber => "SEGMENT_TEMPLATE_NUMBER",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SEGMENT_REFERENCE_SCHEME_UNSPECIFIED" => Some(Self::Unspecified),
                    "SEGMENT_LIST" => Some(Self::SegmentList),
                    "SEGMENT_TEMPLATE_NUMBER" => Some(Self::SegmentTemplateNumber),
                    _ => None,
                }
            }
        }
    }
    /// The manifest type, which corresponds to the adaptive streaming format used.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ManifestType {
        /// The manifest type is not specified.
        Unspecified = 0,
        /// Create an HLS manifest. The corresponding file extension is `.m3u8`.
        Hls = 1,
        /// Create an MPEG-DASH manifest. The corresponding file extension is `.mpd`.
        Dash = 2,
    }
    impl ManifestType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MANIFEST_TYPE_UNSPECIFIED",
                Self::Hls => "HLS",
                Self::Dash => "DASH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MANIFEST_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "HLS" => Some(Self::Hls),
                "DASH" => Some(Self::Dash),
                _ => None,
            }
        }
    }
    /// Specifies the manifest configuration.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ManifestConfig {
        /// `DASH` manifest configuration.
        #[prost(message, tag = "4")]
        Dash(DashConfig),
    }
}
/// A Pub/Sub destination.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PubsubDestination {
    /// The name of the Pub/Sub topic to publish job completion notification
    /// to. For example: `projects/{project}/topics/{topic}`.
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
}
/// Sprite sheet configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpriteSheet {
    /// Format type. The default is `jpeg`.
    ///
    /// Supported formats:
    ///
    /// - `jpeg`
    #[prost(string, tag = "1")]
    pub format: ::prost::alloc::string::String,
    /// Required. File name prefix for the generated sprite sheets.
    ///
    /// Each sprite sheet has an incremental 10-digit zero-padded suffix starting
    /// from 0 before the extension, such as `sprite_sheet0000000123.jpeg`.
    #[prost(string, tag = "2")]
    pub file_prefix: ::prost::alloc::string::String,
    /// Required. The width of sprite in pixels. Must be an even integer. To
    /// preserve the source aspect ratio, set the
    /// [SpriteSheet.sprite_width_pixels][google.cloud.video.transcoder.v1.SpriteSheet.sprite_width_pixels]
    /// field or the
    /// [SpriteSheet.sprite_height_pixels][google.cloud.video.transcoder.v1.SpriteSheet.sprite_height_pixels]
    /// field, but not both (the API will automatically calculate the missing
    /// field).
    ///
    /// For portrait videos that contain horizontal ASR and rotation metadata,
    /// provide the width, in pixels, per the horizontal ASR. The API calculates
    /// the height per the horizontal ASR. The API detects any rotation metadata
    /// and swaps the requested height and width for the output.
    #[prost(int32, tag = "3")]
    pub sprite_width_pixels: i32,
    /// Required. The height of sprite in pixels. Must be an even integer. To
    /// preserve the source aspect ratio, set the
    /// [SpriteSheet.sprite_height_pixels][google.cloud.video.transcoder.v1.SpriteSheet.sprite_height_pixels]
    /// field or the
    /// [SpriteSheet.sprite_width_pixels][google.cloud.video.transcoder.v1.SpriteSheet.sprite_width_pixels]
    /// field, but not both (the API will automatically calculate the missing
    /// field).
    ///
    /// For portrait videos that contain horizontal ASR and rotation metadata,
    /// provide the height, in pixels, per the horizontal ASR. The API calculates
    /// the width per the horizontal ASR. The API detects any rotation metadata
    /// and swaps the requested height and width for the output.
    #[prost(int32, tag = "4")]
    pub sprite_height_pixels: i32,
    /// The maximum number of sprites per row in a sprite sheet. The default is 0,
    /// which indicates no maximum limit.
    #[prost(int32, tag = "5")]
    pub column_count: i32,
    /// The maximum number of rows per sprite sheet. When the sprite sheet is full,
    /// a new sprite sheet is created. The default is 0, which indicates no maximum
    /// limit.
    #[prost(int32, tag = "6")]
    pub row_count: i32,
    /// Start time in seconds, relative to the output file timeline. Determines the
    /// first sprite to pick. The default is `0s`.
    #[prost(message, optional, tag = "7")]
    pub start_time_offset: ::core::option::Option<::prost_types::Duration>,
    /// End time in seconds, relative to the output file timeline. When
    /// `end_time_offset` is not specified, the sprites are generated until the end
    /// of the output file.
    #[prost(message, optional, tag = "8")]
    pub end_time_offset: ::core::option::Option<::prost_types::Duration>,
    /// The quality of the generated sprite sheet. Enter a value between 1
    /// and 100, where 1 is the lowest quality and 100 is the highest quality.
    /// The default is 100. A high quality value corresponds to a low image data
    /// compression ratio.
    #[prost(int32, tag = "11")]
    pub quality: i32,
    /// Specify either total number of sprites or interval to create sprites.
    #[prost(oneof = "sprite_sheet::ExtractionStrategy", tags = "9, 10")]
    pub extraction_strategy: ::core::option::Option<sprite_sheet::ExtractionStrategy>,
}
/// Nested message and enum types in `SpriteSheet`.
pub mod sprite_sheet {
    /// Specify either total number of sprites or interval to create sprites.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ExtractionStrategy {
        /// Total number of sprites. Create the specified number of sprites
        /// distributed evenly across the timeline of the output media. The default
        /// is 100.
        #[prost(int32, tag = "9")]
        TotalCount(i32),
        /// Starting from `0s`, create sprites at regular intervals. Specify the
        /// interval value in seconds.
        #[prost(message, tag = "10")]
        Interval(::prost_types::Duration),
    }
}
/// Overlay configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Overlay {
    /// Image overlay.
    #[prost(message, optional, tag = "1")]
    pub image: ::core::option::Option<overlay::Image>,
    /// List of Animations. The list should be chronological, without any time
    /// overlap.
    #[prost(message, repeated, tag = "2")]
    pub animations: ::prost::alloc::vec::Vec<overlay::Animation>,
}
/// Nested message and enum types in `Overlay`.
pub mod overlay {
    /// 2D normalized coordinates. Default: `{0.0, 0.0}`
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct NormalizedCoordinate {
        /// Normalized x coordinate.
        #[prost(double, tag = "1")]
        pub x: f64,
        /// Normalized y coordinate.
        #[prost(double, tag = "2")]
        pub y: f64,
    }
    /// Overlaid image.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Image {
        /// Required. URI of the image in Cloud Storage. For example,
        /// `gs://bucket/inputs/image.png`. Only PNG and JPEG images are supported.
        #[prost(string, tag = "1")]
        pub uri: ::prost::alloc::string::String,
        /// Normalized image resolution, based on output video resolution. Valid
        /// values: `0.0`–`1.0`. To respect the original image aspect ratio, set
        /// either `x` or `y` to `0.0`. To use the original image resolution, set
        /// both `x` and `y` to `0.0`.
        #[prost(message, optional, tag = "2")]
        pub resolution: ::core::option::Option<NormalizedCoordinate>,
        /// Target image opacity. Valid values are from  `1.0` (solid, default) to
        /// `0.0` (transparent), exclusive. Set this to a value greater than `0.0`.
        #[prost(double, tag = "3")]
        pub alpha: f64,
    }
    /// Display static overlay object.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AnimationStatic {
        /// Normalized coordinates based on output video resolution. Valid
        /// values: `0.0`–`1.0`. `xy` is the upper-left coordinate of the overlay
        /// object. For example, use the x and y coordinates {0,0} to position the
        /// top-left corner of the overlay animation in the top-left corner of the
        /// output video.
        #[prost(message, optional, tag = "1")]
        pub xy: ::core::option::Option<NormalizedCoordinate>,
        /// The time to start displaying the overlay object, in seconds. Default: 0
        #[prost(message, optional, tag = "2")]
        pub start_time_offset: ::core::option::Option<::prost_types::Duration>,
    }
    /// Display overlay object with fade animation.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AnimationFade {
        /// Required. Type of fade animation: `FADE_IN` or `FADE_OUT`.
        #[prost(enumeration = "FadeType", tag = "1")]
        pub fade_type: i32,
        /// Normalized coordinates based on output video resolution. Valid
        /// values: `0.0`–`1.0`. `xy` is the upper-left coordinate of the overlay
        /// object. For example, use the x and y coordinates {0,0} to position the
        /// top-left corner of the overlay animation in the top-left corner of the
        /// output video.
        #[prost(message, optional, tag = "2")]
        pub xy: ::core::option::Option<NormalizedCoordinate>,
        /// The time to start the fade animation, in seconds. Default: 0
        #[prost(message, optional, tag = "3")]
        pub start_time_offset: ::core::option::Option<::prost_types::Duration>,
        /// The time to end the fade animation, in seconds. Default:
        /// `start_time_offset` + 1s
        #[prost(message, optional, tag = "4")]
        pub end_time_offset: ::core::option::Option<::prost_types::Duration>,
    }
    /// End previous overlay animation from the video. Without AnimationEnd, the
    /// overlay object will keep the state of previous animation until the end of
    /// the video.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AnimationEnd {
        /// The time to end overlay object, in seconds. Default: 0
        #[prost(message, optional, tag = "1")]
        pub start_time_offset: ::core::option::Option<::prost_types::Duration>,
    }
    /// Animation types.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Animation {
        /// Animations can be static or fade, or they can end the previous animation.
        #[prost(oneof = "animation::AnimationType", tags = "1, 2, 3")]
        pub animation_type: ::core::option::Option<animation::AnimationType>,
    }
    /// Nested message and enum types in `Animation`.
    pub mod animation {
        /// Animations can be static or fade, or they can end the previous animation.
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum AnimationType {
            /// Display static overlay object.
            #[prost(message, tag = "1")]
            AnimationStatic(super::AnimationStatic),
            /// Display overlay object with fade animation.
            #[prost(message, tag = "2")]
            AnimationFade(super::AnimationFade),
            /// End previous animation.
            #[prost(message, tag = "3")]
            AnimationEnd(super::AnimationEnd),
        }
    }
    /// Fade type for the overlay: `FADE_IN` or `FADE_OUT`.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FadeType {
        /// The fade type is not specified.
        Unspecified = 0,
        /// Fade the overlay object into view.
        FadeIn = 1,
        /// Fade the overlay object out of view.
        FadeOut = 2,
    }
    impl FadeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FADE_TYPE_UNSPECIFIED",
                Self::FadeIn => "FADE_IN",
                Self::FadeOut => "FADE_OUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FADE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "FADE_IN" => Some(Self::FadeIn),
                "FADE_OUT" => Some(Self::FadeOut),
                _ => None,
            }
        }
    }
}
/// Preprocessing configurations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreprocessingConfig {
    /// Color preprocessing configuration.
    #[prost(message, optional, tag = "1")]
    pub color: ::core::option::Option<preprocessing_config::Color>,
    /// Denoise preprocessing configuration.
    #[prost(message, optional, tag = "2")]
    pub denoise: ::core::option::Option<preprocessing_config::Denoise>,
    /// Deblock preprocessing configuration.
    #[prost(message, optional, tag = "3")]
    pub deblock: ::core::option::Option<preprocessing_config::Deblock>,
    /// Audio preprocessing configuration.
    #[prost(message, optional, tag = "4")]
    pub audio: ::core::option::Option<preprocessing_config::Audio>,
    /// Specify the video cropping configuration.
    #[prost(message, optional, tag = "5")]
    pub crop: ::core::option::Option<preprocessing_config::Crop>,
    /// Specify the video pad filter configuration.
    #[prost(message, optional, tag = "6")]
    pub pad: ::core::option::Option<preprocessing_config::Pad>,
    /// Specify the video deinterlace configuration.
    #[prost(message, optional, tag = "7")]
    pub deinterlace: ::core::option::Option<preprocessing_config::Deinterlace>,
}
/// Nested message and enum types in `PreprocessingConfig`.
pub mod preprocessing_config {
    /// Color preprocessing configuration.
    ///
    /// **Note:** This configuration is not supported.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Color {
        /// Control color saturation of the video. Enter a value between -1 and 1,
        /// where -1 is fully desaturated and 1 is maximum saturation. 0 is no
        /// change. The default is 0.
        #[prost(double, tag = "1")]
        pub saturation: f64,
        /// Control black and white contrast of the video. Enter a value between -1
        /// and 1, where -1 is minimum contrast and 1 is maximum contrast. 0 is no
        /// change. The default is 0.
        #[prost(double, tag = "2")]
        pub contrast: f64,
        /// Control brightness of the video. Enter a value between -1 and 1, where -1
        /// is minimum brightness and 1 is maximum brightness. 0 is no change. The
        /// default is 0.
        #[prost(double, tag = "3")]
        pub brightness: f64,
    }
    /// Denoise preprocessing configuration.
    ///
    /// **Note:** This configuration is not supported.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Denoise {
        /// Set strength of the denoise. Enter a value between 0 and 1. The higher
        /// the value, the smoother the image. 0 is no denoising. The default is 0.
        #[prost(double, tag = "1")]
        pub strength: f64,
        /// Set the denoiser mode. The default is `standard`.
        ///
        /// Supported denoiser modes:
        ///
        /// - `standard`
        /// - `grain`
        #[prost(string, tag = "2")]
        pub tune: ::prost::alloc::string::String,
    }
    /// Deblock preprocessing configuration.
    ///
    /// **Note:** This configuration is not supported.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Deblock {
        /// Set strength of the deblocker. Enter a value between 0 and 1. The higher
        /// the value, the stronger the block removal. 0 is no deblocking. The
        /// default is 0.
        #[prost(double, tag = "1")]
        pub strength: f64,
        /// Enable deblocker. The default is `false`.
        #[prost(bool, tag = "2")]
        pub enabled: bool,
    }
    /// Audio preprocessing configuration.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Audio {
        /// Specify audio loudness normalization in loudness units relative to full
        /// scale (LUFS). Enter a value between -24 and 0 (the default), where:
        ///
        /// *   -24 is the Advanced Television Systems Committee (ATSC A/85) standard
        /// *   -23 is the EU R128 broadcast standard
        /// *   -19 is the prior standard for online mono audio
        /// *   -18 is the ReplayGain standard
        /// *   -16 is the prior standard for stereo audio
        /// *   -14 is the new online audio standard recommended by Spotify, as well
        ///      as Amazon Echo
        /// *   0 disables normalization
        #[prost(double, tag = "1")]
        pub lufs: f64,
        /// Enable boosting high frequency components. The default is `false`.
        ///
        /// **Note:** This field is not supported.
        #[prost(bool, tag = "2")]
        pub high_boost: bool,
        /// Enable boosting low frequency components. The default is `false`.
        ///
        /// **Note:** This field is not supported.
        #[prost(bool, tag = "3")]
        pub low_boost: bool,
    }
    /// Video cropping configuration for the input video. The cropped input video
    /// is scaled to match the output resolution.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Crop {
        /// The number of pixels to crop from the top. The default is 0.
        #[prost(int32, tag = "1")]
        pub top_pixels: i32,
        /// The number of pixels to crop from the bottom. The default is 0.
        #[prost(int32, tag = "2")]
        pub bottom_pixels: i32,
        /// The number of pixels to crop from the left. The default is 0.
        #[prost(int32, tag = "3")]
        pub left_pixels: i32,
        /// The number of pixels to crop from the right. The default is 0.
        #[prost(int32, tag = "4")]
        pub right_pixels: i32,
    }
    /// Pad filter configuration for the input video. The padded input video
    /// is scaled after padding with black to match the output resolution.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Pad {
        /// The number of pixels to add to the top. The default is 0.
        #[prost(int32, tag = "1")]
        pub top_pixels: i32,
        /// The number of pixels to add to the bottom. The default is 0.
        #[prost(int32, tag = "2")]
        pub bottom_pixels: i32,
        /// The number of pixels to add to the left. The default is 0.
        #[prost(int32, tag = "3")]
        pub left_pixels: i32,
        /// The number of pixels to add to the right. The default is 0.
        #[prost(int32, tag = "4")]
        pub right_pixels: i32,
    }
    /// Deinterlace configuration for input video.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Deinterlace {
        /// Specify the video deinterlacing filter. The default is `yadif`.
        #[prost(oneof = "deinterlace::DeinterlacingFilter", tags = "1, 2")]
        pub deinterlacing_filter: ::core::option::Option<
            deinterlace::DeinterlacingFilter,
        >,
    }
    /// Nested message and enum types in `Deinterlace`.
    pub mod deinterlace {
        /// Yet Another Deinterlacing Filter Configuration.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct YadifConfig {
            /// Specifies the deinterlacing mode to adopt.
            /// The default is `send_frame`.
            /// Supported values:
            ///
            /// - `send_frame`: Output one frame for each frame
            /// - `send_field`: Output one frame for each field
            #[prost(string, tag = "1")]
            pub mode: ::prost::alloc::string::String,
            /// Disable spacial interlacing.
            /// The default is `false`.
            #[prost(bool, tag = "2")]
            pub disable_spatial_interlacing: bool,
            /// The picture field parity assumed for the input interlaced video.
            /// The default is `auto`.
            /// Supported values:
            ///
            /// - `tff`: Assume the top field is first
            /// - `bff`: Assume the bottom field is first
            /// - `auto`: Enable automatic detection of field parity
            #[prost(string, tag = "3")]
            pub parity: ::prost::alloc::string::String,
            /// Deinterlace all frames rather than just the frames identified as
            /// interlaced. The default is `false`.
            #[prost(bool, tag = "4")]
            pub deinterlace_all_frames: bool,
        }
        /// Bob Weaver Deinterlacing Filter Configuration.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BwdifConfig {
            /// Specifies the deinterlacing mode to adopt.
            /// The default is `send_frame`.
            /// Supported values:
            ///
            /// - `send_frame`: Output one frame for each frame
            /// - `send_field`: Output one frame for each field
            #[prost(string, tag = "1")]
            pub mode: ::prost::alloc::string::String,
            /// The picture field parity assumed for the input interlaced video.
            /// The default is `auto`.
            /// Supported values:
            ///
            /// - `tff`: Assume the top field is first
            /// - `bff`: Assume the bottom field is first
            /// - `auto`: Enable automatic detection of field parity
            #[prost(string, tag = "2")]
            pub parity: ::prost::alloc::string::String,
            /// Deinterlace all frames rather than just the frames identified as
            /// interlaced. The default is `false`.
            #[prost(bool, tag = "3")]
            pub deinterlace_all_frames: bool,
        }
        /// Specify the video deinterlacing filter. The default is `yadif`.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum DeinterlacingFilter {
            /// Specifies the Yet Another Deinterlacing Filter Configuration.
            #[prost(message, tag = "1")]
            Yadif(YadifConfig),
            /// Specifies the Bob Weaver Deinterlacing Filter Configuration.
            #[prost(message, tag = "2")]
            Bwdif(BwdifConfig),
        }
    }
}
/// Video stream resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoStream {
    /// Codec settings can be h264, h265, or vp9.
    #[prost(oneof = "video_stream::CodecSettings", tags = "1, 2, 3")]
    pub codec_settings: ::core::option::Option<video_stream::CodecSettings>,
}
/// Nested message and enum types in `VideoStream`.
pub mod video_stream {
    /// H264 codec settings.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct H264CodecSettings {
        /// The width of the video in pixels. Must be an even integer.
        /// When not specified, the width is adjusted to match the specified height
        /// and input aspect ratio. If both are omitted, the input width is used.
        ///
        /// For portrait videos that contain horizontal ASR and rotation metadata,
        /// provide the width, in pixels, per the horizontal ASR. The API calculates
        /// the height per the horizontal ASR. The API detects any rotation metadata
        /// and swaps the requested height and width for the output.
        #[prost(int32, tag = "1")]
        pub width_pixels: i32,
        /// The height of the video in pixels. Must be an even integer.
        /// When not specified, the height is adjusted to match the specified width
        /// and input aspect ratio. If both are omitted, the input height is used.
        ///
        /// For portrait videos that contain horizontal ASR and rotation metadata,
        /// provide the height, in pixels, per the horizontal ASR. The API calculates
        /// the width per the horizontal ASR. The API detects any rotation metadata
        /// and swaps the requested height and width for the output.
        #[prost(int32, tag = "2")]
        pub height_pixels: i32,
        /// Required. The target video frame rate in frames per second (FPS). Must be
        /// less than or equal to 120. Will default to the input frame rate if larger
        /// than the input frame rate. The API will generate an output FPS that is
        /// divisible by the input FPS, and smaller or equal to the target FPS. See
        /// [Calculating frame
        /// rate](<https://cloud.google.com/transcoder/docs/concepts/frame-rate>) for
        /// more information.
        #[prost(double, tag = "3")]
        pub frame_rate: f64,
        /// Required. The video bitrate in bits per second. The minimum value is
        /// 1,000. The maximum value is 800,000,000.
        #[prost(int32, tag = "4")]
        pub bitrate_bps: i32,
        /// Pixel format to use. The default is `yuv420p`.
        ///
        /// Supported pixel formats:
        ///
        /// - `yuv420p` pixel format
        /// - `yuv422p` pixel format
        /// - `yuv444p` pixel format
        /// - `yuv420p10` 10-bit HDR pixel format
        /// - `yuv422p10` 10-bit HDR pixel format
        /// - `yuv444p10` 10-bit HDR pixel format
        /// - `yuv420p12` 12-bit HDR pixel format
        /// - `yuv422p12` 12-bit HDR pixel format
        /// - `yuv444p12` 12-bit HDR pixel format
        #[prost(string, tag = "5")]
        pub pixel_format: ::prost::alloc::string::String,
        /// Specify the `rate_control_mode`. The default is `vbr`.
        ///
        /// Supported rate control modes:
        ///
        /// - `vbr` - variable bitrate
        /// - `crf` - constant rate factor
        #[prost(string, tag = "6")]
        pub rate_control_mode: ::prost::alloc::string::String,
        /// Target CRF level. Must be between 10 and 36, where 10 is the highest
        /// quality and 36 is the most efficient compression. The default is 21.
        #[prost(int32, tag = "7")]
        pub crf_level: i32,
        /// Specifies whether an open Group of Pictures (GOP) structure should be
        /// allowed or not. The default is `false`.
        #[prost(bool, tag = "8")]
        pub allow_open_gop: bool,
        /// Use two-pass encoding strategy to achieve better video quality.
        /// `VideoStream.rate_control_mode` must be `vbr`. The default is `false`.
        #[prost(bool, tag = "11")]
        pub enable_two_pass: bool,
        /// Size of the Video Buffering Verifier (VBV) buffer in bits. Must be
        /// greater than zero. The default is equal to `VideoStream.bitrate_bps`.
        #[prost(int32, tag = "12")]
        pub vbv_size_bits: i32,
        /// Initial fullness of the Video Buffering Verifier (VBV) buffer in bits.
        /// Must be greater than zero. The default is equal to 90% of
        /// `VideoStream.vbv_size_bits`.
        #[prost(int32, tag = "13")]
        pub vbv_fullness_bits: i32,
        /// The entropy coder to use. The default is `cabac`.
        ///
        /// Supported entropy coders:
        ///
        /// - `cavlc`
        /// - `cabac`
        #[prost(string, tag = "14")]
        pub entropy_coder: ::prost::alloc::string::String,
        /// Allow B-pyramid for reference frame selection. This may not be supported
        /// on all decoders. The default is `false`.
        #[prost(bool, tag = "15")]
        pub b_pyramid: bool,
        /// The number of consecutive B-frames. Must be greater than or equal to
        /// zero. Must be less than `VideoStream.gop_frame_count` if set. The default
        /// is 0.
        #[prost(int32, tag = "16")]
        pub b_frame_count: i32,
        /// Specify the intensity of the adaptive quantizer (AQ). Must be between 0
        /// and 1, where 0 disables the quantizer and 1 maximizes the quantizer. A
        /// higher value equals a lower bitrate but smoother image. The default is 0.
        #[prost(double, tag = "17")]
        pub aq_strength: f64,
        /// Enforces the specified codec profile. The following profiles are
        /// supported:
        ///
        /// *   `baseline`
        /// *   `main`
        /// *   `high` (default)
        ///
        /// The available options are
        /// [FFmpeg-compatible](<https://trac.ffmpeg.org/wiki/Encode/H.264#Tune>).
        /// Note that certain values for this field may cause the
        /// transcoder to override other fields you set in the `H264CodecSettings`
        /// message.
        #[prost(string, tag = "18")]
        pub profile: ::prost::alloc::string::String,
        /// Enforces the specified codec tune. The available options are
        /// [FFmpeg-compatible](<https://trac.ffmpeg.org/wiki/Encode/H.264#Tune>).
        /// Note that certain values for this field may cause the
        /// transcoder to override other fields you set in the `H264CodecSettings`
        /// message.
        #[prost(string, tag = "19")]
        pub tune: ::prost::alloc::string::String,
        /// Enforces the specified codec preset. The default is `veryfast`. The
        /// available options are
        /// [FFmpeg-compatible](<https://trac.ffmpeg.org/wiki/Encode/H.264#Preset>).
        /// Note that certain values for this field may cause the
        /// transcoder to override other fields you set in the `H264CodecSettings`
        /// message.
        #[prost(string, tag = "20")]
        pub preset: ::prost::alloc::string::String,
        /// GOP mode can be either by frame count or duration.
        #[prost(oneof = "h264_codec_settings::GopMode", tags = "9, 10")]
        pub gop_mode: ::core::option::Option<h264_codec_settings::GopMode>,
    }
    /// Nested message and enum types in `H264CodecSettings`.
    pub mod h264_codec_settings {
        /// GOP mode can be either by frame count or duration.
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum GopMode {
            /// Select the GOP size based on the specified frame count. Must be greater
            /// than zero.
            #[prost(int32, tag = "9")]
            GopFrameCount(i32),
            /// Select the GOP size based on the specified duration. The default is
            /// `3s`. Note that `gopDuration` must be less than or equal to
            /// [`segmentDuration`](#SegmentSettings), and
            /// [`segmentDuration`](#SegmentSettings) must be divisible by
            /// `gopDuration`.
            #[prost(message, tag = "10")]
            GopDuration(::prost_types::Duration),
        }
    }
    /// H265 codec settings.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct H265CodecSettings {
        /// The width of the video in pixels. Must be an even integer.
        /// When not specified, the width is adjusted to match the specified height
        /// and input aspect ratio. If both are omitted, the input width is used.
        ///
        /// For portrait videos that contain horizontal ASR and rotation metadata,
        /// provide the width, in pixels, per the horizontal ASR. The API calculates
        /// the height per the horizontal ASR. The API detects any rotation metadata
        /// and swaps the requested height and width for the output.
        #[prost(int32, tag = "1")]
        pub width_pixels: i32,
        /// The height of the video in pixels. Must be an even integer.
        /// When not specified, the height is adjusted to match the specified width
        /// and input aspect ratio. If both are omitted, the input height is used.
        ///
        /// For portrait videos that contain horizontal ASR and rotation metadata,
        /// provide the height, in pixels, per the horizontal ASR. The API calculates
        /// the width per the horizontal ASR. The API detects any rotation metadata
        /// and swaps the requested height and width for the output.
        #[prost(int32, tag = "2")]
        pub height_pixels: i32,
        /// Required. The target video frame rate in frames per second (FPS). Must be
        /// less than or equal to 120. Will default to the input frame rate if larger
        /// than the input frame rate. The API will generate an output FPS that is
        /// divisible by the input FPS, and smaller or equal to the target FPS. See
        /// [Calculating frame
        /// rate](<https://cloud.google.com/transcoder/docs/concepts/frame-rate>) for
        /// more information.
        #[prost(double, tag = "3")]
        pub frame_rate: f64,
        /// Required. The video bitrate in bits per second. The minimum value is
        /// 1,000. The maximum value is 800,000,000.
        #[prost(int32, tag = "4")]
        pub bitrate_bps: i32,
        /// Pixel format to use. The default is `yuv420p`.
        ///
        /// Supported pixel formats:
        ///
        /// - `yuv420p` pixel format
        /// - `yuv422p` pixel format
        /// - `yuv444p` pixel format
        /// - `yuv420p10` 10-bit HDR pixel format
        /// - `yuv422p10` 10-bit HDR pixel format
        /// - `yuv444p10` 10-bit HDR pixel format
        /// - `yuv420p12` 12-bit HDR pixel format
        /// - `yuv422p12` 12-bit HDR pixel format
        /// - `yuv444p12` 12-bit HDR pixel format
        #[prost(string, tag = "5")]
        pub pixel_format: ::prost::alloc::string::String,
        /// Specify the `rate_control_mode`. The default is `vbr`.
        ///
        /// Supported rate control modes:
        ///
        /// - `vbr` - variable bitrate
        /// - `crf` - constant rate factor
        #[prost(string, tag = "6")]
        pub rate_control_mode: ::prost::alloc::string::String,
        /// Target CRF level. Must be between 10 and 36, where 10 is the highest
        /// quality and 36 is the most efficient compression. The default is 21.
        #[prost(int32, tag = "7")]
        pub crf_level: i32,
        /// Specifies whether an open Group of Pictures (GOP) structure should be
        /// allowed or not. The default is `false`.
        #[prost(bool, tag = "8")]
        pub allow_open_gop: bool,
        /// Use two-pass encoding strategy to achieve better video quality.
        /// `VideoStream.rate_control_mode` must be `vbr`. The default is `false`.
        #[prost(bool, tag = "11")]
        pub enable_two_pass: bool,
        /// Size of the Video Buffering Verifier (VBV) buffer in bits. Must be
        /// greater than zero. The default is equal to `VideoStream.bitrate_bps`.
        #[prost(int32, tag = "12")]
        pub vbv_size_bits: i32,
        /// Initial fullness of the Video Buffering Verifier (VBV) buffer in bits.
        /// Must be greater than zero. The default is equal to 90% of
        /// `VideoStream.vbv_size_bits`.
        #[prost(int32, tag = "13")]
        pub vbv_fullness_bits: i32,
        /// Allow B-pyramid for reference frame selection. This may not be supported
        /// on all decoders. The default is `false`.
        #[prost(bool, tag = "14")]
        pub b_pyramid: bool,
        /// The number of consecutive B-frames. Must be greater than or equal to
        /// zero. Must be less than `VideoStream.gop_frame_count` if set. The default
        /// is 0.
        #[prost(int32, tag = "15")]
        pub b_frame_count: i32,
        /// Specify the intensity of the adaptive quantizer (AQ). Must be between 0
        /// and 1, where 0 disables the quantizer and 1 maximizes the quantizer. A
        /// higher value equals a lower bitrate but smoother image. The default is 0.
        #[prost(double, tag = "16")]
        pub aq_strength: f64,
        /// Enforces the specified codec profile. The following profiles are
        /// supported:
        ///
        /// *   8-bit profiles
        ///      *   `main` (default)
        ///      *   `main-intra`
        ///      *   `mainstillpicture`
        /// *   10-bit profiles
        ///      *   `main10` (default)
        ///      *   `main10-intra`
        ///      *   `main422-10`
        ///      *   `main422-10-intra`
        ///      *   `main444-10`
        ///      *   `main444-10-intra`
        /// *   12-bit profiles
        ///      *   `main12` (default)
        ///      *   `main12-intra`
        ///      *   `main422-12`
        ///      *   `main422-12-intra`
        ///      *   `main444-12`
        ///      *   `main444-12-intra`
        ///
        /// The available options are
        /// [FFmpeg-compatible](<https://x265.readthedocs.io/>).
        /// Note that certain values for this field may cause the
        /// transcoder to override other fields you set in the `H265CodecSettings`
        /// message.
        #[prost(string, tag = "17")]
        pub profile: ::prost::alloc::string::String,
        /// Enforces the specified codec tune. The available options are
        /// [FFmpeg-compatible](<https://trac.ffmpeg.org/wiki/Encode/H.265>).
        /// Note that certain values for this field may cause the
        /// transcoder to override other fields you set in the `H265CodecSettings`
        /// message.
        #[prost(string, tag = "18")]
        pub tune: ::prost::alloc::string::String,
        /// Enforces the specified codec preset. The default is `veryfast`. The
        /// available options are
        /// [FFmpeg-compatible](<https://trac.ffmpeg.org/wiki/Encode/H.265>).
        /// Note that certain values for this field may cause the
        /// transcoder to override other fields you set in the `H265CodecSettings`
        /// message.
        #[prost(string, tag = "19")]
        pub preset: ::prost::alloc::string::String,
        /// GOP mode can be either by frame count or duration.
        #[prost(oneof = "h265_codec_settings::GopMode", tags = "9, 10")]
        pub gop_mode: ::core::option::Option<h265_codec_settings::GopMode>,
    }
    /// Nested message and enum types in `H265CodecSettings`.
    pub mod h265_codec_settings {
        /// GOP mode can be either by frame count or duration.
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum GopMode {
            /// Select the GOP size based on the specified frame count. Must be greater
            /// than zero.
            #[prost(int32, tag = "9")]
            GopFrameCount(i32),
            /// Select the GOP size based on the specified duration. The default is
            /// `3s`. Note that `gopDuration` must be less than or equal to
            /// [`segmentDuration`](#SegmentSettings), and
            /// [`segmentDuration`](#SegmentSettings) must be divisible by
            /// `gopDuration`.
            #[prost(message, tag = "10")]
            GopDuration(::prost_types::Duration),
        }
    }
    /// VP9 codec settings.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Vp9CodecSettings {
        /// The width of the video in pixels. Must be an even integer.
        /// When not specified, the width is adjusted to match the specified height
        /// and input aspect ratio. If both are omitted, the input width is used.
        ///
        /// For portrait videos that contain horizontal ASR and rotation metadata,
        /// provide the width, in pixels, per the horizontal ASR. The API calculates
        /// the height per the horizontal ASR. The API detects any rotation metadata
        /// and swaps the requested height and width for the output.
        #[prost(int32, tag = "1")]
        pub width_pixels: i32,
        /// The height of the video in pixels. Must be an even integer.
        /// When not specified, the height is adjusted to match the specified width
        /// and input aspect ratio. If both are omitted, the input height is used.
        ///
        /// For portrait videos that contain horizontal ASR and rotation metadata,
        /// provide the height, in pixels, per the horizontal ASR. The API calculates
        /// the width per the horizontal ASR. The API detects any rotation metadata
        /// and swaps the requested height and width for the output.
        #[prost(int32, tag = "2")]
        pub height_pixels: i32,
        /// Required. The target video frame rate in frames per second (FPS). Must be
        /// less than or equal to 120. Will default to the input frame rate if larger
        /// than the input frame rate. The API will generate an output FPS that is
        /// divisible by the input FPS, and smaller or equal to the target FPS. See
        /// [Calculating frame
        /// rate](<https://cloud.google.com/transcoder/docs/concepts/frame-rate>) for
        /// more information.
        #[prost(double, tag = "3")]
        pub frame_rate: f64,
        /// Required. The video bitrate in bits per second. The minimum value is
        /// 1,000. The maximum value is 480,000,000.
        #[prost(int32, tag = "4")]
        pub bitrate_bps: i32,
        /// Pixel format to use. The default is `yuv420p`.
        ///
        /// Supported pixel formats:
        ///
        /// - `yuv420p` pixel format
        /// - `yuv422p` pixel format
        /// - `yuv444p` pixel format
        /// - `yuv420p10` 10-bit HDR pixel format
        /// - `yuv422p10` 10-bit HDR pixel format
        /// - `yuv444p10` 10-bit HDR pixel format
        /// - `yuv420p12` 12-bit HDR pixel format
        /// - `yuv422p12` 12-bit HDR pixel format
        /// - `yuv444p12` 12-bit HDR pixel format
        #[prost(string, tag = "5")]
        pub pixel_format: ::prost::alloc::string::String,
        /// Specify the `rate_control_mode`. The default is `vbr`.
        ///
        /// Supported rate control modes:
        ///
        /// - `vbr` - variable bitrate
        #[prost(string, tag = "6")]
        pub rate_control_mode: ::prost::alloc::string::String,
        /// Target CRF level. Must be between 10 and 36, where 10 is the highest
        /// quality and 36 is the most efficient compression. The default is 21.
        ///
        /// **Note:** This field is not supported.
        #[prost(int32, tag = "7")]
        pub crf_level: i32,
        /// Enforces the specified codec profile. The following profiles are
        /// supported:
        ///
        /// *   `profile0` (default)
        /// *   `profile1`
        /// *   `profile2`
        /// *   `profile3`
        ///
        /// The available options are
        /// [WebM-compatible](<https://www.webmproject.org/vp9/profiles/>).
        /// Note that certain values for this field may cause the
        /// transcoder to override other fields you set in the `Vp9CodecSettings`
        /// message.
        #[prost(string, tag = "10")]
        pub profile: ::prost::alloc::string::String,
        /// GOP mode can be either by frame count or duration.
        #[prost(oneof = "vp9_codec_settings::GopMode", tags = "8, 9")]
        pub gop_mode: ::core::option::Option<vp9_codec_settings::GopMode>,
    }
    /// Nested message and enum types in `Vp9CodecSettings`.
    pub mod vp9_codec_settings {
        /// GOP mode can be either by frame count or duration.
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum GopMode {
            /// Select the GOP size based on the specified frame count. Must be greater
            /// than zero.
            #[prost(int32, tag = "8")]
            GopFrameCount(i32),
            /// Select the GOP size based on the specified duration. The default is
            /// `3s`. Note that `gopDuration` must be less than or equal to
            /// [`segmentDuration`](#SegmentSettings), and
            /// [`segmentDuration`](#SegmentSettings) must be divisible by
            /// `gopDuration`.
            #[prost(message, tag = "9")]
            GopDuration(::prost_types::Duration),
        }
    }
    /// Codec settings can be h264, h265, or vp9.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CodecSettings {
        /// H264 codec settings.
        #[prost(message, tag = "1")]
        H264(H264CodecSettings),
        /// H265 codec settings.
        #[prost(message, tag = "2")]
        H265(H265CodecSettings),
        /// VP9 codec settings.
        #[prost(message, tag = "3")]
        Vp9(Vp9CodecSettings),
    }
}
/// Audio stream resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioStream {
    /// The codec for this audio stream. The default is `aac`.
    ///
    /// Supported audio codecs:
    ///
    /// - `aac`
    /// - `aac-he`
    /// - `aac-he-v2`
    /// - `mp3`
    /// - `ac3`
    /// - `eac3`
    #[prost(string, tag = "1")]
    pub codec: ::prost::alloc::string::String,
    /// Required. Audio bitrate in bits per second. Must be between 1 and
    /// 10,000,000.
    #[prost(int32, tag = "2")]
    pub bitrate_bps: i32,
    /// Number of audio channels. Must be between 1 and 6. The default is 2.
    #[prost(int32, tag = "3")]
    pub channel_count: i32,
    /// A list of channel names specifying layout of the audio channels.
    /// This only affects the metadata embedded in the container headers, if
    /// supported by the specified format. The default is `\["fl", "fr"\]`.
    ///
    /// Supported channel names:
    ///
    /// - `fl` - Front left channel
    /// - `fr` - Front right channel
    /// - `sl` - Side left channel
    /// - `sr` - Side right channel
    /// - `fc` - Front center channel
    /// - `lfe` - Low frequency
    #[prost(string, repeated, tag = "4")]
    pub channel_layout: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The mapping for the `Job.edit_list` atoms with audio `EditAtom.inputs`.
    #[prost(message, repeated, tag = "5")]
    pub mapping: ::prost::alloc::vec::Vec<audio_stream::AudioMapping>,
    /// The audio sample rate in Hertz. The default is 48000 Hertz.
    #[prost(int32, tag = "6")]
    pub sample_rate_hertz: i32,
    /// The BCP-47 language code, such as `en-US` or `sr-Latn`. For more
    /// information, see
    /// <https://www.unicode.org/reports/tr35/#Unicode_locale_identifier.> Not
    /// supported in MP4 files.
    #[prost(string, tag = "7")]
    pub language_code: ::prost::alloc::string::String,
    /// The name for this particular audio stream that
    /// will be added to the HLS/DASH manifest. Not supported in MP4 files.
    #[prost(string, tag = "8")]
    pub display_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AudioStream`.
pub mod audio_stream {
    /// The mapping for the `Job.edit_list` atoms with audio `EditAtom.inputs`.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AudioMapping {
        /// Required. The `EditAtom.key` that references the atom with audio inputs
        /// in the `Job.edit_list`.
        #[prost(string, tag = "1")]
        pub atom_key: ::prost::alloc::string::String,
        /// Required. The `Input.key` that identifies the input file.
        #[prost(string, tag = "2")]
        pub input_key: ::prost::alloc::string::String,
        /// Required. The zero-based index of the track in the input file.
        #[prost(int32, tag = "3")]
        pub input_track: i32,
        /// Required. The zero-based index of the channel in the input audio stream.
        #[prost(int32, tag = "4")]
        pub input_channel: i32,
        /// Required. The zero-based index of the channel in the output audio stream.
        #[prost(int32, tag = "5")]
        pub output_channel: i32,
        /// Audio volume control in dB. Negative values decrease volume,
        /// positive values increase. The default is 0.
        #[prost(double, tag = "6")]
        pub gain_db: f64,
    }
}
/// Encoding of a text stream. For example, closed captions or subtitles.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextStream {
    /// The codec for this text stream. The default is `webvtt`.
    ///
    /// Supported text codecs:
    ///
    /// - `srt`
    /// - `ttml`
    /// - `cea608`
    /// - `cea708`
    /// - `webvtt`
    #[prost(string, tag = "1")]
    pub codec: ::prost::alloc::string::String,
    /// The BCP-47 language code, such as `en-US` or `sr-Latn`. For more
    /// information, see
    /// <https://www.unicode.org/reports/tr35/#Unicode_locale_identifier.> Not
    /// supported in MP4 files.
    #[prost(string, tag = "2")]
    pub language_code: ::prost::alloc::string::String,
    /// The mapping for the `Job.edit_list` atoms with text `EditAtom.inputs`.
    #[prost(message, repeated, tag = "3")]
    pub mapping: ::prost::alloc::vec::Vec<text_stream::TextMapping>,
    /// The name for this particular text stream that
    /// will be added to the HLS/DASH manifest. Not supported in MP4 files.
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TextStream`.
pub mod text_stream {
    /// The mapping for the `Job.edit_list` atoms with text `EditAtom.inputs`.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextMapping {
        /// Required. The `EditAtom.key` that references atom with text inputs in the
        /// `Job.edit_list`.
        #[prost(string, tag = "1")]
        pub atom_key: ::prost::alloc::string::String,
        /// Required. The `Input.key` that identifies the input file.
        #[prost(string, tag = "2")]
        pub input_key: ::prost::alloc::string::String,
        /// Required. The zero-based index of the track in the input file.
        #[prost(int32, tag = "3")]
        pub input_track: i32,
    }
}
/// Segment settings for `ts`, `fmp4` and `vtt`.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SegmentSettings {
    /// Duration of the segments in seconds. The default is `6.0s`. Note that
    /// `segmentDuration` must be greater than or equal to
    /// [`gopDuration`](#videostream), and `segmentDuration` must be divisible by
    /// [`gopDuration`](#videostream).
    #[prost(message, optional, tag = "1")]
    pub segment_duration: ::core::option::Option<::prost_types::Duration>,
    /// Required. Create an individual segment file. The default is `false`.
    #[prost(bool, tag = "3")]
    pub individual_segments: bool,
}
/// Encryption settings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Encryption {
    /// Required. Identifier for this set of encryption options.
    #[prost(string, tag = "6")]
    pub id: ::prost::alloc::string::String,
    /// Required. DRM system(s) to use; at least one must be specified. If a
    /// DRM system is omitted, it is considered disabled.
    #[prost(message, optional, tag = "8")]
    pub drm_systems: ::core::option::Option<encryption::DrmSystems>,
    /// Encryption mode can be either `aes` or `cenc`.
    #[prost(oneof = "encryption::EncryptionMode", tags = "3, 4, 5")]
    pub encryption_mode: ::core::option::Option<encryption::EncryptionMode>,
    /// Defines where content keys are stored.
    #[prost(oneof = "encryption::SecretSource", tags = "7")]
    pub secret_source: ::core::option::Option<encryption::SecretSource>,
}
/// Nested message and enum types in `Encryption`.
pub mod encryption {
    /// Configuration for AES-128 encryption.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Aes128Encryption {}
    /// Configuration for SAMPLE-AES encryption.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SampleAesEncryption {}
    /// Configuration for MPEG Common Encryption (MPEG-CENC).
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MpegCommonEncryption {
        /// Required. Specify the encryption scheme.
        ///
        /// Supported encryption schemes:
        ///
        /// - `cenc`
        /// - `cbcs`
        #[prost(string, tag = "2")]
        pub scheme: ::prost::alloc::string::String,
    }
    /// Configuration for secrets stored in Google Secret Manager.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SecretManagerSource {
        /// Required. The name of the Secret Version containing the encryption key in
        /// the following format:
        /// `projects/{project}/secrets/{secret_id}/versions/{version_number}`
        ///
        /// Note that only numbered versions are supported. Aliases like "latest" are
        /// not supported.
        #[prost(string, tag = "1")]
        pub secret_version: ::prost::alloc::string::String,
    }
    /// Widevine configuration.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Widevine {}
    /// Fairplay configuration.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Fairplay {}
    /// Playready configuration.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Playready {}
    /// Clearkey configuration.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Clearkey {}
    /// Defines configuration for DRM systems in use.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DrmSystems {
        /// Widevine configuration.
        #[prost(message, optional, tag = "1")]
        pub widevine: ::core::option::Option<Widevine>,
        /// Fairplay configuration.
        #[prost(message, optional, tag = "2")]
        pub fairplay: ::core::option::Option<Fairplay>,
        /// Playready configuration.
        #[prost(message, optional, tag = "3")]
        pub playready: ::core::option::Option<Playready>,
        /// Clearkey configuration.
        #[prost(message, optional, tag = "4")]
        pub clearkey: ::core::option::Option<Clearkey>,
    }
    /// Encryption mode can be either `aes` or `cenc`.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EncryptionMode {
        /// Configuration for AES-128 encryption.
        #[prost(message, tag = "3")]
        Aes128(Aes128Encryption),
        /// Configuration for SAMPLE-AES encryption.
        #[prost(message, tag = "4")]
        SampleAes(SampleAesEncryption),
        /// Configuration for MPEG Common Encryption (MPEG-CENC).
        #[prost(message, tag = "5")]
        MpegCenc(MpegCommonEncryption),
    }
    /// Defines where content keys are stored.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SecretSource {
        /// Keys are stored in Google Secret Manager.
        #[prost(message, tag = "7")]
        SecretManagerKeySource(SecretManagerSource),
    }
}
/// Request message for `TranscoderService.CreateJob`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateJobRequest {
    /// Required. The parent location to create and process this job.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Parameters for creating transcoding job.
    #[prost(message, optional, tag = "2")]
    pub job: ::core::option::Option<Job>,
}
/// Request message for `TranscoderService.ListJobs`.
/// The parent location from which to retrieve the collection of jobs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsRequest {
    /// Required. Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of items to return.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The `next_page_token` value returned from a previous List request, if
    /// any.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// The filter expression, following the syntax outlined in
    /// <https://google.aip.dev/160.>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// One or more fields to compare and use to sort the output.
    /// See <https://google.aip.dev/132#ordering.>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Request message for `TranscoderService.GetJob`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobRequest {
    /// Required. The name of the job to retrieve.
    /// Format: `projects/{project}/locations/{location}/jobs/{job}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for `TranscoderService.DeleteJob`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteJobRequest {
    /// Required. The name of the job to delete.
    /// Format: `projects/{project}/locations/{location}/jobs/{job}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// If set to true, and the job is not found, the request will succeed but no
    /// action will be taken on the server.
    #[prost(bool, tag = "2")]
    pub allow_missing: bool,
}
/// Response message for `TranscoderService.ListJobs`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsResponse {
    /// List of jobs in the specified region.
    #[prost(message, repeated, tag = "1")]
    pub jobs: ::prost::alloc::vec::Vec<Job>,
    /// The pagination token.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// List of regions that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request message for `TranscoderService.CreateJobTemplate`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateJobTemplateRequest {
    /// Required. The parent location to create this job template.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Parameters for creating job template.
    #[prost(message, optional, tag = "2")]
    pub job_template: ::core::option::Option<JobTemplate>,
    /// Required. The ID to use for the job template, which will become the final
    /// component of the job template's resource name.
    ///
    /// This value should be 4-63 characters, and valid characters must match the
    /// regular expression `[a-zA-Z][a-zA-Z0-9_-]*`.
    #[prost(string, tag = "3")]
    pub job_template_id: ::prost::alloc::string::String,
}
/// Request message for `TranscoderService.ListJobTemplates`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobTemplatesRequest {
    /// Required. The parent location from which to retrieve the collection of job
    /// templates. Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of items to return.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The `next_page_token` value returned from a previous List request, if
    /// any.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// The filter expression, following the syntax outlined in
    /// <https://google.aip.dev/160.>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// One or more fields to compare and use to sort the output.
    /// See <https://google.aip.dev/132#ordering.>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Request message for `TranscoderService.GetJobTemplate`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobTemplateRequest {
    /// Required. The name of the job template to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/jobTemplates/{job_template}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for `TranscoderService.DeleteJobTemplate`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteJobTemplateRequest {
    /// Required. The name of the job template to delete.
    /// `projects/{project}/locations/{location}/jobTemplates/{job_template}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// If set to true, and the job template is not found, the request will succeed
    /// but no action will be taken on the server.
    #[prost(bool, tag = "2")]
    pub allow_missing: bool,
}
/// Response message for `TranscoderService.ListJobTemplates`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobTemplatesResponse {
    /// List of job templates in the specified region.
    #[prost(message, repeated, tag = "1")]
    pub job_templates: ::prost::alloc::vec::Vec<JobTemplate>,
    /// The pagination token.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// List of regions that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Generated client implementations.
pub mod transcoder_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Using the Transcoder API, you can queue asynchronous jobs for transcoding
    /// media into various output formats. Output formats may include different
    /// streaming standards such as HTTP Live Streaming (HLS) and Dynamic Adaptive
    /// Streaming over HTTP (DASH). You can also customize jobs using advanced
    /// features such as Digital Rights Management (DRM), audio equalization, content
    /// concatenation, and digital ad-stitch ready content generation.
    #[derive(Debug, Clone)]
    pub struct TranscoderServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TranscoderServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TranscoderServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TranscoderServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TranscoderServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a job in the specified region.
        pub async fn create_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateJobRequest>,
        ) -> std::result::Result<tonic::Response<super::Job>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.transcoder.v1.TranscoderService/CreateJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.video.transcoder.v1.TranscoderService",
                        "CreateJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists jobs in the specified region.
        pub async fn list_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListJobsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListJobsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.transcoder.v1.TranscoderService/ListJobs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.video.transcoder.v1.TranscoderService",
                        "ListJobs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the job data.
        pub async fn get_job(
            &mut self,
            request: impl tonic::IntoRequest<super::GetJobRequest>,
        ) -> std::result::Result<tonic::Response<super::Job>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.transcoder.v1.TranscoderService/GetJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.video.transcoder.v1.TranscoderService",
                        "GetJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a job.
        pub async fn delete_job(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteJobRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.transcoder.v1.TranscoderService/DeleteJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.video.transcoder.v1.TranscoderService",
                        "DeleteJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a job template in the specified region.
        pub async fn create_job_template(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateJobTemplateRequest>,
        ) -> std::result::Result<tonic::Response<super::JobTemplate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.transcoder.v1.TranscoderService/CreateJobTemplate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.video.transcoder.v1.TranscoderService",
                        "CreateJobTemplate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists job templates in the specified region.
        pub async fn list_job_templates(
            &mut self,
            request: impl tonic::IntoRequest<super::ListJobTemplatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListJobTemplatesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.transcoder.v1.TranscoderService/ListJobTemplates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.video.transcoder.v1.TranscoderService",
                        "ListJobTemplates",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the job template data.
        pub async fn get_job_template(
            &mut self,
            request: impl tonic::IntoRequest<super::GetJobTemplateRequest>,
        ) -> std::result::Result<tonic::Response<super::JobTemplate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.transcoder.v1.TranscoderService/GetJobTemplate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.video.transcoder.v1.TranscoderService",
                        "GetJobTemplate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a job template.
        pub async fn delete_job_template(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteJobTemplateRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.video.transcoder.v1.TranscoderService/DeleteJobTemplate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.video.transcoder.v1.TranscoderService",
                        "DeleteJobTemplate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
