// This file is @generated by prost-build.
/// Generated client implementations.
pub mod sql_available_database_versions_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service that exposes Cloud SQL database versions information. This
    /// service is only used internally.
    #[derive(Debug, Clone)]
    pub struct SqlAvailableDatabaseVersionsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlAvailableDatabaseVersionsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlAvailableDatabaseVersionsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlAvailableDatabaseVersionsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlAvailableDatabaseVersionsServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
    }
}
/// An entry for an Access Control list.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AclEntry {
    /// The allowlisted value for the access control list.
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
    /// The time when this access control entry expires in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "2")]
    pub expiration_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. A label to identify this entry.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// This is always `sql#aclEntry`.
    #[prost(string, tag = "4")]
    pub kind: ::prost::alloc::string::String,
}
/// An Admin API warning message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiWarning {
    /// Code to uniquely identify the warning type.
    #[prost(enumeration = "api_warning::SqlApiWarningCode", tag = "1")]
    pub code: i32,
    /// The warning message.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// The region name for REGION_UNREACHABLE warning.
    #[prost(string, tag = "3")]
    pub region: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ApiWarning`.
pub mod api_warning {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlApiWarningCode {
        /// An unknown or unset warning type from Cloud SQL API.
        Unspecified = 0,
        /// Warning when one or more regions are not reachable.  The returned result
        /// set may be incomplete.
        RegionUnreachable = 1,
        /// Warning when user provided maxResults parameter exceeds the limit.  The
        /// returned result set may be incomplete.
        MaxResultsExceedsLimit = 2,
        /// Warning when user tries to create/update a user with credentials that
        /// have previously been compromised by a public data breach.
        CompromisedCredentials = 3,
        /// Warning when the operation succeeds but some non-critical workflow state
        /// failed.
        InternalStateFailure = 4,
    }
    impl SqlApiWarningCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SQL_API_WARNING_CODE_UNSPECIFIED",
                Self::RegionUnreachable => "REGION_UNREACHABLE",
                Self::MaxResultsExceedsLimit => "MAX_RESULTS_EXCEEDS_LIMIT",
                Self::CompromisedCredentials => "COMPROMISED_CREDENTIALS",
                Self::InternalStateFailure => "INTERNAL_STATE_FAILURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_API_WARNING_CODE_UNSPECIFIED" => Some(Self::Unspecified),
                "REGION_UNREACHABLE" => Some(Self::RegionUnreachable),
                "MAX_RESULTS_EXCEEDS_LIMIT" => Some(Self::MaxResultsExceedsLimit),
                "COMPROMISED_CREDENTIALS" => Some(Self::CompromisedCredentials),
                "INTERNAL_STATE_FAILURE" => Some(Self::InternalStateFailure),
                _ => None,
            }
        }
    }
}
/// We currently only support backup retention by specifying the number
/// of backups we will retain.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BackupRetentionSettings {
    /// The unit that 'retained_backups' represents.
    #[prost(enumeration = "backup_retention_settings::RetentionUnit", tag = "1")]
    pub retention_unit: i32,
    /// Depending on the value of retention_unit, this is used to determine
    /// if a backup needs to be deleted.  If retention_unit is 'COUNT', we will
    /// retain this many backups.
    #[prost(message, optional, tag = "2")]
    pub retained_backups: ::core::option::Option<i32>,
}
/// Nested message and enum types in `BackupRetentionSettings`.
pub mod backup_retention_settings {
    /// The units that retained_backups specifies, we only support COUNT.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RetentionUnit {
        /// Backup retention unit is unspecified, will be treated as COUNT.
        Unspecified = 0,
        /// Retention will be by count, eg. "retain the most recent 7 backups".
        Count = 1,
    }
    impl RetentionUnit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RETENTION_UNIT_UNSPECIFIED",
                Self::Count => "COUNT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RETENTION_UNIT_UNSPECIFIED" => Some(Self::Unspecified),
                "COUNT" => Some(Self::Count),
                _ => None,
            }
        }
    }
}
/// Database instance backup configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupConfiguration {
    /// Start time for the daily backup configuration in UTC timezone in the 24
    /// hour format - `HH:MM`.
    #[prost(string, tag = "1")]
    pub start_time: ::prost::alloc::string::String,
    /// Whether this configuration is enabled.
    #[prost(message, optional, tag = "2")]
    pub enabled: ::core::option::Option<bool>,
    /// This is always `sql#backupConfiguration`.
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
    /// (MySQL only) Whether binary log is enabled. If backup configuration is
    /// disabled, binarylog must be disabled as well.
    #[prost(message, optional, tag = "4")]
    pub binary_log_enabled: ::core::option::Option<bool>,
    /// Reserved for future use.
    #[prost(message, optional, tag = "5")]
    pub replication_log_archiving_enabled: ::core::option::Option<bool>,
    /// Location of the backup
    #[prost(string, tag = "6")]
    pub location: ::prost::alloc::string::String,
    /// Whether point in time recovery is enabled.
    #[prost(message, optional, tag = "7")]
    pub point_in_time_recovery_enabled: ::core::option::Option<bool>,
    /// Backup retention settings.
    #[prost(message, optional, tag = "8")]
    pub backup_retention_settings: ::core::option::Option<BackupRetentionSettings>,
    /// The number of days of transaction logs we retain for point in time
    /// restore, from 1-7.
    #[prost(message, optional, tag = "9")]
    pub transaction_log_retention_days: ::core::option::Option<i32>,
    /// Output only. This value contains the storage location of transactional logs
    /// used to perform point-in-time recovery (PITR) for the database.
    #[prost(
        enumeration = "backup_configuration::TransactionalLogStorageState",
        optional,
        tag = "10"
    )]
    pub transactional_log_storage_state: ::core::option::Option<i32>,
}
/// Nested message and enum types in `BackupConfiguration`.
pub mod backup_configuration {
    /// This value contains the storage location of the transactional logs
    /// used to perform point-in-time recovery (PITR) for the database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransactionalLogStorageState {
        /// Unspecified.
        Unspecified = 0,
        /// The transaction logs used for PITR for the instance are stored
        /// on a data disk.
        Disk = 1,
        /// The transaction logs used for PITR for the instance are switching from
        /// being stored on a data disk to being stored in Cloud Storage.
        /// Only applicable to MySQL.
        SwitchingToCloudStorage = 2,
        /// The transaction logs used for PITR for the instance are now stored
        /// in Cloud Storage. Previously, they were stored on a data disk.
        /// Only applicable to MySQL.
        SwitchedToCloudStorage = 3,
        /// The transaction logs used for PITR for the instance are stored in
        /// Cloud Storage. Only applicable to MySQL and PostgreSQL.
        CloudStorage = 4,
    }
    impl TransactionalLogStorageState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TRANSACTIONAL_LOG_STORAGE_STATE_UNSPECIFIED",
                Self::Disk => "DISK",
                Self::SwitchingToCloudStorage => "SWITCHING_TO_CLOUD_STORAGE",
                Self::SwitchedToCloudStorage => "SWITCHED_TO_CLOUD_STORAGE",
                Self::CloudStorage => "CLOUD_STORAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRANSACTIONAL_LOG_STORAGE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "DISK" => Some(Self::Disk),
                "SWITCHING_TO_CLOUD_STORAGE" => Some(Self::SwitchingToCloudStorage),
                "SWITCHED_TO_CLOUD_STORAGE" => Some(Self::SwitchedToCloudStorage),
                "CLOUD_STORAGE" => Some(Self::CloudStorage),
                _ => None,
            }
        }
    }
}
/// Perform disk shrink context.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PerformDiskShrinkContext {
    /// The target disk shrink size in GigaBytes.
    #[prost(int64, tag = "1")]
    pub target_size_gb: i64,
}
/// Backup context.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupContext {
    /// The identifier of the backup.
    #[prost(int64, tag = "1")]
    pub backup_id: i64,
    /// This is always `sql#backupContext`.
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
}
/// Represents a SQL database on the Cloud SQL instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Database {
    /// This is always `sql#database`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The Cloud SQL charset value.
    #[prost(string, tag = "2")]
    pub charset: ::prost::alloc::string::String,
    /// The Cloud SQL collation value.
    #[prost(string, tag = "3")]
    pub collation: ::prost::alloc::string::String,
    /// This field is deprecated and will be removed from a future version of the
    /// API.
    #[prost(string, tag = "4")]
    pub etag: ::prost::alloc::string::String,
    /// The name of the database in the Cloud SQL instance. This does not include
    /// the project ID or instance name.
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    /// The name of the Cloud SQL instance. This does not include the project ID.
    #[prost(string, tag = "6")]
    pub instance: ::prost::alloc::string::String,
    /// The URI of this resource.
    #[prost(string, tag = "7")]
    pub self_link: ::prost::alloc::string::String,
    /// The project ID of the project containing the Cloud SQL database. The Google
    /// apps domain is prefixed if applicable.
    #[prost(string, tag = "8")]
    pub project: ::prost::alloc::string::String,
    #[prost(oneof = "database::DatabaseDetails", tags = "9")]
    pub database_details: ::core::option::Option<database::DatabaseDetails>,
}
/// Nested message and enum types in `Database`.
pub mod database {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DatabaseDetails {
        #[prost(message, tag = "9")]
        SqlserverDatabaseDetails(super::SqlServerDatabaseDetails),
    }
}
/// Represents a Sql Server database on the Cloud SQL instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlServerDatabaseDetails {
    /// The version of SQL Server with which the database is to be made compatible
    #[prost(int32, tag = "1")]
    pub compatibility_level: i32,
    /// The recovery model of a SQL Server database
    #[prost(string, tag = "2")]
    pub recovery_model: ::prost::alloc::string::String,
}
/// Database flags for Cloud SQL instances.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseFlags {
    /// The name of the flag. These flags are passed at instance startup, so
    /// include both server options and system variables. Flags are
    /// specified with underscores, not hyphens. For more information, see
    /// [Configuring Database Flags](<https://cloud.google.com/sql/docs/mysql/flags>)
    /// in the Cloud SQL documentation.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The value of the flag. Boolean flags are set to `on` for true
    /// and `off` for false. This field must be omitted if the flag
    /// doesn't take a value.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// MySQL-specific external server sync settings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MySqlSyncConfig {
    /// Flags to use for the initial dump.
    #[prost(message, repeated, tag = "1")]
    pub initial_sync_flags: ::prost::alloc::vec::Vec<SyncFlags>,
}
/// Initial sync flags for certain Cloud SQL APIs.
/// Currently used for the MySQL external server initial dump.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncFlags {
    /// The name of the flag.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The value of the flag. This field must be omitted if the flag
    /// doesn't take a value.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// Reference to another Cloud SQL instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceReference {
    /// The name of the Cloud SQL instance being referenced.
    /// This does not include the project ID.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The region of the Cloud SQL instance being referenced.
    #[prost(string, tag = "2")]
    pub region: ::prost::alloc::string::String,
    /// The project ID of the Cloud SQL instance being referenced.
    /// The default is the same project ID as the instance references it.
    #[prost(string, tag = "3")]
    pub project: ::prost::alloc::string::String,
}
/// Read-replica configuration for connecting to the on-premises primary
/// instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DemoteMasterConfiguration {
    /// This is always `sql#demoteMasterConfiguration`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// MySQL specific configuration when replicating from a MySQL on-premises
    /// primary instance. Replication configuration information such as the
    /// username, password, certificates, and keys are not stored in the instance
    /// metadata. The configuration information is used only to set up the
    /// replication connection and is stored by MySQL in a file named
    /// `master.info` in the data directory.
    #[prost(message, optional, tag = "2")]
    pub mysql_replica_configuration: ::core::option::Option<
        DemoteMasterMySqlReplicaConfiguration,
    >,
}
/// Read-replica configuration specific to MySQL databases.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DemoteMasterMySqlReplicaConfiguration {
    /// This is always `sql#demoteMasterMysqlReplicaConfiguration`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The username for the replication connection.
    #[prost(string, tag = "2")]
    pub username: ::prost::alloc::string::String,
    /// The password for the replication connection.
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
    /// PEM representation of the replica's private key. The corresponsing public
    /// key is encoded in the client's certificate. The format of the replica's
    /// private key can be either PKCS #1 or PKCS #8.
    #[prost(string, tag = "4")]
    pub client_key: ::prost::alloc::string::String,
    /// PEM representation of the replica's x509 certificate.
    #[prost(string, tag = "5")]
    pub client_certificate: ::prost::alloc::string::String,
    /// PEM representation of the trusted CA's x509 certificate.
    #[prost(string, tag = "6")]
    pub ca_certificate: ::prost::alloc::string::String,
}
/// Database instance export context.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportContext {
    /// The path to the file in Google Cloud Storage where the export will be
    /// stored. The URI is in the form `gs://bucketName/fileName`. If the file
    /// already exists, the request succeeds, but the operation fails. If
    /// `fileType` is `SQL` and the filename ends with .gz,
    /// the contents are compressed.
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    /// Databases to be exported. <br /> `MySQL instances:` If
    /// `fileType` is `SQL` and no database is specified, all
    /// databases are exported, except for the `mysql` system database.
    /// If `fileType` is `CSV`, you can specify one database,
    /// either by using this property or by using the
    /// `csvExportOptions.selectQuery` property, which takes precedence
    /// over this property. <br /> `PostgreSQL instances:` You must specify
    /// one database to be exported. If `fileType` is `CSV`,
    /// this database must match the one specified in the
    /// `csvExportOptions.selectQuery` property. <br /> `SQL Server
    /// instances:` You must specify one database to be exported, and the
    /// `fileType` must be `BAK`.
    #[prost(string, repeated, tag = "2")]
    pub databases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// This is always `sql#exportContext`.
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
    /// Options for exporting data as SQL statements.
    #[prost(message, optional, tag = "4")]
    pub sql_export_options: ::core::option::Option<export_context::SqlExportOptions>,
    /// Options for exporting data as CSV. `MySQL` and `PostgreSQL`
    /// instances only.
    #[prost(message, optional, tag = "5")]
    pub csv_export_options: ::core::option::Option<export_context::SqlCsvExportOptions>,
    /// The file type for the specified uri.
    #[prost(enumeration = "SqlFileType", tag = "6")]
    pub file_type: i32,
    /// Option for export offload.
    #[prost(message, optional, tag = "8")]
    pub offload: ::core::option::Option<bool>,
    /// Options for exporting data as BAK files.
    #[prost(message, optional, tag = "9")]
    pub bak_export_options: ::core::option::Option<export_context::SqlBakExportOptions>,
}
/// Nested message and enum types in `ExportContext`.
pub mod export_context {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SqlCsvExportOptions {
        /// The select query used to extract the data.
        #[prost(string, tag = "1")]
        pub select_query: ::prost::alloc::string::String,
        /// Specifies the character that should appear before a data character that
        /// needs to be escaped.
        #[prost(string, tag = "2")]
        pub escape_character: ::prost::alloc::string::String,
        /// Specifies the quoting character to be used when a data value is quoted.
        #[prost(string, tag = "3")]
        pub quote_character: ::prost::alloc::string::String,
        /// Specifies the character that separates columns within each row (line) of
        /// the file.
        #[prost(string, tag = "4")]
        pub fields_terminated_by: ::prost::alloc::string::String,
        /// This is used to separate lines. If a line does not contain all fields,
        /// the rest of the columns are set to their default values.
        #[prost(string, tag = "6")]
        pub lines_terminated_by: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SqlExportOptions {
        /// Tables to export, or that were exported, from the specified database. If
        /// you specify tables, specify one and only one database. For PostgreSQL
        /// instances, you can specify only one table.
        #[prost(string, repeated, tag = "1")]
        pub tables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Export only schemas.
        #[prost(message, optional, tag = "2")]
        pub schema_only: ::core::option::Option<bool>,
        #[prost(message, optional, tag = "3")]
        pub mysql_export_options: ::core::option::Option<
            sql_export_options::MysqlExportOptions,
        >,
        /// Optional. The number of threads to use for parallel export.
        #[prost(message, optional, tag = "4")]
        pub threads: ::core::option::Option<i32>,
        /// Optional. Whether or not the export should be parallel.
        #[prost(message, optional, tag = "5")]
        pub parallel: ::core::option::Option<bool>,
        /// Optional. Options for exporting from a Cloud SQL for PostgreSQL instance.
        #[prost(message, optional, tag = "6")]
        pub postgres_export_options: ::core::option::Option<
            sql_export_options::PostgresExportOptions,
        >,
    }
    /// Nested message and enum types in `SqlExportOptions`.
    pub mod sql_export_options {
        /// Options for exporting from MySQL.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct MysqlExportOptions {
            /// Option to include SQL statement required to set up replication. If set
            /// to `1`, the dump file includes a CHANGE MASTER TO statement with the
            /// binary log coordinates, and --set-gtid-purged is set to ON. If set to
            /// `2`, the CHANGE MASTER TO statement is written as a SQL comment and
            /// has no effect. If set to any value other than `1`, --set-gtid-purged
            /// is set to OFF.
            #[prost(message, optional, tag = "1")]
            pub master_data: ::core::option::Option<i32>,
        }
        /// Options for exporting from a Cloud SQL for PostgreSQL instance.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct PostgresExportOptions {
            /// Optional. Use this option to include DROP <object> SQL statements.
            /// These statements are used to delete database objects before running the
            /// import operation.
            #[prost(message, optional, tag = "1")]
            pub clean: ::core::option::Option<bool>,
            /// Optional. Option to include an IF EXISTS SQL statement with each DROP
            /// statement produced by clean.
            #[prost(message, optional, tag = "2")]
            pub if_exists: ::core::option::Option<bool>,
        }
    }
    /// Options for exporting BAK files (SQL Server-only)
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SqlBakExportOptions {
        /// Whether or not the export should be striped.
        #[prost(message, optional, tag = "1")]
        pub striped: ::core::option::Option<bool>,
        /// Option for specifying how many stripes to use for the export.
        /// If blank, and the value of the striped field is true,
        /// the number of stripes is automatically chosen.
        #[prost(message, optional, tag = "2")]
        pub stripe_count: ::core::option::Option<i32>,
        /// Type of this bak file will be export, FULL or DIFF, SQL Server only
        #[prost(enumeration = "super::BakType", tag = "4")]
        pub bak_type: i32,
        /// Deprecated: copy_only is deprecated. Use differential_base instead
        #[deprecated]
        #[prost(message, optional, tag = "5")]
        pub copy_only: ::core::option::Option<bool>,
        /// Whether or not the backup can be used as a differential base
        /// copy_only backup can not be served as differential base
        #[prost(message, optional, tag = "6")]
        pub differential_base: ::core::option::Option<bool>,
    }
}
/// Database instance import context.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportContext {
    /// Path to the import file in Cloud Storage, in the form
    /// `gs://bucketName/fileName`. Compressed gzip files (.gz) are supported
    /// when `fileType` is `SQL`. The instance must have
    /// write permissions to the bucket and read access to the file.
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    /// The target database for the import. If `fileType` is `SQL`, this field
    /// is required only if the import file does not specify a database, and is
    /// overridden by any database specification in the import file. If
    /// `fileType` is `CSV`, one database must be specified.
    #[prost(string, tag = "2")]
    pub database: ::prost::alloc::string::String,
    /// This is always `sql#importContext`.
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
    /// The file type for the specified uri.\`SQL`: The file
    /// contains SQL statements. \`CSV`: The file contains CSV data.
    #[prost(enumeration = "SqlFileType", tag = "4")]
    pub file_type: i32,
    /// Options for importing data as CSV.
    #[prost(message, optional, tag = "5")]
    pub csv_import_options: ::core::option::Option<import_context::SqlCsvImportOptions>,
    /// The PostgreSQL user for this import operation. PostgreSQL instances only.
    #[prost(string, tag = "6")]
    pub import_user: ::prost::alloc::string::String,
    /// Import parameters specific to SQL Server .BAK files
    #[prost(message, optional, tag = "7")]
    pub bak_import_options: ::core::option::Option<import_context::SqlBakImportOptions>,
    /// Optional. Options for importing data from SQL statements.
    #[prost(message, optional, tag = "8")]
    pub sql_import_options: ::core::option::Option<import_context::SqlImportOptions>,
}
/// Nested message and enum types in `ImportContext`.
pub mod import_context {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SqlImportOptions {
        /// Optional. The number of threads to use for parallel import.
        #[prost(message, optional, tag = "1")]
        pub threads: ::core::option::Option<i32>,
        /// Optional. Whether or not the import should be parallel.
        #[prost(message, optional, tag = "2")]
        pub parallel: ::core::option::Option<bool>,
        /// Optional. Options for importing from a Cloud SQL for PostgreSQL instance.
        #[prost(message, optional, tag = "3")]
        pub postgres_import_options: ::core::option::Option<
            sql_import_options::PostgresImportOptions,
        >,
    }
    /// Nested message and enum types in `SqlImportOptions`.
    pub mod sql_import_options {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct PostgresImportOptions {
            /// Optional. The --clean flag for the pg_restore utility. This flag
            /// applies only if you enabled Cloud SQL to import files in parallel.
            #[prost(message, optional, tag = "1")]
            pub clean: ::core::option::Option<bool>,
            /// Optional. The --if-exists flag for the pg_restore utility. This flag
            /// applies only if you enabled Cloud SQL to import files in parallel.
            #[prost(message, optional, tag = "2")]
            pub if_exists: ::core::option::Option<bool>,
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SqlCsvImportOptions {
        /// The table to which CSV data is imported.
        #[prost(string, tag = "1")]
        pub table: ::prost::alloc::string::String,
        /// The columns to which CSV data is imported. If not specified, all columns
        /// of the database table are loaded with CSV data.
        #[prost(string, repeated, tag = "2")]
        pub columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Specifies the character that should appear before a data character that
        /// needs to be escaped.
        #[prost(string, tag = "4")]
        pub escape_character: ::prost::alloc::string::String,
        /// Specifies the quoting character to be used when a data value is quoted.
        #[prost(string, tag = "5")]
        pub quote_character: ::prost::alloc::string::String,
        /// Specifies the character that separates columns within each row (line) of
        /// the file.
        #[prost(string, tag = "6")]
        pub fields_terminated_by: ::prost::alloc::string::String,
        /// This is used to separate lines. If a line does not contain all fields,
        /// the rest of the columns are set to their default values.
        #[prost(string, tag = "8")]
        pub lines_terminated_by: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SqlBakImportOptions {
        #[prost(message, optional, tag = "1")]
        pub encryption_options: ::core::option::Option<
            sql_bak_import_options::EncryptionOptions,
        >,
        /// Whether or not the backup set being restored is striped.
        /// Applies only to Cloud SQL for SQL Server.
        #[prost(message, optional, tag = "2")]
        pub striped: ::core::option::Option<bool>,
        /// Whether or not the backup importing will restore database
        /// with NORECOVERY option
        /// Applies only to Cloud SQL for SQL Server.
        #[prost(message, optional, tag = "4")]
        pub no_recovery: ::core::option::Option<bool>,
        /// Whether or not the backup importing request will just bring database
        /// online without downloading Bak content only one of "no_recovery" and
        /// "recovery_only" can be true otherwise error will return. Applies only to
        /// Cloud SQL for SQL Server.
        #[prost(message, optional, tag = "5")]
        pub recovery_only: ::core::option::Option<bool>,
        /// Type of the bak content, FULL or DIFF
        #[prost(enumeration = "super::BakType", tag = "6")]
        pub bak_type: i32,
        /// Optional. The timestamp when the import should stop. This timestamp is in
        /// the [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format (for example,
        /// `2023-10-01T16:19:00.094`). This field is equivalent to the STOPAT
        /// keyword and applies to Cloud SQL for SQL Server only.
        #[prost(message, optional, tag = "7")]
        pub stop_at: ::core::option::Option<::prost_types::Timestamp>,
        /// Optional. The marked transaction where the import should stop. This field
        /// is equivalent to the STOPATMARK keyword and applies to Cloud SQL for SQL
        /// Server only.
        #[prost(string, tag = "8")]
        pub stop_at_mark: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `SqlBakImportOptions`.
    pub mod sql_bak_import_options {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct EncryptionOptions {
            /// Path to the Certificate (.cer) in Cloud Storage, in the form
            /// `gs://bucketName/fileName`. The instance must have
            /// write permissions to the bucket and read access to the file.
            #[prost(string, tag = "1")]
            pub cert_path: ::prost::alloc::string::String,
            /// Path to the Certificate Private Key (.pvk)  in Cloud Storage, in the
            /// form `gs://bucketName/fileName`. The instance must have
            /// write permissions to the bucket and read access to the file.
            #[prost(string, tag = "2")]
            pub pvk_path: ::prost::alloc::string::String,
            /// Password that encrypts the private key
            #[prost(string, tag = "3")]
            pub pvk_password: ::prost::alloc::string::String,
        }
    }
}
/// IP Management configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpConfiguration {
    /// Whether the instance is assigned a public IP address or not.
    #[prost(message, optional, tag = "1")]
    pub ipv4_enabled: ::core::option::Option<bool>,
    /// The resource link for the VPC network from which the Cloud SQL instance is
    /// accessible for private IP. For example,
    /// `/projects/myProject/global/networks/default`. This setting can
    /// be updated, but it cannot be removed after it is set.
    #[prost(string, tag = "2")]
    pub private_network: ::prost::alloc::string::String,
    /// Use `ssl_mode` instead.
    ///
    /// Whether SSL/TLS connections over IP are enforced.
    /// If set to false, then allow both non-SSL/non-TLS and SSL/TLS connections.
    /// For SSL/TLS connections, the client certificate won't be verified. If
    /// set to true, then only allow connections encrypted with SSL/TLS and with
    /// valid client certificates. If you want to enforce SSL/TLS without enforcing
    /// the requirement for valid client certificates, then use the `ssl_mode` flag
    /// instead of the `require_ssl` flag.
    #[prost(message, optional, tag = "3")]
    pub require_ssl: ::core::option::Option<bool>,
    /// The list of external networks that are allowed to connect to the instance
    /// using the IP. In 'CIDR' notation, also known as 'slash' notation (for
    /// example: `157.197.200.0/24`).
    #[prost(message, repeated, tag = "4")]
    pub authorized_networks: ::prost::alloc::vec::Vec<AclEntry>,
    /// The name of the allocated ip range for the private ip Cloud SQL instance.
    /// For example: "google-managed-services-default". If set, the instance ip
    /// will be created in the allocated range. The range name must comply with
    /// [RFC 1035](<https://tools.ietf.org/html/rfc1035>). Specifically, the name
    /// must be 1-63 characters long and match the regular expression
    /// `[a-z](\[-a-z0-9\]*[a-z0-9])?.`
    #[prost(string, tag = "6")]
    pub allocated_ip_range: ::prost::alloc::string::String,
    /// Controls connectivity to private IP instances from Google services,
    /// such as BigQuery.
    #[prost(message, optional, tag = "7")]
    pub enable_private_path_for_google_cloud_services: ::core::option::Option<bool>,
    /// Specify how SSL/TLS is enforced in database connections. If you must use
    /// the `require_ssl` flag for backward compatibility, then only the following
    /// value pairs are valid:
    ///
    /// For PostgreSQL and MySQL:
    ///
    /// * `ssl_mode=ALLOW_UNENCRYPTED_AND_ENCRYPTED` and `require_ssl=false`
    /// * `ssl_mode=ENCRYPTED_ONLY` and `require_ssl=false`
    /// * `ssl_mode=TRUSTED_CLIENT_CERTIFICATE_REQUIRED` and `require_ssl=true`
    ///
    /// For SQL Server:
    ///
    /// * `ssl_mode=ALLOW_UNENCRYPTED_AND_ENCRYPTED` and `require_ssl=false`
    /// * `ssl_mode=ENCRYPTED_ONLY` and `require_ssl=true`
    ///
    /// The value of `ssl_mode` has priority over the value of `require_ssl`.
    ///
    /// For example, for the pair `ssl_mode=ENCRYPTED_ONLY` and
    /// `require_ssl=false`, `ssl_mode=ENCRYPTED_ONLY` means accept only SSL
    /// connections, while `require_ssl=false` means accept both non-SSL
    /// and SSL connections. In this case, MySQL and PostgreSQL databases respect
    /// `ssl_mode` and accepts only SSL connections.
    #[prost(enumeration = "ip_configuration::SslMode", tag = "8")]
    pub ssl_mode: i32,
    /// PSC settings for this instance.
    #[prost(message, optional, tag = "9")]
    pub psc_config: ::core::option::Option<PscConfig>,
    /// Specify what type of CA is used for the server certificate.
    #[prost(enumeration = "ip_configuration::CaMode", optional, tag = "10")]
    pub server_ca_mode: ::core::option::Option<i32>,
}
/// Nested message and enum types in `IpConfiguration`.
pub mod ip_configuration {
    /// The SSL options for database connections.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SslMode {
        /// The SSL mode is unknown.
        Unspecified = 0,
        /// Allow non-SSL/non-TLS and SSL/TLS connections.
        /// For SSL connections to MySQL and PostgreSQL, the client certificate
        /// isn't verified.
        ///
        /// When this value is used, the legacy `require_ssl` flag must be false or
        /// cleared to avoid a conflict between the values of the two flags.
        AllowUnencryptedAndEncrypted = 1,
        /// Only allow connections encrypted with SSL/TLS.
        /// For SSL connections to MySQL and PostgreSQL, the client certificate
        /// isn't verified.
        ///
        /// When this value is used, the legacy `require_ssl` flag must be false or
        /// cleared to avoid a conflict between the values of the two flags.
        EncryptedOnly = 2,
        /// Only allow connections encrypted with SSL/TLS and with valid
        /// client certificates.
        ///
        /// When this value is used, the legacy `require_ssl` flag must be true or
        /// cleared to avoid the conflict between values of two flags.
        /// PostgreSQL clients or users that connect using IAM database
        /// authentication must use either the
        /// [Cloud SQL Auth
        /// Proxy](<https://cloud.google.com/sql/docs/postgres/connect-auth-proxy>) or
        /// [Cloud SQL
        /// Connectors](<https://cloud.google.com/sql/docs/postgres/connect-connectors>)
        /// to enforce client identity verification.
        ///
        /// Only applicable to MySQL and PostgreSQL. Not applicable to SQL Server.
        TrustedClientCertificateRequired = 3,
    }
    impl SslMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SSL_MODE_UNSPECIFIED",
                Self::AllowUnencryptedAndEncrypted => "ALLOW_UNENCRYPTED_AND_ENCRYPTED",
                Self::EncryptedOnly => "ENCRYPTED_ONLY",
                Self::TrustedClientCertificateRequired => {
                    "TRUSTED_CLIENT_CERTIFICATE_REQUIRED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SSL_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "ALLOW_UNENCRYPTED_AND_ENCRYPTED" => {
                    Some(Self::AllowUnencryptedAndEncrypted)
                }
                "ENCRYPTED_ONLY" => Some(Self::EncryptedOnly),
                "TRUSTED_CLIENT_CERTIFICATE_REQUIRED" => {
                    Some(Self::TrustedClientCertificateRequired)
                }
                _ => None,
            }
        }
    }
    /// Various Certificate Authority (CA) modes for certificate signing.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CaMode {
        /// CA mode is unknown.
        Unspecified = 0,
        /// Google-managed self-signed internal CA.
        GoogleManagedInternalCa = 1,
        /// Google-managed regional CA part of root CA hierarchy hosted on Google
        /// Cloud's Certificate Authority Service (CAS).
        GoogleManagedCasCa = 2,
    }
    impl CaMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CA_MODE_UNSPECIFIED",
                Self::GoogleManagedInternalCa => "GOOGLE_MANAGED_INTERNAL_CA",
                Self::GoogleManagedCasCa => "GOOGLE_MANAGED_CAS_CA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CA_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "GOOGLE_MANAGED_INTERNAL_CA" => Some(Self::GoogleManagedInternalCa),
                "GOOGLE_MANAGED_CAS_CA" => Some(Self::GoogleManagedCasCa),
                _ => None,
            }
        }
    }
}
/// PSC settings for a Cloud SQL instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PscConfig {
    /// Whether PSC connectivity is enabled for this instance.
    #[prost(bool, optional, tag = "1")]
    pub psc_enabled: ::core::option::Option<bool>,
    /// Optional. The list of consumer projects that are allow-listed for PSC
    /// connections to this instance. This instance can be connected to with PSC
    /// from any network in these projects.
    ///
    /// Each consumer project in this list may be represented by a project number
    /// (numeric) or by a project id (alphanumeric).
    #[prost(string, repeated, tag = "2")]
    pub allowed_consumer_projects: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Preferred location. This specifies where a Cloud SQL instance is located.
/// Note that if the preferred location is not available, the instance will be
/// located as close as possible within the region. Only one location may be
/// specified.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationPreference {
    /// The App Engine application to follow, it must be in the same region as the
    /// Cloud SQL instance. WARNING: Changing this might restart the instance.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub follow_gae_application: ::prost::alloc::string::String,
    /// The preferred Compute Engine zone (for example: us-central1-a,
    /// us-central1-b, etc.). WARNING: Changing this might restart the instance.
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// The preferred Compute Engine zone for the secondary/failover
    /// (for example: us-central1-a, us-central1-b, etc.).
    /// To disable this field, set it to 'no_secondary_zone'.
    #[prost(string, tag = "4")]
    pub secondary_zone: ::prost::alloc::string::String,
    /// This is always `sql#locationPreference`.
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
}
/// Maintenance window. This specifies when a Cloud SQL instance is
/// restarted for system maintenance purposes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaintenanceWindow {
    /// Hour of day - 0 to 23. Specify in the UTC time zone.
    #[prost(message, optional, tag = "1")]
    pub hour: ::core::option::Option<i32>,
    /// Day of week - `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`,
    /// `SATURDAY`, or `SUNDAY`. Specify in the UTC time zone.
    /// Returned in output as an integer, 1 to 7, where `1` equals Monday.
    #[prost(message, optional, tag = "2")]
    pub day: ::core::option::Option<i32>,
    /// Maintenance timing settings: `canary`, `stable`, or `week5`.
    /// For more information, see [About maintenance on Cloud SQL
    /// instances](<https://cloud.google.com/sql/docs/mysql/maintenance>).
    #[prost(enumeration = "SqlUpdateTrack", tag = "3")]
    pub update_track: i32,
    /// This is always `sql#maintenanceWindow`.
    #[prost(string, tag = "4")]
    pub kind: ::prost::alloc::string::String,
}
/// Deny maintenance Periods. This specifies a date range during when all CSA
/// rollout will be denied.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DenyMaintenancePeriod {
    /// "deny maintenance period" start date. If the year of the start date is
    /// empty, the year of the end date also must be empty. In this case, it means
    /// the deny maintenance period recurs every year. The date is in format
    /// yyyy-mm-dd i.e., 2020-11-01, or mm-dd, i.e., 11-01
    #[prost(string, tag = "1")]
    pub start_date: ::prost::alloc::string::String,
    /// "deny maintenance period" end date. If the year of the end date is empty,
    /// the year of the start date also must be empty. In this case, it means the
    /// no maintenance interval recurs every year. The date is in format yyyy-mm-dd
    /// i.e., 2020-11-01, or mm-dd, i.e., 11-01
    #[prost(string, tag = "2")]
    pub end_date: ::prost::alloc::string::String,
    /// Time in UTC when the "deny maintenance period" starts on start_date and
    /// ends on end_date. The time is in format: HH:mm:SS, i.e., 00:00:00
    #[prost(string, tag = "3")]
    pub time: ::prost::alloc::string::String,
}
/// Insights configuration. This specifies when Cloud SQL Insights feature is
/// enabled and optional configuration.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InsightsConfig {
    /// Whether Query Insights feature is enabled.
    #[prost(bool, tag = "1")]
    pub query_insights_enabled: bool,
    /// Whether Query Insights will record client address when enabled.
    #[prost(bool, tag = "2")]
    pub record_client_address: bool,
    /// Whether Query Insights will record application tags from query when
    /// enabled.
    #[prost(bool, tag = "3")]
    pub record_application_tags: bool,
    /// Maximum query length stored in bytes. Default value: 1024 bytes.
    /// Range: 256-4500 bytes. Query length more than this field value will be
    /// truncated to this value. When unset, query length will be the default
    /// value. Changing query length will restart the database.
    #[prost(message, optional, tag = "4")]
    pub query_string_length: ::core::option::Option<i32>,
    /// Number of query execution plans captured by Insights per minute
    /// for all queries combined. Default is 5.
    #[prost(message, optional, tag = "5")]
    pub query_plans_per_minute: ::core::option::Option<i32>,
}
/// Read-replica configuration specific to MySQL databases.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MySqlReplicaConfiguration {
    /// Path to a SQL dump file in Google Cloud Storage from which the replica
    /// instance is to be created. The URI is in the form gs://bucketName/fileName.
    /// Compressed gzip files (.gz) are also supported.
    /// Dumps have the binlog co-ordinates from which replication
    /// begins. This can be accomplished by setting --master-data to 1 when using
    /// mysqldump.
    #[prost(string, tag = "1")]
    pub dump_file_path: ::prost::alloc::string::String,
    /// The username for the replication connection.
    #[prost(string, tag = "2")]
    pub username: ::prost::alloc::string::String,
    /// The password for the replication connection.
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
    /// Seconds to wait between connect retries. MySQL's default is 60 seconds.
    #[prost(message, optional, tag = "4")]
    pub connect_retry_interval: ::core::option::Option<i32>,
    /// Interval in milliseconds between replication heartbeats.
    #[prost(message, optional, tag = "5")]
    pub master_heartbeat_period: ::core::option::Option<i64>,
    /// PEM representation of the trusted CA's x509 certificate.
    #[prost(string, tag = "6")]
    pub ca_certificate: ::prost::alloc::string::String,
    /// PEM representation of the replica's x509 certificate.
    #[prost(string, tag = "7")]
    pub client_certificate: ::prost::alloc::string::String,
    /// PEM representation of the replica's private key. The corresponsing public
    /// key is encoded in the client's certificate.
    #[prost(string, tag = "8")]
    pub client_key: ::prost::alloc::string::String,
    /// A list of permissible ciphers to use for SSL encryption.
    #[prost(string, tag = "9")]
    pub ssl_cipher: ::prost::alloc::string::String,
    /// Whether or not to check the primary instance's Common Name value in the
    /// certificate that it sends during the SSL handshake.
    #[prost(message, optional, tag = "10")]
    pub verify_server_certificate: ::core::option::Option<bool>,
    /// This is always `sql#mysqlReplicaConfiguration`.
    #[prost(string, tag = "11")]
    pub kind: ::prost::alloc::string::String,
}
/// Disk encryption configuration for an instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskEncryptionConfiguration {
    /// Resource name of KMS key for disk encryption
    #[prost(string, tag = "1")]
    pub kms_key_name: ::prost::alloc::string::String,
    /// This is always `sql#diskEncryptionConfiguration`.
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
}
/// Disk encryption status for an instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskEncryptionStatus {
    /// KMS key version used to encrypt the Cloud SQL instance resource
    #[prost(string, tag = "1")]
    pub kms_key_version_name: ::prost::alloc::string::String,
    /// This is always `sql#diskEncryptionStatus`.
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
}
/// Database instance IP mapping
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpMapping {
    /// The type of this IP address. A `PRIMARY` address is a public address that
    /// can accept incoming connections. A `PRIVATE` address is a private address
    /// that can accept incoming connections. An `OUTGOING` address is the source
    /// address of connections originating from the instance, if supported.
    #[prost(enumeration = "SqlIpAddressType", tag = "1")]
    pub r#type: i32,
    /// The IP address assigned.
    #[prost(string, tag = "2")]
    pub ip_address: ::prost::alloc::string::String,
    /// The due time for this IP to be retired in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`. This field is only available when
    /// the IP is scheduled to be retired.
    #[prost(message, optional, tag = "3")]
    pub time_to_retire: ::core::option::Option<::prost_types::Timestamp>,
}
/// An Operation resource.&nbsp;For successful operations that return an
/// Operation resource, only the fields relevant to the operation are populated
/// in the resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Operation {
    /// This is always `sql#operation`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub target_link: ::prost::alloc::string::String,
    /// The status of an operation.
    #[prost(enumeration = "operation::SqlOperationStatus", tag = "3")]
    pub status: i32,
    /// The email address of the user who initiated this operation.
    #[prost(string, tag = "4")]
    pub user: ::prost::alloc::string::String,
    /// The time this operation was enqueued in UTC timezone in [RFC
    /// 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "5")]
    pub insert_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time this operation actually started in UTC timezone in [RFC
    /// 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "6")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time this operation finished in UTC timezone in [RFC
    /// 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "7")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// If errors occurred during processing of this operation, this field will be
    /// populated.
    #[prost(message, optional, tag = "8")]
    pub error: ::core::option::Option<OperationErrors>,
    /// An Admin API warning message.
    #[prost(message, optional, tag = "19")]
    pub api_warning: ::core::option::Option<ApiWarning>,
    /// The type of the operation. Valid values are:
    /// *  `CREATE`
    /// *  `DELETE`
    /// *  `UPDATE`
    /// *  `RESTART`
    /// *  `IMPORT`
    /// *  `EXPORT`
    /// *  `BACKUP_VOLUME`
    /// *  `RESTORE_VOLUME`
    /// *  `CREATE_USER`
    /// *  `DELETE_USER`
    /// *  `CREATE_DATABASE`
    /// *  `DELETE_DATABASE`
    #[prost(enumeration = "operation::SqlOperationType", tag = "9")]
    pub operation_type: i32,
    /// The context for import operation, if applicable.
    #[prost(message, optional, tag = "10")]
    pub import_context: ::core::option::Option<ImportContext>,
    /// The context for export operation, if applicable.
    #[prost(message, optional, tag = "11")]
    pub export_context: ::core::option::Option<ExportContext>,
    /// The context for backup operation, if applicable.
    #[prost(message, optional, tag = "17")]
    pub backup_context: ::core::option::Option<BackupContext>,
    /// An identifier that uniquely identifies the operation. You can use this
    /// identifier to retrieve the Operations resource that has information about
    /// the operation.
    #[prost(string, tag = "12")]
    pub name: ::prost::alloc::string::String,
    /// Name of the database instance related to this operation.
    #[prost(string, tag = "13")]
    pub target_id: ::prost::alloc::string::String,
    /// The URI of this resource.
    #[prost(string, tag = "14")]
    pub self_link: ::prost::alloc::string::String,
    /// The project ID of the target instance related to this operation.
    #[prost(string, tag = "15")]
    pub target_project: ::prost::alloc::string::String,
    /// The context for acquire SSRS lease operation, if applicable.
    #[prost(message, optional, tag = "20")]
    pub acquire_ssrs_lease_context: ::core::option::Option<AcquireSsrsLeaseContext>,
}
/// Nested message and enum types in `Operation`.
pub mod operation {
    /// The type of Cloud SQL operation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlOperationType {
        /// Unknown operation type.
        Unspecified = 0,
        /// Imports data into a Cloud SQL instance.
        Import = 1,
        /// Exports data from a Cloud SQL instance to a Cloud Storage
        /// bucket.
        Export = 2,
        /// Creates a new Cloud SQL instance.
        Create = 3,
        /// Updates the settings of a Cloud SQL instance.
        Update = 4,
        /// Deletes a Cloud SQL instance.
        Delete = 5,
        /// Restarts the Cloud SQL instance.
        Restart = 6,
        Backup = 7,
        Snapshot = 8,
        /// Performs instance backup.
        BackupVolume = 9,
        /// Deletes an instance backup.
        DeleteVolume = 10,
        /// Restores an instance backup.
        RestoreVolume = 11,
        /// Injects a privileged user in mysql for MOB instances.
        InjectUser = 12,
        /// Clones a Cloud SQL instance.
        Clone = 14,
        /// Stops replication on a Cloud SQL read replica instance.
        StopReplica = 15,
        /// Starts replication on a Cloud SQL read replica instance.
        StartReplica = 16,
        /// Promotes a Cloud SQL replica instance.
        PromoteReplica = 17,
        /// Creates a Cloud SQL replica instance.
        CreateReplica = 18,
        /// Creates a new user in a Cloud SQL instance.
        CreateUser = 19,
        /// Deletes a user from a Cloud SQL instance.
        DeleteUser = 20,
        /// Updates an existing user in a Cloud SQL instance.
        UpdateUser = 21,
        /// Creates a database in the Cloud SQL instance.
        CreateDatabase = 22,
        /// Deletes a database in the Cloud SQL instance.
        DeleteDatabase = 23,
        /// Updates a database in the Cloud SQL instance.
        UpdateDatabase = 24,
        /// Performs failover of an HA-enabled Cloud SQL
        /// failover replica.
        Failover = 25,
        /// Deletes the backup taken by a backup run.
        DeleteBackup = 26,
        RecreateReplica = 27,
        /// Truncates a general or slow log table in MySQL.
        TruncateLog = 28,
        /// Demotes the stand-alone instance to be a Cloud SQL
        /// read replica for an external database server.
        DemoteMaster = 29,
        /// Indicates that the instance is currently in maintenance. Maintenance
        /// typically causes the instance to be unavailable for 1-3 minutes.
        Maintenance = 30,
        /// This field is deprecated, and will be removed in future version of API.
        EnablePrivateIp = 31,
        DeferMaintenance = 32,
        /// Creates clone instance.
        CreateClone = 33,
        /// Reschedule maintenance to another time.
        RescheduleMaintenance = 34,
        /// Starts external sync of a Cloud SQL EM replica to an external primary
        /// instance.
        StartExternalSync = 35,
        /// Recovers logs from an instance's old data disk.
        LogCleanup = 36,
        /// Performs auto-restart of an HA-enabled Cloud SQL database for auto
        /// recovery.
        AutoRestart = 37,
        /// Re-encrypts CMEK instances with latest key version.
        Reencrypt = 38,
        /// Switches the roles of the primary and replica pair. The target instance
        /// should be the replica.
        Switchover = 39,
        /// Acquire a lease for the setup of SQL Server Reporting Services (SSRS).
        AcquireSsrsLease = 42,
        /// Release a lease for the setup of SQL Server Reporting Services (SSRS).
        ReleaseSsrsLease = 43,
        /// Reconfigures old primary after a promote replica operation. Effect of a
        /// promote operation to the old primary is executed in this operation,
        /// asynchronously from the promote replica operation executed to the
        /// replica.
        ReconfigureOldPrimary = 44,
        /// Indicates that the instance, its read replicas, and its cascading
        /// replicas are in maintenance. Maintenance typically gets initiated on
        /// groups of replicas first, followed by the primary instance. For each
        /// instance, maintenance typically causes the instance to be unavailable for
        /// 1-3 minutes.
        ClusterMaintenance = 45,
        /// Indicates that the instance (and any of its replicas) are currently in
        /// maintenance. This is initiated as a self-service request by using SSM.
        /// Maintenance typically causes the instance to be unavailable for 1-3
        /// minutes.
        SelfServiceMaintenance = 46,
        /// Switches a primary instance to a replica. This operation runs as part of
        /// a switchover operation to the original primary instance.
        SwitchoverToReplica = 47,
        /// Updates the major version of a Cloud SQL instance.
        MajorVersionUpgrade = 48,
    }
    impl SqlOperationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SQL_OPERATION_TYPE_UNSPECIFIED",
                Self::Import => "IMPORT",
                Self::Export => "EXPORT",
                Self::Create => "CREATE",
                Self::Update => "UPDATE",
                Self::Delete => "DELETE",
                Self::Restart => "RESTART",
                Self::Backup => "BACKUP",
                Self::Snapshot => "SNAPSHOT",
                Self::BackupVolume => "BACKUP_VOLUME",
                Self::DeleteVolume => "DELETE_VOLUME",
                Self::RestoreVolume => "RESTORE_VOLUME",
                Self::InjectUser => "INJECT_USER",
                Self::Clone => "CLONE",
                Self::StopReplica => "STOP_REPLICA",
                Self::StartReplica => "START_REPLICA",
                Self::PromoteReplica => "PROMOTE_REPLICA",
                Self::CreateReplica => "CREATE_REPLICA",
                Self::CreateUser => "CREATE_USER",
                Self::DeleteUser => "DELETE_USER",
                Self::UpdateUser => "UPDATE_USER",
                Self::CreateDatabase => "CREATE_DATABASE",
                Self::DeleteDatabase => "DELETE_DATABASE",
                Self::UpdateDatabase => "UPDATE_DATABASE",
                Self::Failover => "FAILOVER",
                Self::DeleteBackup => "DELETE_BACKUP",
                Self::RecreateReplica => "RECREATE_REPLICA",
                Self::TruncateLog => "TRUNCATE_LOG",
                Self::DemoteMaster => "DEMOTE_MASTER",
                Self::Maintenance => "MAINTENANCE",
                Self::EnablePrivateIp => "ENABLE_PRIVATE_IP",
                Self::DeferMaintenance => "DEFER_MAINTENANCE",
                Self::CreateClone => "CREATE_CLONE",
                Self::RescheduleMaintenance => "RESCHEDULE_MAINTENANCE",
                Self::StartExternalSync => "START_EXTERNAL_SYNC",
                Self::LogCleanup => "LOG_CLEANUP",
                Self::AutoRestart => "AUTO_RESTART",
                Self::Reencrypt => "REENCRYPT",
                Self::Switchover => "SWITCHOVER",
                Self::AcquireSsrsLease => "ACQUIRE_SSRS_LEASE",
                Self::ReleaseSsrsLease => "RELEASE_SSRS_LEASE",
                Self::ReconfigureOldPrimary => "RECONFIGURE_OLD_PRIMARY",
                Self::ClusterMaintenance => "CLUSTER_MAINTENANCE",
                Self::SelfServiceMaintenance => "SELF_SERVICE_MAINTENANCE",
                Self::SwitchoverToReplica => "SWITCHOVER_TO_REPLICA",
                Self::MajorVersionUpgrade => "MAJOR_VERSION_UPGRADE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_OPERATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "IMPORT" => Some(Self::Import),
                "EXPORT" => Some(Self::Export),
                "CREATE" => Some(Self::Create),
                "UPDATE" => Some(Self::Update),
                "DELETE" => Some(Self::Delete),
                "RESTART" => Some(Self::Restart),
                "BACKUP" => Some(Self::Backup),
                "SNAPSHOT" => Some(Self::Snapshot),
                "BACKUP_VOLUME" => Some(Self::BackupVolume),
                "DELETE_VOLUME" => Some(Self::DeleteVolume),
                "RESTORE_VOLUME" => Some(Self::RestoreVolume),
                "INJECT_USER" => Some(Self::InjectUser),
                "CLONE" => Some(Self::Clone),
                "STOP_REPLICA" => Some(Self::StopReplica),
                "START_REPLICA" => Some(Self::StartReplica),
                "PROMOTE_REPLICA" => Some(Self::PromoteReplica),
                "CREATE_REPLICA" => Some(Self::CreateReplica),
                "CREATE_USER" => Some(Self::CreateUser),
                "DELETE_USER" => Some(Self::DeleteUser),
                "UPDATE_USER" => Some(Self::UpdateUser),
                "CREATE_DATABASE" => Some(Self::CreateDatabase),
                "DELETE_DATABASE" => Some(Self::DeleteDatabase),
                "UPDATE_DATABASE" => Some(Self::UpdateDatabase),
                "FAILOVER" => Some(Self::Failover),
                "DELETE_BACKUP" => Some(Self::DeleteBackup),
                "RECREATE_REPLICA" => Some(Self::RecreateReplica),
                "TRUNCATE_LOG" => Some(Self::TruncateLog),
                "DEMOTE_MASTER" => Some(Self::DemoteMaster),
                "MAINTENANCE" => Some(Self::Maintenance),
                "ENABLE_PRIVATE_IP" => Some(Self::EnablePrivateIp),
                "DEFER_MAINTENANCE" => Some(Self::DeferMaintenance),
                "CREATE_CLONE" => Some(Self::CreateClone),
                "RESCHEDULE_MAINTENANCE" => Some(Self::RescheduleMaintenance),
                "START_EXTERNAL_SYNC" => Some(Self::StartExternalSync),
                "LOG_CLEANUP" => Some(Self::LogCleanup),
                "AUTO_RESTART" => Some(Self::AutoRestart),
                "REENCRYPT" => Some(Self::Reencrypt),
                "SWITCHOVER" => Some(Self::Switchover),
                "ACQUIRE_SSRS_LEASE" => Some(Self::AcquireSsrsLease),
                "RELEASE_SSRS_LEASE" => Some(Self::ReleaseSsrsLease),
                "RECONFIGURE_OLD_PRIMARY" => Some(Self::ReconfigureOldPrimary),
                "CLUSTER_MAINTENANCE" => Some(Self::ClusterMaintenance),
                "SELF_SERVICE_MAINTENANCE" => Some(Self::SelfServiceMaintenance),
                "SWITCHOVER_TO_REPLICA" => Some(Self::SwitchoverToReplica),
                "MAJOR_VERSION_UPGRADE" => Some(Self::MajorVersionUpgrade),
                _ => None,
            }
        }
    }
    /// The status of an operation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlOperationStatus {
        /// The state of the operation is unknown.
        Unspecified = 0,
        /// The operation has been queued, but has not started yet.
        Pending = 1,
        /// The operation is running.
        Running = 2,
        /// The operation completed.
        Done = 3,
    }
    impl SqlOperationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SQL_OPERATION_STATUS_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Running => "RUNNING",
                Self::Done => "DONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_OPERATION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "RUNNING" => Some(Self::Running),
                "DONE" => Some(Self::Done),
                _ => None,
            }
        }
    }
}
/// Database instance operation error.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationError {
    /// This is always `sql#operationError`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Identifies the specific error that occurred.
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
    /// Additional information about the error encountered.
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
/// Database instance operation errors list wrapper.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationErrors {
    /// This is always `sql#operationErrors`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The list of errors encountered while processing this operation.
    #[prost(message, repeated, tag = "2")]
    pub errors: ::prost::alloc::vec::Vec<OperationError>,
}
/// Database instance local user password validation policy
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PasswordValidationPolicy {
    /// Minimum number of characters allowed.
    #[prost(message, optional, tag = "1")]
    pub min_length: ::core::option::Option<i32>,
    /// The complexity of the password.
    #[prost(enumeration = "password_validation_policy::Complexity", tag = "2")]
    pub complexity: i32,
    /// Number of previous passwords that cannot be reused.
    #[prost(message, optional, tag = "3")]
    pub reuse_interval: ::core::option::Option<i32>,
    /// Disallow username as a part of the password.
    #[prost(message, optional, tag = "4")]
    pub disallow_username_substring: ::core::option::Option<bool>,
    /// Minimum interval after which the password can be changed. This flag is only
    /// supported for PostgreSQL.
    #[prost(message, optional, tag = "5")]
    pub password_change_interval: ::core::option::Option<::prost_types::Duration>,
    /// Whether the password policy is enabled or not.
    #[prost(message, optional, tag = "6")]
    pub enable_password_policy: ::core::option::Option<bool>,
    /// This field is deprecated and will be removed in a future version of the
    /// API.
    #[deprecated]
    #[prost(message, optional, tag = "7")]
    pub disallow_compromised_credentials: ::core::option::Option<bool>,
}
/// Nested message and enum types in `PasswordValidationPolicy`.
pub mod password_validation_policy {
    /// The complexity choices of the password.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Complexity {
        /// Complexity check is not specified.
        Unspecified = 0,
        /// A combination of lowercase, uppercase, numeric, and non-alphanumeric
        /// characters.
        Default = 1,
    }
    impl Complexity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "COMPLEXITY_UNSPECIFIED",
                Self::Default => "COMPLEXITY_DEFAULT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPLEXITY_UNSPECIFIED" => Some(Self::Unspecified),
                "COMPLEXITY_DEFAULT" => Some(Self::Default),
                _ => None,
            }
        }
    }
}
/// Data cache configurations.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DataCacheConfig {
    /// Whether data cache is enabled for the instance.
    #[prost(bool, tag = "1")]
    pub data_cache_enabled: bool,
}
/// Database instance settings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Settings {
    /// The version of instance settings. This is a required field for update
    /// method to make sure concurrent updates are handled properly. During update,
    /// use the most recent settingsVersion value for this instance and do not try
    /// to update this value.
    #[prost(message, optional, tag = "1")]
    pub settings_version: ::core::option::Option<i64>,
    /// The App Engine app IDs that can access this instance.
    /// (Deprecated) Applied to First Generation instances only.
    #[deprecated]
    #[prost(string, repeated, tag = "2")]
    pub authorized_gae_applications: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// The tier (or machine type) for this instance, for example
    /// `db-custom-1-3840`. WARNING: Changing this restarts the instance.
    #[prost(string, tag = "3")]
    pub tier: ::prost::alloc::string::String,
    /// This is always `sql#settings`.
    #[prost(string, tag = "4")]
    pub kind: ::prost::alloc::string::String,
    /// User-provided labels, represented as a dictionary where each label is a
    /// single key value pair.
    #[prost(map = "string, string", tag = "5")]
    pub user_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Availability type. Potential values:
    /// *  `ZONAL`: The instance serves data from only one zone. Outages in that
    /// zone affect data accessibility.
    /// *  `REGIONAL`: The instance can serve data from more than one zone in a
    /// region (it is highly available)./
    ///
    /// For more information, see [Overview of the High Availability
    /// Configuration](<https://cloud.google.com/sql/docs/mysql/high-availability>).
    #[prost(enumeration = "SqlAvailabilityType", tag = "6")]
    pub availability_type: i32,
    /// The pricing plan for this instance. This can be either `PER_USE` or
    /// `PACKAGE`. Only `PER_USE` is supported for Second Generation instances.
    #[prost(enumeration = "SqlPricingPlan", tag = "7")]
    pub pricing_plan: i32,
    /// The type of replication this instance uses. This can be either
    /// `ASYNCHRONOUS` or `SYNCHRONOUS`. (Deprecated) This property was only
    /// applicable to First Generation instances.
    #[deprecated]
    #[prost(enumeration = "SqlReplicationType", tag = "8")]
    pub replication_type: i32,
    /// The maximum size to which storage capacity can be automatically increased.
    /// The default value is 0, which specifies that there is no limit.
    #[prost(message, optional, tag = "9")]
    pub storage_auto_resize_limit: ::core::option::Option<i64>,
    /// The activation policy specifies when the instance is activated; it is
    /// applicable only when the instance state is RUNNABLE. Valid values:
    /// *  `ALWAYS`: The instance is on, and remains so even in the absence of
    /// connection requests.
    /// *  `NEVER`: The instance is off; it is not activated, even if a
    /// connection request arrives.
    #[prost(enumeration = "settings::SqlActivationPolicy", tag = "10")]
    pub activation_policy: i32,
    /// The settings for IP Management. This allows to enable or disable the
    /// instance IP and manage which external networks can connect to the instance.
    /// The IPv4 address cannot be disabled for Second Generation instances.
    #[prost(message, optional, tag = "11")]
    pub ip_configuration: ::core::option::Option<IpConfiguration>,
    /// Configuration to increase storage size automatically. The default value is
    /// true.
    #[prost(message, optional, tag = "12")]
    pub storage_auto_resize: ::core::option::Option<bool>,
    /// The location preference settings. This allows the instance to be located as
    /// near as possible to either an App Engine app or Compute Engine zone for
    /// better performance. App Engine co-location was only applicable to First
    /// Generation instances.
    #[prost(message, optional, tag = "13")]
    pub location_preference: ::core::option::Option<LocationPreference>,
    /// The database flags passed to the instance at startup.
    #[prost(message, repeated, tag = "14")]
    pub database_flags: ::prost::alloc::vec::Vec<DatabaseFlags>,
    /// The type of data disk: `PD_SSD` (default) or `PD_HDD`. Not used for
    /// First Generation instances.
    #[prost(enumeration = "SqlDataDiskType", tag = "15")]
    pub data_disk_type: i32,
    /// The maintenance window for this instance. This specifies when the instance
    /// can be restarted for maintenance purposes.
    #[prost(message, optional, tag = "16")]
    pub maintenance_window: ::core::option::Option<MaintenanceWindow>,
    /// The daily backup configuration for the instance.
    #[prost(message, optional, tag = "17")]
    pub backup_configuration: ::core::option::Option<BackupConfiguration>,
    /// Configuration specific to read replica instances. Indicates whether
    /// replication is enabled or not. WARNING: Changing this restarts the
    /// instance.
    #[prost(message, optional, tag = "18")]
    pub database_replication_enabled: ::core::option::Option<bool>,
    /// Configuration specific to read replica instances. Indicates whether
    /// database flags for crash-safe replication are enabled. This property was
    /// only applicable to First Generation instances.
    #[deprecated]
    #[prost(message, optional, tag = "19")]
    pub crash_safe_replication_enabled: ::core::option::Option<bool>,
    /// The size of data disk, in GB. The data disk size minimum is 10GB.
    #[prost(message, optional, tag = "20")]
    pub data_disk_size_gb: ::core::option::Option<i64>,
    /// Active Directory configuration, relevant only for Cloud SQL for SQL Server.
    #[prost(message, optional, tag = "22")]
    pub active_directory_config: ::core::option::Option<SqlActiveDirectoryConfig>,
    /// The name of server Instance collation.
    #[prost(string, tag = "23")]
    pub collation: ::prost::alloc::string::String,
    /// Deny maintenance periods
    #[prost(message, repeated, tag = "24")]
    pub deny_maintenance_periods: ::prost::alloc::vec::Vec<DenyMaintenancePeriod>,
    /// Insights configuration, for now relevant only for Postgres.
    #[prost(message, optional, tag = "25")]
    pub insights_config: ::core::option::Option<InsightsConfig>,
    /// The local user password validation policy of the instance.
    #[prost(message, optional, tag = "27")]
    pub password_validation_policy: ::core::option::Option<PasswordValidationPolicy>,
    /// SQL Server specific audit configuration.
    #[prost(message, optional, tag = "29")]
    pub sql_server_audit_config: ::core::option::Option<SqlServerAuditConfig>,
    /// Optional. The edition of the instance.
    #[prost(enumeration = "settings::Edition", tag = "38")]
    pub edition: i32,
    /// Specifies if connections must use Cloud SQL connectors.
    /// Option values include the following: `NOT_REQUIRED` (Cloud SQL instances
    /// can be connected without Cloud SQL
    /// Connectors) and `REQUIRED` (Only allow connections that use Cloud SQL
    /// Connectors).
    ///
    /// Note that using REQUIRED disables all existing authorized networks. If
    /// this field is not specified when creating a new instance, NOT_REQUIRED is
    /// used. If this field is not specified when patching or updating an existing
    /// instance, it is left unchanged in the instance.
    #[prost(enumeration = "settings::ConnectorEnforcement", tag = "32")]
    pub connector_enforcement: i32,
    /// Configuration to protect against accidental instance deletion.
    #[prost(message, optional, tag = "33")]
    pub deletion_protection_enabled: ::core::option::Option<bool>,
    /// Server timezone, relevant only for Cloud SQL for SQL Server.
    #[prost(string, tag = "34")]
    pub time_zone: ::prost::alloc::string::String,
    /// Specifies advanced machine configuration for the instances relevant only
    /// for SQL Server.
    #[prost(message, optional, tag = "35")]
    pub advanced_machine_features: ::core::option::Option<AdvancedMachineFeatures>,
    /// Configuration for data cache.
    #[prost(message, optional, tag = "37")]
    pub data_cache_config: ::core::option::Option<DataCacheConfig>,
    /// Optional. When this parameter is set to true, Cloud SQL instances can
    /// connect to Vertex AI to pass requests for real-time predictions and
    /// insights to the AI. The default value is false. This applies only to Cloud
    /// SQL for PostgreSQL instances.
    #[prost(message, optional, tag = "40")]
    pub enable_google_ml_integration: ::core::option::Option<bool>,
    /// Optional. By default, Cloud SQL instances have schema extraction disabled
    /// for Dataplex. When this parameter is set to true, schema extraction for
    /// Dataplex on Cloud SQL instances is activated.
    #[prost(message, optional, tag = "41")]
    pub enable_dataplex_integration: ::core::option::Option<bool>,
}
/// Nested message and enum types in `Settings`.
pub mod settings {
    /// Specifies when the instance is activated.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlActivationPolicy {
        /// Unknown activation plan.
        Unspecified = 0,
        /// The instance is always up and running.
        Always = 1,
        /// The instance never starts.
        Never = 2,
        /// The instance starts upon receiving requests.
        OnDemand = 3,
    }
    impl SqlActivationPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SQL_ACTIVATION_POLICY_UNSPECIFIED",
                Self::Always => "ALWAYS",
                Self::Never => "NEVER",
                Self::OnDemand => "ON_DEMAND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_ACTIVATION_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "ALWAYS" => Some(Self::Always),
                "NEVER" => Some(Self::Never),
                "ON_DEMAND" => Some(Self::OnDemand),
                _ => None,
            }
        }
    }
    /// The edition of the instance, can be ENTERPRISE or ENTERPRISE_PLUS.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Edition {
        /// The instance did not specify the edition.
        Unspecified = 0,
        /// The instance is an enterprise edition.
        Enterprise = 2,
        /// The instance is an Enterprise Plus edition.
        EnterprisePlus = 3,
    }
    impl Edition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EDITION_UNSPECIFIED",
                Self::Enterprise => "ENTERPRISE",
                Self::EnterprisePlus => "ENTERPRISE_PLUS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EDITION_UNSPECIFIED" => Some(Self::Unspecified),
                "ENTERPRISE" => Some(Self::Enterprise),
                "ENTERPRISE_PLUS" => Some(Self::EnterprisePlus),
                _ => None,
            }
        }
    }
    /// The options for enforcing Cloud SQL connectors in the instance.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConnectorEnforcement {
        /// The requirement for Cloud SQL connectors is unknown.
        Unspecified = 0,
        /// Do not require Cloud SQL connectors.
        NotRequired = 1,
        /// Require all connections to use Cloud SQL connectors, including the
        /// Cloud SQL Auth Proxy and Cloud SQL Java, Python, and Go connectors.
        /// Note: This disables all existing authorized networks.
        Required = 2,
    }
    impl ConnectorEnforcement {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CONNECTOR_ENFORCEMENT_UNSPECIFIED",
                Self::NotRequired => "NOT_REQUIRED",
                Self::Required => "REQUIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONNECTOR_ENFORCEMENT_UNSPECIFIED" => Some(Self::Unspecified),
                "NOT_REQUIRED" => Some(Self::NotRequired),
                "REQUIRED" => Some(Self::Required),
                _ => None,
            }
        }
    }
}
/// Specifies options for controlling advanced machine features.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdvancedMachineFeatures {
    /// The number of threads per physical core.
    #[prost(int32, tag = "1")]
    pub threads_per_core: i32,
}
/// SslCerts Resource
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslCert {
    /// This is always `sql#sslCert`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Serial number, as extracted from the certificate.
    #[prost(string, tag = "2")]
    pub cert_serial_number: ::prost::alloc::string::String,
    /// PEM representation.
    #[prost(string, tag = "3")]
    pub cert: ::prost::alloc::string::String,
    /// The time when the certificate was created in [RFC
    /// 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// User supplied name.  Constrained to \[a-zA-Z.-_ \]+.
    #[prost(string, tag = "5")]
    pub common_name: ::prost::alloc::string::String,
    /// The time when the certificate expires in [RFC
    /// 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "6")]
    pub expiration_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Sha1 Fingerprint.
    #[prost(string, tag = "7")]
    pub sha1_fingerprint: ::prost::alloc::string::String,
    /// Name of the database instance.
    #[prost(string, tag = "8")]
    pub instance: ::prost::alloc::string::String,
    /// The URI of this resource.
    #[prost(string, tag = "9")]
    pub self_link: ::prost::alloc::string::String,
}
/// SslCertDetail.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslCertDetail {
    /// The public information about the cert.
    #[prost(message, optional, tag = "1")]
    pub cert_info: ::core::option::Option<SslCert>,
    /// The private key for the client cert, in pem format.  Keep private in order
    /// to protect your security.
    #[prost(string, tag = "2")]
    pub cert_private_key: ::prost::alloc::string::String,
}
/// Active Directory configuration, relevant only for Cloud SQL for SQL Server.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlActiveDirectoryConfig {
    /// This is always sql#activeDirectoryConfig.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The name of the domain (e.g., mydomain.com).
    #[prost(string, tag = "2")]
    pub domain: ::prost::alloc::string::String,
}
/// SQL Server specific audit configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlServerAuditConfig {
    /// This is always sql#sqlServerAuditConfig
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The name of the destination bucket (e.g., gs://mybucket).
    #[prost(string, tag = "2")]
    pub bucket: ::prost::alloc::string::String,
    /// How long to keep generated audit files.
    #[prost(message, optional, tag = "3")]
    pub retention_interval: ::core::option::Option<::prost_types::Duration>,
    /// How often to upload generated audit files.
    #[prost(message, optional, tag = "4")]
    pub upload_interval: ::core::option::Option<::prost_types::Duration>,
}
/// Acquire SSRS lease context.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcquireSsrsLeaseContext {
    /// The username to be used as the setup login to connect to the database
    /// server for SSRS setup.
    #[prost(string, optional, tag = "1")]
    pub setup_login: ::core::option::Option<::prost::alloc::string::String>,
    /// The username to be used as the service login to connect to the report
    /// database for SSRS setup.
    #[prost(string, optional, tag = "2")]
    pub service_login: ::core::option::Option<::prost::alloc::string::String>,
    /// The report database to be used for SSRS setup.
    #[prost(string, optional, tag = "3")]
    pub report_database: ::core::option::Option<::prost::alloc::string::String>,
    /// Lease duration needed for SSRS setup.
    #[prost(message, optional, tag = "4")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlFileType {
    /// Unknown file type.
    Unspecified = 0,
    /// File containing SQL statements.
    Sql = 1,
    /// File in CSV format.
    Csv = 2,
    Bak = 4,
}
impl SqlFileType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_FILE_TYPE_UNSPECIFIED",
            Self::Sql => "SQL",
            Self::Csv => "CSV",
            Self::Bak => "BAK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_FILE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SQL" => Some(Self::Sql),
            "CSV" => Some(Self::Csv),
            "BAK" => Some(Self::Bak),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BakType {
    /// Default type.
    Unspecified = 0,
    /// Full backup.
    Full = 1,
    /// Differential backup.
    Diff = 2,
    /// Transaction Log backup
    Tlog = 3,
}
impl BakType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BAK_TYPE_UNSPECIFIED",
            Self::Full => "FULL",
            Self::Diff => "DIFF",
            Self::Tlog => "TLOG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BAK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "FULL" => Some(Self::Full),
            "DIFF" => Some(Self::Diff),
            "TLOG" => Some(Self::Tlog),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlBackendType {
    /// This is an unknown backend type for instance.
    Unspecified = 0,
    /// V1 speckle instance.
    FirstGen = 1,
    /// V2 speckle instance.
    SecondGen = 2,
    /// On premises instance.
    External = 3,
}
impl SqlBackendType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_BACKEND_TYPE_UNSPECIFIED",
            Self::FirstGen => "FIRST_GEN",
            Self::SecondGen => "SECOND_GEN",
            Self::External => "EXTERNAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_BACKEND_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "FIRST_GEN" => Some(Self::FirstGen),
            "SECOND_GEN" => Some(Self::SecondGen),
            "EXTERNAL" => Some(Self::External),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlIpAddressType {
    /// This is an unknown IP address type.
    Unspecified = 0,
    /// IP address the customer is supposed to connect to. Usually this is the
    /// load balancer's IP address
    Primary = 1,
    /// Source IP address of the connection a read replica establishes to its
    /// external primary instance. This IP address can be allowlisted by the
    /// customer in case it has a firewall that filters incoming connection to its
    /// on premises primary instance.
    Outgoing = 2,
    /// Private IP used when using private IPs and network peering.
    Private = 3,
    /// V1 IP of a migrated instance. We want the user to
    /// decommission this IP as soon as the migration is complete.
    /// Note: V1 instances with V1 ip addresses will be counted as PRIMARY.
    Migrated1stGen = 4,
}
impl SqlIpAddressType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_IP_ADDRESS_TYPE_UNSPECIFIED",
            Self::Primary => "PRIMARY",
            Self::Outgoing => "OUTGOING",
            Self::Private => "PRIVATE",
            Self::Migrated1stGen => "MIGRATED_1ST_GEN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_IP_ADDRESS_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PRIMARY" => Some(Self::Primary),
            "OUTGOING" => Some(Self::Outgoing),
            "PRIVATE" => Some(Self::Private),
            "MIGRATED_1ST_GEN" => Some(Self::Migrated1stGen),
            _ => None,
        }
    }
}
/// The database engine type and version.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlDatabaseVersion {
    /// This is an unknown database version.
    Unspecified = 0,
    /// The database version is MySQL 5.1.
    Mysql51 = 2,
    /// The database version is MySQL 5.5.
    Mysql55 = 3,
    /// The database version is MySQL 5.6.
    Mysql56 = 5,
    /// The database version is MySQL 5.7.
    Mysql57 = 6,
    /// The database version is SQL Server 2017 Standard.
    Sqlserver2017Standard = 11,
    /// The database version is SQL Server 2017 Enterprise.
    Sqlserver2017Enterprise = 14,
    /// The database version is SQL Server 2017 Express.
    Sqlserver2017Express = 15,
    /// The database version is SQL Server 2017 Web.
    Sqlserver2017Web = 16,
    /// The database version is PostgreSQL 9.6.
    Postgres96 = 9,
    /// The database version is PostgreSQL 10.
    Postgres10 = 18,
    /// The database version is PostgreSQL 11.
    Postgres11 = 10,
    /// The database version is PostgreSQL 12.
    Postgres12 = 19,
    /// The database version is PostgreSQL 13.
    Postgres13 = 23,
    /// The database version is PostgreSQL 14.
    Postgres14 = 110,
    /// The database version is PostgreSQL 15.
    Postgres15 = 172,
    /// The database version is PostgreSQL 16.
    Postgres16 = 272,
    /// The database version is MySQL 8.
    Mysql80 = 20,
    /// The database major version is MySQL 8.0 and the minor version is 18.
    Mysql8018 = 41,
    /// The database major version is MySQL 8.0 and the minor version is 26.
    Mysql8026 = 85,
    /// The database major version is MySQL 8.0 and the minor version is 27.
    Mysql8027 = 111,
    /// The database major version is MySQL 8.0 and the minor version is 28.
    Mysql8028 = 132,
    /// The database major version is MySQL 8.0 and the minor version is 29.
    Mysql8029 = 148,
    /// The database major version is MySQL 8.0 and the minor version is 30.
    Mysql8030 = 174,
    /// The database major version is MySQL 8.0 and the minor version is 31.
    Mysql8031 = 197,
    /// The database major version is MySQL 8.0 and the minor version is 32.
    Mysql8032 = 213,
    /// The database major version is MySQL 8.0 and the minor version is 33.
    Mysql8033 = 238,
    /// The database major version is MySQL 8.0 and the minor version is 34.
    Mysql8034 = 239,
    /// The database major version is MySQL 8.0 and the minor version is 35.
    Mysql8035 = 240,
    /// The database major version is MySQL 8.0 and the minor version is 36.
    Mysql8036 = 241,
    /// The database major version is MySQL 8.0 and the minor version is 37.
    Mysql8037 = 355,
    /// The database major version is MySQL 8.0 and the minor version is 38.
    Mysql8038 = 356,
    /// The database major version is MySQL 8.0 and the minor version is 39.
    Mysql8039 = 357,
    /// The database major version is MySQL 8.0 and the minor version is 40.
    Mysql8040 = 358,
    /// The database version is MySQL 8.4.
    Mysql84 = 398,
    /// The database version is MySQL 8.4 and the patch version is 0.
    Mysql840 = 399,
    /// The database version is SQL Server 2019 Standard.
    Sqlserver2019Standard = 26,
    /// The database version is SQL Server 2019 Enterprise.
    Sqlserver2019Enterprise = 27,
    /// The database version is SQL Server 2019 Express.
    Sqlserver2019Express = 28,
    /// The database version is SQL Server 2019 Web.
    Sqlserver2019Web = 29,
    /// The database version is SQL Server 2022 Standard.
    Sqlserver2022Standard = 199,
    /// The database version is SQL Server 2022 Enterprise.
    Sqlserver2022Enterprise = 200,
    /// The database version is SQL Server 2022 Express.
    Sqlserver2022Express = 201,
    /// The database version is SQL Server 2022 Web.
    Sqlserver2022Web = 202,
}
impl SqlDatabaseVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_DATABASE_VERSION_UNSPECIFIED",
            Self::Mysql51 => "MYSQL_5_1",
            Self::Mysql55 => "MYSQL_5_5",
            Self::Mysql56 => "MYSQL_5_6",
            Self::Mysql57 => "MYSQL_5_7",
            Self::Sqlserver2017Standard => "SQLSERVER_2017_STANDARD",
            Self::Sqlserver2017Enterprise => "SQLSERVER_2017_ENTERPRISE",
            Self::Sqlserver2017Express => "SQLSERVER_2017_EXPRESS",
            Self::Sqlserver2017Web => "SQLSERVER_2017_WEB",
            Self::Postgres96 => "POSTGRES_9_6",
            Self::Postgres10 => "POSTGRES_10",
            Self::Postgres11 => "POSTGRES_11",
            Self::Postgres12 => "POSTGRES_12",
            Self::Postgres13 => "POSTGRES_13",
            Self::Postgres14 => "POSTGRES_14",
            Self::Postgres15 => "POSTGRES_15",
            Self::Postgres16 => "POSTGRES_16",
            Self::Mysql80 => "MYSQL_8_0",
            Self::Mysql8018 => "MYSQL_8_0_18",
            Self::Mysql8026 => "MYSQL_8_0_26",
            Self::Mysql8027 => "MYSQL_8_0_27",
            Self::Mysql8028 => "MYSQL_8_0_28",
            Self::Mysql8029 => "MYSQL_8_0_29",
            Self::Mysql8030 => "MYSQL_8_0_30",
            Self::Mysql8031 => "MYSQL_8_0_31",
            Self::Mysql8032 => "MYSQL_8_0_32",
            Self::Mysql8033 => "MYSQL_8_0_33",
            Self::Mysql8034 => "MYSQL_8_0_34",
            Self::Mysql8035 => "MYSQL_8_0_35",
            Self::Mysql8036 => "MYSQL_8_0_36",
            Self::Mysql8037 => "MYSQL_8_0_37",
            Self::Mysql8038 => "MYSQL_8_0_38",
            Self::Mysql8039 => "MYSQL_8_0_39",
            Self::Mysql8040 => "MYSQL_8_0_40",
            Self::Mysql84 => "MYSQL_8_4",
            Self::Mysql840 => "MYSQL_8_4_0",
            Self::Sqlserver2019Standard => "SQLSERVER_2019_STANDARD",
            Self::Sqlserver2019Enterprise => "SQLSERVER_2019_ENTERPRISE",
            Self::Sqlserver2019Express => "SQLSERVER_2019_EXPRESS",
            Self::Sqlserver2019Web => "SQLSERVER_2019_WEB",
            Self::Sqlserver2022Standard => "SQLSERVER_2022_STANDARD",
            Self::Sqlserver2022Enterprise => "SQLSERVER_2022_ENTERPRISE",
            Self::Sqlserver2022Express => "SQLSERVER_2022_EXPRESS",
            Self::Sqlserver2022Web => "SQLSERVER_2022_WEB",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_DATABASE_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
            "MYSQL_5_1" => Some(Self::Mysql51),
            "MYSQL_5_5" => Some(Self::Mysql55),
            "MYSQL_5_6" => Some(Self::Mysql56),
            "MYSQL_5_7" => Some(Self::Mysql57),
            "SQLSERVER_2017_STANDARD" => Some(Self::Sqlserver2017Standard),
            "SQLSERVER_2017_ENTERPRISE" => Some(Self::Sqlserver2017Enterprise),
            "SQLSERVER_2017_EXPRESS" => Some(Self::Sqlserver2017Express),
            "SQLSERVER_2017_WEB" => Some(Self::Sqlserver2017Web),
            "POSTGRES_9_6" => Some(Self::Postgres96),
            "POSTGRES_10" => Some(Self::Postgres10),
            "POSTGRES_11" => Some(Self::Postgres11),
            "POSTGRES_12" => Some(Self::Postgres12),
            "POSTGRES_13" => Some(Self::Postgres13),
            "POSTGRES_14" => Some(Self::Postgres14),
            "POSTGRES_15" => Some(Self::Postgres15),
            "POSTGRES_16" => Some(Self::Postgres16),
            "MYSQL_8_0" => Some(Self::Mysql80),
            "MYSQL_8_0_18" => Some(Self::Mysql8018),
            "MYSQL_8_0_26" => Some(Self::Mysql8026),
            "MYSQL_8_0_27" => Some(Self::Mysql8027),
            "MYSQL_8_0_28" => Some(Self::Mysql8028),
            "MYSQL_8_0_29" => Some(Self::Mysql8029),
            "MYSQL_8_0_30" => Some(Self::Mysql8030),
            "MYSQL_8_0_31" => Some(Self::Mysql8031),
            "MYSQL_8_0_32" => Some(Self::Mysql8032),
            "MYSQL_8_0_33" => Some(Self::Mysql8033),
            "MYSQL_8_0_34" => Some(Self::Mysql8034),
            "MYSQL_8_0_35" => Some(Self::Mysql8035),
            "MYSQL_8_0_36" => Some(Self::Mysql8036),
            "MYSQL_8_0_37" => Some(Self::Mysql8037),
            "MYSQL_8_0_38" => Some(Self::Mysql8038),
            "MYSQL_8_0_39" => Some(Self::Mysql8039),
            "MYSQL_8_0_40" => Some(Self::Mysql8040),
            "MYSQL_8_4" => Some(Self::Mysql84),
            "MYSQL_8_4_0" => Some(Self::Mysql840),
            "SQLSERVER_2019_STANDARD" => Some(Self::Sqlserver2019Standard),
            "SQLSERVER_2019_ENTERPRISE" => Some(Self::Sqlserver2019Enterprise),
            "SQLSERVER_2019_EXPRESS" => Some(Self::Sqlserver2019Express),
            "SQLSERVER_2019_WEB" => Some(Self::Sqlserver2019Web),
            "SQLSERVER_2022_STANDARD" => Some(Self::Sqlserver2022Standard),
            "SQLSERVER_2022_ENTERPRISE" => Some(Self::Sqlserver2022Enterprise),
            "SQLSERVER_2022_EXPRESS" => Some(Self::Sqlserver2022Express),
            "SQLSERVER_2022_WEB" => Some(Self::Sqlserver2022Web),
            _ => None,
        }
    }
}
/// The pricing plan for this instance.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlPricingPlan {
    /// This is an unknown pricing plan for this instance.
    Unspecified = 0,
    /// The instance is billed at a monthly flat rate.
    Package = 1,
    /// The instance is billed per usage.
    PerUse = 2,
}
impl SqlPricingPlan {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_PRICING_PLAN_UNSPECIFIED",
            Self::Package => "PACKAGE",
            Self::PerUse => "PER_USE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_PRICING_PLAN_UNSPECIFIED" => Some(Self::Unspecified),
            "PACKAGE" => Some(Self::Package),
            "PER_USE" => Some(Self::PerUse),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlReplicationType {
    /// This is an unknown replication type for a Cloud SQL instance.
    Unspecified = 0,
    /// The synchronous replication mode for First Generation instances. It is the
    /// default value.
    Synchronous = 1,
    /// The asynchronous replication mode for First Generation instances. It
    /// provides a slight performance gain, but if an outage occurs while this
    /// option is set to asynchronous, you can lose up to a few seconds of updates
    /// to your data.
    Asynchronous = 2,
}
impl SqlReplicationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_REPLICATION_TYPE_UNSPECIFIED",
            Self::Synchronous => "SYNCHRONOUS",
            Self::Asynchronous => "ASYNCHRONOUS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_REPLICATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SYNCHRONOUS" => Some(Self::Synchronous),
            "ASYNCHRONOUS" => Some(Self::Asynchronous),
            _ => None,
        }
    }
}
/// The type of disk that is used for a v2 instance to use.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlDataDiskType {
    /// This is an unknown data disk type.
    Unspecified = 0,
    /// An SSD data disk.
    PdSsd = 1,
    /// An HDD data disk.
    PdHdd = 2,
    /// This field is deprecated and will be removed from a future version of the
    /// API.
    ObsoleteLocalSsd = 3,
}
impl SqlDataDiskType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_DATA_DISK_TYPE_UNSPECIFIED",
            Self::PdSsd => "PD_SSD",
            Self::PdHdd => "PD_HDD",
            Self::ObsoleteLocalSsd => "OBSOLETE_LOCAL_SSD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_DATA_DISK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PD_SSD" => Some(Self::PdSsd),
            "PD_HDD" => Some(Self::PdHdd),
            "OBSOLETE_LOCAL_SSD" => Some(Self::ObsoleteLocalSsd),
            _ => None,
        }
    }
}
/// The availability type of the given Cloud SQL instance.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlAvailabilityType {
    /// This is an unknown Availability type.
    Unspecified = 0,
    /// Zonal available instance.
    Zonal = 1,
    /// Regional available instance.
    Regional = 2,
}
impl SqlAvailabilityType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_AVAILABILITY_TYPE_UNSPECIFIED",
            Self::Zonal => "ZONAL",
            Self::Regional => "REGIONAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_AVAILABILITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ZONAL" => Some(Self::Zonal),
            "REGIONAL" => Some(Self::Regional),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlUpdateTrack {
    /// This is an unknown maintenance timing preference.
    Unspecified = 0,
    /// For an instance with a scheduled maintenance window, this maintenance
    /// timing indicates that the maintenance update is scheduled 7 to 14 days
    /// after the notification is sent out. Also referred to as `Week 1` (Console)
    /// and `preview` (gcloud CLI).
    Canary = 1,
    /// For an instance with a scheduled maintenance window, this maintenance
    /// timing indicates that the maintenance update is scheduled 15 to 21 days
    /// after the notification is sent out. Also referred to as `Week 2` (Console)
    /// and `production` (gcloud CLI).
    Stable = 2,
    /// For instance with a scheduled maintenance window, this maintenance
    /// timing indicates that the maintenance update is scheduled 35 to 42 days
    /// after the notification is sent out.
    Week5 = 3,
}
impl SqlUpdateTrack {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_UPDATE_TRACK_UNSPECIFIED",
            Self::Canary => "canary",
            Self::Stable => "stable",
            Self::Week5 => "week5",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_UPDATE_TRACK_UNSPECIFIED" => Some(Self::Unspecified),
            "canary" => Some(Self::Canary),
            "stable" => Some(Self::Stable),
            "week5" => Some(Self::Week5),
            _ => None,
        }
    }
}
/// Backup runs delete request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlBackupRunsDeleteRequest {
    /// The ID of the backup run to delete. To find a backup run ID, use the
    /// [list](<https://cloud.google.com/sql/docs/mysql/admin-api/rest/v1/backupRuns/list>)
    /// method.
    #[prost(int64, tag = "1")]
    pub id: i64,
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "2")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "3")]
    pub project: ::prost::alloc::string::String,
}
/// Backup runs get request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlBackupRunsGetRequest {
    /// The ID of this backup run.
    #[prost(int64, tag = "1")]
    pub id: i64,
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "2")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "3")]
    pub project: ::prost::alloc::string::String,
}
/// Backup runs insert request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlBackupRunsInsertRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<BackupRun>,
}
/// Backup runs list request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlBackupRunsListRequest {
    /// Cloud SQL instance ID, or "-" for all instances. This does not include
    /// the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Maximum number of backup runs per response.
    #[prost(int32, tag = "2")]
    pub max_results: i32,
    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "4")]
    pub project: ::prost::alloc::string::String,
}
/// A BackupRun resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupRun {
    /// This is always `sql#backupRun`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The status of this run.
    #[prost(enumeration = "SqlBackupRunStatus", tag = "2")]
    pub status: i32,
    /// The time the run was enqueued in UTC timezone in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "3")]
    pub enqueued_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The identifier for this backup run. Unique only for a specific Cloud SQL
    /// instance.
    #[prost(int64, tag = "4")]
    pub id: i64,
    /// The time the backup operation actually started in UTC timezone in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "5")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time the backup operation completed in UTC timezone in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "6")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Information about why the backup operation failed. This is only present if
    /// the run has the FAILED status.
    #[prost(message, optional, tag = "7")]
    pub error: ::core::option::Option<OperationError>,
    /// The type of this run; can be either "AUTOMATED" or "ON_DEMAND" or "FINAL".
    /// This field defaults to "ON_DEMAND" and is ignored, when specified for
    /// insert requests.
    #[prost(enumeration = "SqlBackupRunType", tag = "8")]
    pub r#type: i32,
    /// The description of this run, only applicable to on-demand backups.
    #[prost(string, tag = "9")]
    pub description: ::prost::alloc::string::String,
    /// The start time of the backup window during which this the backup was
    /// attempted in [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for
    /// example `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "10")]
    pub window_start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Name of the database instance.
    #[prost(string, tag = "11")]
    pub instance: ::prost::alloc::string::String,
    /// The URI of this resource.
    #[prost(string, tag = "12")]
    pub self_link: ::prost::alloc::string::String,
    /// Location of the backups.
    #[prost(string, tag = "13")]
    pub location: ::prost::alloc::string::String,
    /// Encryption configuration specific to a backup.
    #[prost(message, optional, tag = "16")]
    pub disk_encryption_configuration: ::core::option::Option<
        DiskEncryptionConfiguration,
    >,
    /// Encryption status specific to a backup.
    #[prost(message, optional, tag = "17")]
    pub disk_encryption_status: ::core::option::Option<DiskEncryptionStatus>,
    /// Specifies the kind of backup, PHYSICAL or DEFAULT_SNAPSHOT.
    #[prost(enumeration = "SqlBackupKind", tag = "19")]
    pub backup_kind: i32,
    /// Backup time zone to prevent restores to an instance with
    /// a different time zone. Now relevant only for SQL Server.
    #[prost(string, tag = "23")]
    pub time_zone: ::prost::alloc::string::String,
    /// Output only. The maximum chargeable bytes for the backup.
    #[prost(int64, optional, tag = "24")]
    pub max_chargeable_bytes: ::core::option::Option<i64>,
}
/// Backup run list results.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupRunsListResponse {
    /// This is always `sql#backupRunsList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// A list of backup runs in reverse chronological order of the enqueued time.
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<BackupRun>,
    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The status of a backup run.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlBackupRunStatus {
    /// The status of the run is unknown.
    Unspecified = 0,
    /// The backup operation was enqueued.
    Enqueued = 1,
    /// The backup is overdue across a given backup window. Indicates a
    /// problem. Example: Long-running operation in progress during
    /// the whole window.
    Overdue = 2,
    /// The backup is in progress.
    Running = 3,
    /// The backup failed.
    Failed = 4,
    /// The backup was successful.
    Successful = 5,
    /// The backup was skipped (without problems) for a given backup
    /// window. Example: Instance was idle.
    Skipped = 6,
    /// The backup is about to be deleted.
    DeletionPending = 7,
    /// The backup deletion failed.
    DeletionFailed = 8,
    /// The backup has been deleted.
    Deleted = 9,
}
impl SqlBackupRunStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_BACKUP_RUN_STATUS_UNSPECIFIED",
            Self::Enqueued => "ENQUEUED",
            Self::Overdue => "OVERDUE",
            Self::Running => "RUNNING",
            Self::Failed => "FAILED",
            Self::Successful => "SUCCESSFUL",
            Self::Skipped => "SKIPPED",
            Self::DeletionPending => "DELETION_PENDING",
            Self::DeletionFailed => "DELETION_FAILED",
            Self::Deleted => "DELETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_BACKUP_RUN_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "ENQUEUED" => Some(Self::Enqueued),
            "OVERDUE" => Some(Self::Overdue),
            "RUNNING" => Some(Self::Running),
            "FAILED" => Some(Self::Failed),
            "SUCCESSFUL" => Some(Self::Successful),
            "SKIPPED" => Some(Self::Skipped),
            "DELETION_PENDING" => Some(Self::DeletionPending),
            "DELETION_FAILED" => Some(Self::DeletionFailed),
            "DELETED" => Some(Self::Deleted),
            _ => None,
        }
    }
}
/// Defines the supported backup kinds.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlBackupKind {
    /// This is an unknown BackupKind.
    Unspecified = 0,
    /// The snapshot based backups
    Snapshot = 1,
    /// Physical backups
    Physical = 2,
}
impl SqlBackupKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_BACKUP_KIND_UNSPECIFIED",
            Self::Snapshot => "SNAPSHOT",
            Self::Physical => "PHYSICAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_BACKUP_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "SNAPSHOT" => Some(Self::Snapshot),
            "PHYSICAL" => Some(Self::Physical),
            _ => None,
        }
    }
}
/// Type of backup (i.e. automated, on demand, etc).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlBackupRunType {
    /// This is an unknown BackupRun type.
    Unspecified = 0,
    /// The backup schedule automatically triggers a backup.
    Automated = 1,
    /// The user manually triggers a backup.
    OnDemand = 2,
}
impl SqlBackupRunType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_BACKUP_RUN_TYPE_UNSPECIFIED",
            Self::Automated => "AUTOMATED",
            Self::OnDemand => "ON_DEMAND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_BACKUP_RUN_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "AUTOMATED" => Some(Self::Automated),
            "ON_DEMAND" => Some(Self::OnDemand),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod sql_backup_runs_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing database backups.
    #[derive(Debug, Clone)]
    pub struct SqlBackupRunsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlBackupRunsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlBackupRunsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlBackupRunsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlBackupRunsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the backup taken by a backup run.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlBackupRunsDeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlBackupRunsService/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlBackupRunsService", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a resource containing information about a backup run.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlBackupRunsGetRequest>,
        ) -> std::result::Result<tonic::Response<super::BackupRun>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlBackupRunsService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlBackupRunsService", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new backup run on demand.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlBackupRunsInsertRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlBackupRunsService/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlBackupRunsService", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all backup runs associated with the project or a given instance
        /// and configuration in the reverse chronological order of the backup
        /// initiation time.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlBackupRunsListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BackupRunsListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlBackupRunsService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlBackupRunsService", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Connect settings retrieval request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectSettingsRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Optional. Optional snapshot read timestamp to trade freshness for
    /// performance.
    #[prost(message, optional, tag = "7")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Connect settings retrieval response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectSettings {
    /// This is always `sql#connectSettings`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// SSL configuration.
    #[prost(message, optional, tag = "2")]
    pub server_ca_cert: ::core::option::Option<SslCert>,
    /// The assigned IP addresses for the instance.
    #[prost(message, repeated, tag = "3")]
    pub ip_addresses: ::prost::alloc::vec::Vec<IpMapping>,
    /// The cloud region for the instance. For example, `us-central1`,
    /// `europe-west1`. The region cannot be changed after instance creation.
    #[prost(string, tag = "4")]
    pub region: ::prost::alloc::string::String,
    /// The database engine type and version. The `databaseVersion`
    /// field cannot be changed after instance creation.
    ///    MySQL instances: `MYSQL_8_0`, `MYSQL_5_7` (default),
    /// or `MYSQL_5_6`.
    ///    PostgreSQL instances: `POSTGRES_9_6`, `POSTGRES_10`,
    /// `POSTGRES_11`, `POSTGRES_12` (default), `POSTGRES_13`, or `POSTGRES_14`.
    ///    SQL Server instances: `SQLSERVER_2017_STANDARD` (default),
    /// `SQLSERVER_2017_ENTERPRISE`, `SQLSERVER_2017_EXPRESS`,
    /// `SQLSERVER_2017_WEB`, `SQLSERVER_2019_STANDARD`,
    /// `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`, or
    /// `SQLSERVER_2019_WEB`.
    #[prost(enumeration = "SqlDatabaseVersion", tag = "31")]
    pub database_version: i32,
    /// `SECOND_GEN`: Cloud SQL database instance.
    /// `EXTERNAL`: A database server that is not managed by Google.
    /// This property is read-only; use the `tier` property in the `settings`
    /// object to determine the database type.
    #[prost(enumeration = "SqlBackendType", tag = "32")]
    pub backend_type: i32,
    /// Whether PSC connectivity is enabled for this instance.
    #[prost(bool, tag = "33")]
    pub psc_enabled: bool,
    /// The dns name of the instance.
    #[prost(string, tag = "34")]
    pub dns_name: ::prost::alloc::string::String,
    /// Specify what type of CA is used for the server certificate.
    #[prost(enumeration = "connect_settings::CaMode", tag = "35")]
    pub server_ca_mode: i32,
}
/// Nested message and enum types in `ConnectSettings`.
pub mod connect_settings {
    /// Various Certificate Authority (CA) modes for certificate signing.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CaMode {
        /// CA mode is unknown.
        Unspecified = 0,
        /// Google-managed self-signed internal CA.
        GoogleManagedInternalCa = 1,
        /// Google-managed regional CA part of root CA hierarchy hosted on Google
        /// Cloud's Certificate Authority Service (CAS).
        GoogleManagedCasCa = 2,
    }
    impl CaMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CA_MODE_UNSPECIFIED",
                Self::GoogleManagedInternalCa => "GOOGLE_MANAGED_INTERNAL_CA",
                Self::GoogleManagedCasCa => "GOOGLE_MANAGED_CAS_CA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CA_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "GOOGLE_MANAGED_INTERNAL_CA" => Some(Self::GoogleManagedInternalCa),
                "GOOGLE_MANAGED_CAS_CA" => Some(Self::GoogleManagedCasCa),
                _ => None,
            }
        }
    }
}
/// Ephemeral certificate creation request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateEphemeralCertRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// PEM encoded public key to include in the signed certificate.
    #[prost(string, tag = "3")]
    pub public_key: ::prost::alloc::string::String,
    /// Optional. Access token to include in the signed certificate.
    #[prost(string, tag = "4")]
    pub access_token: ::prost::alloc::string::String,
    /// Optional. Optional snapshot read timestamp to trade freshness for
    /// performance.
    #[prost(message, optional, tag = "7")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. If set, it will contain the cert valid duration.
    #[prost(message, optional, tag = "12")]
    pub valid_duration: ::core::option::Option<::prost_types::Duration>,
}
/// Ephemeral certificate creation request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateEphemeralCertResponse {
    /// Generated cert
    #[prost(message, optional, tag = "1")]
    pub ephemeral_cert: ::core::option::Option<SslCert>,
}
/// Generated client implementations.
pub mod sql_connect_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Cloud SQL connect service.
    #[derive(Debug, Clone)]
    pub struct SqlConnectServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlConnectServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlConnectServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlConnectServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlConnectServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves connect settings about a Cloud SQL instance.
        pub async fn get_connect_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConnectSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConnectSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlConnectService/GetConnectSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlConnectService",
                        "GetConnectSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generates a short-lived X509 certificate containing the provided public key
        /// and signed by a private key specific to the target instance. Users may use
        /// the certificate to authenticate as themselves when connecting to the
        /// database.
        pub async fn generate_ephemeral_cert(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateEphemeralCertRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateEphemeralCertResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlConnectService/GenerateEphemeralCert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlConnectService",
                        "GenerateEphemeralCert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Database delete request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlDatabasesDeleteRequest {
    /// Name of the database to be deleted in the instance.
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "2")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "3")]
    pub project: ::prost::alloc::string::String,
}
/// Database get request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlDatabasesGetRequest {
    /// Name of the database in the instance.
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "2")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "3")]
    pub project: ::prost::alloc::string::String,
}
/// Database insert request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlDatabasesInsertRequest {
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<Database>,
}
/// Database list request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlDatabasesListRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Database update request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlDatabasesUpdateRequest {
    /// Name of the database to be updated in the instance.
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "2")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "3")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<Database>,
}
/// Database list response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabasesListResponse {
    /// This is always `sql#databasesList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// List of database resources in the instance.
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<Database>,
}
/// Generated client implementations.
pub mod sql_databases_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to manage databases.
    #[derive(Debug, Clone)]
    pub struct SqlDatabasesServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlDatabasesServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlDatabasesServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlDatabasesServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlDatabasesServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes a database from a Cloud SQL instance.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlDatabasesDeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlDatabasesService/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlDatabasesService", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a resource containing information about a database inside a Cloud
        /// SQL instance.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlDatabasesGetRequest>,
        ) -> std::result::Result<tonic::Response<super::Database>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlDatabasesService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlDatabasesService", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Inserts a resource containing information about a database inside a Cloud
        /// SQL instance.
        ///
        /// **Note:** You can't modify the default character set and collation.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlDatabasesInsertRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlDatabasesService/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlDatabasesService", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists databases in the specified Cloud SQL instance.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlDatabasesListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DatabasesListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlDatabasesService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlDatabasesService", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Partially updates a resource containing information about a database inside
        /// a Cloud SQL instance. This method supports patch semantics.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlDatabasesUpdateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlDatabasesService/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlDatabasesService", "Patch"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a resource containing information about a database inside a Cloud
        /// SQL instance.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlDatabasesUpdateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlDatabasesService/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlDatabasesService", "Update"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod sql_events_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service that exposes Cloud SQL event information. This
    /// service is only used internally.
    #[derive(Debug, Clone)]
    pub struct SqlEventsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlEventsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlEventsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlEventsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlEventsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
    }
}
/// Flags list request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlFlagsListRequest {
    /// Database type and version you want to retrieve flags for. By default, this
    /// method returns flags for all database types and versions.
    #[prost(string, tag = "1")]
    pub database_version: ::prost::alloc::string::String,
}
/// Flags list response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlagsListResponse {
    /// This is always `sql#flagsList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// List of flags.
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<Flag>,
}
/// A flag resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Flag {
    /// This is the name of the flag. Flag names always use underscores, not
    /// hyphens, for example: `max_allowed_packet`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The type of the flag. Flags are typed to being `BOOLEAN`, `STRING`,
    /// `INTEGER` or `NONE`. `NONE` is used for flags that do not take a
    /// value, such as `skip_grant_tables`.
    #[prost(enumeration = "SqlFlagType", tag = "2")]
    pub r#type: i32,
    /// The database version this flag applies to. Can be
    /// MySQL instances: `MYSQL_8_0`, `MYSQL_8_0_18`, `MYSQL_8_0_26`, `MYSQL_5_7`,
    /// or `MYSQL_5_6`. PostgreSQL instances: `POSTGRES_9_6`, `POSTGRES_10`,
    /// `POSTGRES_11` or `POSTGRES_12`. SQL Server instances:
    /// `SQLSERVER_2017_STANDARD`, `SQLSERVER_2017_ENTERPRISE`,
    /// `SQLSERVER_2017_EXPRESS`, `SQLSERVER_2017_WEB`, `SQLSERVER_2019_STANDARD`,
    /// `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`, or
    /// `SQLSERVER_2019_WEB`.
    /// See [the complete
    /// list](/sql/docs/mysql/admin-api/rest/v1/SqlDatabaseVersion).
    #[prost(enumeration = "SqlDatabaseVersion", repeated, tag = "3")]
    pub applies_to: ::prost::alloc::vec::Vec<i32>,
    /// For `STRING` flags, a list of strings that the value can be set to.
    #[prost(string, repeated, tag = "4")]
    pub allowed_string_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// For `INTEGER` flags, the minimum allowed value.
    #[prost(message, optional, tag = "5")]
    pub min_value: ::core::option::Option<i64>,
    /// For `INTEGER` flags, the maximum allowed value.
    #[prost(message, optional, tag = "6")]
    pub max_value: ::core::option::Option<i64>,
    /// Indicates whether changing this flag will trigger a database restart. Only
    /// applicable to Second Generation instances.
    #[prost(message, optional, tag = "7")]
    pub requires_restart: ::core::option::Option<bool>,
    /// This is always `sql#flag`.
    #[prost(string, tag = "8")]
    pub kind: ::prost::alloc::string::String,
    /// Whether or not the flag is considered in beta.
    #[prost(message, optional, tag = "9")]
    pub in_beta: ::core::option::Option<bool>,
    /// Use this field if only certain integers are accepted. Can be combined
    /// with min_value and max_value to add additional values.
    #[prost(int64, repeated, tag = "10")]
    pub allowed_int_values: ::prost::alloc::vec::Vec<i64>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlFlagType {
    /// This is an unknown flag type.
    Unspecified = 0,
    /// Boolean type flag.
    Boolean = 1,
    /// String type flag.
    String = 2,
    /// Integer type flag.
    Integer = 3,
    /// Flag type used for a server startup option.
    None = 4,
    /// Type introduced specially for MySQL TimeZone offset. Accept a string value
    /// with the format \[-12:59, 13:00\].
    MysqlTimezoneOffset = 5,
    /// Float type flag.
    Float = 6,
    /// Comma-separated list of the strings in a SqlFlagType enum.
    RepeatedString = 7,
}
impl SqlFlagType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_FLAG_TYPE_UNSPECIFIED",
            Self::Boolean => "BOOLEAN",
            Self::String => "STRING",
            Self::Integer => "INTEGER",
            Self::None => "NONE",
            Self::MysqlTimezoneOffset => "MYSQL_TIMEZONE_OFFSET",
            Self::Float => "FLOAT",
            Self::RepeatedString => "REPEATED_STRING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_FLAG_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "BOOLEAN" => Some(Self::Boolean),
            "STRING" => Some(Self::String),
            "INTEGER" => Some(Self::Integer),
            "NONE" => Some(Self::None),
            "MYSQL_TIMEZONE_OFFSET" => Some(Self::MysqlTimezoneOffset),
            "FLOAT" => Some(Self::Float),
            "REPEATED_STRING" => Some(Self::RepeatedString),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod sql_flags_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to manage database flags for Cloud SQL instances.
    #[derive(Debug, Clone)]
    pub struct SqlFlagsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlFlagsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlFlagsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlFlagsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlFlagsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists all available database flags for Cloud SQL instances.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlFlagsListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FlagsListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlFlagsService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.sql.v1.SqlFlagsService", "List"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod sql_iam_policies_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for providing IAM Meta APIs for Cloud SQL.
    #[derive(Debug, Clone)]
    pub struct SqlIamPoliciesServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlIamPoliciesServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlIamPoliciesServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlIamPoliciesServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlIamPoliciesServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
    }
}
/// Generated client implementations.
pub mod sql_instance_names_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Cloud SQL instance names service.
    #[derive(Debug, Clone)]
    pub struct SqlInstanceNamesServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlInstanceNamesServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlInstanceNamesServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlInstanceNamesServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlInstanceNamesServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
    }
}
/// Instance add server CA request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesAddServerCaRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Instance clone request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesCloneRequest {
    /// The ID of the Cloud SQL instance to be cloned (source). This does not
    /// include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the source as well as the clone Cloud SQL instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesCloneRequest>,
}
/// Instance delete request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesDeleteRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance to be deleted.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Instance demote master request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesDemoteMasterRequest {
    /// Cloud SQL instance name.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesDemoteMasterRequest>,
}
/// Instance demote request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesDemoteRequest {
    /// Required. Cloud SQL instance name.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Required. ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Required. The request body.
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesDemoteRequest>,
}
/// Instance export request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesExportRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance to be exported.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesExportRequest>,
}
/// Instance failover request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesFailoverRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the read replica.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesFailoverRequest>,
}
/// Instance get request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesGetRequest {
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Instance import request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesImportRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesImportRequest>,
}
/// Instance insert request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesInsertRequest {
    /// Project ID of the project to which the newly created Cloud SQL instances
    /// should belong.
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<DatabaseInstance>,
}
/// Instance list request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesListRequest {
    /// A filter expression that filters resources listed in the response.
    /// The expression is in the form of field:value. For example,
    /// 'instanceType:CLOUD_SQL_INSTANCE'. Fields can be nested as needed as per
    /// their JSON representation, such as 'settings.userLabels.auto_start:true'.
    ///
    /// Multiple filter queries are space-separated. For example.
    /// 'state:RUNNABLE instanceType:CLOUD_SQL_INSTANCE'. By default, each
    /// expression is an AND expression. However, you can include AND and OR
    /// expressions explicitly.
    #[prost(string, tag = "1")]
    pub filter: ::prost::alloc::string::String,
    /// The maximum number of instances to return. The service may return fewer
    /// than this value.
    /// If unspecified, at most 500 instances are returned.
    /// The maximum value is 1000; values above 1000 are coerced to 1000.
    #[prost(uint32, tag = "2")]
    pub max_results: u32,
    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Project ID of the project for which to list Cloud SQL instances.
    #[prost(string, tag = "4")]
    pub project: ::prost::alloc::string::String,
}
/// Instance list server CAs request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesListServerCasRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Instance patch request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesPatchRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<DatabaseInstance>,
}
/// Instance promote replica request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesPromoteReplicaRequest {
    /// Cloud SQL read replica instance name.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the read replica.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Set to true to invoke a replica failover to the designated DR
    /// replica. As part of replica failover, the promote operation attempts
    /// to add the original primary instance as a replica of the promoted
    /// DR replica when the original primary instance comes back online.
    /// If set to false or not specified, then the original primary
    /// instance becomes an independent Cloud SQL primary instance.
    /// Only applicable to MySQL.
    #[prost(bool, tag = "3")]
    pub failover: bool,
}
/// Instance switchover request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesSwitchoverRequest {
    /// Cloud SQL read replica instance name.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the replica.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Optional. (MySQL only) Cloud SQL instance operations timeout, which is a
    /// sum of all database operations. Default value is 10 minutes and can be
    /// modified to a maximum value of 24 hours.
    #[prost(message, optional, tag = "3")]
    pub db_timeout: ::core::option::Option<::prost_types::Duration>,
}
/// Instance reset SSL config request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesResetSslConfigRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Instance restart request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesRestartRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance to be restarted.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Instance restore backup request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesRestoreBackupRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesRestoreBackupRequest>,
}
/// Instance rotate server CA request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesRotateServerCaRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesRotateServerCaRequest>,
}
/// Instance start replica request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesStartReplicaRequest {
    /// Cloud SQL read replica instance name.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the read replica.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Instance stop replica request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesStopReplicaRequest {
    /// Cloud SQL read replica instance name.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the read replica.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Instance truncate log request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesTruncateLogRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the Cloud SQL project.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesTruncateLogRequest>,
}
/// Instance perform disk shrink request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesPerformDiskShrinkRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Perform disk shrink context.
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<PerformDiskShrinkContext>,
}
/// Instance update request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesUpdateRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<DatabaseInstance>,
}
/// Instance reschedule maintenance request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesRescheduleMaintenanceRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<SqlInstancesRescheduleMaintenanceRequestBody>,
}
/// Instance reencrypt request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesReencryptRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Reencrypt body that users request
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<InstancesReencryptRequest>,
}
/// Database Instance reencrypt request.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InstancesReencryptRequest {
    /// Configuration specific to backup re-encryption
    #[prost(message, optional, tag = "1")]
    pub backup_reencryption_config: ::core::option::Option<BackupReencryptionConfig>,
}
/// Backup Reencryption Config
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BackupReencryptionConfig {
    /// Backup re-encryption limit
    #[prost(int32, optional, tag = "1")]
    pub backup_limit: ::core::option::Option<i32>,
    /// Type of backups users want to re-encrypt.
    #[prost(enumeration = "backup_reencryption_config::BackupType", optional, tag = "2")]
    pub backup_type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `BackupReencryptionConfig`.
pub mod backup_reencryption_config {
    /// Backup type for re-encryption
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BackupType {
        /// Unknown backup type, will be defaulted to AUTOMATIC backup type
        Unspecified = 0,
        /// Reencrypt automatic backups
        Automated = 1,
        /// Reencrypt on-demand backups
        OnDemand = 2,
    }
    impl BackupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BACKUP_TYPE_UNSPECIFIED",
                Self::Automated => "AUTOMATED",
                Self::OnDemand => "ON_DEMAND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BACKUP_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "AUTOMATED" => Some(Self::Automated),
                "ON_DEMAND" => Some(Self::OnDemand),
                _ => None,
            }
        }
    }
}
/// Instance get disk shrink config request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesGetDiskShrinkConfigRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Instance verify external sync settings request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesVerifyExternalSyncSettingsRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Flag to enable verifying connection only
    #[prost(bool, tag = "3")]
    pub verify_connection_only: bool,
    /// External sync mode
    #[prost(
        enumeration = "sql_instances_verify_external_sync_settings_request::ExternalSyncMode",
        tag = "4"
    )]
    pub sync_mode: i32,
    /// Optional. Flag to verify settings required by replication setup only
    #[prost(bool, tag = "5")]
    pub verify_replication_only: bool,
    /// Optional. MigrationType configures the migration to use physical files or
    /// logical dump files. If not set, then the logical dump file configuration is
    /// used. Valid values are `LOGICAL` or `PHYSICAL`. Only applicable to MySQL.
    #[prost(
        enumeration = "sql_instances_verify_external_sync_settings_request::MigrationType",
        tag = "7"
    )]
    pub migration_type: i32,
    /// Optional. Parallel level for initial data sync. Only applicable for
    /// PostgreSQL.
    #[prost(enumeration = "ExternalSyncParallelLevel", tag = "8")]
    pub sync_parallel_level: i32,
    #[prost(
        oneof = "sql_instances_verify_external_sync_settings_request::SyncConfig",
        tags = "6"
    )]
    pub sync_config: ::core::option::Option<
        sql_instances_verify_external_sync_settings_request::SyncConfig,
    >,
}
/// Nested message and enum types in `SqlInstancesVerifyExternalSyncSettingsRequest`.
pub mod sql_instances_verify_external_sync_settings_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExternalSyncMode {
        /// Unknown external sync mode, will be defaulted to ONLINE mode
        Unspecified = 0,
        /// Online external sync will set up replication after initial data external
        /// sync
        Online = 1,
        /// Offline external sync only dumps and loads a one-time snapshot of
        /// the primary instance's data
        Offline = 2,
    }
    impl ExternalSyncMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EXTERNAL_SYNC_MODE_UNSPECIFIED",
                Self::Online => "ONLINE",
                Self::Offline => "OFFLINE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXTERNAL_SYNC_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "ONLINE" => Some(Self::Online),
                "OFFLINE" => Some(Self::Offline),
                _ => None,
            }
        }
    }
    /// MigrationType determines whether the migration is a physical file-based
    /// migration or a logical dump file-based migration.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MigrationType {
        /// Default value is a logical dump file-based migration
        Unspecified = 0,
        /// Logical dump file-based migration
        Logical = 1,
        /// Physical file-based migration
        Physical = 2,
    }
    impl MigrationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MIGRATION_TYPE_UNSPECIFIED",
                Self::Logical => "LOGICAL",
                Self::Physical => "PHYSICAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MIGRATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "LOGICAL" => Some(Self::Logical),
                "PHYSICAL" => Some(Self::Physical),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SyncConfig {
        /// Optional. MySQL-specific settings for start external sync.
        #[prost(message, tag = "6")]
        MysqlSyncConfig(super::MySqlSyncConfig),
    }
}
/// Instance start external sync request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesStartExternalSyncRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// External sync mode.
    #[prost(
        enumeration = "sql_instances_verify_external_sync_settings_request::ExternalSyncMode",
        tag = "3"
    )]
    pub sync_mode: i32,
    /// Whether to skip the verification step (VESS).
    #[prost(bool, tag = "4")]
    pub skip_verification: bool,
    /// Optional. Parallel level for initial data sync. Currently only applicable
    /// for MySQL.
    #[prost(enumeration = "ExternalSyncParallelLevel", tag = "7")]
    pub sync_parallel_level: i32,
    /// Optional. MigrationType configures the migration to use physical files or
    /// logical dump files. If not set, then the logical dump file configuration is
    /// used. Valid values are `LOGICAL` or `PHYSICAL`. Only applicable to MySQL.
    #[prost(
        enumeration = "sql_instances_verify_external_sync_settings_request::MigrationType",
        tag = "8"
    )]
    pub migration_type: i32,
    #[prost(oneof = "sql_instances_start_external_sync_request::SyncConfig", tags = "6")]
    pub sync_config: ::core::option::Option<
        sql_instances_start_external_sync_request::SyncConfig,
    >,
}
/// Nested message and enum types in `SqlInstancesStartExternalSyncRequest`.
pub mod sql_instances_start_external_sync_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SyncConfig {
        /// MySQL-specific settings for start external sync.
        #[prost(message, tag = "6")]
        MysqlSyncConfig(super::MySqlSyncConfig),
    }
}
/// Instance reset replica size request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesResetReplicaSizeRequest {
    /// Cloud SQL read replica instance name.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the read replica.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Instance create ephemeral certificate request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesCreateEphemeralCertRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the Cloud SQL project.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<SslCertsCreateEphemeralRequest>,
}
/// Database instance clone request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesCloneRequest {
    /// Contains details about the clone operation.
    #[prost(message, optional, tag = "1")]
    pub clone_context: ::core::option::Option<CloneContext>,
}
/// Database demote primary instance request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesDemoteMasterRequest {
    /// Contains details about the demoteMaster operation.
    #[prost(message, optional, tag = "1")]
    pub demote_master_context: ::core::option::Option<DemoteMasterContext>,
}
/// This request is used to demote an existing standalone instance to be a
/// Cloud SQL read replica for an external database server.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesDemoteRequest {
    /// Required. Contains details about the demote operation.
    #[prost(message, optional, tag = "1")]
    pub demote_context: ::core::option::Option<DemoteContext>,
}
/// Database instance export request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesExportRequest {
    /// Contains details about the export operation.
    #[prost(message, optional, tag = "1")]
    pub export_context: ::core::option::Option<ExportContext>,
}
/// Instance failover request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesFailoverRequest {
    /// Failover Context.
    #[prost(message, optional, tag = "1")]
    pub failover_context: ::core::option::Option<FailoverContext>,
}
/// SslCerts create ephemeral certificate request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslCertsCreateEphemeralRequest {
    /// PEM encoded public key to include in the signed certificate.
    #[prost(string, tag = "1")]
    pub public_key: ::prost::alloc::string::String,
    /// Access token to include in the signed certificate.
    #[prost(string, tag = "2")]
    pub access_token: ::prost::alloc::string::String,
}
/// Database instance import request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesImportRequest {
    /// Contains details about the import operation.
    #[prost(message, optional, tag = "1")]
    pub import_context: ::core::option::Option<ImportContext>,
}
/// Database instances list response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesListResponse {
    /// This is always `sql#instancesList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// List of warnings that occurred while handling the request.
    #[prost(message, repeated, tag = "2")]
    pub warnings: ::prost::alloc::vec::Vec<ApiWarning>,
    /// List of database instance resources.
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<DatabaseInstance>,
    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[prost(string, tag = "4")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Instances ListServerCas response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesListServerCasResponse {
    /// List of server CA certificates for the instance.
    #[prost(message, repeated, tag = "1")]
    pub certs: ::prost::alloc::vec::Vec<SslCert>,
    #[prost(string, tag = "2")]
    pub active_version: ::prost::alloc::string::String,
    /// This is always `sql#instancesListServerCas`.
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
}
/// Database instance restore backup request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesRestoreBackupRequest {
    /// Parameters required to perform the restore backup operation.
    #[prost(message, optional, tag = "1")]
    pub restore_backup_context: ::core::option::Option<RestoreBackupContext>,
}
/// Rotate server CA request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesRotateServerCaRequest {
    /// Contains details about the rotate server CA operation.
    #[prost(message, optional, tag = "1")]
    pub rotate_server_ca_context: ::core::option::Option<RotateServerCaContext>,
}
/// Instance truncate log request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesTruncateLogRequest {
    /// Contains details about the truncate log operation.
    #[prost(message, optional, tag = "1")]
    pub truncate_log_context: ::core::option::Option<TruncateLogContext>,
}
/// Request to acquire a lease for SSRS.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesAcquireSsrsLeaseRequest {
    /// Contains details about the acquire SSRS lease operation.
    #[prost(message, optional, tag = "1")]
    pub acquire_ssrs_lease_context: ::core::option::Option<AcquireSsrsLeaseContext>,
}
/// Instance verify external sync settings response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesVerifyExternalSyncSettingsResponse {
    /// This is always `sql#migrationSettingErrorList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// List of migration violations.
    #[prost(message, repeated, tag = "2")]
    pub errors: ::prost::alloc::vec::Vec<SqlExternalSyncSettingError>,
    /// List of migration warnings.
    #[prost(message, repeated, tag = "3")]
    pub warnings: ::prost::alloc::vec::Vec<SqlExternalSyncSettingError>,
}
/// Instance get disk shrink config response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesGetDiskShrinkConfigResponse {
    /// This is always `sql#getDiskShrinkConfig`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The minimum size to which a disk can be shrunk in GigaBytes.
    #[prost(int64, tag = "2")]
    pub minimal_target_size_gb: i64,
    /// Additional message to customers.
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
/// Instance get latest recovery time request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesGetLatestRecoveryTimeRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Instance get latest recovery time response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesGetLatestRecoveryTimeResponse {
    /// This is always `sql#getLatestRecoveryTime`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Timestamp, identifies the latest recovery time of the source instance.
    #[prost(message, optional, tag = "2")]
    pub latest_recovery_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Database instance clone context.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloneContext {
    /// This is always `sql#cloneContext`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Reserved for future use.
    #[prost(int64, tag = "2")]
    pub pitr_timestamp_ms: i64,
    /// Name of the Cloud SQL instance to be created as a clone.
    #[prost(string, tag = "3")]
    pub destination_instance_name: ::prost::alloc::string::String,
    /// Binary log coordinates, if specified, identify the position up to which the
    /// source instance is cloned. If not specified, the source instance is
    /// cloned up to the most recent binary log coordinates.
    #[prost(message, optional, tag = "4")]
    pub bin_log_coordinates: ::core::option::Option<BinLogCoordinates>,
    /// Timestamp, if specified, identifies the time to which the source instance
    /// is cloned.
    #[prost(message, optional, tag = "5")]
    pub point_in_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The name of the allocated ip range for the private ip Cloud SQL instance.
    /// For example: "google-managed-services-default". If set, the cloned instance
    /// ip will be created in the allocated range. The range name must comply with
    /// [RFC 1035](<https://tools.ietf.org/html/rfc1035>). Specifically, the name
    /// must be 1-63 characters long and match the regular expression
    /// [a-z](\[-a-z0-9\]*[a-z0-9])?.
    /// Reserved for future use.
    #[prost(string, tag = "6")]
    pub allocated_ip_range: ::prost::alloc::string::String,
    /// (SQL Server only) Clone only the specified databases from the source
    /// instance. Clone all databases if empty.
    #[prost(string, repeated, tag = "9")]
    pub database_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Copy clone and point-in-time recovery clone of an instance to the
    /// specified zone. If no zone is specified, clone to the same primary zone as
    /// the source instance. This field applies to all DB types.
    #[prost(string, optional, tag = "10")]
    pub preferred_zone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Binary log coordinates.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BinLogCoordinates {
    /// Name of the binary log file for a Cloud SQL instance.
    #[prost(string, tag = "1")]
    pub bin_log_file_name: ::prost::alloc::string::String,
    /// Position (offset) within the binary log file.
    #[prost(int64, tag = "2")]
    pub bin_log_position: i64,
    /// This is always `sql#binLogCoordinates`.
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
}
/// A Cloud SQL instance resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseInstance {
    /// This is always `sql#instance`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The current serving state of the Cloud SQL instance.
    #[prost(enumeration = "database_instance::SqlInstanceState", tag = "2")]
    pub state: i32,
    /// The database engine type and version. The `databaseVersion` field cannot
    /// be changed after instance creation.
    #[prost(enumeration = "SqlDatabaseVersion", tag = "3")]
    pub database_version: i32,
    /// The user settings.
    #[prost(message, optional, tag = "4")]
    pub settings: ::core::option::Option<Settings>,
    /// This field is deprecated and will be removed from a future version of the
    /// API. Use the `settings.settingsVersion` field instead.
    #[prost(string, tag = "5")]
    pub etag: ::prost::alloc::string::String,
    /// The name and status of the failover replica.
    #[prost(message, optional, tag = "6")]
    pub failover_replica: ::core::option::Option<database_instance::SqlFailoverReplica>,
    /// The name of the instance which will act as primary in the replication
    /// setup.
    #[prost(string, tag = "7")]
    pub master_instance_name: ::prost::alloc::string::String,
    /// The replicas of the instance.
    #[prost(string, repeated, tag = "8")]
    pub replica_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The maximum disk size of the instance in bytes.
    #[deprecated]
    #[prost(message, optional, tag = "9")]
    pub max_disk_size: ::core::option::Option<i64>,
    /// The current disk usage of the instance in bytes. This property has been
    /// deprecated. Use the
    /// "cloudsql.googleapis.com/database/disk/bytes_used" metric in Cloud
    /// Monitoring API instead. Please see [this
    /// announcement](<https://groups.google.com/d/msg/google-cloud-sql-announce/I_7-F9EBhT0/BtvFtdFeAgAJ>)
    /// for details.
    #[deprecated]
    #[prost(message, optional, tag = "10")]
    pub current_disk_size: ::core::option::Option<i64>,
    /// The assigned IP addresses for the instance.
    #[prost(message, repeated, tag = "11")]
    pub ip_addresses: ::prost::alloc::vec::Vec<IpMapping>,
    /// SSL configuration.
    #[prost(message, optional, tag = "12")]
    pub server_ca_cert: ::core::option::Option<SslCert>,
    /// The instance type.
    #[prost(enumeration = "SqlInstanceType", tag = "13")]
    pub instance_type: i32,
    /// The project ID of the project containing the Cloud SQL instance. The Google
    /// apps domain is prefixed if applicable.
    #[prost(string, tag = "14")]
    pub project: ::prost::alloc::string::String,
    /// The IPv6 address assigned to the instance.
    /// (Deprecated) This property was applicable only
    /// to First Generation instances.
    #[deprecated]
    #[prost(string, tag = "15")]
    pub ipv6_address: ::prost::alloc::string::String,
    /// The service account email address assigned to the instance.\This
    /// property is read-only.
    #[prost(string, tag = "16")]
    pub service_account_email_address: ::prost::alloc::string::String,
    /// Configuration specific to on-premises instances.
    #[prost(message, optional, tag = "17")]
    pub on_premises_configuration: ::core::option::Option<OnPremisesConfiguration>,
    /// Configuration specific to failover replicas and read replicas.
    #[prost(message, optional, tag = "18")]
    pub replica_configuration: ::core::option::Option<ReplicaConfiguration>,
    /// The backend type.
    /// `SECOND_GEN`: Cloud SQL database instance.
    /// `EXTERNAL`: A database server that is not managed by Google.
    ///
    /// This property is read-only; use the `tier` property in the `settings`
    /// object to determine the database type.
    #[prost(enumeration = "SqlBackendType", tag = "19")]
    pub backend_type: i32,
    /// The URI of this resource.
    #[prost(string, tag = "20")]
    pub self_link: ::prost::alloc::string::String,
    /// If the instance state is SUSPENDED, the reason for the suspension.
    #[prost(enumeration = "SqlSuspensionReason", repeated, tag = "21")]
    pub suspension_reason: ::prost::alloc::vec::Vec<i32>,
    /// Connection name of the Cloud SQL instance used in connection strings.
    #[prost(string, tag = "22")]
    pub connection_name: ::prost::alloc::string::String,
    /// Name of the Cloud SQL instance. This does not include the project ID.
    #[prost(string, tag = "23")]
    pub name: ::prost::alloc::string::String,
    /// The geographical region of the Cloud SQL instance.
    ///
    /// It can be one of the
    /// [regions](<https://cloud.google.com/sql/docs/mysql/locations#location-r>)
    /// where Cloud SQL operates:
    ///
    /// For example,  `asia-east1`, `europe-west1`, and  `us-central1`.
    /// The default value is `us-central1`.
    #[prost(string, tag = "24")]
    pub region: ::prost::alloc::string::String,
    /// The Compute Engine zone that the instance is currently serving from. This
    /// value could be different from the zone that was specified when the instance
    /// was created if the instance has failed over to its secondary zone. WARNING:
    /// Changing this might restart the instance.
    #[prost(string, tag = "25")]
    pub gce_zone: ::prost::alloc::string::String,
    /// The Compute Engine zone that the failover instance is currently serving
    /// from for a regional instance. This value could be different
    /// from the zone that was specified when the instance
    /// was created if the instance has failed over to its secondary/failover zone.
    #[prost(string, tag = "34")]
    pub secondary_gce_zone: ::prost::alloc::string::String,
    /// Disk encryption configuration specific to an instance.
    #[prost(message, optional, tag = "26")]
    pub disk_encryption_configuration: ::core::option::Option<
        DiskEncryptionConfiguration,
    >,
    /// Disk encryption status specific to an instance.
    #[prost(message, optional, tag = "27")]
    pub disk_encryption_status: ::core::option::Option<DiskEncryptionStatus>,
    /// Initial root password. Use only on creation. You must set root passwords
    /// before you can connect to PostgreSQL instances.
    #[prost(string, tag = "29")]
    pub root_password: ::prost::alloc::string::String,
    /// The start time of any upcoming scheduled maintenance for this instance.
    #[prost(message, optional, tag = "30")]
    pub scheduled_maintenance: ::core::option::Option<
        database_instance::SqlScheduledMaintenance,
    >,
    /// This status indicates whether the instance satisfies PZS.
    ///
    /// The status is reserved for future use.
    #[prost(message, optional, tag = "35")]
    pub satisfies_pzs: ::core::option::Option<bool>,
    /// Output only. Stores the current database version running on the instance
    /// including minor version such as `MYSQL_8_0_18`.
    #[prost(string, tag = "40")]
    pub database_installed_version: ::prost::alloc::string::String,
    /// This field represents the report generated by the proactive database
    /// wellness job for OutOfDisk issues.
    /// *  Writers:
    ///    *  the proactive database wellness job for OOD.
    /// *  Readers:
    ///    *  the proactive database wellness job
    #[prost(message, optional, tag = "38")]
    pub out_of_disk_report: ::core::option::Option<
        database_instance::SqlOutOfDiskReport,
    >,
    /// Output only. The time when the instance was created in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "39")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. List all maintenance versions applicable on the instance
    #[prost(string, repeated, tag = "41")]
    pub available_maintenance_versions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// The current software version on the instance.
    #[prost(string, tag = "42")]
    pub maintenance_version: ::prost::alloc::string::String,
    /// Output only. All database versions that are available for upgrade.
    #[prost(message, repeated, tag = "45")]
    pub upgradable_database_versions: ::prost::alloc::vec::Vec<AvailableDatabaseVersion>,
    #[prost(
        enumeration = "database_instance::SqlNetworkArchitecture",
        optional,
        tag = "47"
    )]
    pub sql_network_architecture: ::core::option::Option<i32>,
    /// Output only. The link to service attachment of PSC instance.
    #[prost(string, optional, tag = "48")]
    pub psc_service_attachment_link: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// Output only. The dns name of the instance.
    #[prost(string, optional, tag = "49")]
    pub dns_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. DEPRECATED: please use write_endpoint instead.
    #[deprecated]
    #[prost(string, optional, tag = "51")]
    pub primary_dns_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The dns name of the primary instance in a replication group.
    #[prost(string, optional, tag = "52")]
    pub write_endpoint: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. A primary instance and disaster recovery (DR) replica pair.
    /// A DR replica is a cross-region replica that you designate
    /// for failover in the event that the primary instance
    /// experiences regional failure. Only applicable to MySQL.
    #[prost(message, optional, tag = "54")]
    pub replication_cluster: ::core::option::Option<ReplicationCluster>,
    /// Gemini instance configuration.
    #[prost(message, optional, tag = "55")]
    pub gemini_config: ::core::option::Option<GeminiInstanceConfig>,
    /// Output only. This status indicates whether the instance satisfies PZI.
    ///
    /// The status is reserved for future use.
    #[prost(message, optional, tag = "56")]
    pub satisfies_pzi: ::core::option::Option<bool>,
    /// Input only. Whether Cloud SQL is enabled to switch storing point-in-time
    /// recovery log files from a data disk to Cloud Storage.
    #[prost(message, optional, tag = "57")]
    pub switch_transaction_logs_to_cloud_storage_enabled: ::core::option::Option<bool>,
}
/// Nested message and enum types in `DatabaseInstance`.
pub mod database_instance {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SqlFailoverReplica {
        /// The name of the failover replica. If specified at instance creation, a
        /// failover replica is created for the instance. The name
        /// doesn't include the project ID.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// The availability status of the failover replica. A false status indicates
        /// that the failover replica is out of sync. The primary instance can only
        /// failover to the failover replica when the status is true.
        #[prost(message, optional, tag = "2")]
        pub available: ::core::option::Option<bool>,
    }
    /// Any scheduled maintenance for this instance.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SqlScheduledMaintenance {
        /// The start time of any upcoming scheduled maintenance for this instance.
        #[prost(message, optional, tag = "1")]
        pub start_time: ::core::option::Option<::prost_types::Timestamp>,
        #[deprecated]
        #[prost(bool, tag = "2")]
        pub can_defer: bool,
        /// If the scheduled maintenance can be rescheduled.
        #[prost(bool, tag = "3")]
        pub can_reschedule: bool,
        /// Maintenance cannot be rescheduled to start beyond this deadline.
        #[prost(message, optional, tag = "4")]
        pub schedule_deadline_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// This message wraps up the information written by out-of-disk detection job.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SqlOutOfDiskReport {
        /// This field represents the state generated by the proactive database
        /// wellness job for OutOfDisk issues.
        /// *  Writers:
        ///    *  the proactive database wellness job for OOD.
        /// *  Readers:
        ///    *  the proactive database wellness job
        #[prost(
            enumeration = "sql_out_of_disk_report::SqlOutOfDiskState",
            optional,
            tag = "1"
        )]
        pub sql_out_of_disk_state: ::core::option::Option<i32>,
        /// The minimum recommended increase size in GigaBytes
        /// This field is consumed by the frontend
        /// *  Writers:
        ///    *  the proactive database wellness job for OOD.
        /// *  Readers:
        #[prost(int32, optional, tag = "2")]
        pub sql_min_recommended_increase_size_gb: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `SqlOutOfDiskReport`.
    pub mod sql_out_of_disk_report {
        /// This enum lists all possible states regarding out-of-disk issues.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SqlOutOfDiskState {
            /// Unspecified state
            Unspecified = 0,
            /// The instance has plenty space on data disk
            Normal = 1,
            /// Data disk is almost used up. It is shutdown to prevent data
            /// corruption.
            SoftShutdown = 2,
        }
        impl SqlOutOfDiskState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SQL_OUT_OF_DISK_STATE_UNSPECIFIED",
                    Self::Normal => "NORMAL",
                    Self::SoftShutdown => "SOFT_SHUTDOWN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SQL_OUT_OF_DISK_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "NORMAL" => Some(Self::Normal),
                    "SOFT_SHUTDOWN" => Some(Self::SoftShutdown),
                    _ => None,
                }
            }
        }
    }
    /// The current serving state of the database instance.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlInstanceState {
        /// The state of the instance is unknown.
        Unspecified = 0,
        /// The instance is running, or has been stopped by owner.
        Runnable = 1,
        /// The instance is not available, for example due to problems with billing.
        Suspended = 2,
        /// The instance is being deleted.
        PendingDelete = 3,
        /// The instance is being created.
        PendingCreate = 4,
        /// The instance is down for maintenance.
        Maintenance = 5,
        /// The creation of the instance failed or a fatal error occurred during
        /// maintenance.
        Failed = 6,
        /// Deprecated
        OnlineMaintenance = 7,
    }
    impl SqlInstanceState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SQL_INSTANCE_STATE_UNSPECIFIED",
                Self::Runnable => "RUNNABLE",
                Self::Suspended => "SUSPENDED",
                Self::PendingDelete => "PENDING_DELETE",
                Self::PendingCreate => "PENDING_CREATE",
                Self::Maintenance => "MAINTENANCE",
                Self::Failed => "FAILED",
                Self::OnlineMaintenance => "ONLINE_MAINTENANCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_INSTANCE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "RUNNABLE" => Some(Self::Runnable),
                "SUSPENDED" => Some(Self::Suspended),
                "PENDING_DELETE" => Some(Self::PendingDelete),
                "PENDING_CREATE" => Some(Self::PendingCreate),
                "MAINTENANCE" => Some(Self::Maintenance),
                "FAILED" => Some(Self::Failed),
                "ONLINE_MAINTENANCE" => Some(Self::OnlineMaintenance),
                _ => None,
            }
        }
    }
    /// The SQL network architecture for the instance.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlNetworkArchitecture {
        Unspecified = 0,
        /// The instance uses the new network architecture.
        NewNetworkArchitecture = 1,
        /// The instance uses the old network architecture.
        OldNetworkArchitecture = 2,
    }
    impl SqlNetworkArchitecture {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SQL_NETWORK_ARCHITECTURE_UNSPECIFIED",
                Self::NewNetworkArchitecture => "NEW_NETWORK_ARCHITECTURE",
                Self::OldNetworkArchitecture => "OLD_NETWORK_ARCHITECTURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_NETWORK_ARCHITECTURE_UNSPECIFIED" => Some(Self::Unspecified),
                "NEW_NETWORK_ARCHITECTURE" => Some(Self::NewNetworkArchitecture),
                "OLD_NETWORK_ARCHITECTURE" => Some(Self::OldNetworkArchitecture),
                _ => None,
            }
        }
    }
}
/// Gemini instance configuration.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GeminiInstanceConfig {
    /// Output only. Whether Gemini is enabled.
    #[prost(bool, optional, tag = "1")]
    pub entitled: ::core::option::Option<bool>,
    /// Output only. Whether the vacuum management is enabled.
    #[prost(bool, optional, tag = "2")]
    pub google_vacuum_mgmt_enabled: ::core::option::Option<bool>,
    /// Output only. Whether canceling the out-of-memory (OOM) session is enabled.
    #[prost(bool, optional, tag = "3")]
    pub oom_session_cancel_enabled: ::core::option::Option<bool>,
    /// Output only. Whether the active query is enabled.
    #[prost(bool, optional, tag = "4")]
    pub active_query_enabled: ::core::option::Option<bool>,
    /// Output only. Whether the index advisor is enabled.
    #[prost(bool, optional, tag = "5")]
    pub index_advisor_enabled: ::core::option::Option<bool>,
    /// Output only. Whether the flag recommender is enabled.
    #[prost(bool, optional, tag = "6")]
    pub flag_recommender_enabled: ::core::option::Option<bool>,
}
/// A primary instance and disaster recovery (DR) replica pair.
/// A DR replica is a cross-region replica that you designate for failover in
/// the event that the primary instance experiences regional failure.
/// Only applicable to MySQL.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplicationCluster {
    /// Output only. If set, it indicates this instance has a private service
    /// access (PSA) dns endpoint that is pointing to the primary instance of the
    /// cluster. If this instance is the primary, the dns should be pointing to
    /// this instance. After Switchover or Replica failover, this DNS endpoint
    /// points to the promoted instance. This is a read-only field, returned to the
    /// user as information. This field can exist even if a standalone instance
    /// does not yet have a replica, or had a DR replica that was deleted.
    #[prost(string, tag = "1")]
    pub psa_write_endpoint: ::prost::alloc::string::String,
    /// Optional. If the instance is a primary instance, then this field identifies
    /// the disaster recovery (DR) replica. A DR replica is an optional
    /// configuration for Enterprise Plus edition instances. If the instance is a
    /// read replica, then the field is not set. Set this field to a replica name
    /// to designate a DR replica for a primary instance. Remove the replica name
    /// to remove the DR replica designation.
    #[prost(string, tag = "2")]
    pub failover_dr_replica_name: ::prost::alloc::string::String,
    /// Output only. Read-only field that indicates whether the replica is a DR
    /// replica. This field is not set if the instance is a primary instance.
    #[prost(bool, tag = "4")]
    pub dr_replica: bool,
}
/// An available database version. It can be a major or a minor version.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvailableDatabaseVersion {
    /// The version's major version name.
    #[prost(string, optional, tag = "3")]
    pub major_version: ::core::option::Option<::prost::alloc::string::String>,
    /// The database version name. For MySQL 8.0, this string provides the database
    /// major and minor version.
    #[prost(string, optional, tag = "8")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The database version's display name.
    #[prost(string, optional, tag = "9")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Reschedule options for maintenance windows.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SqlInstancesRescheduleMaintenanceRequestBody {
    /// Required. The type of the reschedule the user wants.
    #[prost(message, optional, tag = "3")]
    pub reschedule: ::core::option::Option<
        sql_instances_reschedule_maintenance_request_body::Reschedule,
    >,
}
/// Nested message and enum types in `SqlInstancesRescheduleMaintenanceRequestBody`.
pub mod sql_instances_reschedule_maintenance_request_body {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Reschedule {
        /// Required. The type of the reschedule.
        #[prost(enumeration = "RescheduleType", tag = "1")]
        pub reschedule_type: i32,
        /// Optional. Timestamp when the maintenance shall be rescheduled to if
        /// reschedule_type=SPECIFIC_TIME, in
        /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
        /// `2012-11-15T16:19:00.094Z`.
        #[prost(message, optional, tag = "2")]
        pub schedule_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RescheduleType {
        Unspecified = 0,
        /// Reschedules maintenance to happen now (within 5 minutes).
        Immediate = 1,
        /// Reschedules maintenance to occur within one week from the originally
        /// scheduled day and time.
        NextAvailableWindow = 2,
        /// Reschedules maintenance to a specific time and day.
        SpecificTime = 3,
    }
    impl RescheduleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESCHEDULE_TYPE_UNSPECIFIED",
                Self::Immediate => "IMMEDIATE",
                Self::NextAvailableWindow => "NEXT_AVAILABLE_WINDOW",
                Self::SpecificTime => "SPECIFIC_TIME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESCHEDULE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "IMMEDIATE" => Some(Self::Immediate),
                "NEXT_AVAILABLE_WINDOW" => Some(Self::NextAvailableWindow),
                "SPECIFIC_TIME" => Some(Self::SpecificTime),
                _ => None,
            }
        }
    }
}
/// Database instance demote primary instance context.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DemoteMasterContext {
    /// This is always `sql#demoteMasterContext`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Verify the GTID consistency for demote operation. Default value:
    /// `True`. Setting this flag to `false` enables you to bypass the GTID
    /// consistency check between on-premises primary instance and Cloud SQL
    /// instance during the demotion operation but also exposes you to the risk of
    /// future replication failures. Change the value only if you know the reason
    /// for the GTID divergence and are confident that doing so will not cause any
    /// replication issues.
    #[prost(message, optional, tag = "2")]
    pub verify_gtid_consistency: ::core::option::Option<bool>,
    /// The name of the instance which will act as on-premises primary instance
    /// in the replication setup.
    #[prost(string, tag = "3")]
    pub master_instance_name: ::prost::alloc::string::String,
    /// Configuration specific to read-replicas replicating from the on-premises
    /// primary instance.
    #[prost(message, optional, tag = "4")]
    pub replica_configuration: ::core::option::Option<DemoteMasterConfiguration>,
    /// Flag to skip replication setup on the instance.
    #[prost(bool, tag = "5")]
    pub skip_replication_setup: bool,
}
/// This context is used to demote an existing standalone instance to be
/// a Cloud SQL read replica for an external database server.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DemoteContext {
    /// This is always `sql#demoteContext`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Required. The name of the instance which acts as the on-premises primary
    /// instance in the replication setup.
    #[prost(string, tag = "2")]
    pub source_representative_instance_name: ::prost::alloc::string::String,
}
/// Database instance failover context.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailoverContext {
    /// The current settings version of this instance. Request will be rejected if
    /// this version doesn't match the current settings version.
    #[prost(int64, tag = "1")]
    pub settings_version: i64,
    /// This is always `sql#failoverContext`.
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
}
/// Database instance restore from backup context.
/// Backup context contains source instance id and project id.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreBackupContext {
    /// This is always `sql#restoreBackupContext`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The ID of the backup run to restore from.
    #[prost(int64, tag = "2")]
    pub backup_run_id: i64,
    /// The ID of the instance that the backup was taken from.
    #[prost(string, tag = "3")]
    pub instance_id: ::prost::alloc::string::String,
    /// The full project ID of the source instance.
    #[prost(string, tag = "4")]
    pub project: ::prost::alloc::string::String,
}
/// Instance rotate server CA context.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RotateServerCaContext {
    /// This is always `sql#rotateServerCaContext`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The fingerprint of the next version to be rotated to. If left unspecified,
    /// will be rotated to the most recently added server CA version.
    #[prost(string, tag = "2")]
    pub next_version: ::prost::alloc::string::String,
}
/// Database Instance truncate log context.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TruncateLogContext {
    /// This is always `sql#truncateLogContext`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The type of log to truncate. Valid values are `MYSQL_GENERAL_TABLE` and
    /// `MYSQL_SLOW_TABLE`.
    #[prost(string, tag = "2")]
    pub log_type: ::prost::alloc::string::String,
}
/// External primary instance migration setting error/warning.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlExternalSyncSettingError {
    /// Can be `sql#externalSyncSettingError` or
    /// `sql#externalSyncSettingWarning`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Identifies the specific error that occurred.
    #[prost(
        enumeration = "sql_external_sync_setting_error::SqlExternalSyncSettingErrorType",
        tag = "2"
    )]
    pub r#type: i32,
    /// Additional information about the error encountered.
    #[prost(string, tag = "3")]
    pub detail: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SqlExternalSyncSettingError`.
pub mod sql_external_sync_setting_error {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlExternalSyncSettingErrorType {
        Unspecified = 0,
        ConnectionFailure = 1,
        BinlogNotEnabled = 2,
        IncompatibleDatabaseVersion = 3,
        ReplicaAlreadySetup = 4,
        /// The replication user is missing privileges that are required.
        InsufficientPrivilege = 5,
        /// Unsupported migration type.
        UnsupportedMigrationType = 6,
        /// No pglogical extension installed on databases, applicable for postgres.
        NoPglogicalInstalled = 7,
        /// pglogical node already exists on databases, applicable for postgres.
        PglogicalNodeAlreadyExists = 8,
        /// The value of parameter wal_level is not set to logical.
        InvalidWalLevel = 9,
        /// The value of parameter shared_preload_libraries does not include
        /// pglogical.
        InvalidSharedPreloadLibrary = 10,
        /// The value of parameter max_replication_slots is not sufficient.
        InsufficientMaxReplicationSlots = 11,
        /// The value of parameter max_wal_senders is not sufficient.
        InsufficientMaxWalSenders = 12,
        /// The value of parameter max_worker_processes is not sufficient.
        InsufficientMaxWorkerProcesses = 13,
        /// Extensions installed are either not supported or having unsupported
        /// versions.
        UnsupportedExtensions = 14,
        /// The value of parameter rds.logical_replication is not set to 1.
        InvalidRdsLogicalReplication = 15,
        /// The primary instance logging setup doesn't allow EM sync.
        InvalidLoggingSetup = 16,
        /// The primary instance database parameter setup doesn't allow EM sync.
        InvalidDbParam = 17,
        /// The gtid_mode is not supported, applicable for MySQL.
        UnsupportedGtidMode = 18,
        /// SQL Server Agent is not running.
        SqlserverAgentNotRunning = 19,
        /// The table definition is not support due to missing primary key or replica
        /// identity, applicable for postgres.
        UnsupportedTableDefinition = 20,
        /// The customer has a definer that will break EM setup.
        UnsupportedDefiner = 21,
        /// SQL Server @@SERVERNAME does not match actual host name.
        SqlserverServernameMismatch = 22,
        /// The primary instance has been setup and will fail the setup.
        PrimaryAlreadySetup = 23,
        /// The primary instance has unsupported binary log format.
        UnsupportedBinlogFormat = 24,
        /// The primary instance's binary log retention setting.
        BinlogRetentionSetting = 25,
        /// The primary instance has tables with unsupported storage engine.
        UnsupportedStorageEngine = 26,
        /// Source has tables with limited support
        /// eg: PostgreSQL tables without primary keys.
        LimitedSupportTables = 27,
        /// The replica instance contains existing data.
        ExistingDataInReplica = 28,
        /// The replication user is missing privileges that are optional.
        MissingOptionalPrivileges = 29,
        /// Additional BACKUP_ADMIN privilege is granted to the replication user
        /// which may lock source MySQL 8 instance for DDLs during initial sync.
        RiskyBackupAdminPrivilege = 30,
        /// The Cloud Storage bucket is missing necessary permissions.
        InsufficientGcsPermissions = 31,
        /// The Cloud Storage bucket has an error in the file or contains invalid
        /// file information.
        InvalidFileInfo = 32,
        /// The source instance has unsupported database settings for migration.
        UnsupportedDatabaseSettings = 33,
        /// The replication user is missing parallel import specific privileges.
        /// (e.g. LOCK TABLES) for MySQL.
        MysqlParallelImportInsufficientPrivilege = 34,
        /// The global variable local_infile is off on external server replica.
        LocalInfileOff = 35,
        /// This code instructs customers to turn on point-in-time recovery manually
        /// for the instance after promoting the Cloud SQL for PostgreSQL instance.
        TurnOnPitrAfterPromote = 36,
        /// The minor version of replica database is incompatible with the source.
        IncompatibleDatabaseMinorVersion = 37,
        /// This warning message indicates that Cloud SQL uses the maximum number of
        /// subscriptions to migrate data from the source to the destination.
        SourceMaxSubscriptions = 38,
        /// Unable to verify definers on the source for MySQL.
        UnableToVerifyDefiners = 39,
        /// If a time out occurs while the subscription counts are calculated, then
        /// this value is set to 1. Otherwise, this value is set to 2.
        SubscriptionCalculationStatus = 40,
        /// Count of subscriptions needed to sync source data for PostgreSQL
        /// database.
        PgSubscriptionCount = 41,
        /// Final parallel level that is used to do migration.
        PgSyncParallelLevel = 42,
        /// The disk size of the replica instance is smaller than the data size of
        /// the source instance.
        InsufficientDiskSize = 43,
        /// The data size of the source instance is greater than 1 TB, the number of
        /// cores of the replica instance is less than 8, and the memory of the
        /// replica is less than 32 GB.
        InsufficientMachineTier = 44,
        /// The warning message indicates the unsupported extensions will not be
        /// migrated to the destination.
        UnsupportedExtensionsNotMigrated = 45,
        /// The warning message indicates the pg_cron extension and settings will not
        /// be migrated to the destination.
        ExtensionsNotMigrated = 46,
        /// The error message indicates that pg_cron flags are enabled on the
        /// destination which is not supported during the migration.
        PgCronFlagEnabledInReplica = 47,
        /// This error message indicates that the specified extensions are not
        /// enabled on destination instance. For example, before you can migrate
        /// data to the destination instance, you must enable the PGAudit extension
        /// on the instance.
        ExtensionsNotEnabledInReplica = 48,
        /// The source database has generated columns that can't be migrated. Please
        /// change them to regular columns before migration.
        UnsupportedColumns = 49,
    }
    impl SqlExternalSyncSettingErrorType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SQL_EXTERNAL_SYNC_SETTING_ERROR_TYPE_UNSPECIFIED",
                Self::ConnectionFailure => "CONNECTION_FAILURE",
                Self::BinlogNotEnabled => "BINLOG_NOT_ENABLED",
                Self::IncompatibleDatabaseVersion => "INCOMPATIBLE_DATABASE_VERSION",
                Self::ReplicaAlreadySetup => "REPLICA_ALREADY_SETUP",
                Self::InsufficientPrivilege => "INSUFFICIENT_PRIVILEGE",
                Self::UnsupportedMigrationType => "UNSUPPORTED_MIGRATION_TYPE",
                Self::NoPglogicalInstalled => "NO_PGLOGICAL_INSTALLED",
                Self::PglogicalNodeAlreadyExists => "PGLOGICAL_NODE_ALREADY_EXISTS",
                Self::InvalidWalLevel => "INVALID_WAL_LEVEL",
                Self::InvalidSharedPreloadLibrary => "INVALID_SHARED_PRELOAD_LIBRARY",
                Self::InsufficientMaxReplicationSlots => {
                    "INSUFFICIENT_MAX_REPLICATION_SLOTS"
                }
                Self::InsufficientMaxWalSenders => "INSUFFICIENT_MAX_WAL_SENDERS",
                Self::InsufficientMaxWorkerProcesses => {
                    "INSUFFICIENT_MAX_WORKER_PROCESSES"
                }
                Self::UnsupportedExtensions => "UNSUPPORTED_EXTENSIONS",
                Self::InvalidRdsLogicalReplication => "INVALID_RDS_LOGICAL_REPLICATION",
                Self::InvalidLoggingSetup => "INVALID_LOGGING_SETUP",
                Self::InvalidDbParam => "INVALID_DB_PARAM",
                Self::UnsupportedGtidMode => "UNSUPPORTED_GTID_MODE",
                Self::SqlserverAgentNotRunning => "SQLSERVER_AGENT_NOT_RUNNING",
                Self::UnsupportedTableDefinition => "UNSUPPORTED_TABLE_DEFINITION",
                Self::UnsupportedDefiner => "UNSUPPORTED_DEFINER",
                Self::SqlserverServernameMismatch => "SQLSERVER_SERVERNAME_MISMATCH",
                Self::PrimaryAlreadySetup => "PRIMARY_ALREADY_SETUP",
                Self::UnsupportedBinlogFormat => "UNSUPPORTED_BINLOG_FORMAT",
                Self::BinlogRetentionSetting => "BINLOG_RETENTION_SETTING",
                Self::UnsupportedStorageEngine => "UNSUPPORTED_STORAGE_ENGINE",
                Self::LimitedSupportTables => "LIMITED_SUPPORT_TABLES",
                Self::ExistingDataInReplica => "EXISTING_DATA_IN_REPLICA",
                Self::MissingOptionalPrivileges => "MISSING_OPTIONAL_PRIVILEGES",
                Self::RiskyBackupAdminPrivilege => "RISKY_BACKUP_ADMIN_PRIVILEGE",
                Self::InsufficientGcsPermissions => "INSUFFICIENT_GCS_PERMISSIONS",
                Self::InvalidFileInfo => "INVALID_FILE_INFO",
                Self::UnsupportedDatabaseSettings => "UNSUPPORTED_DATABASE_SETTINGS",
                Self::MysqlParallelImportInsufficientPrivilege => {
                    "MYSQL_PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE"
                }
                Self::LocalInfileOff => "LOCAL_INFILE_OFF",
                Self::TurnOnPitrAfterPromote => "TURN_ON_PITR_AFTER_PROMOTE",
                Self::IncompatibleDatabaseMinorVersion => {
                    "INCOMPATIBLE_DATABASE_MINOR_VERSION"
                }
                Self::SourceMaxSubscriptions => "SOURCE_MAX_SUBSCRIPTIONS",
                Self::UnableToVerifyDefiners => "UNABLE_TO_VERIFY_DEFINERS",
                Self::SubscriptionCalculationStatus => "SUBSCRIPTION_CALCULATION_STATUS",
                Self::PgSubscriptionCount => "PG_SUBSCRIPTION_COUNT",
                Self::PgSyncParallelLevel => "PG_SYNC_PARALLEL_LEVEL",
                Self::InsufficientDiskSize => "INSUFFICIENT_DISK_SIZE",
                Self::InsufficientMachineTier => "INSUFFICIENT_MACHINE_TIER",
                Self::UnsupportedExtensionsNotMigrated => {
                    "UNSUPPORTED_EXTENSIONS_NOT_MIGRATED"
                }
                Self::ExtensionsNotMigrated => "EXTENSIONS_NOT_MIGRATED",
                Self::PgCronFlagEnabledInReplica => "PG_CRON_FLAG_ENABLED_IN_REPLICA",
                Self::ExtensionsNotEnabledInReplica => {
                    "EXTENSIONS_NOT_ENABLED_IN_REPLICA"
                }
                Self::UnsupportedColumns => "UNSUPPORTED_COLUMNS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_EXTERNAL_SYNC_SETTING_ERROR_TYPE_UNSPECIFIED" => {
                    Some(Self::Unspecified)
                }
                "CONNECTION_FAILURE" => Some(Self::ConnectionFailure),
                "BINLOG_NOT_ENABLED" => Some(Self::BinlogNotEnabled),
                "INCOMPATIBLE_DATABASE_VERSION" => {
                    Some(Self::IncompatibleDatabaseVersion)
                }
                "REPLICA_ALREADY_SETUP" => Some(Self::ReplicaAlreadySetup),
                "INSUFFICIENT_PRIVILEGE" => Some(Self::InsufficientPrivilege),
                "UNSUPPORTED_MIGRATION_TYPE" => Some(Self::UnsupportedMigrationType),
                "NO_PGLOGICAL_INSTALLED" => Some(Self::NoPglogicalInstalled),
                "PGLOGICAL_NODE_ALREADY_EXISTS" => Some(Self::PglogicalNodeAlreadyExists),
                "INVALID_WAL_LEVEL" => Some(Self::InvalidWalLevel),
                "INVALID_SHARED_PRELOAD_LIBRARY" => {
                    Some(Self::InvalidSharedPreloadLibrary)
                }
                "INSUFFICIENT_MAX_REPLICATION_SLOTS" => {
                    Some(Self::InsufficientMaxReplicationSlots)
                }
                "INSUFFICIENT_MAX_WAL_SENDERS" => Some(Self::InsufficientMaxWalSenders),
                "INSUFFICIENT_MAX_WORKER_PROCESSES" => {
                    Some(Self::InsufficientMaxWorkerProcesses)
                }
                "UNSUPPORTED_EXTENSIONS" => Some(Self::UnsupportedExtensions),
                "INVALID_RDS_LOGICAL_REPLICATION" => {
                    Some(Self::InvalidRdsLogicalReplication)
                }
                "INVALID_LOGGING_SETUP" => Some(Self::InvalidLoggingSetup),
                "INVALID_DB_PARAM" => Some(Self::InvalidDbParam),
                "UNSUPPORTED_GTID_MODE" => Some(Self::UnsupportedGtidMode),
                "SQLSERVER_AGENT_NOT_RUNNING" => Some(Self::SqlserverAgentNotRunning),
                "UNSUPPORTED_TABLE_DEFINITION" => Some(Self::UnsupportedTableDefinition),
                "UNSUPPORTED_DEFINER" => Some(Self::UnsupportedDefiner),
                "SQLSERVER_SERVERNAME_MISMATCH" => {
                    Some(Self::SqlserverServernameMismatch)
                }
                "PRIMARY_ALREADY_SETUP" => Some(Self::PrimaryAlreadySetup),
                "UNSUPPORTED_BINLOG_FORMAT" => Some(Self::UnsupportedBinlogFormat),
                "BINLOG_RETENTION_SETTING" => Some(Self::BinlogRetentionSetting),
                "UNSUPPORTED_STORAGE_ENGINE" => Some(Self::UnsupportedStorageEngine),
                "LIMITED_SUPPORT_TABLES" => Some(Self::LimitedSupportTables),
                "EXISTING_DATA_IN_REPLICA" => Some(Self::ExistingDataInReplica),
                "MISSING_OPTIONAL_PRIVILEGES" => Some(Self::MissingOptionalPrivileges),
                "RISKY_BACKUP_ADMIN_PRIVILEGE" => Some(Self::RiskyBackupAdminPrivilege),
                "INSUFFICIENT_GCS_PERMISSIONS" => Some(Self::InsufficientGcsPermissions),
                "INVALID_FILE_INFO" => Some(Self::InvalidFileInfo),
                "UNSUPPORTED_DATABASE_SETTINGS" => {
                    Some(Self::UnsupportedDatabaseSettings)
                }
                "MYSQL_PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE" => {
                    Some(Self::MysqlParallelImportInsufficientPrivilege)
                }
                "LOCAL_INFILE_OFF" => Some(Self::LocalInfileOff),
                "TURN_ON_PITR_AFTER_PROMOTE" => Some(Self::TurnOnPitrAfterPromote),
                "INCOMPATIBLE_DATABASE_MINOR_VERSION" => {
                    Some(Self::IncompatibleDatabaseMinorVersion)
                }
                "SOURCE_MAX_SUBSCRIPTIONS" => Some(Self::SourceMaxSubscriptions),
                "UNABLE_TO_VERIFY_DEFINERS" => Some(Self::UnableToVerifyDefiners),
                "SUBSCRIPTION_CALCULATION_STATUS" => {
                    Some(Self::SubscriptionCalculationStatus)
                }
                "PG_SUBSCRIPTION_COUNT" => Some(Self::PgSubscriptionCount),
                "PG_SYNC_PARALLEL_LEVEL" => Some(Self::PgSyncParallelLevel),
                "INSUFFICIENT_DISK_SIZE" => Some(Self::InsufficientDiskSize),
                "INSUFFICIENT_MACHINE_TIER" => Some(Self::InsufficientMachineTier),
                "UNSUPPORTED_EXTENSIONS_NOT_MIGRATED" => {
                    Some(Self::UnsupportedExtensionsNotMigrated)
                }
                "EXTENSIONS_NOT_MIGRATED" => Some(Self::ExtensionsNotMigrated),
                "PG_CRON_FLAG_ENABLED_IN_REPLICA" => {
                    Some(Self::PgCronFlagEnabledInReplica)
                }
                "EXTENSIONS_NOT_ENABLED_IN_REPLICA" => {
                    Some(Self::ExtensionsNotEnabledInReplica)
                }
                "UNSUPPORTED_COLUMNS" => Some(Self::UnsupportedColumns),
                _ => None,
            }
        }
    }
}
/// On-premises instance configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnPremisesConfiguration {
    /// The host and port of the on-premises instance in host:port format
    #[prost(string, tag = "1")]
    pub host_port: ::prost::alloc::string::String,
    /// This is always `sql#onPremisesConfiguration`.
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
    /// The username for connecting to on-premises instance.
    #[prost(string, tag = "3")]
    pub username: ::prost::alloc::string::String,
    /// The password for connecting to on-premises instance.
    #[prost(string, tag = "4")]
    pub password: ::prost::alloc::string::String,
    /// PEM representation of the trusted CA's x509 certificate.
    #[prost(string, tag = "5")]
    pub ca_certificate: ::prost::alloc::string::String,
    /// PEM representation of the replica's x509 certificate.
    #[prost(string, tag = "6")]
    pub client_certificate: ::prost::alloc::string::String,
    /// PEM representation of the replica's private key. The corresponsing public
    /// key is encoded in the client's certificate.
    #[prost(string, tag = "7")]
    pub client_key: ::prost::alloc::string::String,
    /// The dump file to create the Cloud SQL replica.
    #[prost(string, tag = "8")]
    pub dump_file_path: ::prost::alloc::string::String,
    /// The reference to Cloud SQL instance if the source is Cloud SQL.
    #[prost(message, optional, tag = "15")]
    pub source_instance: ::core::option::Option<InstanceReference>,
}
/// Read-replica configuration for connecting to the primary instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplicaConfiguration {
    /// This is always `sql#replicaConfiguration`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// MySQL specific configuration when replicating from a MySQL on-premises
    /// primary instance. Replication configuration information such as the
    /// username, password, certificates, and keys are not stored in the instance
    /// metadata. The configuration information is used only to set up the
    /// replication connection and is stored by MySQL in a file named
    /// `master.info` in the data directory.
    #[prost(message, optional, tag = "2")]
    pub mysql_replica_configuration: ::core::option::Option<MySqlReplicaConfiguration>,
    /// Specifies if the replica is the failover target. If the field is set to
    /// `true`, the replica will be designated as a failover replica. In case the
    /// primary instance fails, the replica instance will be promoted as the new
    /// primary instance. Only one replica can be specified as failover target, and
    /// the replica has to be in different zone with the primary instance.
    #[prost(message, optional, tag = "3")]
    pub failover_target: ::core::option::Option<bool>,
    /// Optional. Specifies if a SQL Server replica is a cascadable replica. A
    /// cascadable replica is a SQL Server cross region replica that supports
    /// replica(s) under it.
    #[prost(message, optional, tag = "5")]
    pub cascadable_replica: ::core::option::Option<bool>,
}
/// Request to acquire a lease for SSRS.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesAcquireSsrsLeaseRequest {
    /// Required. Cloud SQL instance ID. This doesn't include the project ID. It's
    /// composed of lowercase letters, numbers, and hyphens, and it must start with
    /// a letter. The total length must be 98 characters or less (Example:
    /// instance-id).
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Required. Project ID of the project that contains the instance (Example:
    /// project-id).
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Required. The request body.
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesAcquireSsrsLeaseRequest>,
}
/// Response for the acquire SSRS lease request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesAcquireSsrsLeaseResponse {
    /// The unique identifier for this operation.
    #[prost(string, tag = "1")]
    pub operation_id: ::prost::alloc::string::String,
}
/// Request to release a lease for SSRS.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesReleaseSsrsLeaseRequest {
    /// Required. The Cloud SQL instance ID. This doesn't include the project ID.
    /// The instance ID contains lowercase letters, numbers, and hyphens, and it
    /// must start with a letter. This ID can have a maximum length of 98
    /// characters.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Required. The project ID that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Response for the release SSRS lease request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesReleaseSsrsLeaseResponse {
    /// The unique identifier for this operation.
    #[prost(string, tag = "1")]
    pub operation_id: ::prost::alloc::string::String,
}
/// External Sync parallel level.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExternalSyncParallelLevel {
    /// Unknown sync parallel level. Will be defaulted to OPTIMAL.
    Unspecified = 0,
    /// Minimal parallel level.
    Min = 1,
    /// Optimal parallel level.
    Optimal = 2,
    /// Maximum parallel level.
    Max = 3,
}
impl ExternalSyncParallelLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EXTERNAL_SYNC_PARALLEL_LEVEL_UNSPECIFIED",
            Self::Min => "MIN",
            Self::Optimal => "OPTIMAL",
            Self::Max => "MAX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXTERNAL_SYNC_PARALLEL_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "MIN" => Some(Self::Min),
            "OPTIMAL" => Some(Self::Optimal),
            "MAX" => Some(Self::Max),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlInstanceType {
    /// This is an unknown Cloud SQL instance type.
    Unspecified = 0,
    /// A regular Cloud SQL instance that is not replicating from a primary
    /// instance.
    CloudSqlInstance = 1,
    /// An instance running on the customer's premises that is not managed by
    /// Cloud SQL.
    OnPremisesInstance = 2,
    /// A Cloud SQL instance acting as a read-replica.
    ReadReplicaInstance = 3,
}
impl SqlInstanceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_INSTANCE_TYPE_UNSPECIFIED",
            Self::CloudSqlInstance => "CLOUD_SQL_INSTANCE",
            Self::OnPremisesInstance => "ON_PREMISES_INSTANCE",
            Self::ReadReplicaInstance => "READ_REPLICA_INSTANCE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_INSTANCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CLOUD_SQL_INSTANCE" => Some(Self::CloudSqlInstance),
            "ON_PREMISES_INSTANCE" => Some(Self::OnPremisesInstance),
            "READ_REPLICA_INSTANCE" => Some(Self::ReadReplicaInstance),
            _ => None,
        }
    }
}
/// The suspension reason of the database instance if the state is SUSPENDED.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlSuspensionReason {
    /// This is an unknown suspension reason.
    Unspecified = 0,
    /// The instance is suspended due to billing issues (for example:, GCP account
    /// issue)
    BillingIssue = 2,
    /// The instance is suspended due to illegal content (for example:, child
    /// pornography, copyrighted material, etc.).
    LegalIssue = 3,
    /// The instance is causing operational issues (for example:, causing the
    /// database to crash).
    OperationalIssue = 4,
    /// The KMS key used by the instance is either revoked or denied access to
    KmsKeyIssue = 5,
}
impl SqlSuspensionReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_SUSPENSION_REASON_UNSPECIFIED",
            Self::BillingIssue => "BILLING_ISSUE",
            Self::LegalIssue => "LEGAL_ISSUE",
            Self::OperationalIssue => "OPERATIONAL_ISSUE",
            Self::KmsKeyIssue => "KMS_KEY_ISSUE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_SUSPENSION_REASON_UNSPECIFIED" => Some(Self::Unspecified),
            "BILLING_ISSUE" => Some(Self::BillingIssue),
            "LEGAL_ISSUE" => Some(Self::LegalIssue),
            "OPERATIONAL_ISSUE" => Some(Self::OperationalIssue),
            "KMS_KEY_ISSUE" => Some(Self::KmsKeyIssue),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod sql_instances_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to manage Cloud SQL instances.
    #[derive(Debug, Clone)]
    pub struct SqlInstancesServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlInstancesServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlInstancesServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlInstancesServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlInstancesServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Adds a new trusted Certificate Authority (CA) version for the specified
        /// instance. Required to prepare for a certificate rotation. If a CA version
        /// was previously added but never used in a certificate rotation, this
        /// operation replaces that version. There cannot be more than one CA version
        /// waiting to be rotated in. For instances that have enabled Certificate
        /// Authority Service (CAS) based server CA, please use AddServerCertificate to
        /// add a new server certificate.
        pub async fn add_server_ca(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesAddServerCaRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/AddServerCa",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "AddServerCa",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a Cloud SQL instance as a clone of the source instance. Using this
        /// operation might cause your instance to restart.
        pub async fn clone(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesCloneRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/Clone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlInstancesService", "Clone"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Cloud SQL instance.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesDeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlInstancesService", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Demotes the stand-alone instance to be a Cloud SQL read replica for an
        /// external database server.
        pub async fn demote_master(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesDemoteMasterRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/DemoteMaster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "DemoteMaster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Demotes an existing standalone instance to be a Cloud SQL read replica
        /// for an external database server.
        pub async fn demote(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesDemoteRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/Demote",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlInstancesService", "Demote"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Exports data from a Cloud SQL instance to a Cloud Storage bucket as a SQL
        /// dump or CSV file.
        pub async fn export(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesExportRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/Export",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlInstancesService", "Export"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Initiates a manual failover of a high availability (HA) primary instance
        /// to a standby instance, which becomes the primary instance. Users are
        /// then rerouted to the new primary. For more information, see the
        /// [Overview of high
        /// availability](https://cloud.google.com/sql/docs/mysql/high-availability)
        /// page in the Cloud SQL documentation.
        /// If using Legacy HA (MySQL only), this causes the instance to failover to
        /// its failover replica instance.
        pub async fn failover(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesFailoverRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/Failover",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "Failover",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Reencrypt CMEK instance with latest key version.
        pub async fn reencrypt(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesReencryptRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/Reencrypt",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "Reencrypt",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a resource containing information about a Cloud SQL instance.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesGetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DatabaseInstance>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlInstancesService", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Imports data into a Cloud SQL instance from a SQL dump  or CSV file in
        /// Cloud Storage.
        pub async fn import(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesImportRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/Import",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlInstancesService", "Import"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Cloud SQL instance.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesInsertRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlInstancesService", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists instances under a given project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstancesListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlInstancesService", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all of the trusted Certificate Authorities (CAs) for the specified
        /// instance. There can be up to three CAs listed: the CA that was used to sign
        /// the certificate that is currently in use, a CA that has been added but not
        /// yet used to sign a certificate, and a CA used to sign a certificate that
        /// has previously rotated out.
        pub async fn list_server_cas(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesListServerCasRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstancesListServerCasResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/ListServerCas",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "ListServerCas",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Partially updates settings of a Cloud SQL instance by merging the request
        /// with the current configuration. This method supports patch semantics.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesPatchRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlInstancesService", "Patch"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Promotes the read replica instance to be an independent Cloud SQL
        /// primary instance.
        /// Using this operation might cause your instance to restart.
        pub async fn promote_replica(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesPromoteReplicaRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/PromoteReplica",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "PromoteReplica",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Switches over from the primary instance to the designated DR replica
        /// instance.
        pub async fn switchover(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesSwitchoverRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/Switchover",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "Switchover",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes all client certificates and generates a new server SSL certificate
        /// for the instance.
        pub async fn reset_ssl_config(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesResetSslConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/ResetSslConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "ResetSslConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Restarts a Cloud SQL instance.
        pub async fn restart(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesRestartRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/Restart",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlInstancesService", "Restart"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Restores a backup of a Cloud SQL instance. Using this operation might cause
        /// your instance to restart.
        pub async fn restore_backup(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesRestoreBackupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/RestoreBackup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "RestoreBackup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Rotates the server certificate to one signed by the Certificate Authority
        /// (CA) version previously added with the addServerCA method. For instances
        /// that have enabled Certificate Authority Service (CAS) based server CA,
        /// please use RotateServerCertificate to rotate the server certificate.
        pub async fn rotate_server_ca(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesRotateServerCaRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/RotateServerCa",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "RotateServerCa",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Starts the replication in the read replica instance.
        pub async fn start_replica(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesStartReplicaRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/StartReplica",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "StartReplica",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Stops the replication in the read replica instance.
        pub async fn stop_replica(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesStopReplicaRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/StopReplica",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "StopReplica",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Truncate MySQL general and slow query log tables
        /// MySQL only.
        pub async fn truncate_log(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesTruncateLogRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/TruncateLog",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "TruncateLog",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates settings of a Cloud SQL instance. Using this operation might cause
        /// your instance to restart.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesUpdateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlInstancesService", "Update"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generates a short-lived X509 certificate containing the provided public key
        /// and signed by a private key specific to the target instance. Users may use
        /// the certificate to authenticate as themselves when connecting to the
        /// database.
        pub async fn create_ephemeral(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesCreateEphemeralCertRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::SslCert>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/CreateEphemeral",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "CreateEphemeral",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Reschedules the maintenance on the given instance.
        pub async fn reschedule_maintenance(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesRescheduleMaintenanceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/RescheduleMaintenance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "RescheduleMaintenance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Verify External primary instance external sync settings.
        pub async fn verify_external_sync_settings(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesVerifyExternalSyncSettingsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SqlInstancesVerifyExternalSyncSettingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/VerifyExternalSyncSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "VerifyExternalSyncSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Start External primary instance migration.
        pub async fn start_external_sync(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesStartExternalSyncRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/StartExternalSync",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "StartExternalSync",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Perform Disk Shrink on primary instance.
        pub async fn perform_disk_shrink(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesPerformDiskShrinkRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/PerformDiskShrink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "PerformDiskShrink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get Disk Shrink Config for a given instance.
        pub async fn get_disk_shrink_config(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesGetDiskShrinkConfigRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SqlInstancesGetDiskShrinkConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/GetDiskShrinkConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "GetDiskShrinkConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Reset Replica Size to primary instance disk size.
        pub async fn reset_replica_size(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesResetReplicaSizeRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/ResetReplicaSize",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "ResetReplicaSize",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get Latest Recovery Time for a given instance.
        pub async fn get_latest_recovery_time(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesGetLatestRecoveryTimeRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SqlInstancesGetLatestRecoveryTimeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/GetLatestRecoveryTime",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "GetLatestRecoveryTime",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Acquire a lease for the setup of SQL Server Reporting Services (SSRS).
        pub async fn acquire_ssrs_lease(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesAcquireSsrsLeaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SqlInstancesAcquireSsrsLeaseResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/AcquireSsrsLease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "AcquireSsrsLease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Release a lease for the setup of SQL Server Reporting Services (SSRS).
        pub async fn release_ssrs_lease(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesReleaseSsrsLeaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SqlInstancesReleaseSsrsLeaseResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlInstancesService/ReleaseSsrsLease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1.SqlInstancesService",
                        "ReleaseSsrsLease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Operations get request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlOperationsGetRequest {
    /// Instance operation ID.
    #[prost(string, tag = "1")]
    pub operation: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Operations list request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlOperationsListRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Maximum number of operations per response.
    #[prost(uint32, tag = "2")]
    pub max_results: u32,
    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "4")]
    pub project: ::prost::alloc::string::String,
}
/// Operations list response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationsListResponse {
    /// This is always `sql#operationsList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// List of operation resources.
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<Operation>,
    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Operations cancel request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlOperationsCancelRequest {
    /// Instance operation ID.
    #[prost(string, tag = "1")]
    pub operation: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod sql_operations_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to fetch operations for database instances.
    #[derive(Debug, Clone)]
    pub struct SqlOperationsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlOperationsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlOperationsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlOperationsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlOperationsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an instance operation that has been performed on an instance.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlOperationsGetRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlOperationsService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlOperationsService", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all instance operations that have been performed on the given Cloud
        /// SQL instance in the reverse chronological order of the start time.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlOperationsListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OperationsListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlOperationsService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlOperationsService", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Cancels an instance operation that has been performed on an instance.
        pub async fn cancel(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlOperationsCancelRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlOperationsService/Cancel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlOperationsService", "Cancel"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod sql_regions_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service that exposes Cloud SQL region information. This service is only used
    /// internally and does not follow the same patterns as the other v1 RPCs.
    #[derive(Debug, Clone)]
    pub struct SqlRegionsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlRegionsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlRegionsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlRegionsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlRegionsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlSslCertsDeleteRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Sha1 FingerPrint.
    #[prost(string, tag = "3")]
    pub sha1_fingerprint: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlSslCertsGetRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Sha1 FingerPrint.
    #[prost(string, tag = "3")]
    pub sha1_fingerprint: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlSslCertsInsertRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<SslCertsInsertRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlSslCertsListRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// SslCerts insert request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslCertsInsertRequest {
    /// User supplied name.  Must be a distinct name from the other certificates
    /// for this instance.
    #[prost(string, tag = "1")]
    pub common_name: ::prost::alloc::string::String,
}
/// SslCert insert response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslCertsInsertResponse {
    /// This is always `sql#sslCertsInsert`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The operation to track the ssl certs insert request.
    #[prost(message, optional, tag = "2")]
    pub operation: ::core::option::Option<Operation>,
    /// The server Certificate Authority's certificate.  If this is missing you can
    /// force a new one to be generated by calling resetSslConfig method on
    /// instances resource.
    #[prost(message, optional, tag = "3")]
    pub server_ca_cert: ::core::option::Option<SslCert>,
    /// The new client certificate and private key.
    #[prost(message, optional, tag = "4")]
    pub client_cert: ::core::option::Option<SslCertDetail>,
}
/// SslCerts list response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslCertsListResponse {
    /// This is always `sql#sslCertsList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// List of client certificates for the instance.
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<SslCert>,
}
/// Generated client implementations.
pub mod sql_ssl_certs_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to manage SSL certs for Cloud SQL instances.
    #[derive(Debug, Clone)]
    pub struct SqlSslCertsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlSslCertsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlSslCertsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlSslCertsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlSslCertsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the SSL certificate. For First Generation instances, the
        /// certificate remains valid until the instance is restarted.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlSslCertsDeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlSslCertsService/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlSslCertsService", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a particular SSL certificate.  Does not include the private key
        /// (required for usage).  The private key must be saved from the response to
        /// initial creation.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlSslCertsGetRequest>,
        ) -> std::result::Result<tonic::Response<super::SslCert>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlSslCertsService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlSslCertsService", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an SSL certificate and returns it along with the private key and
        /// server certificate authority.  The new certificate will not be usable until
        /// the instance is restarted.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlSslCertsInsertRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SslCertsInsertResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlSslCertsService/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlSslCertsService", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all of the current SSL certificates for the instance.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlSslCertsListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SslCertsListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlSslCertsService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlSslCertsService", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Tiers list request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlTiersListRequest {
    /// Project ID of the project for which to list tiers.
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
}
/// Tiers list response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TiersListResponse {
    /// This is always `sql#tiersList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// List of tiers.
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<Tier>,
}
/// A Google Cloud SQL service tier resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tier {
    /// An identifier for the machine type, for example, `db-custom-1-3840`. For
    /// related information, see [Pricing](/sql/pricing).
    #[prost(string, tag = "1")]
    pub tier: ::prost::alloc::string::String,
    /// The maximum RAM usage of this tier in bytes.
    #[prost(int64, tag = "2")]
    pub ram: i64,
    /// This is always `sql#tier`.
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
    /// The maximum disk size of this tier in bytes.
    #[prost(int64, tag = "4")]
    pub disk_quota: i64,
    /// The applicable regions for this tier.
    #[prost(string, repeated, tag = "5")]
    pub region: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Generated client implementations.
pub mod sql_tiers_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for providing machine types (tiers) for Cloud SQL instances.
    #[derive(Debug, Clone)]
    pub struct SqlTiersServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlTiersServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlTiersServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlTiersServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlTiersServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists all available machine types (tiers) for Cloud SQL, for example,
        /// `db-custom-1-3840`. For more information, see
        /// https://cloud.google.com/sql/pricing.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlTiersListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TiersListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlTiersService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.sql.v1.SqlTiersService", "List"));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlUsersDeleteRequest {
    /// Host of the user in the instance.
    #[prost(string, tag = "1")]
    pub host: ::prost::alloc::string::String,
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "2")]
    pub instance: ::prost::alloc::string::String,
    /// Name of the user in the instance.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "4")]
    pub project: ::prost::alloc::string::String,
}
/// Request message for Users Get RPC
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlUsersGetRequest {
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// User of the instance.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "3")]
    pub project: ::prost::alloc::string::String,
    /// Host of a user of the instance.
    #[prost(string, tag = "4")]
    pub host: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlUsersInsertRequest {
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<User>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlUsersListRequest {
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlUsersUpdateRequest {
    /// Optional. Host of the user in the instance.
    #[prost(string, tag = "1")]
    pub host: ::prost::alloc::string::String,
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "2")]
    pub instance: ::prost::alloc::string::String,
    /// Name of the user in the instance.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "4")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<User>,
}
/// User level password validation policy.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserPasswordValidationPolicy {
    /// Number of failed login attempts allowed before user get locked.
    #[prost(int32, tag = "1")]
    pub allowed_failed_attempts: i32,
    /// Expiration duration after password is updated.
    #[prost(message, optional, tag = "2")]
    pub password_expiration_duration: ::core::option::Option<::prost_types::Duration>,
    /// If true, failed login attempts check will be enabled.
    #[prost(bool, tag = "3")]
    pub enable_failed_attempts_check: bool,
    /// Output only. Read-only password status.
    #[prost(message, optional, tag = "4")]
    pub status: ::core::option::Option<PasswordStatus>,
    /// If true, the user must specify the current password before changing the
    /// password. This flag is supported only for MySQL.
    #[prost(bool, tag = "5")]
    pub enable_password_verification: bool,
}
/// Read-only password status.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PasswordStatus {
    /// If true, user does not have login privileges.
    #[prost(bool, tag = "1")]
    pub locked: bool,
    /// The expiration time of the current password.
    #[prost(message, optional, tag = "2")]
    pub password_expiration_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// A Cloud SQL user resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    /// This is always `sql#user`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The password for the user.
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
    /// This field is deprecated and will be removed from a future version of the
    /// API.
    #[prost(string, tag = "3")]
    pub etag: ::prost::alloc::string::String,
    /// The name of the user in the Cloud SQL instance. Can be omitted for
    /// `update` because it is already specified in the URL.
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The host from which the user can connect. For `insert`
    /// operations, host defaults to an empty string. For `update`
    /// operations, host is specified as part of the request URL. The host name
    /// cannot be updated after insertion.  For a MySQL instance, it's required;
    /// for a PostgreSQL or SQL Server instance, it's optional.
    #[prost(string, tag = "5")]
    pub host: ::prost::alloc::string::String,
    /// The name of the Cloud SQL instance. This does not include the project ID.
    /// Can be omitted for `update` because it is already specified on the
    /// URL.
    #[prost(string, tag = "6")]
    pub instance: ::prost::alloc::string::String,
    /// The project ID of the project containing the Cloud SQL database. The Google
    /// apps domain is prefixed if applicable. Can be omitted for `update` because
    /// it is already specified on the URL.
    #[prost(string, tag = "7")]
    pub project: ::prost::alloc::string::String,
    /// The user type. It determines the method to authenticate the user during
    /// login. The default is the database's built-in user type.
    #[prost(enumeration = "user::SqlUserType", tag = "8")]
    pub r#type: i32,
    /// User level password validation policy.
    #[prost(message, optional, tag = "12")]
    pub password_policy: ::core::option::Option<UserPasswordValidationPolicy>,
    /// Dual password status for the user.
    #[prost(enumeration = "user::DualPasswordType", optional, tag = "13")]
    pub dual_password_type: ::core::option::Option<i32>,
    /// User details for specific database type
    #[prost(oneof = "user::UserDetails", tags = "9")]
    pub user_details: ::core::option::Option<user::UserDetails>,
}
/// Nested message and enum types in `User`.
pub mod user {
    /// The user type.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlUserType {
        /// The database's built-in user type.
        BuiltIn = 0,
        /// Cloud IAM user.
        CloudIamUser = 1,
        /// Cloud IAM service account.
        CloudIamServiceAccount = 2,
        /// Cloud IAM group non-login user.
        CloudIamGroup = 3,
        /// Cloud IAM group login user.
        CloudIamGroupUser = 4,
        /// Cloud IAM group login service account.
        CloudIamGroupServiceAccount = 5,
    }
    impl SqlUserType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::BuiltIn => "BUILT_IN",
                Self::CloudIamUser => "CLOUD_IAM_USER",
                Self::CloudIamServiceAccount => "CLOUD_IAM_SERVICE_ACCOUNT",
                Self::CloudIamGroup => "CLOUD_IAM_GROUP",
                Self::CloudIamGroupUser => "CLOUD_IAM_GROUP_USER",
                Self::CloudIamGroupServiceAccount => "CLOUD_IAM_GROUP_SERVICE_ACCOUNT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BUILT_IN" => Some(Self::BuiltIn),
                "CLOUD_IAM_USER" => Some(Self::CloudIamUser),
                "CLOUD_IAM_SERVICE_ACCOUNT" => Some(Self::CloudIamServiceAccount),
                "CLOUD_IAM_GROUP" => Some(Self::CloudIamGroup),
                "CLOUD_IAM_GROUP_USER" => Some(Self::CloudIamGroupUser),
                "CLOUD_IAM_GROUP_SERVICE_ACCOUNT" => {
                    Some(Self::CloudIamGroupServiceAccount)
                }
                _ => None,
            }
        }
    }
    /// The type of retained password.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DualPasswordType {
        /// The default value.
        Unspecified = 0,
        /// Do not update the user's dual password status.
        NoModifyDualPassword = 1,
        /// No dual password usable for connecting using this user.
        NoDualPassword = 2,
        /// Dual password usable for connecting using this user.
        DualPassword = 3,
    }
    impl DualPasswordType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DUAL_PASSWORD_TYPE_UNSPECIFIED",
                Self::NoModifyDualPassword => "NO_MODIFY_DUAL_PASSWORD",
                Self::NoDualPassword => "NO_DUAL_PASSWORD",
                Self::DualPassword => "DUAL_PASSWORD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DUAL_PASSWORD_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NO_MODIFY_DUAL_PASSWORD" => Some(Self::NoModifyDualPassword),
                "NO_DUAL_PASSWORD" => Some(Self::NoDualPassword),
                "DUAL_PASSWORD" => Some(Self::DualPassword),
                _ => None,
            }
        }
    }
    /// User details for specific database type
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum UserDetails {
        #[prost(message, tag = "9")]
        SqlserverUserDetails(super::SqlServerUserDetails),
    }
}
/// Represents a Sql Server user on the Cloud SQL instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlServerUserDetails {
    /// If the user has been disabled
    #[prost(bool, tag = "1")]
    pub disabled: bool,
    /// The server roles for this user
    #[prost(string, repeated, tag = "2")]
    pub server_roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// User list response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsersListResponse {
    /// This is always `sql#usersList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// List of user resources in the instance.
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<User>,
    /// Unused.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod sql_users_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Cloud SQL users service.
    #[derive(Debug, Clone)]
    pub struct SqlUsersServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlUsersServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlUsersServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlUsersServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlUsersServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes a user from a Cloud SQL instance.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlUsersDeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlUsersService/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlUsersService", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a resource containing information about a user.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlUsersGetRequest>,
        ) -> std::result::Result<tonic::Response<super::User>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlUsersService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.sql.v1.SqlUsersService", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new user in a Cloud SQL instance.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlUsersInsertRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlUsersService/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlUsersService", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists users in the specified Cloud SQL instance.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlUsersListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UsersListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlUsersService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.sql.v1.SqlUsersService", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Updates an existing user in a Cloud SQL instance.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlUsersUpdateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1.SqlUsersService/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1.SqlUsersService", "Update"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
