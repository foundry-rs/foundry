// This file is @generated by prost-build.
/// An API resource in the API Hub.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Api {
    /// Identifier. The name of the API resource in the API Hub.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The display name of the API resource.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. The description of the API resource.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Optional. The documentation for the API resource.
    #[prost(message, optional, tag = "4")]
    pub documentation: ::core::option::Option<Documentation>,
    /// Optional. Owner details for the API resource.
    #[prost(message, optional, tag = "5")]
    pub owner: ::core::option::Option<Owner>,
    /// Output only. The list of versions present in an API resource.
    /// Note: An API resource can be associated with more than 1 version.
    /// Format is
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    #[prost(string, repeated, tag = "6")]
    pub versions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The time at which the API resource was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time at which the API resource was last updated.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The target users for the API.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-target-user`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    #[prost(message, optional, tag = "9")]
    pub target_user: ::core::option::Option<AttributeValues>,
    /// Optional. The team owning the API.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-team`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    #[prost(message, optional, tag = "10")]
    pub team: ::core::option::Option<AttributeValues>,
    /// Optional. The business unit owning the API.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-business-unit`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    #[prost(message, optional, tag = "11")]
    pub business_unit: ::core::option::Option<AttributeValues>,
    /// Optional. The maturity level of the API.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-maturity-level`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    #[prost(message, optional, tag = "12")]
    pub maturity_level: ::core::option::Option<AttributeValues>,
    /// Optional. The list of user defined attributes associated with the API
    /// resource. The key is the attribute name. It will be of the format:
    /// `projects/{project}/locations/{location}/attributes/{attribute}`.
    /// The value is the attribute values associated with the resource.
    #[prost(map = "string, message", tag = "13")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
    /// Optional. The style of the API.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-api-style`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    #[prost(message, optional, tag = "14")]
    pub api_style: ::core::option::Option<AttributeValues>,
    /// Optional. The selected version for an API resource.
    /// This can be used when special handling is needed on client side for
    /// particular version of the API. Format is
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    #[prost(string, tag = "15")]
    pub selected_version: ::prost::alloc::string::String,
}
/// Represents a version of the API resource in API hub. This is also referred
/// to as the API version.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Version {
    /// Identifier. The name of the version.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The display name of the version.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. The description of the version.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Optional. The documentation of the version.
    #[prost(message, optional, tag = "4")]
    pub documentation: ::core::option::Option<Documentation>,
    /// Output only. The specs associated with this version.
    /// Note that an API version can be associated with multiple specs.
    /// Format is
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    #[prost(string, repeated, tag = "5")]
    pub specs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The operations contained in the API version.
    /// These operations will be added to the version when a new spec is
    /// added or when an existing spec is updated. Format is
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`
    #[prost(string, repeated, tag = "6")]
    pub api_operations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The definitions contained in the API version.
    /// These definitions will be added to the version when a new spec is
    /// added or when an existing spec is updated. Format is
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/definitions/{definition}`
    #[prost(string, repeated, tag = "7")]
    pub definitions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The deployments linked to this API version.
    /// Note: A particular API version could be deployed to multiple deployments
    /// (for dev deployment, UAT deployment, etc)
    /// Format is
    /// `projects/{project}/locations/{location}/deployments/{deployment}`
    #[prost(string, repeated, tag = "8")]
    pub deployments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The time at which the version was created.
    #[prost(message, optional, tag = "9")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time at which the version was last updated.
    #[prost(message, optional, tag = "10")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The lifecycle of the API version.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-lifecycle`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    #[prost(message, optional, tag = "11")]
    pub lifecycle: ::core::option::Option<AttributeValues>,
    /// Optional. The compliance associated with the API version.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-compliance`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    #[prost(message, optional, tag = "12")]
    pub compliance: ::core::option::Option<AttributeValues>,
    /// Optional. The accreditations associated with the API version.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-accreditation`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    #[prost(message, optional, tag = "13")]
    pub accreditation: ::core::option::Option<AttributeValues>,
    /// Optional. The list of user defined attributes associated with the Version
    /// resource. The key is the attribute name. It will be of the format:
    /// `projects/{project}/locations/{location}/attributes/{attribute}`.
    /// The value is the attribute values associated with the resource.
    #[prost(map = "string, message", tag = "14")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
    /// Optional. The selected deployment for a Version resource.
    /// This can be used when special handling is needed on client side for a
    /// particular deployment linked to the version.
    /// Format is
    /// `projects/{project}/locations/{location}/deployments/{deployment}`
    #[prost(string, tag = "16")]
    pub selected_deployment: ::prost::alloc::string::String,
}
/// Represents a spec associated with an API version in the API
/// Hub. Note that specs of various types can be uploaded, however
/// parsing of details is supported for OpenAPI spec currently.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Spec {
    /// Identifier. The name of the spec.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The display name of the spec.
    /// This can contain the file name of the spec.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Required. The type of spec.
    /// The value should be one of the allowed values defined for
    /// `projects/{project}/locations/{location}/attributes/system-spec-type`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API.
    ///
    /// Note, this field is mandatory if content is provided.
    #[prost(message, optional, tag = "3")]
    pub spec_type: ::core::option::Option<AttributeValues>,
    /// Optional. Input only. The contents of the uploaded spec.
    #[prost(message, optional, tag = "4")]
    pub contents: ::core::option::Option<SpecContents>,
    /// Output only. Details parsed from the spec.
    #[prost(message, optional, tag = "5")]
    pub details: ::core::option::Option<SpecDetails>,
    /// Optional. The URI of the spec source in case file is uploaded
    /// from an external version control system.
    #[prost(string, tag = "6")]
    pub source_uri: ::prost::alloc::string::String,
    /// Output only. The time at which the spec was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time at which the spec was last updated.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The lint response for the spec.
    #[prost(message, optional, tag = "9")]
    pub lint_response: ::core::option::Option<LintResponse>,
    /// Optional. The list of user defined attributes associated with the spec.
    /// The key is the attribute name. It will be of the format:
    /// `projects/{project}/locations/{location}/attributes/{attribute}`.
    /// The value is the attribute values associated with the resource.
    #[prost(map = "string, message", tag = "10")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
    /// Optional. The documentation of the spec.
    /// For OpenAPI spec, this will be populated from `externalDocs` in OpenAPI
    /// spec.
    #[prost(message, optional, tag = "11")]
    pub documentation: ::core::option::Option<Documentation>,
    /// Optional. Input only. Enum specifying the parsing mode for OpenAPI
    /// Specification (OAS) parsing.
    #[prost(enumeration = "spec::ParsingMode", tag = "12")]
    pub parsing_mode: i32,
}
/// Nested message and enum types in `Spec`.
pub mod spec {
    /// Specifies the parsing mode for API specifications during creation and
    /// update.
    /// - `RELAXED`: Parsing errors in the specification content do not fail the
    /// API call.
    /// - `STRICT`: Parsing errors in the specification content result in failure
    /// of the API call.
    /// If not specified, defaults to `RELAXED`.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ParsingMode {
        /// Defaults to `RELAXED`.
        Unspecified = 0,
        /// Parsing of the Spec on create and update is relaxed, meaning that
        /// parsing errors the spec contents will not fail the API call.
        Relaxed = 1,
        /// Parsing of the Spec on create and update is strict, meaning that
        /// parsing errors in the spec contents will fail the API call.
        Strict = 2,
    }
    impl ParsingMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PARSING_MODE_UNSPECIFIED",
                Self::Relaxed => "RELAXED",
                Self::Strict => "STRICT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PARSING_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "RELAXED" => Some(Self::Relaxed),
                "STRICT" => Some(Self::Strict),
                _ => None,
            }
        }
    }
}
/// Details of the deployment where APIs are hosted.
/// A deployment could represent an Apigee proxy, API gateway, other Google Cloud
/// services or non-Google Cloud services as well. A deployment entity is a root
/// level entity in the API hub and exists independent of any API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Deployment {
    /// Identifier. The name of the deployment.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/deployments/{deployment}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The display name of the deployment.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. The description of the deployment.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Optional. The documentation of the deployment.
    #[prost(message, optional, tag = "4")]
    pub documentation: ::core::option::Option<Documentation>,
    /// Required. The type of deployment.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-deployment-type`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    #[prost(message, optional, tag = "5")]
    pub deployment_type: ::core::option::Option<AttributeValues>,
    /// Required. A URI to the runtime resource. This URI can be used to manage the
    /// resource. For example, if the runtime resource is of type APIGEE_PROXY,
    /// then this field will contain the URI to the management UI of the proxy.
    #[prost(string, tag = "6")]
    pub resource_uri: ::prost::alloc::string::String,
    /// Required. The endpoints at which this deployment resource is listening for
    /// API requests. This could be a list of complete URIs, hostnames or an IP
    /// addresses.
    #[prost(string, repeated, tag = "7")]
    pub endpoints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The API versions linked to this deployment.
    /// Note: A particular deployment could be linked to multiple different API
    /// versions (of same or different APIs).
    #[prost(string, repeated, tag = "8")]
    pub api_versions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The time at which the deployment was created.
    #[prost(message, optional, tag = "9")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time at which the deployment was last updated.
    #[prost(message, optional, tag = "10")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The SLO for this deployment.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-slo`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    #[prost(message, optional, tag = "11")]
    pub slo: ::core::option::Option<AttributeValues>,
    /// Optional. The environment mapping to this deployment.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-environment`
    /// attribute.
    /// The number of values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    #[prost(message, optional, tag = "12")]
    pub environment: ::core::option::Option<AttributeValues>,
    /// Optional. The list of user defined attributes associated with the
    /// deployment resource. The key is the attribute name. It will be of the
    /// format: `projects/{project}/locations/{location}/attributes/{attribute}`.
    /// The value is the attribute values associated with the resource.
    #[prost(map = "string, message", tag = "13")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
}
/// Represents an operation contained in an API version in the API Hub.
/// An operation is added/updated/deleted in an API version when a new spec is
/// added or an existing spec is updated/deleted in a version.
/// Currently, an operation will be created only corresponding to OpenAPI spec as
/// parsing is supported for OpenAPI spec.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiOperation {
    /// Identifier. The name of the operation.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The name of the spec from where the operation was parsed.
    /// Format is
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    #[prost(string, tag = "2")]
    pub spec: ::prost::alloc::string::String,
    /// Output only. Operation details.
    #[prost(message, optional, tag = "3")]
    pub details: ::core::option::Option<OperationDetails>,
    /// Output only. The time at which the operation was created.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time at which the operation was last updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The list of user defined attributes associated with the API
    /// operation resource. The key is the attribute name. It will be of the
    /// format: `projects/{project}/locations/{location}/attributes/{attribute}`.
    /// The value is the attribute values associated with the resource.
    #[prost(map = "string, message", tag = "6")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
}
/// Represents a definition for example schema, request, response definitions
/// contained in an API version.
/// A definition is added/updated/deleted in an API version when a new spec is
/// added or an existing spec is updated/deleted in a version. Currently,
/// definition will be created only corresponding to OpenAPI spec as parsing is
/// supported for OpenAPI spec. Also, within OpenAPI spec, only `schema` object
/// is supported.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Definition {
    /// Identifier. The name of the definition.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/definitions/{definition}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The name of the spec from where the definition was parsed.
    /// Format is
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    #[prost(string, tag = "2")]
    pub spec: ::prost::alloc::string::String,
    /// Output only. The type of the definition.
    #[prost(enumeration = "definition::Type", tag = "3")]
    pub r#type: i32,
    /// Output only. The time at which the definition was created.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time at which the definition was last updated.
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The list of user defined attributes associated with the
    /// definition resource. The key is the attribute name. It will be of the
    /// format: `projects/{project}/locations/{location}/attributes/{attribute}`.
    /// The value is the attribute values associated with the resource.
    #[prost(map = "string, message", tag = "7")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
    #[prost(oneof = "definition::Value", tags = "4")]
    pub value: ::core::option::Option<definition::Value>,
}
/// Nested message and enum types in `Definition`.
pub mod definition {
    /// Enumeration of definition types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Definition type unspecified.
        Unspecified = 0,
        /// Definition type schema.
        Schema = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Schema => "SCHEMA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SCHEMA" => Some(Self::Schema),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        /// Output only. The value of a schema definition.
        #[prost(message, tag = "4")]
        Schema(super::Schema),
    }
}
/// An attribute in the API Hub.
/// An attribute is a name value pair which can be attached to different
/// resources in the API hub based on the scope of the attribute. Attributes can
/// either be pre-defined by the API Hub or created by users.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Attribute {
    /// Identifier. The name of the attribute in the API Hub.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/attributes/{attribute}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The display name of the attribute.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. The description of the attribute.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The definition type of the attribute.
    #[prost(enumeration = "attribute::DefinitionType", tag = "4")]
    pub definition_type: i32,
    /// Required. The scope of the attribute. It represents the resource in the API
    /// Hub to which the attribute can be linked.
    #[prost(enumeration = "attribute::Scope", tag = "5")]
    pub scope: i32,
    /// Required. The type of the data of the attribute.
    #[prost(enumeration = "attribute::DataType", tag = "6")]
    pub data_type: i32,
    /// Optional. The list of allowed values when the attribute value is of type
    /// enum. This is required when the data_type of the attribute is ENUM. The
    /// maximum number of allowed values of an attribute will be 1000.
    #[prost(message, repeated, tag = "7")]
    pub allowed_values: ::prost::alloc::vec::Vec<attribute::AllowedValue>,
    /// Optional. The maximum number of values that the attribute can have when
    /// associated with an API Hub resource. Cardinality 1 would represent a
    /// single-valued attribute. It must not be less than 1 or greater than 20. If
    /// not specified, the cardinality would be set to 1 by default and represent a
    /// single-valued attribute.
    #[prost(int32, tag = "8")]
    pub cardinality: i32,
    /// Output only. When mandatory is true, the attribute is mandatory for the
    /// resource specified in the scope. Only System defined attributes can be
    /// mandatory.
    #[prost(bool, tag = "9")]
    pub mandatory: bool,
    /// Output only. The time at which the attribute was created.
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time at which the attribute was last updated.
    #[prost(message, optional, tag = "11")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Attribute`.
pub mod attribute {
    /// The value that can be assigned to the attribute when the data type is
    /// enum.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AllowedValue {
        /// Required. The ID of the allowed value.
        /// * If provided, the same will be used. The service will throw an error if
        /// the specified id is already used by another allowed value in the same
        /// attribute resource.
        /// * If not provided, a system generated id derived from the display name
        /// will be used. In this case, the service will handle conflict resolution
        /// by adding a system generated suffix in case of duplicates.
        ///
        /// This value should be 4-63 characters, and valid characters
        /// are /[a-z][0-9]-/.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Required. The display name of the allowed value.
        #[prost(string, tag = "2")]
        pub display_name: ::prost::alloc::string::String,
        /// Optional. The detailed description of the allowed value.
        #[prost(string, tag = "3")]
        pub description: ::prost::alloc::string::String,
        /// Optional. When set to true, the allowed value cannot be updated or
        /// deleted by the user. It can only be true for System defined attributes.
        #[prost(bool, tag = "4")]
        pub immutable: bool,
    }
    /// Enumeration of attribute definition types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DefinitionType {
        /// Attribute definition type unspecified.
        Unspecified = 0,
        /// The attribute is predefined by the API Hub. Note that only the list of
        /// allowed values can be updated in this case via UpdateAttribute method.
        SystemDefined = 1,
        /// The attribute is defined by the user.
        UserDefined = 2,
    }
    impl DefinitionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DEFINITION_TYPE_UNSPECIFIED",
                Self::SystemDefined => "SYSTEM_DEFINED",
                Self::UserDefined => "USER_DEFINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEFINITION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SYSTEM_DEFINED" => Some(Self::SystemDefined),
                "USER_DEFINED" => Some(Self::UserDefined),
                _ => None,
            }
        }
    }
    /// Enumeration for the scope of the attribute representing the resource in the
    /// API Hub to which the attribute can be linked.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Scope {
        /// Scope Unspecified.
        Unspecified = 0,
        /// Attribute can be linked to an API.
        Api = 1,
        /// Attribute can be linked to an API version.
        Version = 2,
        /// Attribute can be linked to a Spec.
        Spec = 3,
        /// Attribute can be linked to an API Operation.
        ApiOperation = 4,
        /// Attribute can be linked to a Deployment.
        Deployment = 5,
        /// Attribute can be linked to a Dependency.
        Dependency = 6,
        /// Attribute can be linked to a definition.
        Definition = 7,
        /// Attribute can be linked to a ExternalAPI.
        ExternalApi = 8,
        /// Attribute can be linked to a Plugin.
        Plugin = 9,
    }
    impl Scope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SCOPE_UNSPECIFIED",
                Self::Api => "API",
                Self::Version => "VERSION",
                Self::Spec => "SPEC",
                Self::ApiOperation => "API_OPERATION",
                Self::Deployment => "DEPLOYMENT",
                Self::Dependency => "DEPENDENCY",
                Self::Definition => "DEFINITION",
                Self::ExternalApi => "EXTERNAL_API",
                Self::Plugin => "PLUGIN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
                "API" => Some(Self::Api),
                "VERSION" => Some(Self::Version),
                "SPEC" => Some(Self::Spec),
                "API_OPERATION" => Some(Self::ApiOperation),
                "DEPLOYMENT" => Some(Self::Deployment),
                "DEPENDENCY" => Some(Self::Dependency),
                "DEFINITION" => Some(Self::Definition),
                "EXTERNAL_API" => Some(Self::ExternalApi),
                "PLUGIN" => Some(Self::Plugin),
                _ => None,
            }
        }
    }
    /// Enumeration of attribute's data type.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataType {
        /// Attribute data type unspecified.
        Unspecified = 0,
        /// Attribute's value is of type enum.
        Enum = 1,
        /// Attribute's value is of type json.
        Json = 2,
        /// Attribute's value is of type string.
        String = 3,
    }
    impl DataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DATA_TYPE_UNSPECIFIED",
                Self::Enum => "ENUM",
                Self::Json => "JSON",
                Self::String => "STRING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENUM" => Some(Self::Enum),
                "JSON" => Some(Self::Json),
                "STRING" => Some(Self::String),
                _ => None,
            }
        }
    }
}
/// The spec contents.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpecContents {
    /// Required. The contents of the spec.
    #[prost(bytes = "vec", tag = "1")]
    pub contents: ::prost::alloc::vec::Vec<u8>,
    /// Required. The mime type of the content for example application/json,
    /// application/yaml, application/wsdl etc.
    #[prost(string, tag = "2")]
    pub mime_type: ::prost::alloc::string::String,
}
/// SpecDetails contains the details parsed from supported
/// spec types.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpecDetails {
    /// Output only. The description of the spec.
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    #[prost(oneof = "spec_details::Details", tags = "2")]
    pub details: ::core::option::Option<spec_details::Details>,
}
/// Nested message and enum types in `SpecDetails`.
pub mod spec_details {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Details {
        /// Output only. Additional details apart from `OperationDetails` parsed from
        /// an OpenAPI spec. The OperationDetails parsed from the spec can be
        /// obtained by using
        /// [ListAPIOperations][google.cloud.apihub.v1.ApiHub.ListApiOperations]
        /// method.
        #[prost(message, tag = "2")]
        OpenApiSpecDetails(super::OpenApiSpecDetails),
    }
}
/// OpenApiSpecDetails contains the details parsed from an OpenAPI spec in
/// addition to the fields mentioned in
/// [SpecDetails][google.cloud.apihub.v1.SpecDetails].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenApiSpecDetails {
    /// Output only. The format of the spec.
    #[prost(enumeration = "open_api_spec_details::Format", tag = "1")]
    pub format: i32,
    /// Output only. The version in the spec.
    /// This maps to `info.version` in OpenAPI spec.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// Output only. Owner details for the spec.
    /// This maps to `info.contact` in OpenAPI spec.
    #[prost(message, optional, tag = "3")]
    pub owner: ::core::option::Option<Owner>,
}
/// Nested message and enum types in `OpenApiSpecDetails`.
pub mod open_api_spec_details {
    /// Enumeration of spec formats.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Format {
        /// SpecFile type unspecified.
        Unspecified = 0,
        /// OpenAPI Spec v2.0.
        OpenApiSpec20 = 1,
        /// OpenAPI Spec v3.0.
        OpenApiSpec30 = 2,
        /// OpenAPI Spec v3.1.
        OpenApiSpec31 = 3,
    }
    impl Format {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FORMAT_UNSPECIFIED",
                Self::OpenApiSpec20 => "OPEN_API_SPEC_2_0",
                Self::OpenApiSpec30 => "OPEN_API_SPEC_3_0",
                Self::OpenApiSpec31 => "OPEN_API_SPEC_3_1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "OPEN_API_SPEC_2_0" => Some(Self::OpenApiSpec20),
                "OPEN_API_SPEC_3_0" => Some(Self::OpenApiSpec30),
                "OPEN_API_SPEC_3_1" => Some(Self::OpenApiSpec31),
                _ => None,
            }
        }
    }
}
/// The operation details parsed from the spec.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationDetails {
    /// Output only. Description of the operation behavior.
    /// For OpenAPI spec, this will map to `operation.description` in the
    /// spec, in case description is empty, `operation.summary` will be used.
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Additional external documentation for this operation.
    /// For OpenAPI spec, this will map to `operation.documentation` in the spec.
    #[prost(message, optional, tag = "2")]
    pub documentation: ::core::option::Option<Documentation>,
    /// Output only. For OpenAPI spec, this will be set if `operation.deprecated`is
    /// marked as `true` in the spec.
    #[prost(bool, tag = "3")]
    pub deprecated: bool,
    #[prost(oneof = "operation_details::Operation", tags = "4")]
    pub operation: ::core::option::Option<operation_details::Operation>,
}
/// Nested message and enum types in `OperationDetails`.
pub mod operation_details {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// The HTTP Operation.
        #[prost(message, tag = "4")]
        HttpOperation(super::HttpOperation),
    }
}
/// The HTTP Operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpOperation {
    /// Output only. The path details for the Operation.
    #[prost(message, optional, tag = "1")]
    pub path: ::core::option::Option<Path>,
    /// Output only. Operation method
    #[prost(enumeration = "http_operation::Method", tag = "2")]
    pub method: i32,
}
/// Nested message and enum types in `HttpOperation`.
pub mod http_operation {
    /// Enumeration of Method types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Method {
        /// Method unspecified.
        Unspecified = 0,
        /// Get Operation type.
        Get = 1,
        /// Put Operation type.
        Put = 2,
        /// Post Operation type.
        Post = 3,
        /// Delete Operation type.
        Delete = 4,
        /// Options Operation type.
        Options = 5,
        /// Head Operation type.
        Head = 6,
        /// Patch Operation type.
        Patch = 7,
        /// Trace Operation type.
        Trace = 8,
    }
    impl Method {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "METHOD_UNSPECIFIED",
                Self::Get => "GET",
                Self::Put => "PUT",
                Self::Post => "POST",
                Self::Delete => "DELETE",
                Self::Options => "OPTIONS",
                Self::Head => "HEAD",
                Self::Patch => "PATCH",
                Self::Trace => "TRACE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                "GET" => Some(Self::Get),
                "PUT" => Some(Self::Put),
                "POST" => Some(Self::Post),
                "DELETE" => Some(Self::Delete),
                "OPTIONS" => Some(Self::Options),
                "HEAD" => Some(Self::Head),
                "PATCH" => Some(Self::Patch),
                "TRACE" => Some(Self::Trace),
                _ => None,
            }
        }
    }
}
/// The path details derived from the spec.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Path {
    /// Output only. Complete path relative to server endpoint.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// Output only. A short description for the path applicable to all operations.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
}
/// The schema details derived from the spec. Currently, this entity is supported
/// for OpenAPI spec only.
/// For OpenAPI spec, this maps to the schema defined in
/// the  `definitions` section for OpenAPI 2.0 version and in
/// `components.schemas` section for OpenAPI 3.0 and 3.1 version.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    /// Output only. The display name of the schema.
    /// This will map to the name of the schema in the spec.
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The raw value of the schema definition corresponding to the
    /// schema name in the spec.
    #[prost(bytes = "vec", tag = "2")]
    pub raw_value: ::prost::alloc::vec::Vec<u8>,
}
/// Owner details.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Owner {
    /// Optional. The name of the owner.
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    /// Required. The email of the owner.
    #[prost(string, tag = "2")]
    pub email: ::prost::alloc::string::String,
}
/// Documentation details.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Documentation {
    /// Optional. The uri of the externally hosted documentation.
    #[prost(string, tag = "1")]
    pub external_uri: ::prost::alloc::string::String,
}
/// The attribute values associated with resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributeValues {
    /// Output only. The name of the attribute.
    /// Format: projects/{project}/locations/{location}/attributes/{attribute}
    #[prost(string, tag = "1")]
    pub attribute: ::prost::alloc::string::String,
    /// The attribute values associated with the resource.
    #[prost(oneof = "attribute_values::Value", tags = "2, 3, 4")]
    pub value: ::core::option::Option<attribute_values::Value>,
}
/// Nested message and enum types in `AttributeValues`.
pub mod attribute_values {
    /// The attribute values of data type enum.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EnumAttributeValues {
        /// Required. The attribute values in case attribute data type is enum.
        #[prost(message, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<super::attribute::AllowedValue>,
    }
    /// The attribute values of data type string or JSON.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StringAttributeValues {
        /// Required. The attribute values in case attribute data type is string or
        /// JSON.
        #[prost(string, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// The attribute values associated with the resource.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        /// The attribute values associated with a resource in case attribute data
        /// type is enum.
        #[prost(message, tag = "2")]
        EnumValues(EnumAttributeValues),
        /// The attribute values associated with a resource in case attribute data
        /// type is string.
        #[prost(message, tag = "3")]
        StringValues(StringAttributeValues),
        /// The attribute values associated with a resource in case attribute data
        /// type is JSON.
        #[prost(message, tag = "4")]
        JsonValues(StringAttributeValues),
    }
}
/// A dependency resource defined in the API hub describes a dependency directed
/// from a consumer to a supplier entity. A dependency can be defined between two
/// [Operations][google.cloud.apihub.v1.Operation] or between
/// an [Operation][google.cloud.apihub.v1.Operation] and [External
/// API][google.cloud.apihub.v1.ExternalApi].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dependency {
    /// Identifier. The name of the dependency in the API Hub.
    ///
    /// Format: `projects/{project}/locations/{location}/dependencies/{dependency}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Immutable. The entity acting as the consumer in the dependency.
    #[prost(message, optional, tag = "2")]
    pub consumer: ::core::option::Option<DependencyEntityReference>,
    /// Required. Immutable. The entity acting as the supplier in the dependency.
    #[prost(message, optional, tag = "3")]
    pub supplier: ::core::option::Option<DependencyEntityReference>,
    /// Output only. State of the dependency.
    #[prost(enumeration = "dependency::State", tag = "4")]
    pub state: i32,
    /// Optional. Human readable description corresponding of the dependency.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Discovery mode of the dependency.
    #[prost(enumeration = "dependency::DiscoveryMode", tag = "6")]
    pub discovery_mode: i32,
    /// Output only. Error details of a dependency if the system has detected it
    /// internally.
    #[prost(message, optional, tag = "7")]
    pub error_detail: ::core::option::Option<DependencyErrorDetail>,
    /// Output only. The time at which the dependency was created.
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time at which the dependency was last updated.
    #[prost(message, optional, tag = "9")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The list of user defined attributes associated with the
    /// dependency resource. The key is the attribute name. It will be of the
    /// format: `projects/{project}/locations/{location}/attributes/{attribute}`.
    /// The value is the attribute values associated with the resource.
    #[prost(map = "string, message", tag = "10")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
}
/// Nested message and enum types in `Dependency`.
pub mod dependency {
    /// Possible states for a dependency.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Dependency will be in a proposed state when it is newly identified by the
        /// API hub on its own.
        Proposed = 1,
        /// Dependency will be in a validated state when it is validated by the
        /// admin or manually created in the API hub.
        Validated = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Proposed => "PROPOSED",
                Self::Validated => "VALIDATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROPOSED" => Some(Self::Proposed),
                "VALIDATED" => Some(Self::Validated),
                _ => None,
            }
        }
    }
    /// Possible modes of discovering the dependency.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DiscoveryMode {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Manual mode of discovery when the dependency is defined by the user.
        Manual = 1,
    }
    impl DiscoveryMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DISCOVERY_MODE_UNSPECIFIED",
                Self::Manual => "MANUAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DISCOVERY_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "MANUAL" => Some(Self::Manual),
                _ => None,
            }
        }
    }
}
/// Reference to an entity participating in a dependency.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DependencyEntityReference {
    /// Output only. Display name of the entity.
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    /// Required. Unique identifier for the participating entity.
    #[prost(oneof = "dependency_entity_reference::Identifier", tags = "2, 3")]
    pub identifier: ::core::option::Option<dependency_entity_reference::Identifier>,
}
/// Nested message and enum types in `DependencyEntityReference`.
pub mod dependency_entity_reference {
    /// Required. Unique identifier for the participating entity.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Identifier {
        /// The resource name of an operation in the API Hub.
        ///
        /// Format:
        /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`
        #[prost(string, tag = "2")]
        OperationResourceName(::prost::alloc::string::String),
        /// The resource name of an external API in the API Hub.
        ///
        /// Format:
        /// `projects/{project}/locations/{location}/externalApis/{external_api}`
        #[prost(string, tag = "3")]
        ExternalApiResourceName(::prost::alloc::string::String),
    }
}
/// Details describing error condition of a dependency.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DependencyErrorDetail {
    /// Optional. Error in the dependency.
    #[prost(enumeration = "dependency_error_detail::Error", tag = "1")]
    pub error: i32,
    /// Optional. Timestamp at which the error was found.
    #[prost(message, optional, tag = "2")]
    pub error_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `DependencyErrorDetail`.
pub mod dependency_error_detail {
    /// Possible values representing an error in the dependency.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Error {
        /// Default value used for no error in the dependency.
        Unspecified = 0,
        /// Supplier entity has been deleted.
        SupplierNotFound = 1,
        /// Supplier entity has been recreated.
        SupplierRecreated = 2,
    }
    impl Error {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ERROR_UNSPECIFIED",
                Self::SupplierNotFound => "SUPPLIER_NOT_FOUND",
                Self::SupplierRecreated => "SUPPLIER_RECREATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ERROR_UNSPECIFIED" => Some(Self::Unspecified),
                "SUPPLIER_NOT_FOUND" => Some(Self::SupplierNotFound),
                "SUPPLIER_RECREATED" => Some(Self::SupplierRecreated),
                _ => None,
            }
        }
    }
}
/// LintResponse contains the response from the linter.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LintResponse {
    /// Optional. Array of issues found in the analyzed document.
    #[prost(message, repeated, tag = "1")]
    pub issues: ::prost::alloc::vec::Vec<Issue>,
    /// Optional. Summary of all issue types and counts for each severity level.
    #[prost(message, repeated, tag = "2")]
    pub summary: ::prost::alloc::vec::Vec<lint_response::SummaryEntry>,
    /// Required. Lint state represents success or failure for linting.
    #[prost(enumeration = "LintState", tag = "3")]
    pub state: i32,
    /// Required. Name of the linting application.
    #[prost(string, tag = "4")]
    pub source: ::prost::alloc::string::String,
    /// Required. Name of the linter used.
    #[prost(enumeration = "Linter", tag = "5")]
    pub linter: i32,
    /// Required. Timestamp when the linting response was generated.
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `LintResponse`.
pub mod lint_response {
    /// Count of issues with a given severity.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SummaryEntry {
        /// Required. Severity of the issue.
        #[prost(enumeration = "super::Severity", tag = "1")]
        pub severity: i32,
        /// Required. Count of issues with the given severity.
        #[prost(int32, tag = "2")]
        pub count: i32,
    }
}
/// Issue contains the details of a single issue found by the linter.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Issue {
    /// Required. Rule code unique to each rule defined in linter.
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    /// Required. An array of strings indicating the location in the analyzed
    /// document where the rule was triggered.
    #[prost(string, repeated, tag = "2")]
    pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required. Human-readable message describing the issue found by the linter.
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    /// Required. Severity level of the rule violation.
    #[prost(enumeration = "Severity", tag = "4")]
    pub severity: i32,
    /// Required. Object describing where in the file the issue was found.
    #[prost(message, optional, tag = "5")]
    pub range: ::core::option::Option<Range>,
}
/// Object describing where in the file the issue was found.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Range {
    /// Required. Start of the issue.
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<Point>,
    /// Required. End of the issue.
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<Point>,
}
/// Point within the file (line and character).
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Point {
    /// Required. Line number (zero-indexed).
    #[prost(int32, tag = "1")]
    pub line: i32,
    /// Required. Character position within the line (zero-indexed).
    #[prost(int32, tag = "2")]
    pub character: i32,
}
/// Represents the metadata of the long-running operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// An ApiHubInstance represents the instance resources of the API Hub.
/// Currently, only one ApiHub instance is allowed for each project.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiHubInstance {
    /// Identifier. Format:
    /// `projects/{project}/locations/{location}/apiHubInstances/{apiHubInstance}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Creation timestamp.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Last update timestamp.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The current state of the ApiHub instance.
    #[prost(enumeration = "api_hub_instance::State", tag = "4")]
    pub state: i32,
    /// Output only. Extra information about ApiHub instance state. Currently the
    /// message would be populated when state is `FAILED`.
    #[prost(string, tag = "5")]
    pub state_message: ::prost::alloc::string::String,
    /// Required. Config of the ApiHub instance.
    #[prost(message, optional, tag = "6")]
    pub config: ::core::option::Option<api_hub_instance::Config>,
    /// Optional. Instance labels to represent user-provided metadata.
    /// Refer to cloud documentation on labels for more details.
    /// <https://cloud.google.com/compute/docs/labeling-resources>
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Description of the ApiHub instance.
    #[prost(string, tag = "8")]
    pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ApiHubInstance`.
pub mod api_hub_instance {
    /// Available configurations to provision an ApiHub Instance.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Config {
        /// Required. The Customer Managed Encryption Key (CMEK) used for data
        /// encryption. The CMEK name should follow the format of
        /// `projects/(\[^/\]+)/locations/(\[^/\]+)/keyRings/(\[^/\]+)/cryptoKeys/(\[^/\]+)`,
        /// where the location must match the instance location.
        #[prost(string, tag = "1")]
        pub cmek_key_name: ::prost::alloc::string::String,
    }
    /// State of the ApiHub Instance.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified = 0,
        /// The ApiHub instance has not been initialized or has been deleted.
        Inactive = 1,
        /// The ApiHub instance is being created.
        Creating = 2,
        /// The ApiHub instance has been created and is ready for use.
        Active = 3,
        /// The ApiHub instance is being updated.
        Updating = 4,
        /// The ApiHub instance is being deleted.
        Deleting = 5,
        /// The ApiHub instance encountered an error during a state change.
        Failed = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Inactive => "INACTIVE",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Updating => "UPDATING",
                Self::Deleting => "DELETING",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "INACTIVE" => Some(Self::Inactive),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// An external API represents an API being provided by external sources. This
/// can be used to model third-party APIs and can be used to define dependencies.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalApi {
    /// Identifier. Format:
    /// `projects/{project}/locations/{location}/externalApi/{externalApi}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Display name of the external API. Max length is 63 characters
    /// (Unicode Code Points).
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. Description of the external API. Max length is 2000 characters
    /// (Unicode Code Points).
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Optional. List of endpoints on which this API is accessible.
    #[prost(string, repeated, tag = "4")]
    pub endpoints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. List of paths served by this API.
    #[prost(string, repeated, tag = "5")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Documentation of the external API.
    #[prost(message, optional, tag = "6")]
    pub documentation: ::core::option::Option<Documentation>,
    /// Optional. The list of user defined attributes associated with the Version
    /// resource. The key is the attribute name. It will be of the format:
    /// `projects/{project}/locations/{location}/attributes/{attribute}`.
    /// The value is the attribute values associated with the resource.
    #[prost(map = "string, message", tag = "7")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AttributeValues,
    >,
    /// Output only. Creation timestamp.
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Last update timestamp.
    #[prost(message, optional, tag = "9")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Lint state represents success or failure for linting.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LintState {
    /// Lint state unspecified.
    Unspecified = 0,
    /// Linting was completed successfully.
    Success = 1,
    /// Linting encountered errors.
    Error = 2,
}
impl LintState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "LINT_STATE_UNSPECIFIED",
            Self::Success => "LINT_STATE_SUCCESS",
            Self::Error => "LINT_STATE_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "LINT_STATE_SUCCESS" => Some(Self::Success),
            "LINT_STATE_ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
/// Enumeration of linter types.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Linter {
    /// Linter type unspecified.
    Unspecified = 0,
    /// Linter type spectral.
    Spectral = 1,
    /// Linter type other.
    Other = 2,
}
impl Linter {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "LINTER_UNSPECIFIED",
            Self::Spectral => "SPECTRAL",
            Self::Other => "OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINTER_UNSPECIFIED" => Some(Self::Unspecified),
            "SPECTRAL" => Some(Self::Spectral),
            "OTHER" => Some(Self::Other),
            _ => None,
        }
    }
}
/// Severity of the issue.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Severity {
    /// Severity unspecified.
    Unspecified = 0,
    /// Severity error.
    Error = 1,
    /// Severity warning.
    Warning = 2,
    /// Severity info.
    Info = 3,
    /// Severity hint.
    Hint = 4,
}
impl Severity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SEVERITY_UNSPECIFIED",
            Self::Error => "SEVERITY_ERROR",
            Self::Warning => "SEVERITY_WARNING",
            Self::Info => "SEVERITY_INFO",
            Self::Hint => "SEVERITY_HINT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
            "SEVERITY_ERROR" => Some(Self::Error),
            "SEVERITY_WARNING" => Some(Self::Warning),
            "SEVERITY_INFO" => Some(Self::Info),
            "SEVERITY_HINT" => Some(Self::Hint),
            _ => None,
        }
    }
}
/// The [CreateApi][google.cloud.apihub.v1.ApiHub.CreateApi] method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateApiRequest {
    /// Required. The parent resource for the API resource.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The ID to use for the API resource, which will become the final
    /// component of the API's resource name. This field is optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    /// the specified id is already used by another API resource in the API hub.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-500 characters, and valid characters
    /// are /[a-z][A-Z][0-9]-_/.
    #[prost(string, tag = "2")]
    pub api_id: ::prost::alloc::string::String,
    /// Required. The API resource to create.
    #[prost(message, optional, tag = "3")]
    pub api: ::core::option::Option<Api>,
}
/// The [GetApi][google.cloud.apihub.v1.ApiHub.GetApi] method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetApiRequest {
    /// Required. The name of the API resource to retrieve.
    /// Format: `projects/{project}/locations/{location}/apis/{api}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [UpdateApi][google.cloud.apihub.v1.ApiHub.UpdateApi] method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateApiRequest {
    /// Required. The API resource to update.
    ///
    /// The API resource's `name` field is used to identify the API resource to
    /// update.
    /// Format: `projects/{project}/locations/{location}/apis/{api}`
    #[prost(message, optional, tag = "1")]
    pub api: ::core::option::Option<Api>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The [DeleteApi][google.cloud.apihub.v1.ApiHub.DeleteApi] method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteApiRequest {
    /// Required. The name of the API resource to delete.
    /// Format: `projects/{project}/locations/{location}/apis/{api}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If set to true, any versions from this API will also be deleted.
    /// Otherwise, the request will only work if the API has no versions.
    #[prost(bool, tag = "2")]
    pub force: bool,
}
/// The [ListApis][google.cloud.apihub.v1.ApiHub.ListApis] method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListApisRequest {
    /// Required. The parent, which owns this collection of API resources.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. An expression that filters the list of ApiResources.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string. The
    /// comparison operator must be one of: `<`, `>`, `:` or `=`. Filters are not
    /// case sensitive.
    ///
    /// The following fields in the `ApiResource` are eligible for filtering:
    ///
    ///    * `owner.email` - The email of the team which owns the ApiResource.
    ///    Allowed comparison operators: `=`.
    ///    * `create_time` - The time at which the ApiResource was created. The
    ///    value should be in the (RFC3339)\[<https://tools.ietf.org/html/rfc3339\]>
    ///    format. Allowed comparison operators: `>` and `<`.
    ///    * `display_name` - The display name of the ApiResource. Allowed
    ///    comparison operators: `=`.
    ///    * `target_user.enum_values.values.id` - The allowed value id of the
    ///    target users attribute associated with the ApiResource. Allowed
    ///    comparison operator is `:`.
    ///    * `target_user.enum_values.values.display_name` - The allowed value
    ///    display name of the target users attribute associated with the
    ///    ApiResource. Allowed comparison operator is `:`.
    ///    * `team.enum_values.values.id` - The allowed value id of the team
    ///    attribute associated with the ApiResource. Allowed comparison operator is
    ///    `:`.
    ///    * `team.enum_values.values.display_name` - The allowed value display name
    ///    of the team attribute associated with the ApiResource. Allowed comparison
    ///    operator is `:`.
    ///    * `business_unit.enum_values.values.id` - The allowed value id of the
    ///    business unit attribute associated with the ApiResource. Allowed
    ///    comparison operator is `:`.
    ///    * `business_unit.enum_values.values.display_name` - The allowed value
    ///    display name of the business unit attribute associated with the
    ///    ApiResource. Allowed comparison operator is `:`.
    ///    * `maturity_level.enum_values.values.id` - The allowed value id of the
    ///    maturity level attribute associated with the ApiResource. Allowed
    ///    comparison operator is `:`.
    ///    * `maturity_level.enum_values.values.display_name` - The allowed value
    ///    display name of the maturity level attribute associated with the
    ///    ApiResource. Allowed comparison operator is `:`.
    ///    * `api_style.enum_values.values.id` - The allowed value id of the
    ///    api style attribute associated with the ApiResource. Allowed
    ///    comparison operator is `:`.
    ///    * `api_style.enum_values.values.display_name` - The allowed value display
    ///    name of the api style attribute associated with the ApiResource. Allowed
    ///    comparison operator is `:`.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are supported. At most
    /// three filter fields are allowed in the filter string and if provided
    /// more than that then `INVALID_ARGUMENT` error is returned by the API.
    ///
    /// Here are a few examples:
    ///
    ///    * `owner.email = \"apihub@google.com\"` -  - The owner team email is
    ///    _apihub@google.com_.
    ///    * `owner.email = \"apihub@google.com\" AND create_time <
    ///    \"2021-08-15T14:50:00Z\" AND create_time > \"2021-08-10T12:00:00Z\"` -
    ///    The owner team email is _apihub@google.com_ and the api was created
    ///    before _2021-08-15 14:50:00 UTC_ and after _2021-08-10 12:00:00 UTC_.
    ///    * `owner.email = \"apihub@google.com\" OR team.enum_values.values.id:
    ///    apihub-team-id` - The filter string specifies the APIs where the owner
    ///    team email is _apihub@google.com_ or the id of the allowed value
    ///    associated with the team attribute is _apihub-team-id_.
    ///    * `owner.email = \"apihub@google.com\" OR
    ///    team.enum_values.values.display_name: ApiHub Team` - The filter string
    ///    specifies the APIs where the owner team email is _apihub@google.com_ or
    ///    the display name of the allowed value associated with the team attribute
    ///    is `ApiHub Team`.
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The maximum number of API resources to return. The service may
    /// return fewer than this value. If unspecified, at most 50 Apis will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListApis` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters (except page_size) provided to
    /// `ListApis` must match the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// The [ListApis][google.cloud.apihub.v1.ApiHub.ListApis] method's response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListApisResponse {
    /// The API resources present in the API hub.
    #[prost(message, repeated, tag = "1")]
    pub apis: ::prost::alloc::vec::Vec<Api>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The [CreateVersion][google.cloud.apihub.v1.ApiHub.CreateVersion] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVersionRequest {
    /// Required. The parent resource for API version.
    /// Format: `projects/{project}/locations/{location}/apis/{api}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The ID to use for the API version, which will become the final
    /// component of the version's resource name. This field is optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    /// the specified id is already used by another version in the API resource.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-500 characters, and valid characters
    /// are /[a-z][A-Z][0-9]-_/.
    #[prost(string, tag = "2")]
    pub version_id: ::prost::alloc::string::String,
    /// Required. The version to create.
    #[prost(message, optional, tag = "3")]
    pub version: ::core::option::Option<Version>,
}
/// The [GetVersion][google.cloud.apihub.v1.ApiHub.GetVersion] method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVersionRequest {
    /// Required. The name of the API version to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [UpdateVersion][google.cloud.apihub.v1.ApiHub.UpdateVersion] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateVersionRequest {
    /// Required. The API version to update.
    ///
    /// The version's `name` field is used to identify the API version to update.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    #[prost(message, optional, tag = "1")]
    pub version: ::core::option::Option<Version>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The [DeleteVersion][google.cloud.apihub.v1.ApiHub.DeleteVersion] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteVersionRequest {
    /// Required. The name of the version to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If set to true, any specs from this version will also be deleted.
    /// Otherwise, the request will only work if the version has no specs.
    #[prost(bool, tag = "2")]
    pub force: bool,
}
/// The [ListVersions][google.cloud.apihub.v1.ApiHub.ListVersions] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVersionsRequest {
    /// Required. The parent which owns this collection of API versions i.e., the
    /// API resource Format: `projects/{project}/locations/{location}/apis/{api}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. An expression that filters the list of Versions.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string, a
    /// number, or a boolean. The comparison operator must be one of: `<`, `>` or
    /// `=`. Filters are not case sensitive.
    ///
    /// The following fields in the `Version` are eligible for filtering:
    ///
    ///    * `display_name` - The display name of the Version. Allowed
    ///    comparison operators: `=`.
    ///    * `create_time` - The time at which the Version was created. The
    ///    value should be in the (RFC3339)\[<https://tools.ietf.org/html/rfc3339\]>
    ///    format. Allowed comparison operators: `>` and `<`.
    ///    * `lifecycle.enum_values.values.id` - The allowed value id of the
    ///    lifecycle attribute associated with the Version. Allowed comparison
    ///    operators: `:`.
    ///    * `lifecycle.enum_values.values.display_name` - The allowed value display
    ///    name of the lifecycle attribute associated with the Version. Allowed
    ///    comparison operators: `:`.
    ///    * `compliance.enum_values.values.id` -  The allowed value id of the
    ///    compliances attribute associated with the Version. Allowed comparison
    ///    operators: `:`.
    ///    * `compliance.enum_values.values.display_name` -  The allowed value
    ///    display name of the compliances attribute associated with the Version.
    ///    Allowed comparison operators: `:`.
    ///    * `accreditation.enum_values.values.id` - The allowed value id of the
    ///    accreditations attribute associated with the Version. Allowed
    ///    comparison operators: `:`.
    ///    * `accreditation.enum_values.values.display_name` - The allowed value
    ///    display name of the accreditations attribute associated with the Version.
    ///    Allowed comparison operators: `:`.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are
    /// supported. At most three filter fields are allowed in the filter
    /// string and if provided more than that then `INVALID_ARGUMENT` error is
    /// returned by the API.
    ///
    /// Here are a few examples:
    ///
    ///    * `lifecycle.enum_values.values.id: preview-id` - The filter string
    ///    specifies that the id of the allowed value associated with the lifecycle
    ///    attribute of the Version is _preview-id_.
    ///    * `lifecycle.enum_values.values.display_name: \"Preview Display Name\"` -
    ///    The filter string specifies that the display name of the allowed value
    ///    associated with the lifecycle attribute of the Version is `Preview
    ///    Display Name`.
    ///    * `lifecycle.enum_values.values.id: preview-id AND create_time <
    ///    \"2021-08-15T14:50:00Z\" AND create_time > \"2021-08-10T12:00:00Z\"` -
    ///    The id of the allowed value associated with the lifecycle attribute of
    ///    the Version is _preview-id_ and it was created before _2021-08-15
    ///    14:50:00 UTC_ and after _2021-08-10 12:00:00 UTC_.
    ///    * `compliance.enum_values.values.id: gdpr-id OR
    ///    compliance.enum_values.values.id: pci-dss-id`
    ///    - The id of the allowed value associated with the compliance attribute is
    ///    _gdpr-id_ or _pci-dss-id_.
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The maximum number of versions to return. The service may return
    /// fewer than this value. If unspecified, at most 50 versions will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListVersions` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters (except page_size) provided to
    /// `ListVersions` must match the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// The [ListVersions][google.cloud.apihub.v1.ApiHub.ListVersions] method's
/// response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVersionsResponse {
    /// The versions corresponding to an API.
    #[prost(message, repeated, tag = "1")]
    pub versions: ::prost::alloc::vec::Vec<Version>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The [CreateSpec][google.cloud.apihub.v1.ApiHub.CreateSpec] method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSpecRequest {
    /// Required. The parent resource for Spec.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The ID to use for the spec, which will become the final component
    /// of the spec's resource name. This field is optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    /// the specified id is already used by another spec in the API
    /// resource.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-500 characters, and valid characters
    /// are /[a-z][A-Z][0-9]-_/.
    #[prost(string, tag = "2")]
    pub spec_id: ::prost::alloc::string::String,
    /// Required. The spec to create.
    #[prost(message, optional, tag = "3")]
    pub spec: ::core::option::Option<Spec>,
}
/// The [GetSpec][google.cloud.apihub.v1.ApiHub.GetSpec] method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSpecRequest {
    /// Required. The name of the spec to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [UpdateSpec][google.cloud.apihub.v1.ApiHub.UpdateSpec] method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSpecRequest {
    /// Required. The spec to update.
    ///
    /// The spec's `name` field is used to identify the spec to
    /// update. Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    #[prost(message, optional, tag = "1")]
    pub spec: ::core::option::Option<Spec>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The [DeleteSpec][google.cloud.apihub.v1.ApiHub.DeleteSpec] method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSpecRequest {
    /// Required. The name of the spec  to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [ListSpecs][ListSpecs] method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSpecsRequest {
    /// Required. The parent, which owns this collection of specs.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. An expression that filters the list of Specs.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string. The
    /// comparison operator must be one of: `<`, `>`, `:` or `=`. Filters are not
    /// case sensitive.
    ///
    /// The following fields in the `Spec` are eligible for filtering:
    ///
    ///    * `display_name` - The display name of the Spec. Allowed comparison
    ///    operators: `=`.
    ///    * `create_time` - The time at which the Spec was created. The
    ///    value should be in the (RFC3339)\[<https://tools.ietf.org/html/rfc3339\]>
    ///    format. Allowed comparison operators: `>` and `<`.
    ///    * `spec_type.enum_values.values.id` - The allowed value id of the
    ///    spec_type attribute associated with the Spec. Allowed comparison
    ///    operators: `:`.
    ///    * `spec_type.enum_values.values.display_name` - The allowed value display
    ///    name of the spec_type attribute associated with the Spec. Allowed
    ///    comparison operators: `:`.
    ///    * `lint_response.json_values.values` - The json value of the
    ///    lint_response attribute associated with the Spec. Allowed comparison
    ///    operators: `:`.
    ///    * `mime_type` - The MIME type of the Spec. Allowed comparison
    ///    operators: `=`.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are
    /// supported. At most three filter fields are allowed in the filter
    /// string and if provided more than that then `INVALID_ARGUMENT` error is
    /// returned by the API.
    ///
    /// Here are a few examples:
    ///
    ///    * `spec_type.enum_values.values.id: rest-id` -  The filter
    ///    string specifies that the id of the allowed value associated with the
    ///    spec_type attribute is _rest-id_.
    ///    * `spec_type.enum_values.values.display_name: \"Rest Display Name\"` -
    ///    The filter string specifies that the display name of the allowed value
    ///    associated with the spec_type attribute is `Rest Display Name`.
    ///    * `spec_type.enum_values.values.id: grpc-id AND create_time <
    ///    \"2021-08-15T14:50:00Z\" AND create_time > \"2021-08-10T12:00:00Z\"` -
    ///    The id of the allowed value associated with the spec_type attribute is
    ///    _grpc-id_ and the spec was created before _2021-08-15 14:50:00 UTC_ and
    ///    after _2021-08-10 12:00:00 UTC_.
    ///    * `spec_type.enum_values.values.id: rest-id OR
    ///    spec_type.enum_values.values.id: grpc-id`
    ///    - The id of the allowed value associated with the spec_type attribute is
    ///    _rest-id_ or _grpc-id_.
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The maximum number of specs to return. The service may return
    /// fewer than this value. If unspecified, at most 50 specs will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListSpecs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListSpecs` must
    /// match the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// The [ListSpecs][google.cloud.apihub.v1.ApiHub.ListSpecs] method's response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSpecsResponse {
    /// The specs corresponding to an API.
    #[prost(message, repeated, tag = "1")]
    pub specs: ::prost::alloc::vec::Vec<Spec>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The [GetSpecContents][google.cloud.apihub.v1.ApiHub.GetSpecContents] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSpecContentsRequest {
    /// Required. The name of the spec whose contents need to be retrieved.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [GetApiOperation][google.cloud.apihub.v1.ApiHub.GetApiOperation] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetApiOperationRequest {
    /// Required. The name of the operation to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [ListApiOperations][google.cloud.apihub.v1.ApiHub.ListApiOperations]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListApiOperationsRequest {
    /// Required. The parent which owns this collection of operations i.e., the API
    /// version. Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. An expression that filters the list of ApiOperations.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string or a
    /// boolean. The comparison operator must be one of: `<`, `>` or
    /// `=`. Filters are not case sensitive.
    ///
    /// The following fields in the `ApiOperation` are eligible for filtering:
    ///    * `name` - The ApiOperation resource name. Allowed comparison
    ///    operators:
    ///    `=`.
    ///    * `details.http_operation.path.path` - The http operation's complete path
    ///    relative to server endpoint. Allowed comparison operators: `=`.
    ///    * `details.http_operation.method` - The http operation method type.
    ///    Allowed comparison operators: `=`.
    ///    * `details.deprecated` - Indicates if the ApiOperation is deprecated.
    ///    Allowed values are True / False indicating the deprycation status of the
    ///    ApiOperation. Allowed comparison operators: `=`.
    ///    * `create_time` - The time at which the ApiOperation was created. The
    ///    value should be in the (RFC3339)\[<https://tools.ietf.org/html/rfc3339\]>
    ///    format. Allowed comparison operators: `>` and `<`.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are supported. At most
    /// three filter fields are allowed in the filter string and if provided
    /// more than that then `INVALID_ARGUMENT` error is returned by the API.
    ///
    /// Here are a few examples:
    ///
    ///    * `details.deprecated = True` -  The ApiOperation is deprecated.
    ///    * `details.http_operation.method = GET AND create_time <
    ///    \"2021-08-15T14:50:00Z\" AND create_time > \"2021-08-10T12:00:00Z\"` -
    ///    The method of the http operation of the ApiOperation is _GET_ and the
    ///    spec was created before _2021-08-15 14:50:00 UTC_ and after _2021-08-10
    ///    12:00:00 UTC_.
    ///    * `details.http_operation.method = GET OR details.http_operation.method =
    ///    POST`. - The http operation of the method of ApiOperation is _GET_ or
    ///    _POST_.
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The maximum number of operations to return. The service may
    /// return fewer than this value. If unspecified, at most 50 operations will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListApiOperations` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters (except page_size) provided to
    /// `ListApiOperations` must match the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// The [ListApiOperations][google.cloud.apihub.v1.ApiHub.ListApiOperations]
/// method's response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListApiOperationsResponse {
    /// The operations corresponding to an API version.
    /// Only following field will be populated in the response: name,
    /// spec, details.deprecated, details.http_operation.path.path,
    /// details.http_operation.method and details.documentation.external_uri.
    #[prost(message, repeated, tag = "1")]
    pub api_operations: ::prost::alloc::vec::Vec<ApiOperation>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The [GetDefinition][google.cloud.apihub.v1.ApiHub.GetDefinition] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDefinitionRequest {
    /// Required. The name of the definition to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/definitions/{definition}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [CreateDeployment][google.cloud.apihub.v1.ApiHub.CreateDeployment]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDeploymentRequest {
    /// Required. The parent resource for the deployment resource.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The ID to use for the deployment resource, which will become the
    /// final component of the deployment's resource name. This field is optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    /// the specified id is already used by another deployment resource in the API
    /// hub.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-500 characters, and valid characters
    /// are /[a-z][A-Z][0-9]-_/.
    #[prost(string, tag = "2")]
    pub deployment_id: ::prost::alloc::string::String,
    /// Required. The deployment resource to create.
    #[prost(message, optional, tag = "3")]
    pub deployment: ::core::option::Option<Deployment>,
}
/// The [GetDeployment][google.cloud.apihub.v1.ApiHub.GetDeployment] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDeploymentRequest {
    /// Required. The name of the deployment resource to retrieve.
    /// Format: `projects/{project}/locations/{location}/deployments/{deployment}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [UpdateDeployment][google.cloud.apihub.v1.ApiHub.UpdateDeployment]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDeploymentRequest {
    /// Required. The deployment resource to update.
    ///
    /// The deployment resource's `name` field is used to identify the deployment
    /// resource to update.
    /// Format: `projects/{project}/locations/{location}/deployments/{deployment}`
    #[prost(message, optional, tag = "1")]
    pub deployment: ::core::option::Option<Deployment>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The [DeleteDeployment][google.cloud.apihub.v1.ApiHub.DeleteDeployment]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDeploymentRequest {
    /// Required. The name of the deployment resource to delete.
    /// Format: `projects/{project}/locations/{location}/deployments/{deployment}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [ListDeployments][google.cloud.apihub.v1.ApiHub.ListDeployments] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentsRequest {
    /// Required. The parent, which owns this collection of deployment resources.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. An expression that filters the list of Deployments.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string. The
    /// comparison operator must be one of: `<`, `>` or
    /// `=`. Filters are not case sensitive.
    ///
    /// The following fields in the `Deployments` are eligible for filtering:
    ///
    ///    * `display_name` - The display name of the Deployment. Allowed
    ///    comparison operators: `=`.
    ///    * `create_time` - The time at which the Deployment was created. The
    ///    value should be in the (RFC3339)\[<https://tools.ietf.org/html/rfc3339\]>
    ///    format. Allowed comparison operators: `>` and `<`.
    ///    * `resource_uri` - A URI to the deployment resource. Allowed
    ///    comparison operators: `=`.
    ///    * `api_versions` - The API versions linked to this deployment. Allowed
    ///    comparison operators: `:`.
    ///    * `deployment_type.enum_values.values.id` - The allowed value id of the
    ///    deployment_type attribute associated with the Deployment. Allowed
    ///    comparison operators: `:`.
    ///    * `deployment_type.enum_values.values.display_name` - The allowed value
    ///    display name of the deployment_type attribute associated with the
    ///    Deployment. Allowed comparison operators: `:`.
    ///    * `slo.string_values.values` -The allowed string value of the slo
    ///    attribute associated with the deployment. Allowed comparison
    ///    operators: `:`.
    ///    * `environment.enum_values.values.id` - The allowed value id of the
    ///    environment attribute associated with the deployment. Allowed
    ///    comparison operators: `:`.
    ///    * `environment.enum_values.values.display_name` - The allowed value
    ///    display name of the environment attribute associated with the deployment.
    ///    Allowed comparison operators: `:`.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are supported. At most
    /// three filter fields are allowed in the filter string and if provided
    /// more than that then `INVALID_ARGUMENT` error is returned by the API.
    ///
    /// Here are a few examples:
    ///
    ///    * `environment.enum_values.values.id: staging-id` - The allowed value id
    ///    of the environment attribute associated with the Deployment is
    ///    _staging-id_.
    ///    * `environment.enum_values.values.display_name: \"Staging Deployment\"` -
    ///    The allowed value display name of the environment attribute associated
    ///    with the Deployment is `Staging Deployment`.
    ///    * `environment.enum_values.values.id: production-id AND create_time <
    ///    \"2021-08-15T14:50:00Z\" AND create_time > \"2021-08-10T12:00:00Z\"` -
    ///    The allowed value id of the environment attribute associated with the
    ///    Deployment is _production-id_ and Deployment was created before
    ///    _2021-08-15 14:50:00 UTC_ and after _2021-08-10 12:00:00 UTC_.
    ///    * `environment.enum_values.values.id: production-id OR
    ///    slo.string_values.values: \"99.99%\"`
    ///    - The allowed value id of the environment attribute Deployment is
    ///    _production-id_ or string value of the slo attribute is _99.99%_.
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The maximum number of deployment resources to return. The service
    /// may return fewer than this value. If unspecified, at most 50 deployments
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListDeployments` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters (except page_size) provided to
    /// `ListDeployments` must match the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// The [ListDeployments][google.cloud.apihub.v1.ApiHub.ListDeployments] method's
/// response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentsResponse {
    /// The deployment resources present in the API hub.
    #[prost(message, repeated, tag = "1")]
    pub deployments: ::prost::alloc::vec::Vec<Deployment>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The [CreateAttribute][google.cloud.apihub.v1.ApiHub.CreateAttribute] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAttributeRequest {
    /// Required. The parent resource for Attribute.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The ID to use for the attribute, which will become the final
    /// component of the attribute's resource name. This field is optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    /// the specified id is already used by another attribute resource in the API
    /// hub.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-500 characters, and valid characters
    /// are /[a-z][A-Z][0-9]-_/.
    #[prost(string, tag = "2")]
    pub attribute_id: ::prost::alloc::string::String,
    /// Required. The attribute to create.
    #[prost(message, optional, tag = "3")]
    pub attribute: ::core::option::Option<Attribute>,
}
/// The [GetAttribute][google.cloud.apihub.v1.ApiHub.GetAttribute] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAttributeRequest {
    /// Required. The name of the attribute to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/attributes/{attribute}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [UpdateAttribute][google.cloud.apihub.v1.ApiHub.UpdateAttribute] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAttributeRequest {
    /// Required. The attribute to update.
    ///
    /// The attribute's `name` field is used to identify the attribute to update.
    /// Format:
    /// `projects/{project}/locations/{location}/attributes/{attribute}`
    #[prost(message, optional, tag = "1")]
    pub attribute: ::core::option::Option<Attribute>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The [DeleteAttribute][google.cloud.apihub.v1.ApiHub.DeleteAttribute] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAttributeRequest {
    /// Required. The name of the attribute to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/attributes/{attribute}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [ListAttributes][google.cloud.apihub.v1.ApiHub.ListAttributes] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAttributesRequest {
    /// Required. The parent resource for Attribute.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. An expression that filters the list of Attributes.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string or a
    /// boolean. The comparison operator must be one of: `<`, `>` or
    /// `=`. Filters are not case sensitive.
    ///
    /// The following fields in the `Attribute` are eligible for filtering:
    ///
    ///    * `display_name` - The display name of the Attribute. Allowed
    ///    comparison operators: `=`.
    ///    * `definition_type` - The definition type of the attribute. Allowed
    ///    comparison operators: `=`.
    ///    * `scope` - The scope of the attribute. Allowed comparison operators:
    ///    `=`.
    ///    * `data_type` - The type of the data of the attribute. Allowed
    ///    comparison operators: `=`.
    ///    * `mandatory` - Denotes whether the attribute is mandatory or not.
    ///    Allowed comparison operators: `=`.
    ///    * `create_time` - The time at which the Attribute was created. The
    ///    value should be in the (RFC3339)\[<https://tools.ietf.org/html/rfc3339\]>
    ///    format. Allowed comparison operators: `>` and `<`.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are
    /// supported. At most three filter fields are allowed in the filter
    /// string and if provided more than that then `INVALID_ARGUMENT` error is
    /// returned by the API.
    ///
    /// Here are a few examples:
    ///
    ///    * `display_name = production` -  - The display name of the attribute is
    ///    _production_.
    ///    * `(display_name = production) AND (create_time <
    ///    \"2021-08-15T14:50:00Z\") AND (create_time > \"2021-08-10T12:00:00Z\")` -
    ///    The display name of the attribute is _production_ and the attribute was
    ///    created before _2021-08-15 14:50:00 UTC_ and after _2021-08-10 12:00:00
    ///    UTC_.
    ///    * `display_name = production OR scope = api` -
    ///    The attribute where the display name is _production_ or the scope is
    ///    _api_.
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The maximum number of attribute resources to return. The service
    /// may return fewer than this value. If unspecified, at most 50 attributes
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListAttributes` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListAttributes` must
    /// match the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// The [ListAttributes][google.cloud.apihub.v1.ApiHub.ListAttributes] method's
/// response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAttributesResponse {
    /// The list of all attributes.
    #[prost(message, repeated, tag = "1")]
    pub attributes: ::prost::alloc::vec::Vec<Attribute>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The [SearchResources][google.cloud.apihub.v1.ApiHub.SearchResources] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResourcesRequest {
    /// Required. The resource name of the location which will be of the type
    /// `projects/{project_id}/locations/{location_id}`. This field is used to
    /// identify the instance of API-Hub in which resources should be searched.
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
    /// Required. The free text search query. This query can contain keywords which
    /// could be related to any detail of the API-Hub resources such display names,
    /// descriptions, attributes etc.
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    /// Optional. An expression that filters the list of search results.
    ///
    /// A filter expression consists of a field name, a comparison operator,
    /// and a value for filtering. The value must be a string, a number, or a
    /// boolean. The comparison operator must be `=`. Filters are not case
    /// sensitive.
    ///
    /// The following field names are eligible for filtering:
    ///     * `resource_type` - The type of resource in the search results.
    ///     Must be one of the following: `Api`, `ApiOperation`, `Deployment`,
    ///     `Definition`, `Spec` or `Version`. This field can only be specified once
    ///     in the filter.
    ///
    /// Here are is an example:
    ///
    ///    * `resource_type = Api` - The resource_type is _Api_.
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The maximum number of search results to return. The service may
    /// return fewer than this value. If unspecified at most 10 search results will
    /// be returned. If value is negative then `INVALID_ARGUMENT` error is
    /// returned. The maximum value is 25; values above 25 will be coerced to 25.
    /// While paginating, you can specify a new page size parameter for each page
    /// of search results to be listed.
    #[prost(int32, tag = "4")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// [SearchResources][SearchResources]
    /// call. Specify this parameter to retrieve the next page of transactions.
    ///
    /// When paginating, you must specify the `page_token` parameter and all the
    /// other parameters except
    /// [page_size][google.cloud.apihub.v1.SearchResourcesRequest.page_size]
    /// should be specified with the same value which was used in the previous
    /// call. If the other fields are set with a different value than the previous
    /// call then `INVALID_ARGUMENT` error is returned.
    #[prost(string, tag = "5")]
    pub page_token: ::prost::alloc::string::String,
}
/// ApiHubResource is one of the resources such as Api, Operation, Deployment,
/// Definition, Spec and Version resources stored in API-Hub.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiHubResource {
    #[prost(oneof = "api_hub_resource::Resource", tags = "1, 2, 3, 4, 5, 6")]
    pub resource: ::core::option::Option<api_hub_resource::Resource>,
}
/// Nested message and enum types in `ApiHubResource`.
pub mod api_hub_resource {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Resource {
        /// This represents Api resource in search results. Only name, display_name,
        /// description and owner fields are populated in search results.
        #[prost(message, tag = "1")]
        Api(super::Api),
        /// This represents ApiOperation resource in search results. Only name,
        /// and description fields are populated in search results.
        #[prost(message, tag = "2")]
        Operation(super::ApiOperation),
        /// This represents Deployment resource in search results. Only name,
        /// display_name and description fields are populated in search results.
        #[prost(message, tag = "3")]
        Deployment(super::Deployment),
        /// This represents Spec resource in search results. Only name,
        /// display_name and description fields are populated in search results.
        #[prost(message, tag = "4")]
        Spec(super::Spec),
        /// This represents Definition resource in search results.
        /// Only name field is populated in search results.
        #[prost(message, tag = "5")]
        Definition(super::Definition),
        /// This represents Version resource in search results. Only name,
        /// display_name and description fields are populated in search results.
        #[prost(message, tag = "6")]
        Version(super::Version),
    }
}
/// Represents the search results.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResult {
    /// This represents the ApiHubResource.
    /// Note: Only selected fields of the resources are populated in response.
    #[prost(message, optional, tag = "1")]
    pub resource: ::core::option::Option<ApiHubResource>,
}
/// Response for the
/// [SearchResources][google.cloud.apihub.v1.ApiHub.SearchResources] method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResourcesResponse {
    /// List of search results according to the filter and search query specified.
    /// The order of search results represents the ranking.
    #[prost(message, repeated, tag = "1")]
    pub search_results: ::prost::alloc::vec::Vec<SearchResult>,
    /// Pass this token in the
    /// [SearchResourcesRequest][google.cloud.apihub.v1.SearchResourcesRequest]
    /// to continue to list results. If all results have been returned, this field
    /// is an empty string or not present in the response.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The
/// [CreateDependency][google.cloud.apihub.v1.ApiHubDependencies.CreateDependency]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDependencyRequest {
    /// Required. The parent resource for the dependency resource.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The ID to use for the dependency resource, which will become the
    /// final component of the dependency's resource name. This field is optional.
    /// * If provided, the same will be used. The service will throw an error if
    /// duplicate id is provided by the client.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-500 characters, and valid characters
    /// are `[a-z][A-Z][0-9]-_`.
    #[prost(string, tag = "2")]
    pub dependency_id: ::prost::alloc::string::String,
    /// Required. The dependency resource to create.
    #[prost(message, optional, tag = "3")]
    pub dependency: ::core::option::Option<Dependency>,
}
/// The [GetDependency][.ApiHubDependencies.GetDependency]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDependencyRequest {
    /// Required. The name of the dependency resource to retrieve.
    /// Format: `projects/{project}/locations/{location}/dependencies/{dependency}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The
/// [UpdateDependency][google.cloud.apihub.v1.ApiHubDependencies.UpdateDependency]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDependencyRequest {
    /// Required. The dependency resource to update.
    ///
    /// The dependency's `name` field is used to identify the dependency to update.
    /// Format: `projects/{project}/locations/{location}/dependencies/{dependency}`
    #[prost(message, optional, tag = "1")]
    pub dependency: ::core::option::Option<Dependency>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The
/// [DeleteDependency][google.cloud.apihub.v1.ApiHubDependencies.DeleteDependency]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDependencyRequest {
    /// Required. The name of the dependency resource to delete.
    /// Format: `projects/{project}/locations/{location}/dependencies/{dependency}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The
/// [ListDependencies][google.cloud.apihub.v1.ApiHubDependencies.ListDependencies]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDependenciesRequest {
    /// Required. The parent which owns this collection of dependency resources.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. An expression that filters the list of Dependencies.
    ///
    /// A filter expression consists of a field name, a comparison operator, and
    /// a value for filtering. The value must be a string. Allowed comparison
    /// operator is `=`. Filters are not case sensitive.
    ///
    /// The following fields in the `Dependency` are eligible for filtering:
    ///
    ///    * `consumer.operation_resource_name` - The operation resource name for
    ///    the consumer entity involved in a dependency. Allowed comparison
    ///    operators: `=`.
    ///    * `consumer.external_api_resource_name` - The external api resource name
    ///    for the consumer entity involved in a dependency. Allowed comparison
    ///    operators: `=`.
    ///    * `supplier.operation_resource_name` - The operation resource name for
    ///    the supplier entity involved in a dependency. Allowed comparison
    ///    operators: `=`.
    ///    * `supplier.external_api_resource_name` - The external api resource name
    ///    for the supplier entity involved in a dependency. Allowed comparison
    ///    operators: `=`.
    ///
    /// Expressions are combined with either `AND` logic operator or `OR` logical
    /// operator but not both of them together i.e. only one of the `AND` or `OR`
    /// operator can be used throughout the filter string and both the operators
    /// cannot be used together. No other logical operators are supported. At most
    /// three filter fields are allowed in the filter string and if provided
    /// more than that then `INVALID_ARGUMENT` error is returned by the API.
    ///
    /// For example, `consumer.operation_resource_name =
    /// \"projects/p1/locations/global/apis/a1/versions/v1/operations/o1\" OR
    /// supplier.operation_resource_name =
    /// \"projects/p1/locations/global/apis/a1/versions/v1/operations/o1\"` - The
    /// dependencies with either consumer or supplier operation resource name as
    /// _projects/p1/locations/global/apis/a1/versions/v1/operations/o1_.
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The maximum number of dependency resources to return. The service
    /// may return fewer than this value. If unspecified, at most 50 dependencies
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListDependencies` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListDependencies` must
    /// match the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// The
/// [ListDependencies][google.cloud.apihub.v1.ApiHubDependencies.ListDependencies]
/// method's response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDependenciesResponse {
    /// The dependency resources present in the API hub.
    /// Only following field will be populated in the response: name.
    #[prost(message, repeated, tag = "1")]
    pub dependencies: ::prost::alloc::vec::Vec<Dependency>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The [CreateExternalApi][google.cloud.apihub.v1.ApiHub.CreateExternalApi]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateExternalApiRequest {
    /// Required. The parent resource for the External API resource.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The ID to use for the External API resource, which will become
    /// the final component of the External API's resource name. This field is
    /// optional.
    ///
    /// * If provided, the same will be used. The service will throw an error if
    /// the specified id is already used by another External API resource in the
    /// API hub.
    /// * If not provided, a system generated id will be used.
    ///
    /// This value should be 4-500 characters, and valid characters
    /// are /[a-z][A-Z][0-9]-_/.
    #[prost(string, tag = "2")]
    pub external_api_id: ::prost::alloc::string::String,
    /// Required. The External API resource to create.
    #[prost(message, optional, tag = "3")]
    pub external_api: ::core::option::Option<ExternalApi>,
}
/// The [GetExternalApi][google.cloud.apihub.v1.ApiHub.GetExternalApi] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetExternalApiRequest {
    /// Required. The name of the External API resource to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/externalApis/{externalApi}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [UpdateExternalApi][google.cloud.apihub.v1.ApiHub.UpdateExternalApi]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateExternalApiRequest {
    /// Required. The External API resource to update.
    ///
    /// The External API resource's `name` field is used to identify the External
    /// API resource to update. Format:
    /// `projects/{project}/locations/{location}/externalApis/{externalApi}`
    #[prost(message, optional, tag = "1")]
    pub external_api: ::core::option::Option<ExternalApi>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The [DeleteExternalApi][google.cloud.apihub.v1.ApiHub.DeleteExternalApi]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteExternalApiRequest {
    /// Required. The name of the External API resource to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/externalApis/{externalApi}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [ListExternalApis][google.cloud.apihub.v1.ApiHub.ListExternalApis]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExternalApisRequest {
    /// Required. The parent, which owns this collection of External API resources.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of External API resources to return. The
    /// service may return fewer than this value. If unspecified, at most 50
    /// ExternalApis will be returned. The maximum value is 1000; values above 1000
    /// will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListExternalApis` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters (except page_size) provided to
    /// `ListExternalApis` must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The [ListExternalApis][google.cloud.apihub.v1.ApiHub.ListExternalApis]
/// method's response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExternalApisResponse {
    /// The External API resources present in the API hub.
    /// Only following fields will be populated in the response: name,
    /// display_name, documentation.external_uri.
    #[prost(message, repeated, tag = "1")]
    pub external_apis: ::prost::alloc::vec::Vec<ExternalApi>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod api_hub_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service provides all methods related to the API hub.
    #[derive(Debug, Clone)]
    pub struct ApiHubClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ApiHubClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ApiHubClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ApiHubClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ApiHubClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create an API resource in the API hub.
        /// Once an API resource is created, versions can be added to it.
        pub async fn create_api(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateApiRequest>,
        ) -> std::result::Result<tonic::Response<super::Api>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/CreateApi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "CreateApi"));
            self.inner.unary(req, path, codec).await
        }
        /// Get API resource details including the API versions contained in it.
        pub async fn get_api(
            &mut self,
            request: impl tonic::IntoRequest<super::GetApiRequest>,
        ) -> std::result::Result<tonic::Response<super::Api>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetApi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetApi"));
            self.inner.unary(req, path, codec).await
        }
        /// List API resources in the API hub.
        pub async fn list_apis(
            &mut self,
            request: impl tonic::IntoRequest<super::ListApisRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListApisResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/ListApis",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "ListApis"));
            self.inner.unary(req, path, codec).await
        }
        /// Update an API resource in the API hub. The following fields in the
        /// [API][] can be updated:
        ///
        /// * [display_name][google.cloud.apihub.v1.Api.display_name]
        /// * [description][google.cloud.apihub.v1.Api.description]
        /// * [owner][google.cloud.apihub.v1.Api.owner]
        /// * [documentation][google.cloud.apihub.v1.Api.documentation]
        /// * [target_user][google.cloud.apihub.v1.Api.target_user]
        /// * [team][google.cloud.apihub.v1.Api.team]
        /// * [business_unit][google.cloud.apihub.v1.Api.business_unit]
        /// * [maturity_level][google.cloud.apihub.v1.Api.maturity_level]
        /// * [attributes][google.cloud.apihub.v1.Api.attributes]
        ///
        /// The
        /// [update_mask][google.cloud.apihub.v1.UpdateApiRequest.update_mask]
        /// should be used to specify the fields being updated.
        ///
        /// Updating the owner field requires complete owner message
        /// and updates both owner and email fields.
        pub async fn update_api(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateApiRequest>,
        ) -> std::result::Result<tonic::Response<super::Api>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/UpdateApi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "UpdateApi"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete an API resource in the API hub. API can only be deleted if all
        /// underlying versions are deleted.
        pub async fn delete_api(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteApiRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/DeleteApi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "DeleteApi"));
            self.inner.unary(req, path, codec).await
        }
        /// Create an API version for an API resource in the API hub.
        pub async fn create_version(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::Version>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/CreateVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "CreateVersion"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get details about the API version of an API resource. This will include
        /// information about the specs and operations present in the API
        /// version as well as the deployments linked to it.
        pub async fn get_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::Version>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetVersion"));
            self.inner.unary(req, path, codec).await
        }
        /// List API versions of an API resource in the API hub.
        pub async fn list_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListVersionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/ListVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "ListVersions"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update API version. The following fields in the
        /// [version][google.cloud.apihub.v1.Version] can be updated currently:
        ///
        /// * [display_name][google.cloud.apihub.v1.Version.display_name]
        /// * [description][google.cloud.apihub.v1.Version.description]
        /// * [documentation][google.cloud.apihub.v1.Version.documentation]
        /// * [deployments][google.cloud.apihub.v1.Version.deployments]
        /// * [lifecycle][google.cloud.apihub.v1.Version.lifecycle]
        /// * [compliance][google.cloud.apihub.v1.Version.compliance]
        /// * [accreditation][google.cloud.apihub.v1.Version.accreditation]
        /// * [attributes][google.cloud.apihub.v1.Version.attributes]
        ///
        /// The
        /// [update_mask][google.cloud.apihub.v1.UpdateVersionRequest.update_mask]
        /// should be used to specify the fields being updated.
        pub async fn update_version(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::Version>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/UpdateVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "UpdateVersion"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete an API version. Version can only be deleted if all underlying specs,
        /// operations, definitions and linked deployments are deleted.
        pub async fn delete_version(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteVersionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/DeleteVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "DeleteVersion"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Add a spec to an API version in the API hub.
        /// Multiple specs can be added to an API version.
        /// Note, while adding a spec, at least one of `contents` or `source_uri` must
        /// be provided. If `contents` is provided, then `spec_type` must also be
        /// provided.
        ///
        /// On adding a spec with contents to the version, the operations present in it
        /// will be added to the version.Note that the file contents in the spec should
        /// be of the same type as defined in the
        /// `projects/{project}/locations/{location}/attributes/system-spec-type`
        /// attribute associated with spec resource. Note that specs of various types
        /// can be uploaded, however parsing of details is supported for OpenAPI spec
        /// currently.
        ///
        /// In order to access the information parsed from the spec, use the
        /// [GetSpec][google.cloud.apihub.v1.ApiHub.GetSpec] method.
        /// In order to access the raw contents for a particular spec, use the
        /// [GetSpecContents][google.cloud.apihub.v1.ApiHub.GetSpecContents] method.
        /// In order to access the operations parsed from the spec, use the
        /// [ListAPIOperations][google.cloud.apihub.v1.ApiHub.ListApiOperations]
        /// method.
        pub async fn create_spec(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSpecRequest>,
        ) -> std::result::Result<tonic::Response<super::Spec>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/CreateSpec",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "CreateSpec"));
            self.inner.unary(req, path, codec).await
        }
        /// Get details about the information parsed from a spec.
        /// Note that this method does not return the raw spec contents.
        /// Use [GetSpecContents][google.cloud.apihub.v1.ApiHub.GetSpecContents] method
        /// to retrieve the same.
        pub async fn get_spec(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSpecRequest>,
        ) -> std::result::Result<tonic::Response<super::Spec>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetSpec",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetSpec"));
            self.inner.unary(req, path, codec).await
        }
        /// Get spec contents.
        pub async fn get_spec_contents(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSpecContentsRequest>,
        ) -> std::result::Result<tonic::Response<super::SpecContents>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetSpecContents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetSpecContents"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List specs corresponding to a particular API resource.
        pub async fn list_specs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSpecsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSpecsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/ListSpecs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "ListSpecs"));
            self.inner.unary(req, path, codec).await
        }
        /// Update spec. The following fields in the
        /// [spec][google.cloud.apihub.v1.Spec] can be updated:
        ///
        /// * [display_name][google.cloud.apihub.v1.Spec.display_name]
        /// * [source_uri][google.cloud.apihub.v1.Spec.source_uri]
        /// * [lint_response][google.cloud.apihub.v1.Spec.lint_response]
        /// * [attributes][google.cloud.apihub.v1.Spec.attributes]
        /// * [contents][google.cloud.apihub.v1.Spec.contents]
        /// * [spec_type][google.cloud.apihub.v1.Spec.spec_type]
        ///
        /// In case of an OAS spec, updating spec contents can lead to:
        /// 1. Creation, deletion and update of operations.
        /// 2. Creation, deletion and update of definitions.
        /// 3. Update of other info parsed out from the new spec.
        ///
        /// In case of contents or source_uri being present in update mask, spec_type
        /// must also be present. Also, spec_type can not be present in update mask if
        /// contents or source_uri is not present.
        ///
        /// The
        /// [update_mask][google.cloud.apihub.v1.UpdateSpecRequest.update_mask]
        /// should be used to specify the fields being updated.
        pub async fn update_spec(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSpecRequest>,
        ) -> std::result::Result<tonic::Response<super::Spec>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/UpdateSpec",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "UpdateSpec"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a spec.
        /// Deleting a spec will also delete the associated operations from the
        /// version.
        pub async fn delete_spec(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSpecRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/DeleteSpec",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "DeleteSpec"));
            self.inner.unary(req, path, codec).await
        }
        /// Get details about a particular operation in API version.
        pub async fn get_api_operation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetApiOperationRequest>,
        ) -> std::result::Result<tonic::Response<super::ApiOperation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetApiOperation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetApiOperation"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List operations in an API version.
        pub async fn list_api_operations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListApiOperationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListApiOperationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/ListApiOperations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "ListApiOperations"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get details about a definition in an API version.
        pub async fn get_definition(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDefinitionRequest>,
        ) -> std::result::Result<tonic::Response<super::Definition>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetDefinition",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetDefinition"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a deployment resource in the API hub.
        /// Once a deployment resource is created, it can be associated with API
        /// versions.
        pub async fn create_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/CreateDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "CreateDeployment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get details about a deployment and the API versions linked to it.
        pub async fn get_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetDeployment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List deployment resources in the API hub.
        pub async fn list_deployments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDeploymentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/ListDeployments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "ListDeployments"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a deployment resource in the API hub. The following fields in the
        /// [deployment resource][google.cloud.apihub.v1.Deployment] can be
        /// updated:
        ///
        /// * [display_name][google.cloud.apihub.v1.Deployment.display_name]
        /// * [description][google.cloud.apihub.v1.Deployment.description]
        /// * [documentation][google.cloud.apihub.v1.Deployment.documentation]
        /// * [deployment_type][google.cloud.apihub.v1.Deployment.deployment_type]
        /// * [resource_uri][google.cloud.apihub.v1.Deployment.resource_uri]
        /// * [endpoints][google.cloud.apihub.v1.Deployment.endpoints]
        /// * [slo][google.cloud.apihub.v1.Deployment.slo]
        /// * [environment][google.cloud.apihub.v1.Deployment.environment]
        /// * [attributes][google.cloud.apihub.v1.Deployment.attributes]
        ///
        /// The
        /// [update_mask][google.cloud.apihub.v1.UpdateDeploymentRequest.update_mask]
        /// should be used to specify the fields being updated.
        pub async fn update_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<super::Deployment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/UpdateDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "UpdateDeployment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a deployment resource in the API hub.
        pub async fn delete_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDeploymentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/DeleteDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "DeleteDeployment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a user defined attribute.
        ///
        /// Certain pre defined attributes are already created by the API hub. These
        /// attributes will have type as `SYSTEM_DEFINED` and can be listed via
        /// [ListAttributes][google.cloud.apihub.v1.ApiHub.ListAttributes] method.
        /// Allowed values for the same can be updated via
        /// [UpdateAttribute][google.cloud.apihub.v1.ApiHub.UpdateAttribute] method.
        pub async fn create_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAttributeRequest>,
        ) -> std::result::Result<tonic::Response<super::Attribute>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/CreateAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "CreateAttribute"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get details about the attribute.
        pub async fn get_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAttributeRequest>,
        ) -> std::result::Result<tonic::Response<super::Attribute>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetAttribute"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update the attribute.  The following fields in the
        /// [Attribute resource][google.cloud.apihub.v1.Attribute] can be updated:
        ///
        /// * [display_name][google.cloud.apihub.v1.Attribute.display_name]
        /// The display name can be updated for user defined attributes only.
        /// * [description][google.cloud.apihub.v1.Attribute.description]
        /// The description can be updated for user defined attributes only.
        /// * [allowed_values][google.cloud.apihub.v1.Attribute.allowed_values]
        /// To update the list of allowed values, clients need to use the fetched list
        /// of allowed values and add or remove values to or from the same list.
        /// The mutable allowed values can be updated for both user defined and System
        /// defined attributes. The immutable allowed values cannot be updated or
        /// deleted. The updated list of allowed values cannot be empty. If an allowed
        /// value that is already used by some resource's attribute is deleted, then
        /// the association between the resource and the attribute value will also be
        /// deleted.
        /// * [cardinality][google.cloud.apihub.v1.Attribute.cardinality]
        /// The cardinality can be updated for user defined attributes only.
        /// Cardinality can only be increased during an update.
        ///
        /// The
        /// [update_mask][google.cloud.apihub.v1.UpdateAttributeRequest.update_mask]
        /// should be used to specify the fields being updated.
        pub async fn update_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAttributeRequest>,
        ) -> std::result::Result<tonic::Response<super::Attribute>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/UpdateAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "UpdateAttribute"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete an attribute.
        ///
        /// Note: System defined attributes cannot be deleted. All
        /// associations of the attribute being deleted with any API hub resource will
        /// also get deleted.
        pub async fn delete_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAttributeRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/DeleteAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "DeleteAttribute"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all attributes.
        pub async fn list_attributes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAttributesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAttributesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/ListAttributes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "ListAttributes"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Search across API-Hub resources.
        pub async fn search_resources(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchResourcesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchResourcesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/SearchResources",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "SearchResources"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create an External API resource in the API hub.
        pub async fn create_external_api(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateExternalApiRequest>,
        ) -> std::result::Result<tonic::Response<super::ExternalApi>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/CreateExternalApi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "CreateExternalApi"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get details about an External API resource in the API hub.
        pub async fn get_external_api(
            &mut self,
            request: impl tonic::IntoRequest<super::GetExternalApiRequest>,
        ) -> std::result::Result<tonic::Response<super::ExternalApi>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/GetExternalApi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "GetExternalApi"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update an External API resource in the API hub. The following fields can be
        /// updated:
        ///
        /// * [display_name][google.cloud.apihub.v1.ExternalApi.display_name]
        /// * [description][google.cloud.apihub.v1.ExternalApi.description]
        /// * [documentation][google.cloud.apihub.v1.ExternalApi.documentation]
        /// * [endpoints][google.cloud.apihub.v1.ExternalApi.endpoints]
        /// * [paths][google.cloud.apihub.v1.ExternalApi.paths]
        ///
        /// The
        /// [update_mask][google.cloud.apihub.v1.UpdateExternalApiRequest.update_mask]
        /// should be used to specify the fields being updated.
        pub async fn update_external_api(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateExternalApiRequest>,
        ) -> std::result::Result<tonic::Response<super::ExternalApi>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/UpdateExternalApi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "UpdateExternalApi"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete an External API resource in the API hub.
        pub async fn delete_external_api(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteExternalApiRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/DeleteExternalApi",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "DeleteExternalApi"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List External API resources in the API hub.
        pub async fn list_external_apis(
            &mut self,
            request: impl tonic::IntoRequest<super::ListExternalApisRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListExternalApisResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHub/ListExternalApis",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHub", "ListExternalApis"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod api_hub_dependencies_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service provides methods for various operations related to a
    /// [Dependency][google.cloud.apihub.v1.Dependency] in the API hub.
    #[derive(Debug, Clone)]
    pub struct ApiHubDependenciesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ApiHubDependenciesClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ApiHubDependenciesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ApiHubDependenciesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ApiHubDependenciesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a dependency between two entities in the API hub.
        pub async fn create_dependency(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDependencyRequest>,
        ) -> std::result::Result<tonic::Response<super::Dependency>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHubDependencies/CreateDependency",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.ApiHubDependencies",
                        "CreateDependency",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get details about a dependency resource in the API hub.
        pub async fn get_dependency(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDependencyRequest>,
        ) -> std::result::Result<tonic::Response<super::Dependency>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHubDependencies/GetDependency",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.ApiHubDependencies",
                        "GetDependency",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a dependency based on the
        /// [update_mask][google.cloud.apihub.v1.UpdateDependencyRequest.update_mask]
        /// provided in the request.
        ///
        /// The following fields in the [dependency][google.cloud.apihub.v1.Dependency]
        /// can be updated:
        /// * [description][google.cloud.apihub.v1.Dependency.description]
        pub async fn update_dependency(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDependencyRequest>,
        ) -> std::result::Result<tonic::Response<super::Dependency>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHubDependencies/UpdateDependency",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.ApiHubDependencies",
                        "UpdateDependency",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete the dependency resource.
        pub async fn delete_dependency(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDependencyRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHubDependencies/DeleteDependency",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.ApiHubDependencies",
                        "DeleteDependency",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List dependencies based on the provided filter and pagination parameters.
        pub async fn list_dependencies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDependenciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDependenciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHubDependencies/ListDependencies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.ApiHubDependencies",
                        "ListDependencies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The
/// [CreateHostProjectRegistration][google.cloud.apihub.v1.HostProjectRegistrationService.CreateHostProjectRegistration]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateHostProjectRegistrationRequest {
    /// Required. The parent resource for the host project.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID to use for the Host Project Registration, which will
    /// become the final component of the host project registration's resource
    /// name. The ID must be the same as the Google cloud project specified in the
    /// host_project_registration.gcp_project field.
    #[prost(string, tag = "2")]
    pub host_project_registration_id: ::prost::alloc::string::String,
    /// Required. The host project registration to register.
    #[prost(message, optional, tag = "3")]
    pub host_project_registration: ::core::option::Option<HostProjectRegistration>,
}
/// The
/// [GetHostProjectRegistration][google.cloud.apihub.v1.HostProjectRegistrationService.GetHostProjectRegistration]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHostProjectRegistrationRequest {
    /// Required. Host project registration resource name.
    /// projects/{project}/locations/{location}/hostProjectRegistrations/{host_project_registration_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The
/// [ListHostProjectRegistrations][google.cloud.apihub.v1.HostProjectRegistrationService.ListHostProjectRegistrations]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHostProjectRegistrationsRequest {
    /// Required. The parent, which owns this collection of host projects.
    /// Format: `projects/*/locations/*`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of host project registrations to return. The
    /// service may return fewer than this value. If unspecified, at most 50 host
    /// project registrations will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// `ListHostProjectRegistrations` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all other parameters (except page_size) provided to
    /// `ListHostProjectRegistrations` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression that filters the list of HostProjectRegistrations.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string. All
    /// standard operators as documented at <https://google.aip.dev/160> are
    /// supported.
    ///
    /// The following fields in the `HostProjectRegistration` are eligible for
    /// filtering:
    ///
    ///    * `name` - The name of the HostProjectRegistration.
    ///    * `create_time` - The time at which the HostProjectRegistration was
    ///    created. The value should be in the
    ///    (RFC3339)\[<https://tools.ietf.org/html/rfc3339\]> format.
    ///    * `gcp_project` - The Google cloud project associated with the
    ///    HostProjectRegistration.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// The
/// [ListHostProjectRegistrations][google.cloud.apihub.v1.HostProjectRegistrationService.ListHostProjectRegistrations]
/// method's response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHostProjectRegistrationsResponse {
    /// The list of host project registrations.
    #[prost(message, repeated, tag = "1")]
    pub host_project_registrations: ::prost::alloc::vec::Vec<HostProjectRegistration>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Host project registration refers to the registration of a Google cloud
/// project with Api Hub as a host project. This is the project where Api Hub is
/// provisioned. It acts as the consumer project for the Api Hub instance
/// provisioned. Multiple runtime projects can be attached to the host project
/// and these attachments define the scope of Api Hub.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HostProjectRegistration {
    /// Identifier. The name of the host project registration.
    /// Format:
    /// "projects/{project}/locations/{location}/hostProjectRegistrations/{host_project_registration}".
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Immutable. Google cloud project name in the format:
    /// "projects/abc" or "projects/123". As input, project name with either
    /// project id or number are accepted. As output, this field will contain
    /// project number.
    #[prost(string, tag = "2")]
    pub gcp_project: ::prost::alloc::string::String,
    /// Output only. The time at which the host project registration was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod host_project_registration_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service is used for managing the host project registrations.
    #[derive(Debug, Clone)]
    pub struct HostProjectRegistrationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl HostProjectRegistrationServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> HostProjectRegistrationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> HostProjectRegistrationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            HostProjectRegistrationServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a host project registration.
        /// A Google cloud project can be registered as a host project if it is not
        /// attached as a runtime project to another host project.
        /// A project can be registered as a host project only once. Subsequent
        /// register calls for the same project will fail.
        pub async fn create_host_project_registration(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateHostProjectRegistrationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HostProjectRegistration>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.HostProjectRegistrationService/CreateHostProjectRegistration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.HostProjectRegistrationService",
                        "CreateHostProjectRegistration",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a host project registration.
        pub async fn get_host_project_registration(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHostProjectRegistrationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HostProjectRegistration>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.HostProjectRegistrationService/GetHostProjectRegistration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.HostProjectRegistrationService",
                        "GetHostProjectRegistration",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists host project registrations.
        pub async fn list_host_project_registrations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListHostProjectRegistrationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListHostProjectRegistrationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.HostProjectRegistrationService/ListHostProjectRegistrations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.HostProjectRegistrationService",
                        "ListHostProjectRegistrations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The [GetStyleGuide][ApiHub.GetStyleGuide] method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStyleGuideRequest {
    /// Required. The name of the spec to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/plugins/{plugin}/styleGuide`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [UpdateStyleGuide][ApiHub.UpdateStyleGuide] method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateStyleGuideRequest {
    /// Required. The Style guide resource to update.
    #[prost(message, optional, tag = "1")]
    pub style_guide: ::core::option::Option<StyleGuide>,
    /// Optional. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The [GetStyleGuideContents][ApiHub.GetStyleGuideContents] method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStyleGuideContentsRequest {
    /// Required. The name of the StyleGuide whose contents need to be retrieved.
    /// There is exactly one style guide resource per project per location.
    /// The expected format is
    /// `projects/{project}/locations/{location}/plugins/{plugin}/styleGuide`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [LintSpec][ApiHub.LintSpec] method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LintSpecRequest {
    /// Required. The name of the spec to be linted.
    /// Format:
    /// `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The style guide contents.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StyleGuideContents {
    /// Required. The contents of the style guide.
    #[prost(bytes = "vec", tag = "1")]
    pub contents: ::prost::alloc::vec::Vec<u8>,
    /// Required. The mime type of the content.
    #[prost(string, tag = "2")]
    pub mime_type: ::prost::alloc::string::String,
}
/// Represents a singleton style guide resource to be used for linting Open API
/// specs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StyleGuide {
    /// Identifier. The name of the style guide.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/plugins/{plugin}/styleGuide`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Target linter for the style guide.
    #[prost(enumeration = "Linter", tag = "2")]
    pub linter: i32,
    /// Required. Input only. The contents of the uploaded style guide.
    #[prost(message, optional, tag = "3")]
    pub contents: ::core::option::Option<StyleGuideContents>,
}
/// Generated client implementations.
pub mod linting_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service provides all methods related to the 1p Linter.
    #[derive(Debug, Clone)]
    pub struct LintingServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl LintingServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> LintingServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LintingServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            LintingServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Get the style guide being used for linting.
        pub async fn get_style_guide(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStyleGuideRequest>,
        ) -> std::result::Result<tonic::Response<super::StyleGuide>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.LintingService/GetStyleGuide",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.LintingService",
                        "GetStyleGuide",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update the styleGuide to be used for liniting in by API hub.
        pub async fn update_style_guide(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateStyleGuideRequest>,
        ) -> std::result::Result<tonic::Response<super::StyleGuide>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.LintingService/UpdateStyleGuide",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.LintingService",
                        "UpdateStyleGuide",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the contents of the style guide.
        pub async fn get_style_guide_contents(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStyleGuideContentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StyleGuideContents>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.LintingService/GetStyleGuideContents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.LintingService",
                        "GetStyleGuideContents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lints the requested spec and updates the corresponding API Spec with the
        /// lint response. This lint response will be available in all subsequent
        /// Get and List Spec calls to Core service.
        pub async fn lint_spec(
            &mut self,
            request: impl tonic::IntoRequest<super::LintSpecRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.LintingService/LintSpec",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.LintingService", "LintSpec"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// A plugin resource in the API Hub.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Plugin {
    /// Identifier. The name of the plugin.
    /// Format: `projects/{project}/locations/{location}/plugins/{plugin}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The display name of the plugin. Max length is 50 characters
    /// (Unicode code points).
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Required. The type of the API.
    /// This maps to the following system defined attribute:
    /// `projects/{project}/locations/{location}/attributes/system-plugin-type`
    /// attribute.
    /// The number of allowed values for this attribute will be based on the
    /// cardinality of the attribute. The same can be retrieved via GetAttribute
    /// API. All values should be from the list of allowed values defined for the
    /// attribute.
    #[prost(message, optional, tag = "3")]
    pub r#type: ::core::option::Option<AttributeValues>,
    /// Optional. The plugin description. Max length is 2000 characters (Unicode
    /// code points).
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Represents the state of the plugin.
    #[prost(enumeration = "plugin::State", tag = "5")]
    pub state: i32,
}
/// Nested message and enum types in `Plugin`.
pub mod plugin {
    /// Possible states a plugin can have. Note that this enum may receive new
    /// values in the future. Consumers are advised to always code against the
    /// enum values expecting new states can be added later on.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified = 0,
        /// The plugin is enabled.
        Enabled = 1,
        /// The plugin is disabled.
        Disabled = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Enabled => "ENABLED",
                Self::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
/// The [GetPlugin][google.cloud.apihub.v1.ApiHubPlugin.GetPlugin] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPluginRequest {
    /// Required. The name of the plugin to retrieve.
    /// Format: `projects/{project}/locations/{location}/plugins/{plugin}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [EnablePlugin][google.cloud.apihub.v1.ApiHubPlugin.EnablePlugin] method's
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnablePluginRequest {
    /// Required. The name of the plugin to enable.
    /// Format: `projects/{project}/locations/{location}/plugins/{plugin}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The [DisablePlugin][google.cloud.apihub.v1.ApiHubPlugin.DisablePlugin]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisablePluginRequest {
    /// Required. The name of the plugin to disable.
    /// Format: `projects/{project}/locations/{location}/plugins/{plugin}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod api_hub_plugin_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service is used for managing plugins inside the API Hub.
    #[derive(Debug, Clone)]
    pub struct ApiHubPluginClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ApiHubPluginClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ApiHubPluginClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ApiHubPluginClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ApiHubPluginClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Get details about an API Hub plugin.
        pub async fn get_plugin(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPluginRequest>,
        ) -> std::result::Result<tonic::Response<super::Plugin>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHubPlugin/GetPlugin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.apihub.v1.ApiHubPlugin", "GetPlugin"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Enables a plugin.
        /// The `state` of the plugin after enabling is `ENABLED`
        pub async fn enable_plugin(
            &mut self,
            request: impl tonic::IntoRequest<super::EnablePluginRequest>,
        ) -> std::result::Result<tonic::Response<super::Plugin>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHubPlugin/EnablePlugin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.ApiHubPlugin",
                        "EnablePlugin",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Disables a plugin.
        /// The `state` of the plugin after disabling is `DISABLED`
        pub async fn disable_plugin(
            &mut self,
            request: impl tonic::IntoRequest<super::DisablePluginRequest>,
        ) -> std::result::Result<tonic::Response<super::Plugin>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.ApiHubPlugin/DisablePlugin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.ApiHubPlugin",
                        "DisablePlugin",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The
/// [CreateApiHubInstance][google.cloud.apihub.v1.Provisioning.CreateApiHubInstance]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateApiHubInstanceRequest {
    /// Required. The parent resource for the Api Hub instance resource.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Identifier to assign to the Api Hub instance. Must be unique
    /// within scope of the parent resource. If the field is not provided, system
    /// generated id will be used.
    ///
    /// This value should be 4-40 characters, and valid characters
    /// are `/[a-z][A-Z][0-9]-_/`.
    #[prost(string, tag = "2")]
    pub api_hub_instance_id: ::prost::alloc::string::String,
    /// Required. The ApiHub instance.
    #[prost(message, optional, tag = "3")]
    pub api_hub_instance: ::core::option::Option<ApiHubInstance>,
}
/// The
/// [GetApiHubInstance][google.cloud.apihub.v1.Provisioning.GetApiHubInstance]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetApiHubInstanceRequest {
    /// Required. The name of the Api Hub instance to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/apiHubInstances/{apiHubInstance}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The
/// [LookupApiHubInstance][google.cloud.apihub.v1.Provisioning.LookupApiHubInstance]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupApiHubInstanceRequest {
    /// Required. There will always be only one Api Hub instance for a GCP project
    /// across all locations.
    /// The parent resource for the Api Hub instance resource.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// The
/// [LookupApiHubInstance][google.cloud.apihub.v1.Provisioning.LookupApiHubInstance]
/// method's response.`
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupApiHubInstanceResponse {
    /// API Hub instance for a project if it exists, empty otherwise.
    #[prost(message, optional, tag = "1")]
    pub api_hub_instance: ::core::option::Option<ApiHubInstance>,
}
/// Generated client implementations.
pub mod provisioning_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service is used for managing the data plane provisioning of the API hub.
    #[derive(Debug, Clone)]
    pub struct ProvisioningClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ProvisioningClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ProvisioningClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ProvisioningClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ProvisioningClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Provisions instance resources for the API Hub.
        pub async fn create_api_hub_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateApiHubInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.Provisioning/CreateApiHubInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.Provisioning",
                        "CreateApiHubInstance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single API Hub instance.
        pub async fn get_api_hub_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetApiHubInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::ApiHubInstance>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.Provisioning/GetApiHubInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.Provisioning",
                        "GetApiHubInstance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Looks up an Api Hub instance in a given GCP project. There will always be
        /// only one Api Hub instance for a GCP project across all locations.
        pub async fn lookup_api_hub_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupApiHubInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LookupApiHubInstanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.Provisioning/LookupApiHubInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.Provisioning",
                        "LookupApiHubInstance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The
/// [CreateRuntimeProjectAttachment][google.cloud.apihub.v1.RuntimeProjectAttachmentService.CreateRuntimeProjectAttachment]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRuntimeProjectAttachmentRequest {
    /// Required. The parent resource for the Runtime Project Attachment.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID to use for the Runtime Project Attachment, which will
    /// become the final component of the Runtime Project Attachment's name. The ID
    /// must be the same as the project ID of the Google cloud project specified in
    /// the runtime_project_attachment.runtime_project field.
    #[prost(string, tag = "2")]
    pub runtime_project_attachment_id: ::prost::alloc::string::String,
    /// Required. The Runtime Project Attachment to create.
    #[prost(message, optional, tag = "3")]
    pub runtime_project_attachment: ::core::option::Option<RuntimeProjectAttachment>,
}
/// The
/// [GetRuntimeProjectAttachment][google.cloud.apihub.v1.RuntimeProjectAttachmentService.GetRuntimeProjectAttachment]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRuntimeProjectAttachmentRequest {
    /// Required. The name of the API resource to retrieve.
    /// Format:
    /// `projects/{project}/locations/{location}/runtimeProjectAttachments/{runtime_project_attachment}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The
/// [ListRuntimeProjectAttachments][google.cloud.apihub.v1.RuntimeProjectAttachmentService.ListRuntimeProjectAttachments]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRuntimeProjectAttachmentsRequest {
    /// Required. The parent, which owns this collection of runtime project
    /// attachments. Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of runtime project attachments to return. The
    /// service may return fewer than this value. If unspecified, at most 50
    /// runtime project attachments will be returned. The maximum value is 1000;
    /// values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// `ListRuntimeProjectAttachments` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all other parameters (except page_size) provided to
    /// `ListRuntimeProjectAttachments` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression that filters the list of RuntimeProjectAttachments.
    ///
    /// A filter expression consists of a field name, a comparison
    /// operator, and a value for filtering. The value must be a string. All
    /// standard operators as documented at <https://google.aip.dev/160> are
    /// supported.
    ///
    /// The following fields in the `RuntimeProjectAttachment` are eligible for
    /// filtering:
    ///
    ///    * `name` - The name of the RuntimeProjectAttachment.
    ///    * `create_time` - The time at which the RuntimeProjectAttachment was
    ///    created. The value should be in the
    ///    (RFC3339)\[<https://tools.ietf.org/html/rfc3339\]> format.
    ///    * `runtime_project` - The Google cloud project associated with the
    ///    RuntimeProjectAttachment.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// The
/// [ListRuntimeProjectAttachments][google.cloud.apihub.v1.RuntimeProjectAttachmentService.ListRuntimeProjectAttachments]
/// method's response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRuntimeProjectAttachmentsResponse {
    /// List of runtime project attachments.
    #[prost(message, repeated, tag = "1")]
    pub runtime_project_attachments: ::prost::alloc::vec::Vec<RuntimeProjectAttachment>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The
/// [DeleteRuntimeProjectAttachment][google.cloud.apihub.v1.RuntimeProjectAttachmentService.DeleteRuntimeProjectAttachment]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRuntimeProjectAttachmentRequest {
    /// Required. The name of the Runtime Project Attachment to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/runtimeProjectAttachments/{runtime_project_attachment}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The
/// [LookupRuntimeProjectAttachment][google.cloud.apihub.v1.RuntimeProjectAttachmentService.LookupRuntimeProjectAttachment]
/// method's request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupRuntimeProjectAttachmentRequest {
    /// Required. Runtime project ID to look up runtime project attachment for.
    /// Lookup happens across all regions. Expected format:
    /// `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The
/// [ListRuntimeProjectAttachments][google.cloud.apihub.v1.RuntimeProjectAttachmentService.ListRuntimeProjectAttachments]
/// method's response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupRuntimeProjectAttachmentResponse {
    /// Runtime project attachment for a project if exists, empty otherwise.
    #[prost(message, optional, tag = "1")]
    pub runtime_project_attachment: ::core::option::Option<RuntimeProjectAttachment>,
}
/// Runtime project attachment represents an attachment from the runtime project
/// to the host project. Api Hub looks for deployments in the attached runtime
/// projects and creates corresponding resources in Api Hub for the discovered
/// deployments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeProjectAttachment {
    /// Identifier. The resource name of a runtime project attachment. Format:
    /// "projects/{project}/locations/{location}/runtimeProjectAttachments/{runtime_project_attachment}".
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Immutable. Google cloud project name in the format:
    /// "projects/abc" or "projects/123". As input, project name with either
    /// project id or number are accepted. As output, this field will contain
    /// project number.
    #[prost(string, tag = "2")]
    pub runtime_project: ::prost::alloc::string::String,
    /// Output only. Create time.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod runtime_project_attachment_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service is used for managing the runtime project attachments.
    #[derive(Debug, Clone)]
    pub struct RuntimeProjectAttachmentServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RuntimeProjectAttachmentServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RuntimeProjectAttachmentServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RuntimeProjectAttachmentServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            RuntimeProjectAttachmentServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Attaches a runtime project to the host project.
        pub async fn create_runtime_project_attachment(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateRuntimeProjectAttachmentRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::RuntimeProjectAttachment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.RuntimeProjectAttachmentService/CreateRuntimeProjectAttachment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.RuntimeProjectAttachmentService",
                        "CreateRuntimeProjectAttachment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a runtime project attachment.
        pub async fn get_runtime_project_attachment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRuntimeProjectAttachmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RuntimeProjectAttachment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.RuntimeProjectAttachmentService/GetRuntimeProjectAttachment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.RuntimeProjectAttachmentService",
                        "GetRuntimeProjectAttachment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List runtime projects attached to the host project.
        pub async fn list_runtime_project_attachments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRuntimeProjectAttachmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRuntimeProjectAttachmentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.RuntimeProjectAttachmentService/ListRuntimeProjectAttachments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.RuntimeProjectAttachmentService",
                        "ListRuntimeProjectAttachments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a runtime project attachment in the API Hub. This call will detach
        /// the runtime project from the host project.
        pub async fn delete_runtime_project_attachment(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteRuntimeProjectAttachmentRequest,
            >,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.RuntimeProjectAttachmentService/DeleteRuntimeProjectAttachment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.RuntimeProjectAttachmentService",
                        "DeleteRuntimeProjectAttachment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Look up a runtime project attachment. This API can be called in the context
        /// of any project.
        pub async fn lookup_runtime_project_attachment(
            &mut self,
            request: impl tonic::IntoRequest<
                super::LookupRuntimeProjectAttachmentRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::LookupRuntimeProjectAttachmentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.apihub.v1.RuntimeProjectAttachmentService/LookupRuntimeProjectAttachment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.apihub.v1.RuntimeProjectAttachmentService",
                        "LookupRuntimeProjectAttachment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
