// This file is @generated by prost-build.
/// Represents an access event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Access {
    /// Associated email, such as "foo@google.com".
    ///
    /// The email address of the authenticated user or a service account acting on
    /// behalf of a third party principal making the request. For third party
    /// identity callers, the `principal_subject` field is populated instead of
    /// this field. For privacy reasons, the principal email address is sometimes
    /// redacted. For more information, see [Caller identities in audit
    /// logs](<https://cloud.google.com/logging/docs/audit#user-id>).
    #[prost(string, tag = "1")]
    pub principal_email: ::prost::alloc::string::String,
    /// Caller's IP address, such as "1.1.1.1".
    #[prost(string, tag = "2")]
    pub caller_ip: ::prost::alloc::string::String,
    /// The caller IP's geolocation, which identifies where the call came from.
    #[prost(message, optional, tag = "3")]
    pub caller_ip_geo: ::core::option::Option<Geolocation>,
    /// Type of user agent associated with the finding. For example, an operating
    /// system shell or an embedded or standalone application.
    #[prost(string, tag = "4")]
    pub user_agent_family: ::prost::alloc::string::String,
    /// The caller's user agent string associated with the finding.
    #[prost(string, tag = "12")]
    pub user_agent: ::prost::alloc::string::String,
    /// This is the API service that the service account made a call to, e.g.
    /// "iam.googleapis.com"
    #[prost(string, tag = "5")]
    pub service_name: ::prost::alloc::string::String,
    /// The method that the service account called, e.g. "SetIamPolicy".
    #[prost(string, tag = "6")]
    pub method_name: ::prost::alloc::string::String,
    /// A string that represents the principal_subject that is associated with the
    /// identity. Unlike `principal_email`, `principal_subject` supports principals
    /// that aren't associated with email addresses, such as third party
    /// principals. For most identities, the format is
    /// `principal://iam.googleapis.com/{identity pool name}/subject/{subject}`.
    /// Some GKE identities, such as GKE_WORKLOAD, FREEFORM, and GKE_HUB_WORKLOAD,
    /// still use the legacy format `serviceAccount:{identity pool
    /// name}\[{subject}\]`.
    #[prost(string, tag = "7")]
    pub principal_subject: ::prost::alloc::string::String,
    /// The name of the service account key that was used to create or exchange
    /// credentials when authenticating the service account that made the request.
    /// This is a scheme-less URI full resource name. For example:
    ///
    /// "//iam.googleapis.com/projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{key}".
    ///
    #[prost(string, tag = "8")]
    pub service_account_key_name: ::prost::alloc::string::String,
    /// The identity delegation history of an authenticated service account that
    /// made the request. The `serviceAccountDelegationInfo\[\]` object contains
    /// information about the real authorities that try to access Google Cloud
    /// resources by delegating on a service account. When multiple authorities are
    /// present, they are guaranteed to be sorted based on the original ordering of
    /// the identity delegation events.
    #[prost(message, repeated, tag = "9")]
    pub service_account_delegation_info: ::prost::alloc::vec::Vec<
        ServiceAccountDelegationInfo,
    >,
    /// A string that represents a username. The username provided depends on the
    /// type of the finding and is likely not an IAM principal. For example, this
    /// can be a system username if the finding is related to a virtual machine, or
    /// it can be an application login username.
    #[prost(string, tag = "11")]
    pub user_name: ::prost::alloc::string::String,
}
/// Identity delegation history of an authenticated service account.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAccountDelegationInfo {
    /// The email address of a Google account.
    #[prost(string, tag = "1")]
    pub principal_email: ::prost::alloc::string::String,
    /// A string representing the principal_subject associated with the identity.
    /// As compared to `principal_email`, supports principals that aren't
    /// associated with email addresses, such as third party principals. For most
    /// identities, the format will be `principal://iam.googleapis.com/{identity
    /// pool name}/subjects/{subject}` except for some GKE identities
    /// (GKE_WORKLOAD, FREEFORM, GKE_HUB_WORKLOAD) that are still in the legacy
    /// format `serviceAccount:{identity pool name}\[{subject}\]`
    #[prost(string, tag = "2")]
    pub principal_subject: ::prost::alloc::string::String,
}
/// Represents a geographical location for a given access.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Geolocation {
    /// A CLDR.
    #[prost(string, tag = "1")]
    pub region_code: ::prost::alloc::string::String,
}
/// Represents an application associated with a finding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Application {
    /// The base URI that identifies the network location of the application in
    /// which the vulnerability was detected. For example, `<http://example.com`.>
    #[prost(string, tag = "1")]
    pub base_uri: ::prost::alloc::string::String,
    /// The full URI with payload that can be used to reproduce the
    /// vulnerability. For example, `<http://example.com?p=aMmYgI6H`.>
    #[prost(string, tag = "2")]
    pub full_uri: ::prost::alloc::string::String,
}
/// Message that contains the resource name and display name of a folder
/// resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Folder {
    /// Full resource name of this folder. See:
    /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
    #[prost(string, tag = "1")]
    pub resource_folder: ::prost::alloc::string::String,
    /// The user defined display name for this folder.
    #[prost(string, tag = "2")]
    pub resource_folder_display_name: ::prost::alloc::string::String,
}
/// User specified security marks that are attached to the parent Security
/// Command Center resource. Security marks are scoped within a Security Command
/// Center organization -- they can be modified and viewed by all users who have
/// proper permissions on the organization.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityMarks {
    /// The relative resource name of the SecurityMarks. See:
    /// <https://cloud.google.com/apis/design/resource_names#relative_resource_name>
    /// Examples:
    /// "organizations/{organization_id}/assets/{asset_id}/securityMarks"
    /// "organizations/{organization_id}/sources/{source_id}/findings/{finding_id}/securityMarks".
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Mutable user specified security marks belonging to the parent resource.
    /// Constraints are as follows:
    ///
    ///    * Keys and values are treated as case insensitive
    ///    * Keys must be between 1 - 256 characters (inclusive)
    ///    * Keys must be letters, numbers, underscores, or dashes
    ///    * Values have leading and trailing whitespace trimmed, remaining
    ///      characters must be between 1 - 4096 characters (inclusive)
    #[prost(map = "string, string", tag = "2")]
    pub marks: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The canonical name of the marks.
    /// Examples:
    /// "organizations/{organization_id}/assets/{asset_id}/securityMarks"
    /// "folders/{folder_id}/assets/{asset_id}/securityMarks"
    /// "projects/{project_number}/assets/{asset_id}/securityMarks"
    /// "organizations/{organization_id}/sources/{source_id}/findings/{finding_id}/securityMarks"
    /// "folders/{folder_id}/sources/{source_id}/findings/{finding_id}/securityMarks"
    /// "projects/{project_number}/sources/{source_id}/findings/{finding_id}/securityMarks"
    #[prost(string, tag = "3")]
    pub canonical_name: ::prost::alloc::string::String,
}
/// Security Command Center representation of a Google Cloud
/// resource.
///
/// The Asset is a Security Command Center resource that captures information
/// about a single Google Cloud resource. All modifications to an Asset are only
/// within the context of Security Command Center and don't affect the referenced
/// Google Cloud resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Asset {
    /// The relative resource name of this asset. See:
    /// <https://cloud.google.com/apis/design/resource_names#relative_resource_name>
    /// Example:
    /// "organizations/{organization_id}/assets/{asset_id}".
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Security Command Center managed properties. These properties are managed by
    /// Security Command Center and cannot be modified by the user.
    #[prost(message, optional, tag = "2")]
    pub security_center_properties: ::core::option::Option<
        asset::SecurityCenterProperties,
    >,
    /// Resource managed properties. These properties are managed and defined by
    /// the Google Cloud resource and cannot be modified by the user.
    #[prost(map = "string, message", tag = "7")]
    pub resource_properties: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost_types::Value,
    >,
    /// User specified security marks. These marks are entirely managed by the user
    /// and come from the SecurityMarks resource that belongs to the asset.
    #[prost(message, optional, tag = "8")]
    pub security_marks: ::core::option::Option<SecurityMarks>,
    /// The time at which the asset was created in Security Command Center.
    #[prost(message, optional, tag = "9")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time at which the asset was last updated or added in Cloud SCC.
    #[prost(message, optional, tag = "10")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Cloud IAM Policy information associated with the Google Cloud resource
    /// described by the Security Command Center asset. This information is managed
    /// and defined by the Google Cloud resource and cannot be modified by the
    /// user.
    #[prost(message, optional, tag = "11")]
    pub iam_policy: ::core::option::Option<asset::IamPolicy>,
    /// The canonical name of the resource. It's either
    /// "organizations/{organization_id}/assets/{asset_id}",
    /// "folders/{folder_id}/assets/{asset_id}" or
    /// "projects/{project_number}/assets/{asset_id}", depending on the closest CRM
    /// ancestor of the resource.
    #[prost(string, tag = "13")]
    pub canonical_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Asset`.
pub mod asset {
    /// Security Command Center managed properties. These properties are managed by
    /// Security Command Center and cannot be modified by the user.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SecurityCenterProperties {
        /// The full resource name of the Google Cloud resource this asset
        /// represents. This field is immutable after create time. See:
        /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
        #[prost(string, tag = "1")]
        pub resource_name: ::prost::alloc::string::String,
        /// The type of the Google Cloud resource. Examples include: APPLICATION,
        /// PROJECT, and ORGANIZATION. This is a case insensitive field defined by
        /// Security Command Center and/or the producer of the resource and is
        /// immutable after create time.
        #[prost(string, tag = "2")]
        pub resource_type: ::prost::alloc::string::String,
        /// The full resource name of the immediate parent of the resource. See:
        /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
        #[prost(string, tag = "3")]
        pub resource_parent: ::prost::alloc::string::String,
        /// The full resource name of the project the resource belongs to. See:
        /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
        #[prost(string, tag = "4")]
        pub resource_project: ::prost::alloc::string::String,
        /// Owners of the Google Cloud resource.
        #[prost(string, repeated, tag = "5")]
        pub resource_owners: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// The user defined display name for this resource.
        #[prost(string, tag = "6")]
        pub resource_display_name: ::prost::alloc::string::String,
        /// The user defined display name for the parent of this resource.
        #[prost(string, tag = "7")]
        pub resource_parent_display_name: ::prost::alloc::string::String,
        /// The user defined display name for the project of this resource.
        #[prost(string, tag = "8")]
        pub resource_project_display_name: ::prost::alloc::string::String,
        /// Contains a Folder message for each folder in the assets ancestry.
        /// The first folder is the deepest nested folder, and the last folder is the
        /// folder directly under the Organization.
        #[prost(message, repeated, tag = "10")]
        pub folders: ::prost::alloc::vec::Vec<super::Folder>,
    }
    /// Cloud IAM Policy information associated with the Google Cloud resource
    /// described by the Security Command Center asset. This information is managed
    /// and defined by the Google Cloud resource and cannot be modified by the
    /// user.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IamPolicy {
        /// The JSON representation of the Policy associated with the asset.
        /// See <https://cloud.google.com/iam/reference/rest/v1/Policy> for format
        /// details.
        #[prost(string, tag = "1")]
        pub policy_blob: ::prost::alloc::string::String,
    }
}
/// An attack exposure contains the results of an attack path simulation run.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttackExposure {
    /// A number between 0 (inclusive) and infinity that represents how important
    /// this finding is to remediate. The higher the score, the more important it
    /// is to remediate.
    #[prost(double, tag = "1")]
    pub score: f64,
    /// The most recent time the attack exposure was updated on this finding.
    #[prost(message, optional, tag = "2")]
    pub latest_calculation_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The resource name of the attack path simulation result that contains the
    /// details regarding this attack exposure score.
    /// Example: `organizations/123/simulations/456/attackExposureResults/789`
    #[prost(string, tag = "3")]
    pub attack_exposure_result: ::prost::alloc::string::String,
    /// What state this AttackExposure is in. This captures whether or not an
    /// attack exposure has been calculated or not.
    #[prost(enumeration = "attack_exposure::State", tag = "4")]
    pub state: i32,
    /// The number of high value resources that are exposed as a result of this
    /// finding.
    #[prost(int32, tag = "5")]
    pub exposed_high_value_resources_count: i32,
    /// The number of medium value resources that are exposed as a result of this
    /// finding.
    #[prost(int32, tag = "6")]
    pub exposed_medium_value_resources_count: i32,
    /// The number of high value resources that are exposed as a result of this
    /// finding.
    #[prost(int32, tag = "7")]
    pub exposed_low_value_resources_count: i32,
}
/// Nested message and enum types in `AttackExposure`.
pub mod attack_exposure {
    /// This enum defines the various states an AttackExposure can be in.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state is not specified.
        Unspecified = 0,
        /// The attack exposure has been calculated.
        Calculated = 1,
        /// The attack exposure has not been calculated.
        NotCalculated = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Calculated => "CALCULATED",
                Self::NotCalculated => "NOT_CALCULATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CALCULATED" => Some(Self::Calculated),
                "NOT_CALCULATED" => Some(Self::NotCalculated),
                _ => None,
            }
        }
    }
}
/// A path that an attacker could take to reach an exposed resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttackPath {
    /// The attack path name, for example,
    ///   `organizations/12/simulation/34/valuedResources/56/attackPaths/78`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// A list of nodes that exist in this attack path.
    #[prost(message, repeated, tag = "2")]
    pub path_nodes: ::prost::alloc::vec::Vec<attack_path::AttackPathNode>,
    /// A list of the edges between nodes in this attack path.
    #[prost(message, repeated, tag = "3")]
    pub edges: ::prost::alloc::vec::Vec<attack_path::AttackPathEdge>,
}
/// Nested message and enum types in `AttackPath`.
pub mod attack_path {
    /// Represents one point that an attacker passes through in this attack path.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AttackPathNode {
        /// The name of the resource at this point in the attack path.
        /// The format of the name follows the Cloud Asset Inventory [resource
        /// name
        /// format](<https://cloud.google.com/asset-inventory/docs/resource-name-format>)
        #[prost(string, tag = "1")]
        pub resource: ::prost::alloc::string::String,
        /// The [supported resource
        /// type](<https://cloud.google.com/asset-inventory/docs/supported-asset-types>)
        #[prost(string, tag = "2")]
        pub resource_type: ::prost::alloc::string::String,
        /// Human-readable name of this resource.
        #[prost(string, tag = "3")]
        pub display_name: ::prost::alloc::string::String,
        /// The findings associated with this node in the attack path.
        #[prost(message, repeated, tag = "4")]
        pub associated_findings: ::prost::alloc::vec::Vec<
            attack_path_node::PathNodeAssociatedFinding,
        >,
        /// Unique id of the attack path node.
        #[prost(string, tag = "5")]
        pub uuid: ::prost::alloc::string::String,
        /// A list of attack step nodes that exist in this attack path node.
        #[prost(message, repeated, tag = "6")]
        pub attack_steps: ::prost::alloc::vec::Vec<attack_path_node::AttackStepNode>,
    }
    /// Nested message and enum types in `AttackPathNode`.
    pub mod attack_path_node {
        /// A finding that is associated with this node in the attack path.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PathNodeAssociatedFinding {
            /// Canonical name of the associated findings. Example:
            /// `organizations/123/sources/456/findings/789`
            #[prost(string, tag = "1")]
            pub canonical_finding: ::prost::alloc::string::String,
            /// The additional taxonomy group within findings from a given source.
            #[prost(string, tag = "2")]
            pub finding_category: ::prost::alloc::string::String,
            /// Full resource name of the finding.
            #[prost(string, tag = "3")]
            pub name: ::prost::alloc::string::String,
        }
        /// Detailed steps the attack can take between path nodes.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AttackStepNode {
            /// Unique ID for one Node
            #[prost(string, tag = "1")]
            pub uuid: ::prost::alloc::string::String,
            /// Attack step type. Can be either AND, OR or DEFENSE
            #[prost(enumeration = "NodeType", tag = "2")]
            pub r#type: i32,
            /// User friendly name of the attack step
            #[prost(string, tag = "3")]
            pub display_name: ::prost::alloc::string::String,
            /// Attack step labels for metadata
            #[prost(map = "string, string", tag = "4")]
            pub labels: ::std::collections::HashMap<
                ::prost::alloc::string::String,
                ::prost::alloc::string::String,
            >,
            /// Attack step description
            #[prost(string, tag = "5")]
            pub description: ::prost::alloc::string::String,
        }
        /// The type of the incoming attack step node.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum NodeType {
            /// Type not specified
            Unspecified = 0,
            /// Incoming edge joined with AND
            And = 1,
            /// Incoming edge joined with OR
            Or = 2,
            /// Incoming edge is defense
            Defense = 3,
            /// Incoming edge is attacker
            Attacker = 4,
        }
        impl NodeType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "NODE_TYPE_UNSPECIFIED",
                    Self::And => "NODE_TYPE_AND",
                    Self::Or => "NODE_TYPE_OR",
                    Self::Defense => "NODE_TYPE_DEFENSE",
                    Self::Attacker => "NODE_TYPE_ATTACKER",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NODE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "NODE_TYPE_AND" => Some(Self::And),
                    "NODE_TYPE_OR" => Some(Self::Or),
                    "NODE_TYPE_DEFENSE" => Some(Self::Defense),
                    "NODE_TYPE_ATTACKER" => Some(Self::Attacker),
                    _ => None,
                }
            }
        }
    }
    /// Represents a connection between a source node and a destination node in
    /// this attack path.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AttackPathEdge {
        /// The attack node uuid of the source node.
        #[prost(string, tag = "1")]
        pub source: ::prost::alloc::string::String,
        /// The attack node uuid of the destination node.
        #[prost(string, tag = "2")]
        pub destination: ::prost::alloc::string::String,
    }
}
/// Information related to Google Cloud Backup and DR Service findings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupDisasterRecovery {
    /// The name of a Backup and DR template which comprises one or more backup
    /// policies. See the [Backup and DR
    /// documentation](<https://cloud.google.com/backup-disaster-recovery/docs/concepts/backup-plan#temp>)
    /// for more information. For example, `snap-ov`.
    #[prost(string, tag = "1")]
    pub backup_template: ::prost::alloc::string::String,
    /// The names of Backup and DR policies that are associated with a template
    /// and that define when to run a backup, how frequently to run a backup, and
    /// how long to retain the backup image. For example, `onvaults`.
    #[prost(string, repeated, tag = "2")]
    pub policies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The name of a Backup and DR host, which is managed by the backup and
    /// recovery appliance and known to the management console. The host can be of
    /// type Generic (for example, Compute Engine, SQL Server, Oracle DB, SMB file
    /// system, etc.), vCenter, or an ESX server. See the [Backup and DR
    /// documentation on
    /// hosts](<https://cloud.google.com/backup-disaster-recovery/docs/configuration/manage-hosts-and-their-applications>)
    /// for more information. For example, `centos7-01`.
    #[prost(string, tag = "3")]
    pub host: ::prost::alloc::string::String,
    /// The names of Backup and DR applications. An application is a VM, database,
    /// or file system on a managed host monitored by a backup and recovery
    /// appliance. For example, `centos7-01-vol00`, `centos7-01-vol01`,
    /// `centos7-01-vol02`.
    #[prost(string, repeated, tag = "4")]
    pub applications: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The name of the Backup and DR storage pool that the backup and recovery
    /// appliance is storing data in. The storage pool could be of type Cloud,
    /// Primary, Snapshot, or OnVault. See the [Backup and DR documentation on
    /// storage
    /// pools](<https://cloud.google.com/backup-disaster-recovery/docs/concepts/storage-pools>).
    /// For example, `DiskPoolOne`.
    #[prost(string, tag = "5")]
    pub storage_pool: ::prost::alloc::string::String,
    /// The names of Backup and DR advanced policy options of a policy applying to
    /// an application. See the [Backup and DR documentation on policy
    /// options](<https://cloud.google.com/backup-disaster-recovery/docs/create-plan/policy-settings>).
    /// For example, `skipofflineappsincongrp, nounmap`.
    #[prost(string, repeated, tag = "6")]
    pub policy_options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The name of the Backup and DR resource profile that specifies the storage
    /// media for backups of application and VM data. See the [Backup and DR
    /// documentation on
    /// profiles](<https://cloud.google.com/backup-disaster-recovery/docs/concepts/backup-plan#profile>).
    /// For example, `GCP`.
    #[prost(string, tag = "7")]
    pub profile: ::prost::alloc::string::String,
    /// The name of the Backup and DR appliance that captures, moves, and manages
    /// the lifecycle of backup data. For example, `backup-server-57137`.
    #[prost(string, tag = "8")]
    pub appliance: ::prost::alloc::string::String,
    /// The backup type of the Backup and DR image.
    /// For example, `Snapshot`, `Remote Snapshot`, `OnVault`.
    #[prost(string, tag = "9")]
    pub backup_type: ::prost::alloc::string::String,
    /// The timestamp at which the Backup and DR backup was created.
    #[prost(message, optional, tag = "10")]
    pub backup_create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Configures how to deliver Findings to BigQuery Instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQueryExport {
    /// The relative resource name of this export. See:
    /// <https://cloud.google.com/apis/design/resource_names#relative_resource_name.>
    /// Example format:
    /// "organizations/{organization_id}/bigQueryExports/{export_id}" Example
    /// format: "folders/{folder_id}/bigQueryExports/{export_id}" Example format:
    /// "projects/{project_id}/bigQueryExports/{export_id}"
    /// This field is provided in responses, and is ignored when provided in create
    /// requests.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The description of the export (max of 1024 characters).
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Expression that defines the filter to apply across create/update events
    /// of findings. The expression is a list of zero or more restrictions combined
    /// via logical operators `AND` and `OR`. Parentheses are supported, and `OR`
    /// has higher precedence than `AND`.
    ///
    /// Restrictions have the form `<field> <operator> <value>` and may have a
    /// `-` character in front of them to indicate negation. The fields map to
    /// those defined in the corresponding resource.
    ///
    /// The supported operators are:
    ///
    /// * `=` for all value types.
    /// * `>`, `<`, `>=`, `<=` for integer values.
    /// * `:`, meaning substring matching, for strings.
    ///
    /// The supported value types are:
    ///
    /// * string literals in quotes.
    /// * integer literals without quotes.
    /// * boolean literals `true` and `false` without quotes.
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
    /// The dataset to write findings' updates to. Its format is
    /// "projects/\[project_id\]/datasets/\[bigquery_dataset_id\]".
    /// BigQuery Dataset unique ID  must contain only letters (a-z, A-Z), numbers
    /// (0-9), or underscores (_).
    #[prost(string, tag = "4")]
    pub dataset: ::prost::alloc::string::String,
    /// Output only. The time at which the BigQuery export was created.
    /// This field is set by the server and will be ignored if provided on export
    /// on creation.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The most recent time at which the BigQuery export was updated.
    /// This field is set by the server and will be ignored if provided on export
    /// creation or update.
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Email address of the user who last edited the BigQuery export.
    /// This field is set by the server and will be ignored if provided on export
    /// creation or update.
    #[prost(string, tag = "7")]
    pub most_recent_editor: ::prost::alloc::string::String,
    /// Output only. The service account that needs permission to create table and
    /// upload data to the BigQuery dataset.
    #[prost(string, tag = "8")]
    pub principal: ::prost::alloc::string::String,
}
/// Fields related to Google Cloud Armor findings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudArmor {
    /// Information about the [Google Cloud Armor security
    /// policy](<https://cloud.google.com/armor/docs/security-policy-overview>)
    /// relevant to the finding.
    #[prost(message, optional, tag = "1")]
    pub security_policy: ::core::option::Option<SecurityPolicy>,
    /// Information about incoming requests evaluated by [Google Cloud Armor
    /// security
    /// policies](<https://cloud.google.com/armor/docs/security-policy-overview>).
    #[prost(message, optional, tag = "2")]
    pub requests: ::core::option::Option<Requests>,
    /// Information about potential Layer 7 DDoS attacks identified by [Google
    /// Cloud Armor Adaptive
    /// Protection](<https://cloud.google.com/armor/docs/adaptive-protection-overview>).
    #[prost(message, optional, tag = "3")]
    pub adaptive_protection: ::core::option::Option<AdaptiveProtection>,
    /// Information about DDoS attack volume and classification.
    #[prost(message, optional, tag = "4")]
    pub attack: ::core::option::Option<Attack>,
    /// Distinguish between volumetric & protocol DDoS attack and
    /// application layer attacks. For example, "L3_4" for Layer 3 and Layer 4 DDoS
    /// attacks, or "L_7" for Layer 7 DDoS attacks.
    #[prost(string, tag = "5")]
    pub threat_vector: ::prost::alloc::string::String,
    /// Duration of attack from the start until the current moment (updated every 5
    /// minutes).
    #[prost(message, optional, tag = "6")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
}
/// Information about the [Google Cloud Armor security
/// policy](<https://cloud.google.com/armor/docs/security-policy-overview>)
/// relevant to the finding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicy {
    /// The name of the Google Cloud Armor security policy, for example,
    /// "my-security-policy".
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The type of Google Cloud Armor security policy for example, 'backend
    /// security policy', 'edge security policy', 'network edge security policy',
    /// or 'always-on DDoS protection'.
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    /// Whether or not the associated rule or policy is in preview mode.
    #[prost(bool, tag = "3")]
    pub preview: bool,
}
/// Information about the requests relevant to the finding.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Requests {
    /// For 'Increasing deny ratio', the ratio is the denied traffic divided by the
    /// allowed traffic. For 'Allowed traffic spike', the ratio is the allowed
    /// traffic in the short term divided by allowed traffic in the long term.
    #[prost(double, tag = "1")]
    pub ratio: f64,
    /// Allowed RPS (requests per second) in the short term.
    #[prost(int32, tag = "2")]
    pub short_term_allowed: i32,
    /// Allowed RPS (requests per second) over the long term.
    #[prost(int32, tag = "3")]
    pub long_term_allowed: i32,
    /// Denied RPS (requests per second) over the long term.
    #[prost(int32, tag = "4")]
    pub long_term_denied: i32,
}
/// Information about [Google Cloud Armor Adaptive
/// Protection](<https://cloud.google.com/armor/docs/cloud-armor-overview#google-cloud-armor-adaptive-protection>).
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdaptiveProtection {
    /// A score of 0 means that there is low confidence that the detected event is
    /// an actual attack. A score of 1 means that there is high confidence that the
    /// detected event is an attack. See the [Adaptive Protection
    /// documentation](<https://cloud.google.com/armor/docs/adaptive-protection-overview#configure-alert-tuning>)
    /// for further explanation.
    #[prost(double, tag = "1")]
    pub confidence: f64,
}
/// Information about DDoS attack volume and classification.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Attack {
    /// Total PPS (packets per second) volume of attack.
    #[prost(int32, tag = "1")]
    pub volume_pps: i32,
    /// Total BPS (bytes per second) volume of attack.
    #[prost(int32, tag = "2")]
    pub volume_bps: i32,
    /// Type of attack, for example, 'SYN-flood', 'NTP-udp', or 'CHARGEN-udp'.
    #[prost(string, tag = "3")]
    pub classification: ::prost::alloc::string::String,
}
/// The [data profile](<https://cloud.google.com/dlp/docs/data-profiles>)
/// associated with the finding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudDlpDataProfile {
    /// Name of the data profile, for example,
    /// `projects/123/locations/europe/tableProfiles/8383929`.
    #[prost(string, tag = "1")]
    pub data_profile: ::prost::alloc::string::String,
    /// The resource hierarchy level at which the data profile was generated.
    #[prost(enumeration = "cloud_dlp_data_profile::ParentType", tag = "2")]
    pub parent_type: i32,
}
/// Nested message and enum types in `CloudDlpDataProfile`.
pub mod cloud_dlp_data_profile {
    /// Parents for configurations that produce data profile findings.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ParentType {
        /// Unspecified parent type.
        Unspecified = 0,
        /// Organization-level configurations.
        Organization = 1,
        /// Project-level configurations.
        Project = 2,
    }
    impl ParentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PARENT_TYPE_UNSPECIFIED",
                Self::Organization => "ORGANIZATION",
                Self::Project => "PROJECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PARENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ORGANIZATION" => Some(Self::Organization),
                "PROJECT" => Some(Self::Project),
                _ => None,
            }
        }
    }
}
/// Details about the Cloud Data Loss Prevention (Cloud DLP) [inspection
/// job](<https://cloud.google.com/dlp/docs/concepts-job-triggers>) that produced
/// the finding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudDlpInspection {
    /// Name of the inspection job, for example,
    /// `projects/123/locations/europe/dlpJobs/i-8383929`.
    #[prost(string, tag = "1")]
    pub inspect_job: ::prost::alloc::string::String,
    /// The type of information (or
    /// *[infoType](<https://cloud.google.com/dlp/docs/infotypes-reference>)*) found,
    /// for example, `EMAIL_ADDRESS` or `STREET_ADDRESS`.
    #[prost(string, tag = "2")]
    pub info_type: ::prost::alloc::string::String,
    /// The number of times Cloud DLP found this infoType within this job
    /// and resource.
    #[prost(int64, tag = "3")]
    pub info_type_count: i64,
    /// Whether Cloud DLP scanned the complete resource or a sampled subset.
    #[prost(bool, tag = "4")]
    pub full_scan: bool,
}
/// Contains compliance information about a security standard indicating unmet
/// recommendations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Compliance {
    /// Industry-wide compliance standards or benchmarks, such as CIS, PCI, and
    /// OWASP.
    #[prost(string, tag = "1")]
    pub standard: ::prost::alloc::string::String,
    /// Version of the standard or benchmark, for example, 1.1
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// Policies within the standard or benchmark, for example, A.12.4.1
    #[prost(string, repeated, tag = "3")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Contains information about the IP connection associated with the finding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Connection {
    /// Destination IP address. Not present for sockets that are listening and not
    /// connected.
    #[prost(string, tag = "1")]
    pub destination_ip: ::prost::alloc::string::String,
    /// Destination port. Not present for sockets that are listening and not
    /// connected.
    #[prost(int32, tag = "2")]
    pub destination_port: i32,
    /// Source IP address.
    #[prost(string, tag = "3")]
    pub source_ip: ::prost::alloc::string::String,
    /// Source port.
    #[prost(int32, tag = "4")]
    pub source_port: i32,
    /// IANA Internet Protocol Number such as TCP(6) and UDP(17).
    #[prost(enumeration = "connection::Protocol", tag = "5")]
    pub protocol: i32,
}
/// Nested message and enum types in `Connection`.
pub mod connection {
    /// IANA Internet Protocol Number such as TCP(6) and UDP(17).
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Protocol {
        /// Unspecified protocol (not HOPOPT).
        Unspecified = 0,
        /// Internet Control Message Protocol.
        Icmp = 1,
        /// Transmission Control Protocol.
        Tcp = 6,
        /// User Datagram Protocol.
        Udp = 17,
        /// Generic Routing Encapsulation.
        Gre = 47,
        /// Encap Security Payload.
        Esp = 50,
    }
    impl Protocol {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROTOCOL_UNSPECIFIED",
                Self::Icmp => "ICMP",
                Self::Tcp => "TCP",
                Self::Udp => "UDP",
                Self::Gre => "GRE",
                Self::Esp => "ESP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROTOCOL_UNSPECIFIED" => Some(Self::Unspecified),
                "ICMP" => Some(Self::Icmp),
                "TCP" => Some(Self::Tcp),
                "UDP" => Some(Self::Udp),
                "GRE" => Some(Self::Gre),
                "ESP" => Some(Self::Esp),
                _ => None,
            }
        }
    }
}
/// Details about specific contacts
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContactDetails {
    /// A list of contacts
    #[prost(message, repeated, tag = "1")]
    pub contacts: ::prost::alloc::vec::Vec<Contact>,
}
/// The email address of a contact.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Contact {
    /// An email address. For example, "`person123@company.com`".
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
}
/// Represents a generic name-value label. A label has separate name and value
/// fields to support filtering with the `contains()` function. For more
/// information, see [Filtering on array-type
/// fields](<https://cloud.google.com/security-command-center/docs/how-to-api-list-findings#array-contains-filtering>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Label {
    /// Name of the label.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Value that corresponds to the label's name.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// Container associated with the finding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Container {
    /// Name of the container.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Container image URI provided when configuring a pod or container. This
    /// string can identify a container image version using mutable tags.
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    /// Optional container image ID, if provided by the container runtime. Uniquely
    /// identifies the container image launched using a container image digest.
    #[prost(string, tag = "3")]
    pub image_id: ::prost::alloc::string::String,
    /// Container labels, as provided by the container runtime.
    #[prost(message, repeated, tag = "4")]
    pub labels: ::prost::alloc::vec::Vec<Label>,
    /// The time that the container was created.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Represents database access information, such as queries. A database may be a
/// sub-resource of an instance (as in the case of Cloud SQL instances or Cloud
/// Spanner instances), or the database instance itself. Some database resources
/// might not have the [full resource
/// name](<https://google.aip.dev/122#full-resource-names>) populated because these
/// resource types, such as Cloud SQL databases, are not yet supported by Cloud
/// Asset Inventory. In these cases only the display name is provided.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Database {
    /// Some database resources may not have the [full resource
    /// name](<https://google.aip.dev/122#full-resource-names>) populated because
    /// these resource types are not yet supported by Cloud Asset Inventory (e.g.
    /// Cloud SQL databases). In these cases only the display name will be
    /// provided.
    /// The [full resource name](<https://google.aip.dev/122#full-resource-names>) of
    /// the database that the user connected to, if it is supported by Cloud Asset
    /// Inventory.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The human-readable name of the database that the user connected to.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// The username used to connect to the database. The username might not be an
    /// IAM principal and does not have a set format.
    #[prost(string, tag = "3")]
    pub user_name: ::prost::alloc::string::String,
    /// The SQL statement that is associated with the database access.
    #[prost(string, tag = "4")]
    pub query: ::prost::alloc::string::String,
    /// The target usernames, roles, or groups of an SQL privilege grant, which is
    /// not an IAM policy change.
    #[prost(string, repeated, tag = "5")]
    pub grantees: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The version of the database, for example, POSTGRES_14.
    /// See [the complete
    /// list](<https://cloud.google.com/sql/docs/mysql/admin-api/rest/v1/SqlDatabaseVersion>).
    #[prost(string, tag = "6")]
    pub version: ::prost::alloc::string::String,
}
/// An EffectiveEventThreatDetectionCustomModule is the representation of
/// an Event Threat Detection custom module at a specified level of the
/// resource hierarchy: organization, folder, or project. If a custom module is
/// inherited from a parent organization or folder, the value of the
/// `enablement_state` property in EffectiveEventThreatDetectionCustomModule is
/// set to the value that is effective in the parent, instead of `INHERITED`.
/// For example, if the module is enabled in a parent organization or folder, the
/// effective `enablement_state` for the module in all child folders or projects
/// is also `enabled`. EffectiveEventThreatDetectionCustomModule is read-only.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EffectiveEventThreatDetectionCustomModule {
    /// Output only. The resource name of the effective ETD custom module.
    ///
    /// Its format is:
    ///
    ///    * `organizations/{organization}/eventThreatDetectionSettings/effectiveCustomModules/{module}`.
    ///    * `folders/{folder}/eventThreatDetectionSettings/effectiveCustomModules/{module}`.
    ///    * `projects/{project}/eventThreatDetectionSettings/effectiveCustomModules/{module}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Config for the effective module.
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<::prost_types::Struct>,
    /// Output only. The effective state of enablement for the module at the given
    /// level of the hierarchy.
    #[prost(
        enumeration = "effective_event_threat_detection_custom_module::EnablementState",
        tag = "3"
    )]
    pub enablement_state: i32,
    /// Output only. Type for the module. e.g. CONFIGURABLE_BAD_IP.
    #[prost(string, tag = "4")]
    pub r#type: ::prost::alloc::string::String,
    /// Output only. The human readable name to be displayed for the module.
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The description for the module.
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `EffectiveEventThreatDetectionCustomModule`.
pub mod effective_event_threat_detection_custom_module {
    /// The enablement state of the module.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnablementState {
        /// Unspecified enablement state.
        Unspecified = 0,
        /// The module is enabled at the given level.
        Enabled = 1,
        /// The module is disabled at the given level.
        Disabled = 2,
    }
    impl EnablementState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ENABLEMENT_STATE_UNSPECIFIED",
                Self::Enabled => "ENABLED",
                Self::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENABLEMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
/// Defines the properties in a custom module configuration for Security
/// Health Analytics. Use the custom module configuration to create custom
/// detectors that generate custom findings for resources that you specify.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomConfig {
    /// The CEL expression to evaluate to produce findings. When the expression
    /// evaluates to true against a resource, a finding is generated.
    #[prost(message, optional, tag = "1")]
    pub predicate: ::core::option::Option<super::super::super::r#type::Expr>,
    /// Custom output properties.
    #[prost(message, optional, tag = "2")]
    pub custom_output: ::core::option::Option<custom_config::CustomOutputSpec>,
    /// The resource types that the custom module operates on. Each custom module
    /// can specify up to 5 resource types.
    #[prost(message, optional, tag = "3")]
    pub resource_selector: ::core::option::Option<custom_config::ResourceSelector>,
    /// The severity to assign to findings generated by the module.
    #[prost(enumeration = "custom_config::Severity", tag = "4")]
    pub severity: i32,
    /// Text that describes the vulnerability or misconfiguration that the custom
    /// module detects. This explanation is returned with each finding instance to
    /// help investigators understand the detected issue. The text must be enclosed
    /// in quotation marks.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// An explanation of the recommended steps that security teams can take to
    /// resolve the detected issue. This explanation is returned with each finding
    /// generated by this module in the `nextSteps` property of the finding JSON.
    #[prost(string, tag = "6")]
    pub recommendation: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CustomConfig`.
pub mod custom_config {
    /// A set of optional name-value pairs that define custom source properties to
    /// return with each finding that is generated by the custom module. The custom
    /// source properties that are defined here are included in the finding JSON
    /// under `sourceProperties`.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CustomOutputSpec {
        /// A list of custom output properties to add to the finding.
        #[prost(message, repeated, tag = "1")]
        pub properties: ::prost::alloc::vec::Vec<custom_output_spec::Property>,
    }
    /// Nested message and enum types in `CustomOutputSpec`.
    pub mod custom_output_spec {
        /// An individual name-value pair that defines a custom source property.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Property {
            /// Name of the property for the custom output.
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            /// The CEL expression for the custom output. A resource property can be
            /// specified to return the value of the property or a text string enclosed
            /// in quotation marks.
            #[prost(message, optional, tag = "2")]
            pub value_expression: ::core::option::Option<
                super::super::super::super::super::r#type::Expr,
            >,
        }
    }
    /// Resource for selecting resource type.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResourceSelector {
        /// The resource types to run the detector on.
        #[prost(string, repeated, tag = "1")]
        pub resource_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Defines the valid value options for the severity of a finding.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Severity {
        /// Unspecified severity.
        Unspecified = 0,
        /// Critical severity.
        Critical = 1,
        /// High severity.
        High = 2,
        /// Medium severity.
        Medium = 3,
        /// Low severity.
        Low = 4,
    }
    impl Severity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SEVERITY_UNSPECIFIED",
                Self::Critical => "CRITICAL",
                Self::High => "HIGH",
                Self::Medium => "MEDIUM",
                Self::Low => "LOW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
                "CRITICAL" => Some(Self::Critical),
                "HIGH" => Some(Self::High),
                "MEDIUM" => Some(Self::Medium),
                "LOW" => Some(Self::Low),
                _ => None,
            }
        }
    }
}
/// An EffectiveSecurityHealthAnalyticsCustomModule is the representation of
/// a Security Health Analytics custom module at a specified level of the
/// resource hierarchy: organization, folder, or project. If a custom module is
/// inherited from a parent organization or folder, the value of the
/// `enablementState` property in EffectiveSecurityHealthAnalyticsCustomModule is
/// set to the value that is effective in the parent, instead of  `INHERITED`.
/// For example, if the module is enabled in a parent organization or folder, the
/// effective enablement_state for the module in all child folders or projects is
/// also `enabled`. EffectiveSecurityHealthAnalyticsCustomModule is read-only.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EffectiveSecurityHealthAnalyticsCustomModule {
    /// Output only. The resource name of the custom module.
    /// Its format is
    /// "organizations/{organization}/securityHealthAnalyticsSettings/effectiveCustomModules/{customModule}",
    /// or
    /// "folders/{folder}/securityHealthAnalyticsSettings/effectiveCustomModules/{customModule}",
    /// or
    /// "projects/{project}/securityHealthAnalyticsSettings/effectiveCustomModules/{customModule}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The user-specified configuration for the module.
    #[prost(message, optional, tag = "2")]
    pub custom_config: ::core::option::Option<CustomConfig>,
    /// Output only. The effective state of enablement for the module at the given
    /// level of the hierarchy.
    #[prost(
        enumeration = "effective_security_health_analytics_custom_module::EnablementState",
        tag = "3"
    )]
    pub enablement_state: i32,
    /// Output only. The display name for the custom module. The name must be
    /// between 1 and 128 characters, start with a lowercase letter, and contain
    /// alphanumeric characters or underscores only.
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `EffectiveSecurityHealthAnalyticsCustomModule`.
pub mod effective_security_health_analytics_custom_module {
    /// The enablement state of the module.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnablementState {
        /// Unspecified enablement state.
        Unspecified = 0,
        /// The module is enabled at the given level.
        Enabled = 1,
        /// The module is disabled at the given level.
        Disabled = 2,
    }
    impl EnablementState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ENABLEMENT_STATE_UNSPECIFIED",
                Self::Enabled => "ENABLED",
                Self::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENABLEMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
/// Represents an instance of an Event Threat Detection custom module,
/// including its full module name, display name, enablement state, and last
/// updated time. You can create a custom module at the organization, folder, or
/// project level. Custom modules that you create at the organization or folder
/// level are inherited by child folders and projects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventThreatDetectionCustomModule {
    /// Immutable. The resource name of the Event Threat Detection custom module.
    ///
    /// Its format is:
    ///
    ///    * `organizations/{organization}/eventThreatDetectionSettings/customModules/{module}`.
    ///    * `folders/{folder}/eventThreatDetectionSettings/customModules/{module}`.
    ///    * `projects/{project}/eventThreatDetectionSettings/customModules/{module}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Config for the module. For the resident module, its config value is defined
    /// at this level. For the inherited module, its config value is inherited from
    /// the ancestor module.
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<::prost_types::Struct>,
    /// Output only. The closest ancestor module that this module inherits the
    /// enablement state from. The format is the same as the
    /// EventThreatDetectionCustomModule resource name.
    #[prost(string, tag = "3")]
    pub ancestor_module: ::prost::alloc::string::String,
    /// The state of enablement for the module at the given level of the hierarchy.
    #[prost(
        enumeration = "event_threat_detection_custom_module::EnablementState",
        tag = "4"
    )]
    pub enablement_state: i32,
    /// Type for the module. e.g. CONFIGURABLE_BAD_IP.
    #[prost(string, tag = "5")]
    pub r#type: ::prost::alloc::string::String,
    /// The human readable name to be displayed for the module.
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    /// The description for the module.
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The time the module was last updated.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The editor the module was last updated by.
    #[prost(string, tag = "9")]
    pub last_editor: ::prost::alloc::string::String,
}
/// Nested message and enum types in `EventThreatDetectionCustomModule`.
pub mod event_threat_detection_custom_module {
    /// The enablement state of the module.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnablementState {
        /// Unspecified enablement state.
        Unspecified = 0,
        /// The module is enabled at the given level.
        Enabled = 1,
        /// The module is disabled at the given level.
        Disabled = 2,
        /// When the enablement state is inherited.
        Inherited = 3,
    }
    impl EnablementState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ENABLEMENT_STATE_UNSPECIFIED",
                Self::Enabled => "ENABLED",
                Self::Disabled => "DISABLED",
                Self::Inherited => "INHERITED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENABLEMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                "INHERITED" => Some(Self::Inherited),
                _ => None,
            }
        }
    }
}
/// A list of zero or more errors encountered while validating the uploaded
/// configuration of an Event Threat Detection Custom Module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomModuleValidationErrors {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<CustomModuleValidationError>,
}
/// An error encountered while validating the uploaded configuration of an
/// Event Threat Detection Custom Module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomModuleValidationError {
    /// A description of the error, suitable for human consumption. Required.
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    /// The path, in RFC 8901 JSON Pointer format, to the field that failed
    /// validation. This may be left empty if no specific field is affected.
    #[prost(string, tag = "2")]
    pub field_path: ::prost::alloc::string::String,
    /// The initial position of the error in the uploaded text version of the
    /// module. This field may be omitted if no specific position applies, or if
    /// one could not be computed.
    #[prost(message, optional, tag = "3")]
    pub start: ::core::option::Option<Position>,
    /// The end position of the error in the uploaded text version of the
    /// module. This field may be omitted if no specific position applies, or if
    /// one could not be computed..
    #[prost(message, optional, tag = "4")]
    pub end: ::core::option::Option<Position>,
}
/// A position in the uploaded text version of a module.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Position {
    #[prost(int32, tag = "1")]
    pub line_number: i32,
    #[prost(int32, tag = "2")]
    pub column_number: i32,
}
/// Exfiltration represents a data exfiltration attempt from one or more sources
/// to one or more targets. The `sources` attribute lists the sources of the
/// exfiltrated data. The `targets` attribute lists the destinations the data was
/// copied to.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Exfiltration {
    /// If there are multiple sources, then the data is considered "joined" between
    /// them. For instance, BigQuery can join multiple tables, and each
    /// table would be considered a source.
    #[prost(message, repeated, tag = "1")]
    pub sources: ::prost::alloc::vec::Vec<ExfilResource>,
    /// If there are multiple targets, each target would get a complete copy of the
    /// "joined" source data.
    #[prost(message, repeated, tag = "2")]
    pub targets: ::prost::alloc::vec::Vec<ExfilResource>,
    /// Total exfiltrated bytes processed for the entire job.
    #[prost(int64, tag = "3")]
    pub total_exfiltrated_bytes: i64,
}
/// Resource where data was exfiltrated from or exfiltrated to.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExfilResource {
    /// The resource's [full resource
    /// name](<https://cloud.google.com/apis/design/resource_names#full_resource_name>).
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Subcomponents of the asset that was exfiltrated, like URIs used during
    /// exfiltration, table names, databases, and filenames. For example, multiple
    /// tables might have been exfiltrated from the same Cloud SQL instance, or
    /// multiple files might have been exfiltrated from the same Cloud Storage
    /// bucket.
    #[prost(string, repeated, tag = "2")]
    pub components: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Representation of third party SIEM/SOAR fields within SCC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalSystem {
    /// Full resource name of the external system, for example:
    /// "organizations/1234/sources/5678/findings/123456/externalSystems/jira",
    /// "folders/1234/sources/5678/findings/123456/externalSystems/jira",
    /// "projects/1234/sources/5678/findings/123456/externalSystems/jira"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// References primary/secondary etc assignees in the external system.
    #[prost(string, repeated, tag = "2")]
    pub assignees: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The identifier that's used to track the finding's corresponding case in the
    /// external system.
    #[prost(string, tag = "3")]
    pub external_uid: ::prost::alloc::string::String,
    /// The most recent status of the finding's corresponding case, as reported by
    /// the external system.
    #[prost(string, tag = "4")]
    pub status: ::prost::alloc::string::String,
    /// The time when the case was last updated, as reported by the external
    /// system.
    #[prost(message, optional, tag = "5")]
    pub external_system_update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The link to the finding's corresponding case in the external system.
    #[prost(string, tag = "6")]
    pub case_uri: ::prost::alloc::string::String,
    /// The priority of the finding's corresponding case in the external system.
    #[prost(string, tag = "7")]
    pub case_priority: ::prost::alloc::string::String,
    /// The SLA of the finding's corresponding case in the external system.
    #[prost(message, optional, tag = "9")]
    pub case_sla: ::core::option::Option<::prost_types::Timestamp>,
    /// The time when the case was created, as reported by the external system.
    #[prost(message, optional, tag = "10")]
    pub case_create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time when the case was closed, as reported by the external system.
    #[prost(message, optional, tag = "11")]
    pub case_close_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Information about the ticket, if any, that is being used to track the
    /// resolution of the issue that is identified by this finding.
    #[prost(message, optional, tag = "8")]
    pub ticket_info: ::core::option::Option<external_system::TicketInfo>,
}
/// Nested message and enum types in `ExternalSystem`.
pub mod external_system {
    /// Information about the ticket, if any, that is being used to track the
    /// resolution of the issue that is identified by this finding.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TicketInfo {
        /// The identifier of the ticket in the ticket system.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// The assignee of the ticket in the ticket system.
        #[prost(string, tag = "2")]
        pub assignee: ::prost::alloc::string::String,
        /// The description of the ticket in the ticket system.
        #[prost(string, tag = "3")]
        pub description: ::prost::alloc::string::String,
        /// The link to the ticket in the ticket system.
        #[prost(string, tag = "4")]
        pub uri: ::prost::alloc::string::String,
        /// The latest status of the ticket, as reported by the ticket system.
        #[prost(string, tag = "5")]
        pub status: ::prost::alloc::string::String,
        /// The time when the ticket was last updated, as reported by the ticket
        /// system.
        #[prost(message, optional, tag = "6")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    }
}
/// File information about the related binary/library used by an executable, or
/// the script used by a script interpreter
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct File {
    /// Absolute path of the file as a JSON encoded string.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// Size of the file in bytes.
    #[prost(int64, tag = "2")]
    pub size: i64,
    /// SHA256 hash of the first hashed_size bytes of the file encoded as a
    /// hex string.  If hashed_size == size, sha256 represents the SHA256 hash
    /// of the entire file.
    #[prost(string, tag = "3")]
    pub sha256: ::prost::alloc::string::String,
    /// The length in bytes of the file prefix that was hashed.  If
    /// hashed_size == size, any hashes reported represent the entire
    /// file.
    #[prost(int64, tag = "4")]
    pub hashed_size: i64,
    /// True when the hash covers only a prefix of the file.
    #[prost(bool, tag = "5")]
    pub partially_hashed: bool,
    /// Prefix of the file contents as a JSON-encoded string.
    #[prost(string, tag = "6")]
    pub contents: ::prost::alloc::string::String,
    /// Path of the file in terms of underlying disk/partition identifiers.
    #[prost(message, optional, tag = "7")]
    pub disk_path: ::core::option::Option<file::DiskPath>,
}
/// Nested message and enum types in `File`.
pub mod file {
    /// Path of the file in terms of underlying disk/partition identifiers.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DiskPath {
        /// UUID of the partition (format
        /// <https://wiki.archlinux.org/title/persistent_block_device_naming#by-uuid>)
        #[prost(string, tag = "1")]
        pub partition_uuid: ::prost::alloc::string::String,
        /// Relative path of the file in the partition as a JSON encoded string.
        /// Example: /home/user1/executable_file.sh
        #[prost(string, tag = "2")]
        pub relative_path: ::prost::alloc::string::String,
    }
}
/// Contains details about groups of which this finding is a member. A group is a
/// collection of findings that are related in some way.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupMembership {
    /// Type of group.
    #[prost(enumeration = "group_membership::GroupType", tag = "1")]
    pub group_type: i32,
    /// ID of the group.
    #[prost(string, tag = "2")]
    pub group_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `GroupMembership`.
pub mod group_membership {
    /// Possible types of groups.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GroupType {
        /// Default value.
        Unspecified = 0,
        /// Group represents a toxic combination.
        ToxicCombination = 1,
    }
    impl GroupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "GROUP_TYPE_UNSPECIFIED",
                Self::ToxicCombination => "GROUP_TYPE_TOXIC_COMBINATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GROUP_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "GROUP_TYPE_TOXIC_COMBINATION" => Some(Self::ToxicCombination),
                _ => None,
            }
        }
    }
}
/// Represents a particular IAM binding, which captures a member's role addition,
/// removal, or state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IamBinding {
    /// The action that was performed on a Binding.
    #[prost(enumeration = "iam_binding::Action", tag = "1")]
    pub action: i32,
    /// Role that is assigned to "members".
    /// For example, "roles/viewer", "roles/editor", or "roles/owner".
    #[prost(string, tag = "2")]
    pub role: ::prost::alloc::string::String,
    /// A single identity requesting access for a Cloud Platform resource, for
    /// example, "foo@google.com".
    #[prost(string, tag = "3")]
    pub member: ::prost::alloc::string::String,
}
/// Nested message and enum types in `IamBinding`.
pub mod iam_binding {
    /// The type of action performed on a Binding in a policy.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        /// Unspecified.
        Unspecified = 0,
        /// Addition of a Binding.
        Add = 1,
        /// Removal of a Binding.
        Remove = 2,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ACTION_UNSPECIFIED",
                Self::Add => "ADD",
                Self::Remove => "REMOVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "ADD" => Some(Self::Add),
                "REMOVE" => Some(Self::Remove),
                _ => None,
            }
        }
    }
}
/// Represents what's commonly known as an _indicator of compromise_ (IoC) in
/// computer forensics. This is an artifact observed on a network or in an
/// operating system that, with high confidence, indicates a computer intrusion.
/// For more information, see [Indicator of
/// compromise](<https://en.wikipedia.org/wiki/Indicator_of_compromise>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Indicator {
    /// The list of IP addresses that are associated with the finding.
    #[prost(string, repeated, tag = "1")]
    pub ip_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of domains associated to the Finding.
    #[prost(string, repeated, tag = "2")]
    pub domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The list of matched signatures indicating that the given
    /// process is present in the environment.
    #[prost(message, repeated, tag = "3")]
    pub signatures: ::prost::alloc::vec::Vec<indicator::ProcessSignature>,
    /// The list of URIs associated to the Findings.
    #[prost(string, repeated, tag = "4")]
    pub uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Indicator`.
pub mod indicator {
    /// Indicates what signature matched this process.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProcessSignature {
        /// Describes the type of resource associated with the signature.
        #[prost(enumeration = "process_signature::SignatureType", tag = "8")]
        pub signature_type: i32,
        #[prost(oneof = "process_signature::Signature", tags = "6, 7")]
        pub signature: ::core::option::Option<process_signature::Signature>,
    }
    /// Nested message and enum types in `ProcessSignature`.
    pub mod process_signature {
        /// A signature corresponding to memory page hashes.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MemoryHashSignature {
            /// The binary family.
            #[prost(string, tag = "1")]
            pub binary_family: ::prost::alloc::string::String,
            /// The list of memory hash detections contributing to the binary family
            /// match.
            #[prost(message, repeated, tag = "4")]
            pub detections: ::prost::alloc::vec::Vec<memory_hash_signature::Detection>,
        }
        /// Nested message and enum types in `MemoryHashSignature`.
        pub mod memory_hash_signature {
            /// Memory hash detection contributing to the binary family match.
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Detection {
                /// The name of the binary associated with the memory hash
                /// signature detection.
                #[prost(string, tag = "2")]
                pub binary: ::prost::alloc::string::String,
                /// The percentage of memory page hashes in the signature
                /// that were matched.
                #[prost(double, tag = "3")]
                pub percent_pages_matched: f64,
            }
        }
        /// A signature corresponding to a YARA rule.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct YaraRuleSignature {
            /// The name of the YARA rule.
            #[prost(string, tag = "5")]
            pub yara_rule: ::prost::alloc::string::String,
        }
        /// Possible resource types to be associated with a signature.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SignatureType {
            /// The default signature type.
            Unspecified = 0,
            /// Used for signatures concerning processes.
            Process = 1,
            /// Used for signatures concerning disks.
            File = 2,
        }
        impl SignatureType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SIGNATURE_TYPE_UNSPECIFIED",
                    Self::Process => "SIGNATURE_TYPE_PROCESS",
                    Self::File => "SIGNATURE_TYPE_FILE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SIGNATURE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SIGNATURE_TYPE_PROCESS" => Some(Self::Process),
                    "SIGNATURE_TYPE_FILE" => Some(Self::File),
                    _ => None,
                }
            }
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Signature {
            /// Signature indicating that a binary family was matched.
            #[prost(message, tag = "6")]
            MemoryHashSignature(MemoryHashSignature),
            /// Signature indicating that a YARA rule was matched.
            #[prost(message, tag = "7")]
            YaraRuleSignature(YaraRuleSignature),
        }
    }
}
/// Kernel mode rootkit signatures.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelRootkit {
    /// Rootkit name, when available.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// True if unexpected modifications of kernel code memory are present.
    #[prost(bool, tag = "2")]
    pub unexpected_code_modification: bool,
    /// True if unexpected modifications of kernel read-only data memory are
    /// present.
    #[prost(bool, tag = "3")]
    pub unexpected_read_only_data_modification: bool,
    /// True if `ftrace` points are present with callbacks pointing to regions
    /// that are not in the expected kernel or module code range.
    #[prost(bool, tag = "4")]
    pub unexpected_ftrace_handler: bool,
    /// True if `kprobe` points are present with callbacks pointing to regions
    /// that are not in the expected kernel or module code range.
    #[prost(bool, tag = "5")]
    pub unexpected_kprobe_handler: bool,
    /// True if kernel code pages that are not in the expected kernel or module
    /// code regions are present.
    #[prost(bool, tag = "6")]
    pub unexpected_kernel_code_pages: bool,
    /// True if system call handlers that are are not in the expected kernel or
    /// module code regions are present.
    #[prost(bool, tag = "7")]
    pub unexpected_system_call_handler: bool,
    /// True if interrupt handlers that are are not in the expected kernel or
    /// module code regions are present.
    #[prost(bool, tag = "8")]
    pub unexpected_interrupt_handler: bool,
    /// True if unexpected processes in the scheduler run queue are present. Such
    /// processes are in the run queue, but not in the process task list.
    #[prost(bool, tag = "9")]
    pub unexpected_processes_in_runqueue: bool,
}
/// Kubernetes-related attributes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Kubernetes {
    /// Kubernetes
    /// [Pods](<https://cloud.google.com/kubernetes-engine/docs/concepts/pod>)
    /// associated with the finding. This field contains Pod records for each
    /// container that is owned by a Pod.
    #[prost(message, repeated, tag = "1")]
    pub pods: ::prost::alloc::vec::Vec<kubernetes::Pod>,
    /// Provides Kubernetes
    /// [node](<https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-architecture#nodes>)
    /// information.
    #[prost(message, repeated, tag = "2")]
    pub nodes: ::prost::alloc::vec::Vec<kubernetes::Node>,
    /// GKE [node
    /// pools](<https://cloud.google.com/kubernetes-engine/docs/concepts/node-pools>)
    /// associated with the finding. This field contains node pool information for
    /// each node, when it is available.
    #[prost(message, repeated, tag = "3")]
    pub node_pools: ::prost::alloc::vec::Vec<kubernetes::NodePool>,
    /// Provides Kubernetes role information for findings that involve [Roles or
    /// ClusterRoles](<https://cloud.google.com/kubernetes-engine/docs/how-to/role-based-access-control>).
    #[prost(message, repeated, tag = "4")]
    pub roles: ::prost::alloc::vec::Vec<kubernetes::Role>,
    /// Provides Kubernetes role binding information for findings that involve
    /// [RoleBindings or
    /// ClusterRoleBindings](<https://cloud.google.com/kubernetes-engine/docs/how-to/role-based-access-control>).
    #[prost(message, repeated, tag = "5")]
    pub bindings: ::prost::alloc::vec::Vec<kubernetes::Binding>,
    /// Provides information on any Kubernetes access reviews (privilege checks)
    /// relevant to the finding.
    #[prost(message, repeated, tag = "6")]
    pub access_reviews: ::prost::alloc::vec::Vec<kubernetes::AccessReview>,
    /// Kubernetes objects related to the finding.
    #[prost(message, repeated, tag = "7")]
    pub objects: ::prost::alloc::vec::Vec<kubernetes::Object>,
}
/// Nested message and enum types in `Kubernetes`.
pub mod kubernetes {
    /// A Kubernetes Pod.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Pod {
        /// Kubernetes Pod namespace.
        #[prost(string, tag = "1")]
        pub ns: ::prost::alloc::string::String,
        /// Kubernetes Pod name.
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        /// Pod labels.  For Kubernetes containers, these are applied to the
        /// container.
        #[prost(message, repeated, tag = "3")]
        pub labels: ::prost::alloc::vec::Vec<super::Label>,
        /// Pod containers associated with this finding, if any.
        #[prost(message, repeated, tag = "4")]
        pub containers: ::prost::alloc::vec::Vec<super::Container>,
    }
    /// Kubernetes nodes associated with the finding.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Node {
        /// [Full resource name](<https://google.aip.dev/122#full-resource-names>) of
        /// the Compute Engine VM running the cluster node.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
    }
    /// Provides GKE node pool information.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NodePool {
        /// Kubernetes node pool name.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Nodes associated with the finding.
        #[prost(message, repeated, tag = "2")]
        pub nodes: ::prost::alloc::vec::Vec<Node>,
    }
    /// Kubernetes Role or ClusterRole.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Role {
        /// Role type.
        #[prost(enumeration = "role::Kind", tag = "1")]
        pub kind: i32,
        /// Role namespace.
        #[prost(string, tag = "2")]
        pub ns: ::prost::alloc::string::String,
        /// Role name.
        #[prost(string, tag = "3")]
        pub name: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `Role`.
    pub mod role {
        /// Types of Kubernetes roles.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Kind {
            /// Role type is not specified.
            Unspecified = 0,
            /// Kubernetes Role.
            Role = 1,
            /// Kubernetes ClusterRole.
            ClusterRole = 2,
        }
        impl Kind {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "KIND_UNSPECIFIED",
                    Self::Role => "ROLE",
                    Self::ClusterRole => "CLUSTER_ROLE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "KIND_UNSPECIFIED" => Some(Self::Unspecified),
                    "ROLE" => Some(Self::Role),
                    "CLUSTER_ROLE" => Some(Self::ClusterRole),
                    _ => None,
                }
            }
        }
    }
    /// Represents a Kubernetes RoleBinding or ClusterRoleBinding.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Binding {
        /// Namespace for the binding.
        #[prost(string, tag = "1")]
        pub ns: ::prost::alloc::string::String,
        /// Name for the binding.
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        /// The Role or ClusterRole referenced by the binding.
        #[prost(message, optional, tag = "3")]
        pub role: ::core::option::Option<Role>,
        /// Represents one or more subjects that are bound to the role. Not always
        /// available for PATCH requests.
        #[prost(message, repeated, tag = "4")]
        pub subjects: ::prost::alloc::vec::Vec<Subject>,
    }
    /// Represents a Kubernetes subject.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Subject {
        /// Authentication type for the subject.
        #[prost(enumeration = "subject::AuthType", tag = "1")]
        pub kind: i32,
        /// Namespace for the subject.
        #[prost(string, tag = "2")]
        pub ns: ::prost::alloc::string::String,
        /// Name for the subject.
        #[prost(string, tag = "3")]
        pub name: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `Subject`.
    pub mod subject {
        /// Auth types that can be used for the subject's kind field.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum AuthType {
            /// Authentication is not specified.
            Unspecified = 0,
            /// User with valid certificate.
            User = 1,
            /// Users managed by Kubernetes API with credentials stored as secrets.
            Serviceaccount = 2,
            /// Collection of users.
            Group = 3,
        }
        impl AuthType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "AUTH_TYPE_UNSPECIFIED",
                    Self::User => "USER",
                    Self::Serviceaccount => "SERVICEACCOUNT",
                    Self::Group => "GROUP",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "AUTH_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "USER" => Some(Self::User),
                    "SERVICEACCOUNT" => Some(Self::Serviceaccount),
                    "GROUP" => Some(Self::Group),
                    _ => None,
                }
            }
        }
    }
    /// Conveys information about a Kubernetes access review (such as one returned
    /// by a [`kubectl auth
    /// can-i`](<https://kubernetes.io/docs/reference/access-authn-authz/authorization/#checking-api-access>)
    /// command) that was involved in a finding.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AccessReview {
        /// The API group of the resource. "*" means all.
        #[prost(string, tag = "1")]
        pub group: ::prost::alloc::string::String,
        /// Namespace of the action being requested. Currently, there is no
        /// distinction between no namespace and all namespaces.  Both
        /// are represented by "" (empty).
        #[prost(string, tag = "2")]
        pub ns: ::prost::alloc::string::String,
        /// The name of the resource being requested. Empty means all.
        #[prost(string, tag = "3")]
        pub name: ::prost::alloc::string::String,
        /// The optional resource type requested. "*" means all.
        #[prost(string, tag = "4")]
        pub resource: ::prost::alloc::string::String,
        /// The optional subresource type.
        #[prost(string, tag = "5")]
        pub subresource: ::prost::alloc::string::String,
        /// A Kubernetes resource API verb, like get, list, watch, create, update,
        /// delete, proxy. "*" means all.
        #[prost(string, tag = "6")]
        pub verb: ::prost::alloc::string::String,
        /// The API version of the resource. "*" means all.
        #[prost(string, tag = "7")]
        pub version: ::prost::alloc::string::String,
    }
    /// Kubernetes object related to the finding, uniquely identified by GKNN.
    /// Used if the object Kind is not one of Pod, Node, NodePool, Binding, or
    /// AccessReview.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Object {
        /// Kubernetes object group, such as "policy.k8s.io/v1".
        #[prost(string, tag = "1")]
        pub group: ::prost::alloc::string::String,
        /// Kubernetes object kind, such as "Namespace".
        #[prost(string, tag = "2")]
        pub kind: ::prost::alloc::string::String,
        /// Kubernetes object namespace. Must be a valid DNS label. Named
        /// "ns" to avoid collision with C++ namespace keyword. For details see
        /// <https://kubernetes.io/docs/tasks/administer-cluster/namespaces/.>
        #[prost(string, tag = "3")]
        pub ns: ::prost::alloc::string::String,
        /// Kubernetes object name. For details see
        /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/names/.>
        #[prost(string, tag = "4")]
        pub name: ::prost::alloc::string::String,
        /// Pod containers associated with this finding, if any.
        #[prost(message, repeated, tag = "5")]
        pub containers: ::prost::alloc::vec::Vec<super::Container>,
    }
}
/// Contains information related to the load balancer associated with the
/// finding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadBalancer {
    /// The name of the load balancer associated with the finding.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// An individual entry in a log.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogEntry {
    #[prost(oneof = "log_entry::LogEntry", tags = "1")]
    pub log_entry: ::core::option::Option<log_entry::LogEntry>,
}
/// Nested message and enum types in `LogEntry`.
pub mod log_entry {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum LogEntry {
        /// An individual entry in a log stored in Cloud Logging.
        #[prost(message, tag = "1")]
        CloudLoggingEntry(super::CloudLoggingEntry),
    }
}
/// Metadata taken from a [Cloud Logging
/// LogEntry](<https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry>)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudLoggingEntry {
    /// A unique identifier for the log entry.
    #[prost(string, tag = "1")]
    pub insert_id: ::prost::alloc::string::String,
    /// The type of the log (part of `log_name`. `log_name` is the resource name of
    /// the log to which this log entry belongs). For example:
    /// `cloudresourcemanager.googleapis.com/activity`. Note that this field is not
    /// URL-encoded, unlike the `LOG_ID` field in `LogEntry`.
    #[prost(string, tag = "2")]
    pub log_id: ::prost::alloc::string::String,
    /// The organization, folder, or project of the monitored resource that
    /// produced this log entry.
    #[prost(string, tag = "3")]
    pub resource_container: ::prost::alloc::string::String,
    /// The time the event described by the log entry occurred.
    #[prost(message, optional, tag = "4")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
/// MITRE ATT&CK tactics and techniques related to this finding.
/// See: <https://attack.mitre.org>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MitreAttack {
    /// The MITRE ATT&CK tactic most closely represented by this finding, if any.
    #[prost(enumeration = "mitre_attack::Tactic", tag = "1")]
    pub primary_tactic: i32,
    /// The MITRE ATT&CK technique most closely represented by this finding, if
    /// any. primary_techniques is a repeated field because there are multiple
    /// levels of MITRE ATT&CK techniques.  If the technique most closely
    /// represented by this finding is a sub-technique (e.g. `SCANNING_IP_BLOCKS`),
    /// both the sub-technique and its parent technique(s) will be listed (e.g.
    /// `SCANNING_IP_BLOCKS`, `ACTIVE_SCANNING`).
    #[prost(enumeration = "mitre_attack::Technique", repeated, tag = "2")]
    pub primary_techniques: ::prost::alloc::vec::Vec<i32>,
    /// Additional MITRE ATT&CK tactics related to this finding, if any.
    #[prost(enumeration = "mitre_attack::Tactic", repeated, tag = "3")]
    pub additional_tactics: ::prost::alloc::vec::Vec<i32>,
    /// Additional MITRE ATT&CK techniques related to this finding, if any, along
    /// with any of their respective parent techniques.
    #[prost(enumeration = "mitre_attack::Technique", repeated, tag = "4")]
    pub additional_techniques: ::prost::alloc::vec::Vec<i32>,
    /// The MITRE ATT&CK version referenced by the above fields. E.g. "8".
    #[prost(string, tag = "5")]
    pub version: ::prost::alloc::string::String,
}
/// Nested message and enum types in `MitreAttack`.
pub mod mitre_attack {
    /// MITRE ATT&CK tactics that can be referenced by SCC findings.
    /// See: <https://attack.mitre.org/tactics/enterprise/>
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Tactic {
        /// Unspecified value.
        Unspecified = 0,
        /// TA0043
        Reconnaissance = 1,
        /// TA0042
        ResourceDevelopment = 2,
        /// TA0001
        InitialAccess = 5,
        /// TA0002
        Execution = 3,
        /// TA0003
        Persistence = 6,
        /// TA0004
        PrivilegeEscalation = 8,
        /// TA0005
        DefenseEvasion = 7,
        /// TA0006
        CredentialAccess = 9,
        /// TA0007
        Discovery = 10,
        /// TA0008
        LateralMovement = 11,
        /// TA0009
        Collection = 12,
        /// TA0011
        CommandAndControl = 4,
        /// TA0010
        Exfiltration = 13,
        /// TA0040
        Impact = 14,
    }
    impl Tactic {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TACTIC_UNSPECIFIED",
                Self::Reconnaissance => "RECONNAISSANCE",
                Self::ResourceDevelopment => "RESOURCE_DEVELOPMENT",
                Self::InitialAccess => "INITIAL_ACCESS",
                Self::Execution => "EXECUTION",
                Self::Persistence => "PERSISTENCE",
                Self::PrivilegeEscalation => "PRIVILEGE_ESCALATION",
                Self::DefenseEvasion => "DEFENSE_EVASION",
                Self::CredentialAccess => "CREDENTIAL_ACCESS",
                Self::Discovery => "DISCOVERY",
                Self::LateralMovement => "LATERAL_MOVEMENT",
                Self::Collection => "COLLECTION",
                Self::CommandAndControl => "COMMAND_AND_CONTROL",
                Self::Exfiltration => "EXFILTRATION",
                Self::Impact => "IMPACT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TACTIC_UNSPECIFIED" => Some(Self::Unspecified),
                "RECONNAISSANCE" => Some(Self::Reconnaissance),
                "RESOURCE_DEVELOPMENT" => Some(Self::ResourceDevelopment),
                "INITIAL_ACCESS" => Some(Self::InitialAccess),
                "EXECUTION" => Some(Self::Execution),
                "PERSISTENCE" => Some(Self::Persistence),
                "PRIVILEGE_ESCALATION" => Some(Self::PrivilegeEscalation),
                "DEFENSE_EVASION" => Some(Self::DefenseEvasion),
                "CREDENTIAL_ACCESS" => Some(Self::CredentialAccess),
                "DISCOVERY" => Some(Self::Discovery),
                "LATERAL_MOVEMENT" => Some(Self::LateralMovement),
                "COLLECTION" => Some(Self::Collection),
                "COMMAND_AND_CONTROL" => Some(Self::CommandAndControl),
                "EXFILTRATION" => Some(Self::Exfiltration),
                "IMPACT" => Some(Self::Impact),
                _ => None,
            }
        }
    }
    /// MITRE ATT&CK techniques that can be referenced by SCC findings.
    /// See: <https://attack.mitre.org/techniques/enterprise/>
    /// Next ID: 65
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Technique {
        /// Unspecified value.
        Unspecified = 0,
        /// T1036
        Masquerading = 49,
        /// T1036.005
        MatchLegitimateNameOrLocation = 50,
        /// T1037
        BootOrLogonInitializationScripts = 37,
        /// T1037.005
        StartupItems = 38,
        /// T1046
        NetworkServiceDiscovery = 32,
        /// T1057
        ProcessDiscovery = 56,
        /// T1059
        CommandAndScriptingInterpreter = 6,
        /// T1059.004
        UnixShell = 7,
        /// T1059.006
        Python = 59,
        /// T1068
        ExploitationForPrivilegeEscalation = 63,
        /// T1069
        PermissionGroupsDiscovery = 18,
        /// T1069.003
        CloudGroups = 19,
        /// T1070.004
        IndicatorRemovalFileDeletion = 64,
        /// T1071
        ApplicationLayerProtocol = 45,
        /// T1071.004
        Dns = 46,
        /// T1072
        SoftwareDeploymentTools = 47,
        /// T1078
        ValidAccounts = 14,
        /// T1078.001
        DefaultAccounts = 35,
        /// T1078.003
        LocalAccounts = 15,
        /// T1078.004
        CloudAccounts = 16,
        /// T1090
        Proxy = 9,
        /// T1090.002
        ExternalProxy = 10,
        /// T1090.003
        MultiHopProxy = 11,
        /// T1098
        AccountManipulation = 22,
        /// T1098.001
        AdditionalCloudCredentials = 40,
        /// T1098.004
        SshAuthorizedKeys = 23,
        /// T1098.006
        AdditionalContainerClusterRoles = 58,
        /// T1105
        IngressToolTransfer = 3,
        /// T1106
        NativeApi = 4,
        /// T1110
        BruteForce = 44,
        /// T1129
        SharedModules = 5,
        /// T1134
        AccessTokenManipulation = 33,
        /// T1134.001
        TokenImpersonationOrTheft = 39,
        /// T1190
        ExploitPublicFacingApplication = 27,
        /// T1484
        DomainPolicyModification = 30,
        /// T1485
        DataDestruction = 29,
        /// T1489
        ServiceStop = 52,
        /// T1490
        InhibitSystemRecovery = 36,
        /// T1496
        ResourceHijacking = 8,
        /// T1498
        NetworkDenialOfService = 17,
        /// T1526
        CloudServiceDiscovery = 48,
        /// T1528
        StealApplicationAccessToken = 42,
        /// T1531
        AccountAccessRemoval = 51,
        /// T1539
        StealWebSessionCookie = 25,
        /// T1543
        CreateOrModifySystemProcess = 24,
        /// T1548
        AbuseElevationControlMechanism = 34,
        /// T1552
        UnsecuredCredentials = 13,
        /// T1556
        ModifyAuthenticationProcess = 28,
        /// T1562
        ImpairDefenses = 31,
        /// T1562.001
        DisableOrModifyTools = 55,
        /// T1567
        ExfiltrationOverWebService = 20,
        /// T1567.002
        ExfiltrationToCloudStorage = 21,
        /// T1568
        DynamicResolution = 12,
        /// T1570
        LateralToolTransfer = 41,
        /// T1578
        ModifyCloudComputeInfrastructure = 26,
        /// T1578.001
        CreateSnapshot = 54,
        /// T1580
        CloudInfrastructureDiscovery = 53,
        /// T1588
        ObtainCapabilities = 43,
        /// T1595
        ActiveScanning = 1,
        /// T1595.001
        ScanningIpBlocks = 2,
        /// T1609
        ContainerAdministrationCommand = 60,
        /// T1611
        EscapeToHost = 61,
        /// T1613
        ContainerAndResourceDiscovery = 57,
        /// T1649
        StealOrForgeAuthenticationCertificates = 62,
    }
    impl Technique {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TECHNIQUE_UNSPECIFIED",
                Self::Masquerading => "MASQUERADING",
                Self::MatchLegitimateNameOrLocation => {
                    "MATCH_LEGITIMATE_NAME_OR_LOCATION"
                }
                Self::BootOrLogonInitializationScripts => {
                    "BOOT_OR_LOGON_INITIALIZATION_SCRIPTS"
                }
                Self::StartupItems => "STARTUP_ITEMS",
                Self::NetworkServiceDiscovery => "NETWORK_SERVICE_DISCOVERY",
                Self::ProcessDiscovery => "PROCESS_DISCOVERY",
                Self::CommandAndScriptingInterpreter => {
                    "COMMAND_AND_SCRIPTING_INTERPRETER"
                }
                Self::UnixShell => "UNIX_SHELL",
                Self::Python => "PYTHON",
                Self::ExploitationForPrivilegeEscalation => {
                    "EXPLOITATION_FOR_PRIVILEGE_ESCALATION"
                }
                Self::PermissionGroupsDiscovery => "PERMISSION_GROUPS_DISCOVERY",
                Self::CloudGroups => "CLOUD_GROUPS",
                Self::IndicatorRemovalFileDeletion => "INDICATOR_REMOVAL_FILE_DELETION",
                Self::ApplicationLayerProtocol => "APPLICATION_LAYER_PROTOCOL",
                Self::Dns => "DNS",
                Self::SoftwareDeploymentTools => "SOFTWARE_DEPLOYMENT_TOOLS",
                Self::ValidAccounts => "VALID_ACCOUNTS",
                Self::DefaultAccounts => "DEFAULT_ACCOUNTS",
                Self::LocalAccounts => "LOCAL_ACCOUNTS",
                Self::CloudAccounts => "CLOUD_ACCOUNTS",
                Self::Proxy => "PROXY",
                Self::ExternalProxy => "EXTERNAL_PROXY",
                Self::MultiHopProxy => "MULTI_HOP_PROXY",
                Self::AccountManipulation => "ACCOUNT_MANIPULATION",
                Self::AdditionalCloudCredentials => "ADDITIONAL_CLOUD_CREDENTIALS",
                Self::SshAuthorizedKeys => "SSH_AUTHORIZED_KEYS",
                Self::AdditionalContainerClusterRoles => {
                    "ADDITIONAL_CONTAINER_CLUSTER_ROLES"
                }
                Self::IngressToolTransfer => "INGRESS_TOOL_TRANSFER",
                Self::NativeApi => "NATIVE_API",
                Self::BruteForce => "BRUTE_FORCE",
                Self::SharedModules => "SHARED_MODULES",
                Self::AccessTokenManipulation => "ACCESS_TOKEN_MANIPULATION",
                Self::TokenImpersonationOrTheft => "TOKEN_IMPERSONATION_OR_THEFT",
                Self::ExploitPublicFacingApplication => {
                    "EXPLOIT_PUBLIC_FACING_APPLICATION"
                }
                Self::DomainPolicyModification => "DOMAIN_POLICY_MODIFICATION",
                Self::DataDestruction => "DATA_DESTRUCTION",
                Self::ServiceStop => "SERVICE_STOP",
                Self::InhibitSystemRecovery => "INHIBIT_SYSTEM_RECOVERY",
                Self::ResourceHijacking => "RESOURCE_HIJACKING",
                Self::NetworkDenialOfService => "NETWORK_DENIAL_OF_SERVICE",
                Self::CloudServiceDiscovery => "CLOUD_SERVICE_DISCOVERY",
                Self::StealApplicationAccessToken => "STEAL_APPLICATION_ACCESS_TOKEN",
                Self::AccountAccessRemoval => "ACCOUNT_ACCESS_REMOVAL",
                Self::StealWebSessionCookie => "STEAL_WEB_SESSION_COOKIE",
                Self::CreateOrModifySystemProcess => "CREATE_OR_MODIFY_SYSTEM_PROCESS",
                Self::AbuseElevationControlMechanism => {
                    "ABUSE_ELEVATION_CONTROL_MECHANISM"
                }
                Self::UnsecuredCredentials => "UNSECURED_CREDENTIALS",
                Self::ModifyAuthenticationProcess => "MODIFY_AUTHENTICATION_PROCESS",
                Self::ImpairDefenses => "IMPAIR_DEFENSES",
                Self::DisableOrModifyTools => "DISABLE_OR_MODIFY_TOOLS",
                Self::ExfiltrationOverWebService => "EXFILTRATION_OVER_WEB_SERVICE",
                Self::ExfiltrationToCloudStorage => "EXFILTRATION_TO_CLOUD_STORAGE",
                Self::DynamicResolution => "DYNAMIC_RESOLUTION",
                Self::LateralToolTransfer => "LATERAL_TOOL_TRANSFER",
                Self::ModifyCloudComputeInfrastructure => {
                    "MODIFY_CLOUD_COMPUTE_INFRASTRUCTURE"
                }
                Self::CreateSnapshot => "CREATE_SNAPSHOT",
                Self::CloudInfrastructureDiscovery => "CLOUD_INFRASTRUCTURE_DISCOVERY",
                Self::ObtainCapabilities => "OBTAIN_CAPABILITIES",
                Self::ActiveScanning => "ACTIVE_SCANNING",
                Self::ScanningIpBlocks => "SCANNING_IP_BLOCKS",
                Self::ContainerAdministrationCommand => {
                    "CONTAINER_ADMINISTRATION_COMMAND"
                }
                Self::EscapeToHost => "ESCAPE_TO_HOST",
                Self::ContainerAndResourceDiscovery => "CONTAINER_AND_RESOURCE_DISCOVERY",
                Self::StealOrForgeAuthenticationCertificates => {
                    "STEAL_OR_FORGE_AUTHENTICATION_CERTIFICATES"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TECHNIQUE_UNSPECIFIED" => Some(Self::Unspecified),
                "MASQUERADING" => Some(Self::Masquerading),
                "MATCH_LEGITIMATE_NAME_OR_LOCATION" => {
                    Some(Self::MatchLegitimateNameOrLocation)
                }
                "BOOT_OR_LOGON_INITIALIZATION_SCRIPTS" => {
                    Some(Self::BootOrLogonInitializationScripts)
                }
                "STARTUP_ITEMS" => Some(Self::StartupItems),
                "NETWORK_SERVICE_DISCOVERY" => Some(Self::NetworkServiceDiscovery),
                "PROCESS_DISCOVERY" => Some(Self::ProcessDiscovery),
                "COMMAND_AND_SCRIPTING_INTERPRETER" => {
                    Some(Self::CommandAndScriptingInterpreter)
                }
                "UNIX_SHELL" => Some(Self::UnixShell),
                "PYTHON" => Some(Self::Python),
                "EXPLOITATION_FOR_PRIVILEGE_ESCALATION" => {
                    Some(Self::ExploitationForPrivilegeEscalation)
                }
                "PERMISSION_GROUPS_DISCOVERY" => Some(Self::PermissionGroupsDiscovery),
                "CLOUD_GROUPS" => Some(Self::CloudGroups),
                "INDICATOR_REMOVAL_FILE_DELETION" => {
                    Some(Self::IndicatorRemovalFileDeletion)
                }
                "APPLICATION_LAYER_PROTOCOL" => Some(Self::ApplicationLayerProtocol),
                "DNS" => Some(Self::Dns),
                "SOFTWARE_DEPLOYMENT_TOOLS" => Some(Self::SoftwareDeploymentTools),
                "VALID_ACCOUNTS" => Some(Self::ValidAccounts),
                "DEFAULT_ACCOUNTS" => Some(Self::DefaultAccounts),
                "LOCAL_ACCOUNTS" => Some(Self::LocalAccounts),
                "CLOUD_ACCOUNTS" => Some(Self::CloudAccounts),
                "PROXY" => Some(Self::Proxy),
                "EXTERNAL_PROXY" => Some(Self::ExternalProxy),
                "MULTI_HOP_PROXY" => Some(Self::MultiHopProxy),
                "ACCOUNT_MANIPULATION" => Some(Self::AccountManipulation),
                "ADDITIONAL_CLOUD_CREDENTIALS" => Some(Self::AdditionalCloudCredentials),
                "SSH_AUTHORIZED_KEYS" => Some(Self::SshAuthorizedKeys),
                "ADDITIONAL_CONTAINER_CLUSTER_ROLES" => {
                    Some(Self::AdditionalContainerClusterRoles)
                }
                "INGRESS_TOOL_TRANSFER" => Some(Self::IngressToolTransfer),
                "NATIVE_API" => Some(Self::NativeApi),
                "BRUTE_FORCE" => Some(Self::BruteForce),
                "SHARED_MODULES" => Some(Self::SharedModules),
                "ACCESS_TOKEN_MANIPULATION" => Some(Self::AccessTokenManipulation),
                "TOKEN_IMPERSONATION_OR_THEFT" => Some(Self::TokenImpersonationOrTheft),
                "EXPLOIT_PUBLIC_FACING_APPLICATION" => {
                    Some(Self::ExploitPublicFacingApplication)
                }
                "DOMAIN_POLICY_MODIFICATION" => Some(Self::DomainPolicyModification),
                "DATA_DESTRUCTION" => Some(Self::DataDestruction),
                "SERVICE_STOP" => Some(Self::ServiceStop),
                "INHIBIT_SYSTEM_RECOVERY" => Some(Self::InhibitSystemRecovery),
                "RESOURCE_HIJACKING" => Some(Self::ResourceHijacking),
                "NETWORK_DENIAL_OF_SERVICE" => Some(Self::NetworkDenialOfService),
                "CLOUD_SERVICE_DISCOVERY" => Some(Self::CloudServiceDiscovery),
                "STEAL_APPLICATION_ACCESS_TOKEN" => {
                    Some(Self::StealApplicationAccessToken)
                }
                "ACCOUNT_ACCESS_REMOVAL" => Some(Self::AccountAccessRemoval),
                "STEAL_WEB_SESSION_COOKIE" => Some(Self::StealWebSessionCookie),
                "CREATE_OR_MODIFY_SYSTEM_PROCESS" => {
                    Some(Self::CreateOrModifySystemProcess)
                }
                "ABUSE_ELEVATION_CONTROL_MECHANISM" => {
                    Some(Self::AbuseElevationControlMechanism)
                }
                "UNSECURED_CREDENTIALS" => Some(Self::UnsecuredCredentials),
                "MODIFY_AUTHENTICATION_PROCESS" => {
                    Some(Self::ModifyAuthenticationProcess)
                }
                "IMPAIR_DEFENSES" => Some(Self::ImpairDefenses),
                "DISABLE_OR_MODIFY_TOOLS" => Some(Self::DisableOrModifyTools),
                "EXFILTRATION_OVER_WEB_SERVICE" => Some(Self::ExfiltrationOverWebService),
                "EXFILTRATION_TO_CLOUD_STORAGE" => Some(Self::ExfiltrationToCloudStorage),
                "DYNAMIC_RESOLUTION" => Some(Self::DynamicResolution),
                "LATERAL_TOOL_TRANSFER" => Some(Self::LateralToolTransfer),
                "MODIFY_CLOUD_COMPUTE_INFRASTRUCTURE" => {
                    Some(Self::ModifyCloudComputeInfrastructure)
                }
                "CREATE_SNAPSHOT" => Some(Self::CreateSnapshot),
                "CLOUD_INFRASTRUCTURE_DISCOVERY" => {
                    Some(Self::CloudInfrastructureDiscovery)
                }
                "OBTAIN_CAPABILITIES" => Some(Self::ObtainCapabilities),
                "ACTIVE_SCANNING" => Some(Self::ActiveScanning),
                "SCANNING_IP_BLOCKS" => Some(Self::ScanningIpBlocks),
                "CONTAINER_ADMINISTRATION_COMMAND" => {
                    Some(Self::ContainerAdministrationCommand)
                }
                "ESCAPE_TO_HOST" => Some(Self::EscapeToHost),
                "CONTAINER_AND_RESOURCE_DISCOVERY" => {
                    Some(Self::ContainerAndResourceDiscovery)
                }
                "STEAL_OR_FORGE_AUTHENTICATION_CERTIFICATES" => {
                    Some(Self::StealOrForgeAuthenticationCertificates)
                }
                _ => None,
            }
        }
    }
}
/// Represents a Jupyter notebook IPYNB file, such as a [Colab Enterprise
/// notebook](<https://cloud.google.com/colab/docs/introduction>) file, that is
/// associated with a finding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Notebook {
    /// The name of the notebook.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The source notebook service, for example, "Colab Enterprise".
    #[prost(string, tag = "2")]
    pub service: ::prost::alloc::string::String,
    /// The user ID of the latest author to modify the notebook.
    #[prost(string, tag = "3")]
    pub last_author: ::prost::alloc::string::String,
    /// The most recent time the notebook was updated.
    #[prost(message, optional, tag = "4")]
    pub notebook_update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Contains information about the org policies associated with the finding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrgPolicy {
    /// The resource name of the org policy.
    /// Example:
    /// "organizations/{organization_id}/policies/{constraint_name}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Represents an operating system process.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Process {
    /// The process name, as displayed in utilities like `top` and `ps`. This name
    /// can be accessed through `/proc/\[pid\]/comm` and changed with
    /// `prctl(PR_SET_NAME)`.
    #[prost(string, tag = "12")]
    pub name: ::prost::alloc::string::String,
    /// File information for the process executable.
    #[prost(message, optional, tag = "3")]
    pub binary: ::core::option::Option<File>,
    /// File information for libraries loaded by the process.
    #[prost(message, repeated, tag = "4")]
    pub libraries: ::prost::alloc::vec::Vec<File>,
    /// When the process represents the invocation of a script, `binary` provides
    /// information about the interpreter, while `script` provides information
    /// about the script file provided to the interpreter.
    #[prost(message, optional, tag = "5")]
    pub script: ::core::option::Option<File>,
    /// Process arguments as JSON encoded strings.
    #[prost(string, repeated, tag = "6")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// True if `args` is incomplete.
    #[prost(bool, tag = "7")]
    pub arguments_truncated: bool,
    /// Process environment variables.
    #[prost(message, repeated, tag = "8")]
    pub env_variables: ::prost::alloc::vec::Vec<EnvironmentVariable>,
    /// True if `env_variables` is incomplete.
    #[prost(bool, tag = "9")]
    pub env_variables_truncated: bool,
    /// The process ID.
    #[prost(int64, tag = "10")]
    pub pid: i64,
    /// The parent process ID.
    #[prost(int64, tag = "11")]
    pub parent_pid: i64,
}
/// A name-value pair representing an environment variable used in an operating
/// system process.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnvironmentVariable {
    /// Environment variable name as a JSON encoded string.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Environment variable value as a JSON encoded string.
    #[prost(string, tag = "2")]
    pub val: ::prost::alloc::string::String,
}
/// Represents a posture that is deployed on Google Cloud by the
/// Security Command Center Posture Management service.
/// A posture contains one or more policy sets. A policy set is a
/// group of policies that enforce a set of security rules on Google
/// Cloud.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPosture {
    /// Name of the posture, for example, `CIS-Posture`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The version of the posture, for example, `c7cfa2a8`.
    #[prost(string, tag = "2")]
    pub revision_id: ::prost::alloc::string::String,
    /// The project, folder, or organization on which the posture is deployed,
    /// for example, `projects/{project_number}`.
    #[prost(string, tag = "3")]
    pub posture_deployment_resource: ::prost::alloc::string::String,
    /// The name of the posture deployment, for example,
    /// `organizations/{org_id}/posturedeployments/{posture_deployment_id}`.
    #[prost(string, tag = "4")]
    pub posture_deployment: ::prost::alloc::string::String,
    /// The name of the updated policy, for example,
    /// `projects/{project_id}/policies/{constraint_name}`.
    #[prost(string, tag = "5")]
    pub changed_policy: ::prost::alloc::string::String,
    /// The name of the updated policyset, for example, `cis-policyset`.
    #[prost(string, tag = "6")]
    pub policy_set: ::prost::alloc::string::String,
    /// The ID of the updated policy, for example, `compute-policy-1`.
    #[prost(string, tag = "7")]
    pub policy: ::prost::alloc::string::String,
    /// The details about a change in an updated policy that violates the deployed
    /// posture.
    #[prost(message, repeated, tag = "8")]
    pub policy_drift_details: ::prost::alloc::vec::Vec<
        security_posture::PolicyDriftDetails,
    >,
}
/// Nested message and enum types in `SecurityPosture`.
pub mod security_posture {
    /// The policy field that violates the deployed posture and its expected and
    /// detected values.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PolicyDriftDetails {
        /// The name of the updated field, for example
        /// constraint.implementation.policy_rules\[0\].enforce
        #[prost(string, tag = "1")]
        pub field: ::prost::alloc::string::String,
        /// The value of this field that was configured in a posture, for example,
        /// `true` or `allowed_values={"projects/29831892"}`.
        #[prost(string, tag = "2")]
        pub expected_value: ::prost::alloc::string::String,
        /// The detected value that violates the deployed posture, for example,
        /// `false` or `allowed_values={"projects/22831892"}`.
        #[prost(string, tag = "3")]
        pub detected_value: ::prost::alloc::string::String,
    }
}
/// Contains details about a group of security issues that, when the issues
/// occur together, represent a greater risk than when the issues occur
/// independently. A group of such issues is referred to as a toxic combination.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToxicCombination {
    /// The
    /// [Attack exposure
    /// score](<https://cloud.google.com/security-command-center/docs/attack-exposure-learn#attack_exposure_scores>)
    /// of this toxic combination. The score is a measure of how much this toxic
    /// combination exposes one or more high-value resources to potential attack.
    #[prost(double, tag = "1")]
    pub attack_exposure_score: f64,
    /// List of resource names of findings associated with this toxic combination.
    /// For example, `organizations/123/sources/456/findings/789`.
    #[prost(string, repeated, tag = "2")]
    pub related_findings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Refers to common vulnerability fields e.g. cve, cvss, cwe etc.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vulnerability {
    /// CVE stands for Common Vulnerabilities and Exposures
    /// (<https://cve.mitre.org/about/>)
    #[prost(message, optional, tag = "1")]
    pub cve: ::core::option::Option<Cve>,
    /// The offending package is relevant to the finding.
    #[prost(message, optional, tag = "2")]
    pub offending_package: ::core::option::Option<Package>,
    /// The fixed package is relevant to the finding.
    #[prost(message, optional, tag = "3")]
    pub fixed_package: ::core::option::Option<Package>,
    /// The security bulletin is relevant to this finding.
    #[prost(message, optional, tag = "4")]
    pub security_bulletin: ::core::option::Option<SecurityBulletin>,
}
/// CVE stands for Common Vulnerabilities and Exposures.
/// Information from the [CVE
/// record](<https://www.cve.org/ResourcesSupport/Glossary>) that describes this
/// vulnerability.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cve {
    /// The unique identifier for the vulnerability. e.g. CVE-2021-34527
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Additional information about the CVE.
    /// e.g. <https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-34527>
    #[prost(message, repeated, tag = "2")]
    pub references: ::prost::alloc::vec::Vec<Reference>,
    /// Describe Common Vulnerability Scoring System specified at
    /// <https://www.first.org/cvss/v3.1/specification-document>
    #[prost(message, optional, tag = "3")]
    pub cvssv3: ::core::option::Option<Cvssv3>,
    /// Whether upstream fix is available for the CVE.
    #[prost(bool, tag = "4")]
    pub upstream_fix_available: bool,
    /// The potential impact of the vulnerability if it was to be exploited.
    #[prost(enumeration = "cve::RiskRating", tag = "5")]
    pub impact: i32,
    /// The exploitation activity of the vulnerability in the wild.
    #[prost(enumeration = "cve::ExploitationActivity", tag = "6")]
    pub exploitation_activity: i32,
    /// Whether or not the vulnerability has been observed in the wild.
    #[prost(bool, tag = "7")]
    pub observed_in_the_wild: bool,
    /// Whether or not the vulnerability was zero day when the finding was
    /// published.
    #[prost(bool, tag = "8")]
    pub zero_day: bool,
    /// Date the first publicly available exploit or PoC was released.
    #[prost(message, optional, tag = "9")]
    pub exploit_release_date: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Cve`.
pub mod cve {
    /// The possible values of impact of the vulnerability if it was to be
    /// exploited.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RiskRating {
        /// Invalid or empty value.
        Unspecified = 0,
        /// Exploitation would have little to no security impact.
        Low = 1,
        /// Exploitation would enable attackers to perform activities, or could allow
        /// attackers to have a direct impact, but would require additional steps.
        Medium = 2,
        /// Exploitation would enable attackers to have a notable direct impact
        /// without needing to overcome any major mitigating factors.
        High = 3,
        /// Exploitation would fundamentally undermine the security of affected
        /// systems, enable actors to perform significant attacks with minimal
        /// effort, with little to no mitigating factors to overcome.
        Critical = 4,
    }
    impl RiskRating {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RISK_RATING_UNSPECIFIED",
                Self::Low => "LOW",
                Self::Medium => "MEDIUM",
                Self::High => "HIGH",
                Self::Critical => "CRITICAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RISK_RATING_UNSPECIFIED" => Some(Self::Unspecified),
                "LOW" => Some(Self::Low),
                "MEDIUM" => Some(Self::Medium),
                "HIGH" => Some(Self::High),
                "CRITICAL" => Some(Self::Critical),
                _ => None,
            }
        }
    }
    /// The possible values of exploitation activity of the vulnerability in the
    /// wild.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExploitationActivity {
        /// Invalid or empty value.
        Unspecified = 0,
        /// Exploitation has been reported or confirmed to widely occur.
        Wide = 1,
        /// Limited reported or confirmed exploitation activities.
        Confirmed = 2,
        /// Exploit is publicly available.
        Available = 3,
        /// No known exploitation activity, but has a high potential for
        /// exploitation.
        Anticipated = 4,
        /// No known exploitation activity.
        NoKnown = 5,
    }
    impl ExploitationActivity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EXPLOITATION_ACTIVITY_UNSPECIFIED",
                Self::Wide => "WIDE",
                Self::Confirmed => "CONFIRMED",
                Self::Available => "AVAILABLE",
                Self::Anticipated => "ANTICIPATED",
                Self::NoKnown => "NO_KNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXPLOITATION_ACTIVITY_UNSPECIFIED" => Some(Self::Unspecified),
                "WIDE" => Some(Self::Wide),
                "CONFIRMED" => Some(Self::Confirmed),
                "AVAILABLE" => Some(Self::Available),
                "ANTICIPATED" => Some(Self::Anticipated),
                "NO_KNOWN" => Some(Self::NoKnown),
                _ => None,
            }
        }
    }
}
/// Additional Links
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reference {
    /// Source of the reference e.g. NVD
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    /// Uri for the mentioned source e.g.
    /// <https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-34527.>
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
}
/// Common Vulnerability Scoring System version 3.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Cvssv3 {
    /// The base score is a function of the base metric scores.
    #[prost(double, tag = "1")]
    pub base_score: f64,
    /// Base Metrics
    /// Represents the intrinsic characteristics of a vulnerability that are
    /// constant over time and across user environments.
    /// This metric reflects the context by which vulnerability exploitation is
    /// possible.
    #[prost(enumeration = "cvssv3::AttackVector", tag = "5")]
    pub attack_vector: i32,
    /// This metric describes the conditions beyond the attacker's control that
    /// must exist in order to exploit the vulnerability.
    #[prost(enumeration = "cvssv3::AttackComplexity", tag = "6")]
    pub attack_complexity: i32,
    /// This metric describes the level of privileges an attacker must possess
    /// before successfully exploiting the vulnerability.
    #[prost(enumeration = "cvssv3::PrivilegesRequired", tag = "7")]
    pub privileges_required: i32,
    /// This metric captures the requirement for a human user, other than the
    /// attacker, to participate in the successful compromise of the vulnerable
    /// component.
    #[prost(enumeration = "cvssv3::UserInteraction", tag = "8")]
    pub user_interaction: i32,
    /// The Scope metric captures whether a vulnerability in one vulnerable
    /// component impacts resources in components beyond its security scope.
    #[prost(enumeration = "cvssv3::Scope", tag = "9")]
    pub scope: i32,
    /// This metric measures the impact to the confidentiality of the information
    /// resources managed by a software component due to a successfully exploited
    /// vulnerability.
    #[prost(enumeration = "cvssv3::Impact", tag = "10")]
    pub confidentiality_impact: i32,
    /// This metric measures the impact to integrity of a successfully exploited
    /// vulnerability.
    #[prost(enumeration = "cvssv3::Impact", tag = "11")]
    pub integrity_impact: i32,
    /// This metric measures the impact to the availability of the impacted
    /// component resulting from a successfully exploited vulnerability.
    #[prost(enumeration = "cvssv3::Impact", tag = "12")]
    pub availability_impact: i32,
}
/// Nested message and enum types in `Cvssv3`.
pub mod cvssv3 {
    /// This metric reflects the context by which vulnerability exploitation is
    /// possible.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AttackVector {
        /// Invalid value.
        Unspecified = 0,
        /// The vulnerable component is bound to the network stack and the set of
        /// possible attackers extends beyond the other options listed below, up to
        /// and including the entire Internet.
        Network = 1,
        /// The vulnerable component is bound to the network stack, but the attack is
        /// limited at the protocol level to a logically adjacent topology.
        Adjacent = 2,
        /// The vulnerable component is not bound to the network stack and the
        /// attacker's path is via read/write/execute capabilities.
        Local = 3,
        /// The attack requires the attacker to physically touch or manipulate the
        /// vulnerable component.
        Physical = 4,
    }
    impl AttackVector {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ATTACK_VECTOR_UNSPECIFIED",
                Self::Network => "ATTACK_VECTOR_NETWORK",
                Self::Adjacent => "ATTACK_VECTOR_ADJACENT",
                Self::Local => "ATTACK_VECTOR_LOCAL",
                Self::Physical => "ATTACK_VECTOR_PHYSICAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ATTACK_VECTOR_UNSPECIFIED" => Some(Self::Unspecified),
                "ATTACK_VECTOR_NETWORK" => Some(Self::Network),
                "ATTACK_VECTOR_ADJACENT" => Some(Self::Adjacent),
                "ATTACK_VECTOR_LOCAL" => Some(Self::Local),
                "ATTACK_VECTOR_PHYSICAL" => Some(Self::Physical),
                _ => None,
            }
        }
    }
    /// This metric describes the conditions beyond the attacker's control that
    /// must exist in order to exploit the vulnerability.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AttackComplexity {
        /// Invalid value.
        Unspecified = 0,
        /// Specialized access conditions or extenuating circumstances do not exist.
        /// An attacker can expect repeatable success when attacking the vulnerable
        /// component.
        Low = 1,
        /// A successful attack depends on conditions beyond the attacker's control.
        /// That is, a successful attack cannot be accomplished at will, but requires
        /// the attacker to invest in some measurable amount of effort in preparation
        /// or execution against the vulnerable component before a successful attack
        /// can be expected.
        High = 2,
    }
    impl AttackComplexity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ATTACK_COMPLEXITY_UNSPECIFIED",
                Self::Low => "ATTACK_COMPLEXITY_LOW",
                Self::High => "ATTACK_COMPLEXITY_HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ATTACK_COMPLEXITY_UNSPECIFIED" => Some(Self::Unspecified),
                "ATTACK_COMPLEXITY_LOW" => Some(Self::Low),
                "ATTACK_COMPLEXITY_HIGH" => Some(Self::High),
                _ => None,
            }
        }
    }
    /// This metric describes the level of privileges an attacker must possess
    /// before successfully exploiting the vulnerability.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PrivilegesRequired {
        /// Invalid value.
        Unspecified = 0,
        /// The attacker is unauthorized prior to attack, and therefore does not
        /// require any access to settings or files of the vulnerable system to
        /// carry out an attack.
        None = 1,
        /// The attacker requires privileges that provide basic user capabilities
        /// that could normally affect only settings and files owned by a user.
        /// Alternatively, an attacker with Low privileges has the ability to access
        /// only non-sensitive resources.
        Low = 2,
        /// The attacker requires privileges that provide significant (e.g.,
        /// administrative) control over the vulnerable component allowing access to
        /// component-wide settings and files.
        High = 3,
    }
    impl PrivilegesRequired {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PRIVILEGES_REQUIRED_UNSPECIFIED",
                Self::None => "PRIVILEGES_REQUIRED_NONE",
                Self::Low => "PRIVILEGES_REQUIRED_LOW",
                Self::High => "PRIVILEGES_REQUIRED_HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRIVILEGES_REQUIRED_UNSPECIFIED" => Some(Self::Unspecified),
                "PRIVILEGES_REQUIRED_NONE" => Some(Self::None),
                "PRIVILEGES_REQUIRED_LOW" => Some(Self::Low),
                "PRIVILEGES_REQUIRED_HIGH" => Some(Self::High),
                _ => None,
            }
        }
    }
    /// This metric captures the requirement for a human user, other than the
    /// attacker, to participate in the successful compromise of the vulnerable
    /// component.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserInteraction {
        /// Invalid value.
        Unspecified = 0,
        /// The vulnerable system can be exploited without interaction from any user.
        None = 1,
        /// Successful exploitation of this vulnerability requires a user to take
        /// some action before the vulnerability can be exploited.
        Required = 2,
    }
    impl UserInteraction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "USER_INTERACTION_UNSPECIFIED",
                Self::None => "USER_INTERACTION_NONE",
                Self::Required => "USER_INTERACTION_REQUIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "USER_INTERACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "USER_INTERACTION_NONE" => Some(Self::None),
                "USER_INTERACTION_REQUIRED" => Some(Self::Required),
                _ => None,
            }
        }
    }
    /// The Scope metric captures whether a vulnerability in one vulnerable
    /// component impacts resources in components beyond its security scope.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Scope {
        /// Invalid value.
        Unspecified = 0,
        /// An exploited vulnerability can only affect resources managed by the same
        /// security authority.
        Unchanged = 1,
        /// An exploited vulnerability can affect resources beyond the security scope
        /// managed by the security authority of the vulnerable component.
        Changed = 2,
    }
    impl Scope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SCOPE_UNSPECIFIED",
                Self::Unchanged => "SCOPE_UNCHANGED",
                Self::Changed => "SCOPE_CHANGED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SCOPE_UNCHANGED" => Some(Self::Unchanged),
                "SCOPE_CHANGED" => Some(Self::Changed),
                _ => None,
            }
        }
    }
    /// The Impact metrics capture the effects of a successfully exploited
    /// vulnerability on the component that suffers the worst outcome that is most
    /// directly and predictably associated with the attack.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Impact {
        /// Invalid value.
        Unspecified = 0,
        /// High impact.
        High = 1,
        /// Low impact.
        Low = 2,
        /// No impact.
        None = 3,
    }
    impl Impact {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "IMPACT_UNSPECIFIED",
                Self::High => "IMPACT_HIGH",
                Self::Low => "IMPACT_LOW",
                Self::None => "IMPACT_NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IMPACT_UNSPECIFIED" => Some(Self::Unspecified),
                "IMPACT_HIGH" => Some(Self::High),
                "IMPACT_LOW" => Some(Self::Low),
                "IMPACT_NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
/// Package is a generic definition of a package.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Package {
    /// The name of the package where the vulnerability was detected.
    #[prost(string, tag = "1")]
    pub package_name: ::prost::alloc::string::String,
    /// The CPE URI where the vulnerability was detected.
    #[prost(string, tag = "2")]
    pub cpe_uri: ::prost::alloc::string::String,
    /// Type of package, for example, os, maven, or go.
    #[prost(string, tag = "3")]
    pub package_type: ::prost::alloc::string::String,
    /// The version of the package.
    #[prost(string, tag = "4")]
    pub package_version: ::prost::alloc::string::String,
}
/// SecurityBulletin are notifications of vulnerabilities of Google products.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityBulletin {
    /// ID of the bulletin corresponding to the vulnerability.
    #[prost(string, tag = "1")]
    pub bulletin_id: ::prost::alloc::string::String,
    /// Submission time of this Security Bulletin.
    #[prost(message, optional, tag = "2")]
    pub submission_time: ::core::option::Option<::prost_types::Timestamp>,
    /// This represents a version that the cluster receiving this notification
    /// should be upgraded to, based on its current version. For example, 1.15.0
    #[prost(string, tag = "3")]
    pub suggested_upgrade_version: ::prost::alloc::string::String,
}
/// Security Command Center finding.
///
/// A finding is a record of assessment data like security, risk, health, or
/// privacy, that is ingested into Security Command Center for presentation,
/// notification, analysis, policy testing, and enforcement. For example, a
/// cross-site scripting (XSS) vulnerability in an App Engine application is a
/// finding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Finding {
    /// The [relative resource
    /// name](<https://cloud.google.com/apis/design/resource_names#relative_resource_name>)
    /// of the finding. Example:
    /// "organizations/{organization_id}/sources/{source_id}/findings/{finding_id}",
    /// "folders/{folder_id}/sources/{source_id}/findings/{finding_id}",
    /// "projects/{project_id}/sources/{source_id}/findings/{finding_id}".
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The relative resource name of the source the finding belongs to. See:
    /// <https://cloud.google.com/apis/design/resource_names#relative_resource_name>
    /// This field is immutable after creation time.
    /// For example:
    /// "organizations/{organization_id}/sources/{source_id}"
    #[prost(string, tag = "2")]
    pub parent: ::prost::alloc::string::String,
    /// For findings on Google Cloud resources, the full resource
    /// name of the Google Cloud resource this finding is for. See:
    /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
    /// When the finding is for a non-Google Cloud resource, the resourceName can
    /// be a customer or partner defined string. This field is immutable after
    /// creation time.
    #[prost(string, tag = "3")]
    pub resource_name: ::prost::alloc::string::String,
    /// The state of the finding.
    #[prost(enumeration = "finding::State", tag = "4")]
    pub state: i32,
    /// The additional taxonomy group within findings from a given source.
    /// This field is immutable after creation time.
    /// Example: "XSS_FLASH_INJECTION"
    #[prost(string, tag = "5")]
    pub category: ::prost::alloc::string::String,
    /// The URI that, if available, points to a web page outside of Security
    /// Command Center where additional information about the finding can be found.
    /// This field is guaranteed to be either empty or a well formed URL.
    #[prost(string, tag = "6")]
    pub external_uri: ::prost::alloc::string::String,
    /// Source specific properties. These properties are managed by the source
    /// that writes the finding. The key names in the source_properties map must be
    /// between 1 and 255 characters, and must start with a letter and contain
    /// alphanumeric characters or underscores only.
    #[prost(map = "string, message", tag = "7")]
    pub source_properties: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost_types::Value,
    >,
    /// Output only. User specified security marks. These marks are entirely
    /// managed by the user and come from the SecurityMarks resource that belongs
    /// to the finding.
    #[prost(message, optional, tag = "8")]
    pub security_marks: ::core::option::Option<SecurityMarks>,
    /// The time the finding was first detected. If an existing finding is updated,
    /// then this is the time the update occurred.
    /// For example, if the finding represents an open firewall, this property
    /// captures the time the detector believes the firewall became open. The
    /// accuracy is determined by the detector. If the finding is later resolved,
    /// then this time reflects when the finding was resolved. This must not
    /// be set to a value greater than the current timestamp.
    #[prost(message, optional, tag = "9")]
    pub event_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time at which the finding was created in Security Command Center.
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The severity of the finding. This field is managed by the source that
    /// writes the finding.
    #[prost(enumeration = "finding::Severity", tag = "12")]
    pub severity: i32,
    /// The canonical name of the finding. It's either
    /// "organizations/{organization_id}/sources/{source_id}/findings/{finding_id}",
    /// "folders/{folder_id}/sources/{source_id}/findings/{finding_id}" or
    /// "projects/{project_number}/sources/{source_id}/findings/{finding_id}",
    /// depending on the closest CRM ancestor of the resource associated with the
    /// finding.
    #[prost(string, tag = "14")]
    pub canonical_name: ::prost::alloc::string::String,
    /// Indicates the mute state of a finding (either muted, unmuted
    /// or undefined). Unlike other attributes of a finding, a finding provider
    /// shouldn't set the value of mute.
    #[prost(enumeration = "finding::Mute", tag = "15")]
    pub mute: i32,
    /// The class of the finding.
    #[prost(enumeration = "finding::FindingClass", tag = "17")]
    pub finding_class: i32,
    /// Represents what's commonly known as an *indicator of compromise* (IoC) in
    /// computer forensics. This is an artifact observed on a network or in an
    /// operating system that, with high confidence, indicates a computer
    /// intrusion. For more information, see [Indicator of
    /// compromise](<https://en.wikipedia.org/wiki/Indicator_of_compromise>).
    #[prost(message, optional, tag = "18")]
    pub indicator: ::core::option::Option<Indicator>,
    /// Represents vulnerability-specific fields like CVE and CVSS scores.
    /// CVE stands for Common Vulnerabilities and Exposures
    /// (<https://cve.mitre.org/about/>)
    #[prost(message, optional, tag = "20")]
    pub vulnerability: ::core::option::Option<Vulnerability>,
    /// Output only. The most recent time this finding was muted or unmuted.
    #[prost(message, optional, tag = "21")]
    pub mute_update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Third party SIEM/SOAR fields within SCC, contains external
    /// system information and external system finding fields.
    #[prost(map = "string, message", tag = "22")]
    pub external_systems: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ExternalSystem,
    >,
    /// MITRE ATT&CK tactics and techniques related to this finding.
    /// See: <https://attack.mitre.org>
    #[prost(message, optional, tag = "25")]
    pub mitre_attack: ::core::option::Option<MitreAttack>,
    /// Access details associated with the finding, such as more information on the
    /// caller, which method was accessed, and from where.
    #[prost(message, optional, tag = "26")]
    pub access: ::core::option::Option<Access>,
    /// Contains information about the IP connection associated with the finding.
    #[prost(message, repeated, tag = "31")]
    pub connections: ::prost::alloc::vec::Vec<Connection>,
    /// Records additional information about the mute operation, for example, the
    /// [mute configuration](/security-command-center/docs/how-to-mute-findings)
    /// that muted the finding and the user who muted the finding.
    #[prost(string, tag = "28")]
    pub mute_initiator: ::prost::alloc::string::String,
    /// Output only. The mute information regarding this finding.
    #[prost(message, optional, tag = "61")]
    pub mute_info: ::core::option::Option<finding::MuteInfo>,
    /// Represents operating system processes associated with the Finding.
    #[prost(message, repeated, tag = "30")]
    pub processes: ::prost::alloc::vec::Vec<Process>,
    /// Output only. Map containing the points of contact for the given finding.
    /// The key represents the type of contact, while the value contains a list of
    /// all the contacts that pertain. Please refer to:
    /// <https://cloud.google.com/resource-manager/docs/managing-notification-contacts#notification-categories>
    ///
    ///      {
    ///        "security": {
    ///          "contacts": [
    ///            {
    ///              "email": "person1@company.com"
    ///            },
    ///            {
    ///              "email": "person2@company.com"
    ///            }
    ///          ]
    ///        }
    ///      }
    #[prost(map = "string, message", tag = "33")]
    pub contacts: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ContactDetails,
    >,
    /// Contains compliance information for security standards associated to the
    /// finding.
    #[prost(message, repeated, tag = "34")]
    pub compliances: ::prost::alloc::vec::Vec<Compliance>,
    /// Output only. The human readable display name of the finding source such as
    /// "Event Threat Detection" or "Security Health Analytics".
    #[prost(string, tag = "36")]
    pub parent_display_name: ::prost::alloc::string::String,
    /// Contains more details about the finding.
    #[prost(string, tag = "37")]
    pub description: ::prost::alloc::string::String,
    /// Represents exfiltrations associated with the finding.
    #[prost(message, optional, tag = "38")]
    pub exfiltration: ::core::option::Option<Exfiltration>,
    /// Represents IAM bindings associated with the finding.
    #[prost(message, repeated, tag = "39")]
    pub iam_bindings: ::prost::alloc::vec::Vec<IamBinding>,
    /// Steps to address the finding.
    #[prost(string, tag = "40")]
    pub next_steps: ::prost::alloc::string::String,
    /// Unique identifier of the module which generated the finding.
    /// Example:
    /// folders/598186756061/securityHealthAnalyticsSettings/customModules/56799441161885
    #[prost(string, tag = "41")]
    pub module_name: ::prost::alloc::string::String,
    /// Containers associated with the finding. This field provides information for
    /// both Kubernetes and non-Kubernetes containers.
    #[prost(message, repeated, tag = "42")]
    pub containers: ::prost::alloc::vec::Vec<Container>,
    /// Kubernetes resources associated with the finding.
    #[prost(message, optional, tag = "43")]
    pub kubernetes: ::core::option::Option<Kubernetes>,
    /// Database associated with the finding.
    #[prost(message, optional, tag = "44")]
    pub database: ::core::option::Option<Database>,
    /// The results of an attack path simulation relevant to this finding.
    #[prost(message, optional, tag = "45")]
    pub attack_exposure: ::core::option::Option<AttackExposure>,
    /// File associated with the finding.
    #[prost(message, repeated, tag = "46")]
    pub files: ::prost::alloc::vec::Vec<File>,
    /// Cloud Data Loss Prevention (Cloud DLP) inspection results that are
    /// associated with the finding.
    #[prost(message, optional, tag = "48")]
    pub cloud_dlp_inspection: ::core::option::Option<CloudDlpInspection>,
    /// Cloud DLP data profile that is associated with the finding.
    #[prost(message, optional, tag = "49")]
    pub cloud_dlp_data_profile: ::core::option::Option<CloudDlpDataProfile>,
    /// Signature of the kernel rootkit.
    #[prost(message, optional, tag = "50")]
    pub kernel_rootkit: ::core::option::Option<KernelRootkit>,
    /// Contains information about the org policies associated with the finding.
    #[prost(message, repeated, tag = "51")]
    pub org_policies: ::prost::alloc::vec::Vec<OrgPolicy>,
    /// Represents an application associated with the finding.
    #[prost(message, optional, tag = "53")]
    pub application: ::core::option::Option<Application>,
    /// Fields related to Backup and DR findings.
    #[prost(message, optional, tag = "55")]
    pub backup_disaster_recovery: ::core::option::Option<BackupDisasterRecovery>,
    /// The security posture associated with the finding.
    #[prost(message, optional, tag = "56")]
    pub security_posture: ::core::option::Option<SecurityPosture>,
    /// Log entries that are relevant to the finding.
    #[prost(message, repeated, tag = "57")]
    pub log_entries: ::prost::alloc::vec::Vec<LogEntry>,
    /// The load balancers associated with the finding.
    #[prost(message, repeated, tag = "58")]
    pub load_balancers: ::prost::alloc::vec::Vec<LoadBalancer>,
    /// Fields related to Cloud Armor findings.
    #[prost(message, optional, tag = "59")]
    pub cloud_armor: ::core::option::Option<CloudArmor>,
    /// Notebook associated with the finding.
    #[prost(message, optional, tag = "63")]
    pub notebook: ::core::option::Option<Notebook>,
    /// Contains details about a group of security issues that, when the issues
    /// occur together, represent a greater risk than when the issues occur
    /// independently. A group of such issues is referred to as a toxic
    /// combination.
    /// This field cannot be updated. Its value is ignored in all update requests.
    #[prost(message, optional, tag = "64")]
    pub toxic_combination: ::core::option::Option<ToxicCombination>,
    /// Contains details about groups of which this finding is a member. A group is
    /// a collection of findings that are related in some way.
    /// This field cannot be updated. Its value is ignored in all update requests.
    #[prost(message, repeated, tag = "65")]
    pub group_memberships: ::prost::alloc::vec::Vec<GroupMembership>,
}
/// Nested message and enum types in `Finding`.
pub mod finding {
    /// Mute information about the finding, including whether the finding has a
    /// static mute or any matching dynamic mute rules.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MuteInfo {
        /// If set, the static mute applied to this finding. Static mutes override
        /// dynamic mutes. If unset, there is no static mute.
        #[prost(message, optional, tag = "1")]
        pub static_mute: ::core::option::Option<mute_info::StaticMute>,
        /// The list of dynamic mute rules that currently match the finding.
        #[prost(message, repeated, tag = "2")]
        pub dynamic_mute_records: ::prost::alloc::vec::Vec<mute_info::DynamicMuteRecord>,
    }
    /// Nested message and enum types in `MuteInfo`.
    pub mod mute_info {
        /// Information about the static mute state. A static mute state overrides
        /// any dynamic mute rules that apply to this finding. The static mute state
        /// can be set by a static mute rule or by muting the finding directly.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct StaticMute {
            /// The static mute state. If the value is `MUTED` or `UNMUTED`, then the
            /// finding's overall mute state will have the same value.
            #[prost(enumeration = "super::Mute", tag = "1")]
            pub state: i32,
            /// When the static mute was applied.
            #[prost(message, optional, tag = "2")]
            pub apply_time: ::core::option::Option<::prost_types::Timestamp>,
        }
        /// The record of a dynamic mute rule that matches the finding.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DynamicMuteRecord {
            /// The relative resource name of the mute rule, represented by a mute
            /// config, that created this record, for example
            /// `organizations/123/muteConfigs/mymuteconfig` or
            /// `organizations/123/locations/global/muteConfigs/mymuteconfig`.
            #[prost(string, tag = "1")]
            pub mute_config: ::prost::alloc::string::String,
            /// When the dynamic mute rule first matched the finding.
            #[prost(message, optional, tag = "2")]
            pub match_time: ::core::option::Option<::prost_types::Timestamp>,
        }
    }
    /// The state of the finding.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unspecified state.
        Unspecified = 0,
        /// The finding requires attention and has not been addressed yet.
        Active = 1,
        /// The finding has been fixed, triaged as a non-issue or otherwise addressed
        /// and is no longer active.
        Inactive = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
    /// The severity of the finding.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Severity {
        /// This value is used for findings when a source doesn't write a severity
        /// value.
        Unspecified = 0,
        /// Vulnerability:
        /// A critical vulnerability is easily discoverable by an external actor,
        /// exploitable, and results in the direct ability to execute arbitrary code,
        /// exfiltrate data, and otherwise gain additional access and privileges to
        /// cloud resources and workloads. Examples include publicly accessible
        /// unprotected user data and public SSH access with weak or no
        /// passwords.
        ///
        /// Threat:
        /// Indicates a threat that is able to access, modify, or delete data or
        /// execute unauthorized code within existing resources.
        Critical = 1,
        /// Vulnerability:
        /// A high risk vulnerability can be easily discovered and exploited in
        /// combination with other vulnerabilities in order to gain direct access and
        /// the ability to execute arbitrary code, exfiltrate data, and otherwise
        /// gain additional access and privileges to cloud resources and workloads.
        /// An example is a database with weak or no passwords that is only
        /// accessible internally. This database could easily be compromised by an
        /// actor that had access to the internal network.
        ///
        /// Threat:
        /// Indicates a threat that is able to create new computational resources in
        /// an environment but not able to access data or execute code in existing
        /// resources.
        High = 2,
        /// Vulnerability:
        /// A medium risk vulnerability could be used by an actor to gain access to
        /// resources or privileges that enable them to eventually (through multiple
        /// steps or a complex exploit) gain access and the ability to execute
        /// arbitrary code or exfiltrate data. An example is a service account with
        /// access to more projects than it should have. If an actor gains access to
        /// the service account, they could potentially use that access to manipulate
        /// a project the service account was not intended to.
        ///
        /// Threat:
        /// Indicates a threat that is able to cause operational impact but may not
        /// access data or execute unauthorized code.
        Medium = 3,
        /// Vulnerability:
        /// A low risk vulnerability hampers a security organization's ability to
        /// detect vulnerabilities or active threats in their deployment, or prevents
        /// the root cause investigation of security issues. An example is monitoring
        /// and logs being disabled for resource configurations and access.
        ///
        /// Threat:
        /// Indicates a threat that has obtained minimal access to an environment but
        /// is not able to access data, execute code, or create resources.
        Low = 4,
    }
    impl Severity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SEVERITY_UNSPECIFIED",
                Self::Critical => "CRITICAL",
                Self::High => "HIGH",
                Self::Medium => "MEDIUM",
                Self::Low => "LOW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
                "CRITICAL" => Some(Self::Critical),
                "HIGH" => Some(Self::High),
                "MEDIUM" => Some(Self::Medium),
                "LOW" => Some(Self::Low),
                _ => None,
            }
        }
    }
    /// Mute state a finding can be in.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mute {
        /// Unspecified.
        Unspecified = 0,
        /// Finding has been muted.
        Muted = 1,
        /// Finding has been unmuted.
        Unmuted = 2,
        /// Finding has never been muted/unmuted.
        Undefined = 4,
    }
    impl Mute {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MUTE_UNSPECIFIED",
                Self::Muted => "MUTED",
                Self::Unmuted => "UNMUTED",
                Self::Undefined => "UNDEFINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MUTE_UNSPECIFIED" => Some(Self::Unspecified),
                "MUTED" => Some(Self::Muted),
                "UNMUTED" => Some(Self::Unmuted),
                "UNDEFINED" => Some(Self::Undefined),
                _ => None,
            }
        }
    }
    /// Represents what kind of Finding it is.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FindingClass {
        /// Unspecified finding class.
        Unspecified = 0,
        /// Describes unwanted or malicious activity.
        Threat = 1,
        /// Describes a potential weakness in software that increases risk to
        /// Confidentiality & Integrity & Availability.
        Vulnerability = 2,
        /// Describes a potential weakness in cloud resource/asset configuration that
        /// increases risk.
        Misconfiguration = 3,
        /// Describes a security observation that is for informational purposes.
        Observation = 4,
        /// Describes an error that prevents some SCC functionality.
        SccError = 5,
        /// Describes a potential security risk due to a change in the security
        /// posture.
        PostureViolation = 6,
        /// Describes a group of security issues that, when the issues
        /// occur together, represent a greater risk than when the issues occur
        /// independently. A group of such issues is referred to as a toxic
        /// combination.
        ToxicCombination = 7,
    }
    impl FindingClass {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FINDING_CLASS_UNSPECIFIED",
                Self::Threat => "THREAT",
                Self::Vulnerability => "VULNERABILITY",
                Self::Misconfiguration => "MISCONFIGURATION",
                Self::Observation => "OBSERVATION",
                Self::SccError => "SCC_ERROR",
                Self::PostureViolation => "POSTURE_VIOLATION",
                Self::ToxicCombination => "TOXIC_COMBINATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FINDING_CLASS_UNSPECIFIED" => Some(Self::Unspecified),
                "THREAT" => Some(Self::Threat),
                "VULNERABILITY" => Some(Self::Vulnerability),
                "MISCONFIGURATION" => Some(Self::Misconfiguration),
                "OBSERVATION" => Some(Self::Observation),
                "SCC_ERROR" => Some(Self::SccError),
                "POSTURE_VIOLATION" => Some(Self::PostureViolation),
                "TOXIC_COMBINATION" => Some(Self::ToxicCombination),
                _ => None,
            }
        }
    }
}
/// A mute config is a Cloud SCC resource that contains the configuration
/// to mute create/update events of findings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MuteConfig {
    /// This field will be ignored if provided on config creation. Format
    /// `organizations/{organization}/muteConfigs/{mute_config}`
    /// `folders/{folder}/muteConfigs/{mute_config}`
    /// `projects/{project}/muteConfigs/{mute_config}`
    /// `organizations/{organization}/locations/global/muteConfigs/{mute_config}`
    /// `folders/{folder}/locations/global/muteConfigs/{mute_config}`
    /// `projects/{project}/locations/global/muteConfigs/{mute_config}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The human readable name to be displayed for the mute config.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// A description of the mute config.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Required. An expression that defines the filter to apply across
    /// create/update events of findings. While creating a filter string, be
    /// mindful of the scope in which the mute configuration is being created.
    /// E.g., If a filter contains project = X but is created under the project = Y
    /// scope, it might not match any findings.
    ///
    /// The following field and operator combinations are supported:
    ///
    /// * severity: `=`, `:`
    /// * category: `=`, `:`
    /// * resource.name: `=`, `:`
    /// * resource.project_name: `=`, `:`
    /// * resource.project_display_name: `=`, `:`
    /// * resource.folders.resource_folder: `=`, `:`
    /// * resource.parent_name: `=`, `:`
    /// * resource.parent_display_name: `=`, `:`
    /// * resource.type: `=`, `:`
    /// * finding_class: `=`, `:`
    /// * indicator.ip_addresses: `=`, `:`
    /// * indicator.domains: `=`, `:`
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Output only. The time at which the mute config was created.
    /// This field is set by the server and will be ignored if provided on config
    /// creation.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The most recent time at which the mute config was updated.
    /// This field is set by the server and will be ignored if provided on config
    /// creation or update.
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Email address of the user who last edited the mute config.
    /// This field is set by the server and will be ignored if provided on config
    /// creation or update.
    #[prost(string, tag = "7")]
    pub most_recent_editor: ::prost::alloc::string::String,
    /// Optional. The type of the mute config, which determines what type of mute
    /// state the config affects. The static mute state takes precedence over the
    /// dynamic mute state. Immutable after creation. STATIC by default if not set
    /// during creation.
    #[prost(enumeration = "mute_config::MuteConfigType", tag = "8")]
    pub r#type: i32,
    /// Optional. The expiry of the mute config. Only applicable for dynamic
    /// configs. If the expiry is set, when the config expires, it is removed from
    /// all findings.
    #[prost(message, optional, tag = "9")]
    pub expiry_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `MuteConfig`.
pub mod mute_config {
    /// The type of MuteConfig.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MuteConfigType {
        /// Unused.
        Unspecified = 0,
        /// A static mute config, which sets the static mute state of future matching
        /// findings to muted. Once the static mute state has been set, finding or
        /// config modifications will not affect the state.
        Static = 1,
        /// A dynamic mute config, which is applied to existing and future matching
        /// findings, setting their dynamic mute state to "muted". If the config is
        /// updated or deleted, or a matching finding is updated, such that the
        /// finding doesn't match the config, the config will be removed from the
        /// finding, and the finding's dynamic mute state may become "unmuted"
        /// (unless other configs still match).
        Dynamic = 2,
    }
    impl MuteConfigType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MUTE_CONFIG_TYPE_UNSPECIFIED",
                Self::Static => "STATIC",
                Self::Dynamic => "DYNAMIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MUTE_CONFIG_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STATIC" => Some(Self::Static),
                "DYNAMIC" => Some(Self::Dynamic),
                _ => None,
            }
        }
    }
}
/// Cloud Security Command Center (Cloud SCC) notification configs.
///
/// A notification config is a Cloud SCC resource that contains the configuration
/// to send notifications for create/update events of findings, assets and etc.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationConfig {
    /// The relative resource name of this notification config. See:
    /// <https://cloud.google.com/apis/design/resource_names#relative_resource_name>
    /// Example:
    /// "organizations/{organization_id}/notificationConfigs/notify_public_bucket",
    /// "folders/{folder_id}/notificationConfigs/notify_public_bucket",
    /// or "projects/{project_id}/notificationConfigs/notify_public_bucket".
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The description of the notification config (max of 1024 characters).
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// The Pub/Sub topic to send notifications to. Its format is
    /// "projects/\[project_id\]/topics/\[topic\]".
    #[prost(string, tag = "3")]
    pub pubsub_topic: ::prost::alloc::string::String,
    /// Output only. The service account that needs "pubsub.topics.publish"
    /// permission to publish to the Pub/Sub topic.
    #[prost(string, tag = "4")]
    pub service_account: ::prost::alloc::string::String,
    /// The config for triggering notifications.
    #[prost(oneof = "notification_config::NotifyConfig", tags = "5")]
    pub notify_config: ::core::option::Option<notification_config::NotifyConfig>,
}
/// Nested message and enum types in `NotificationConfig`.
pub mod notification_config {
    /// The config for streaming-based notifications, which send each event as soon
    /// as it is detected.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StreamingConfig {
        /// Expression that defines the filter to apply across create/update events
        /// of assets or findings as specified by the event type. The expression is a
        /// list of zero or more restrictions combined via logical operators `AND`
        /// and `OR`. Parentheses are supported, and `OR` has higher precedence than
        /// `AND`.
        ///
        /// Restrictions have the form `<field> <operator> <value>` and may have a
        /// `-` character in front of them to indicate negation. The fields map to
        /// those defined in the corresponding resource.
        ///
        /// The supported operators are:
        ///
        /// * `=` for all value types.
        /// * `>`, `<`, `>=`, `<=` for integer values.
        /// * `:`, meaning substring matching, for strings.
        ///
        /// The supported value types are:
        ///
        /// * string literals in quotes.
        /// * integer literals without quotes.
        /// * boolean literals `true` and `false` without quotes.
        #[prost(string, tag = "1")]
        pub filter: ::prost::alloc::string::String,
    }
    /// The config for triggering notifications.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum NotifyConfig {
        /// The config for triggering streaming-based notifications.
        #[prost(message, tag = "5")]
        StreamingConfig(StreamingConfig),
    }
}
/// Information related to the Google Cloud resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Resource {
    /// The full resource name of the resource. See:
    /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The human readable name of the resource.
    #[prost(string, tag = "8")]
    pub display_name: ::prost::alloc::string::String,
    /// The full resource type of the resource.
    #[prost(string, tag = "6")]
    pub r#type: ::prost::alloc::string::String,
    /// The full resource name of project that the resource belongs to.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// The project ID that the resource belongs to.
    #[prost(string, tag = "3")]
    pub project_display_name: ::prost::alloc::string::String,
    /// The full resource name of resource's parent.
    #[prost(string, tag = "4")]
    pub parent: ::prost::alloc::string::String,
    /// The human readable name of resource's parent.
    #[prost(string, tag = "5")]
    pub parent_display_name: ::prost::alloc::string::String,
    /// Output only. Contains a Folder message for each folder in the assets
    /// ancestry. The first folder is the deepest nested folder, and the last
    /// folder is the folder directly under the Organization.
    #[prost(message, repeated, tag = "7")]
    pub folders: ::prost::alloc::vec::Vec<Folder>,
    /// Indicates which cloud provider the resource resides in.
    #[prost(enumeration = "CloudProvider", tag = "9")]
    pub cloud_provider: i32,
    /// Indicates which organization or tenant in the cloud provider the finding
    /// applies to.
    #[prost(string, tag = "10")]
    pub organization: ::prost::alloc::string::String,
    /// The parent service or product from which the resource is provided, for
    /// example, GKE or SNS.
    #[prost(string, tag = "11")]
    pub service: ::prost::alloc::string::String,
    /// The region or location of the service (if applicable).
    #[prost(string, tag = "12")]
    pub location: ::prost::alloc::string::String,
    /// Provides the path to the resource within the resource hierarchy.
    #[prost(message, optional, tag = "18")]
    pub resource_path: ::core::option::Option<ResourcePath>,
    /// A string representation of the resource path.
    /// For Google Cloud, it has the format of
    /// `organizations/{organization_id}/folders/{folder_id}/folders/{folder_id}/projects/{project_id}`
    /// where there can be any number of folders.
    /// For AWS, it has the format of
    /// `org/{organization_id}/ou/{organizational_unit_id}/ou/{organizational_unit_id}/account/{account_id}`
    /// where there can be any number of organizational units.
    /// For Azure, it has the format of
    /// `mg/{management_group_id}/mg/{management_group_id}/subscription/{subscription_id}/rg/{resource_group_name}`
    /// where there can be any number of management groups.
    #[prost(string, tag = "19")]
    pub resource_path_string: ::prost::alloc::string::String,
    #[prost(oneof = "resource::CloudProviderMetadata", tags = "16, 17")]
    pub cloud_provider_metadata: ::core::option::Option<resource::CloudProviderMetadata>,
}
/// Nested message and enum types in `Resource`.
pub mod resource {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CloudProviderMetadata {
        /// The AWS metadata associated with the finding.
        #[prost(message, tag = "16")]
        AwsMetadata(super::AwsMetadata),
        /// The Azure metadata associated with the finding.
        #[prost(message, tag = "17")]
        AzureMetadata(super::AzureMetadata),
    }
}
/// AWS metadata associated with the resource, only applicable if the finding's
/// cloud provider is Amazon Web Services.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AwsMetadata {
    /// The AWS organization associated with the resource.
    #[prost(message, optional, tag = "2")]
    pub organization: ::core::option::Option<aws_metadata::AwsOrganization>,
    /// A list of AWS organizational units associated with the resource, ordered
    /// from lowest level (closest to the account) to highest level.
    #[prost(message, repeated, tag = "3")]
    pub organizational_units: ::prost::alloc::vec::Vec<
        aws_metadata::AwsOrganizationalUnit,
    >,
    /// The AWS account associated with the resource.
    #[prost(message, optional, tag = "4")]
    pub account: ::core::option::Option<aws_metadata::AwsAccount>,
}
/// Nested message and enum types in `AwsMetadata`.
pub mod aws_metadata {
    /// An organization is a collection of accounts that are centrally managed
    /// together using consolidated billing, organized hierarchically with
    /// organizational units (OUs), and controlled with policies.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AwsOrganization {
        /// The unique identifier (ID) for the organization. The regex pattern for an
        /// organization ID string requires "o-" followed by from 10 to 32 lowercase
        /// letters or digits.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
    }
    /// An Organizational Unit (OU) is a container of AWS accounts within a root of
    /// an organization. Policies that are attached to an OU apply to all accounts
    /// contained in that OU and in any child OUs.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AwsOrganizationalUnit {
        /// The unique identifier (ID) associated with this OU. The regex pattern for
        /// an organizational unit ID string requires "ou-" followed by from 4 to 32
        /// lowercase letters or digits (the ID of the root that contains the OU).
        /// This string is followed by a second "-" dash and from 8 to 32 additional
        /// lowercase letters or digits. For example, "ou-ab12-cd34ef56".
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// The friendly name of the OU.
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
    }
    /// An AWS account that is a member of an organization.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AwsAccount {
        /// The unique identifier (ID) of the account, containing exactly 12 digits.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// The friendly name of this account.
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
    }
}
/// Azure metadata associated with the resource, only applicable if the finding's
/// cloud provider is Microsoft Azure.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AzureMetadata {
    /// A list of Azure management groups associated with the resource, ordered
    /// from lowest level (closest to the subscription) to highest level.
    #[prost(message, repeated, tag = "4")]
    pub management_groups: ::prost::alloc::vec::Vec<
        azure_metadata::AzureManagementGroup,
    >,
    /// The Azure subscription associated with the resource.
    #[prost(message, optional, tag = "5")]
    pub subscription: ::core::option::Option<azure_metadata::AzureSubscription>,
    /// The Azure resource group associated with the resource.
    #[prost(message, optional, tag = "6")]
    pub resource_group: ::core::option::Option<azure_metadata::AzureResourceGroup>,
}
/// Nested message and enum types in `AzureMetadata`.
pub mod azure_metadata {
    /// Represents an Azure management group.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AzureManagementGroup {
        /// The UUID of the Azure management group, for example,
        /// `20000000-0001-0000-0000-000000000000`.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// The display name of the Azure management group.
        #[prost(string, tag = "2")]
        pub display_name: ::prost::alloc::string::String,
    }
    /// Represents an Azure subscription.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AzureSubscription {
        /// The UUID of the Azure subscription, for example,
        /// `291bba3f-e0a5-47bc-a099-3bdcb2a50a05`.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// The display name of the Azure subscription.
        #[prost(string, tag = "2")]
        pub display_name: ::prost::alloc::string::String,
    }
    /// Represents an Azure resource group.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AzureResourceGroup {
        /// The name of the Azure resource group. This is not a UUID.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
    }
}
/// Represents the path of resources leading up to the resource this finding is
/// about.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePath {
    /// The list of nodes that make the up resource path, ordered from lowest
    /// level to highest level.
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<resource_path::ResourcePathNode>,
}
/// Nested message and enum types in `ResourcePath`.
pub mod resource_path {
    /// A node within the resource path. Each node represents a resource within the
    /// resource hierarchy.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResourcePathNode {
        /// The type of resource this node represents.
        #[prost(enumeration = "ResourcePathNodeType", tag = "1")]
        pub node_type: i32,
        /// The ID of the resource this node represents.
        #[prost(string, tag = "2")]
        pub id: ::prost::alloc::string::String,
        /// The display name of the resource this node represents.
        #[prost(string, tag = "3")]
        pub display_name: ::prost::alloc::string::String,
    }
    /// The type of resource the node represents.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResourcePathNodeType {
        /// Node type is unspecified.
        Unspecified = 0,
        /// The node represents a Google Cloud organization.
        GcpOrganization = 1,
        /// The node represents a Google Cloud folder.
        GcpFolder = 2,
        /// The node represents a Google Cloud project.
        GcpProject = 3,
        /// The node represents an AWS organization.
        AwsOrganization = 4,
        /// The node represents an AWS organizational unit.
        AwsOrganizationalUnit = 5,
        /// The node represents an AWS account.
        AwsAccount = 6,
        /// The node represents an Azure management group.
        AzureManagementGroup = 7,
        /// The node represents an Azure subscription.
        AzureSubscription = 8,
        /// The node represents an Azure resource group.
        AzureResourceGroup = 9,
    }
    impl ResourcePathNodeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESOURCE_PATH_NODE_TYPE_UNSPECIFIED",
                Self::GcpOrganization => "GCP_ORGANIZATION",
                Self::GcpFolder => "GCP_FOLDER",
                Self::GcpProject => "GCP_PROJECT",
                Self::AwsOrganization => "AWS_ORGANIZATION",
                Self::AwsOrganizationalUnit => "AWS_ORGANIZATIONAL_UNIT",
                Self::AwsAccount => "AWS_ACCOUNT",
                Self::AzureManagementGroup => "AZURE_MANAGEMENT_GROUP",
                Self::AzureSubscription => "AZURE_SUBSCRIPTION",
                Self::AzureResourceGroup => "AZURE_RESOURCE_GROUP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESOURCE_PATH_NODE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "GCP_ORGANIZATION" => Some(Self::GcpOrganization),
                "GCP_FOLDER" => Some(Self::GcpFolder),
                "GCP_PROJECT" => Some(Self::GcpProject),
                "AWS_ORGANIZATION" => Some(Self::AwsOrganization),
                "AWS_ORGANIZATIONAL_UNIT" => Some(Self::AwsOrganizationalUnit),
                "AWS_ACCOUNT" => Some(Self::AwsAccount),
                "AZURE_MANAGEMENT_GROUP" => Some(Self::AzureManagementGroup),
                "AZURE_SUBSCRIPTION" => Some(Self::AzureSubscription),
                "AZURE_RESOURCE_GROUP" => Some(Self::AzureResourceGroup),
                _ => None,
            }
        }
    }
}
/// Enumeration representing the various cloud providers a finding's resource
/// could reside in.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CloudProvider {
    /// The cloud provider is unspecified.
    Unspecified = 0,
    /// The cloud provider is Google Cloud Platform.
    GoogleCloudPlatform = 1,
    /// The cloud provider is Amazon Web Services.
    AmazonWebServices = 2,
    /// The cloud provider is Microsoft Azure.
    MicrosoftAzure = 3,
}
impl CloudProvider {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CLOUD_PROVIDER_UNSPECIFIED",
            Self::GoogleCloudPlatform => "GOOGLE_CLOUD_PLATFORM",
            Self::AmazonWebServices => "AMAZON_WEB_SERVICES",
            Self::MicrosoftAzure => "MICROSOFT_AZURE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLOUD_PROVIDER_UNSPECIFIED" => Some(Self::Unspecified),
            "GOOGLE_CLOUD_PLATFORM" => Some(Self::GoogleCloudPlatform),
            "AMAZON_WEB_SERVICES" => Some(Self::AmazonWebServices),
            "MICROSOFT_AZURE" => Some(Self::MicrosoftAzure),
            _ => None,
        }
    }
}
/// Cloud SCC's Notification
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationMessage {
    /// Name of the notification config that generated current notification.
    #[prost(string, tag = "1")]
    pub notification_config_name: ::prost::alloc::string::String,
    /// The Cloud resource tied to this notification's Finding.
    #[prost(message, optional, tag = "3")]
    pub resource: ::core::option::Option<Resource>,
    /// Notification Event.
    #[prost(oneof = "notification_message::Event", tags = "2")]
    pub event: ::core::option::Option<notification_message::Event>,
}
/// Nested message and enum types in `NotificationMessage`.
pub mod notification_message {
    /// Notification Event.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        /// If it's a Finding based notification config, this field will be
        /// populated.
        #[prost(message, tag = "2")]
        Finding(super::Finding),
    }
}
/// User specified settings that are attached to the Security Command
/// Center organization.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrganizationSettings {
    /// The relative resource name of the settings. See:
    /// <https://cloud.google.com/apis/design/resource_names#relative_resource_name>
    /// Example:
    /// "organizations/{organization_id}/organizationSettings".
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// A flag that indicates if Asset Discovery should be enabled. If the flag is
    /// set to `true`, then discovery of assets will occur. If it is set to
    /// `false`, all historical assets will remain, but discovery of future assets
    /// will not occur.
    #[prost(bool, tag = "2")]
    pub enable_asset_discovery: bool,
    /// The configuration used for Asset Discovery runs.
    #[prost(message, optional, tag = "3")]
    pub asset_discovery_config: ::core::option::Option<
        organization_settings::AssetDiscoveryConfig,
    >,
}
/// Nested message and enum types in `OrganizationSettings`.
pub mod organization_settings {
    /// The configuration used for Asset Discovery runs.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AssetDiscoveryConfig {
        /// The project ids to use for filtering asset discovery.
        #[prost(string, repeated, tag = "1")]
        pub project_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// The mode to use for filtering asset discovery.
        #[prost(enumeration = "asset_discovery_config::InclusionMode", tag = "2")]
        pub inclusion_mode: i32,
        /// The folder ids to use for filtering asset discovery.
        /// It consists of only digits, e.g., 756619654966.
        #[prost(string, repeated, tag = "3")]
        pub folder_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `AssetDiscoveryConfig`.
    pub mod asset_discovery_config {
        /// The mode of inclusion when running Asset Discovery.
        /// Asset discovery can be limited by explicitly identifying projects to be
        /// included or excluded. If INCLUDE_ONLY is set, then only those projects
        /// within the organization and their children are discovered during asset
        /// discovery. If EXCLUDE is set, then projects that don't match those
        /// projects are discovered during asset discovery. If neither are set, then
        /// all projects within the organization are discovered during asset
        /// discovery.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum InclusionMode {
            /// Unspecified. Setting the mode with this value will disable
            /// inclusion/exclusion filtering for Asset Discovery.
            Unspecified = 0,
            /// Asset Discovery will capture only the resources within the projects
            /// specified. All other resources will be ignored.
            IncludeOnly = 1,
            /// Asset Discovery will ignore all resources under the projects specified.
            /// All other resources will be retrieved.
            Exclude = 2,
        }
        impl InclusionMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "INCLUSION_MODE_UNSPECIFIED",
                    Self::IncludeOnly => "INCLUDE_ONLY",
                    Self::Exclude => "EXCLUDE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "INCLUSION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                    "INCLUDE_ONLY" => Some(Self::IncludeOnly),
                    "EXCLUDE" => Some(Self::Exclude),
                    _ => None,
                }
            }
        }
    }
}
/// A resource value configuration (RVC) is a mapping configuration of user's
/// resources to resource values. Used in Attack path simulations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceValueConfig {
    /// Name for the resource value configuration
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Resource value level this expression represents
    #[prost(enumeration = "ResourceValue", tag = "2")]
    pub resource_value: i32,
    /// Required. Tag values combined with `AND` to check against.
    /// Values in the form "tagValues/123"
    /// Example: `\[ "tagValues/123", "tagValues/456", "tagValues/789" \]`
    /// <https://cloud.google.com/resource-manager/docs/tags/tags-creating-and-managing>
    #[prost(string, repeated, tag = "3")]
    pub tag_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Apply resource_value only to resources that match resource_type.
    /// resource_type will be checked with `AND` of other resources.
    /// For example, "storage.googleapis.com/Bucket" with resource_value "HIGH"
    /// will apply "HIGH" value only to "storage.googleapis.com/Bucket" resources.
    #[prost(string, tag = "4")]
    pub resource_type: ::prost::alloc::string::String,
    /// Project or folder to scope this configuration to.
    /// For example, "project/456" would apply this configuration only to resources
    /// in "project/456" scope will be checked with `AND` of other
    /// resources.
    #[prost(string, tag = "5")]
    pub scope: ::prost::alloc::string::String,
    /// List of resource labels to search for, evaluated with `AND`.
    /// For example, `"resource_labels_selector": {"key": "value", "env": "prod"}`
    /// will match resources with labels "key": "value" `AND` "env":
    /// "prod"
    /// <https://cloud.google.com/resource-manager/docs/creating-managing-labels>
    #[prost(map = "string, string", tag = "6")]
    pub resource_labels_selector: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Description of the resource value configuration.
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Timestamp this resource value configuration was created.
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp this resource value configuration was last updated.
    #[prost(message, optional, tag = "9")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Cloud provider this configuration applies to
    #[prost(enumeration = "CloudProvider", tag = "10")]
    pub cloud_provider: i32,
    /// A mapping of the sensitivity on Sensitive Data Protection finding to
    /// resource values. This mapping can only be used in combination with a
    /// resource_type that is related to BigQuery, e.g.
    /// "bigquery.googleapis.com/Dataset".
    #[prost(message, optional, tag = "11")]
    pub sensitive_data_protection_mapping: ::core::option::Option<
        resource_value_config::SensitiveDataProtectionMapping,
    >,
}
/// Nested message and enum types in `ResourceValueConfig`.
pub mod resource_value_config {
    /// Resource value mapping for Sensitive Data Protection findings.
    /// If any of these mappings have a resource value that is not unspecified,
    /// the resource_value field will be ignored when reading this configuration.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SensitiveDataProtectionMapping {
        /// Resource value mapping for high-sensitivity Sensitive Data Protection
        /// findings
        #[prost(enumeration = "super::ResourceValue", tag = "1")]
        pub high_sensitivity_mapping: i32,
        /// Resource value mapping for medium-sensitivity Sensitive Data Protection
        /// findings
        #[prost(enumeration = "super::ResourceValue", tag = "2")]
        pub medium_sensitivity_mapping: i32,
    }
}
/// Value enum to map to a resource
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResourceValue {
    /// Unspecific value
    Unspecified = 0,
    /// High resource value
    High = 1,
    /// Medium resource value
    Medium = 2,
    /// Low resource value
    Low = 3,
    /// No resource value, e.g. ignore these resources
    None = 4,
}
impl ResourceValue {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RESOURCE_VALUE_UNSPECIFIED",
            Self::High => "HIGH",
            Self::Medium => "MEDIUM",
            Self::Low => "LOW",
            Self::None => "NONE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESOURCE_VALUE_UNSPECIFIED" => Some(Self::Unspecified),
            "HIGH" => Some(Self::High),
            "MEDIUM" => Some(Self::Medium),
            "LOW" => Some(Self::Low),
            "NONE" => Some(Self::None),
            _ => None,
        }
    }
}
/// Response of asset discovery run
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RunAssetDiscoveryResponse {
    /// The state of an asset discovery run.
    #[prost(enumeration = "run_asset_discovery_response::State", tag = "1")]
    pub state: i32,
    /// The duration between asset discovery run start and end
    #[prost(message, optional, tag = "2")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
}
/// Nested message and enum types in `RunAssetDiscoveryResponse`.
pub mod run_asset_discovery_response {
    /// The state of an asset discovery run.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Asset discovery run state was unspecified.
        Unspecified = 0,
        /// Asset discovery run completed successfully.
        Completed = 1,
        /// Asset discovery run was cancelled with tasks still pending, as another
        /// run for the same organization was started with a higher priority.
        Superseded = 2,
        /// Asset discovery run was killed and terminated.
        Terminated = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Completed => "COMPLETED",
                Self::Superseded => "SUPERSEDED",
                Self::Terminated => "TERMINATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "COMPLETED" => Some(Self::Completed),
                "SUPERSEDED" => Some(Self::Superseded),
                "TERMINATED" => Some(Self::Terminated),
                _ => None,
            }
        }
    }
}
/// Represents an instance of a Security Health Analytics custom module,
/// including its full module name, display name, enablement state, and last
/// updated time. You can create a custom module at the organization, folder, or
/// project level. Custom modules that you create at the organization or folder
/// level are inherited by the child folders and projects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityHealthAnalyticsCustomModule {
    /// Immutable. The resource name of the custom module.
    /// Its format is
    /// "organizations/{organization}/securityHealthAnalyticsSettings/customModules/{customModule}",
    /// or
    /// "folders/{folder}/securityHealthAnalyticsSettings/customModules/{customModule}",
    /// or
    /// "projects/{project}/securityHealthAnalyticsSettings/customModules/{customModule}"
    ///
    /// The id {customModule} is server-generated and is not user settable.
    /// It will be a numeric id containing 1-20 digits.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The display name of the Security Health Analytics custom module. This
    /// display name becomes the finding category for all findings that are
    /// returned by this custom module. The display name must be between 1 and
    /// 128 characters, start with a lowercase letter, and contain alphanumeric
    /// characters or underscores only.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// The enablement state of the custom module.
    #[prost(
        enumeration = "security_health_analytics_custom_module::EnablementState",
        tag = "4"
    )]
    pub enablement_state: i32,
    /// Output only. The time at which the custom module was last updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The editor that last updated the custom module.
    #[prost(string, tag = "6")]
    pub last_editor: ::prost::alloc::string::String,
    /// Output only. If empty, indicates that the custom module was created in the
    /// organization, folder, or project in which you are viewing the custom
    /// module. Otherwise, `ancestor_module` specifies the organization or folder
    /// from which the custom module is inherited.
    #[prost(string, tag = "7")]
    pub ancestor_module: ::prost::alloc::string::String,
    /// The user specified custom configuration for the module.
    #[prost(message, optional, tag = "8")]
    pub custom_config: ::core::option::Option<CustomConfig>,
}
/// Nested message and enum types in `SecurityHealthAnalyticsCustomModule`.
pub mod security_health_analytics_custom_module {
    /// Possible enablement states of a custom module.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnablementState {
        /// Unspecified enablement state.
        Unspecified = 0,
        /// The module is enabled at the given CRM resource.
        Enabled = 1,
        /// The module is disabled at the given CRM resource.
        Disabled = 2,
        /// State is inherited from an ancestor module. The module will either
        /// be effectively ENABLED or DISABLED based on its closest non-inherited
        /// ancestor module in the CRM hierarchy.
        Inherited = 3,
    }
    impl EnablementState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ENABLEMENT_STATE_UNSPECIFIED",
                Self::Enabled => "ENABLED",
                Self::Disabled => "DISABLED",
                Self::Inherited => "INHERITED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENABLEMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                "INHERITED" => Some(Self::Inherited),
                _ => None,
            }
        }
    }
}
/// A resource that is determined to have value to a user's system
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValuedResource {
    /// Valued resource name, for example,
    ///   e.g.:
    ///   `organizations/123/simulations/456/valuedResources/789`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The
    /// [full resource
    /// name](<https://cloud.google.com/apis/design/resource_names#full_resource_name>)
    /// of the valued resource.
    #[prost(string, tag = "2")]
    pub resource: ::prost::alloc::string::String,
    /// The [resource
    /// type](<https://cloud.google.com/asset-inventory/docs/supported-asset-types>)
    /// of the valued resource.
    #[prost(string, tag = "3")]
    pub resource_type: ::prost::alloc::string::String,
    /// Human-readable name of the valued resource.
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    /// How valuable this resource is.
    #[prost(enumeration = "valued_resource::ResourceValue", tag = "5")]
    pub resource_value: i32,
    /// Exposed score for this valued resource. A value of 0 means no exposure was
    /// detected exposure.
    #[prost(double, tag = "6")]
    pub exposed_score: f64,
    /// List of resource value configurations' metadata used to determine the value
    /// of this resource. Maximum of 100.
    #[prost(message, repeated, tag = "7")]
    pub resource_value_configs_used: ::prost::alloc::vec::Vec<
        ResourceValueConfigMetadata,
    >,
}
/// Nested message and enum types in `ValuedResource`.
pub mod valued_resource {
    /// How valuable the resource is.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResourceValue {
        /// The resource value isn't specified.
        Unspecified = 0,
        /// This is a low-value resource.
        Low = 1,
        /// This is a medium-value resource.
        Medium = 2,
        /// This is a high-value resource.
        High = 3,
    }
    impl ResourceValue {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESOURCE_VALUE_UNSPECIFIED",
                Self::Low => "RESOURCE_VALUE_LOW",
                Self::Medium => "RESOURCE_VALUE_MEDIUM",
                Self::High => "RESOURCE_VALUE_HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESOURCE_VALUE_UNSPECIFIED" => Some(Self::Unspecified),
                "RESOURCE_VALUE_LOW" => Some(Self::Low),
                "RESOURCE_VALUE_MEDIUM" => Some(Self::Medium),
                "RESOURCE_VALUE_HIGH" => Some(Self::High),
                _ => None,
            }
        }
    }
}
/// Metadata about a ResourceValueConfig. For example, id and name.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceValueConfigMetadata {
    /// Resource value config name
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Attack path simulation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Simulation {
    /// Full resource name of the Simulation:
    /// `organizations/123/simulations/456`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time simulation was created
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Resource value configurations' metadata used in this simulation. Maximum of
    /// 100.
    #[prost(message, repeated, tag = "3")]
    pub resource_value_configs_metadata: ::prost::alloc::vec::Vec<
        ResourceValueConfigMetadata,
    >,
    /// Indicates which cloud provider was used in this simulation.
    #[prost(enumeration = "CloudProvider", tag = "4")]
    pub cloud_provider: i32,
}
/// Security Command Center finding source. A finding source
/// is an entity or a mechanism that can produce a finding. A source is like a
/// container of findings that come from the same scanner, logger, monitor, and
/// other tools.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Source {
    /// The relative resource name of this source. See:
    /// <https://cloud.google.com/apis/design/resource_names#relative_resource_name>
    /// Example:
    /// "organizations/{organization_id}/sources/{source_id}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The source's display name.
    /// A source's display name must be unique amongst its siblings, for example,
    /// two sources with the same parent can't share the same display name.
    /// The display name must have a length between 1 and 64 characters
    /// (inclusive).
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// The description of the source (max of 1024 characters).
    /// Example:
    /// "Web Security Scanner is a web security scanner for common
    /// vulnerabilities in App Engine applications. It can automatically
    /// scan and detect four common vulnerabilities, including cross-site-scripting
    /// (XSS), Flash injection, mixed content (HTTP in HTTPS), and
    /// outdated or insecure libraries."
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// The canonical name of the finding source. It's either
    /// "organizations/{organization_id}/sources/{source_id}",
    /// "folders/{folder_id}/sources/{source_id}", or
    /// "projects/{project_number}/sources/{source_id}",
    /// depending on the closest CRM ancestor of the resource associated with the
    /// finding.
    #[prost(string, tag = "14")]
    pub canonical_name: ::prost::alloc::string::String,
}
/// Request message for bulk findings update.
///
/// Note:
/// 1. If multiple bulk update requests match the same resource, the order in
/// which they get executed is not defined.
/// 2. Once a bulk operation is started, there is no way to stop it.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkMuteFindingsRequest {
    /// Required. The parent, at which bulk action needs to be applied. Its format
    /// is `organizations/\[organization_id\]`, `folders/\[folder_id\]`,
    /// `projects/\[project_id\]`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Expression that identifies findings that should be updated.
    /// The expression is a list of zero or more restrictions combined
    /// via logical operators `AND` and `OR`. Parentheses are supported, and `OR`
    /// has higher precedence than `AND`.
    ///
    /// Restrictions have the form `<field> <operator> <value>` and may have a
    /// `-` character in front of them to indicate negation. The fields map to
    /// those defined in the corresponding resource.
    ///
    /// The supported operators are:
    ///
    /// * `=` for all value types.
    /// * `>`, `<`, `>=`, `<=` for integer values.
    /// * `:`, meaning substring matching, for strings.
    ///
    /// The supported value types are:
    ///
    /// * string literals in quotes.
    /// * integer literals without quotes.
    /// * boolean literals `true` and `false` without quotes.
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// This can be a mute configuration name or any identifier for mute/unmute
    /// of findings based on the filter.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub mute_annotation: ::prost::alloc::string::String,
    /// Optional. All findings matching the given filter will have their mute state
    /// set to this value. The default value is `MUTED`. Setting this to
    /// `UNDEFINED` will clear the mute state on all matching findings.
    #[prost(enumeration = "bulk_mute_findings_request::MuteState", tag = "4")]
    pub mute_state: i32,
}
/// Nested message and enum types in `BulkMuteFindingsRequest`.
pub mod bulk_mute_findings_request {
    /// The mute state.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MuteState {
        /// Unused.
        Unspecified = 0,
        /// Matching findings will be muted (default).
        Muted = 1,
        /// Matching findings will have their mute state cleared.
        Undefined = 2,
    }
    impl MuteState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MUTE_STATE_UNSPECIFIED",
                Self::Muted => "MUTED",
                Self::Undefined => "UNDEFINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MUTE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "MUTED" => Some(Self::Muted),
                "UNDEFINED" => Some(Self::Undefined),
                _ => None,
            }
        }
    }
}
/// The response to a BulkMute request. Contains the LRO information.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BulkMuteFindingsResponse {}
/// Request message for creating a finding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFindingRequest {
    /// Required. Resource name of the new finding's parent. Its format should be
    /// `organizations/\[organization_id\]/sources/\[source_id\]`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Unique identifier provided by the client within the parent scope.
    /// It must be alphanumeric and less than or equal to 32 characters and
    /// greater than 0 characters in length.
    #[prost(string, tag = "2")]
    pub finding_id: ::prost::alloc::string::String,
    /// Required. The Finding being created. The name and security_marks will be
    /// ignored as they are both output only fields on this resource.
    #[prost(message, optional, tag = "3")]
    pub finding: ::core::option::Option<Finding>,
}
/// Request message for creating a mute config.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMuteConfigRequest {
    /// Required. Resource name of the new mute configs's parent. Its format is
    /// `organizations/\[organization_id\]`, `folders/\[folder_id\]`, or
    /// `projects/\[project_id\]`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The mute config being created.
    #[prost(message, optional, tag = "2")]
    pub mute_config: ::core::option::Option<MuteConfig>,
    /// Required. Unique identifier provided by the client within the parent scope.
    /// It must consist of only lowercase letters, numbers, and hyphens, must start
    /// with a letter, must end with either a letter or a number, and must be 63
    /// characters or less.
    #[prost(string, tag = "3")]
    pub mute_config_id: ::prost::alloc::string::String,
}
/// Request message to create single resource value config
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateResourceValueConfigRequest {
    /// Required. Resource name of the new ResourceValueConfig's parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource value config being created.
    #[prost(message, optional, tag = "2")]
    pub resource_value_config: ::core::option::Option<ResourceValueConfig>,
}
/// Request message to create multiple resource value configs
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateResourceValueConfigsRequest {
    /// Required. Resource name of the new ResourceValueConfig's parent.
    /// The parent field in the CreateResourceValueConfigRequest
    /// messages must either be empty or match this field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource value configs to be created.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateResourceValueConfigRequest>,
}
/// Response message for BatchCreateResourceValueConfigs
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateResourceValueConfigsResponse {
    /// The resource value configs created
    #[prost(message, repeated, tag = "1")]
    pub resource_value_configs: ::prost::alloc::vec::Vec<ResourceValueConfig>,
}
/// Request message to delete resource value config
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteResourceValueConfigRequest {
    /// Required. Name of the ResourceValueConfig to delete
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message to get resource value config
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetResourceValueConfigRequest {
    /// Required. Name of the resource value config to retrieve. Its format is
    /// `organizations/{organization}/resourceValueConfigs/{config_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message to list resource value configs of a parent
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListResourceValueConfigsRequest {
    /// Required. The parent, which owns the collection of resource value configs.
    /// Its format is
    /// `organizations/\[organization_id\]`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The number of results to return. The service may return fewer than
    /// this value.
    /// If unspecified, at most 10 configs will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListResourceValueConfigs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListResourceValueConfigs` must match the call that provided the
    /// page token.
    ///
    /// page_size can be specified, and the new page_size will be used.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message to list resource value configs
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListResourceValueConfigsResponse {
    /// The resource value configs from the specified parent.
    #[prost(message, repeated, tag = "1")]
    pub resource_value_configs: ::prost::alloc::vec::Vec<ResourceValueConfig>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is empty, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message to update resource value config
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateResourceValueConfigRequest {
    /// Required. The resource value config being updated.
    #[prost(message, optional, tag = "1")]
    pub resource_value_config: ::core::option::Option<ResourceValueConfig>,
    /// The list of fields to be updated.
    /// If empty all mutable fields will be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for creating a notification config.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNotificationConfigRequest {
    /// Required. Resource name of the new notification config's parent. Its format
    /// is `organizations/\[organization_id\]`, `folders/\[folder_id\]`, or
    /// `projects/\[project_id\]`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required.
    /// Unique identifier provided by the client within the parent scope.
    /// It must be between 1 and 128 characters and contain alphanumeric
    /// characters, underscores, or hyphens only.
    #[prost(string, tag = "2")]
    pub config_id: ::prost::alloc::string::String,
    /// Required. The notification config being created. The name and the service
    /// account will be ignored as they are both output only fields on this
    /// resource.
    #[prost(message, optional, tag = "3")]
    pub notification_config: ::core::option::Option<NotificationConfig>,
}
/// Request message for creating Security Health Analytics custom modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSecurityHealthAnalyticsCustomModuleRequest {
    /// Required. Resource name of the new custom module's parent. Its format is
    /// `organizations/{organization}/securityHealthAnalyticsSettings`,
    /// `folders/{folder}/securityHealthAnalyticsSettings`, or
    /// `projects/{project}/securityHealthAnalyticsSettings`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. SecurityHealthAnalytics custom module to create. The provided
    /// name is ignored and reset with provided parent information and
    /// server-generated ID.
    #[prost(message, optional, tag = "2")]
    pub security_health_analytics_custom_module: ::core::option::Option<
        SecurityHealthAnalyticsCustomModule,
    >,
}
/// Request message for creating a source.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSourceRequest {
    /// Required. Resource name of the new source's parent. Its format should be
    /// `organizations/\[organization_id\]`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The Source being created, only the display_name and description
    /// will be used. All other fields will be ignored.
    #[prost(message, optional, tag = "2")]
    pub source: ::core::option::Option<Source>,
}
/// Request message for deleting a mute config.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteMuteConfigRequest {
    /// Required. Name of the mute config to delete. Its format is
    /// `organizations/{organization}/muteConfigs/{config_id}`,
    /// `folders/{folder}/muteConfigs/{config_id}`,
    /// `projects/{project}/muteConfigs/{config_id}`,
    /// `organizations/{organization}/locations/global/muteConfigs/{config_id}`,
    /// `folders/{folder}/locations/global/muteConfigs/{config_id}`, or
    /// `projects/{project}/locations/global/muteConfigs/{config_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for deleting a notification config.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNotificationConfigRequest {
    /// Required. Name of the notification config to delete. Its format is
    /// `organizations/\[organization_id\]/notificationConfigs/\[config_id\]`,
    /// `folders/\[folder_id\]/notificationConfigs/\[config_id\]`,
    /// or `projects/\[project_id\]/notificationConfigs/\[config_id\]`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for deleting Security Health Analytics custom modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSecurityHealthAnalyticsCustomModuleRequest {
    /// Required. Name of the custom module to delete. Its format is
    /// `organizations/{organization}/securityHealthAnalyticsSettings/customModules/{customModule}`,
    /// `folders/{folder}/securityHealthAnalyticsSettings/customModules/{customModule}`,
    /// or
    /// `projects/{project}/securityHealthAnalyticsSettings/customModules/{customModule}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for retrieving a BigQuery export.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBigQueryExportRequest {
    /// Required. Name of the BigQuery export to retrieve. Its format is
    /// `organizations/{organization}/bigQueryExports/{export_id}`,
    /// `folders/{folder}/bigQueryExports/{export_id}`, or
    /// `projects/{project}/bigQueryExports/{export_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for retrieving a mute config.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMuteConfigRequest {
    /// Required. Name of the mute config to retrieve. Its format is
    /// `organizations/{organization}/muteConfigs/{config_id}`,
    /// `folders/{folder}/muteConfigs/{config_id}`,
    /// `projects/{project}/muteConfigs/{config_id}`,
    /// `organizations/{organization}/locations/global/muteConfigs/{config_id}`,
    /// `folders/{folder}/locations/global/muteConfigs/{config_id}`, or
    /// `projects/{project}/locations/global/muteConfigs/{config_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for getting a notification config.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNotificationConfigRequest {
    /// Required. Name of the notification config to get. Its format is
    /// `organizations/\[organization_id\]/notificationConfigs/\[config_id\]`,
    /// `folders/\[folder_id\]/notificationConfigs/\[config_id\]`,
    /// or `projects/\[project_id\]/notificationConfigs/\[config_id\]`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for getting organization settings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrganizationSettingsRequest {
    /// Required. Name of the organization to get organization settings for. Its
    /// format is `organizations/\[organization_id\]/organizationSettings`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for getting effective Security Health Analytics custom
/// modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEffectiveSecurityHealthAnalyticsCustomModuleRequest {
    /// Required. Name of the effective custom module to get. Its format is
    /// `organizations/{organization}/securityHealthAnalyticsSettings/effectiveCustomModules/{customModule}`,
    /// `folders/{folder}/securityHealthAnalyticsSettings/effectiveCustomModules/{customModule}`,
    /// or
    /// `projects/{project}/securityHealthAnalyticsSettings/effectiveCustomModules/{customModule}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for getting Security Health Analytics custom modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSecurityHealthAnalyticsCustomModuleRequest {
    /// Required. Name of the custom module to get. Its format is
    /// `organizations/{organization}/securityHealthAnalyticsSettings/customModules/{customModule}`,
    /// `folders/{folder}/securityHealthAnalyticsSettings/customModules/{customModule}`,
    /// or
    /// `projects/{project}/securityHealthAnalyticsSettings/customModules/{customModule}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for getting a source.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSourceRequest {
    /// Required. Relative resource name of the source. Its format is
    /// `organizations/\[organization_id\]/source/\[source_id\]`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for grouping by assets.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupAssetsRequest {
    /// Required. The name of the parent to group the assets by. Its format is
    /// `organizations/\[organization_id\]`, `folders/\[folder_id\]`, or
    /// `projects/\[project_id\]`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Expression that defines the filter to apply across assets.
    /// The expression is a list of zero or more restrictions combined via logical
    /// operators `AND` and `OR`.
    /// Parentheses are supported, and `OR` has higher precedence than `AND`.
    ///
    /// Restrictions have the form `<field> <operator> <value>` and may have a `-`
    /// character in front of them to indicate negation. The fields map to those
    /// defined in the Asset resource. Examples include:
    ///
    /// * name
    /// * security_center_properties.resource_name
    /// * resource_properties.a_property
    /// * security_marks.marks.marka
    ///
    /// The supported operators are:
    ///
    /// * `=` for all value types.
    /// * `>`, `<`, `>=`, `<=` for integer values.
    /// * `:`, meaning substring matching, for strings.
    ///
    /// The supported value types are:
    ///
    /// * string literals in quotes.
    /// * integer literals without quotes.
    /// * boolean literals `true` and `false` without quotes.
    ///
    /// The following field and operator combinations are supported:
    ///
    /// * name: `=`
    /// * update_time: `=`, `>`, `<`, `>=`, `<=`
    ///
    ///    Usage: This should be milliseconds since epoch or an RFC3339 string.
    ///    Examples:
    ///      `update_time = "2019-06-10T16:07:18-07:00"`
    ///      `update_time = 1560208038000`
    ///
    /// * create_time: `=`, `>`, `<`, `>=`, `<=`
    ///
    ///    Usage: This should be milliseconds since epoch or an RFC3339 string.
    ///    Examples:
    ///      `create_time = "2019-06-10T16:07:18-07:00"`
    ///      `create_time = 1560208038000`
    ///
    /// * iam_policy.policy_blob: `=`, `:`
    /// * resource_properties: `=`, `:`, `>`, `<`, `>=`, `<=`
    /// * security_marks.marks: `=`, `:`
    /// * security_center_properties.resource_name: `=`, `:`
    /// * security_center_properties.resource_display_name: `=`, `:`
    /// * security_center_properties.resource_type: `=`, `:`
    /// * security_center_properties.resource_parent: `=`, `:`
    /// * security_center_properties.resource_parent_display_name: `=`, `:`
    /// * security_center_properties.resource_project: `=`, `:`
    /// * security_center_properties.resource_project_display_name: `=`, `:`
    /// * security_center_properties.resource_owners: `=`, `:`
    ///
    /// For example, `resource_properties.size = 100` is a valid filter string.
    ///
    /// Use a partial match on the empty string to filter based on a property
    /// existing: `resource_properties.my_property : ""`
    ///
    /// Use a negated partial match on the empty string to filter based on a
    /// property not existing: `-resource_properties.my_property : ""`
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Required. Expression that defines what assets fields to use for grouping.
    /// The string value should follow SQL syntax: comma separated list of fields.
    /// For example:
    /// "security_center_properties.resource_project,security_center_properties.project".
    ///
    /// The following fields are supported when compare_duration is not set:
    ///
    /// * security_center_properties.resource_project
    /// * security_center_properties.resource_project_display_name
    /// * security_center_properties.resource_type
    /// * security_center_properties.resource_parent
    /// * security_center_properties.resource_parent_display_name
    ///
    /// The following fields are supported when compare_duration is set:
    ///
    /// * security_center_properties.resource_type
    /// * security_center_properties.resource_project_display_name
    /// * security_center_properties.resource_parent_display_name
    #[prost(string, tag = "3")]
    pub group_by: ::prost::alloc::string::String,
    /// When compare_duration is set, the GroupResult's "state_change" property is
    /// updated to indicate whether the asset was added, removed, or remained
    /// present during the compare_duration period of time that precedes the
    /// read_time. This is the time between (read_time - compare_duration) and
    /// read_time.
    ///
    /// The state change value is derived based on the presence of the asset at the
    /// two points in time. Intermediate state changes between the two times don't
    /// affect the result. For example, the results aren't affected if the asset is
    /// removed and re-created again.
    ///
    /// Possible "state_change" values when compare_duration is specified:
    ///
    /// * "ADDED":   indicates that the asset was not present at the start of
    ///                 compare_duration, but present at reference_time.
    /// * "REMOVED": indicates that the asset was present at the start of
    ///                 compare_duration, but not present at reference_time.
    /// * "ACTIVE":  indicates that the asset was present at both the
    ///                 start and the end of the time period defined by
    ///                 compare_duration and reference_time.
    ///
    /// If compare_duration is not specified, then the only possible state_change
    /// is "UNUSED", which will be the state_change set for all assets present at
    /// read_time.
    ///
    /// If this field is set then `state_change` must be a specified field in
    /// `group_by`.
    #[prost(message, optional, tag = "4")]
    pub compare_duration: ::core::option::Option<::prost_types::Duration>,
    /// Time used as a reference point when filtering assets. The filter is limited
    /// to assets existing at the supplied time and their values are those at that
    /// specific time. Absence of this field will default to the API's version of
    /// NOW.
    #[prost(message, optional, tag = "5")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The value returned by the last `GroupAssetsResponse`; indicates
    /// that this is a continuation of a prior `GroupAssets` call, and that the
    /// system should return the next page of data.
    #[prost(string, tag = "7")]
    pub page_token: ::prost::alloc::string::String,
    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    #[prost(int32, tag = "8")]
    pub page_size: i32,
}
/// Response message for grouping by assets.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupAssetsResponse {
    /// Group results. There exists an element for each existing unique
    /// combination of property/values. The element contains a count for the number
    /// of times those specific property/values appear.
    #[prost(message, repeated, tag = "1")]
    pub group_by_results: ::prost::alloc::vec::Vec<GroupResult>,
    /// Time used for executing the groupBy request.
    #[prost(message, optional, tag = "2")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
    /// The total number of results matching the query.
    #[prost(int32, tag = "4")]
    pub total_size: i32,
}
/// Request message for grouping by findings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupFindingsRequest {
    /// Required. Name of the source to groupBy. Its format is
    /// `organizations/\[organization_id\]/sources/\[source_id\]`,
    /// `folders/\[folder_id\]/sources/\[source_id\]`, or
    /// `projects/\[project_id\]/sources/\[source_id\]`. To groupBy across all sources
    /// provide a source_id of `-`. For example:
    /// `organizations/{organization_id}/sources/-, folders/{folder_id}/sources/-`,
    /// or `projects/{project_id}/sources/-`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Expression that defines the filter to apply across findings.
    /// The expression is a list of one or more restrictions combined via logical
    /// operators `AND` and `OR`.
    /// Parentheses are supported, and `OR` has higher precedence than `AND`.
    ///
    /// Restrictions have the form `<field> <operator> <value>` and may have a `-`
    /// character in front of them to indicate negation. Examples include:
    ///
    ///   * name
    ///   * source_properties.a_property
    ///   * security_marks.marks.marka
    ///
    /// The supported operators are:
    ///
    /// * `=` for all value types.
    /// * `>`, `<`, `>=`, `<=` for integer values.
    /// * `:`, meaning substring matching, for strings.
    ///
    /// The supported value types are:
    ///
    /// * string literals in quotes.
    /// * integer literals without quotes.
    /// * boolean literals `true` and `false` without quotes.
    ///
    /// The following field and operator combinations are supported:
    ///
    /// * name: `=`
    /// * parent: `=`, `:`
    /// * resource_name: `=`, `:`
    /// * state: `=`, `:`
    /// * category: `=`, `:`
    /// * external_uri: `=`, `:`
    /// * event_time: `=`, `>`, `<`, `>=`, `<=`
    ///
    ///    Usage: This should be milliseconds since epoch or an RFC3339 string.
    ///    Examples:
    ///      `event_time = "2019-06-10T16:07:18-07:00"`
    ///      `event_time = 1560208038000`
    ///
    /// * severity: `=`, `:`
    /// * workflow_state: `=`, `:`
    /// * security_marks.marks: `=`, `:`
    /// * source_properties: `=`, `:`, `>`, `<`, `>=`, `<=`
    ///
    ///    For example, `source_properties.size = 100` is a valid filter string.
    ///
    ///    Use a partial match on the empty string to filter based on a property
    ///    existing: `source_properties.my_property : ""`
    ///
    ///    Use a negated partial match on the empty string to filter based on a
    ///    property not existing: `-source_properties.my_property : ""`
    ///
    /// * resource:
    ///    * resource.name: `=`, `:`
    ///    * resource.parent_name: `=`, `:`
    ///    * resource.parent_display_name: `=`, `:`
    ///    * resource.project_name: `=`, `:`
    ///    * resource.project_display_name: `=`, `:`
    ///    * resource.type: `=`, `:`
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Required. Expression that defines what assets fields to use for grouping
    /// (including `state_change`). The string value should follow SQL syntax:
    /// comma separated list of fields. For example: "parent,resource_name".
    ///
    /// The following fields are supported when compare_duration is set:
    ///
    /// * state_change
    #[prost(string, tag = "3")]
    pub group_by: ::prost::alloc::string::String,
    /// Time used as a reference point when filtering findings. The filter is
    /// limited to findings existing at the supplied time and their values are
    /// those at that specific time. Absence of this field will default to the
    /// API's version of NOW.
    #[prost(message, optional, tag = "4")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
    /// When compare_duration is set, the GroupResult's "state_change" attribute is
    /// updated to indicate whether the finding had its state changed, the
    /// finding's state remained unchanged, or if the finding was added during the
    /// compare_duration period of time that precedes the read_time. This is the
    /// time between (read_time - compare_duration) and read_time.
    ///
    /// The state_change value is derived based on the presence and state of the
    /// finding at the two points in time. Intermediate state changes between the
    /// two times don't affect the result. For example, the results aren't affected
    /// if the finding is made inactive and then active again.
    ///
    /// Possible "state_change" values when compare_duration is specified:
    ///
    /// * "CHANGED":   indicates that the finding was present and matched the given
    ///                   filter at the start of compare_duration, but changed its
    ///                   state at read_time.
    /// * "UNCHANGED": indicates that the finding was present and matched the given
    ///                   filter at the start of compare_duration and did not change
    ///                   state at read_time.
    /// * "ADDED":     indicates that the finding did not match the given filter or
    ///                   was not present at the start of compare_duration, but was
    ///                   present at read_time.
    /// * "REMOVED":   indicates that the finding was present and matched the
    ///                   filter at the start of compare_duration, but did not match
    ///                   the filter at read_time.
    ///
    /// If compare_duration is not specified, then the only possible state_change
    /// is "UNUSED",  which will be the state_change set for all findings present
    /// at read_time.
    ///
    /// If this field is set then `state_change` must be a specified field in
    /// `group_by`.
    #[prost(message, optional, tag = "5")]
    pub compare_duration: ::core::option::Option<::prost_types::Duration>,
    /// The value returned by the last `GroupFindingsResponse`; indicates
    /// that this is a continuation of a prior `GroupFindings` call, and
    /// that the system should return the next page of data.
    #[prost(string, tag = "7")]
    pub page_token: ::prost::alloc::string::String,
    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    #[prost(int32, tag = "8")]
    pub page_size: i32,
}
/// Response message for group by findings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupFindingsResponse {
    /// Group results. There exists an element for each existing unique
    /// combination of property/values. The element contains a count for the number
    /// of times those specific property/values appear.
    #[prost(message, repeated, tag = "1")]
    pub group_by_results: ::prost::alloc::vec::Vec<GroupResult>,
    /// Time used for executing the groupBy request.
    #[prost(message, optional, tag = "2")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
    /// The total number of results matching the query.
    #[prost(int32, tag = "4")]
    pub total_size: i32,
}
/// Result containing the properties and count of a groupBy request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupResult {
    /// Properties matching the groupBy fields in the request.
    #[prost(map = "string, message", tag = "1")]
    pub properties: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost_types::Value,
    >,
    /// Total count of resources for the given properties.
    #[prost(int64, tag = "2")]
    pub count: i64,
}
/// Request message for listing descendant Security Health Analytics custom
/// modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDescendantSecurityHealthAnalyticsCustomModulesRequest {
    /// Required. Name of parent to list descendant custom modules. Its format is
    /// `organizations/{organization}/securityHealthAnalyticsSettings`,
    /// `folders/{folder}/securityHealthAnalyticsSettings`, or
    /// `projects/{project}/securityHealthAnalyticsSettings`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last call indicating a continuation
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for listing descendant Security Health Analytics custom
/// modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDescendantSecurityHealthAnalyticsCustomModulesResponse {
    /// Custom modules belonging to the requested parent and its descendants.
    #[prost(message, repeated, tag = "1")]
    pub security_health_analytics_custom_modules: ::prost::alloc::vec::Vec<
        SecurityHealthAnalyticsCustomModule,
    >,
    /// If not empty, indicates that there may be more custom modules to be
    /// returned.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for listing the valued resources for a given simulation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListValuedResourcesRequest {
    /// Required. Name of parent to list valued resources.
    ///
    /// Valid formats:
    /// `organizations/{organization}`,
    /// `organizations/{organization}/simulations/{simulation}`
    /// `organizations/{organization}/simulations/{simulation}/attackExposureResults/{attack_exposure_result_v2}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The filter expression that filters the valued resources in the response.
    /// Supported fields:
    ///
    ///    * `resource_value` supports =
    ///    * `resource_type` supports =
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// The value returned by the last `ListValuedResourcesResponse`; indicates
    /// that this is a continuation of a prior `ListValuedResources` call, and
    /// that the system should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    #[prost(int32, tag = "4")]
    pub page_size: i32,
    /// Optional. The fields by which to order the valued resources response.
    ///
    /// Supported fields:
    ///
    ///    * `exposed_score`
    ///
    ///    * `resource_value`
    ///
    ///    * `resource_type`
    ///
    ///    * `resource`
    ///
    ///    * `display_name`
    ///
    /// Values should be a comma separated list of fields. For example:
    /// `exposed_score,resource_value`.
    ///
    /// The default sorting order is descending. To specify ascending or descending
    /// order for a field, append a ` ASC` or a ` DESC` suffix, respectively; for
    /// example: `exposed_score DESC`.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response message for listing the valued resources for a given simulation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListValuedResourcesResponse {
    /// The valued resources that the attack path simulation identified.
    #[prost(message, repeated, tag = "1")]
    pub valued_resources: ::prost::alloc::vec::Vec<ValuedResource>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// The estimated total number of results matching the query.
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Request message for listing the attack paths for a given simulation or valued
/// resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAttackPathsRequest {
    /// Required. Name of parent to list attack paths.
    ///
    /// Valid formats:
    /// `organizations/{organization}`,
    /// `organizations/{organization}/simulations/{simulation}`
    /// `organizations/{organization}/simulations/{simulation}/attackExposureResults/{attack_exposure_result_v2}`
    /// `organizations/{organization}/simulations/{simulation}/valuedResources/{valued_resource}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The filter expression that filters the attack path in the response.
    /// Supported fields:
    ///
    ///    * `valued_resources` supports =
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// The value returned by the last `ListAttackPathsResponse`; indicates
    /// that this is a continuation of a prior `ListAttackPaths` call, and
    /// that the system should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    #[prost(int32, tag = "4")]
    pub page_size: i32,
}
/// Response message for listing the attack paths for a given simulation or
/// valued resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAttackPathsResponse {
    /// The attack paths that the attack path simulation identified.
    #[prost(message, repeated, tag = "1")]
    pub attack_paths: ::prost::alloc::vec::Vec<AttackPath>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for getting simulation.
/// Simulation name can include "latest" to retrieve the latest simulation
/// For example, "organizations/123/simulations/latest"
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSimulationRequest {
    /// Required. The organization name or simulation name of this simulation
    ///
    /// Valid format:
    /// `organizations/{organization}/simulations/latest`
    /// `organizations/{organization}/simulations/{simulation}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for getting a valued resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetValuedResourceRequest {
    /// Required. The name of this valued resource
    ///
    /// Valid format:
    /// `organizations/{organization}/simulations/{simulation}/valuedResources/{valued_resource}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for listing  mute configs at a given scope e.g. organization,
/// folder or project.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMuteConfigsRequest {
    /// Required. The parent, which owns the collection of mute configs. Its format
    /// is `organizations/\[organization_id\]`, `folders/\[folder_id\]`,
    /// `projects/\[project_id\]`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of configs to return. The service may return fewer than
    /// this value.
    /// If unspecified, at most 10 configs will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListMuteConfigs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListMuteConfigs` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for listing mute configs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMuteConfigsResponse {
    /// The mute configs from the specified parent.
    #[prost(message, repeated, tag = "1")]
    pub mute_configs: ::prost::alloc::vec::Vec<MuteConfig>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for listing notification configs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotificationConfigsRequest {
    /// Required. The name of the parent in which to list the notification
    /// configurations. Its format is "organizations/\[organization_id\]",
    /// "folders/\[folder_id\]", or "projects/\[project_id\]".
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The value returned by the last `ListNotificationConfigsResponse`; indicates
    /// that this is a continuation of a prior `ListNotificationConfigs` call, and
    /// that the system should return the next page of data.
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
/// Response message for listing notification configs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotificationConfigsResponse {
    /// Notification configs belonging to the requested parent.
    #[prost(message, repeated, tag = "1")]
    pub notification_configs: ::prost::alloc::vec::Vec<NotificationConfig>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for listing effective Security Health Analytics custom
/// modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEffectiveSecurityHealthAnalyticsCustomModulesRequest {
    /// Required. Name of parent to list effective custom modules. Its format is
    /// `organizations/{organization}/securityHealthAnalyticsSettings`,
    /// `folders/{folder}/securityHealthAnalyticsSettings`, or
    /// `projects/{project}/securityHealthAnalyticsSettings`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last call indicating a continuation
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for listing effective Security Health Analytics custom
/// modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEffectiveSecurityHealthAnalyticsCustomModulesResponse {
    /// Effective custom modules belonging to the requested parent.
    #[prost(message, repeated, tag = "1")]
    pub effective_security_health_analytics_custom_modules: ::prost::alloc::vec::Vec<
        EffectiveSecurityHealthAnalyticsCustomModule,
    >,
    /// If not empty, indicates that there may be more effective custom modules to
    /// be returned.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for listing Security Health Analytics custom modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSecurityHealthAnalyticsCustomModulesRequest {
    /// Required. Name of parent to list custom modules. Its format is
    /// `organizations/{organization}/securityHealthAnalyticsSettings`,
    /// `folders/{folder}/securityHealthAnalyticsSettings`, or
    /// `projects/{project}/securityHealthAnalyticsSettings`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last call indicating a continuation
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for listing Security Health Analytics custom modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSecurityHealthAnalyticsCustomModulesResponse {
    /// Custom modules belonging to the requested parent.
    #[prost(message, repeated, tag = "1")]
    pub security_health_analytics_custom_modules: ::prost::alloc::vec::Vec<
        SecurityHealthAnalyticsCustomModule,
    >,
    /// If not empty, indicates that there may be more custom modules to be
    /// returned.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for listing sources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSourcesRequest {
    /// Required. Resource name of the parent of sources to list. Its format should
    /// be `organizations/\[organization_id\]`, `folders/\[folder_id\]`, or
    /// `projects/\[project_id\]`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The value returned by the last `ListSourcesResponse`; indicates
    /// that this is a continuation of a prior `ListSources` call, and
    /// that the system should return the next page of data.
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    #[prost(int32, tag = "7")]
    pub page_size: i32,
}
/// Response message for listing sources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSourcesResponse {
    /// Sources belonging to the requested parent.
    #[prost(message, repeated, tag = "1")]
    pub sources: ::prost::alloc::vec::Vec<Source>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for listing assets.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetsRequest {
    /// Required. The name of the parent resource that contains the assets. The
    /// value that you can specify on parent depends on the method in which you
    /// specify parent. You can specify one of the following values:
    /// `organizations/\[organization_id\]`, `folders/\[folder_id\]`, or
    /// `projects/\[project_id\]`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Expression that defines the filter to apply across assets.
    /// The expression is a list of zero or more restrictions combined via logical
    /// operators `AND` and `OR`.
    /// Parentheses are supported, and `OR` has higher precedence than `AND`.
    ///
    /// Restrictions have the form `<field> <operator> <value>` and may have a `-`
    /// character in front of them to indicate negation. The fields map to those
    /// defined in the Asset resource. Examples include:
    ///
    /// * name
    /// * security_center_properties.resource_name
    /// * resource_properties.a_property
    /// * security_marks.marks.marka
    ///
    /// The supported operators are:
    ///
    /// * `=` for all value types.
    /// * `>`, `<`, `>=`, `<=` for integer values.
    /// * `:`, meaning substring matching, for strings.
    ///
    /// The supported value types are:
    ///
    /// * string literals in quotes.
    /// * integer literals without quotes.
    /// * boolean literals `true` and `false` without quotes.
    ///
    /// The following are the allowed field and operator combinations:
    ///
    /// * name: `=`
    /// * update_time: `=`, `>`, `<`, `>=`, `<=`
    ///
    ///    Usage: This should be milliseconds since epoch or an RFC3339 string.
    ///    Examples:
    ///      `update_time = "2019-06-10T16:07:18-07:00"`
    ///      `update_time = 1560208038000`
    ///
    /// * create_time: `=`, `>`, `<`, `>=`, `<=`
    ///
    ///    Usage: This should be milliseconds since epoch or an RFC3339 string.
    ///    Examples:
    ///      `create_time = "2019-06-10T16:07:18-07:00"`
    ///      `create_time = 1560208038000`
    ///
    /// * iam_policy.policy_blob: `=`, `:`
    /// * resource_properties: `=`, `:`, `>`, `<`, `>=`, `<=`
    /// * security_marks.marks: `=`, `:`
    /// * security_center_properties.resource_name: `=`, `:`
    /// * security_center_properties.resource_display_name: `=`, `:`
    /// * security_center_properties.resource_type: `=`, `:`
    /// * security_center_properties.resource_parent: `=`, `:`
    /// * security_center_properties.resource_parent_display_name: `=`, `:`
    /// * security_center_properties.resource_project: `=`, `:`
    /// * security_center_properties.resource_project_display_name: `=`, `:`
    /// * security_center_properties.resource_owners: `=`, `:`
    ///
    /// For example, `resource_properties.size = 100` is a valid filter string.
    ///
    /// Use a partial match on the empty string to filter based on a property
    /// existing: `resource_properties.my_property : ""`
    ///
    /// Use a negated partial match on the empty string to filter based on a
    /// property not existing: `-resource_properties.my_property : ""`
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Expression that defines what fields and order to use for sorting. The
    /// string value should follow SQL syntax: comma separated list of fields. For
    /// example: "name,resource_properties.a_property". The default sorting order
    /// is ascending. To specify descending order for a field, a suffix " desc"
    /// should be appended to the field name. For example: "name
    /// desc,resource_properties.a_property". Redundant space characters in the
    /// syntax are insignificant. "name desc,resource_properties.a_property" and "
    /// name     desc  ,   resource_properties.a_property  " are equivalent.
    ///
    /// The following fields are supported:
    /// name
    /// update_time
    /// resource_properties
    /// security_marks.marks
    /// security_center_properties.resource_name
    /// security_center_properties.resource_display_name
    /// security_center_properties.resource_parent
    /// security_center_properties.resource_parent_display_name
    /// security_center_properties.resource_project
    /// security_center_properties.resource_project_display_name
    /// security_center_properties.resource_type
    #[prost(string, tag = "3")]
    pub order_by: ::prost::alloc::string::String,
    /// Time used as a reference point when filtering assets. The filter is limited
    /// to assets existing at the supplied time and their values are those at that
    /// specific time. Absence of this field will default to the API's version of
    /// NOW.
    #[prost(message, optional, tag = "4")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
    /// When compare_duration is set, the ListAssetsResult's "state_change"
    /// attribute is updated to indicate whether the asset was added, removed, or
    /// remained present during the compare_duration period of time that precedes
    /// the read_time. This is the time between (read_time - compare_duration) and
    /// read_time.
    ///
    /// The state_change value is derived based on the presence of the asset at the
    /// two points in time. Intermediate state changes between the two times don't
    /// affect the result. For example, the results aren't affected if the asset is
    /// removed and re-created again.
    ///
    /// Possible "state_change" values when compare_duration is specified:
    ///
    /// * "ADDED":   indicates that the asset was not present at the start of
    ///                 compare_duration, but present at read_time.
    /// * "REMOVED": indicates that the asset was present at the start of
    ///                 compare_duration, but not present at read_time.
    /// * "ACTIVE":  indicates that the asset was present at both the
    ///                 start and the end of the time period defined by
    ///                 compare_duration and read_time.
    ///
    /// If compare_duration is not specified, then the only possible state_change
    /// is "UNUSED",  which will be the state_change set for all assets present at
    /// read_time.
    #[prost(message, optional, tag = "5")]
    pub compare_duration: ::core::option::Option<::prost_types::Duration>,
    /// A field mask to specify the ListAssetsResult fields to be listed in the
    /// response.
    /// An empty field mask will list all fields.
    #[prost(message, optional, tag = "7")]
    pub field_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The value returned by the last `ListAssetsResponse`; indicates
    /// that this is a continuation of a prior `ListAssets` call, and
    /// that the system should return the next page of data.
    #[prost(string, tag = "8")]
    pub page_token: ::prost::alloc::string::String,
    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    #[prost(int32, tag = "9")]
    pub page_size: i32,
}
/// Response message for listing assets.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetsResponse {
    /// Assets matching the list request.
    #[prost(message, repeated, tag = "1")]
    pub list_assets_results: ::prost::alloc::vec::Vec<
        list_assets_response::ListAssetsResult,
    >,
    /// Time used for executing the list request.
    #[prost(message, optional, tag = "2")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
    /// The total number of assets matching the query.
    #[prost(int32, tag = "4")]
    pub total_size: i32,
}
/// Nested message and enum types in `ListAssetsResponse`.
pub mod list_assets_response {
    /// Result containing the Asset and its State.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListAssetsResult {
        /// Asset matching the search request.
        #[prost(message, optional, tag = "1")]
        pub asset: ::core::option::Option<super::Asset>,
        /// State change of the asset between the points in time.
        #[prost(enumeration = "list_assets_result::StateChange", tag = "2")]
        pub state_change: i32,
    }
    /// Nested message and enum types in `ListAssetsResult`.
    pub mod list_assets_result {
        /// The change in state of the asset.
        ///
        /// When querying across two points in time this describes
        /// the change between the two points: ADDED, REMOVED, or ACTIVE.
        /// If there was no compare_duration supplied in the request the state change
        /// will be: UNUSED
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum StateChange {
            /// State change is unused, this is the canonical default for this enum.
            Unused = 0,
            /// Asset was added between the points in time.
            Added = 1,
            /// Asset was removed between the points in time.
            Removed = 2,
            /// Asset was present at both point(s) in time.
            Active = 3,
        }
        impl StateChange {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unused => "UNUSED",
                    Self::Added => "ADDED",
                    Self::Removed => "REMOVED",
                    Self::Active => "ACTIVE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNUSED" => Some(Self::Unused),
                    "ADDED" => Some(Self::Added),
                    "REMOVED" => Some(Self::Removed),
                    "ACTIVE" => Some(Self::Active),
                    _ => None,
                }
            }
        }
    }
}
/// Request message for listing findings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFindingsRequest {
    /// Required. Name of the source the findings belong to. Its format is
    /// `organizations/\[organization_id\]/sources/\[source_id\]`,
    /// `folders/\[folder_id\]/sources/\[source_id\]`, or
    /// `projects/\[project_id\]/sources/\[source_id\]`. To list across all sources
    /// provide a source_id of `-`. For example:
    /// `organizations/{organization_id}/sources/-`,
    /// `folders/{folder_id}/sources/-` or `projects/{projects_id}/sources/-`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Expression that defines the filter to apply across findings.
    /// The expression is a list of one or more restrictions combined via logical
    /// operators `AND` and `OR`.
    /// Parentheses are supported, and `OR` has higher precedence than `AND`.
    ///
    /// Restrictions have the form `<field> <operator> <value>` and may have a `-`
    /// character in front of them to indicate negation. Examples include:
    ///
    ///   * name
    ///   * source_properties.a_property
    ///   * security_marks.marks.marka
    ///
    /// The supported operators are:
    ///
    /// * `=` for all value types.
    /// * `>`, `<`, `>=`, `<=` for integer values.
    /// * `:`, meaning substring matching, for strings.
    ///
    /// The supported value types are:
    ///
    /// * string literals in quotes.
    /// * integer literals without quotes.
    /// * boolean literals `true` and `false` without quotes.
    ///
    /// The following field and operator combinations are supported:
    ///
    /// * name: `=`
    /// * parent: `=`, `:`
    /// * resource_name: `=`, `:`
    /// * state: `=`, `:`
    /// * category: `=`, `:`
    /// * external_uri: `=`, `:`
    /// * event_time: `=`, `>`, `<`, `>=`, `<=`
    ///
    ///    Usage: This should be milliseconds since epoch or an RFC3339 string.
    ///    Examples:
    ///      `event_time = "2019-06-10T16:07:18-07:00"`
    ///      `event_time = 1560208038000`
    ///
    /// * severity: `=`, `:`
    /// * workflow_state: `=`, `:`
    /// * security_marks.marks: `=`, `:`
    /// * source_properties: `=`, `:`, `>`, `<`, `>=`, `<=`
    ///
    ///    For example, `source_properties.size = 100` is a valid filter string.
    ///
    ///    Use a partial match on the empty string to filter based on a property
    ///    existing: `source_properties.my_property : ""`
    ///
    ///    Use a negated partial match on the empty string to filter based on a
    ///    property not existing: `-source_properties.my_property : ""`
    ///
    /// * resource:
    ///    * resource.name: `=`, `:`
    ///    * resource.parent_name: `=`, `:`
    ///    * resource.parent_display_name: `=`, `:`
    ///    * resource.project_name: `=`, `:`
    ///    * resource.project_display_name: `=`, `:`
    ///    * resource.type: `=`, `:`
    ///    * resource.folders.resource_folder: `=`, `:`
    ///    * resource.display_name: `=`, `:`
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Expression that defines what fields and order to use for sorting. The
    /// string value should follow SQL syntax: comma separated list of fields. For
    /// example: "name,resource_properties.a_property". The default sorting order
    /// is ascending. To specify descending order for a field, a suffix " desc"
    /// should be appended to the field name. For example: "name
    /// desc,source_properties.a_property". Redundant space characters in the
    /// syntax are insignificant. "name desc,source_properties.a_property" and "
    /// name     desc  ,   source_properties.a_property  " are equivalent.
    ///
    /// The following fields are supported:
    /// name
    /// parent
    /// state
    /// category
    /// resource_name
    /// event_time
    /// source_properties
    /// security_marks.marks
    #[prost(string, tag = "3")]
    pub order_by: ::prost::alloc::string::String,
    /// Time used as a reference point when filtering findings. The filter is
    /// limited to findings existing at the supplied time and their values are
    /// those at that specific time. Absence of this field will default to the
    /// API's version of NOW.
    #[prost(message, optional, tag = "4")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
    /// When compare_duration is set, the ListFindingsResult's "state_change"
    /// attribute is updated to indicate whether the finding had its state changed,
    /// the finding's state remained unchanged, or if the finding was added in any
    /// state during the compare_duration period of time that precedes the
    /// read_time. This is the time between (read_time - compare_duration) and
    /// read_time.
    ///
    /// The state_change value is derived based on the presence and state of the
    /// finding at the two points in time. Intermediate state changes between the
    /// two times don't affect the result. For example, the results aren't affected
    /// if the finding is made inactive and then active again.
    ///
    /// Possible "state_change" values when compare_duration is specified:
    ///
    /// * "CHANGED":   indicates that the finding was present and matched the given
    ///                   filter at the start of compare_duration, but changed its
    ///                   state at read_time.
    /// * "UNCHANGED": indicates that the finding was present and matched the given
    ///                   filter at the start of compare_duration and did not change
    ///                   state at read_time.
    /// * "ADDED":     indicates that the finding did not match the given filter or
    ///                   was not present at the start of compare_duration, but was
    ///                   present at read_time.
    /// * "REMOVED":   indicates that the finding was present and matched the
    ///                   filter at the start of compare_duration, but did not match
    ///                   the filter at read_time.
    ///
    /// If compare_duration is not specified, then the only possible state_change
    /// is "UNUSED", which will be the state_change set for all findings present at
    /// read_time.
    #[prost(message, optional, tag = "5")]
    pub compare_duration: ::core::option::Option<::prost_types::Duration>,
    /// A field mask to specify the Finding fields to be listed in the response.
    /// An empty field mask will list all fields.
    #[prost(message, optional, tag = "7")]
    pub field_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The value returned by the last `ListFindingsResponse`; indicates
    /// that this is a continuation of a prior `ListFindings` call, and
    /// that the system should return the next page of data.
    #[prost(string, tag = "8")]
    pub page_token: ::prost::alloc::string::String,
    /// The maximum number of results to return in a single response. Default is
    /// 10, minimum is 1, maximum is 1000.
    #[prost(int32, tag = "9")]
    pub page_size: i32,
}
/// Response message for listing findings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFindingsResponse {
    /// Findings matching the list request.
    #[prost(message, repeated, tag = "1")]
    pub list_findings_results: ::prost::alloc::vec::Vec<
        list_findings_response::ListFindingsResult,
    >,
    /// Time used for executing the list request.
    #[prost(message, optional, tag = "2")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
    /// The total number of findings matching the query.
    #[prost(int32, tag = "4")]
    pub total_size: i32,
}
/// Nested message and enum types in `ListFindingsResponse`.
pub mod list_findings_response {
    /// Result containing the Finding and its StateChange.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListFindingsResult {
        /// Finding matching the search request.
        #[prost(message, optional, tag = "1")]
        pub finding: ::core::option::Option<super::Finding>,
        /// State change of the finding between the points in time.
        #[prost(enumeration = "list_findings_result::StateChange", tag = "2")]
        pub state_change: i32,
        /// Output only. Resource that is associated with this finding.
        #[prost(message, optional, tag = "3")]
        pub resource: ::core::option::Option<list_findings_result::Resource>,
    }
    /// Nested message and enum types in `ListFindingsResult`.
    pub mod list_findings_result {
        /// Information related to the Google Cloud resource that is
        /// associated with this finding.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Resource {
            /// The full resource name of the resource. See:
            /// <https://cloud.google.com/apis/design/resource_names#full_resource_name>
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            /// The human readable name of the resource.
            #[prost(string, tag = "8")]
            pub display_name: ::prost::alloc::string::String,
            /// The full resource type of the resource.
            #[prost(string, tag = "6")]
            pub r#type: ::prost::alloc::string::String,
            /// The full resource name of project that the resource belongs to.
            #[prost(string, tag = "2")]
            pub project_name: ::prost::alloc::string::String,
            /// The project ID that the resource belongs to.
            #[prost(string, tag = "3")]
            pub project_display_name: ::prost::alloc::string::String,
            /// The full resource name of resource's parent.
            #[prost(string, tag = "4")]
            pub parent_name: ::prost::alloc::string::String,
            /// The human readable name of resource's parent.
            #[prost(string, tag = "5")]
            pub parent_display_name: ::prost::alloc::string::String,
            /// Contains a Folder message for each folder in the assets ancestry.
            /// The first folder is the deepest nested folder, and the last folder is
            /// the folder directly under the Organization.
            #[prost(message, repeated, tag = "7")]
            pub folders: ::prost::alloc::vec::Vec<super::super::Folder>,
            /// Indicates which cloud provider the finding is from.
            #[prost(enumeration = "super::super::CloudProvider", tag = "9")]
            pub cloud_provider: i32,
            /// Indicates which organization / tenant the finding is for.
            #[prost(string, tag = "10")]
            pub organization: ::prost::alloc::string::String,
            /// The service or resource provider associated with the resource.
            #[prost(string, tag = "11")]
            pub service: ::prost::alloc::string::String,
            /// The region or location of the service (if applicable).
            #[prost(string, tag = "12")]
            pub location: ::prost::alloc::string::String,
            /// Provides the path to the resource within the resource hierarchy.
            #[prost(message, optional, tag = "18")]
            pub resource_path: ::core::option::Option<super::super::ResourcePath>,
            /// A string representation of the resource path.
            /// For Google Cloud, it has the format of
            /// `org/{organization_id}/folder/{folder_id}/folder/{folder_id}/project/{project_id}`
            /// where there can be any number of folders.
            /// For AWS, it has the format of
            /// `org/{organization_id}/ou/{organizational_unit_id}/ou/{organizational_unit_id}/account/{account_id}`
            /// where there can be any number of organizational units.
            /// For Azure, it has the format of
            /// `mg/{management_group_id}/mg/{management_group_id}/subscription/{subscription_id}/rg/{resource_group_name}`
            /// where there can be any number of management groups.
            #[prost(string, tag = "19")]
            pub resource_path_string: ::prost::alloc::string::String,
            #[prost(oneof = "resource::CloudProviderMetadata", tags = "16, 17")]
            pub cloud_provider_metadata: ::core::option::Option<
                resource::CloudProviderMetadata,
            >,
        }
        /// Nested message and enum types in `Resource`.
        pub mod resource {
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum CloudProviderMetadata {
                /// The AWS metadata associated with the finding.
                #[prost(message, tag = "16")]
                AwsMetadata(super::super::super::AwsMetadata),
                /// The Azure metadata associated with the finding.
                #[prost(message, tag = "17")]
                AzureMetadata(super::super::super::AzureMetadata),
            }
        }
        /// The change in state of the finding.
        ///
        /// When querying across two points in time this describes
        /// the change in the finding between the two points: CHANGED, UNCHANGED,
        /// ADDED, or REMOVED. Findings can not be deleted, so REMOVED implies that
        /// the finding at timestamp does not match the filter specified, but it did
        /// at timestamp - compare_duration. If there was no compare_duration
        /// supplied in the request the state change will be: UNUSED
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum StateChange {
            /// State change is unused, this is the canonical default for this enum.
            Unused = 0,
            /// The finding has changed state in some way between the points in time
            /// and existed at both points.
            Changed = 1,
            /// The finding has not changed state between the points in time and
            /// existed at both points.
            Unchanged = 2,
            /// The finding was created between the points in time.
            Added = 3,
            /// The finding at timestamp does not match the filter specified, but it
            /// did at timestamp - compare_duration.
            Removed = 4,
        }
        impl StateChange {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unused => "UNUSED",
                    Self::Changed => "CHANGED",
                    Self::Unchanged => "UNCHANGED",
                    Self::Added => "ADDED",
                    Self::Removed => "REMOVED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNUSED" => Some(Self::Unused),
                    "CHANGED" => Some(Self::Changed),
                    "UNCHANGED" => Some(Self::Unchanged),
                    "ADDED" => Some(Self::Added),
                    "REMOVED" => Some(Self::Removed),
                    _ => None,
                }
            }
        }
    }
}
/// Request message for updating a finding's state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetFindingStateRequest {
    /// Required. The [relative resource
    /// name](<https://cloud.google.com/apis/design/resource_names#relative_resource_name>)
    /// of the finding. Example:
    /// `organizations/{organization_id}/sources/{source_id}/findings/{finding_id}`,
    /// `folders/{folder_id}/sources/{source_id}/findings/{finding_id}`,
    /// `projects/{project_id}/sources/{source_id}/findings/{finding_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The desired State of the finding.
    #[prost(enumeration = "finding::State", tag = "2")]
    pub state: i32,
    /// Required. The time at which the updated state takes effect.
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request message for updating a finding's mute status.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetMuteRequest {
    /// Required. The [relative resource
    /// name](<https://cloud.google.com/apis/design/resource_names#relative_resource_name>)
    /// of the finding. Example:
    /// `organizations/{organization_id}/sources/{source_id}/findings/{finding_id}`,
    /// `folders/{folder_id}/sources/{source_id}/findings/{finding_id}`,
    /// `projects/{project_id}/sources/{source_id}/findings/{finding_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The desired state of the Mute.
    #[prost(enumeration = "finding::Mute", tag = "2")]
    pub mute: i32,
}
/// Request message for running asset discovery for an organization.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunAssetDiscoveryRequest {
    /// Required. Name of the organization to run asset discovery for. Its format
    /// is `organizations/\[organization_id\]`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// Request message to simulate a CustomConfig against a given test resource.
/// Maximum size of the request is 4 MB by default.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateSecurityHealthAnalyticsCustomModuleRequest {
    /// Required. The relative resource name of the organization, project, or
    /// folder. For more information about relative resource names, see [Relative
    /// Resource
    /// Name](<https://cloud.google.com/apis/design/resource_names#relative_resource_name>)
    /// Example: `organizations/{organization_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The custom configuration that you need to test.
    #[prost(message, optional, tag = "2")]
    pub custom_config: ::core::option::Option<CustomConfig>,
    /// Required. Resource data to simulate custom module against.
    #[prost(message, optional, tag = "3")]
    pub resource: ::core::option::Option<
        simulate_security_health_analytics_custom_module_request::SimulatedResource,
    >,
}
/// Nested message and enum types in `SimulateSecurityHealthAnalyticsCustomModuleRequest`.
pub mod simulate_security_health_analytics_custom_module_request {
    /// Manually constructed resource name. If the custom module evaluates against
    /// only the resource data, you can omit the `iam_policy_data` field. If it
    /// evaluates only the `iam_policy_data` field, you can omit the resource data.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SimulatedResource {
        /// Required. The type of the resource, for example,
        /// `compute.googleapis.com/Disk`.
        #[prost(string, tag = "1")]
        pub resource_type: ::prost::alloc::string::String,
        /// Optional. A representation of the Google Cloud resource. Should match the
        /// Google Cloud resource JSON format.
        #[prost(message, optional, tag = "2")]
        pub resource_data: ::core::option::Option<::prost_types::Struct>,
        /// Optional. A representation of the IAM policy.
        #[prost(message, optional, tag = "3")]
        pub iam_policy_data: ::core::option::Option<
            super::super::super::super::iam::v1::Policy,
        >,
    }
}
/// Response message for simulating a `SecurityHealthAnalyticsCustomModule`
/// against a given resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateSecurityHealthAnalyticsCustomModuleResponse {
    /// Result for test case in the corresponding request.
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<
        simulate_security_health_analytics_custom_module_response::SimulatedResult,
    >,
}
/// Nested message and enum types in `SimulateSecurityHealthAnalyticsCustomModuleResponse`.
pub mod simulate_security_health_analytics_custom_module_response {
    /// Possible test result.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SimulatedResult {
        #[prost(oneof = "simulated_result::Result", tags = "1, 2, 3")]
        pub result: ::core::option::Option<simulated_result::Result>,
    }
    /// Nested message and enum types in `SimulatedResult`.
    pub mod simulated_result {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Result {
            /// Finding that would be published for the test case,
            /// if a violation is detected.
            #[prost(message, tag = "1")]
            Finding(super::super::Finding),
            /// Indicates that the test case does not trigger any violation.
            #[prost(message, tag = "2")]
            NoViolation(()),
            /// Error encountered during the test.
            #[prost(message, tag = "3")]
            Error(super::super::super::super::super::rpc::Status),
        }
    }
}
/// Request message for updating a ExternalSystem resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateExternalSystemRequest {
    /// Required. The external system resource to update.
    #[prost(message, optional, tag = "1")]
    pub external_system: ::core::option::Option<ExternalSystem>,
    /// The FieldMask to use when updating the external system resource.
    ///
    /// If empty all mutable fields will be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for updating or creating a finding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFindingRequest {
    /// Required. The finding resource to update or create if it does not already
    /// exist. parent, security_marks, and update_time will be ignored.
    ///
    /// In the case of creation, the finding id portion of the name must be
    /// alphanumeric and less than or equal to 32 characters and greater than 0
    /// characters in length.
    #[prost(message, optional, tag = "1")]
    pub finding: ::core::option::Option<Finding>,
    /// The FieldMask to use when updating the finding resource. This field should
    /// not be specified when creating a finding.
    ///
    /// When updating a finding, an empty mask is treated as updating all mutable
    /// fields and replacing source_properties.  Individual source_properties can
    /// be added/updated by using "source_properties.<property key>" in the field
    /// mask.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for updating a mute config.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateMuteConfigRequest {
    /// Required. The mute config being updated.
    #[prost(message, optional, tag = "1")]
    pub mute_config: ::core::option::Option<MuteConfig>,
    /// The list of fields to be updated.
    /// If empty all mutable fields will be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for updating a notification config.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNotificationConfigRequest {
    /// Required. The notification config to update.
    #[prost(message, optional, tag = "1")]
    pub notification_config: ::core::option::Option<NotificationConfig>,
    /// The FieldMask to use when updating the notification config.
    ///
    /// If empty all mutable fields will be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for updating an organization's settings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateOrganizationSettingsRequest {
    /// Required. The organization settings resource to update.
    #[prost(message, optional, tag = "1")]
    pub organization_settings: ::core::option::Option<OrganizationSettings>,
    /// The FieldMask to use when updating the settings resource.
    ///
    /// If empty all mutable fields will be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for updating Security Health Analytics custom modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSecurityHealthAnalyticsCustomModuleRequest {
    /// Required. The SecurityHealthAnalytics custom module to update.
    #[prost(message, optional, tag = "1")]
    pub security_health_analytics_custom_module: ::core::option::Option<
        SecurityHealthAnalyticsCustomModule,
    >,
    /// The list of fields to be updated. The only fields that can be updated are
    /// `enablement_state` and `custom_config`. If empty or set to the wildcard
    /// value `*`, both `enablement_state` and `custom_config` are updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for updating a source.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSourceRequest {
    /// Required. The source resource to update.
    #[prost(message, optional, tag = "1")]
    pub source: ::core::option::Option<Source>,
    /// The FieldMask to use when updating the source resource.
    ///
    /// If empty all mutable fields will be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for updating a SecurityMarks resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSecurityMarksRequest {
    /// Required. The security marks resource to update.
    #[prost(message, optional, tag = "1")]
    pub security_marks: ::core::option::Option<SecurityMarks>,
    /// The FieldMask to use when updating the security marks resource.
    ///
    /// The field mask must not contain duplicate fields.
    /// If empty or set to "marks", all marks will be replaced.  Individual
    /// marks can be updated using "marks.<mark_key>".
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The time at which the updated SecurityMarks take effect.
    /// If not set uses current server time.  Updates will be applied to the
    /// SecurityMarks that are active immediately preceding this time. Must be
    /// earlier or equal to the server time.
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request message for creating a BigQuery export.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBigQueryExportRequest {
    /// Required. The name of the parent resource of the new BigQuery export. Its
    /// format is `organizations/\[organization_id\]`, `folders/\[folder_id\]`, or
    /// `projects/\[project_id\]`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The BigQuery export being created.
    #[prost(message, optional, tag = "2")]
    pub big_query_export: ::core::option::Option<BigQueryExport>,
    /// Required. Unique identifier provided by the client within the parent scope.
    /// It must consist of only lowercase letters, numbers, and hyphens, must start
    /// with a letter, must end with either a letter or a number, and must be 63
    /// characters or less.
    #[prost(string, tag = "3")]
    pub big_query_export_id: ::prost::alloc::string::String,
}
/// Request message for updating a BigQuery export.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBigQueryExportRequest {
    /// Required. The BigQuery export being updated.
    #[prost(message, optional, tag = "1")]
    pub big_query_export: ::core::option::Option<BigQueryExport>,
    /// The list of fields to be updated.
    /// If empty all mutable fields will be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for listing BigQuery exports at a given scope e.g.
/// organization, folder or project.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBigQueryExportsRequest {
    /// Required. The parent, which owns the collection of BigQuery exports. Its
    /// format is `organizations/\[organization_id\]`, `folders/\[folder_id\]`,
    /// `projects/\[project_id\]`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of configs to return. The service may return fewer than
    /// this value.
    /// If unspecified, at most 10 configs will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListBigQueryExports` call.
    /// Provide this to retrieve the subsequent page.
    /// When paginating, all other parameters provided to `ListBigQueryExports`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for listing BigQuery exports.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBigQueryExportsResponse {
    /// The BigQuery exports from the specified parent.
    #[prost(message, repeated, tag = "1")]
    pub big_query_exports: ::prost::alloc::vec::Vec<BigQueryExport>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for deleting a BigQuery export.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBigQueryExportRequest {
    /// Required. The name of the BigQuery export to delete. Its format is
    /// `organizations/{organization}/bigQueryExports/{export_id}`,
    /// `folders/{folder}/bigQueryExports/{export_id}`, or
    /// `projects/{project}/bigQueryExports/{export_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request to create an Event Threat Detection custom module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEventThreatDetectionCustomModuleRequest {
    /// Required. The new custom module's parent.
    ///
    /// Its format is:
    ///
    ///    * `organizations/{organization}/eventThreatDetectionSettings`.
    ///    * `folders/{folder}/eventThreatDetectionSettings`.
    ///    * `projects/{project}/eventThreatDetectionSettings`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The module to create. The
    /// event_threat_detection_custom_module.name will be ignored and server
    /// generated.
    #[prost(message, optional, tag = "2")]
    pub event_threat_detection_custom_module: ::core::option::Option<
        EventThreatDetectionCustomModule,
    >,
}
/// Request to validate an Event Threat Detection custom module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateEventThreatDetectionCustomModuleRequest {
    /// Required. Resource name of the parent to validate the Custom Module under.
    ///
    /// Its format is:
    ///
    ///    * `organizations/{organization}/eventThreatDetectionSettings`.
    ///    * `folders/{folder}/eventThreatDetectionSettings`.
    ///    * `projects/{project}/eventThreatDetectionSettings`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The raw text of the module's contents. Used to generate error
    /// messages.
    #[prost(string, tag = "2")]
    pub raw_text: ::prost::alloc::string::String,
    /// Required. The type of the module (e.g. CONFIGURABLE_BAD_IP).
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
}
/// Response to validating an Event Threat Detection custom module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateEventThreatDetectionCustomModuleResponse {
    /// A list of errors returned by the validator. If the list is empty, there
    /// were no errors.
    #[prost(message, optional, tag = "2")]
    pub errors: ::core::option::Option<CustomModuleValidationErrors>,
}
/// Request to delete an Event Threat Detection custom module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEventThreatDetectionCustomModuleRequest {
    /// Required. Name of the custom module to delete.
    ///
    /// Its format is:
    ///
    /// * `organizations/{organization}/eventThreatDetectionSettings/customModules/{module}`.
    /// * `folders/{folder}/eventThreatDetectionSettings/customModules/{module}`.
    /// * `projects/{project}/eventThreatDetectionSettings/customModules/{module}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request to get an Event Threat Detection custom module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventThreatDetectionCustomModuleRequest {
    /// Required. Name of the custom module to get.
    ///
    /// Its format is:
    ///
    /// * `organizations/{organization}/eventThreatDetectionSettings/customModules/{module}`.
    /// * `folders/{folder}/eventThreatDetectionSettings/customModules/{module}`.
    /// * `projects/{project}/eventThreatDetectionSettings/customModules/{module}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request to list current and descendant resident Event Threat Detection custom
/// modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDescendantEventThreatDetectionCustomModulesRequest {
    /// Required. Name of the parent to list custom modules under.
    ///
    /// Its format is:
    ///
    ///    * `organizations/{organization}/eventThreatDetectionSettings`.
    ///    * `folders/{folder}/eventThreatDetectionSettings`.
    ///    * `projects/{project}/eventThreatDetectionSettings`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// A page token, received from a previous
    /// `ListDescendantEventThreatDetectionCustomModules` call. Provide this to
    /// retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListDescendantEventThreatDetectionCustomModules` must match the call that
    /// provided the page token.
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    /// The maximum number of modules to return. The service may return fewer than
    /// this value.
    /// If unspecified, at most 10 configs will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
/// Response for listing current and descendant resident
/// Event Threat Detection custom modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDescendantEventThreatDetectionCustomModulesResponse {
    /// Custom modules belonging to the requested parent.
    #[prost(message, repeated, tag = "1")]
    pub event_threat_detection_custom_modules: ::prost::alloc::vec::Vec<
        EventThreatDetectionCustomModule,
    >,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request to list Event Threat Detection custom modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEventThreatDetectionCustomModulesRequest {
    /// Required. Name of the parent to list custom modules under.
    ///
    /// Its format is:
    ///
    ///    * `organizations/{organization}/eventThreatDetectionSettings`.
    ///    * `folders/{folder}/eventThreatDetectionSettings`.
    ///    * `projects/{project}/eventThreatDetectionSettings`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// A page token, received from a previous
    /// `ListEventThreatDetectionCustomModules` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListEventThreatDetectionCustomModules` must match the call that provided
    /// the page token.
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    /// The maximum number of modules to return. The service may return fewer than
    /// this value.
    /// If unspecified, at most 10 configs will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
/// Response for listing Event Threat Detection custom modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEventThreatDetectionCustomModulesResponse {
    /// Custom modules belonging to the requested parent.
    #[prost(message, repeated, tag = "1")]
    pub event_threat_detection_custom_modules: ::prost::alloc::vec::Vec<
        EventThreatDetectionCustomModule,
    >,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request to update an Event Threat Detection custom module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEventThreatDetectionCustomModuleRequest {
    /// Required. The module being updated.
    #[prost(message, optional, tag = "1")]
    pub event_threat_detection_custom_module: ::core::option::Option<
        EventThreatDetectionCustomModule,
    >,
    /// The list of fields to be updated.
    /// If empty all mutable fields will be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request to get an EffectiveEventThreatDetectionCustomModule.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEffectiveEventThreatDetectionCustomModuleRequest {
    /// Required. The resource name of the effective Event Threat Detection custom
    /// module.
    ///
    /// Its format is:
    ///
    ///    * `organizations/{organization}/eventThreatDetectionSettings/effectiveCustomModules/{module}`.
    ///    * `folders/{folder}/eventThreatDetectionSettings/effectiveCustomModules/{module}`.
    ///    * `projects/{project}/eventThreatDetectionSettings/effectiveCustomModules/{module}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request to list effective Event Threat Detection custom modules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEffectiveEventThreatDetectionCustomModulesRequest {
    /// Required. Name of the parent to list custom modules for.
    ///
    /// Its format is:
    ///
    ///    * `organizations/{organization}/eventThreatDetectionSettings`.
    ///    * `folders/{folder}/eventThreatDetectionSettings`.
    ///    * `projects/{project}/eventThreatDetectionSettings`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// A page token, received from a previous
    /// `ListEffectiveEventThreatDetectionCustomModules` call. Provide this to
    /// retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListEffectiveEventThreatDetectionCustomModules` must match the call that
    /// provided the page token.
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    /// The maximum number of modules to return. The service may return fewer than
    /// this value.
    /// If unspecified, at most 10 configs will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
/// Response for listing EffectiveEventThreatDetectionCustomModules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEffectiveEventThreatDetectionCustomModulesResponse {
    /// Effective custom modules belonging to the requested parent.
    #[prost(message, repeated, tag = "1")]
    pub effective_event_threat_detection_custom_modules: ::prost::alloc::vec::Vec<
        EffectiveEventThreatDetectionCustomModule,
    >,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod security_center_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// V1 APIs for Security Center service.
    #[derive(Debug, Clone)]
    pub struct SecurityCenterClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SecurityCenterClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SecurityCenterClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SecurityCenterClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SecurityCenterClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Kicks off an LRO to bulk mute findings for a parent based on a filter. The
        /// parent can be either an organization, folder or project. The findings
        /// matched by the filter will be muted after the LRO is done.
        pub async fn bulk_mute_findings(
            &mut self,
            request: impl tonic::IntoRequest<super::BulkMuteFindingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/BulkMuteFindings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "BulkMuteFindings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a resident SecurityHealthAnalyticsCustomModule at the scope of the
        /// given CRM parent, and also creates inherited
        /// SecurityHealthAnalyticsCustomModules for all CRM descendants of the given
        /// parent. These modules are enabled by default.
        pub async fn create_security_health_analytics_custom_module(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateSecurityHealthAnalyticsCustomModuleRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SecurityHealthAnalyticsCustomModule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/CreateSecurityHealthAnalyticsCustomModule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "CreateSecurityHealthAnalyticsCustomModule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a source.
        pub async fn create_source(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSourceRequest>,
        ) -> std::result::Result<tonic::Response<super::Source>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/CreateSource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "CreateSource",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a finding. The corresponding source must exist for finding creation
        /// to succeed.
        pub async fn create_finding(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFindingRequest>,
        ) -> std::result::Result<tonic::Response<super::Finding>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/CreateFinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "CreateFinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a mute config.
        pub async fn create_mute_config(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateMuteConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::MuteConfig>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/CreateMuteConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "CreateMuteConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a notification config.
        pub async fn create_notification_config(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateNotificationConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NotificationConfig>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/CreateNotificationConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "CreateNotificationConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an existing mute config.
        pub async fn delete_mute_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteMuteConfigRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/DeleteMuteConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "DeleteMuteConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a notification config.
        pub async fn delete_notification_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteNotificationConfigRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/DeleteNotificationConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "DeleteNotificationConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified SecurityHealthAnalyticsCustomModule and all of its
        /// descendants in the CRM hierarchy. This method is only supported for
        /// resident custom modules.
        pub async fn delete_security_health_analytics_custom_module(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteSecurityHealthAnalyticsCustomModuleRequest,
            >,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/DeleteSecurityHealthAnalyticsCustomModule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "DeleteSecurityHealthAnalyticsCustomModule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the simulation by name or the latest simulation for the given
        /// organization.
        pub async fn get_simulation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSimulationRequest>,
        ) -> std::result::Result<tonic::Response<super::Simulation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/GetSimulation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "GetSimulation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the valued resource by name
        pub async fn get_valued_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::GetValuedResourceRequest>,
        ) -> std::result::Result<tonic::Response<super::ValuedResource>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/GetValuedResource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "GetValuedResource",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a BigQuery export.
        pub async fn get_big_query_export(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBigQueryExportRequest>,
        ) -> std::result::Result<tonic::Response<super::BigQueryExport>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/GetBigQueryExport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "GetBigQueryExport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy on the specified Source.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::GetIamPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::iam::v1::Policy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a mute config.
        pub async fn get_mute_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMuteConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::MuteConfig>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/GetMuteConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "GetMuteConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a notification config.
        pub async fn get_notification_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNotificationConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NotificationConfig>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/GetNotificationConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "GetNotificationConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the settings for an organization.
        pub async fn get_organization_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOrganizationSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OrganizationSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/GetOrganizationSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "GetOrganizationSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves an EffectiveSecurityHealthAnalyticsCustomModule.
        pub async fn get_effective_security_health_analytics_custom_module(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetEffectiveSecurityHealthAnalyticsCustomModuleRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::EffectiveSecurityHealthAnalyticsCustomModule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/GetEffectiveSecurityHealthAnalyticsCustomModule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "GetEffectiveSecurityHealthAnalyticsCustomModule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a SecurityHealthAnalyticsCustomModule.
        pub async fn get_security_health_analytics_custom_module(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetSecurityHealthAnalyticsCustomModuleRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SecurityHealthAnalyticsCustomModule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/GetSecurityHealthAnalyticsCustomModule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "GetSecurityHealthAnalyticsCustomModule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a source.
        pub async fn get_source(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSourceRequest>,
        ) -> std::result::Result<tonic::Response<super::Source>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/GetSource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "GetSource",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Filters an organization's assets and  groups them by their specified
        /// properties.
        #[deprecated]
        pub async fn group_assets(
            &mut self,
            request: impl tonic::IntoRequest<super::GroupAssetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GroupAssetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/GroupAssets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "GroupAssets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Filters an organization or source's findings and  groups them by their
        /// specified properties.
        ///
        /// To group across all sources provide a `-` as the source id.
        /// Example: /v1/organizations/{organization_id}/sources/-/findings,
        /// /v1/folders/{folder_id}/sources/-/findings,
        /// /v1/projects/{project_id}/sources/-/findings
        pub async fn group_findings(
            &mut self,
            request: impl tonic::IntoRequest<super::GroupFindingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GroupFindingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/GroupFindings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "GroupFindings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists an organization's assets.
        #[deprecated]
        pub async fn list_assets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAssetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAssetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/ListAssets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "ListAssets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns a list of all resident SecurityHealthAnalyticsCustomModules under
        /// the given CRM parent and all of the parent’s CRM descendants.
        pub async fn list_descendant_security_health_analytics_custom_modules(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListDescendantSecurityHealthAnalyticsCustomModulesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::ListDescendantSecurityHealthAnalyticsCustomModulesResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/ListDescendantSecurityHealthAnalyticsCustomModules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "ListDescendantSecurityHealthAnalyticsCustomModules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists an organization or source's findings.
        ///
        /// To list across all sources provide a `-` as the source id.
        /// Example: /v1/organizations/{organization_id}/sources/-/findings
        pub async fn list_findings(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFindingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFindingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/ListFindings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "ListFindings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists mute configs.
        pub async fn list_mute_configs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMuteConfigsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMuteConfigsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/ListMuteConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "ListMuteConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists notification configs.
        pub async fn list_notification_configs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNotificationConfigsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListNotificationConfigsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/ListNotificationConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "ListNotificationConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns a list of all EffectiveSecurityHealthAnalyticsCustomModules for the
        /// given parent. This includes resident modules defined at the scope of the
        /// parent, and inherited modules, inherited from CRM ancestors.
        pub async fn list_effective_security_health_analytics_custom_modules(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListEffectiveSecurityHealthAnalyticsCustomModulesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::ListEffectiveSecurityHealthAnalyticsCustomModulesResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/ListEffectiveSecurityHealthAnalyticsCustomModules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "ListEffectiveSecurityHealthAnalyticsCustomModules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns a list of all SecurityHealthAnalyticsCustomModules for the given
        /// parent. This includes resident modules defined at the scope of the parent,
        /// and inherited modules, inherited from CRM ancestors.
        pub async fn list_security_health_analytics_custom_modules(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListSecurityHealthAnalyticsCustomModulesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListSecurityHealthAnalyticsCustomModulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/ListSecurityHealthAnalyticsCustomModules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "ListSecurityHealthAnalyticsCustomModules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all sources belonging to an organization.
        pub async fn list_sources(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSourcesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSourcesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/ListSources",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "ListSources",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Runs asset discovery. The discovery is tracked with a long-running
        /// operation.
        ///
        /// This API can only be called with limited frequency for an organization. If
        /// it is called too frequently the caller will receive a TOO_MANY_REQUESTS
        /// error.
        #[deprecated]
        pub async fn run_asset_discovery(
            &mut self,
            request: impl tonic::IntoRequest<super::RunAssetDiscoveryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/RunAssetDiscovery",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "RunAssetDiscovery",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the state of a finding.
        pub async fn set_finding_state(
            &mut self,
            request: impl tonic::IntoRequest<super::SetFindingStateRequest>,
        ) -> std::result::Result<tonic::Response<super::Finding>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/SetFindingState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "SetFindingState",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the mute state of a finding.
        pub async fn set_mute(
            &mut self,
            request: impl tonic::IntoRequest<super::SetMuteRequest>,
        ) -> std::result::Result<tonic::Response<super::Finding>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/SetMute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "SetMute",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified Source.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::SetIamPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::iam::v1::Policy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the permissions that a caller has on the specified source.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::TestIamPermissionsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::super::super::super::iam::v1::TestIamPermissionsResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Simulates a given SecurityHealthAnalyticsCustomModule and Resource.
        pub async fn simulate_security_health_analytics_custom_module(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SimulateSecurityHealthAnalyticsCustomModuleRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SimulateSecurityHealthAnalyticsCustomModuleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/SimulateSecurityHealthAnalyticsCustomModule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "SimulateSecurityHealthAnalyticsCustomModule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates external system. This is for a given finding.
        pub async fn update_external_system(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateExternalSystemRequest>,
        ) -> std::result::Result<tonic::Response<super::ExternalSystem>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/UpdateExternalSystem",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "UpdateExternalSystem",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates or updates a finding. The corresponding source must exist for a
        /// finding creation to succeed.
        pub async fn update_finding(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateFindingRequest>,
        ) -> std::result::Result<tonic::Response<super::Finding>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/UpdateFinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "UpdateFinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a mute config.
        pub async fn update_mute_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateMuteConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::MuteConfig>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/UpdateMuteConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "UpdateMuteConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        ///
        /// Updates a notification config. The following update
        /// fields are allowed: description, pubsub_topic, streaming_config.filter
        pub async fn update_notification_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateNotificationConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NotificationConfig>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/UpdateNotificationConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "UpdateNotificationConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an organization's settings.
        pub async fn update_organization_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateOrganizationSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OrganizationSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/UpdateOrganizationSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "UpdateOrganizationSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the SecurityHealthAnalyticsCustomModule under the given name based
        /// on the given update mask. Updating the enablement state is supported on
        /// both resident and inherited modules (though resident modules cannot have an
        /// enablement state of "inherited"). Updating the display name and custom
        /// config of a module is supported on resident modules only.
        pub async fn update_security_health_analytics_custom_module(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateSecurityHealthAnalyticsCustomModuleRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SecurityHealthAnalyticsCustomModule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/UpdateSecurityHealthAnalyticsCustomModule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "UpdateSecurityHealthAnalyticsCustomModule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a source.
        pub async fn update_source(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSourceRequest>,
        ) -> std::result::Result<tonic::Response<super::Source>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/UpdateSource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "UpdateSource",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates security marks.
        pub async fn update_security_marks(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSecurityMarksRequest>,
        ) -> std::result::Result<tonic::Response<super::SecurityMarks>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/UpdateSecurityMarks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "UpdateSecurityMarks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a BigQuery export.
        pub async fn create_big_query_export(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBigQueryExportRequest>,
        ) -> std::result::Result<tonic::Response<super::BigQueryExport>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/CreateBigQueryExport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "CreateBigQueryExport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an existing BigQuery export.
        pub async fn delete_big_query_export(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBigQueryExportRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/DeleteBigQueryExport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "DeleteBigQueryExport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a BigQuery export.
        pub async fn update_big_query_export(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBigQueryExportRequest>,
        ) -> std::result::Result<tonic::Response<super::BigQueryExport>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/UpdateBigQueryExport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "UpdateBigQueryExport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists BigQuery exports. Note that when requesting BigQuery exports at a
        /// given level all exports under that level are also returned e.g. if
        /// requesting BigQuery exports under a folder, then all BigQuery exports
        /// immediately under the folder plus the ones created under the projects
        /// within the folder are returned.
        pub async fn list_big_query_exports(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBigQueryExportsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBigQueryExportsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/ListBigQueryExports",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "ListBigQueryExports",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a resident Event Threat Detection custom module at the scope of the
        /// given Resource Manager parent, and also creates inherited custom modules
        /// for all descendants of the given parent. These modules are enabled by
        /// default.
        pub async fn create_event_threat_detection_custom_module(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateEventThreatDetectionCustomModuleRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::EventThreatDetectionCustomModule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/CreateEventThreatDetectionCustomModule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "CreateEventThreatDetectionCustomModule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified Event Threat Detection custom module and all of its
        /// descendants in the Resource Manager hierarchy. This method is only
        /// supported for resident custom modules.
        pub async fn delete_event_threat_detection_custom_module(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteEventThreatDetectionCustomModuleRequest,
            >,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/DeleteEventThreatDetectionCustomModule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "DeleteEventThreatDetectionCustomModule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an Event Threat Detection custom module.
        pub async fn get_event_threat_detection_custom_module(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetEventThreatDetectionCustomModuleRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::EventThreatDetectionCustomModule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/GetEventThreatDetectionCustomModule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "GetEventThreatDetectionCustomModule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all resident Event Threat Detection custom modules under the
        /// given Resource Manager parent and its descendants.
        pub async fn list_descendant_event_threat_detection_custom_modules(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListDescendantEventThreatDetectionCustomModulesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::ListDescendantEventThreatDetectionCustomModulesResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/ListDescendantEventThreatDetectionCustomModules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "ListDescendantEventThreatDetectionCustomModules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all Event Threat Detection custom modules for the given
        /// Resource Manager parent. This includes resident modules defined at the
        /// scope of the parent along with modules inherited from ancestors.
        pub async fn list_event_threat_detection_custom_modules(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListEventThreatDetectionCustomModulesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListEventThreatDetectionCustomModulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/ListEventThreatDetectionCustomModules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "ListEventThreatDetectionCustomModules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the Event Threat Detection custom module with the given name based
        /// on the given update mask. Updating the enablement state is supported for
        /// both resident and inherited modules (though resident modules cannot have an
        /// enablement state of "inherited"). Updating the display name or
        /// configuration of a module is supported for resident modules only. The type
        /// of a module cannot be changed.
        pub async fn update_event_threat_detection_custom_module(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateEventThreatDetectionCustomModuleRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::EventThreatDetectionCustomModule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/UpdateEventThreatDetectionCustomModule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "UpdateEventThreatDetectionCustomModule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Validates the given Event Threat Detection custom module.
        pub async fn validate_event_threat_detection_custom_module(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ValidateEventThreatDetectionCustomModuleRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ValidateEventThreatDetectionCustomModuleResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/ValidateEventThreatDetectionCustomModule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "ValidateEventThreatDetectionCustomModule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an effective Event Threat Detection custom module at the given level.
        pub async fn get_effective_event_threat_detection_custom_module(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetEffectiveEventThreatDetectionCustomModuleRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::EffectiveEventThreatDetectionCustomModule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/GetEffectiveEventThreatDetectionCustomModule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "GetEffectiveEventThreatDetectionCustomModule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all effective Event Threat Detection custom modules for the
        /// given parent. This includes resident modules defined at the scope of the
        /// parent along with modules inherited from its ancestors.
        pub async fn list_effective_event_threat_detection_custom_modules(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListEffectiveEventThreatDetectionCustomModulesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::ListEffectiveEventThreatDetectionCustomModulesResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/ListEffectiveEventThreatDetectionCustomModules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "ListEffectiveEventThreatDetectionCustomModules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a ResourceValueConfig for an organization. Maps user's tags to
        /// difference resource values for use by the attack path simulation.
        pub async fn batch_create_resource_value_configs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::BatchCreateResourceValueConfigsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::BatchCreateResourceValueConfigsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/BatchCreateResourceValueConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "BatchCreateResourceValueConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a ResourceValueConfig.
        pub async fn delete_resource_value_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteResourceValueConfigRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/DeleteResourceValueConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "DeleteResourceValueConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a ResourceValueConfig.
        pub async fn get_resource_value_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetResourceValueConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ResourceValueConfig>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/GetResourceValueConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "GetResourceValueConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all ResourceValueConfigs.
        pub async fn list_resource_value_configs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListResourceValueConfigsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListResourceValueConfigsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/ListResourceValueConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "ListResourceValueConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an existing ResourceValueConfigs with new rules.
        pub async fn update_resource_value_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateResourceValueConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ResourceValueConfig>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/UpdateResourceValueConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "UpdateResourceValueConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the valued resources for a set of simulation results and filter.
        pub async fn list_valued_resources(
            &mut self,
            request: impl tonic::IntoRequest<super::ListValuedResourcesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListValuedResourcesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/ListValuedResources",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "ListValuedResources",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the attack paths for a set of simulation results or valued resources
        /// and filter.
        pub async fn list_attack_paths(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAttackPathsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAttackPathsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securitycenter.v1.SecurityCenter/ListAttackPaths",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securitycenter.v1.SecurityCenter",
                        "ListAttackPaths",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
