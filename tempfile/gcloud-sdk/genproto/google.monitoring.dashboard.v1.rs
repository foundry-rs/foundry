// This file is @generated by prost-build.
/// A chart that displays alert policy data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlertChart {
    /// Required. The resource name of the alert policy. The format is:
    ///
    ///      projects/\[PROJECT_ID_OR_NUMBER\]/alertPolicies/\[ALERT_POLICY_ID\]
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A widget that groups the other widgets. All widgets that are within
/// the area spanned by the grouping widget are considered member widgets.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CollapsibleGroup {
    /// The collapsed state of the widget on first page load.
    #[prost(bool, tag = "1")]
    pub collapsed: bool,
}
/// Describes how to combine multiple time series to provide a different view of
/// the data.  Aggregation of time series is done in two steps. First, each time
/// series in the set is _aligned_ to the same time interval boundaries, then the
/// set of time series is optionally _reduced_ in number.
///
/// Alignment consists of applying the `per_series_aligner` operation
/// to each time series after its data has been divided into regular
/// `alignment_period` time intervals. This process takes _all_ of the data
/// points in an alignment period, applies a mathematical transformation such as
/// averaging, minimum, maximum, delta, etc., and converts them into a single
/// data point per period.
///
/// Reduction is when the aligned and transformed time series can optionally be
/// combined, reducing the number of time series through similar mathematical
/// transformations. Reduction involves applying a `cross_series_reducer` to
/// all the time series, optionally sorting the time series into subsets with
/// `group_by_fields`, and applying the reducer to each subset.
///
/// The raw time series data can contain a huge amount of information from
/// multiple sources. Alignment and reduction transforms this mass of data into
/// a more manageable and representative collection of data, for example "the
/// 95% latency across the average of all tasks in a cluster". This
/// representative data can be more easily graphed and comprehended, and the
/// individual time series data is still available for later drilldown. For more
/// details, see [Filtering and
/// aggregation](<https://cloud.google.com/monitoring/api/v3/aggregation>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Aggregation {
    /// The `alignment_period` specifies a time interval, in seconds, that is used
    /// to divide the data in all the
    /// [time series][google.monitoring.v3.TimeSeries] into consistent blocks of
    /// time. This will be done before the per-series aligner can be applied to
    /// the data.
    ///
    /// The value must be at least 60 seconds. If a per-series aligner other than
    /// `ALIGN_NONE` is specified, this field is required or an error is returned.
    /// If no per-series aligner is specified, or the aligner `ALIGN_NONE` is
    /// specified, then this field is ignored.
    ///
    /// The maximum value of the `alignment_period` is 2 years, or 104 weeks.
    #[prost(message, optional, tag = "1")]
    pub alignment_period: ::core::option::Option<::prost_types::Duration>,
    /// An `Aligner` describes how to bring the data points in a single
    /// time series into temporal alignment. Except for `ALIGN_NONE`, all
    /// alignments cause all the data points in an `alignment_period` to be
    /// mathematically grouped together, resulting in a single data point for
    /// each `alignment_period` with end timestamp at the end of the period.
    ///
    /// Not all alignment operations may be applied to all time series. The valid
    /// choices depend on the `metric_kind` and `value_type` of the original time
    /// series. Alignment can change the `metric_kind` or the `value_type` of
    /// the time series.
    ///
    /// Time series data must be aligned in order to perform cross-time
    /// series reduction. If `cross_series_reducer` is specified, then
    /// `per_series_aligner` must be specified and not equal to `ALIGN_NONE`
    /// and `alignment_period` must be specified; otherwise, an error is
    /// returned.
    #[prost(enumeration = "aggregation::Aligner", tag = "2")]
    pub per_series_aligner: i32,
    /// The reduction operation to be used to combine time series into a single
    /// time series, where the value of each data point in the resulting series is
    /// a function of all the already aligned values in the input time series.
    ///
    /// Not all reducer operations can be applied to all time series. The valid
    /// choices depend on the `metric_kind` and the `value_type` of the original
    /// time series. Reduction can yield a time series with a different
    /// `metric_kind` or `value_type` than the input time series.
    ///
    /// Time series data must first be aligned (see `per_series_aligner`) in order
    /// to perform cross-time series reduction. If `cross_series_reducer` is
    /// specified, then `per_series_aligner` must be specified, and must not be
    /// `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an
    /// error is returned.
    #[prost(enumeration = "aggregation::Reducer", tag = "4")]
    pub cross_series_reducer: i32,
    /// The set of fields to preserve when `cross_series_reducer` is
    /// specified. The `group_by_fields` determine how the time series are
    /// partitioned into subsets prior to applying the aggregation
    /// operation. Each subset contains time series that have the same
    /// value for each of the grouping fields. Each individual time
    /// series is a member of exactly one subset. The
    /// `cross_series_reducer` is applied to each subset of time series.
    /// It is not possible to reduce across different resource types, so
    /// this field implicitly contains `resource.type`.  Fields not
    /// specified in `group_by_fields` are aggregated away.  If
    /// `group_by_fields` is not specified and all the time series have
    /// the same resource type, then the time series are aggregated into
    /// a single output time series. If `cross_series_reducer` is not
    /// defined, this field is ignored.
    #[prost(string, repeated, tag = "5")]
    pub group_by_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Aggregation`.
pub mod aggregation {
    /// The `Aligner` specifies the operation that will be applied to the data
    /// points in each alignment period in a time series. Except for
    /// `ALIGN_NONE`, which specifies that no operation be applied, each alignment
    /// operation replaces the set of data values in each alignment period with
    /// a single value: the result of applying the operation to the data values.
    /// An aligned time series has a single data value at the end of each
    /// `alignment_period`.
    ///
    /// An alignment operation can change the data type of the values, too. For
    /// example, if you apply a counting operation to boolean values, the data
    /// `value_type` in the original time series is `BOOLEAN`, but the `value_type`
    /// in the aligned result is `INT64`.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Aligner {
        /// No alignment. Raw data is returned. Not valid if cross-series reduction
        /// is requested. The `value_type` of the result is the same as the
        /// `value_type` of the input.
        AlignNone = 0,
        /// Align and convert to
        /// [DELTA][google.api.MetricDescriptor.MetricKind.DELTA].
        /// The output is `delta = y1 - y0`.
        ///
        /// This alignment is valid for
        /// [CUMULATIVE][google.api.MetricDescriptor.MetricKind.CUMULATIVE] and
        /// `DELTA` metrics. If the selected alignment period results in periods
        /// with no data, then the aligned value for such a period is created by
        /// interpolation. The `value_type`  of the aligned result is the same as
        /// the `value_type` of the input.
        AlignDelta = 1,
        /// Align and convert to a rate. The result is computed as
        /// `rate = (y1 - y0)/(t1 - t0)`, or "delta over time".
        /// Think of this aligner as providing the slope of the line that passes
        /// through the value at the start and at the end of the `alignment_period`.
        ///
        /// This aligner is valid for `CUMULATIVE`
        /// and `DELTA` metrics with numeric values. If the selected alignment
        /// period results in periods with no data, then the aligned value for
        /// such a period is created by interpolation. The output is a `GAUGE`
        /// metric with `value_type` `DOUBLE`.
        ///
        /// If, by "rate", you mean "percentage change", see the
        /// `ALIGN_PERCENT_CHANGE` aligner instead.
        AlignRate = 2,
        /// Align by interpolating between adjacent points around the alignment
        /// period boundary. This aligner is valid for `GAUGE` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as the
        /// `value_type` of the input.
        AlignInterpolate = 3,
        /// Align by moving the most recent data point before the end of the
        /// alignment period to the boundary at the end of the alignment
        /// period. This aligner is valid for `GAUGE` metrics. The `value_type` of
        /// the aligned result is the same as the `value_type` of the input.
        AlignNextOlder = 4,
        /// Align the time series by returning the minimum value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as
        /// the `value_type` of the input.
        AlignMin = 10,
        /// Align the time series by returning the maximum value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is the same as
        /// the `value_type` of the input.
        AlignMax = 11,
        /// Align the time series by returning the mean value in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric values. The `value_type` of the aligned result is `DOUBLE`.
        AlignMean = 12,
        /// Align the time series by returning the number of values in each alignment
        /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
        /// numeric or Boolean values. The `value_type` of the aligned result is
        /// `INT64`.
        AlignCount = 13,
        /// Align the time series by returning the sum of the values in each
        /// alignment period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with numeric and distribution values. The `value_type` of the
        /// aligned result is the same as the `value_type` of the input.
        AlignSum = 14,
        /// Align the time series by returning the standard deviation of the values
        /// in each alignment period. This aligner is valid for `GAUGE` and
        /// `DELTA` metrics with numeric values. The `value_type` of the output is
        /// `DOUBLE`.
        AlignStddev = 15,
        /// Align the time series by returning the number of `True` values in
        /// each alignment period. This aligner is valid for `GAUGE` metrics with
        /// Boolean values. The `value_type` of the output is `INT64`.
        AlignCountTrue = 16,
        /// Align the time series by returning the number of `False` values in
        /// each alignment period. This aligner is valid for `GAUGE` metrics with
        /// Boolean values. The `value_type` of the output is `INT64`.
        AlignCountFalse = 24,
        /// Align the time series by returning the ratio of the number of `True`
        /// values to the total number of values in each alignment period. This
        /// aligner is valid for `GAUGE` metrics with Boolean values. The output
        /// value is in the range \[0.0, 1.0\] and has `value_type` `DOUBLE`.
        AlignFractionTrue = 17,
        /// Align the time series by using [percentile
        /// aggregation](<https://en.wikipedia.org/wiki/Percentile>). The resulting
        /// data point in each alignment period is the 99th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        AlignPercentile99 = 18,
        /// Align the time series by using [percentile
        /// aggregation](<https://en.wikipedia.org/wiki/Percentile>). The resulting
        /// data point in each alignment period is the 95th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        AlignPercentile95 = 19,
        /// Align the time series by using [percentile
        /// aggregation](<https://en.wikipedia.org/wiki/Percentile>). The resulting
        /// data point in each alignment period is the 50th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        AlignPercentile50 = 20,
        /// Align the time series by using [percentile
        /// aggregation](<https://en.wikipedia.org/wiki/Percentile>). The resulting
        /// data point in each alignment period is the 5th percentile of all data
        /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
        /// metrics with distribution values. The output is a `GAUGE` metric with
        /// `value_type` `DOUBLE`.
        AlignPercentile05 = 21,
        /// Align and convert to a percentage change. This aligner is valid for
        /// `GAUGE` and `DELTA` metrics with numeric values. This alignment returns
        /// `((current - previous)/previous) * 100`, where the value of `previous` is
        /// determined based on the `alignment_period`.
        ///
        /// If the values of `current` and `previous` are both 0, then the returned
        /// value is 0. If only `previous` is 0, the returned value is infinity.
        ///
        /// A 10-minute moving mean is computed at each point of the alignment period
        /// prior to the above calculation to smooth the metric and prevent false
        /// positives from very short-lived spikes. The moving mean is only
        /// applicable for data whose values are `>= 0`. Any values `< 0` are
        /// treated as a missing datapoint, and are ignored. While `DELTA`
        /// metrics are accepted by this alignment, special care should be taken that
        /// the values for the metric will always be positive. The output is a
        /// `GAUGE` metric with `value_type` `DOUBLE`.
        AlignPercentChange = 23,
    }
    impl Aligner {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::AlignNone => "ALIGN_NONE",
                Self::AlignDelta => "ALIGN_DELTA",
                Self::AlignRate => "ALIGN_RATE",
                Self::AlignInterpolate => "ALIGN_INTERPOLATE",
                Self::AlignNextOlder => "ALIGN_NEXT_OLDER",
                Self::AlignMin => "ALIGN_MIN",
                Self::AlignMax => "ALIGN_MAX",
                Self::AlignMean => "ALIGN_MEAN",
                Self::AlignCount => "ALIGN_COUNT",
                Self::AlignSum => "ALIGN_SUM",
                Self::AlignStddev => "ALIGN_STDDEV",
                Self::AlignCountTrue => "ALIGN_COUNT_TRUE",
                Self::AlignCountFalse => "ALIGN_COUNT_FALSE",
                Self::AlignFractionTrue => "ALIGN_FRACTION_TRUE",
                Self::AlignPercentile99 => "ALIGN_PERCENTILE_99",
                Self::AlignPercentile95 => "ALIGN_PERCENTILE_95",
                Self::AlignPercentile50 => "ALIGN_PERCENTILE_50",
                Self::AlignPercentile05 => "ALIGN_PERCENTILE_05",
                Self::AlignPercentChange => "ALIGN_PERCENT_CHANGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALIGN_NONE" => Some(Self::AlignNone),
                "ALIGN_DELTA" => Some(Self::AlignDelta),
                "ALIGN_RATE" => Some(Self::AlignRate),
                "ALIGN_INTERPOLATE" => Some(Self::AlignInterpolate),
                "ALIGN_NEXT_OLDER" => Some(Self::AlignNextOlder),
                "ALIGN_MIN" => Some(Self::AlignMin),
                "ALIGN_MAX" => Some(Self::AlignMax),
                "ALIGN_MEAN" => Some(Self::AlignMean),
                "ALIGN_COUNT" => Some(Self::AlignCount),
                "ALIGN_SUM" => Some(Self::AlignSum),
                "ALIGN_STDDEV" => Some(Self::AlignStddev),
                "ALIGN_COUNT_TRUE" => Some(Self::AlignCountTrue),
                "ALIGN_COUNT_FALSE" => Some(Self::AlignCountFalse),
                "ALIGN_FRACTION_TRUE" => Some(Self::AlignFractionTrue),
                "ALIGN_PERCENTILE_99" => Some(Self::AlignPercentile99),
                "ALIGN_PERCENTILE_95" => Some(Self::AlignPercentile95),
                "ALIGN_PERCENTILE_50" => Some(Self::AlignPercentile50),
                "ALIGN_PERCENTILE_05" => Some(Self::AlignPercentile05),
                "ALIGN_PERCENT_CHANGE" => Some(Self::AlignPercentChange),
                _ => None,
            }
        }
    }
    /// A Reducer operation describes how to aggregate data points from multiple
    /// time series into a single time series, where the value of each data point
    /// in the resulting series is a function of all the already aligned values in
    /// the input time series.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Reducer {
        /// No cross-time series reduction. The output of the `Aligner` is
        /// returned.
        ReduceNone = 0,
        /// Reduce by computing the mean value across time series for each
        /// alignment period. This reducer is valid for
        /// [DELTA][google.api.MetricDescriptor.MetricKind.DELTA] and
        /// [GAUGE][google.api.MetricDescriptor.MetricKind.GAUGE] metrics with
        /// numeric or distribution values. The `value_type` of the output is
        /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
        ReduceMean = 1,
        /// Reduce by computing the minimum value across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric values. The `value_type` of the output is the same as the
        /// `value_type` of the input.
        ReduceMin = 2,
        /// Reduce by computing the maximum value across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric values. The `value_type` of the output is the same as the
        /// `value_type` of the input.
        ReduceMax = 3,
        /// Reduce by computing the sum across time series for each
        /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
        /// with numeric and distribution values. The `value_type` of the output is
        /// the same as the `value_type` of the input.
        ReduceSum = 4,
        /// Reduce by computing the standard deviation across time series
        /// for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics with numeric or distribution values. The `value_type`
        /// of the output is `DOUBLE`.
        ReduceStddev = 5,
        /// Reduce by computing the number of data points across time series
        /// for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of numeric, Boolean, distribution, and string
        /// `value_type`. The `value_type` of the output is `INT64`.
        ReduceCount = 6,
        /// Reduce by computing the number of `True`-valued data points across time
        /// series for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
        /// is `INT64`.
        ReduceCountTrue = 7,
        /// Reduce by computing the number of `False`-valued data points across time
        /// series for each alignment period. This reducer is valid for `DELTA` and
        /// `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
        /// is `INT64`.
        ReduceCountFalse = 15,
        /// Reduce by computing the ratio of the number of `True`-valued data points
        /// to the total number of data points for each alignment period. This
        /// reducer is valid for `DELTA` and `GAUGE` metrics of Boolean `value_type`.
        /// The output value is in the range \[0.0, 1.0\] and has `value_type`
        /// `DOUBLE`.
        ReduceFractionTrue = 8,
        /// Reduce by computing the [99th
        /// percentile](<https://en.wikipedia.org/wiki/Percentile>) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        ReducePercentile99 = 9,
        /// Reduce by computing the [95th
        /// percentile](<https://en.wikipedia.org/wiki/Percentile>) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        ReducePercentile95 = 10,
        /// Reduce by computing the [50th
        /// percentile](<https://en.wikipedia.org/wiki/Percentile>) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        ReducePercentile50 = 11,
        /// Reduce by computing the [5th
        /// percentile](<https://en.wikipedia.org/wiki/Percentile>) of data points
        /// across time series for each alignment period. This reducer is valid for
        /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
        /// of the output is `DOUBLE`.
        ReducePercentile05 = 12,
    }
    impl Reducer {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ReduceNone => "REDUCE_NONE",
                Self::ReduceMean => "REDUCE_MEAN",
                Self::ReduceMin => "REDUCE_MIN",
                Self::ReduceMax => "REDUCE_MAX",
                Self::ReduceSum => "REDUCE_SUM",
                Self::ReduceStddev => "REDUCE_STDDEV",
                Self::ReduceCount => "REDUCE_COUNT",
                Self::ReduceCountTrue => "REDUCE_COUNT_TRUE",
                Self::ReduceCountFalse => "REDUCE_COUNT_FALSE",
                Self::ReduceFractionTrue => "REDUCE_FRACTION_TRUE",
                Self::ReducePercentile99 => "REDUCE_PERCENTILE_99",
                Self::ReducePercentile95 => "REDUCE_PERCENTILE_95",
                Self::ReducePercentile50 => "REDUCE_PERCENTILE_50",
                Self::ReducePercentile05 => "REDUCE_PERCENTILE_05",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REDUCE_NONE" => Some(Self::ReduceNone),
                "REDUCE_MEAN" => Some(Self::ReduceMean),
                "REDUCE_MIN" => Some(Self::ReduceMin),
                "REDUCE_MAX" => Some(Self::ReduceMax),
                "REDUCE_SUM" => Some(Self::ReduceSum),
                "REDUCE_STDDEV" => Some(Self::ReduceStddev),
                "REDUCE_COUNT" => Some(Self::ReduceCount),
                "REDUCE_COUNT_TRUE" => Some(Self::ReduceCountTrue),
                "REDUCE_COUNT_FALSE" => Some(Self::ReduceCountFalse),
                "REDUCE_FRACTION_TRUE" => Some(Self::ReduceFractionTrue),
                "REDUCE_PERCENTILE_99" => Some(Self::ReducePercentile99),
                "REDUCE_PERCENTILE_95" => Some(Self::ReducePercentile95),
                "REDUCE_PERCENTILE_50" => Some(Self::ReducePercentile50),
                "REDUCE_PERCENTILE_05" => Some(Self::ReducePercentile05),
                _ => None,
            }
        }
    }
}
/// Describes a ranking-based time series filter. Each input time series is
/// ranked with an aligner. The filter will allow up to `num_time_series` time
/// series to pass through it, selecting them based on the relative ranking.
///
/// For example, if `ranking_method` is `METHOD_MEAN`,`direction` is `BOTTOM`,
/// and `num_time_series` is 3, then the 3 times series with the lowest mean
/// values will pass through the filter.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PickTimeSeriesFilter {
    /// `ranking_method` is applied to each time series independently to produce
    /// the value which will be used to compare the time series to other time
    /// series.
    #[prost(enumeration = "pick_time_series_filter::Method", tag = "1")]
    pub ranking_method: i32,
    /// How many time series to allow to pass through the filter.
    #[prost(int32, tag = "2")]
    pub num_time_series: i32,
    /// How to use the ranking to select time series that pass through the filter.
    #[prost(enumeration = "pick_time_series_filter::Direction", tag = "3")]
    pub direction: i32,
    /// Select the top N streams/time series within this time interval
    #[prost(message, optional, tag = "4")]
    pub interval: ::core::option::Option<super::super::super::r#type::Interval>,
}
/// Nested message and enum types in `PickTimeSeriesFilter`.
pub mod pick_time_series_filter {
    /// The value reducers that can be applied to a `PickTimeSeriesFilter`.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Method {
        /// Not allowed. You must specify a different `Method` if you specify a
        /// `PickTimeSeriesFilter`.
        Unspecified = 0,
        /// Select the mean of all values.
        Mean = 1,
        /// Select the maximum value.
        Max = 2,
        /// Select the minimum value.
        Min = 3,
        /// Compute the sum of all values.
        Sum = 4,
        /// Select the most recent value.
        Latest = 5,
    }
    impl Method {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "METHOD_UNSPECIFIED",
                Self::Mean => "METHOD_MEAN",
                Self::Max => "METHOD_MAX",
                Self::Min => "METHOD_MIN",
                Self::Sum => "METHOD_SUM",
                Self::Latest => "METHOD_LATEST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                "METHOD_MEAN" => Some(Self::Mean),
                "METHOD_MAX" => Some(Self::Max),
                "METHOD_MIN" => Some(Self::Min),
                "METHOD_SUM" => Some(Self::Sum),
                "METHOD_LATEST" => Some(Self::Latest),
                _ => None,
            }
        }
    }
    /// Describes the ranking directions.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Direction {
        /// Not allowed. You must specify a different `Direction` if you specify a
        /// `PickTimeSeriesFilter`.
        Unspecified = 0,
        /// Pass the highest `num_time_series` ranking inputs.
        Top = 1,
        /// Pass the lowest `num_time_series` ranking inputs.
        Bottom = 2,
    }
    impl Direction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DIRECTION_UNSPECIFIED",
                Self::Top => "TOP",
                Self::Bottom => "BOTTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
                "TOP" => Some(Self::Top),
                "BOTTOM" => Some(Self::Bottom),
                _ => None,
            }
        }
    }
}
/// A filter that ranks streams based on their statistical relation to other
/// streams in a request.
/// Note: This field is deprecated and completely ignored by the API.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StatisticalTimeSeriesFilter {
    /// `rankingMethod` is applied to a set of time series, and then the produced
    /// value for each individual time series is used to compare a given time
    /// series to others.
    /// These are methods that cannot be applied stream-by-stream, but rather
    /// require the full context of a request to evaluate time series.
    #[prost(enumeration = "statistical_time_series_filter::Method", tag = "1")]
    pub ranking_method: i32,
    /// How many time series to output.
    #[prost(int32, tag = "2")]
    pub num_time_series: i32,
}
/// Nested message and enum types in `StatisticalTimeSeriesFilter`.
pub mod statistical_time_series_filter {
    /// The filter methods that can be applied to a stream.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Method {
        /// Not allowed in well-formed requests.
        Unspecified = 0,
        /// Compute the outlier score of each stream.
        ClusterOutlier = 1,
    }
    impl Method {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "METHOD_UNSPECIFIED",
                Self::ClusterOutlier => "METHOD_CLUSTER_OUTLIER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                "METHOD_CLUSTER_OUTLIER" => Some(Self::ClusterOutlier),
                _ => None,
            }
        }
    }
}
/// A filter to reduce the amount of data charted in relevant widgets.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DashboardFilter {
    /// Required. The key for the label
    #[prost(string, tag = "1")]
    pub label_key: ::prost::alloc::string::String,
    /// The placeholder text that can be referenced in a filter string or MQL
    /// query. If omitted, the dashboard filter will be applied to all relevant
    /// widgets in the dashboard.
    #[prost(string, tag = "3")]
    pub template_variable: ::prost::alloc::string::String,
    /// The specified filter type
    #[prost(enumeration = "dashboard_filter::FilterType", tag = "5")]
    pub filter_type: i32,
    /// The default value used in the filter comparison
    #[prost(oneof = "dashboard_filter::DefaultValue", tags = "4")]
    pub default_value: ::core::option::Option<dashboard_filter::DefaultValue>,
}
/// Nested message and enum types in `DashboardFilter`.
pub mod dashboard_filter {
    /// The type for the dashboard filter
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FilterType {
        /// Filter type is unspecified. This is not valid in a well-formed request.
        Unspecified = 0,
        /// Filter on a resource label value
        ResourceLabel = 1,
        /// Filter on a metrics label value
        MetricLabel = 2,
        /// Filter on a user metadata label value
        UserMetadataLabel = 3,
        /// Filter on a system metadata label value
        SystemMetadataLabel = 4,
        /// Filter on a group id
        Group = 5,
    }
    impl FilterType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FILTER_TYPE_UNSPECIFIED",
                Self::ResourceLabel => "RESOURCE_LABEL",
                Self::MetricLabel => "METRIC_LABEL",
                Self::UserMetadataLabel => "USER_METADATA_LABEL",
                Self::SystemMetadataLabel => "SYSTEM_METADATA_LABEL",
                Self::Group => "GROUP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FILTER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "RESOURCE_LABEL" => Some(Self::ResourceLabel),
                "METRIC_LABEL" => Some(Self::MetricLabel),
                "USER_METADATA_LABEL" => Some(Self::UserMetadataLabel),
                "SYSTEM_METADATA_LABEL" => Some(Self::SystemMetadataLabel),
                "GROUP" => Some(Self::Group),
                _ => None,
            }
        }
    }
    /// The default value used in the filter comparison
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DefaultValue {
        /// A variable-length string value.
        #[prost(string, tag = "4")]
        StringValue(::prost::alloc::string::String),
    }
}
/// A widget that displays a list of error groups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorReportingPanel {
    /// The resource name of the Google Cloud Platform project. Written
    /// as `projects/{projectID}` or `projects/{projectNumber}`, where
    /// `{projectID}` and `{projectNumber}` can be found in the
    /// [Google Cloud console](<https://support.google.com/cloud/answer/6158840>).
    ///
    /// Examples: `projects/my-project-123`, `projects/5551234`.
    #[prost(string, repeated, tag = "1")]
    pub project_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// An identifier of the service, such as the name of the
    /// executable, job, or Google App Engine service name. This field is expected
    /// to have a low number of values that are relatively stable over time, as
    /// opposed to `version`, which can be changed whenever new code is deployed.
    ///
    /// Contains the service name for error reports extracted from Google
    /// App Engine logs or `default` if the App Engine default service is used.
    #[prost(string, repeated, tag = "2")]
    pub services: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Represents the source code version that the developer provided,
    /// which could represent a version label or a Git SHA-1 hash, for example.
    /// For App Engine standard environment, the version is set to the version of
    /// the app.
    #[prost(string, repeated, tag = "3")]
    pub versions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A widget that displays a list of incidents
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IncidentList {
    /// Optional. The monitored resource for which incidents are listed.
    /// The resource doesn't need to be fully specified. That is, you can specify
    /// the resource type but not the values of the resource labels.
    /// The resource type and labels are used for filtering.
    #[prost(message, repeated, tag = "1")]
    pub monitored_resources: ::prost::alloc::vec::Vec<
        super::super::super::api::MonitoredResource,
    >,
    /// Optional. A list of alert policy names to filter the incident list by.
    /// Don't include the project ID prefix in the policy name. For
    /// example, use `alertPolicies/utilization`.
    #[prost(string, repeated, tag = "2")]
    pub policy_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A widget that displays a stream of log.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogsPanel {
    /// A filter that chooses which log entries to return.  See [Advanced Logs
    /// Queries](<https://cloud.google.com/logging/docs/view/advanced-queries>).
    /// Only log entries that match the filter are returned.  An empty filter
    /// matches all log entries.
    #[prost(string, tag = "1")]
    pub filter: ::prost::alloc::string::String,
    /// The names of logging resources to collect logs for. Currently only projects
    /// are supported. If empty, the widget will default to the host project.
    #[prost(string, repeated, tag = "2")]
    pub resource_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// TimeSeriesQuery collects the set of supported methods for querying time
/// series data from the Stackdriver metrics API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeriesQuery {
    /// The unit of data contained in fetched time series. If non-empty, this
    /// unit will override any unit that accompanies fetched data. The format is
    /// the same as the
    /// [`unit`](<https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors>)
    /// field in `MetricDescriptor`.
    #[prost(string, tag = "5")]
    pub unit_override: ::prost::alloc::string::String,
    /// Optional. If set, Cloud Monitoring will treat the full query duration as
    /// the alignment period so that there will be only 1 output value.
    ///
    /// *Note: This could override the configured alignment period except for
    /// the cases where a series of data points are expected, like
    ///    - XyChart
    ///    - Scorecard's spark chart
    #[prost(bool, tag = "7")]
    pub output_full_duration: bool,
    /// Parameters needed to obtain data for the chart.
    #[prost(oneof = "time_series_query::Source", tags = "1, 2, 3, 6")]
    pub source: ::core::option::Option<time_series_query::Source>,
}
/// Nested message and enum types in `TimeSeriesQuery`.
pub mod time_series_query {
    /// Parameters needed to obtain data for the chart.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// Filter parameters to fetch time series.
        #[prost(message, tag = "1")]
        TimeSeriesFilter(super::TimeSeriesFilter),
        /// Parameters to fetch a ratio between two time series filters.
        #[prost(message, tag = "2")]
        TimeSeriesFilterRatio(super::TimeSeriesFilterRatio),
        /// A query used to fetch time series with MQL.
        #[prost(string, tag = "3")]
        TimeSeriesQueryLanguage(::prost::alloc::string::String),
        /// A query used to fetch time series with PromQL.
        #[prost(string, tag = "6")]
        PrometheusQuery(::prost::alloc::string::String),
    }
}
/// A filter that defines a subset of time series data that is displayed in a
/// widget. Time series data is fetched using the
/// [`ListTimeSeries`](<https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list>)
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeriesFilter {
    /// Required. The [monitoring
    /// filter](<https://cloud.google.com/monitoring/api/v3/filters>) that identifies
    /// the metric types, resources, and projects to query.
    #[prost(string, tag = "1")]
    pub filter: ::prost::alloc::string::String,
    /// By default, the raw time series data is returned.
    /// Use this field to combine multiple time series for different views of the
    /// data.
    #[prost(message, optional, tag = "2")]
    pub aggregation: ::core::option::Option<Aggregation>,
    /// Apply a second aggregation after `aggregation` is applied.
    #[prost(message, optional, tag = "3")]
    pub secondary_aggregation: ::core::option::Option<Aggregation>,
    /// Selects an optional time series filter.
    #[prost(oneof = "time_series_filter::OutputFilter", tags = "4, 5")]
    pub output_filter: ::core::option::Option<time_series_filter::OutputFilter>,
}
/// Nested message and enum types in `TimeSeriesFilter`.
pub mod time_series_filter {
    /// Selects an optional time series filter.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum OutputFilter {
        /// Ranking based time series filter.
        #[prost(message, tag = "4")]
        PickTimeSeriesFilter(super::PickTimeSeriesFilter),
        /// Statistics based time series filter.
        /// Note: This field is deprecated and completely ignored by the API.
        #[prost(message, tag = "5")]
        StatisticalTimeSeriesFilter(super::StatisticalTimeSeriesFilter),
    }
}
/// A pair of time series filters that define a ratio computation. The output
/// time series is the pair-wise division of each aligned element from the
/// numerator and denominator time series.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeriesFilterRatio {
    /// The numerator of the ratio.
    #[prost(message, optional, tag = "1")]
    pub numerator: ::core::option::Option<time_series_filter_ratio::RatioPart>,
    /// The denominator of the ratio.
    #[prost(message, optional, tag = "2")]
    pub denominator: ::core::option::Option<time_series_filter_ratio::RatioPart>,
    /// Apply a second aggregation after the ratio is computed.
    #[prost(message, optional, tag = "3")]
    pub secondary_aggregation: ::core::option::Option<Aggregation>,
    /// Selects an optional filter that is applied to the time series after
    /// computing the ratio.
    #[prost(oneof = "time_series_filter_ratio::OutputFilter", tags = "4, 5")]
    pub output_filter: ::core::option::Option<time_series_filter_ratio::OutputFilter>,
}
/// Nested message and enum types in `TimeSeriesFilterRatio`.
pub mod time_series_filter_ratio {
    /// Describes a query to build the numerator or denominator of a
    /// TimeSeriesFilterRatio.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RatioPart {
        /// Required. The [monitoring
        /// filter](<https://cloud.google.com/monitoring/api/v3/filters>) that
        /// identifies the metric types, resources, and projects to query.
        #[prost(string, tag = "1")]
        pub filter: ::prost::alloc::string::String,
        /// By default, the raw time series data is returned.
        /// Use this field to combine multiple time series for different views of the
        /// data.
        #[prost(message, optional, tag = "2")]
        pub aggregation: ::core::option::Option<super::Aggregation>,
    }
    /// Selects an optional filter that is applied to the time series after
    /// computing the ratio.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum OutputFilter {
        /// Ranking based time series filter.
        #[prost(message, tag = "4")]
        PickTimeSeriesFilter(super::PickTimeSeriesFilter),
        /// Statistics based time series filter.
        /// Note: This field is deprecated and completely ignored by the API.
        #[prost(message, tag = "5")]
        StatisticalTimeSeriesFilter(super::StatisticalTimeSeriesFilter),
    }
}
/// Defines a threshold for categorizing time series values.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Threshold {
    /// A label for the threshold.
    #[prost(string, tag = "1")]
    pub label: ::prost::alloc::string::String,
    /// The value of the threshold. The value should be defined in the native scale
    /// of the metric.
    #[prost(double, tag = "2")]
    pub value: f64,
    /// The state color for this threshold. Color is not allowed in a XyChart.
    #[prost(enumeration = "threshold::Color", tag = "3")]
    pub color: i32,
    /// The direction for the current threshold. Direction is not allowed in a
    /// XyChart.
    #[prost(enumeration = "threshold::Direction", tag = "4")]
    pub direction: i32,
    /// The target axis to use for plotting the threshold. Target axis is not
    /// allowed in a Scorecard.
    #[prost(enumeration = "threshold::TargetAxis", tag = "5")]
    pub target_axis: i32,
}
/// Nested message and enum types in `Threshold`.
pub mod threshold {
    /// The color suggests an interpretation to the viewer when actual values cross
    /// the threshold. Comments on each color provide UX guidance on how users can
    /// be expected to interpret a given state color.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Color {
        /// Color is unspecified. Not allowed in well-formed requests.
        Unspecified = 0,
        /// Crossing the threshold is "concerning" behavior.
        Yellow = 4,
        /// Crossing the threshold is "emergency" behavior.
        Red = 6,
    }
    impl Color {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "COLOR_UNSPECIFIED",
                Self::Yellow => "YELLOW",
                Self::Red => "RED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COLOR_UNSPECIFIED" => Some(Self::Unspecified),
                "YELLOW" => Some(Self::Yellow),
                "RED" => Some(Self::Red),
                _ => None,
            }
        }
    }
    /// Whether the threshold is considered crossed by an actual value above or
    /// below its threshold value.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Direction {
        /// Not allowed in well-formed requests.
        Unspecified = 0,
        /// The threshold will be considered crossed if the actual value is above
        /// the threshold value.
        Above = 1,
        /// The threshold will be considered crossed if the actual value is below
        /// the threshold value.
        Below = 2,
    }
    impl Direction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DIRECTION_UNSPECIFIED",
                Self::Above => "ABOVE",
                Self::Below => "BELOW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
                "ABOVE" => Some(Self::Above),
                "BELOW" => Some(Self::Below),
                _ => None,
            }
        }
    }
    /// An axis identifier.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetAxis {
        /// The target axis was not specified. Defaults to Y1.
        Unspecified = 0,
        /// The y_axis (the right axis of chart).
        Y1 = 1,
        /// The y2_axis (the left axis of chart).
        Y2 = 2,
    }
    impl TargetAxis {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TARGET_AXIS_UNSPECIFIED",
                Self::Y1 => "Y1",
                Self::Y2 => "Y2",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TARGET_AXIS_UNSPECIFIED" => Some(Self::Unspecified),
                "Y1" => Some(Self::Y1),
                "Y2" => Some(Self::Y2),
                _ => None,
            }
        }
    }
}
/// Defines the possible types of spark chart supported by the `Scorecard`.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SparkChartType {
    /// Not allowed in well-formed requests.
    Unspecified = 0,
    /// The sparkline will be rendered as a small line chart.
    SparkLine = 1,
    /// The sparkbar will be rendered as a small bar chart.
    SparkBar = 2,
}
impl SparkChartType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SPARK_CHART_TYPE_UNSPECIFIED",
            Self::SparkLine => "SPARK_LINE",
            Self::SparkBar => "SPARK_BAR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SPARK_CHART_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SPARK_LINE" => Some(Self::SparkLine),
            "SPARK_BAR" => Some(Self::SparkBar),
            _ => None,
        }
    }
}
/// A widget that displays timeseries data as a pie or a donut.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PieChart {
    /// Required. The queries for the chart's data.
    #[prost(message, repeated, tag = "1")]
    pub data_sets: ::prost::alloc::vec::Vec<pie_chart::PieChartDataSet>,
    /// Required. Indicates the visualization type for the PieChart.
    #[prost(enumeration = "pie_chart::PieChartType", tag = "2")]
    pub chart_type: i32,
    /// Optional. Indicates whether or not the pie chart should show slices' labels
    #[prost(bool, tag = "4")]
    pub show_labels: bool,
}
/// Nested message and enum types in `PieChart`.
pub mod pie_chart {
    /// Groups a time series query definition.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PieChartDataSet {
        /// Required. The query for the PieChart. See,
        /// `google.monitoring.dashboard.v1.TimeSeriesQuery`.
        #[prost(message, optional, tag = "1")]
        pub time_series_query: ::core::option::Option<super::TimeSeriesQuery>,
        /// Optional. A template for the name of the slice. This name will be
        /// displayed in the legend and the tooltip of the pie chart. It replaces the
        /// auto-generated names for the slices. For example, if the template is set
        /// to
        /// `${resource.labels.zone}`, the zone's value will be used for the name
        /// instead of the default name.
        #[prost(string, tag = "2")]
        pub slice_name_template: ::prost::alloc::string::String,
        /// Optional. The lower bound on data point frequency for this data set,
        /// implemented by specifying the minimum alignment period to use in a time
        /// series query. For example, if the data is published once every 10
        /// minutes, the `min_alignment_period` should be at least 10 minutes. It
        /// would not make sense to fetch and align data at one minute intervals.
        #[prost(message, optional, tag = "3")]
        pub min_alignment_period: ::core::option::Option<::prost_types::Duration>,
    }
    /// Types for the pie chart.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PieChartType {
        /// The zero value. No type specified. Do not use.
        Unspecified = 0,
        /// A Pie type PieChart.
        Pie = 1,
        /// Similar to PIE, but the DONUT type PieChart has a hole in the middle.
        Donut = 2,
    }
    impl PieChartType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PIE_CHART_TYPE_UNSPECIFIED",
                Self::Pie => "PIE",
                Self::Donut => "DONUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PIE_CHART_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PIE" => Some(Self::Pie),
                "DONUT" => Some(Self::Donut),
                _ => None,
            }
        }
    }
}
/// A widget showing the latest value of a metric, and how this value relates to
/// one or more thresholds.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Scorecard {
    /// Required. Fields for querying time series data from the
    /// Stackdriver metrics API.
    #[prost(message, optional, tag = "1")]
    pub time_series_query: ::core::option::Option<TimeSeriesQuery>,
    /// The thresholds used to determine the state of the scorecard given the
    /// time series' current value. For an actual value x, the scorecard is in a
    /// danger state if x is less than or equal to a danger threshold that triggers
    /// below, or greater than or equal to a danger threshold that triggers above.
    /// Similarly, if x is above/below a warning threshold that triggers
    /// above/below, then the scorecard is in a warning state - unless x also puts
    /// it in a danger state. (Danger trumps warning.)
    ///
    /// As an example, consider a scorecard with the following four thresholds:
    ///
    /// ```
    /// {
    ///    value: 90,
    ///    category: 'DANGER',
    ///    trigger: 'ABOVE',
    /// },
    /// {
    ///    value: 70,
    ///    category: 'WARNING',
    ///    trigger: 'ABOVE',
    /// },
    /// {
    ///    value: 10,
    ///    category: 'DANGER',
    ///    trigger: 'BELOW',
    /// },
    /// {
    ///    value: 20,
    ///    category: 'WARNING',
    ///    trigger: 'BELOW',
    /// }
    /// ```
    ///
    /// Then: values less than or equal to 10 would put the scorecard in a DANGER
    /// state, values greater than 10 but less than or equal to 20 a WARNING state,
    /// values strictly between 20 and 70 an OK state, values greater than or equal
    /// to 70 but less than 90 a WARNING state, and values greater than or equal to
    /// 90 a DANGER state.
    #[prost(message, repeated, tag = "6")]
    pub thresholds: ::prost::alloc::vec::Vec<Threshold>,
    /// Defines the optional additional chart shown on the scorecard. If
    /// neither is included - then a default scorecard is shown.
    #[prost(oneof = "scorecard::DataView", tags = "4, 5, 7")]
    pub data_view: ::core::option::Option<scorecard::DataView>,
}
/// Nested message and enum types in `Scorecard`.
pub mod scorecard {
    /// A gauge chart shows where the current value sits within a pre-defined
    /// range. The upper and lower bounds should define the possible range of
    /// values for the scorecard's query (inclusive).
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct GaugeView {
        /// The lower bound for this gauge chart. The value of the chart should
        /// always be greater than or equal to this.
        #[prost(double, tag = "1")]
        pub lower_bound: f64,
        /// The upper bound for this gauge chart. The value of the chart should
        /// always be less than or equal to this.
        #[prost(double, tag = "2")]
        pub upper_bound: f64,
    }
    /// A sparkChart is a small chart suitable for inclusion in a table-cell or
    /// inline in text. This message contains the configuration for a sparkChart
    /// to show up on a Scorecard, showing recent trends of the scorecard's
    /// timeseries.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SparkChartView {
        /// Required. The type of sparkchart to show in this chartView.
        #[prost(enumeration = "super::SparkChartType", tag = "1")]
        pub spark_chart_type: i32,
        /// The lower bound on data point frequency in the chart implemented by
        /// specifying the minimum alignment period to use in a time series query.
        /// For example, if the data is published once every 10 minutes it would not
        /// make sense to fetch and align data at one minute intervals. This field is
        /// optional and exists only as a hint.
        #[prost(message, optional, tag = "2")]
        pub min_alignment_period: ::core::option::Option<::prost_types::Duration>,
    }
    /// Defines the optional additional chart shown on the scorecard. If
    /// neither is included - then a default scorecard is shown.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum DataView {
        /// Will cause the scorecard to show a gauge chart.
        #[prost(message, tag = "4")]
        GaugeView(GaugeView),
        /// Will cause the scorecard to show a spark chart.
        #[prost(message, tag = "5")]
        SparkChartView(SparkChartView),
        /// Will cause the `Scorecard` to show only the value, with no indicator to
        /// its value relative to its thresholds.
        #[prost(message, tag = "7")]
        BlankView(()),
    }
}
/// A widget that defines a new section header. Sections populate a table of
/// contents and allow easier navigation of long-form content.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SectionHeader {
    /// The subtitle of the section
    #[prost(string, tag = "1")]
    pub subtitle: ::prost::alloc::string::String,
    /// Whether to insert a divider below the section in the table of contents
    #[prost(bool, tag = "2")]
    pub divider_below: bool,
}
/// A widget that groups the other widgets by using a dropdown menu. All widgets
/// that are within the area spanned by the grouping widget are considered
/// member widgets.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SingleViewGroup {}
/// Table display options that can be reused.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableDisplayOptions {
    /// Optional. This field is unused and has been replaced by
    /// TimeSeriesTable.column_settings
    #[deprecated]
    #[prost(string, repeated, tag = "1")]
    pub shown_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A table that displays time series data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeriesTable {
    /// Required. The data displayed in this table.
    #[prost(message, repeated, tag = "1")]
    pub data_sets: ::prost::alloc::vec::Vec<time_series_table::TableDataSet>,
    /// Optional. Store rendering strategy
    #[prost(enumeration = "time_series_table::MetricVisualization", tag = "2")]
    pub metric_visualization: i32,
    /// Optional. The list of the persistent column settings for the table.
    #[prost(message, repeated, tag = "4")]
    pub column_settings: ::prost::alloc::vec::Vec<time_series_table::ColumnSettings>,
}
/// Nested message and enum types in `TimeSeriesTable`.
pub mod time_series_table {
    /// Groups a time series query definition with table options.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TableDataSet {
        /// Required. Fields for querying time series data from the
        /// Stackdriver metrics API.
        #[prost(message, optional, tag = "1")]
        pub time_series_query: ::core::option::Option<super::TimeSeriesQuery>,
        /// Optional. A template string for naming `TimeSeries` in the resulting data
        /// set. This should be a string with interpolations of the form
        /// `${label_name}`, which will resolve to the label's value i.e.
        /// "${resource.labels.project_id}."
        #[prost(string, tag = "2")]
        pub table_template: ::prost::alloc::string::String,
        /// Optional. The lower bound on data point frequency for this data set,
        /// implemented by specifying the minimum alignment period to use in a time
        /// series query For example, if the data is published once every 10 minutes,
        /// the `min_alignment_period` should be at least 10 minutes. It would not
        /// make sense to fetch and align data at one minute intervals.
        #[prost(message, optional, tag = "3")]
        pub min_alignment_period: ::core::option::Option<::prost_types::Duration>,
        /// Optional. Table display options for configuring how the table is
        /// rendered.
        #[prost(message, optional, tag = "4")]
        pub table_display_options: ::core::option::Option<super::TableDisplayOptions>,
    }
    /// The persistent settings for a table's columns.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ColumnSettings {
        /// Required. The id of the column.
        #[prost(string, tag = "1")]
        pub column: ::prost::alloc::string::String,
        /// Required. Whether the column should be visible on page load.
        #[prost(bool, tag = "2")]
        pub visible: bool,
    }
    /// Enum for metric metric_visualization
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MetricVisualization {
        /// Unspecified state
        Unspecified = 0,
        /// Default text rendering
        Number = 1,
        /// Horizontal bar rendering
        Bar = 2,
    }
    impl MetricVisualization {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "METRIC_VISUALIZATION_UNSPECIFIED",
                Self::Number => "NUMBER",
                Self::Bar => "BAR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "METRIC_VISUALIZATION_UNSPECIFIED" => Some(Self::Unspecified),
                "NUMBER" => Some(Self::Number),
                "BAR" => Some(Self::Bar),
                _ => None,
            }
        }
    }
}
/// A widget that displays textual content.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Text {
    /// The text content to be displayed.
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
    /// How the text content is formatted.
    #[prost(enumeration = "text::Format", tag = "2")]
    pub format: i32,
    /// How the text is styled
    #[prost(message, optional, tag = "3")]
    pub style: ::core::option::Option<text::TextStyle>,
}
/// Nested message and enum types in `Text`.
pub mod text {
    /// Properties that determine how the title and content are styled
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextStyle {
        /// The background color as a hex string. "#RRGGBB" or "#RGB"
        #[prost(string, tag = "1")]
        pub background_color: ::prost::alloc::string::String,
        /// The text color as a hex string. "#RRGGBB" or "#RGB"
        #[prost(string, tag = "2")]
        pub text_color: ::prost::alloc::string::String,
        /// The horizontal alignment of both the title and content
        #[prost(enumeration = "text_style::HorizontalAlignment", tag = "3")]
        pub horizontal_alignment: i32,
        /// The vertical alignment of both the title and content
        #[prost(enumeration = "text_style::VerticalAlignment", tag = "4")]
        pub vertical_alignment: i32,
        /// The amount of padding around the widget
        #[prost(enumeration = "text_style::PaddingSize", tag = "5")]
        pub padding: i32,
        /// Font sizes for both the title and content. The title will still be larger
        /// relative to the content.
        #[prost(enumeration = "text_style::FontSize", tag = "6")]
        pub font_size: i32,
        /// The pointer location for this widget (also sometimes called a "tail")
        #[prost(enumeration = "text_style::PointerLocation", tag = "7")]
        pub pointer_location: i32,
    }
    /// Nested message and enum types in `TextStyle`.
    pub mod text_style {
        /// The horizontal alignment of both the title and content on a text widget
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum HorizontalAlignment {
            /// No horizontal alignment specified, will default to H_LEFT
            Unspecified = 0,
            /// Left-align
            HLeft = 1,
            /// Center-align
            HCenter = 2,
            /// Right-align
            HRight = 3,
        }
        impl HorizontalAlignment {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "HORIZONTAL_ALIGNMENT_UNSPECIFIED",
                    Self::HLeft => "H_LEFT",
                    Self::HCenter => "H_CENTER",
                    Self::HRight => "H_RIGHT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "HORIZONTAL_ALIGNMENT_UNSPECIFIED" => Some(Self::Unspecified),
                    "H_LEFT" => Some(Self::HLeft),
                    "H_CENTER" => Some(Self::HCenter),
                    "H_RIGHT" => Some(Self::HRight),
                    _ => None,
                }
            }
        }
        /// The vertical alignment of both the title and content on a text widget
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum VerticalAlignment {
            /// No vertical alignment specified, will default to V_TOP
            Unspecified = 0,
            /// Top-align
            VTop = 1,
            /// Center-align
            VCenter = 2,
            /// Bottom-align
            VBottom = 3,
        }
        impl VerticalAlignment {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "VERTICAL_ALIGNMENT_UNSPECIFIED",
                    Self::VTop => "V_TOP",
                    Self::VCenter => "V_CENTER",
                    Self::VBottom => "V_BOTTOM",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "VERTICAL_ALIGNMENT_UNSPECIFIED" => Some(Self::Unspecified),
                    "V_TOP" => Some(Self::VTop),
                    "V_CENTER" => Some(Self::VCenter),
                    "V_BOTTOM" => Some(Self::VBottom),
                    _ => None,
                }
            }
        }
        /// Specifies padding size around a text widget
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PaddingSize {
            /// No padding size specified, will default to P_EXTRA_SMALL
            Unspecified = 0,
            /// Extra small padding
            PExtraSmall = 1,
            /// Small padding
            PSmall = 2,
            /// Medium padding
            PMedium = 3,
            /// Large padding
            PLarge = 4,
            /// Extra large padding
            PExtraLarge = 5,
        }
        impl PaddingSize {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "PADDING_SIZE_UNSPECIFIED",
                    Self::PExtraSmall => "P_EXTRA_SMALL",
                    Self::PSmall => "P_SMALL",
                    Self::PMedium => "P_MEDIUM",
                    Self::PLarge => "P_LARGE",
                    Self::PExtraLarge => "P_EXTRA_LARGE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PADDING_SIZE_UNSPECIFIED" => Some(Self::Unspecified),
                    "P_EXTRA_SMALL" => Some(Self::PExtraSmall),
                    "P_SMALL" => Some(Self::PSmall),
                    "P_MEDIUM" => Some(Self::PMedium),
                    "P_LARGE" => Some(Self::PLarge),
                    "P_EXTRA_LARGE" => Some(Self::PExtraLarge),
                    _ => None,
                }
            }
        }
        /// Specifies a font size for the title and content of a text widget
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum FontSize {
            /// No font size specified, will default to FS_LARGE
            Unspecified = 0,
            /// Extra small font size
            FsExtraSmall = 1,
            /// Small font size
            FsSmall = 2,
            /// Medium font size
            FsMedium = 3,
            /// Large font size
            FsLarge = 4,
            /// Extra large font size
            FsExtraLarge = 5,
        }
        impl FontSize {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "FONT_SIZE_UNSPECIFIED",
                    Self::FsExtraSmall => "FS_EXTRA_SMALL",
                    Self::FsSmall => "FS_SMALL",
                    Self::FsMedium => "FS_MEDIUM",
                    Self::FsLarge => "FS_LARGE",
                    Self::FsExtraLarge => "FS_EXTRA_LARGE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FONT_SIZE_UNSPECIFIED" => Some(Self::Unspecified),
                    "FS_EXTRA_SMALL" => Some(Self::FsExtraSmall),
                    "FS_SMALL" => Some(Self::FsSmall),
                    "FS_MEDIUM" => Some(Self::FsMedium),
                    "FS_LARGE" => Some(Self::FsLarge),
                    "FS_EXTRA_LARGE" => Some(Self::FsExtraLarge),
                    _ => None,
                }
            }
        }
        /// Specifies where a visual pointer is placed on a text widget (also
        /// sometimes called a "tail")
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PointerLocation {
            /// No visual pointer
            Unspecified = 0,
            /// Placed in the middle of the top of the widget
            PlTop = 1,
            /// Placed in the middle of the right side of the widget
            PlRight = 2,
            /// Placed in the middle of the bottom of the widget
            PlBottom = 3,
            /// Placed in the middle of the left side of the widget
            PlLeft = 4,
            /// Placed on the left side of the top of the widget
            PlTopLeft = 5,
            /// Placed on the right side of the top of the widget
            PlTopRight = 6,
            /// Placed on the top of the right side of the widget
            PlRightTop = 7,
            /// Placed on the bottom of the right side of the widget
            PlRightBottom = 8,
            /// Placed on the right side of the bottom of the widget
            PlBottomRight = 9,
            /// Placed on the left side of the bottom of the widget
            PlBottomLeft = 10,
            /// Placed on the bottom of the left side of the widget
            PlLeftBottom = 11,
            /// Placed on the top of the left side of the widget
            PlLeftTop = 12,
        }
        impl PointerLocation {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "POINTER_LOCATION_UNSPECIFIED",
                    Self::PlTop => "PL_TOP",
                    Self::PlRight => "PL_RIGHT",
                    Self::PlBottom => "PL_BOTTOM",
                    Self::PlLeft => "PL_LEFT",
                    Self::PlTopLeft => "PL_TOP_LEFT",
                    Self::PlTopRight => "PL_TOP_RIGHT",
                    Self::PlRightTop => "PL_RIGHT_TOP",
                    Self::PlRightBottom => "PL_RIGHT_BOTTOM",
                    Self::PlBottomRight => "PL_BOTTOM_RIGHT",
                    Self::PlBottomLeft => "PL_BOTTOM_LEFT",
                    Self::PlLeftBottom => "PL_LEFT_BOTTOM",
                    Self::PlLeftTop => "PL_LEFT_TOP",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "POINTER_LOCATION_UNSPECIFIED" => Some(Self::Unspecified),
                    "PL_TOP" => Some(Self::PlTop),
                    "PL_RIGHT" => Some(Self::PlRight),
                    "PL_BOTTOM" => Some(Self::PlBottom),
                    "PL_LEFT" => Some(Self::PlLeft),
                    "PL_TOP_LEFT" => Some(Self::PlTopLeft),
                    "PL_TOP_RIGHT" => Some(Self::PlTopRight),
                    "PL_RIGHT_TOP" => Some(Self::PlRightTop),
                    "PL_RIGHT_BOTTOM" => Some(Self::PlRightBottom),
                    "PL_BOTTOM_RIGHT" => Some(Self::PlBottomRight),
                    "PL_BOTTOM_LEFT" => Some(Self::PlBottomLeft),
                    "PL_LEFT_BOTTOM" => Some(Self::PlLeftBottom),
                    "PL_LEFT_TOP" => Some(Self::PlLeftTop),
                    _ => None,
                }
            }
        }
    }
    /// The format type of the text content.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Format {
        /// Format is unspecified. Defaults to MARKDOWN.
        Unspecified = 0,
        /// The text contains Markdown formatting.
        Markdown = 1,
        /// The text contains no special formatting.
        Raw = 2,
    }
    impl Format {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FORMAT_UNSPECIFIED",
                Self::Markdown => "MARKDOWN",
                Self::Raw => "RAW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "MARKDOWN" => Some(Self::Markdown),
                "RAW" => Some(Self::Raw),
                _ => None,
            }
        }
    }
}
/// A chart that displays data on a 2D (X and Y axes) plane.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct XyChart {
    /// Required. The data displayed in this chart.
    #[prost(message, repeated, tag = "1")]
    pub data_sets: ::prost::alloc::vec::Vec<xy_chart::DataSet>,
    /// The duration used to display a comparison chart. A comparison chart
    /// simultaneously shows values from two similar-length time periods
    /// (e.g., week-over-week metrics).
    /// The duration must be positive, and it can only be applied to charts with
    /// data sets of LINE plot type.
    #[prost(message, optional, tag = "4")]
    pub timeshift_duration: ::core::option::Option<::prost_types::Duration>,
    /// Threshold lines drawn horizontally across the chart.
    #[prost(message, repeated, tag = "5")]
    pub thresholds: ::prost::alloc::vec::Vec<Threshold>,
    /// The properties applied to the x-axis.
    #[prost(message, optional, tag = "6")]
    pub x_axis: ::core::option::Option<xy_chart::Axis>,
    /// The properties applied to the y-axis.
    #[prost(message, optional, tag = "7")]
    pub y_axis: ::core::option::Option<xy_chart::Axis>,
    /// The properties applied to the y2-axis.
    #[prost(message, optional, tag = "9")]
    pub y2_axis: ::core::option::Option<xy_chart::Axis>,
    /// Display options for the chart.
    #[prost(message, optional, tag = "8")]
    pub chart_options: ::core::option::Option<ChartOptions>,
}
/// Nested message and enum types in `XyChart`.
pub mod xy_chart {
    /// Groups a time series query definition with charting options.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DataSet {
        /// Required. Fields for querying time series data from the
        /// Stackdriver metrics API.
        #[prost(message, optional, tag = "1")]
        pub time_series_query: ::core::option::Option<super::TimeSeriesQuery>,
        /// How this data should be plotted on the chart.
        #[prost(enumeration = "data_set::PlotType", tag = "2")]
        pub plot_type: i32,
        /// A template string for naming `TimeSeries` in the resulting data set.
        /// This should be a string with interpolations of the form `${label_name}`,
        /// which will resolve to the label's value.
        #[prost(string, tag = "3")]
        pub legend_template: ::prost::alloc::string::String,
        /// Optional. The lower bound on data point frequency for this data set,
        /// implemented by specifying the minimum alignment period to use in a time
        /// series query For example, if the data is published once every 10 minutes,
        /// the `min_alignment_period` should be at least 10 minutes. It would not
        /// make sense to fetch and align data at one minute intervals.
        #[prost(message, optional, tag = "4")]
        pub min_alignment_period: ::core::option::Option<::prost_types::Duration>,
        /// Optional. The target axis to use for plotting the metric.
        #[prost(enumeration = "data_set::TargetAxis", tag = "5")]
        pub target_axis: i32,
    }
    /// Nested message and enum types in `DataSet`.
    pub mod data_set {
        /// The types of plotting strategies for data sets.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PlotType {
            /// Plot type is unspecified. The view will default to `LINE`.
            Unspecified = 0,
            /// The data is plotted as a set of lines (one line per series).
            Line = 1,
            /// The data is plotted as a set of filled areas (one area per series),
            /// with the areas stacked vertically (the base of each area is the top of
            /// its predecessor, and the base of the first area is the x-axis). Since
            /// the areas do not overlap, each is filled with a different opaque color.
            StackedArea = 2,
            /// The data is plotted as a set of rectangular boxes (one box per series),
            /// with the boxes stacked vertically (the base of each box is the top of
            /// its predecessor, and the base of the first box is the x-axis). Since
            /// the boxes do not overlap, each is filled with a different opaque color.
            StackedBar = 3,
            /// The data is plotted as a heatmap. The series being plotted must have a
            /// `DISTRIBUTION` value type. The value of each bucket in the distribution
            /// is displayed as a color. This type is not currently available in the
            /// Stackdriver Monitoring application.
            Heatmap = 4,
        }
        impl PlotType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "PLOT_TYPE_UNSPECIFIED",
                    Self::Line => "LINE",
                    Self::StackedArea => "STACKED_AREA",
                    Self::StackedBar => "STACKED_BAR",
                    Self::Heatmap => "HEATMAP",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PLOT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "LINE" => Some(Self::Line),
                    "STACKED_AREA" => Some(Self::StackedArea),
                    "STACKED_BAR" => Some(Self::StackedBar),
                    "HEATMAP" => Some(Self::Heatmap),
                    _ => None,
                }
            }
        }
        /// An axis identifier.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum TargetAxis {
            /// The target axis was not specified. Defaults to Y1.
            Unspecified = 0,
            /// The y_axis (the right axis of chart).
            Y1 = 1,
            /// The y2_axis (the left axis of chart).
            Y2 = 2,
        }
        impl TargetAxis {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TARGET_AXIS_UNSPECIFIED",
                    Self::Y1 => "Y1",
                    Self::Y2 => "Y2",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TARGET_AXIS_UNSPECIFIED" => Some(Self::Unspecified),
                    "Y1" => Some(Self::Y1),
                    "Y2" => Some(Self::Y2),
                    _ => None,
                }
            }
        }
    }
    /// A chart axis.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Axis {
        /// The label of the axis.
        #[prost(string, tag = "1")]
        pub label: ::prost::alloc::string::String,
        /// The axis scale. By default, a linear scale is used.
        #[prost(enumeration = "axis::Scale", tag = "2")]
        pub scale: i32,
    }
    /// Nested message and enum types in `Axis`.
    pub mod axis {
        /// Types of scales used in axes.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Scale {
            /// Scale is unspecified. The view will default to `LINEAR`.
            Unspecified = 0,
            /// Linear scale.
            Linear = 1,
            /// Logarithmic scale (base 10).
            Log10 = 2,
        }
        impl Scale {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SCALE_UNSPECIFIED",
                    Self::Linear => "LINEAR",
                    Self::Log10 => "LOG10",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SCALE_UNSPECIFIED" => Some(Self::Unspecified),
                    "LINEAR" => Some(Self::Linear),
                    "LOG10" => Some(Self::Log10),
                    _ => None,
                }
            }
        }
    }
}
/// Options to control visual rendering of a chart.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChartOptions {
    /// The chart mode.
    #[prost(enumeration = "chart_options::Mode", tag = "1")]
    pub mode: i32,
}
/// Nested message and enum types in `ChartOptions`.
pub mod chart_options {
    /// Chart mode options.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        /// Mode is unspecified. The view will default to `COLOR`.
        Unspecified = 0,
        /// The chart distinguishes data series using different color. Line
        /// colors may get reused when there are many lines in the chart.
        Color = 1,
        /// The chart uses the Stackdriver x-ray mode, in which each
        /// data set is plotted using the same semi-transparent color.
        XRay = 2,
        /// The chart displays statistics such as average, median, 95th percentile,
        /// and more.
        Stats = 3,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODE_UNSPECIFIED",
                Self::Color => "COLOR",
                Self::XRay => "X_RAY",
                Self::Stats => "STATS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "COLOR" => Some(Self::Color),
                "X_RAY" => Some(Self::XRay),
                "STATS" => Some(Self::Stats),
                _ => None,
            }
        }
    }
}
/// Widget contains a single dashboard component and configuration of how to
/// present the component in the dashboard.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Widget {
    /// Optional. The title of the widget.
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// Optional. The widget id. Ids may be made up of alphanumerics, dashes and
    /// underscores. Widget ids are optional.
    #[prost(string, tag = "17")]
    pub id: ::prost::alloc::string::String,
    /// Content defines the component used to populate the widget.
    #[prost(
        oneof = "widget::Content",
        tags = "2, 3, 4, 5, 7, 8, 9, 10, 12, 14, 19, 21, 22"
    )]
    pub content: ::core::option::Option<widget::Content>,
}
/// Nested message and enum types in `Widget`.
pub mod widget {
    /// Content defines the component used to populate the widget.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        /// A chart of time series data.
        #[prost(message, tag = "2")]
        XyChart(super::XyChart),
        /// A scorecard summarizing time series data.
        #[prost(message, tag = "3")]
        Scorecard(super::Scorecard),
        /// A raw string or markdown displaying textual content.
        #[prost(message, tag = "4")]
        Text(super::Text),
        /// A blank space.
        #[prost(message, tag = "5")]
        Blank(()),
        /// A chart of alert policy data.
        #[prost(message, tag = "7")]
        AlertChart(super::AlertChart),
        /// A widget that displays time series data in a tabular format.
        #[prost(message, tag = "8")]
        TimeSeriesTable(super::TimeSeriesTable),
        /// A widget that groups the other widgets. All widgets that are within
        /// the area spanned by the grouping widget are considered member widgets.
        #[prost(message, tag = "9")]
        CollapsibleGroup(super::CollapsibleGroup),
        /// A widget that shows a stream of logs.
        #[prost(message, tag = "10")]
        LogsPanel(super::LogsPanel),
        /// A widget that shows list of incidents.
        #[prost(message, tag = "12")]
        IncidentList(super::IncidentList),
        /// A widget that displays timeseries data as a pie chart.
        #[prost(message, tag = "14")]
        PieChart(super::PieChart),
        /// A widget that displays a list of error groups.
        #[prost(message, tag = "19")]
        ErrorReportingPanel(super::ErrorReportingPanel),
        /// A widget that defines a section header for easier navigation of the
        /// dashboard.
        #[prost(message, tag = "21")]
        SectionHeader(super::SectionHeader),
        /// A widget that groups the other widgets by using a dropdown menu.
        #[prost(message, tag = "22")]
        SingleViewGroup(super::SingleViewGroup),
    }
}
/// A basic layout divides the available space into vertical columns of equal
/// width and arranges a list of widgets using a row-first strategy.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GridLayout {
    /// The number of columns into which the view's width is divided. If omitted
    /// or set to zero, a system default will be used while rendering.
    #[prost(int64, tag = "1")]
    pub columns: i64,
    /// The informational elements that are arranged into the columns row-first.
    #[prost(message, repeated, tag = "2")]
    pub widgets: ::prost::alloc::vec::Vec<Widget>,
}
/// A mosaic layout divides the available space into a grid of blocks, and
/// overlays the grid with tiles. Unlike `GridLayout`, tiles may span multiple
/// grid blocks and can be placed at arbitrary locations in the grid.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MosaicLayout {
    /// The number of columns in the mosaic grid. The number of columns must be
    /// between 1 and 12, inclusive.
    #[prost(int32, tag = "1")]
    pub columns: i32,
    /// The tiles to display.
    #[prost(message, repeated, tag = "3")]
    pub tiles: ::prost::alloc::vec::Vec<mosaic_layout::Tile>,
}
/// Nested message and enum types in `MosaicLayout`.
pub mod mosaic_layout {
    /// A single tile in the mosaic. The placement and size of the tile are
    /// configurable.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Tile {
        /// The zero-indexed position of the tile in grid blocks relative to the
        /// left edge of the grid. Tiles must be contained within the specified
        /// number of columns. `x_pos` cannot be negative.
        #[prost(int32, tag = "1")]
        pub x_pos: i32,
        /// The zero-indexed position of the tile in grid blocks relative to the
        /// top edge of the grid. `y_pos` cannot be negative.
        #[prost(int32, tag = "2")]
        pub y_pos: i32,
        /// The width of the tile, measured in grid blocks. Tiles must have a
        /// minimum width of 1.
        #[prost(int32, tag = "3")]
        pub width: i32,
        /// The height of the tile, measured in grid blocks. Tiles must have a
        /// minimum height of 1.
        #[prost(int32, tag = "4")]
        pub height: i32,
        /// The informational widget contained in the tile. For example an `XyChart`.
        #[prost(message, optional, tag = "5")]
        pub widget: ::core::option::Option<super::Widget>,
    }
}
/// A simplified layout that divides the available space into rows
/// and arranges a set of widgets horizontally in each row.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RowLayout {
    /// The rows of content to display.
    #[prost(message, repeated, tag = "1")]
    pub rows: ::prost::alloc::vec::Vec<row_layout::Row>,
}
/// Nested message and enum types in `RowLayout`.
pub mod row_layout {
    /// Defines the layout properties and content for a row.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Row {
        /// The relative weight of this row. The row weight is used to adjust the
        /// height of rows on the screen (relative to peers). Greater the weight,
        /// greater the height of the row on the screen. If omitted, a value
        /// of 1 is used while rendering.
        #[prost(int64, tag = "1")]
        pub weight: i64,
        /// The display widgets arranged horizontally in this row.
        #[prost(message, repeated, tag = "2")]
        pub widgets: ::prost::alloc::vec::Vec<super::Widget>,
    }
}
/// A simplified layout that divides the available space into vertical columns
/// and arranges a set of widgets vertically in each column.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnLayout {
    /// The columns of content to display.
    #[prost(message, repeated, tag = "1")]
    pub columns: ::prost::alloc::vec::Vec<column_layout::Column>,
}
/// Nested message and enum types in `ColumnLayout`.
pub mod column_layout {
    /// Defines the layout properties and content for a column.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Column {
        /// The relative weight of this column. The column weight is used to adjust
        /// the width of columns on the screen (relative to peers).
        /// Greater the weight, greater the width of the column on the screen.
        /// If omitted, a value of 1 is used while rendering.
        #[prost(int64, tag = "1")]
        pub weight: i64,
        /// The display widgets arranged vertically in this column.
        #[prost(message, repeated, tag = "2")]
        pub widgets: ::prost::alloc::vec::Vec<super::Widget>,
    }
}
/// A Google Stackdriver dashboard. Dashboards define the content and layout
/// of pages in the Stackdriver web application.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dashboard {
    /// Identifier. The resource name of the dashboard.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The mutable, human-readable name.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// `etag` is used for optimistic concurrency control as a way to help
    /// prevent simultaneous updates of a policy from overwriting each other.
    /// An `etag` is returned in the response to `GetDashboard`, and
    /// users are expected to put that etag in the request to `UpdateDashboard` to
    /// ensure that their change will be applied to the same version of the
    /// Dashboard configuration. The field should not be passed during
    /// dashboard creation.
    #[prost(string, tag = "4")]
    pub etag: ::prost::alloc::string::String,
    /// Filters to reduce the amount of data charted based on the filter criteria.
    #[prost(message, repeated, tag = "11")]
    pub dashboard_filters: ::prost::alloc::vec::Vec<DashboardFilter>,
    /// Labels applied to the dashboard
    #[prost(map = "string, string", tag = "12")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// A dashboard's root container element that defines the layout style.
    #[prost(oneof = "dashboard::Layout", tags = "5, 6, 8, 9")]
    pub layout: ::core::option::Option<dashboard::Layout>,
}
/// Nested message and enum types in `Dashboard`.
pub mod dashboard {
    /// A dashboard's root container element that defines the layout style.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Layout {
        /// Content is arranged with a basic layout that re-flows a simple list of
        /// informational elements like widgets or tiles.
        #[prost(message, tag = "5")]
        GridLayout(super::GridLayout),
        /// The content is arranged as a grid of tiles, with each content widget
        /// occupying one or more grid blocks.
        #[prost(message, tag = "6")]
        MosaicLayout(super::MosaicLayout),
        /// The content is divided into equally spaced rows and the widgets are
        /// arranged horizontally.
        #[prost(message, tag = "8")]
        RowLayout(super::RowLayout),
        /// The content is divided into equally spaced columns and the widgets are
        /// arranged vertically.
        #[prost(message, tag = "9")]
        ColumnLayout(super::ColumnLayout),
    }
}
/// The `CreateDashboard` request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDashboardRequest {
    /// Required. The project on which to execute the request. The format is:
    ///
    ///      projects/\[PROJECT_ID_OR_NUMBER\]
    ///
    /// The `\[PROJECT_ID_OR_NUMBER\]` must match the dashboard resource name.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The initial dashboard specification.
    #[prost(message, optional, tag = "2")]
    pub dashboard: ::core::option::Option<Dashboard>,
    /// If set, validate the request and preview the review, but do not actually
    /// save it.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// The `ListDashboards` request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDashboardsRequest {
    /// Required. The scope of the dashboards to list. The format is:
    ///
    ///      projects/\[PROJECT_ID_OR_NUMBER\]
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// A positive number that is the maximum number of results to return.
    /// If unspecified, a default of 1000 is used.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. If this field is not empty then it must contain the
    /// `nextPageToken` value returned by a previous call to this method.  Using
    /// this field causes the method to return additional results from the previous
    /// method call.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The `ListDashboards` request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDashboardsResponse {
    /// The list of requested dashboards.
    #[prost(message, repeated, tag = "1")]
    pub dashboards: ::prost::alloc::vec::Vec<Dashboard>,
    /// If there are more results than have been returned, then this field is set
    /// to a non-empty value.  To see the additional results,
    /// use that value as `page_token` in the next call to this method.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The `GetDashboard` request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDashboardRequest {
    /// Required. The resource name of the Dashboard. The format is one of:
    ///
    ///   -  `dashboards/\[DASHBOARD_ID\]` (for system dashboards)
    ///   -  `projects/\[PROJECT_ID_OR_NUMBER\]/dashboards/\[DASHBOARD_ID\]`
    ///        (for custom dashboards).
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The `DeleteDashboard` request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDashboardRequest {
    /// Required. The resource name of the Dashboard. The format is:
    ///
    ///      projects/\[PROJECT_ID_OR_NUMBER\]/dashboards/\[DASHBOARD_ID\]
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The `UpdateDashboard` request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDashboardRequest {
    /// Required. The dashboard that will replace the existing dashboard.
    #[prost(message, optional, tag = "1")]
    pub dashboard: ::core::option::Option<Dashboard>,
    /// If set, validate the request and preview the review, but do not actually
    /// save it.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Generated client implementations.
pub mod dashboards_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Manages Stackdriver dashboards. A dashboard is an arrangement of data display
    /// widgets in a specific layout.
    #[derive(Debug, Clone)]
    pub struct DashboardsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DashboardsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DashboardsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DashboardsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DashboardsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a new custom dashboard. For examples on how you can use this API to
        /// create dashboards, see [Managing dashboards by
        /// API](https://cloud.google.com/monitoring/dashboards/api-dashboard). This
        /// method requires the `monitoring.dashboards.create` permission on the
        /// specified project. For more information about permissions, see [Cloud
        /// Identity and Access Management](https://cloud.google.com/iam).
        pub async fn create_dashboard(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDashboardRequest>,
        ) -> std::result::Result<tonic::Response<super::Dashboard>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.dashboard.v1.DashboardsService/CreateDashboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.monitoring.dashboard.v1.DashboardsService",
                        "CreateDashboard",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the existing dashboards.
        ///
        /// This method requires the `monitoring.dashboards.list` permission
        /// on the specified project. For more information, see
        /// [Cloud Identity and Access Management](https://cloud.google.com/iam).
        pub async fn list_dashboards(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDashboardsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDashboardsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.dashboard.v1.DashboardsService/ListDashboards",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.monitoring.dashboard.v1.DashboardsService",
                        "ListDashboards",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Fetches a specific dashboard.
        ///
        /// This method requires the `monitoring.dashboards.get` permission
        /// on the specified dashboard. For more information, see
        /// [Cloud Identity and Access Management](https://cloud.google.com/iam).
        pub async fn get_dashboard(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDashboardRequest>,
        ) -> std::result::Result<tonic::Response<super::Dashboard>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.dashboard.v1.DashboardsService/GetDashboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.monitoring.dashboard.v1.DashboardsService",
                        "GetDashboard",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an existing custom dashboard.
        ///
        /// This method requires the `monitoring.dashboards.delete` permission
        /// on the specified dashboard. For more information, see
        /// [Cloud Identity and Access Management](https://cloud.google.com/iam).
        pub async fn delete_dashboard(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDashboardRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.dashboard.v1.DashboardsService/DeleteDashboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.monitoring.dashboard.v1.DashboardsService",
                        "DeleteDashboard",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Replaces an existing custom dashboard with a new definition.
        ///
        /// This method requires the `monitoring.dashboards.update` permission
        /// on the specified dashboard. For more information, see
        /// [Cloud Identity and Access Management](https://cloud.google.com/iam).
        pub async fn update_dashboard(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDashboardRequest>,
        ) -> std::result::Result<tonic::Response<super::Dashboard>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.monitoring.dashboard.v1.DashboardsService/UpdateDashboard",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.monitoring.dashboard.v1.DashboardsService",
                        "UpdateDashboard",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
