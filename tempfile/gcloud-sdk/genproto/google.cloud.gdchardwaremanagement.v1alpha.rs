// This file is @generated by prost-build.
/// An order for GDC hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Order {
    /// Identifier. Name of this order.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Display name of this order.
    #[prost(string, tag = "13")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Time when this order was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when this order was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels associated with this order as key value pairs.
    /// For more information about labels, see [Create and manage
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels>).
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. State of this order. On order creation, state will be set to
    /// DRAFT.
    #[prost(enumeration = "order::State", tag = "5")]
    pub state: i32,
    /// Required. Customer contact information.
    #[prost(message, optional, tag = "6")]
    pub organization_contact: ::core::option::Option<OrganizationContact>,
    /// Optional. Customer specified workloads of interest targeted by this order.
    /// This must contain <= 20 elements and the length of each element must be <=
    /// 50 characters.
    #[prost(string, repeated, tag = "7")]
    pub target_workloads: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required. Information about the customer's motivation for this order. The
    /// length of this field must be <= 1000 characters.
    #[prost(string, tag = "8")]
    pub customer_motivation: ::prost::alloc::string::String,
    /// Required. Customer specified deadline by when this order should be
    /// fulfilled.
    #[prost(message, optional, tag = "9")]
    pub fulfillment_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. [Unicode CLDR](<http://cldr.unicode.org/>) region code where this
    /// order will be deployed. For a list of valid CLDR region codes, see the
    /// [Language Subtag
    /// Registry](<https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry>).
    #[prost(string, tag = "10")]
    pub region_code: ::prost::alloc::string::String,
    /// Output only. Link to the order form.
    #[prost(string, tag = "11")]
    pub order_form_uri: ::prost::alloc::string::String,
    /// Output only. Type of this Order.
    #[prost(enumeration = "order::Type", tag = "12")]
    pub r#type: i32,
    /// Output only. Time when the order was submitted. Is auto-populated to the
    /// current time when an order is submitted.
    #[prost(message, optional, tag = "14")]
    pub submit_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. The Google Cloud Billing ID to be charged for this order.
    #[prost(string, tag = "15")]
    pub billing_id: ::prost::alloc::string::String,
    /// Optional. Existing hardware to be removed as part of this order.
    /// Note: any hardware removed will be recycled unless otherwise agreed.
    #[prost(message, repeated, tag = "16")]
    pub existing_hardware: ::prost::alloc::vec::Vec<HardwareLocation>,
}
/// Nested message and enum types in `Order`.
pub mod order {
    /// Valid states of an order.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State of the order is unspecified.
        Unspecified = 0,
        /// Order is being drafted by the customer and has not been submitted yet.
        Draft = 1,
        /// Order has been submitted to Google.
        Submitted = 2,
        /// All information required from the customer for fulfillment of the order
        /// is complete.
        InfoComplete = 12,
        /// Order has been accepted by Google.
        Accepted = 3,
        /// Order needs more information from the customer.
        AdditionalInfoNeeded = 4,
        /// Google has initiated building hardware for the order.
        Building = 5,
        /// The hardware has been built and is being shipped.
        Shipping = 6,
        /// The hardware is being installed.
        Installing = 7,
        /// An error occurred in processing the order and customer intervention is
        /// required.
        Failed = 8,
        /// Order has been partially completed i.e., some hardware have been
        /// delivered and installed.
        PartiallyCompleted = 9,
        /// Order has been completed.
        Completed = 10,
        /// Order has been cancelled.
        Cancelled = 11,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Draft => "DRAFT",
                Self::Submitted => "SUBMITTED",
                Self::InfoComplete => "INFO_COMPLETE",
                Self::Accepted => "ACCEPTED",
                Self::AdditionalInfoNeeded => "ADDITIONAL_INFO_NEEDED",
                Self::Building => "BUILDING",
                Self::Shipping => "SHIPPING",
                Self::Installing => "INSTALLING",
                Self::Failed => "FAILED",
                Self::PartiallyCompleted => "PARTIALLY_COMPLETED",
                Self::Completed => "COMPLETED",
                Self::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "DRAFT" => Some(Self::Draft),
                "SUBMITTED" => Some(Self::Submitted),
                "INFO_COMPLETE" => Some(Self::InfoComplete),
                "ACCEPTED" => Some(Self::Accepted),
                "ADDITIONAL_INFO_NEEDED" => Some(Self::AdditionalInfoNeeded),
                "BUILDING" => Some(Self::Building),
                "SHIPPING" => Some(Self::Shipping),
                "INSTALLING" => Some(Self::Installing),
                "FAILED" => Some(Self::Failed),
                "PARTIALLY_COMPLETED" => Some(Self::PartiallyCompleted),
                "COMPLETED" => Some(Self::Completed),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
    /// Valid types of an Order.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Type of the order is unspecified.
        Unspecified = 0,
        /// Paid by the customer.
        Paid = 1,
        /// Proof of concept for the customer.
        Poc = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Paid => "PAID",
                Self::Poc => "POC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PAID" => Some(Self::Paid),
                "POC" => Some(Self::Poc),
                _ => None,
            }
        }
    }
}
/// A physical site where hardware will be installed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Site {
    /// Identifier. Name of the site.
    /// Format: `projects/{project}/locations/{location}/sites/{site}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Display name of this Site.
    #[prost(string, tag = "24")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. Description of this Site.
    #[prost(string, tag = "25")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Time when this site was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when this site was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels associated with this site as key value pairs.
    /// For more information about labels, see [Create and manage
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels>).
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Contact information for this site.
    #[prost(message, optional, tag = "5")]
    pub organization_contact: ::core::option::Option<OrganizationContact>,
    /// Optional. A URL to the Google Maps address location of the site.
    /// An example value is `<https://goo.gl/maps/xxxxxxxxx`.>
    #[prost(string, tag = "6")]
    pub google_maps_pin_uri: ::prost::alloc::string::String,
    /// Optional. The time periods when the site is accessible.
    /// If this field is empty, the site is accessible at all times.
    ///
    /// This field is used by Google to schedule the initial installation as well
    /// as any later hardware maintenance. You may update this at any time. For
    /// example, if the initial installation is requested during off-hours but
    /// maintenance should be performed during regular business hours, you should
    /// update the access times after initial installation is complete.
    #[prost(message, repeated, tag = "26")]
    pub access_times: ::prost::alloc::vec::Vec<TimePeriod>,
    /// Optional. Any additional notes for this Site. Please include information
    /// about:
    ///   - security or access restrictions
    ///   - any regulations affecting the technicians visiting the site
    ///   - any special process or approval required to move the equipment
    ///   - whether a representative will be available during site visits
    #[prost(string, tag = "27")]
    pub notes: ::prost::alloc::string::String,
    /// Optional. Customer defined identifier for this Site. This can be used to
    /// identify the site in the customer's own systems.
    #[prost(string, tag = "28")]
    pub customer_site_id: ::prost::alloc::string::String,
}
/// A group of hardware that is part of the same order, has the same SKU, and is
/// delivered to the same site.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HardwareGroup {
    /// Identifier. Name of this hardware group.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/hardwareGroups/{hardware_group}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time when this hardware group was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when this hardware group was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels associated with this hardware group as key value pairs.
    /// For more information about labels, see [Create and manage
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels>).
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Number of hardware in this HardwareGroup.
    #[prost(int32, tag = "5")]
    pub hardware_count: i32,
    /// Required. Configuration for hardware in this HardwareGroup.
    #[prost(message, optional, tag = "6")]
    pub config: ::core::option::Option<HardwareConfig>,
    /// Required. Name of the site where the hardware in this HardwareGroup will be
    /// delivered.
    /// Format: `projects/{project}/locations/{location}/sites/{site}`
    #[prost(string, tag = "7")]
    pub site: ::prost::alloc::string::String,
    /// Output only. Current state of this HardwareGroup.
    #[prost(enumeration = "hardware_group::State", tag = "8")]
    pub state: i32,
    /// Optional. Name of the zone that the hardware in this HardwareGroup belongs
    /// to. Format: `projects/{project}/locations/{location}/zones/{zone}`
    #[prost(string, tag = "9")]
    pub zone: ::prost::alloc::string::String,
    /// Optional. Requested installation date for the hardware in this
    /// HardwareGroup. Filled in by the customer.
    #[prost(message, optional, tag = "10")]
    pub requested_installation_date: ::core::option::Option<
        super::super::super::r#type::Date,
    >,
}
/// Nested message and enum types in `HardwareGroup`.
pub mod hardware_group {
    /// Valid states of a HardwareGroup.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State of the HardwareGroup is unspecified.
        Unspecified = 0,
        /// More information is required from the customer to make progress.
        AdditionalInfoNeeded = 1,
        /// Google has initiated building hardware for this HardwareGroup.
        Building = 2,
        /// The hardware has been built and is being shipped.
        Shipping = 3,
        /// The hardware is being installed.
        Installing = 4,
        /// Some hardware in the HardwareGroup have been installed.
        PartiallyInstalled = 5,
        /// All hardware in the HardwareGroup have been installed.
        Installed = 6,
        /// An error occurred and customer intervention is required.
        Failed = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::AdditionalInfoNeeded => "ADDITIONAL_INFO_NEEDED",
                Self::Building => "BUILDING",
                Self::Shipping => "SHIPPING",
                Self::Installing => "INSTALLING",
                Self::PartiallyInstalled => "PARTIALLY_INSTALLED",
                Self::Installed => "INSTALLED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ADDITIONAL_INFO_NEEDED" => Some(Self::AdditionalInfoNeeded),
                "BUILDING" => Some(Self::Building),
                "SHIPPING" => Some(Self::Shipping),
                "INSTALLING" => Some(Self::Installing),
                "PARTIALLY_INSTALLED" => Some(Self::PartiallyInstalled),
                "INSTALLED" => Some(Self::Installed),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// An instance of hardware installed at a site.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hardware {
    /// Identifier. Name of this hardware.
    /// Format: `projects/{project}/locations/{location}/hardware/{hardware}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Display name for this hardware.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Time when this hardware was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when this hardware was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels associated with this hardware as key value pairs.
    /// For more information about labels, see [Create and manage
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels>).
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Name of the order that this hardware belongs to.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "6")]
    pub order: ::prost::alloc::string::String,
    /// Output only. Name for the hardware group that this hardware belongs to.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/hardwareGroups/{hardware_group}`
    #[prost(string, tag = "7")]
    pub hardware_group: ::prost::alloc::string::String,
    /// Required. Name for the site that this hardware belongs to.
    /// Format: `projects/{project}/locations/{location}/sites/{site}`
    #[prost(string, tag = "8")]
    pub site: ::prost::alloc::string::String,
    /// Output only. Current state for this hardware.
    #[prost(enumeration = "hardware::State", tag = "9")]
    pub state: i32,
    /// Output only. Link to the Customer Intake Questionnaire (CIQ) sheet for this
    /// Hardware.
    #[prost(string, tag = "10")]
    pub ciq_uri: ::prost::alloc::string::String,
    /// Required. Configuration for this hardware.
    #[prost(message, optional, tag = "11")]
    pub config: ::core::option::Option<HardwareConfig>,
    /// Output only. Estimated installation date for this hardware.
    #[prost(message, optional, tag = "12")]
    pub estimated_installation_date: ::core::option::Option<
        super::super::super::r#type::Date,
    >,
    /// Optional. Physical properties of this hardware.
    #[prost(message, optional, tag = "13")]
    pub physical_info: ::core::option::Option<HardwarePhysicalInfo>,
    /// Optional. Information for installation of this hardware.
    #[prost(message, optional, tag = "14")]
    pub installation_info: ::core::option::Option<HardwareInstallationInfo>,
    /// Required. Name for the zone that this hardware belongs to.
    /// Format: `projects/{project}/locations/{location}/zones/{zone}`
    #[prost(string, tag = "15")]
    pub zone: ::prost::alloc::string::String,
    /// Optional. Requested installation date for this hardware. If not specified,
    /// this is auto-populated from the order's fulfillment_time upon submission or
    /// from the HardwareGroup's requested_installation_date upon order acceptance.
    #[prost(message, optional, tag = "16")]
    pub requested_installation_date: ::core::option::Option<
        super::super::super::r#type::Date,
    >,
    /// Output only. Actual installation date for this hardware. Filled in by
    /// Google.
    #[prost(message, optional, tag = "17")]
    pub actual_installation_date: ::core::option::Option<
        super::super::super::r#type::Date,
    >,
    /// Output only. Per machine asset information needed for turnup.
    #[prost(message, repeated, tag = "20")]
    pub machine_infos: ::prost::alloc::vec::Vec<hardware::MachineInfo>,
}
/// Nested message and enum types in `Hardware`.
pub mod hardware {
    /// Message to describe the MAC address of a machine.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MacAddress {
        /// Output only. Address string.
        #[prost(string, tag = "1")]
        pub address: ::prost::alloc::string::String,
        /// Output only. Address type for this MAC address.
        #[prost(enumeration = "mac_address::AddressType", tag = "2")]
        pub r#type: i32,
        /// Output only. Static IP address (if used) that is associated with the MAC
        /// address. Only applicable for VIRTUAL MAC address type.
        #[prost(string, tag = "3")]
        pub ipv4_address: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `MacAddress`.
    pub mod mac_address {
        /// Enum for the different types of MAC address.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum AddressType {
            /// Unspecified address type.
            Unspecified = 0,
            /// Address of a network interface card.
            Nic = 1,
            /// Address of a baseboard management controller.
            Bmc = 2,
            /// Address of a virtual interface.
            Virtual = 3,
        }
        impl AddressType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "ADDRESS_TYPE_UNSPECIFIED",
                    Self::Nic => "NIC",
                    Self::Bmc => "BMC",
                    Self::Virtual => "VIRTUAL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ADDRESS_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "NIC" => Some(Self::Nic),
                    "BMC" => Some(Self::Bmc),
                    "VIRTUAL" => Some(Self::Virtual),
                    _ => None,
                }
            }
        }
    }
    /// Information about individual disks on a machine.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DiskInfo {
        /// Output only. Disk manufacturer.
        #[prost(string, tag = "1")]
        pub manufacturer: ::prost::alloc::string::String,
        /// Output only. Disk slot number.
        #[prost(int32, tag = "2")]
        pub slot: i32,
        /// Output only. Disk serial number.
        #[prost(string, tag = "3")]
        pub serial_number: ::prost::alloc::string::String,
        /// Output only. Disk PSID.
        #[prost(string, tag = "4")]
        pub psid: ::prost::alloc::string::String,
        /// Output only. Disk part number.
        #[prost(string, tag = "5")]
        pub part_number: ::prost::alloc::string::String,
        /// Output only. Disk model number.
        #[prost(string, tag = "6")]
        pub model_number: ::prost::alloc::string::String,
    }
    /// Information about individual machines vendors will provide during turnup.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MachineInfo {
        /// Output only. Machine service tag.
        #[prost(string, tag = "1")]
        pub service_tag: ::prost::alloc::string::String,
        /// Output only. Each associated MAC address.
        #[prost(message, repeated, tag = "2")]
        pub mac_addresses: ::prost::alloc::vec::Vec<MacAddress>,
        /// Output only. Machine name.
        #[prost(string, tag = "3")]
        pub name: ::prost::alloc::string::String,
        /// Output only. Information for each disk installed.
        #[prost(message, repeated, tag = "4")]
        pub disk_infos: ::prost::alloc::vec::Vec<DiskInfo>,
    }
    /// Valid states for hardware.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State of the Hardware is unspecified.
        Unspecified = 0,
        /// More information is required from the customer to make progress.
        AdditionalInfoNeeded = 1,
        /// Google has initiated building hardware for this Hardware.
        Building = 2,
        /// The hardware has been built and is being shipped.
        Shipping = 3,
        /// The hardware is being installed.
        Installing = 4,
        /// The hardware has been installed.
        Installed = 5,
        /// An error occurred and customer intervention is required.
        Failed = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::AdditionalInfoNeeded => "ADDITIONAL_INFO_NEEDED",
                Self::Building => "BUILDING",
                Self::Shipping => "SHIPPING",
                Self::Installing => "INSTALLING",
                Self::Installed => "INSTALLED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ADDITIONAL_INFO_NEEDED" => Some(Self::AdditionalInfoNeeded),
                "BUILDING" => Some(Self::Building),
                "SHIPPING" => Some(Self::Shipping),
                "INSTALLING" => Some(Self::Installing),
                "INSTALLED" => Some(Self::Installed),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// A comment on an order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Comment {
    /// Identifier. Name of this comment.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/comments/{comment}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time when this comment was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels associated with this comment as key value pairs.
    /// For more information about labels, see [Create and manage
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels>).
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Username of the author of this comment. This is auto-populated
    /// from the credentials used during creation of the comment.
    #[prost(string, tag = "4")]
    pub author: ::prost::alloc::string::String,
    /// Required. Text of this comment. The length of text must be <= 1000
    /// characters.
    #[prost(string, tag = "5")]
    pub text: ::prost::alloc::string::String,
    /// Output only. Timestamp of the first time this comment was viewed by the
    /// customer. If the comment wasn't viewed then this timestamp will be unset.
    #[prost(message, optional, tag = "6")]
    pub customer_viewed_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The entity the author belongs to.
    #[prost(enumeration = "Entity", tag = "7")]
    pub author_entity: i32,
}
/// A log entry of a change made to an order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeLogEntry {
    /// Identifier. Name of this change log entry.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/changeLogEntries/{change_log_entry}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time when this change log entry was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels associated with this change log entry as key value pairs.
    /// For more information about labels, see [Create and manage
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels>).
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Content of this log entry.
    #[prost(string, tag = "4")]
    pub log: ::prost::alloc::string::String,
}
/// A stock keeping unit (SKU) of GDC hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sku {
    /// Identifier. Name of this SKU.
    /// Format: `projects/{project}/locations/{location}/skus/{sku}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Display name of this SKU.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Time when this SKU was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when this SKU was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Configuration for this SKU.
    #[prost(message, optional, tag = "6")]
    pub config: ::core::option::Option<SkuConfig>,
    /// Output only. Available instances of this SKU. This field should be used for
    /// checking availability of a SKU.
    #[prost(message, repeated, tag = "7")]
    pub instances: ::prost::alloc::vec::Vec<SkuInstance>,
    /// Output only. Description of this SKU.
    #[prost(string, tag = "8")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The SKU revision ID.
    /// A new revision is created whenever `config` is updated. The format is an
    /// 8-character hexadecimal string.
    #[prost(string, tag = "9")]
    pub revision_id: ::prost::alloc::string::String,
    /// Output only. Flag to indicate whether or not this revision is active. Only
    /// an active revision can be used in a new Order.
    #[prost(bool, tag = "10")]
    pub is_active: bool,
    /// Output only. Type of this SKU.
    #[prost(enumeration = "sku::Type", tag = "11")]
    pub r#type: i32,
    /// Output only. The vCPU count associated with this SKU.
    #[prost(int32, tag = "12")]
    pub vcpu_count: i32,
}
/// Nested message and enum types in `Sku`.
pub mod sku {
    /// Valid types of a SKU.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Type of the SKU is unspecified. This is not an allowed value.
        Unspecified = 0,
        /// Rack SKU.
        Rack = 1,
        /// Server SKU.
        Server = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Rack => "RACK",
                Self::Server => "SERVER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "RACK" => Some(Self::Rack),
                "SERVER" => Some(Self::Server),
                _ => None,
            }
        }
    }
}
/// A zone holding a set of hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Zone {
    /// Identifier. Name of this zone.
    /// Format: `projects/{project}/locations/{location}/zones/{zone}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time when this zone was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when this zone was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels associated with this zone as key value pairs.
    /// For more information about labels, see [Create and manage
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels>).
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Human friendly display name of this zone.
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Current state for this zone.
    #[prost(enumeration = "zone::State", tag = "8")]
    pub state: i32,
    /// Required. The points of contact.
    #[prost(message, repeated, tag = "9")]
    pub contacts: ::prost::alloc::vec::Vec<Contact>,
    /// Output only. Link to the Customer Intake Questionnaire (CIQ) sheet for this
    /// zone.
    #[prost(string, tag = "10")]
    pub ciq_uri: ::prost::alloc::string::String,
    /// Optional. Networking configuration for this zone.
    #[prost(message, optional, tag = "11")]
    pub network_config: ::core::option::Option<ZoneNetworkConfig>,
    /// Output only. Globally unique identifier generated for this Edge Zone.
    #[prost(string, tag = "12")]
    pub globally_unique_id: ::prost::alloc::string::String,
    /// Output only. Subscription configurations for this zone.
    #[prost(message, repeated, tag = "13")]
    pub subscription_configs: ::prost::alloc::vec::Vec<SubscriptionConfig>,
    /// Output only. Provisioning state for configurations like MAC addresses.
    #[prost(enumeration = "zone::ProvisioningState", tag = "14")]
    pub provisioning_state: i32,
}
/// Nested message and enum types in `Zone`.
pub mod zone {
    /// Valid states for a zone.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State of the Zone is unspecified.
        Unspecified = 0,
        /// More information is required from the customer to make progress.
        AdditionalInfoNeeded = 1,
        /// Google is preparing the Zone.
        Preparing = 2,
        /// Factory turnup has succeeded.
        ReadyForCustomerFactoryTurnupChecks = 5,
        /// The Zone is ready for site turnup.
        ReadyForSiteTurnup = 6,
        /// The Zone failed in factory turnup checks.
        CustomerFactoryTurnupChecksFailed = 7,
        /// The Zone is available to use.
        Active = 3,
        /// The Zone has been cancelled.
        Cancelled = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::AdditionalInfoNeeded => "ADDITIONAL_INFO_NEEDED",
                Self::Preparing => "PREPARING",
                Self::ReadyForCustomerFactoryTurnupChecks => {
                    "READY_FOR_CUSTOMER_FACTORY_TURNUP_CHECKS"
                }
                Self::ReadyForSiteTurnup => "READY_FOR_SITE_TURNUP",
                Self::CustomerFactoryTurnupChecksFailed => {
                    "CUSTOMER_FACTORY_TURNUP_CHECKS_FAILED"
                }
                Self::Active => "ACTIVE",
                Self::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ADDITIONAL_INFO_NEEDED" => Some(Self::AdditionalInfoNeeded),
                "PREPARING" => Some(Self::Preparing),
                "READY_FOR_CUSTOMER_FACTORY_TURNUP_CHECKS" => {
                    Some(Self::ReadyForCustomerFactoryTurnupChecks)
                }
                "READY_FOR_SITE_TURNUP" => Some(Self::ReadyForSiteTurnup),
                "CUSTOMER_FACTORY_TURNUP_CHECKS_FAILED" => {
                    Some(Self::CustomerFactoryTurnupChecksFailed)
                }
                "ACTIVE" => Some(Self::Active),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
    /// Valid provisioning states for configurations like MAC addresses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProvisioningState {
        /// Provisioning state is unspecified.
        Unspecified = 0,
        /// Provisioning is required. Set by Google.
        ProvisioningRequired = 1,
        /// Provisioning is in progress. Set by customer.
        ProvisioningInProgress = 2,
        /// Provisioning is complete. Set by customer.
        ProvisioningComplete = 3,
    }
    impl ProvisioningState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROVISIONING_STATE_UNSPECIFIED",
                Self::ProvisioningRequired => "PROVISIONING_REQUIRED",
                Self::ProvisioningInProgress => "PROVISIONING_IN_PROGRESS",
                Self::ProvisioningComplete => "PROVISIONING_COMPLETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROVISIONING_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING_REQUIRED" => Some(Self::ProvisioningRequired),
                "PROVISIONING_IN_PROGRESS" => Some(Self::ProvisioningInProgress),
                "PROVISIONING_COMPLETE" => Some(Self::ProvisioningComplete),
                _ => None,
            }
        }
    }
}
/// Contact information of the customer organization.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrganizationContact {
    /// Required. The organization's address.
    #[prost(message, optional, tag = "1")]
    pub address: ::core::option::Option<super::super::super::r#type::PostalAddress>,
    /// Optional. The organization's email.
    #[prost(string, tag = "2")]
    pub email: ::prost::alloc::string::String,
    /// Optional. The organization's phone number.
    #[prost(string, tag = "3")]
    pub phone: ::prost::alloc::string::String,
    /// Required. The individual points of contact in the organization at this
    /// location.
    #[prost(message, repeated, tag = "4")]
    pub contacts: ::prost::alloc::vec::Vec<Contact>,
}
/// Contact details of a point of contact.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Contact {
    /// Required. Given name of the contact.
    #[prost(string, tag = "1")]
    pub given_name: ::prost::alloc::string::String,
    /// Optional. Family name of the contact.
    #[prost(string, tag = "2")]
    pub family_name: ::prost::alloc::string::String,
    /// Required. Email of the contact.
    #[prost(string, tag = "3")]
    pub email: ::prost::alloc::string::String,
    /// Required. Phone number of the contact.
    #[prost(string, tag = "4")]
    pub phone: ::prost::alloc::string::String,
    /// Optional. Time zone of the contact.
    #[prost(message, optional, tag = "5")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
    /// Optional. The time periods when the contact is reachable.
    /// If this field is empty, the contact is reachable at all times.
    #[prost(message, repeated, tag = "6")]
    pub reachable_times: ::prost::alloc::vec::Vec<TimePeriod>,
}
/// Configuration for GDC hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HardwareConfig {
    /// Required. Reference to the SKU for this hardware. This can point to a
    /// specific SKU revision in the form of `resource_name@revision_id` as defined
    /// in [AIP-162](<https://google.aip.dev/162>). If no revision_id is specified,
    /// it refers to the latest revision.
    #[prost(string, tag = "1")]
    pub sku: ::prost::alloc::string::String,
    /// Required. Power supply type for this hardware.
    #[prost(enumeration = "PowerSupply", tag = "2")]
    pub power_supply: i32,
    /// Optional. Subscription duration for the hardware in months.
    #[prost(int32, tag = "3")]
    pub subscription_duration_months: i32,
}
/// Configuration for a SKU.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SkuConfig {
    /// Information about CPU configuration.
    #[prost(string, tag = "1")]
    pub cpu: ::prost::alloc::string::String,
    /// Information about GPU configuration.
    #[prost(string, tag = "2")]
    pub gpu: ::prost::alloc::string::String,
    /// Information about RAM configuration.
    #[prost(string, tag = "3")]
    pub ram: ::prost::alloc::string::String,
    /// Information about storage configuration.
    #[prost(string, tag = "4")]
    pub storage: ::prost::alloc::string::String,
}
/// A specific instance of the SKU.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SkuInstance {
    /// The [Unicode CLDR](<https://cldr.unicode.org>) region code where this
    /// instance is available.
    #[prost(string, tag = "1")]
    pub region_code: ::prost::alloc::string::String,
    /// Power supply type for this instance.
    #[prost(enumeration = "PowerSupply", tag = "2")]
    pub power_supply: i32,
    /// Reference to the corresponding SKU in the Cloud Billing API.
    /// The estimated price information can be retrieved using that API.
    /// Format: `services/{service}/skus/{sku}`
    #[prost(string, tag = "3")]
    pub billing_sku: ::prost::alloc::string::String,
    /// Reference to the corresponding SKU per vCPU in the Cloud Billing API.
    /// The estimated price information can be retrieved using that API.
    /// Format: `services/{service}/skus/{sku}`
    #[prost(string, tag = "4")]
    pub billing_sku_per_vcpu: ::prost::alloc::string::String,
    /// Subscription duration for the hardware in months.
    #[prost(int32, tag = "5")]
    pub subscription_duration_months: i32,
}
/// Physical properties of a hardware.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HardwarePhysicalInfo {
    /// Required. The power receptacle type.
    #[prost(enumeration = "hardware_physical_info::PowerReceptacleType", tag = "1")]
    pub power_receptacle: i32,
    /// Required. Type of the uplink network connection.
    #[prost(enumeration = "hardware_physical_info::NetworkUplinkType", tag = "2")]
    pub network_uplink: i32,
    /// Required. Voltage of the power supply.
    #[prost(enumeration = "hardware_physical_info::Voltage", tag = "3")]
    pub voltage: i32,
    /// Required. Amperes of the power supply.
    #[prost(enumeration = "hardware_physical_info::Amperes", tag = "4")]
    pub amperes: i32,
}
/// Nested message and enum types in `HardwarePhysicalInfo`.
pub mod hardware_physical_info {
    /// Valid power receptacle types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PowerReceptacleType {
        /// Facility plug type is unspecified.
        Unspecified = 0,
        /// NEMA 5-15.
        Nema515 = 1,
        /// C13.
        C13 = 2,
        /// Standard european receptacle.
        StandardEu = 3,
    }
    impl PowerReceptacleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "POWER_RECEPTACLE_TYPE_UNSPECIFIED",
                Self::Nema515 => "NEMA_5_15",
                Self::C13 => "C_13",
                Self::StandardEu => "STANDARD_EU",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "POWER_RECEPTACLE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NEMA_5_15" => Some(Self::Nema515),
                "C_13" => Some(Self::C13),
                "STANDARD_EU" => Some(Self::StandardEu),
                _ => None,
            }
        }
    }
    /// Valid network uplink types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NetworkUplinkType {
        /// Network uplink type is unspecified.
        Unspecified = 0,
        /// RJ-45.
        Rj45 = 1,
    }
    impl NetworkUplinkType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "NETWORK_UPLINK_TYPE_UNSPECIFIED",
                Self::Rj45 => "RJ_45",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NETWORK_UPLINK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "RJ_45" => Some(Self::Rj45),
                _ => None,
            }
        }
    }
    /// Valid voltage values.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Voltage {
        /// Voltage is unspecified.
        Unspecified = 0,
        /// 120V.
        Voltage110 = 1,
        /// 220V.
        Voltage220 = 3,
    }
    impl Voltage {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "VOLTAGE_UNSPECIFIED",
                Self::Voltage110 => "VOLTAGE_110",
                Self::Voltage220 => "VOLTAGE_220",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VOLTAGE_UNSPECIFIED" => Some(Self::Unspecified),
                "VOLTAGE_110" => Some(Self::Voltage110),
                "VOLTAGE_220" => Some(Self::Voltage220),
                _ => None,
            }
        }
    }
    /// Valid amperes values.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Amperes {
        /// Amperes is unspecified.
        Unspecified = 0,
        /// 15A.
        Amperes15 = 1,
    }
    impl Amperes {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "AMPERES_UNSPECIFIED",
                Self::Amperes15 => "AMPERES_15",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AMPERES_UNSPECIFIED" => Some(Self::Unspecified),
                "AMPERES_15" => Some(Self::Amperes15),
                _ => None,
            }
        }
    }
}
/// Information for installation of a Hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HardwareInstallationInfo {
    /// Required. Location of the rack in the site e.g. Floor 2, Room 201, Row 7,
    /// Rack 3.
    #[prost(string, tag = "1")]
    pub rack_location: ::prost::alloc::string::String,
    /// Required. Distance from the power outlet in meters.
    #[prost(int32, tag = "2")]
    pub power_distance_meters: i32,
    /// Required. Distance from the network switch in meters.
    #[prost(int32, tag = "3")]
    pub switch_distance_meters: i32,
    /// Required. Dimensions of the rack unit.
    #[prost(message, optional, tag = "4")]
    pub rack_unit_dimensions: ::core::option::Option<Dimensions>,
    /// Required. Rack space allocated for the hardware.
    #[prost(message, optional, tag = "5")]
    pub rack_space: ::core::option::Option<RackSpace>,
    /// Required. Type of the rack.
    #[prost(enumeration = "hardware_installation_info::RackType", tag = "6")]
    pub rack_type: i32,
}
/// Nested message and enum types in `HardwareInstallationInfo`.
pub mod hardware_installation_info {
    /// Valid rack types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RackType {
        /// Rack type is unspecified.
        Unspecified = 0,
        /// Two post rack.
        TwoPost = 1,
        /// Four post rack.
        FourPost = 2,
    }
    impl RackType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RACK_TYPE_UNSPECIFIED",
                Self::TwoPost => "TWO_POST",
                Self::FourPost => "FOUR_POST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RACK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TWO_POST" => Some(Self::TwoPost),
                "FOUR_POST" => Some(Self::FourPost),
                _ => None,
            }
        }
    }
}
/// Networking configuration for a zone.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneNetworkConfig {
    /// Required. An IPv4 address block for machine management.
    /// Should be a private RFC1918 or public CIDR block large enough to allocate
    /// at least one address per machine in the Zone.
    /// Should be in `management_ipv4_subnet`, and disjoint with other address
    /// ranges.
    #[prost(string, tag = "1")]
    pub machine_mgmt_ipv4_range: ::prost::alloc::string::String,
    /// Required. An IPv4 address block for kubernetes nodes.
    /// Should be a private RFC1918 or public CIDR block large enough to allocate
    /// at least one address per machine in the Zone.
    /// Should be in `kubernetes_ipv4_subnet`, and disjoint with other address
    /// ranges.
    #[prost(string, tag = "2")]
    pub kubernetes_node_ipv4_range: ::prost::alloc::string::String,
    /// Required. An IPv4 address block for kubernetes control plane.
    /// Should be a private RFC1918 or public CIDR block large enough to allocate
    /// at least one address per cluster in the Zone.
    /// Should be in `kubernetes_ipv4_subnet`, and disjoint with other address
    /// ranges.
    #[prost(string, tag = "3")]
    pub kubernetes_control_plane_ipv4_range: ::prost::alloc::string::String,
    /// Required. An IPv4 subnet for the management network.
    #[prost(message, optional, tag = "4")]
    pub management_ipv4_subnet: ::core::option::Option<Subnet>,
    /// Optional. An IPv4 subnet for the kubernetes network.
    /// If unspecified, the kubernetes subnet will be the same as the management
    /// subnet.
    #[prost(message, optional, tag = "5")]
    pub kubernetes_ipv4_subnet: ::core::option::Option<Subnet>,
    /// Optional. DNS nameservers.
    /// The GDC Infrastructure will resolve DNS queries via these IPs.
    /// If unspecified, Google DNS is used.
    #[prost(string, repeated, tag = "6")]
    pub dns_ipv4_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Kubernetes VLAN ID.
    /// By default, the kubernetes node, including the primary kubernetes network,
    /// are in the same VLAN as the machine management network.
    /// For network segmentation purposes, these can optionally be separated.
    #[prost(int32, tag = "7")]
    pub kubernetes_primary_vlan_id: i32,
}
/// Represents a subnet.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subnet {
    /// Required. Address range for this subnet in CIDR notation.
    #[prost(string, tag = "1")]
    pub address_range: ::prost::alloc::string::String,
    /// Required. Default gateway for this subnet.
    #[prost(string, tag = "2")]
    pub default_gateway_ip_address: ::prost::alloc::string::String,
}
/// Represents a time period in a week.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimePeriod {
    /// Required. The start of the time period.
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<super::super::super::r#type::TimeOfDay>,
    /// Required. The end of the time period.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<super::super::super::r#type::TimeOfDay>,
    /// Required. The days of the week that the time period is active.
    #[prost(
        enumeration = "super::super::super::r#type::DayOfWeek",
        repeated,
        packed = "false",
        tag = "3"
    )]
    pub days: ::prost::alloc::vec::Vec<i32>,
}
/// Represents the dimensions of an object.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Dimensions {
    /// Required. Width in inches.
    #[prost(float, tag = "1")]
    pub width_inches: f32,
    /// Required. Height in inches.
    #[prost(float, tag = "2")]
    pub height_inches: f32,
    /// Required. Depth in inches.
    #[prost(float, tag = "3")]
    pub depth_inches: f32,
}
/// Represents contiguous space in a rack.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RackSpace {
    /// Required. First rack unit of the rack space (inclusive).
    #[prost(int32, tag = "1")]
    pub start_rack_unit: i32,
    /// Required. Last rack unit of the rack space (inclusive).
    #[prost(int32, tag = "2")]
    pub end_rack_unit: i32,
}
/// Represents the location of one or many hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HardwareLocation {
    /// Required. Name of the site where the hardware are present.
    /// Format: `projects/{project}/locations/{location}/sites/{site}`
    #[prost(string, tag = "1")]
    pub site: ::prost::alloc::string::String,
    /// Required. Location of the rack in the site e.g. Floor 2, Room 201, Row 7,
    /// Rack 3.
    #[prost(string, tag = "2")]
    pub rack_location: ::prost::alloc::string::String,
    /// Optional. Spaces occupied by the hardware in the rack.
    /// If unset, this location is assumed to be the entire rack.
    #[prost(message, repeated, tag = "3")]
    pub rack_space: ::prost::alloc::vec::Vec<RackSpace>,
}
/// A message to store a subscription configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscriptionConfig {
    /// Output only. The unique identifier of the subscription.
    #[prost(string, tag = "1")]
    pub subscription_id: ::prost::alloc::string::String,
    /// Output only. The Google Cloud Billing ID that the subscription is created
    /// under.
    #[prost(string, tag = "2")]
    pub billing_id: ::prost::alloc::string::String,
    /// Output only. The current state of the subscription.
    #[prost(enumeration = "subscription_config::SubscriptionState", tag = "3")]
    pub state: i32,
}
/// Nested message and enum types in `SubscriptionConfig`.
pub mod subscription_config {
    /// Enum to represent the state of the subscription.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SubscriptionState {
        /// State is unspecified.
        Unspecified = 0,
        /// Active state means that the subscription has been created successfully
        /// and billing is happening.
        Active = 1,
        /// Inactive means that the subscription has been created successfully, but
        /// billing has not started yet.
        Inactive = 2,
        /// The subscription is in an erroneous state.
        Error = 3,
        /// The subscription state failed to be retrieved. This may be a transient
        /// issue. The user should retry the request.
        FailedToRetrieve = 4,
        /// The subscription has been completed, because it has reached the end date.
        Completed = 5,
    }
    impl SubscriptionState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SUBSCRIPTION_STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
                Self::Error => "ERROR",
                Self::FailedToRetrieve => "FAILED_TO_RETRIEVE",
                Self::Completed => "COMPLETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUBSCRIPTION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                "ERROR" => Some(Self::Error),
                "FAILED_TO_RETRIEVE" => Some(Self::FailedToRetrieve),
                "COMPLETED" => Some(Self::Completed),
                _ => None,
            }
        }
    }
}
/// The power supply options.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PowerSupply {
    /// Power supply is unspecified.
    Unspecified = 0,
    /// AC power supply.
    Ac = 1,
    /// DC power supply.
    Dc = 2,
}
impl PowerSupply {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "POWER_SUPPLY_UNSPECIFIED",
            Self::Ac => "POWER_SUPPLY_AC",
            Self::Dc => "POWER_SUPPLY_DC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "POWER_SUPPLY_UNSPECIFIED" => Some(Self::Unspecified),
            "POWER_SUPPLY_AC" => Some(Self::Ac),
            "POWER_SUPPLY_DC" => Some(Self::Dc),
            _ => None,
        }
    }
}
/// Entity is used to denote an organization or party.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Entity {
    /// Entity is unspecified.
    Unspecified = 0,
    /// Google.
    Google = 1,
    /// Customer.
    Customer = 2,
    /// Vendor.
    Vendor = 3,
}
impl Entity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENTITY_UNSPECIFIED",
            Self::Google => "GOOGLE",
            Self::Customer => "CUSTOMER",
            Self::Vendor => "VENDOR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENTITY_UNSPECIFIED" => Some(Self::Unspecified),
            "GOOGLE" => Some(Self::Google),
            "CUSTOMER" => Some(Self::Customer),
            "VENDOR" => Some(Self::Vendor),
            _ => None,
        }
    }
}
/// A request to list orders.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOrdersRequest {
    /// Required. The project and location to list orders in.
    /// Format: `projects/{project}/locations/{location}`
    ///
    /// To list orders across all locations, substitute `-` (the hyphen or
    /// dash character) for the location and check the unreachable field in
    /// the response message.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering condition. See [AIP-160](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A list of orders.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOrdersResponse {
    /// The list of orders.
    #[prost(message, repeated, tag = "1")]
    pub orders: ::prost::alloc::vec::Vec<Order>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached. Only used for queries to the wildcard
    /// location `-`. If non-empty, it indicates that the results are incomplete.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get an order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrderRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to create an order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateOrderRequest {
    /// Required. The project and location to create the order in.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. ID used to uniquely identify the Order within its parent scope.
    /// This field should contain at most 63 characters and must start with
    /// lowercase characters.
    /// Only lowercase characters, numbers and `-` are accepted.
    /// The `-` character cannot be the first or the last one.
    /// A system generated ID will be used if the field is not set.
    ///
    /// The order.name field in the request will be ignored.
    #[prost(string, tag = "2")]
    pub order_id: ::prost::alloc::string::String,
    /// Required. The order to create.
    #[prost(message, optional, tag = "3")]
    pub order: ::core::option::Option<Order>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to update an order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateOrderRequest {
    /// Required. A mask to specify the fields in the Order to overwrite with this
    /// update. The fields specified in the update_mask are relative to the order,
    /// not the full request. A field will be overwritten if it is in the mask. If
    /// you don't provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The order to update.
    #[prost(message, optional, tag = "2")]
    pub order: ::core::option::Option<Order>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to delete an order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteOrderRequest {
    /// Required. The name of the order.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional. An option to delete any nested resources in the Order, such as a
    /// HardwareGroup. If true, any nested resources for this Order will also be
    /// deleted. Otherwise, the request will only succeed if the Order has no
    /// nested resources.
    #[prost(bool, tag = "3")]
    pub force: bool,
}
/// A request to submit an order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitOrderRequest {
    /// Required. The name of the order.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional. Type of this request. If unset, the request type is assumed to be
    /// `INFO_PENDING`.
    #[prost(enumeration = "submit_order_request::Type", tag = "3")]
    pub r#type: i32,
}
/// Nested message and enum types in `SubmitOrderRequest`.
pub mod submit_order_request {
    /// Valid types of submit order request.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Request type is unspecified. This should not be used.
        Unspecified = 0,
        /// Use this request type to submit your order and initiate conversation with
        /// Google. After this submission, you will not be able to modify the number
        /// or SKU of your ordered hardware. Please note that this order will not be
        /// ready for fulfillment yet until you provide more information, such as
        /// zone network configuration, hardware physical and installation
        /// information, etc.
        /// If you are submitting an order for a SKU type of RACK, please use this
        /// request type, as additional information will be required outside of the
        /// API.
        InfoPending = 1,
        /// Use this request type if and when you are ready to submit your order for
        /// fulfillment. In addition to the information required for `INFO_PENDING`,
        /// the order must contain all required information, such as zone network
        /// configuration, hardware physical and installation information, etc.
        /// Further changes to any order information will no longer be allowed.
        InfoComplete = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::InfoPending => "INFO_PENDING",
                Self::InfoComplete => "INFO_COMPLETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INFO_PENDING" => Some(Self::InfoPending),
                "INFO_COMPLETE" => Some(Self::InfoComplete),
                _ => None,
            }
        }
    }
}
/// A request to list sites.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSitesRequest {
    /// Required. The project and location to list sites in.
    /// Format: `projects/{project}/locations/{location}`
    ///
    /// To list sites across all locations, substitute `-` (the hyphen or
    /// dash character) for the location and check the unreachable field in
    /// the response message.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering condition. See [AIP-160](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A list of sites.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSitesResponse {
    /// The list of sites.
    #[prost(message, repeated, tag = "1")]
    pub sites: ::prost::alloc::vec::Vec<Site>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached. Only used for queries to the wildcard
    /// location `-`. If non-empty, it indicates that the results are incomplete.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get a site.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSiteRequest {
    /// Required. The name of the site.
    /// Format: `projects/{project}/locations/{location}/sites/{site}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to create a site.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSiteRequest {
    /// Required. The project and location to create the site in.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. ID used to uniquely identify the Site within its parent scope.
    /// This field should contain at most 63 characters and must start with
    /// lowercase characters.
    /// Only lowercase characters, numbers and `-` are accepted.
    /// The `-` character cannot be the first or the last one.
    /// A system generated ID will be used if the field is not set.
    ///
    /// The site.name field in the request will be ignored.
    #[prost(string, tag = "2")]
    pub site_id: ::prost::alloc::string::String,
    /// Required. The site to create.
    #[prost(message, optional, tag = "3")]
    pub site: ::core::option::Option<Site>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to update a site.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSiteRequest {
    /// Required. A mask to specify the fields in the Site to overwrite with this
    /// update. The fields specified in the update_mask are relative to the site,
    /// not the full request. A field will be overwritten if it is in the mask. If
    /// you don't provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The site to update.
    #[prost(message, optional, tag = "2")]
    pub site: ::core::option::Option<Site>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to delete a site.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSiteRequest {
    /// Required. The name of the site.
    /// Format: `projects/{project}/locations/{location}/sites/{site}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to list hardware groups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHardwareGroupsRequest {
    /// Required. The order to list hardware groups in.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering condition. See [AIP-160](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A list of hardware groups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHardwareGroupsResponse {
    /// The list of hardware groups.
    #[prost(message, repeated, tag = "1")]
    pub hardware_groups: ::prost::alloc::vec::Vec<HardwareGroup>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get a hardware group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHardwareGroupRequest {
    /// Required. The name of the hardware group.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/hardwareGroups/{hardware_group}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to create a hardware group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateHardwareGroupRequest {
    /// Required. The order to create the hardware group in.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. ID used to uniquely identify the HardwareGroup within its parent
    /// scope. This field should contain at most 63 characters and must start with
    /// lowercase characters.
    /// Only lowercase characters, numbers and `-` are accepted.
    /// The `-` character cannot be the first or the last one.
    /// A system generated ID will be used if the field is not set.
    ///
    /// The hardware_group.name field in the request will be ignored.
    #[prost(string, tag = "2")]
    pub hardware_group_id: ::prost::alloc::string::String,
    /// Required. The hardware group to create.
    #[prost(message, optional, tag = "3")]
    pub hardware_group: ::core::option::Option<HardwareGroup>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to update a hardware group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateHardwareGroupRequest {
    /// Required. A mask to specify the fields in the HardwareGroup to overwrite
    /// with this update. The fields specified in the update_mask are relative to
    /// the hardware group, not the full request. A field will be overwritten if it
    /// is in the mask. If you don't provide a mask then all fields will be
    /// overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The hardware group to update.
    #[prost(message, optional, tag = "2")]
    pub hardware_group: ::core::option::Option<HardwareGroup>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to delete a hardware group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteHardwareGroupRequest {
    /// Required. The name of the hardware group.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/hardwareGroups/{hardware_group}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to list hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHardwareRequest {
    /// Required. The project and location to list hardware in.
    /// Format: `projects/{project}/locations/{location}`
    ///
    /// To list hardware across all locations, substitute `-` (the hyphen or
    /// dash character) for the location and check the unreachable field in
    /// the response message.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering condition. See [AIP-160](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A list of hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHardwareResponse {
    /// The list of hardware.
    #[prost(message, repeated, tag = "1")]
    pub hardware: ::prost::alloc::vec::Vec<Hardware>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached. Only used for queries to the wildcard
    /// location `-`. If non-empty, it indicates that the results are incomplete.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHardwareRequest {
    /// Required. The name of the hardware.
    /// Format: `projects/{project}/locations/{location}/hardware/{hardware}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to create hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateHardwareRequest {
    /// Required. The project and location to create hardware in.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. ID used to uniquely identify the Hardware within its parent
    /// scope. This field should contain at most 63 characters and must start with
    /// lowercase characters.
    /// Only lowercase characters, numbers and `-` are accepted.
    /// The `-` character cannot be the first or the last one.
    /// A system generated ID will be used if the field is not set.
    ///
    /// The hardware.name field in the request will be ignored.
    #[prost(string, tag = "2")]
    pub hardware_id: ::prost::alloc::string::String,
    /// Required. The resource to create.
    #[prost(message, optional, tag = "3")]
    pub hardware: ::core::option::Option<Hardware>,
}
/// A request to update hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateHardwareRequest {
    /// Required. A mask to specify the fields in the Hardware to overwrite with
    /// this update. The fields specified in the update_mask are relative to the
    /// hardware, not the full request. A field will be overwritten if it is in the
    /// mask. If you don't provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The hardware to update.
    #[prost(message, optional, tag = "2")]
    pub hardware: ::core::option::Option<Hardware>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to delete hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteHardwareRequest {
    /// Required. The name of the hardware.
    /// Format: `projects/{project}/locations/{location}/hardware/{hardware}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to list comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCommentsRequest {
    /// Required. The order to list comments on.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering condition. See [AIP-160](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A request to list comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCommentsResponse {
    /// The list of comments.
    #[prost(message, repeated, tag = "1")]
    pub comments: ::prost::alloc::vec::Vec<Comment>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get a comment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCommentRequest {
    /// Required. The name of the comment.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/comments/{comment}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to create a comment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCommentRequest {
    /// Required. The order to create the comment on.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. ID used to uniquely identify the Comment within its parent scope.
    /// This field should contain at most 63 characters and must start with
    /// lowercase characters.
    /// Only lowercase characters, numbers and `-` are accepted.
    /// The `-` character cannot be the first or the last one.
    /// A system generated ID will be used if the field is not set.
    ///
    /// The comment.name field in the request will be ignored.
    #[prost(string, tag = "2")]
    pub comment_id: ::prost::alloc::string::String,
    /// Required. The comment to create.
    #[prost(message, optional, tag = "3")]
    pub comment: ::core::option::Option<Comment>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to record an action on a comment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordActionOnCommentRequest {
    /// Required. The name of the comment.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/comments/{comment}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The action type of the recorded action.
    #[prost(enumeration = "record_action_on_comment_request::ActionType", tag = "2")]
    pub action_type: i32,
}
/// Nested message and enum types in `RecordActionOnCommentRequest`.
pub mod record_action_on_comment_request {
    /// Valid action types of Comment.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ActionType {
        /// Action is unspecified.
        Unspecified = 0,
        /// Mark comment as read.
        Read = 1,
        /// Mark comment as unread.
        Unread = 2,
    }
    impl ActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ACTION_TYPE_UNSPECIFIED",
                Self::Read => "READ",
                Self::Unread => "UNREAD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "READ" => Some(Self::Read),
                "UNREAD" => Some(Self::Unread),
                _ => None,
            }
        }
    }
}
/// A request to list change log entries.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChangeLogEntriesRequest {
    /// Required. The order to list change log entries for.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering condition. See [AIP-160](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A list of change log entries.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChangeLogEntriesResponse {
    /// The list of change log entries.
    #[prost(message, repeated, tag = "1")]
    pub change_log_entries: ::prost::alloc::vec::Vec<ChangeLogEntry>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get a change log entry.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChangeLogEntryRequest {
    /// Required. The name of the change log entry.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/changeLogEntries/{change_log_entry}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to list SKUs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSkusRequest {
    /// Required. The project and location to list SKUs in.
    /// Format: `projects/{project}/locations/{location}`
    ///
    /// To list SKUs across all locations, substitute `-` (the hyphen or
    /// dash character) for the location and check the unreachable field in
    /// the response message.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering condition. See [AIP-160](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A list of SKUs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSkusResponse {
    /// The list of SKUs.
    #[prost(message, repeated, tag = "1")]
    pub skus: ::prost::alloc::vec::Vec<Sku>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached. Only used for queries to the wildcard
    /// location `-`. If non-empty, it indicates that the results are incomplete.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get an SKU.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSkuRequest {
    /// Required. The name of the SKU.
    /// Format: `projects/{project}/locations/{location}/skus/{sku}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to list zones.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListZonesRequest {
    /// Required. The project and location to list zones in.
    /// Format: `projects/{project}/locations/{location}`
    ///
    /// To list zones across all locations, substitute `-` (the hyphen or
    /// dash character) for the location and check the unreachable field in
    /// the response message.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering condition. See [AIP-160](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A list of zones.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListZonesResponse {
    /// The list of zones.
    #[prost(message, repeated, tag = "1")]
    pub zones: ::prost::alloc::vec::Vec<Zone>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached. Only used for queries to the wildcard
    /// location `-`. If non-empty, it indicates that the results are incomplete.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get a zone.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetZoneRequest {
    /// Required. The name of the zone.
    /// Format: `projects/{project}/locations/{location}/zones/{zone}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to create a zone.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateZoneRequest {
    /// Required. The project and location to create the zone in.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. ID used to uniquely identify the Zone within its parent scope.
    /// This field should contain at most 63 characters and must start with
    /// lowercase characters.
    /// Only lowercase characters, numbers and `-` are accepted.
    /// The `-` character cannot be the first or the last one.
    /// A system generated ID will be used if the field is not set.
    ///
    /// The zone.name field in the request will be ignored.
    #[prost(string, tag = "2")]
    pub zone_id: ::prost::alloc::string::String,
    /// Required. The zone to create.
    #[prost(message, optional, tag = "3")]
    pub zone: ::core::option::Option<Zone>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to update a zone.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateZoneRequest {
    /// Required. A mask to specify the fields in the Zone to overwrite with this
    /// update. The fields specified in the update_mask are relative to the zone,
    /// not the full request. A field will be overwritten if it is in the mask. If
    /// you don't provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The zone to update.
    #[prost(message, optional, tag = "2")]
    pub zone: ::core::option::Option<Zone>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to delete a zone.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteZoneRequest {
    /// Required. The name of the zone.
    /// Format: `projects/{project}/locations/{location}/zones/{zone}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to signal the state of a zone.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalZoneStateRequest {
    /// Required. The name of the zone.
    /// Format: `projects/{project}/locations/{location}/zones/{zone}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional. The state signal to send for this zone. Either state_signal or
    /// provisioning_state_signal must be set, but not both.
    #[prost(enumeration = "signal_zone_state_request::StateSignal", tag = "3")]
    pub state_signal: i32,
    /// Optional. The provisioning state signal to send for this zone. Either
    /// state_signal or provisioning_state_signal must be set, but not both.
    #[prost(
        enumeration = "signal_zone_state_request::ProvisioningStateSignal",
        tag = "4"
    )]
    pub provisioning_state_signal: i32,
}
/// Nested message and enum types in `SignalZoneStateRequest`.
pub mod signal_zone_state_request {
    /// Valid state signals for a zone.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StateSignal {
        /// State signal of the zone is unspecified.
        Unspecified = 0,
        /// The Zone is ready for site turnup.
        FactoryTurnupChecksPassed = 1,
        /// The Zone failed in factory turnup checks.
        FactoryTurnupChecksFailed = 2,
    }
    impl StateSignal {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_SIGNAL_UNSPECIFIED",
                Self::FactoryTurnupChecksPassed => "FACTORY_TURNUP_CHECKS_PASSED",
                Self::FactoryTurnupChecksFailed => "FACTORY_TURNUP_CHECKS_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_SIGNAL_UNSPECIFIED" => Some(Self::Unspecified),
                "FACTORY_TURNUP_CHECKS_PASSED" => Some(Self::FactoryTurnupChecksPassed),
                "FACTORY_TURNUP_CHECKS_FAILED" => Some(Self::FactoryTurnupChecksFailed),
                _ => None,
            }
        }
    }
    /// Valid provisioning state signals for a zone.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProvisioningStateSignal {
        /// Provisioning state signal is unspecified.
        Unspecified = 0,
        /// Provisioning is in progress.
        ProvisioningInProgress = 1,
        /// Provisioning is complete.
        ProvisioningComplete = 2,
    }
    impl ProvisioningStateSignal {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROVISIONING_STATE_SIGNAL_UNSPECIFIED",
                Self::ProvisioningInProgress => "PROVISIONING_IN_PROGRESS",
                Self::ProvisioningComplete => "PROVISIONING_COMPLETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROVISIONING_STATE_SIGNAL_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING_IN_PROGRESS" => Some(Self::ProvisioningInProgress),
                "PROVISIONING_COMPLETE" => Some(Self::ProvisioningComplete),
                _ => None,
            }
        }
    }
}
/// Represents the metadata of a long-running operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. The verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod gdc_hardware_management_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The GDC Hardware Management service.
    #[derive(Debug, Clone)]
    pub struct GdcHardwareManagementClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl GdcHardwareManagementClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> GdcHardwareManagementClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GdcHardwareManagementClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            GdcHardwareManagementClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists orders in a given project and location.
        pub async fn list_orders(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOrdersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOrdersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListOrders",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListOrders",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of an order.
        pub async fn get_order(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOrderRequest>,
        ) -> std::result::Result<tonic::Response<super::Order>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetOrder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new order in a given project and location.
        pub async fn create_order(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateOrder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of an order.
        pub async fn update_order(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "UpdateOrder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an order.
        pub async fn delete_order(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "DeleteOrder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Submits an order.
        pub async fn submit_order(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/SubmitOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "SubmitOrder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists sites in a given project and location.
        pub async fn list_sites(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSitesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSitesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListSites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListSites",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a site.
        pub async fn get_site(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSiteRequest>,
        ) -> std::result::Result<tonic::Response<super::Site>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new site in a given project and location.
        pub async fn create_site(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSiteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a site.
        pub async fn update_site(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSiteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "UpdateSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a site.
        pub async fn delete_site(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSiteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "DeleteSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists hardware groups in a given order.
        pub async fn list_hardware_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListHardwareGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListHardwareGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListHardwareGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListHardwareGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a hardware group.
        pub async fn get_hardware_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHardwareGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::HardwareGroup>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetHardwareGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetHardwareGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new hardware group in a given order.
        pub async fn create_hardware_group(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateHardwareGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateHardwareGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateHardwareGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a hardware group.
        pub async fn update_hardware_group(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateHardwareGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateHardwareGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "UpdateHardwareGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a hardware group.
        pub async fn delete_hardware_group(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteHardwareGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteHardwareGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "DeleteHardwareGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists hardware in a given project and location.
        pub async fn list_hardware(
            &mut self,
            request: impl tonic::IntoRequest<super::ListHardwareRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListHardwareResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListHardware",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListHardware",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets hardware details.
        pub async fn get_hardware(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHardwareRequest>,
        ) -> std::result::Result<tonic::Response<super::Hardware>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetHardware",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetHardware",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates new hardware in a given project and location.
        pub async fn create_hardware(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateHardwareRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateHardware",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateHardware",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates hardware parameters.
        pub async fn update_hardware(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateHardwareRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateHardware",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "UpdateHardware",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes hardware.
        pub async fn delete_hardware(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteHardwareRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteHardware",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "DeleteHardware",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the comments on an order.
        pub async fn list_comments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCommentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCommentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListComments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListComments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the content of a comment.
        pub async fn get_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCommentRequest>,
        ) -> std::result::Result<tonic::Response<super::Comment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new comment on an order.
        pub async fn create_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Record Action on a Comment. If the Action specified in the request is READ,
        /// the viewed time in the comment is set to the time the request was received.
        /// If the comment is already marked as read, subsequent calls will be ignored.
        /// If the Action is UNREAD, the viewed time is cleared from the comment.
        pub async fn record_action_on_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::RecordActionOnCommentRequest>,
        ) -> std::result::Result<tonic::Response<super::Comment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/RecordActionOnComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "RecordActionOnComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the changes made to an order.
        pub async fn list_change_log_entries(
            &mut self,
            request: impl tonic::IntoRequest<super::ListChangeLogEntriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListChangeLogEntriesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListChangeLogEntries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListChangeLogEntries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a change to an order.
        pub async fn get_change_log_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::GetChangeLogEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::ChangeLogEntry>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetChangeLogEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetChangeLogEntry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists SKUs for a given project and location.
        pub async fn list_skus(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSkusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSkusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListSkus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListSkus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of an SKU.
        pub async fn get_sku(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSkuRequest>,
        ) -> std::result::Result<tonic::Response<super::Sku>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetSku",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetSku",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists zones in a given project and location.
        pub async fn list_zones(
            &mut self,
            request: impl tonic::IntoRequest<super::ListZonesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListZonesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListZones",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListZones",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a zone.
        pub async fn get_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::GetZoneRequest>,
        ) -> std::result::Result<tonic::Response<super::Zone>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new zone in a given project and location.
        pub async fn create_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a zone.
        pub async fn update_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "UpdateZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a zone.
        pub async fn delete_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "DeleteZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Signals the state of a zone.
        pub async fn signal_zone_state(
            &mut self,
            request: impl tonic::IntoRequest<super::SignalZoneStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/SignalZoneState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "SignalZoneState",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
