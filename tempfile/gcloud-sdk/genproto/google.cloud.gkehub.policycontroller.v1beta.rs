// This file is @generated by prost-build.
/// **Policy Controller**: State for a single cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MembershipState {
    /// Currently these include (also serving as map keys):
    /// 1. "admission"
    /// 2. "audit"
    /// 3. "mutation"
    #[prost(map = "string, message", tag = "3")]
    pub component_states: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        OnClusterState,
    >,
    /// The overall Policy Controller lifecycle state observed by the Hub Feature
    /// controller.
    #[prost(enumeration = "membership_state::LifecycleState", tag = "4")]
    pub state: i32,
    /// The overall content state observed by the Hub Feature controller.
    #[prost(message, optional, tag = "6")]
    pub policy_content_state: ::core::option::Option<PolicyContentState>,
}
/// Nested message and enum types in `MembershipState`.
pub mod membership_state {
    /// The set of states Policy Controller can exist in.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LifecycleState {
        /// The lifecycle state is unspecified.
        Unspecified = 0,
        /// The PC does not exist on the given cluster, and no k8s resources of any
        /// type that are associated with the PC should exist there. The cluster
        /// does not possess a membership with the PCH.
        NotInstalled = 1,
        /// The PCH possesses a Membership, however the PC is not fully installed
        /// on the cluster.
        /// In this state the hub can be expected to be taking actions to
        /// install the PC on the cluster.
        Installing = 2,
        /// The PC is fully installed on the cluster and in an operational mode.
        /// In this state PCH will be reconciling state with the PC, and
        /// the PC will be performing it's operational tasks per that software.
        /// Entering a READY state requires that the hub has confirmed the PC is
        /// installed and its pods are operational with the version of
        /// the PC the PCH expects.
        Active = 3,
        /// The PC is fully installed, but in the process of changing the
        /// configuration (including changing the version of PC either up and down,
        /// or modifying the manifests of PC) of the resources running on the
        /// cluster. The PCH has a Membership, is aware of the version the cluster
        /// should be running in, but has not confirmed for itself that the PC is
        /// running with that version.
        Updating = 4,
        /// The PC may have resources on the cluster,
        /// but the PCH wishes to remove the Membership.
        /// The Membership still exists.
        Decommissioning = 5,
        /// The PC is not operational, and the PCH is unable to act to make it
        /// operational.
        /// Entering a CLUSTER_ERROR state happens automatically when the PCH
        /// determines that a PC installed on the cluster is non-operative or
        /// that the cluster does not meet requirements set for the PCH to
        /// administer the cluster but has nevertheless been given an instruction to
        /// do so (such as 'install').
        ClusterError = 6,
        /// In this state, the PC may still be operational,
        /// and only the PCH is unable to act.
        /// The hub should not issue instructions to change the PC state,
        /// or otherwise interfere with the on-cluster resources.
        /// Entering a HUB_ERROR state happens automatically when the PCH determines
        /// the hub is in an unhealthy state and it wishes to 'take hands off' to
        /// avoid corrupting the PC or other data.
        HubError = 7,
        /// Policy Controller (PC) is installed but suspended. This means that the
        /// policies are not enforced, but violations are still recorded (through
        /// audit).
        Suspended = 8,
        /// PoCo Hub is not taking any action to reconcile cluster objects.  Changes
        /// to those objects will not be overwritten by PoCo Hub.
        Detached = 9,
    }
    impl LifecycleState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LIFECYCLE_STATE_UNSPECIFIED",
                Self::NotInstalled => "NOT_INSTALLED",
                Self::Installing => "INSTALLING",
                Self::Active => "ACTIVE",
                Self::Updating => "UPDATING",
                Self::Decommissioning => "DECOMMISSIONING",
                Self::ClusterError => "CLUSTER_ERROR",
                Self::HubError => "HUB_ERROR",
                Self::Suspended => "SUSPENDED",
                Self::Detached => "DETACHED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LIFECYCLE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "NOT_INSTALLED" => Some(Self::NotInstalled),
                "INSTALLING" => Some(Self::Installing),
                "ACTIVE" => Some(Self::Active),
                "UPDATING" => Some(Self::Updating),
                "DECOMMISSIONING" => Some(Self::Decommissioning),
                "CLUSTER_ERROR" => Some(Self::ClusterError),
                "HUB_ERROR" => Some(Self::HubError),
                "SUSPENDED" => Some(Self::Suspended),
                "DETACHED" => Some(Self::Detached),
                _ => None,
            }
        }
    }
}
/// The state of the policy controller policy content
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyContentState {
    /// The state of the template library
    #[prost(message, optional, tag = "1")]
    pub template_library_state: ::core::option::Option<OnClusterState>,
    /// The state of the any bundles included in the chosen
    /// version of the manifest
    #[prost(map = "string, message", tag = "2")]
    pub bundle_states: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        OnClusterState,
    >,
    /// The state of the referential data sync configuration.  This could
    /// represent the state of either the syncSet object(s) or the config
    /// object, depending on the version of PoCo configured by the user.
    #[prost(message, optional, tag = "3")]
    pub referential_sync_config_state: ::core::option::Option<OnClusterState>,
}
/// **Policy Controller**: Configuration for a single cluster.
/// Intended to parallel the PolicyController CR.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MembershipSpec {
    /// Policy Controller configuration for the cluster.
    #[prost(message, optional, tag = "1")]
    pub policy_controller_hub_config: ::core::option::Option<HubConfig>,
    /// Version of Policy Controller installed.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
/// Configuration for Policy Controller
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HubConfig {
    /// The install_spec represents the intended state specified by the
    /// latest request that mutated install_spec in the feature spec,
    /// not the lifecycle state of the
    /// feature observed by the Hub feature controller
    /// that is reported in the feature state.
    #[prost(enumeration = "hub_config::InstallSpec", tag = "1")]
    pub install_spec: i32,
    /// Sets the interval for Policy Controller Audit Scans (in seconds).
    /// When set to 0, this disables audit functionality altogether.
    #[prost(int64, optional, tag = "2")]
    pub audit_interval_seconds: ::core::option::Option<i64>,
    /// The set of namespaces that are excluded from Policy Controller checks.
    /// Namespaces do not need to currently exist on the cluster.
    #[prost(string, repeated, tag = "3")]
    pub exemptable_namespaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Enables the ability to use Constraint Templates that reference to objects
    /// other than the object currently being evaluated.
    #[prost(bool, tag = "4")]
    pub referential_rules_enabled: bool,
    /// Logs all denies and dry run failures.
    #[prost(bool, tag = "5")]
    pub log_denies_enabled: bool,
    /// Enables the ability to mutate resources using Policy Controller.
    #[prost(bool, tag = "6")]
    pub mutation_enabled: bool,
    /// Monitoring specifies the configuration of monitoring.
    #[prost(message, optional, tag = "8")]
    pub monitoring: ::core::option::Option<MonitoringConfig>,
    /// Specifies the desired policy content on the cluster
    #[prost(message, optional, tag = "9")]
    pub policy_content: ::core::option::Option<PolicyContentSpec>,
    /// The maximum number of audit violations to be stored in a constraint.
    /// If not set, the internal default (currently 20) will be used.
    #[prost(int64, optional, tag = "10")]
    pub constraint_violation_limit: ::core::option::Option<i64>,
    /// Map of deployment configs to deployments ("admission", "audit",
    /// "mutation').
    #[prost(map = "string, message", tag = "11")]
    pub deployment_configs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        PolicyControllerDeploymentConfig,
    >,
}
/// Nested message and enum types in `HubConfig`.
pub mod hub_config {
    /// The set of installation specs that the Hub Feature controller may
    /// actuate.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InstallSpec {
        /// Spec is unknown.
        Unspecified = 0,
        /// Request to uninstall Policy Controller.
        NotInstalled = 1,
        /// Request to install and enable Policy Controller.
        Enabled = 2,
        /// Request to suspend Policy Controller i.e. its webhooks. If Policy
        /// Controller is not installed, it will be installed but suspended.
        Suspended = 3,
        /// Request to stop all reconciliation actions by PoCo Hub controller.
        /// This is a breakglass mechanism to stop PoCo Hub from affecting
        /// cluster resources.
        Detached = 4,
    }
    impl InstallSpec {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "INSTALL_SPEC_UNSPECIFIED",
                Self::NotInstalled => "INSTALL_SPEC_NOT_INSTALLED",
                Self::Enabled => "INSTALL_SPEC_ENABLED",
                Self::Suspended => "INSTALL_SPEC_SUSPENDED",
                Self::Detached => "INSTALL_SPEC_DETACHED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INSTALL_SPEC_UNSPECIFIED" => Some(Self::Unspecified),
                "INSTALL_SPEC_NOT_INSTALLED" => Some(Self::NotInstalled),
                "INSTALL_SPEC_ENABLED" => Some(Self::Enabled),
                "INSTALL_SPEC_SUSPENDED" => Some(Self::Suspended),
                "INSTALL_SPEC_DETACHED" => Some(Self::Detached),
                _ => None,
            }
        }
    }
}
/// Deployment-specific configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyControllerDeploymentConfig {
    /// Pod replica count.
    #[prost(int64, optional, tag = "1")]
    pub replica_count: ::core::option::Option<i64>,
    /// Container resource requirements.
    #[prost(message, optional, tag = "2")]
    pub container_resources: ::core::option::Option<ResourceRequirements>,
    /// Pod anti-affinity enablement. Deprecated: use `pod_affinity` instead.
    #[deprecated]
    #[prost(bool, optional, tag = "3")]
    pub pod_anti_affinity: ::core::option::Option<bool>,
    /// Pod tolerations of node taints.
    #[prost(message, repeated, tag = "4")]
    pub pod_tolerations: ::prost::alloc::vec::Vec<
        policy_controller_deployment_config::Toleration,
    >,
    /// Pod affinity configuration.
    #[prost(enumeration = "policy_controller_deployment_config::Affinity", tag = "5")]
    pub pod_affinity: i32,
}
/// Nested message and enum types in `PolicyControllerDeploymentConfig`.
pub mod policy_controller_deployment_config {
    /// Toleration of a node taint.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Toleration {
        /// Matches a taint key (not necessarily unique).
        #[prost(string, optional, tag = "1")]
        pub key: ::core::option::Option<::prost::alloc::string::String>,
        /// Matches a taint operator.
        #[prost(string, optional, tag = "2")]
        pub operator: ::core::option::Option<::prost::alloc::string::String>,
        /// Matches a taint value.
        #[prost(string, optional, tag = "3")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
        /// Matches a taint effect.
        #[prost(string, optional, tag = "4")]
        pub effect: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// The pod affinity configuration used by a deployment.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Affinity {
        /// No affinity configuration has been specified.
        Unspecified = 0,
        /// Affinity configurations will be removed from the deployment.
        NoAffinity = 1,
        /// Anti-affinity configuration will be applied to this deployment.
        /// Default for admissions deployment.
        AntiAffinity = 2,
    }
    impl Affinity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "AFFINITY_UNSPECIFIED",
                Self::NoAffinity => "NO_AFFINITY",
                Self::AntiAffinity => "ANTI_AFFINITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AFFINITY_UNSPECIFIED" => Some(Self::Unspecified),
                "NO_AFFINITY" => Some(Self::NoAffinity),
                "ANTI_AFFINITY" => Some(Self::AntiAffinity),
                _ => None,
            }
        }
    }
}
/// ResourceRequirements describes the compute resource requirements.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceRequirements {
    /// Limits describes the maximum amount of compute resources allowed for use by
    /// the running container.
    #[prost(message, optional, tag = "1")]
    pub limits: ::core::option::Option<ResourceList>,
    /// Requests describes the amount of compute resources reserved for the
    /// container by the kube-scheduler.
    #[prost(message, optional, tag = "2")]
    pub requests: ::core::option::Option<ResourceList>,
}
/// ResourceList contains container resource requirements.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceList {
    /// Memory requirement expressed in Kubernetes resource units.
    #[prost(string, optional, tag = "1")]
    pub memory: ::core::option::Option<::prost::alloc::string::String>,
    /// CPU requirement expressed in Kubernetes resource units.
    #[prost(string, optional, tag = "2")]
    pub cpu: ::core::option::Option<::prost::alloc::string::String>,
}
/// The config specifying which default library templates to install.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TemplateLibraryConfig {
    /// Configures the manner in which the template library is installed on the
    /// cluster.
    #[prost(enumeration = "template_library_config::Installation", tag = "2")]
    pub installation: i32,
}
/// Nested message and enum types in `TemplateLibraryConfig`.
pub mod template_library_config {
    /// How the template library should be installed
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Installation {
        /// No installation strategy has been specified.
        Unspecified = 0,
        /// Do not install the template library.
        NotInstalled = 1,
        /// Install the entire template library.
        All = 2,
    }
    impl Installation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "INSTALLATION_UNSPECIFIED",
                Self::NotInstalled => "NOT_INSTALLED",
                Self::All => "ALL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INSTALLATION_UNSPECIFIED" => Some(Self::Unspecified),
                "NOT_INSTALLED" => Some(Self::NotInstalled),
                "ALL" => Some(Self::All),
                _ => None,
            }
        }
    }
}
/// MonitoringConfig specifies the backends Policy Controller should
/// export metrics to. For example, to specify metrics should be exported to
/// Cloud Monitoring and Prometheus, specify
/// backends: \["cloudmonitoring", "prometheus"\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MonitoringConfig {
    /// Specifies the list of backends Policy Controller will export to.
    /// An empty list would effectively disable metrics export.
    #[prost(enumeration = "monitoring_config::MonitoringBackend", repeated, tag = "1")]
    pub backends: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `MonitoringConfig`.
pub mod monitoring_config {
    /// Supported backend options for monitoring
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MonitoringBackend {
        /// Backend cannot be determined
        Unspecified = 0,
        /// Prometheus backend for monitoring
        Prometheus = 1,
        /// Stackdriver/Cloud Monitoring backend for monitoring
        CloudMonitoring = 2,
    }
    impl MonitoringBackend {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MONITORING_BACKEND_UNSPECIFIED",
                Self::Prometheus => "PROMETHEUS",
                Self::CloudMonitoring => "CLOUD_MONITORING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MONITORING_BACKEND_UNSPECIFIED" => Some(Self::Unspecified),
                "PROMETHEUS" => Some(Self::Prometheus),
                "CLOUD_MONITORING" => Some(Self::CloudMonitoring),
                _ => None,
            }
        }
    }
}
/// OnClusterState represents the state of a sub-component of Policy Controller.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnClusterState {
    /// The lifecycle state of this component.
    #[prost(enumeration = "membership_state::LifecycleState", tag = "1")]
    pub state: i32,
    /// Surface potential errors or information logs.
    #[prost(string, tag = "2")]
    pub details: ::prost::alloc::string::String,
}
/// BundleInstallSpec is the specification configuration for a single managed
/// bundle.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BundleInstallSpec {
    /// The set of namespaces to be exempted from the bundle.
    #[prost(string, repeated, tag = "2")]
    pub exempted_namespaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// PolicyContentSpec defines the user's desired content configuration on the
/// cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyContentSpec {
    /// map of bundle name to BundleInstallSpec. The bundle name maps to the
    /// `bundleName` key in the `policycontroller.gke.io/constraintData` annotation
    /// on a constraint.
    #[prost(map = "string, message", tag = "1")]
    pub bundles: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        BundleInstallSpec,
    >,
    /// Configures the installation of the Template Library.
    #[prost(message, optional, tag = "2")]
    pub template_library: ::core::option::Option<TemplateLibraryConfig>,
}
