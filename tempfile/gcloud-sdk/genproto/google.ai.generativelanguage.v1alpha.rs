// This file is @generated by prost-build.
/// The base structured datatype containing multi-part content of a message.
///
/// A `Content` includes a `role` field designating the producer of the `Content`
/// and a `parts` field containing multi-part data that contains the content of
/// the message turn.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Content {
    /// Ordered `Parts` that constitute a single message. Parts may have different
    /// MIME types.
    #[prost(message, repeated, tag = "1")]
    pub parts: ::prost::alloc::vec::Vec<Part>,
    /// Optional. The producer of the content. Must be either 'user' or 'model'.
    ///
    /// Useful to set for multi-turn conversations, otherwise can be left blank
    /// or unset.
    #[prost(string, tag = "2")]
    pub role: ::prost::alloc::string::String,
}
/// A datatype containing media that is part of a multi-part `Content` message.
///
/// A `Part` consists of data which has an associated datatype. A `Part` can only
/// contain one of the accepted types in `Part.data`.
///
/// A `Part` must have a fixed IANA MIME type identifying the type and subtype
/// of the media if the `inline_data` field is filled with raw bytes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Part {
    #[prost(oneof = "part::Data", tags = "2, 3, 4, 5, 6, 9, 10")]
    pub data: ::core::option::Option<part::Data>,
}
/// Nested message and enum types in `Part`.
pub mod part {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        /// Inline text.
        #[prost(string, tag = "2")]
        Text(::prost::alloc::string::String),
        /// Inline media bytes.
        #[prost(message, tag = "3")]
        InlineData(super::Blob),
        /// A predicted `FunctionCall` returned from the model that contains
        /// a string representing the `FunctionDeclaration.name` with the
        /// arguments and their values.
        #[prost(message, tag = "4")]
        FunctionCall(super::FunctionCall),
        /// The result output of a `FunctionCall` that contains a string
        /// representing the `FunctionDeclaration.name` and a structured JSON
        /// object containing any output from the function is used as context to
        /// the model.
        #[prost(message, tag = "5")]
        FunctionResponse(super::FunctionResponse),
        /// URI based data.
        #[prost(message, tag = "6")]
        FileData(super::FileData),
        /// Code generated by the model that is meant to be executed.
        #[prost(message, tag = "9")]
        ExecutableCode(super::ExecutableCode),
        /// Result of executing the `ExecutableCode`.
        #[prost(message, tag = "10")]
        CodeExecutionResult(super::CodeExecutionResult),
    }
}
/// Raw media bytes.
///
/// Text should not be sent as raw bytes, use the 'text' field.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Blob {
    /// The IANA standard MIME type of the source data.
    /// Examples:
    ///    - image/png
    ///    - image/jpeg
    /// If an unsupported MIME type is provided, an error will be returned. For a
    /// complete list of supported types, see [Supported file
    /// formats](<https://ai.google.dev/gemini-api/docs/prompting_with_media#supported_file_formats>).
    #[prost(string, tag = "1")]
    pub mime_type: ::prost::alloc::string::String,
    /// Raw bytes for media formats.
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// URI based data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileData {
    /// Optional. The IANA standard MIME type of the source data.
    #[prost(string, tag = "1")]
    pub mime_type: ::prost::alloc::string::String,
    /// Required. URI.
    #[prost(string, tag = "2")]
    pub file_uri: ::prost::alloc::string::String,
}
/// Code generated by the model that is meant to be executed, and the result
/// returned to the model.
///
/// Only generated when using the `CodeExecution` tool, in which the code will
/// be automatically executed, and a corresponding `CodeExecutionResult` will
/// also be generated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutableCode {
    /// Required. Programming language of the `code`.
    #[prost(enumeration = "executable_code::Language", tag = "1")]
    pub language: i32,
    /// Required. The code to be executed.
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ExecutableCode`.
pub mod executable_code {
    /// Supported programming languages for the generated code.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Language {
        /// Unspecified language. This value should not be used.
        Unspecified = 0,
        /// Python >= 3.10, with numpy and simpy available.
        Python = 1,
    }
    impl Language {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LANGUAGE_UNSPECIFIED",
                Self::Python => "PYTHON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LANGUAGE_UNSPECIFIED" => Some(Self::Unspecified),
                "PYTHON" => Some(Self::Python),
                _ => None,
            }
        }
    }
}
/// Result of executing the `ExecutableCode`.
///
/// Only generated when using the `CodeExecution`, and always follows a `part`
/// containing the `ExecutableCode`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CodeExecutionResult {
    /// Required. Outcome of the code execution.
    #[prost(enumeration = "code_execution_result::Outcome", tag = "1")]
    pub outcome: i32,
    /// Optional. Contains stdout when code execution is successful, stderr or
    /// other description otherwise.
    #[prost(string, tag = "2")]
    pub output: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CodeExecutionResult`.
pub mod code_execution_result {
    /// Enumeration of possible outcomes of the code execution.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Outcome {
        /// Unspecified status. This value should not be used.
        Unspecified = 0,
        /// Code execution completed successfully.
        Ok = 1,
        /// Code execution finished but with a failure. `stderr` should contain the
        /// reason.
        Failed = 2,
        /// Code execution ran for too long, and was cancelled. There may or may not
        /// be a partial output present.
        DeadlineExceeded = 3,
    }
    impl Outcome {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OUTCOME_UNSPECIFIED",
                Self::Ok => "OUTCOME_OK",
                Self::Failed => "OUTCOME_FAILED",
                Self::DeadlineExceeded => "OUTCOME_DEADLINE_EXCEEDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OUTCOME_UNSPECIFIED" => Some(Self::Unspecified),
                "OUTCOME_OK" => Some(Self::Ok),
                "OUTCOME_FAILED" => Some(Self::Failed),
                "OUTCOME_DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
                _ => None,
            }
        }
    }
}
/// Tool details that the model may use to generate response.
///
/// A `Tool` is a piece of code that enables the system to interact with
/// external systems to perform an action, or set of actions, outside of
/// knowledge and scope of the model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tool {
    /// Optional. A list of `FunctionDeclarations` available to the model that can
    /// be used for function calling.
    ///
    /// The model or system does not execute the function. Instead the defined
    /// function may be returned as a
    /// [FunctionCall][google.ai.generativelanguage.v1alpha.Part.function_call]
    /// with arguments to the client side for execution. The model may decide to
    /// call a subset of these functions by populating
    /// [FunctionCall][google.ai.generativelanguage.v1alpha.Part.function_call] in
    /// the response. The next conversation turn may contain a
    /// [FunctionResponse][google.ai.generativelanguage.v1alpha.Part.function_response]
    /// with the [Content.role][google.ai.generativelanguage.v1alpha.Content.role]
    /// "function" generation context for the next model turn.
    #[prost(message, repeated, tag = "1")]
    pub function_declarations: ::prost::alloc::vec::Vec<FunctionDeclaration>,
    /// Optional. Retrieval tool that is powered by Google search.
    #[prost(message, optional, tag = "2")]
    pub google_search_retrieval: ::core::option::Option<GoogleSearchRetrieval>,
    /// Optional. Enables the model to execute code as part of generation.
    #[prost(message, optional, tag = "3")]
    pub code_execution: ::core::option::Option<CodeExecution>,
    /// Optional. GoogleSearch tool type.
    /// Tool to support Google Search in Model. Powered by Google.
    #[prost(message, optional, tag = "4")]
    pub google_search: ::core::option::Option<tool::GoogleSearch>,
}
/// Nested message and enum types in `Tool`.
pub mod tool {
    /// GoogleSearch tool type.
    /// Tool to support Google Search in Model. Powered by Google.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct GoogleSearch {}
}
/// Tool to retrieve public web data for grounding, powered by Google.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GoogleSearchRetrieval {
    /// Specifies the dynamic retrieval configuration for the given source.
    #[prost(message, optional, tag = "1")]
    pub dynamic_retrieval_config: ::core::option::Option<DynamicRetrievalConfig>,
}
/// Describes the options to customize dynamic retrieval.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DynamicRetrievalConfig {
    /// The mode of the predictor to be used in dynamic retrieval.
    #[prost(enumeration = "dynamic_retrieval_config::Mode", tag = "1")]
    pub mode: i32,
    /// The threshold to be used in dynamic retrieval.
    /// If not set, a system default value is used.
    #[prost(float, optional, tag = "2")]
    pub dynamic_threshold: ::core::option::Option<f32>,
}
/// Nested message and enum types in `DynamicRetrievalConfig`.
pub mod dynamic_retrieval_config {
    /// The mode of the predictor to be used in dynamic retrieval.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        /// Always trigger retrieval.
        Unspecified = 0,
        /// Run retrieval only when system decides it is necessary.
        Dynamic = 1,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODE_UNSPECIFIED",
                Self::Dynamic => "MODE_DYNAMIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "MODE_DYNAMIC" => Some(Self::Dynamic),
                _ => None,
            }
        }
    }
}
/// Tool that executes code generated by the model, and automatically returns
/// the result to the model.
///
/// See also `ExecutableCode` and `CodeExecutionResult` which are only generated
/// when using this tool.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CodeExecution {}
/// The Tool configuration containing parameters for specifying `Tool` use
/// in the request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolConfig {
    /// Optional. Function calling config.
    #[prost(message, optional, tag = "1")]
    pub function_calling_config: ::core::option::Option<FunctionCallingConfig>,
}
/// Configuration for specifying function calling behavior.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionCallingConfig {
    /// Optional. Specifies the mode in which function calling should execute. If
    /// unspecified, the default value will be set to AUTO.
    #[prost(enumeration = "function_calling_config::Mode", tag = "1")]
    pub mode: i32,
    /// Optional. A set of function names that, when provided, limits the functions
    /// the model will call.
    ///
    /// This should only be set when the Mode is ANY. Function names
    /// should match \[FunctionDeclaration.name\]. With mode set to ANY, model will
    /// predict a function call from the set of function names provided.
    #[prost(string, repeated, tag = "2")]
    pub allowed_function_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `FunctionCallingConfig`.
pub mod function_calling_config {
    /// Defines the execution behavior for function calling by defining the
    /// execution mode.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        /// Unspecified function calling mode. This value should not be used.
        Unspecified = 0,
        /// Default model behavior, model decides to predict either a function call
        /// or a natural language response.
        Auto = 1,
        /// Model is constrained to always predicting a function call only.
        /// If "allowed_function_names" are set, the predicted function call will be
        /// limited to any one of "allowed_function_names", else the predicted
        /// function call will be any one of the provided "function_declarations".
        Any = 2,
        /// Model will not predict any function call. Model behavior is same as when
        /// not passing any function declarations.
        None = 3,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODE_UNSPECIFIED",
                Self::Auto => "AUTO",
                Self::Any => "ANY",
                Self::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "AUTO" => Some(Self::Auto),
                "ANY" => Some(Self::Any),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
/// Structured representation of a function declaration as defined by the
/// [OpenAPI 3.03 specification](<https://spec.openapis.org/oas/v3.0.3>). Included
/// in this declaration are the function name and parameters. This
/// FunctionDeclaration is a representation of a block of code that can be used
/// as a `Tool` by the model and executed by the client.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionDeclaration {
    /// Required. The name of the function.
    /// Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum
    /// length of 63.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. A brief description of the function.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Optional. Describes the parameters to this function. Reflects the Open
    /// API 3.03 Parameter Object string Key: the name of the parameter. Parameter
    /// names are case sensitive. Schema Value: the Schema defining the type used
    /// for the parameter.
    #[prost(message, optional, tag = "3")]
    pub parameters: ::core::option::Option<Schema>,
    /// Optional. Describes the output from this function in JSON Schema format.
    /// Reflects the Open API 3.03 Response Object. The Schema defines the type
    /// used for the response value of the function.
    #[prost(message, optional, tag = "4")]
    pub response: ::core::option::Option<Schema>,
}
/// A predicted `FunctionCall` returned from the model that contains
/// a string representing the `FunctionDeclaration.name` with the
/// arguments and their values.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionCall {
    /// Optional. The unique id of the function call. If populated, the client to
    /// execute the `function_call` and return the response with the matching `id`.
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
    /// Required. The name of the function to call.
    /// Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum
    /// length of 63.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The function parameters and values in JSON object format.
    #[prost(message, optional, tag = "2")]
    pub args: ::core::option::Option<::prost_types::Struct>,
}
/// The result output from a `FunctionCall` that contains a string
/// representing the `FunctionDeclaration.name` and a structured JSON
/// object containing any output from the function is used as context to
/// the model. This should contain the result of a`FunctionCall` made
/// based on model prediction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionResponse {
    /// Optional. The id of the function call this response is for. Populated by
    /// the client to match the corresponding function call `id`.
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
    /// Required. The name of the function to call.
    /// Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum
    /// length of 63.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The function response in JSON object format.
    #[prost(message, optional, tag = "2")]
    pub response: ::core::option::Option<::prost_types::Struct>,
}
/// The `Schema` object allows the definition of input and output data types.
/// These types can be objects, but also primitives and arrays.
/// Represents a select subset of an [OpenAPI 3.0 schema
/// object](<https://spec.openapis.org/oas/v3.0.3#schema>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    /// Required. Data type.
    #[prost(enumeration = "Type", tag = "1")]
    pub r#type: i32,
    /// Optional. The format of the data. This is used only for primitive
    /// datatypes. Supported formats:
    ///   for NUMBER type: float, double
    ///   for INTEGER type: int32, int64
    ///   for STRING type: enum
    #[prost(string, tag = "2")]
    pub format: ::prost::alloc::string::String,
    /// Optional. A brief description of the parameter. This could contain examples
    /// of use. Parameter description may be formatted as Markdown.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Optional. Indicates if the value may be null.
    #[prost(bool, tag = "4")]
    pub nullable: bool,
    /// Optional. Possible values of the element of Type.STRING with enum format.
    /// For example we can define an Enum Direction as :
    /// {type:STRING, format:enum, enum:\["EAST", NORTH", "SOUTH", "WEST"\]}
    #[prost(string, repeated, tag = "5")]
    pub r#enum: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Schema of the elements of Type.ARRAY.
    #[prost(message, optional, boxed, tag = "6")]
    pub items: ::core::option::Option<::prost::alloc::boxed::Box<Schema>>,
    /// Optional. Maximum number of the elements for Type.ARRAY.
    #[prost(int64, tag = "21")]
    pub max_items: i64,
    /// Optional. Minimum number of the elements for Type.ARRAY.
    #[prost(int64, tag = "22")]
    pub min_items: i64,
    /// Optional. Properties of Type.OBJECT.
    #[prost(map = "string, message", tag = "7")]
    pub properties: ::std::collections::HashMap<::prost::alloc::string::String, Schema>,
    /// Optional. Required properties of Type.OBJECT.
    #[prost(string, repeated, tag = "8")]
    pub required: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Passage included inline with a grounding configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundingPassage {
    /// Identifier for the passage for attributing this passage in grounded
    /// answers.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Content of the passage.
    #[prost(message, optional, tag = "2")]
    pub content: ::core::option::Option<Content>,
}
/// A repeated list of passages.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundingPassages {
    /// List of passages.
    #[prost(message, repeated, tag = "1")]
    pub passages: ::prost::alloc::vec::Vec<GroundingPassage>,
}
/// Type contains the list of OpenAPI data types as defined by
/// <https://spec.openapis.org/oas/v3.0.3#data-types>
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
    /// Not specified, should not be used.
    Unspecified = 0,
    /// String type.
    String = 1,
    /// Number type.
    Number = 2,
    /// Integer type.
    Integer = 3,
    /// Boolean type.
    Boolean = 4,
    /// Array type.
    Array = 5,
    /// Object type.
    Object = 6,
}
impl Type {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TYPE_UNSPECIFIED",
            Self::String => "STRING",
            Self::Number => "NUMBER",
            Self::Integer => "INTEGER",
            Self::Boolean => "BOOLEAN",
            Self::Array => "ARRAY",
            Self::Object => "OBJECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "STRING" => Some(Self::String),
            "NUMBER" => Some(Self::Number),
            "INTEGER" => Some(Self::Integer),
            "BOOLEAN" => Some(Self::Boolean),
            "ARRAY" => Some(Self::Array),
            "OBJECT" => Some(Self::Object),
            _ => None,
        }
    }
}
/// Content that has been preprocessed and can be used in subsequent request
/// to GenerativeService.
///
/// Cached content can be only used with model it was created for.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CachedContent {
    /// Optional. Identifier. The resource name referring to the cached content.
    /// Format: `cachedContents/{id}`
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Immutable. The user-generated meaningful display name of the
    /// cached content. Maximum 128 Unicode characters.
    #[prost(string, optional, tag = "11")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. Immutable. The name of the `Model` to use for cached content
    /// Format: `models/{model}`
    #[prost(string, optional, tag = "2")]
    pub model: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Input only. Immutable. Developer set system instruction.
    /// Currently text only.
    #[prost(message, optional, tag = "3")]
    pub system_instruction: ::core::option::Option<Content>,
    /// Optional. Input only. Immutable. The content to cache.
    #[prost(message, repeated, tag = "4")]
    pub contents: ::prost::alloc::vec::Vec<Content>,
    /// Optional. Input only. Immutable. A list of `Tools` the model may use to
    /// generate the next response
    #[prost(message, repeated, tag = "5")]
    pub tools: ::prost::alloc::vec::Vec<Tool>,
    /// Optional. Input only. Immutable. Tool config. This config is shared for all
    /// tools.
    #[prost(message, optional, tag = "6")]
    pub tool_config: ::core::option::Option<ToolConfig>,
    /// Output only. Creation time of the cache entry.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. When the cache entry was last updated in UTC time.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Metadata on the usage of the cached content.
    #[prost(message, optional, tag = "12")]
    pub usage_metadata: ::core::option::Option<cached_content::UsageMetadata>,
    /// Specifies when this resource will expire.
    #[prost(oneof = "cached_content::Expiration", tags = "9, 10")]
    pub expiration: ::core::option::Option<cached_content::Expiration>,
}
/// Nested message and enum types in `CachedContent`.
pub mod cached_content {
    /// Metadata on the usage of the cached content.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UsageMetadata {
        /// Total number of tokens that the cached content consumes.
        #[prost(int32, tag = "1")]
        pub total_token_count: i32,
    }
    /// Specifies when this resource will expire.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Expiration {
        /// Timestamp in UTC of when this resource is considered expired.
        /// This is *always* provided on output, regardless of what was sent
        /// on input.
        #[prost(message, tag = "9")]
        ExpireTime(::prost_types::Timestamp),
        /// Input only. New TTL for this resource, input only.
        #[prost(message, tag = "10")]
        Ttl(::prost_types::Duration),
    }
}
/// Request to list CachedContents.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCachedContentsRequest {
    /// Optional. The maximum number of cached contents to return. The service may
    /// return fewer than this value. If unspecified, some default (under maximum)
    /// number of items will be returned. The maximum value is 1000; values above
    /// 1000 will be coerced to 1000.
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListCachedContents` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCachedContents` must
    /// match the call that provided the page token.
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response with CachedContents list.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCachedContentsResponse {
    /// List of cached contents.
    #[prost(message, repeated, tag = "1")]
    pub cached_contents: ::prost::alloc::vec::Vec<CachedContent>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request to create CachedContent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCachedContentRequest {
    /// Required. The cached content to create.
    #[prost(message, optional, tag = "1")]
    pub cached_content: ::core::option::Option<CachedContent>,
}
/// Request to read CachedContent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCachedContentRequest {
    /// Required. The resource name referring to the content cache entry.
    /// Format: `cachedContents/{id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request to update CachedContent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCachedContentRequest {
    /// Required. The content cache entry to update
    #[prost(message, optional, tag = "1")]
    pub cached_content: ::core::option::Option<CachedContent>,
    /// The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request to delete CachedContent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCachedContentRequest {
    /// Required. The resource name referring to the content cache entry
    /// Format: `cachedContents/{id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod cache_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// API for managing cache of content (CachedContent resources) that can be used
    /// in GenerativeService requests. This way generate content requests can benefit
    /// from preprocessing work being done earlier, possibly lowering their
    /// computational cost. It is intended to be used with large contexts.
    #[derive(Debug, Clone)]
    pub struct CacheServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CacheServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CacheServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CacheServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CacheServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists CachedContents.
        pub async fn list_cached_contents(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCachedContentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCachedContentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.CacheService/ListCachedContents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.CacheService",
                        "ListCachedContents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates CachedContent resource.
        pub async fn create_cached_content(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCachedContentRequest>,
        ) -> std::result::Result<tonic::Response<super::CachedContent>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.CacheService/CreateCachedContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.CacheService",
                        "CreateCachedContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Reads CachedContent resource.
        pub async fn get_cached_content(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCachedContentRequest>,
        ) -> std::result::Result<tonic::Response<super::CachedContent>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.CacheService/GetCachedContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.CacheService",
                        "GetCachedContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates CachedContent resource (only expiration is updatable).
        pub async fn update_cached_content(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCachedContentRequest>,
        ) -> std::result::Result<tonic::Response<super::CachedContent>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.CacheService/UpdateCachedContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.CacheService",
                        "UpdateCachedContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes CachedContent resource.
        pub async fn delete_cached_content(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCachedContentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.CacheService/DeleteCachedContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.CacheService",
                        "DeleteCachedContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// A collection of source attributions for a piece of content.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CitationMetadata {
    /// Citations to sources for a specific response.
    #[prost(message, repeated, tag = "1")]
    pub citation_sources: ::prost::alloc::vec::Vec<CitationSource>,
}
/// A citation to a source for a portion of a specific response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CitationSource {
    /// Optional. Start of segment of the response that is attributed to this
    /// source.
    ///
    /// Index indicates the start of the segment, measured in bytes.
    #[prost(int32, optional, tag = "1")]
    pub start_index: ::core::option::Option<i32>,
    /// Optional. End of the attributed segment, exclusive.
    #[prost(int32, optional, tag = "2")]
    pub end_index: ::core::option::Option<i32>,
    /// Optional. URI that is attributed as a source for a portion of the text.
    #[prost(string, optional, tag = "3")]
    pub uri: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. License for the GitHub project that is attributed as a source for
    /// segment.
    ///
    /// License info is required for code citations.
    #[prost(string, optional, tag = "4")]
    pub license: ::core::option::Option<::prost::alloc::string::String>,
}
/// Content filtering metadata associated with processing a single request.
///
/// ContentFilter contains a reason and an optional supporting string. The reason
/// may be unspecified.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContentFilter {
    /// The reason content was blocked during request processing.
    #[prost(enumeration = "content_filter::BlockedReason", tag = "1")]
    pub reason: i32,
    /// A string that describes the filtering behavior in more detail.
    #[prost(string, optional, tag = "2")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ContentFilter`.
pub mod content_filter {
    /// A list of reasons why content may have been blocked.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BlockedReason {
        /// A blocked reason was not specified.
        Unspecified = 0,
        /// Content was blocked by safety settings.
        Safety = 1,
        /// Content was blocked, but the reason is uncategorized.
        Other = 2,
    }
    impl BlockedReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BLOCKED_REASON_UNSPECIFIED",
                Self::Safety => "SAFETY",
                Self::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BLOCKED_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "SAFETY" => Some(Self::Safety),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
/// Safety feedback for an entire request.
///
/// This field is populated if content in the input and/or response is blocked
/// due to safety settings. SafetyFeedback may not exist for every HarmCategory.
/// Each SafetyFeedback will return the safety settings used by the request as
/// well as the lowest HarmProbability that should be allowed in order to return
/// a result.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SafetyFeedback {
    /// Safety rating evaluated from content.
    #[prost(message, optional, tag = "1")]
    pub rating: ::core::option::Option<SafetyRating>,
    /// Safety settings applied to the request.
    #[prost(message, optional, tag = "2")]
    pub setting: ::core::option::Option<SafetySetting>,
}
/// Safety rating for a piece of content.
///
/// The safety rating contains the category of harm and the
/// harm probability level in that category for a piece of content.
/// Content is classified for safety across a number of
/// harm categories and the probability of the harm classification is included
/// here.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SafetyRating {
    /// Required. The category for this rating.
    #[prost(enumeration = "HarmCategory", tag = "3")]
    pub category: i32,
    /// Required. The probability of harm for this content.
    #[prost(enumeration = "safety_rating::HarmProbability", tag = "4")]
    pub probability: i32,
    /// Was this content blocked because of this rating?
    #[prost(bool, tag = "5")]
    pub blocked: bool,
}
/// Nested message and enum types in `SafetyRating`.
pub mod safety_rating {
    /// The probability that a piece of content is harmful.
    ///
    /// The classification system gives the probability of the content being
    /// unsafe. This does not indicate the severity of harm for a piece of content.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HarmProbability {
        /// Probability is unspecified.
        Unspecified = 0,
        /// Content has a negligible chance of being unsafe.
        Negligible = 1,
        /// Content has a low chance of being unsafe.
        Low = 2,
        /// Content has a medium chance of being unsafe.
        Medium = 3,
        /// Content has a high chance of being unsafe.
        High = 4,
    }
    impl HarmProbability {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "HARM_PROBABILITY_UNSPECIFIED",
                Self::Negligible => "NEGLIGIBLE",
                Self::Low => "LOW",
                Self::Medium => "MEDIUM",
                Self::High => "HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HARM_PROBABILITY_UNSPECIFIED" => Some(Self::Unspecified),
                "NEGLIGIBLE" => Some(Self::Negligible),
                "LOW" => Some(Self::Low),
                "MEDIUM" => Some(Self::Medium),
                "HIGH" => Some(Self::High),
                _ => None,
            }
        }
    }
}
/// Safety setting, affecting the safety-blocking behavior.
///
/// Passing a safety setting for a category changes the allowed probability that
/// content is blocked.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SafetySetting {
    /// Required. The category for this setting.
    #[prost(enumeration = "HarmCategory", tag = "3")]
    pub category: i32,
    /// Required. Controls the probability threshold at which harm is blocked.
    #[prost(enumeration = "safety_setting::HarmBlockThreshold", tag = "4")]
    pub threshold: i32,
}
/// Nested message and enum types in `SafetySetting`.
pub mod safety_setting {
    /// Block at and beyond a specified harm probability.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HarmBlockThreshold {
        /// Threshold is unspecified.
        Unspecified = 0,
        /// Content with NEGLIGIBLE will be allowed.
        BlockLowAndAbove = 1,
        /// Content with NEGLIGIBLE and LOW will be allowed.
        BlockMediumAndAbove = 2,
        /// Content with NEGLIGIBLE, LOW, and MEDIUM will be allowed.
        BlockOnlyHigh = 3,
        /// All content will be allowed.
        BlockNone = 4,
        /// Turn off the safety filter.
        Off = 5,
    }
    impl HarmBlockThreshold {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
                Self::BlockLowAndAbove => "BLOCK_LOW_AND_ABOVE",
                Self::BlockMediumAndAbove => "BLOCK_MEDIUM_AND_ABOVE",
                Self::BlockOnlyHigh => "BLOCK_ONLY_HIGH",
                Self::BlockNone => "BLOCK_NONE",
                Self::Off => "OFF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HARM_BLOCK_THRESHOLD_UNSPECIFIED" => Some(Self::Unspecified),
                "BLOCK_LOW_AND_ABOVE" => Some(Self::BlockLowAndAbove),
                "BLOCK_MEDIUM_AND_ABOVE" => Some(Self::BlockMediumAndAbove),
                "BLOCK_ONLY_HIGH" => Some(Self::BlockOnlyHigh),
                "BLOCK_NONE" => Some(Self::BlockNone),
                "OFF" => Some(Self::Off),
                _ => None,
            }
        }
    }
}
/// The category of a rating.
///
/// These categories cover various kinds of harms that developers
/// may wish to adjust.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HarmCategory {
    /// Category is unspecified.
    Unspecified = 0,
    /// **PaLM** - Negative or harmful comments targeting identity and/or protected
    /// attribute.
    Derogatory = 1,
    /// **PaLM** - Content that is rude, disrespectful, or profane.
    Toxicity = 2,
    /// **PaLM** - Describes scenarios depicting violence against an individual or
    /// group, or general descriptions of gore.
    Violence = 3,
    /// **PaLM** - Contains references to sexual acts or other lewd content.
    Sexual = 4,
    /// **PaLM** - Promotes unchecked medical advice.
    Medical = 5,
    /// **PaLM** - Dangerous content that promotes, facilitates, or encourages
    /// harmful acts.
    Dangerous = 6,
    /// **Gemini** - Harassment content.
    Harassment = 7,
    /// **Gemini** - Hate speech and content.
    HateSpeech = 8,
    /// **Gemini** - Sexually explicit content.
    SexuallyExplicit = 9,
    /// **Gemini** - Dangerous content.
    DangerousContent = 10,
    /// **Gemini** - Content that may be used to harm civic integrity.
    CivicIntegrity = 11,
}
impl HarmCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "HARM_CATEGORY_UNSPECIFIED",
            Self::Derogatory => "HARM_CATEGORY_DEROGATORY",
            Self::Toxicity => "HARM_CATEGORY_TOXICITY",
            Self::Violence => "HARM_CATEGORY_VIOLENCE",
            Self::Sexual => "HARM_CATEGORY_SEXUAL",
            Self::Medical => "HARM_CATEGORY_MEDICAL",
            Self::Dangerous => "HARM_CATEGORY_DANGEROUS",
            Self::Harassment => "HARM_CATEGORY_HARASSMENT",
            Self::HateSpeech => "HARM_CATEGORY_HATE_SPEECH",
            Self::SexuallyExplicit => "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            Self::DangerousContent => "HARM_CATEGORY_DANGEROUS_CONTENT",
            Self::CivicIntegrity => "HARM_CATEGORY_CIVIC_INTEGRITY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HARM_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
            "HARM_CATEGORY_DEROGATORY" => Some(Self::Derogatory),
            "HARM_CATEGORY_TOXICITY" => Some(Self::Toxicity),
            "HARM_CATEGORY_VIOLENCE" => Some(Self::Violence),
            "HARM_CATEGORY_SEXUAL" => Some(Self::Sexual),
            "HARM_CATEGORY_MEDICAL" => Some(Self::Medical),
            "HARM_CATEGORY_DANGEROUS" => Some(Self::Dangerous),
            "HARM_CATEGORY_HARASSMENT" => Some(Self::Harassment),
            "HARM_CATEGORY_HATE_SPEECH" => Some(Self::HateSpeech),
            "HARM_CATEGORY_SEXUALLY_EXPLICIT" => Some(Self::SexuallyExplicit),
            "HARM_CATEGORY_DANGEROUS_CONTENT" => Some(Self::DangerousContent),
            "HARM_CATEGORY_CIVIC_INTEGRITY" => Some(Self::CivicIntegrity),
            _ => None,
        }
    }
}
/// Request to generate a message response from the model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateMessageRequest {
    /// Required. The name of the model to use.
    ///
    /// Format: `name=models/{model}`.
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    /// Required. The structured textual input given to the model as a prompt.
    ///
    /// Given a
    /// prompt, the model will return what it predicts is the next message in the
    /// discussion.
    #[prost(message, optional, tag = "2")]
    pub prompt: ::core::option::Option<MessagePrompt>,
    /// Optional. Controls the randomness of the output.
    ///
    /// Values can range over `\[0.0,1.0\]`,
    /// inclusive. A value closer to `1.0` will produce responses that are more
    /// varied, while a value closer to `0.0` will typically result in
    /// less surprising responses from the model.
    #[prost(float, optional, tag = "3")]
    pub temperature: ::core::option::Option<f32>,
    /// Optional. The number of generated response messages to return.
    ///
    /// This value must be between
    /// `\[1, 8\]`, inclusive. If unset, this will default to `1`.
    #[prost(int32, optional, tag = "4")]
    pub candidate_count: ::core::option::Option<i32>,
    /// Optional. The maximum cumulative probability of tokens to consider when
    /// sampling.
    ///
    /// The model uses combined Top-k and nucleus sampling.
    ///
    /// Nucleus sampling considers the smallest set of tokens whose probability
    /// sum is at least `top_p`.
    #[prost(float, optional, tag = "5")]
    pub top_p: ::core::option::Option<f32>,
    /// Optional. The maximum number of tokens to consider when sampling.
    ///
    /// The model uses combined Top-k and nucleus sampling.
    ///
    /// Top-k sampling considers the set of `top_k` most probable tokens.
    #[prost(int32, optional, tag = "6")]
    pub top_k: ::core::option::Option<i32>,
}
/// The response from the model.
///
/// This includes candidate messages and
/// conversation history in the form of chronologically-ordered messages.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateMessageResponse {
    /// Candidate response messages from the model.
    #[prost(message, repeated, tag = "1")]
    pub candidates: ::prost::alloc::vec::Vec<Message>,
    /// The conversation history used by the model.
    #[prost(message, repeated, tag = "2")]
    pub messages: ::prost::alloc::vec::Vec<Message>,
    /// A set of content filtering metadata for the prompt and response
    /// text.
    ///
    /// This indicates which `SafetyCategory`(s) blocked a
    /// candidate from this response, the lowest `HarmProbability`
    /// that triggered a block, and the HarmThreshold setting for that category.
    #[prost(message, repeated, tag = "3")]
    pub filters: ::prost::alloc::vec::Vec<ContentFilter>,
}
/// The base unit of structured text.
///
/// A `Message` includes an `author` and the `content` of
/// the `Message`.
///
/// The `author` is used to tag messages when they are fed to the
/// model as text.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
    /// Optional. The author of this Message.
    ///
    /// This serves as a key for tagging
    /// the content of this Message when it is fed to the model as text.
    ///
    /// The author can be any alphanumeric string.
    #[prost(string, tag = "1")]
    pub author: ::prost::alloc::string::String,
    /// Required. The text content of the structured `Message`.
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    /// Output only. Citation information for model-generated `content` in this
    /// `Message`.
    ///
    /// If this `Message` was generated as output from the model, this field may be
    /// populated with attribution information for any text included in the
    /// `content`. This field is used only on output.
    #[prost(message, optional, tag = "3")]
    pub citation_metadata: ::core::option::Option<CitationMetadata>,
}
/// All of the structured input text passed to the model as a prompt.
///
/// A `MessagePrompt` contains a structured set of fields that provide context
/// for the conversation, examples of user input/model output message pairs that
/// prime the model to respond in different ways, and the conversation history
/// or list of messages representing the alternating turns of the conversation
/// between the user and the model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessagePrompt {
    /// Optional. Text that should be provided to the model first to ground the
    /// response.
    ///
    /// If not empty, this `context` will be given to the model first before the
    /// `examples` and `messages`. When using a `context` be sure to provide it
    /// with every request to maintain continuity.
    ///
    /// This field can be a description of your prompt to the model to help provide
    /// context and guide the responses. Examples: "Translate the phrase from
    /// English to French." or "Given a statement, classify the sentiment as happy,
    /// sad or neutral."
    ///
    /// Anything included in this field will take precedence over message history
    /// if the total input size exceeds the model's `input_token_limit` and the
    /// input request is truncated.
    #[prost(string, tag = "1")]
    pub context: ::prost::alloc::string::String,
    /// Optional. Examples of what the model should generate.
    ///
    /// This includes both user input and the response that the model should
    /// emulate.
    ///
    /// These `examples` are treated identically to conversation messages except
    /// that they take precedence over the history in `messages`:
    /// If the total input size exceeds the model's `input_token_limit` the input
    /// will be truncated. Items will be dropped from `messages` before `examples`.
    #[prost(message, repeated, tag = "2")]
    pub examples: ::prost::alloc::vec::Vec<Example>,
    /// Required. A snapshot of the recent conversation history sorted
    /// chronologically.
    ///
    /// Turns alternate between two authors.
    ///
    /// If the total input size exceeds the model's `input_token_limit` the input
    /// will be truncated: The oldest items will be dropped from `messages`.
    #[prost(message, repeated, tag = "3")]
    pub messages: ::prost::alloc::vec::Vec<Message>,
}
/// An input/output example used to instruct the Model.
///
/// It demonstrates how the model should respond or format its response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Example {
    /// Required. An example of an input `Message` from the user.
    #[prost(message, optional, tag = "1")]
    pub input: ::core::option::Option<Message>,
    /// Required. An example of what the model should output given the input.
    #[prost(message, optional, tag = "2")]
    pub output: ::core::option::Option<Message>,
}
/// Counts the number of tokens in the `prompt` sent to a model.
///
/// Models may tokenize text differently, so each model may return a different
/// `token_count`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountMessageTokensRequest {
    /// Required. The model's resource name. This serves as an ID for the Model to
    /// use.
    ///
    /// This name should match a model name returned by the `ListModels` method.
    ///
    /// Format: `models/{model}`
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    /// Required. The prompt, whose token count is to be returned.
    #[prost(message, optional, tag = "2")]
    pub prompt: ::core::option::Option<MessagePrompt>,
}
/// A response from `CountMessageTokens`.
///
/// It returns the model's `token_count` for the `prompt`.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CountMessageTokensResponse {
    /// The number of tokens that the `model` tokenizes the `prompt` into.
    ///
    /// Always non-negative.
    #[prost(int32, tag = "1")]
    pub token_count: i32,
}
/// Generated client implementations.
pub mod discuss_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// An API for using Generative Language Models (GLMs) in dialog applications.
    ///
    /// Also known as large language models (LLMs), this API provides models that
    /// are trained for multi-turn dialog.
    #[derive(Debug, Clone)]
    pub struct DiscussServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DiscussServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DiscussServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DiscussServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DiscussServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Generates a response from the model given an input `MessagePrompt`.
        pub async fn generate_message(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateMessageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateMessageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.DiscussService/GenerateMessage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.DiscussService",
                        "GenerateMessage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Runs a model's tokenizer on a string and returns the token count.
        pub async fn count_message_tokens(
            &mut self,
            request: impl tonic::IntoRequest<super::CountMessageTokensRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CountMessageTokensResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.DiscussService/CountMessageTokens",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.DiscussService",
                        "CountMessageTokens",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// A file uploaded to the API.
/// Next ID: 15
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct File {
    /// Immutable. Identifier. The `File` resource name. The ID (name excluding the
    /// "files/" prefix) can contain up to 40 characters that are lowercase
    /// alphanumeric or dashes (-). The ID cannot start or end with a dash. If the
    /// name is empty on create, a unique name will be generated. Example:
    /// `files/123-456`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The human-readable display name for the `File`. The display name
    /// must be no more than 512 characters in length, including spaces. Example:
    /// "Welcome Image"
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. MIME type of the file.
    #[prost(string, tag = "3")]
    pub mime_type: ::prost::alloc::string::String,
    /// Output only. Size of the file in bytes.
    #[prost(int64, tag = "4")]
    pub size_bytes: i64,
    /// Output only. The timestamp of when the `File` was created.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp of when the `File` was last updated.
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp of when the `File` will be deleted. Only set if
    /// the `File` is scheduled to expire.
    #[prost(message, optional, tag = "7")]
    pub expiration_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. SHA-256 hash of the uploaded bytes.
    #[prost(bytes = "vec", tag = "8")]
    pub sha256_hash: ::prost::alloc::vec::Vec<u8>,
    /// Output only. The uri of the `File`.
    #[prost(string, tag = "9")]
    pub uri: ::prost::alloc::string::String,
    /// Output only. Processing state of the File.
    #[prost(enumeration = "file::State", tag = "10")]
    pub state: i32,
    /// Output only. Error status if File processing failed.
    #[prost(message, optional, tag = "11")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    /// Metadata for the File.
    #[prost(oneof = "file::Metadata", tags = "12")]
    pub metadata: ::core::option::Option<file::Metadata>,
}
/// Nested message and enum types in `File`.
pub mod file {
    /// States for the lifecycle of a File.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified = 0,
        /// File is being processed and cannot be used for inference yet.
        Processing = 1,
        /// File is processed and available for inference.
        Active = 2,
        /// File failed processing.
        Failed = 10,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Processing => "PROCESSING",
                Self::Active => "ACTIVE",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROCESSING" => Some(Self::Processing),
                "ACTIVE" => Some(Self::Active),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    /// Metadata for the File.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Metadata {
        /// Output only. Metadata for a video.
        #[prost(message, tag = "12")]
        VideoMetadata(super::VideoMetadata),
    }
}
/// Metadata for a video `File`.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VideoMetadata {
    /// Duration of the video.
    #[prost(message, optional, tag = "1")]
    pub video_duration: ::core::option::Option<::prost_types::Duration>,
}
/// Request for `CreateFile`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFileRequest {
    /// Optional. Metadata for the file to create.
    #[prost(message, optional, tag = "1")]
    pub file: ::core::option::Option<File>,
}
/// Response for `CreateFile`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFileResponse {
    /// Metadata for the created file.
    #[prost(message, optional, tag = "1")]
    pub file: ::core::option::Option<File>,
}
/// Request for `ListFiles`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFilesRequest {
    /// Optional. Maximum number of `File`s to return per page.
    /// If unspecified, defaults to 10. Maximum `page_size` is 100.
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    /// Optional. A page token from a previous `ListFiles` call.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response for `ListFiles`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFilesResponse {
    /// The list of `File`s.
    #[prost(message, repeated, tag = "1")]
    pub files: ::prost::alloc::vec::Vec<File>,
    /// A token that can be sent as a `page_token` into a subsequent `ListFiles`
    /// call.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request for `GetFile`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFileRequest {
    /// Required. The name of the `File` to get.
    /// Example: `files/abc-123`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for `DeleteFile`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFileRequest {
    /// Required. The name of the `File` to delete.
    /// Example: `files/abc-123`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod file_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// An API for uploading and managing files.
    #[derive(Debug, Clone)]
    pub struct FileServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl FileServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> FileServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FileServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            FileServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a `File`.
        pub async fn create_file(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateFileResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.FileService/CreateFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.FileService",
                        "CreateFile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the metadata for `File`s owned by the requesting project.
        pub async fn list_files(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFilesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFilesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.FileService/ListFiles",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.FileService",
                        "ListFiles",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the metadata for the given `File`.
        pub async fn get_file(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFileRequest>,
        ) -> std::result::Result<tonic::Response<super::File>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.FileService/GetFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.FileService",
                        "GetFile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the `File`.
        pub async fn delete_file(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFileRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.FileService/DeleteFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.FileService",
                        "DeleteFile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// A `Corpus` is a collection of `Document`s.
/// A project can create up to 5 corpora.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Corpus {
    /// Immutable. Identifier. The `Corpus` resource name. The ID (name excluding
    /// the "corpora/" prefix) can contain up to 40 characters that are lowercase
    /// alphanumeric or dashes
    /// (-). The ID cannot start or end with a dash. If the name is empty on
    /// create, a unique name will be derived from `display_name` along with a 12
    /// character random suffix.
    /// Example: `corpora/my-awesome-corpora-123a456b789c`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The human-readable display name for the `Corpus`. The display
    /// name must be no more than 512 characters in length, including spaces.
    /// Example: "Docs on Semantic Retriever"
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The Timestamp of when the `Corpus` was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The Timestamp of when the `Corpus` was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// A `Document` is a collection of `Chunk`s.
/// A `Corpus` can have a maximum of 10,000 `Document`s.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Document {
    /// Immutable. Identifier. The `Document` resource name. The ID (name excluding
    /// the "corpora/*/documents/" prefix) can contain up to 40 characters that are
    /// lowercase alphanumeric or dashes (-). The ID cannot start or end with a
    /// dash. If the name is empty on create, a unique name will be derived from
    /// `display_name` along with a 12 character random suffix.
    /// Example: `corpora/{corpus_id}/documents/my-awesome-doc-123a456b789c`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The human-readable display name for the `Document`. The display
    /// name must be no more than 512 characters in length, including spaces.
    /// Example: "Semantic Retriever Documentation"
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. User provided custom metadata stored as key-value pairs used for
    /// querying. A `Document` can have a maximum of 20 `CustomMetadata`.
    #[prost(message, repeated, tag = "3")]
    pub custom_metadata: ::prost::alloc::vec::Vec<CustomMetadata>,
    /// Output only. The Timestamp of when the `Document` was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The Timestamp of when the `Document` was created.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// User provided string values assigned to a single metadata key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringList {
    /// The string values of the metadata to store.
    #[prost(string, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// User provided metadata stored as key-value pairs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomMetadata {
    /// Required. The key of the metadata to store.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(oneof = "custom_metadata::Value", tags = "2, 6, 7")]
    pub value: ::core::option::Option<custom_metadata::Value>,
}
/// Nested message and enum types in `CustomMetadata`.
pub mod custom_metadata {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        /// The string value of the metadata to store.
        #[prost(string, tag = "2")]
        StringValue(::prost::alloc::string::String),
        /// The StringList value of the metadata to store.
        #[prost(message, tag = "6")]
        StringListValue(super::StringList),
        /// The numeric value of the metadata to store.
        #[prost(float, tag = "7")]
        NumericValue(f32),
    }
}
/// User provided filter to limit retrieval based on `Chunk` or `Document` level
/// metadata values.
/// Example (genre = drama OR genre = action):
///    key = "document.custom_metadata.genre"
///    conditions = [{string_value = "drama", operation = EQUAL},
///                  {string_value = "action", operation = EQUAL}]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataFilter {
    /// Required. The key of the metadata to filter on.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// Required. The `Condition`s for the given key that will trigger this filter.
    /// Multiple `Condition`s are joined by logical ORs.
    #[prost(message, repeated, tag = "2")]
    pub conditions: ::prost::alloc::vec::Vec<Condition>,
}
/// Filter condition applicable to a single key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Condition {
    /// Required. Operator applied to the given key-value pair to trigger the
    /// condition.
    #[prost(enumeration = "condition::Operator", tag = "5")]
    pub operation: i32,
    /// The value type must be consistent with the value type defined in the field
    /// for the corresponding key. If the value types are not consistent, the
    /// result will be an empty set. When the `CustomMetadata` has a `StringList`
    /// value type, the filtering condition should use `string_value` paired with
    /// an INCLUDES/EXCLUDES operation, otherwise the result will also be an empty
    /// set.
    #[prost(oneof = "condition::Value", tags = "1, 6")]
    pub value: ::core::option::Option<condition::Value>,
}
/// Nested message and enum types in `Condition`.
pub mod condition {
    /// Defines the valid operators that can be applied to a key-value pair.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Operator {
        /// The default value. This value is unused.
        Unspecified = 0,
        /// Supported by numeric.
        Less = 1,
        /// Supported by numeric.
        LessEqual = 2,
        /// Supported by numeric & string.
        Equal = 3,
        /// Supported by numeric.
        GreaterEqual = 4,
        /// Supported by numeric.
        Greater = 5,
        /// Supported by numeric & string.
        NotEqual = 6,
        /// Supported by string only when `CustomMetadata` value type for the given
        /// key has a `string_list_value`.
        Includes = 7,
        /// Supported by string only when `CustomMetadata` value type for the given
        /// key has a `string_list_value`.
        Excludes = 8,
    }
    impl Operator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OPERATOR_UNSPECIFIED",
                Self::Less => "LESS",
                Self::LessEqual => "LESS_EQUAL",
                Self::Equal => "EQUAL",
                Self::GreaterEqual => "GREATER_EQUAL",
                Self::Greater => "GREATER",
                Self::NotEqual => "NOT_EQUAL",
                Self::Includes => "INCLUDES",
                Self::Excludes => "EXCLUDES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                "LESS" => Some(Self::Less),
                "LESS_EQUAL" => Some(Self::LessEqual),
                "EQUAL" => Some(Self::Equal),
                "GREATER_EQUAL" => Some(Self::GreaterEqual),
                "GREATER" => Some(Self::Greater),
                "NOT_EQUAL" => Some(Self::NotEqual),
                "INCLUDES" => Some(Self::Includes),
                "EXCLUDES" => Some(Self::Excludes),
                _ => None,
            }
        }
    }
    /// The value type must be consistent with the value type defined in the field
    /// for the corresponding key. If the value types are not consistent, the
    /// result will be an empty set. When the `CustomMetadata` has a `StringList`
    /// value type, the filtering condition should use `string_value` paired with
    /// an INCLUDES/EXCLUDES operation, otherwise the result will also be an empty
    /// set.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        /// The string value to filter the metadata on.
        #[prost(string, tag = "1")]
        StringValue(::prost::alloc::string::String),
        /// The numeric value to filter the metadata on.
        #[prost(float, tag = "6")]
        NumericValue(f32),
    }
}
/// A `Chunk` is a subpart of a `Document` that is treated as an independent unit
/// for the purposes of vector representation and storage.
/// A `Corpus` can have a maximum of 1 million `Chunk`s.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Chunk {
    /// Immutable. Identifier. The `Chunk` resource name. The ID (name excluding
    /// the "corpora/*/documents/*/chunks/" prefix) can contain up to 40 characters
    /// that are lowercase alphanumeric or dashes (-). The ID cannot start or end
    /// with a dash. If the name is empty on create, a random 12-character unique
    /// ID will be generated.
    /// Example: `corpora/{corpus_id}/documents/{document_id}/chunks/123a456b789c`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The content for the `Chunk`, such as the text string.
    /// The maximum number of tokens per chunk is 2043.
    #[prost(message, optional, tag = "2")]
    pub data: ::core::option::Option<ChunkData>,
    /// Optional. User provided custom metadata stored as key-value pairs.
    /// The maximum number of `CustomMetadata` per chunk is 20.
    #[prost(message, repeated, tag = "3")]
    pub custom_metadata: ::prost::alloc::vec::Vec<CustomMetadata>,
    /// Output only. The Timestamp of when the `Chunk` was created.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The Timestamp of when the `Chunk` was last updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Current state of the `Chunk`.
    #[prost(enumeration = "chunk::State", tag = "6")]
    pub state: i32,
}
/// Nested message and enum types in `Chunk`.
pub mod chunk {
    /// States for the lifecycle of a `Chunk`.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified = 0,
        /// `Chunk` is being processed (embedding and vector storage).
        PendingProcessing = 1,
        /// `Chunk` is processed and available for querying.
        Active = 2,
        /// `Chunk` failed processing.
        Failed = 10,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::PendingProcessing => "STATE_PENDING_PROCESSING",
                Self::Active => "STATE_ACTIVE",
                Self::Failed => "STATE_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "STATE_PENDING_PROCESSING" => Some(Self::PendingProcessing),
                "STATE_ACTIVE" => Some(Self::Active),
                "STATE_FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Extracted data that represents the `Chunk` content.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkData {
    #[prost(oneof = "chunk_data::Data", tags = "1")]
    pub data: ::core::option::Option<chunk_data::Data>,
}
/// Nested message and enum types in `ChunkData`.
pub mod chunk_data {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        /// The `Chunk` content as a string.
        /// The maximum number of tokens per chunk is 2043.
        #[prost(string, tag = "1")]
        StringValue(::prost::alloc::string::String),
    }
}
/// Request to generate a completion from the model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateContentRequest {
    /// Required. The name of the `Model` to use for generating the completion.
    ///
    /// Format: `models/{model}`.
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    /// Optional. Developer set [system
    /// instruction(s)](<https://ai.google.dev/gemini-api/docs/system-instructions>).
    /// Currently, text only.
    #[prost(message, optional, tag = "8")]
    pub system_instruction: ::core::option::Option<Content>,
    /// Required. The content of the current conversation with the model.
    ///
    /// For single-turn queries, this is a single instance. For multi-turn queries
    /// like [chat](<https://ai.google.dev/gemini-api/docs/text-generation#chat>),
    /// this is a repeated field that contains the conversation history and the
    /// latest request.
    #[prost(message, repeated, tag = "2")]
    pub contents: ::prost::alloc::vec::Vec<Content>,
    /// Optional. A list of `Tools` the `Model` may use to generate the next
    /// response.
    ///
    /// A `Tool` is a piece of code that enables the system to interact with
    /// external systems to perform an action, or set of actions, outside of
    /// knowledge and scope of the `Model`. Supported `Tool`s are `Function` and
    /// `code_execution`. Refer to the [Function
    /// calling](<https://ai.google.dev/gemini-api/docs/function-calling>) and the
    /// [Code execution](<https://ai.google.dev/gemini-api/docs/code-execution>)
    /// guides to learn more.
    #[prost(message, repeated, tag = "5")]
    pub tools: ::prost::alloc::vec::Vec<Tool>,
    /// Optional. Tool configuration for any `Tool` specified in the request. Refer
    /// to the [Function calling
    /// guide](<https://ai.google.dev/gemini-api/docs/function-calling#function_calling_mode>)
    /// for a usage example.
    #[prost(message, optional, tag = "7")]
    pub tool_config: ::core::option::Option<ToolConfig>,
    /// Optional. A list of unique `SafetySetting` instances for blocking unsafe
    /// content.
    ///
    /// This will be enforced on the `GenerateContentRequest.contents` and
    /// `GenerateContentResponse.candidates`. There should not be more than one
    /// setting for each `SafetyCategory` type. The API will block any contents and
    /// responses that fail to meet the thresholds set by these settings. This list
    /// overrides the default settings for each `SafetyCategory` specified in the
    /// safety_settings. If there is no `SafetySetting` for a given
    /// `SafetyCategory` provided in the list, the API will use the default safety
    /// setting for that category. Harm categories HARM_CATEGORY_HATE_SPEECH,
    /// HARM_CATEGORY_SEXUALLY_EXPLICIT, HARM_CATEGORY_DANGEROUS_CONTENT,
    /// HARM_CATEGORY_HARASSMENT, HARM_CATEGORY_CIVIC_INTEGRITY are supported.
    /// Refer to the [guide](<https://ai.google.dev/gemini-api/docs/safety-settings>)
    /// for detailed information on available safety settings. Also refer to the
    /// [Safety guidance](<https://ai.google.dev/gemini-api/docs/safety-guidance>) to
    /// learn how to incorporate safety considerations in your AI applications.
    #[prost(message, repeated, tag = "3")]
    pub safety_settings: ::prost::alloc::vec::Vec<SafetySetting>,
    /// Optional. Configuration options for model generation and outputs.
    #[prost(message, optional, tag = "4")]
    pub generation_config: ::core::option::Option<GenerationConfig>,
    /// Optional. The name of the content
    /// [cached](<https://ai.google.dev/gemini-api/docs/caching>) to use as context
    /// to serve the prediction. Format: `cachedContents/{cachedContent}`
    #[prost(string, optional, tag = "9")]
    pub cached_content: ::core::option::Option<::prost::alloc::string::String>,
}
/// The configuration for the prebuilt speaker to use.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrebuiltVoiceConfig {
    /// The name of the preset voice to use.
    #[prost(string, optional, tag = "1")]
    pub voice_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// The configuration for the voice to use.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VoiceConfig {
    /// The configuration for the speaker to use.
    #[prost(oneof = "voice_config::VoiceConfig", tags = "1")]
    pub voice_config: ::core::option::Option<voice_config::VoiceConfig>,
}
/// Nested message and enum types in `VoiceConfig`.
pub mod voice_config {
    /// The configuration for the speaker to use.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum VoiceConfig {
        /// The configuration for the prebuilt voice to use.
        #[prost(message, tag = "1")]
        PrebuiltVoiceConfig(super::PrebuiltVoiceConfig),
    }
}
/// The speech generation config.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpeechConfig {
    /// The configuration for the speaker to use.
    #[prost(message, optional, tag = "1")]
    pub voice_config: ::core::option::Option<VoiceConfig>,
}
/// Configuration options for model generation and outputs. Not all parameters
/// are configurable for every model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerationConfig {
    /// Optional. Number of generated responses to return.
    ///
    /// Currently, this value can only be set to 1. If unset, this will default
    /// to 1.
    #[prost(int32, optional, tag = "1")]
    pub candidate_count: ::core::option::Option<i32>,
    /// Optional. The set of character sequences (up to 5) that will stop output
    /// generation. If specified, the API will stop at the first appearance of a
    /// `stop_sequence`. The stop sequence will not be included as part of the
    /// response.
    #[prost(string, repeated, tag = "2")]
    pub stop_sequences: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The maximum number of tokens to include in a response candidate.
    ///
    /// Note: The default value varies by model, see the `Model.output_token_limit`
    /// attribute of the `Model` returned from the `getModel` function.
    #[prost(int32, optional, tag = "4")]
    pub max_output_tokens: ::core::option::Option<i32>,
    /// Optional. Controls the randomness of the output.
    ///
    /// Note: The default value varies by model, see the `Model.temperature`
    /// attribute of the `Model` returned from the `getModel` function.
    ///
    /// Values can range from \[0.0, 2.0\].
    #[prost(float, optional, tag = "5")]
    pub temperature: ::core::option::Option<f32>,
    /// Optional. The maximum cumulative probability of tokens to consider when
    /// sampling.
    ///
    /// The model uses combined Top-k and Top-p (nucleus) sampling.
    ///
    /// Tokens are sorted based on their assigned probabilities so that only the
    /// most likely tokens are considered. Top-k sampling directly limits the
    /// maximum number of tokens to consider, while Nucleus sampling limits the
    /// number of tokens based on the cumulative probability.
    ///
    /// Note: The default value varies by `Model` and is specified by
    /// the`Model.top_p` attribute returned from the `getModel` function. An empty
    /// `top_k` attribute indicates that the model doesn't apply top-k sampling
    /// and doesn't allow setting `top_k` on requests.
    #[prost(float, optional, tag = "6")]
    pub top_p: ::core::option::Option<f32>,
    /// Optional. The maximum number of tokens to consider when sampling.
    ///
    /// Gemini models use Top-p (nucleus) sampling or a combination of Top-k and
    /// nucleus sampling. Top-k sampling considers the set of `top_k` most probable
    /// tokens. Models running with nucleus sampling don't allow top_k setting.
    ///
    /// Note: The default value varies by `Model` and is specified by
    /// the`Model.top_p` attribute returned from the `getModel` function. An empty
    /// `top_k` attribute indicates that the model doesn't apply top-k sampling
    /// and doesn't allow setting `top_k` on requests.
    #[prost(int32, optional, tag = "7")]
    pub top_k: ::core::option::Option<i32>,
    /// Optional. MIME type of the generated candidate text.
    /// Supported MIME types are:
    /// `text/plain`: (default) Text output.
    /// `application/json`: JSON response in the response candidates.
    /// `text/x.enum`: ENUM as a string response in the response candidates.
    /// Refer to the
    /// [docs](<https://ai.google.dev/gemini-api/docs/prompting_with_media#plain_text_formats>)
    /// for a list of all supported text MIME types.
    #[prost(string, tag = "13")]
    pub response_mime_type: ::prost::alloc::string::String,
    /// Optional. Output schema of the generated candidate text. Schemas must be a
    /// subset of the [OpenAPI schema](<https://spec.openapis.org/oas/v3.0.3#schema>)
    /// and can be objects, primitives or arrays.
    ///
    /// If set, a compatible `response_mime_type` must also be set.
    /// Compatible MIME types:
    /// `application/json`: Schema for JSON response.
    /// Refer to the [JSON text generation
    /// guide](<https://ai.google.dev/gemini-api/docs/json-mode>) for more details.
    #[prost(message, optional, tag = "14")]
    pub response_schema: ::core::option::Option<Schema>,
    /// Optional. Presence penalty applied to the next token's logprobs if the
    /// token has already been seen in the response.
    ///
    /// This penalty is binary on/off and not dependant on the number of times the
    /// token is used (after the first). Use
    /// [frequency_penalty][google.ai.generativelanguage.v1alpha.GenerationConfig.frequency_penalty]
    /// for a penalty that increases with each use.
    ///
    /// A positive penalty will discourage the use of tokens that have already
    /// been used in the response, increasing the vocabulary.
    ///
    /// A negative penalty will encourage the use of tokens that have already been
    /// used in the response, decreasing the vocabulary.
    #[prost(float, optional, tag = "15")]
    pub presence_penalty: ::core::option::Option<f32>,
    /// Optional. Frequency penalty applied to the next token's logprobs,
    /// multiplied by the number of times each token has been seen in the respponse
    /// so far.
    ///
    /// A positive penalty will discourage the use of tokens that have already
    /// been used, proportional to the number of times the token has been used:
    /// The more a token is used, the more dificult it is for the model to use
    /// that token again increasing the vocabulary of responses.
    ///
    /// Caution: A _negative_ penalty will encourage the model to reuse tokens
    /// proportional to the number of times the token has been used. Small
    /// negative values will reduce the vocabulary of a response. Larger negative
    /// values will cause the model to start repeating a common token  until it
    /// hits the
    /// [max_output_tokens][google.ai.generativelanguage.v1alpha.GenerationConfig.max_output_tokens]
    /// limit.
    #[prost(float, optional, tag = "16")]
    pub frequency_penalty: ::core::option::Option<f32>,
    /// Optional. If true, export the logprobs results in response.
    #[prost(bool, optional, tag = "17")]
    pub response_logprobs: ::core::option::Option<bool>,
    /// Optional. Only valid if
    /// [response_logprobs=True][google.ai.generativelanguage.v1alpha.GenerationConfig.response_logprobs].
    /// This sets the number of top logprobs to return at each decoding step in the
    /// [Candidate.logprobs_result][google.ai.generativelanguage.v1alpha.Candidate.logprobs_result].
    #[prost(int32, optional, tag = "18")]
    pub logprobs: ::core::option::Option<i32>,
    /// Optional. Enables enhanced civic answers. It may not be available for all
    /// models.
    #[prost(bool, optional, tag = "19")]
    pub enable_enhanced_civic_answers: ::core::option::Option<bool>,
    /// Optional. The requested modalities of the response. Represents the set of
    /// modalities that the model can return, and should be expected in the
    /// response. This is an exact match to the modalities of the response.
    ///
    /// A model may have multiple combinations of supported modalities. If the
    /// requested modalities do not match any of the supported combinations, an
    /// error will be returned.
    ///
    /// An empty list is equivalent to requesting only text.
    #[prost(
        enumeration = "generation_config::Modality",
        repeated,
        packed = "false",
        tag = "20"
    )]
    pub response_modalities: ::prost::alloc::vec::Vec<i32>,
    /// Optional. The speech generation config.
    #[prost(message, optional, tag = "21")]
    pub speech_config: ::core::option::Option<SpeechConfig>,
}
/// Nested message and enum types in `GenerationConfig`.
pub mod generation_config {
    /// Supported modalities of the response.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Modality {
        /// Default value.
        Unspecified = 0,
        /// Indicates the model should return text.
        Text = 1,
        /// Indicates the model should return images.
        Image = 2,
        /// Indicates the model should return audio.
        Audio = 3,
    }
    impl Modality {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODALITY_UNSPECIFIED",
                Self::Text => "TEXT",
                Self::Image => "IMAGE",
                Self::Audio => "AUDIO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODALITY_UNSPECIFIED" => Some(Self::Unspecified),
                "TEXT" => Some(Self::Text),
                "IMAGE" => Some(Self::Image),
                "AUDIO" => Some(Self::Audio),
                _ => None,
            }
        }
    }
}
/// Configuration for retrieving grounding content from a `Corpus` or
/// `Document` created using the Semantic Retriever API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SemanticRetrieverConfig {
    /// Required. Name of the resource for retrieval. Example: `corpora/123` or
    /// `corpora/123/documents/abc`.
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    /// Required. Query to use for matching `Chunk`s in the given resource by
    /// similarity.
    #[prost(message, optional, tag = "2")]
    pub query: ::core::option::Option<Content>,
    /// Optional. Filters for selecting `Document`s and/or `Chunk`s from the
    /// resource.
    #[prost(message, repeated, tag = "3")]
    pub metadata_filters: ::prost::alloc::vec::Vec<MetadataFilter>,
    /// Optional. Maximum number of relevant `Chunk`s to retrieve.
    #[prost(int32, optional, tag = "4")]
    pub max_chunks_count: ::core::option::Option<i32>,
    /// Optional. Minimum relevance score for retrieved relevant `Chunk`s.
    #[prost(float, optional, tag = "5")]
    pub minimum_relevance_score: ::core::option::Option<f32>,
}
/// Response from the model supporting multiple candidate responses.
///
/// Safety ratings and content filtering are reported for both
/// prompt in `GenerateContentResponse.prompt_feedback` and for each candidate
/// in `finish_reason` and in `safety_ratings`. The API:
///   - Returns either all requested candidates or none of them
///   - Returns no candidates at all only if there was something wrong with the
///     prompt (check `prompt_feedback`)
///   - Reports feedback on each candidate in `finish_reason` and
///     `safety_ratings`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateContentResponse {
    /// Candidate responses from the model.
    #[prost(message, repeated, tag = "1")]
    pub candidates: ::prost::alloc::vec::Vec<Candidate>,
    /// Returns the prompt's feedback related to the content filters.
    #[prost(message, optional, tag = "2")]
    pub prompt_feedback: ::core::option::Option<
        generate_content_response::PromptFeedback,
    >,
    /// Output only. Metadata on the generation requests' token usage.
    #[prost(message, optional, tag = "3")]
    pub usage_metadata: ::core::option::Option<generate_content_response::UsageMetadata>,
    /// Output only. The model version used to generate the response.
    #[prost(string, tag = "4")]
    pub model_version: ::prost::alloc::string::String,
}
/// Nested message and enum types in `GenerateContentResponse`.
pub mod generate_content_response {
    /// A set of the feedback metadata the prompt specified in
    /// `GenerateContentRequest.content`.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PromptFeedback {
        /// Optional. If set, the prompt was blocked and no candidates are returned.
        /// Rephrase the prompt.
        #[prost(enumeration = "prompt_feedback::BlockReason", tag = "1")]
        pub block_reason: i32,
        /// Ratings for safety of the prompt.
        /// There is at most one rating per category.
        #[prost(message, repeated, tag = "2")]
        pub safety_ratings: ::prost::alloc::vec::Vec<super::SafetyRating>,
    }
    /// Nested message and enum types in `PromptFeedback`.
    pub mod prompt_feedback {
        /// Specifies the reason why the prompt was blocked.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum BlockReason {
            /// Default value. This value is unused.
            Unspecified = 0,
            /// Prompt was blocked due to safety reasons. Inspect `safety_ratings`
            /// to understand which safety category blocked it.
            Safety = 1,
            /// Prompt was blocked due to unknown reasons.
            Other = 2,
            /// Prompt was blocked due to the terms which are included from the
            /// terminology blocklist.
            Blocklist = 3,
            /// Prompt was blocked due to prohibited content.
            ProhibitedContent = 4,
            /// Candidates blocked due to unsafe image generation content.
            ImageSafety = 5,
        }
        impl BlockReason {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "BLOCK_REASON_UNSPECIFIED",
                    Self::Safety => "SAFETY",
                    Self::Other => "OTHER",
                    Self::Blocklist => "BLOCKLIST",
                    Self::ProhibitedContent => "PROHIBITED_CONTENT",
                    Self::ImageSafety => "IMAGE_SAFETY",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "BLOCK_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                    "SAFETY" => Some(Self::Safety),
                    "OTHER" => Some(Self::Other),
                    "BLOCKLIST" => Some(Self::Blocklist),
                    "PROHIBITED_CONTENT" => Some(Self::ProhibitedContent),
                    "IMAGE_SAFETY" => Some(Self::ImageSafety),
                    _ => None,
                }
            }
        }
    }
    /// Metadata on the generation request's token usage.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UsageMetadata {
        /// Number of tokens in the prompt. When `cached_content` is set, this is
        /// still the total effective prompt size meaning this includes the number of
        /// tokens in the cached content.
        #[prost(int32, tag = "1")]
        pub prompt_token_count: i32,
        /// Number of tokens in the cached part of the prompt (the cached content)
        #[prost(int32, tag = "4")]
        pub cached_content_token_count: i32,
        /// Total number of tokens across all the generated response candidates.
        #[prost(int32, tag = "2")]
        pub candidates_token_count: i32,
        /// Total token count for the generation request (prompt + response
        /// candidates).
        #[prost(int32, tag = "3")]
        pub total_token_count: i32,
    }
}
/// A response candidate generated from the model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Candidate {
    /// Output only. Index of the candidate in the list of response candidates.
    #[prost(int32, optional, tag = "3")]
    pub index: ::core::option::Option<i32>,
    /// Output only. Generated content returned from the model.
    #[prost(message, optional, tag = "1")]
    pub content: ::core::option::Option<Content>,
    /// Optional. Output only. The reason why the model stopped generating tokens.
    ///
    /// If empty, the model has not stopped generating tokens.
    #[prost(enumeration = "candidate::FinishReason", tag = "2")]
    pub finish_reason: i32,
    /// List of ratings for the safety of a response candidate.
    ///
    /// There is at most one rating per category.
    #[prost(message, repeated, tag = "5")]
    pub safety_ratings: ::prost::alloc::vec::Vec<SafetyRating>,
    /// Output only. Citation information for model-generated candidate.
    ///
    /// This field may be populated with recitation information for any text
    /// included in the `content`. These are passages that are "recited" from
    /// copyrighted material in the foundational LLM's training data.
    #[prost(message, optional, tag = "6")]
    pub citation_metadata: ::core::option::Option<CitationMetadata>,
    /// Output only. Token count for this candidate.
    #[prost(int32, tag = "7")]
    pub token_count: i32,
    /// Output only. Attribution information for sources that contributed to a
    /// grounded answer.
    ///
    /// This field is populated for `GenerateAnswer` calls.
    #[prost(message, repeated, tag = "8")]
    pub grounding_attributions: ::prost::alloc::vec::Vec<GroundingAttribution>,
    /// Output only. Grounding metadata for the candidate.
    ///
    /// This field is populated for `GenerateContent` calls.
    #[prost(message, optional, tag = "9")]
    pub grounding_metadata: ::core::option::Option<GroundingMetadata>,
    /// Output only. Average log probability score of the candidate.
    #[prost(double, tag = "10")]
    pub avg_logprobs: f64,
    /// Output only. Log-likelihood scores for the response tokens and top tokens
    #[prost(message, optional, tag = "11")]
    pub logprobs_result: ::core::option::Option<LogprobsResult>,
}
/// Nested message and enum types in `Candidate`.
pub mod candidate {
    /// Defines the reason why the model stopped generating tokens.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FinishReason {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Natural stop point of the model or provided stop sequence.
        Stop = 1,
        /// The maximum number of tokens as specified in the request was reached.
        MaxTokens = 2,
        /// The response candidate content was flagged for safety reasons.
        Safety = 3,
        /// The response candidate content was flagged for recitation reasons.
        Recitation = 4,
        /// The response candidate content was flagged for using an unsupported
        /// language.
        Language = 6,
        /// Unknown reason.
        Other = 5,
        /// Token generation stopped because the content contains forbidden terms.
        Blocklist = 7,
        /// Token generation stopped for potentially containing prohibited content.
        ProhibitedContent = 8,
        /// Token generation stopped because the content potentially contains
        /// Sensitive Personally Identifiable Information (SPII).
        Spii = 9,
        /// The function call generated by the model is invalid.
        MalformedFunctionCall = 10,
        /// Token generation stopped because generated images contain safety
        /// violations.
        ImageSafety = 11,
    }
    impl FinishReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FINISH_REASON_UNSPECIFIED",
                Self::Stop => "STOP",
                Self::MaxTokens => "MAX_TOKENS",
                Self::Safety => "SAFETY",
                Self::Recitation => "RECITATION",
                Self::Language => "LANGUAGE",
                Self::Other => "OTHER",
                Self::Blocklist => "BLOCKLIST",
                Self::ProhibitedContent => "PROHIBITED_CONTENT",
                Self::Spii => "SPII",
                Self::MalformedFunctionCall => "MALFORMED_FUNCTION_CALL",
                Self::ImageSafety => "IMAGE_SAFETY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FINISH_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "STOP" => Some(Self::Stop),
                "MAX_TOKENS" => Some(Self::MaxTokens),
                "SAFETY" => Some(Self::Safety),
                "RECITATION" => Some(Self::Recitation),
                "LANGUAGE" => Some(Self::Language),
                "OTHER" => Some(Self::Other),
                "BLOCKLIST" => Some(Self::Blocklist),
                "PROHIBITED_CONTENT" => Some(Self::ProhibitedContent),
                "SPII" => Some(Self::Spii),
                "MALFORMED_FUNCTION_CALL" => Some(Self::MalformedFunctionCall),
                "IMAGE_SAFETY" => Some(Self::ImageSafety),
                _ => None,
            }
        }
    }
}
/// Logprobs Result
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogprobsResult {
    /// Length = total number of decoding steps.
    #[prost(message, repeated, tag = "1")]
    pub top_candidates: ::prost::alloc::vec::Vec<logprobs_result::TopCandidates>,
    /// Length = total number of decoding steps.
    /// The chosen candidates may or may not be in top_candidates.
    #[prost(message, repeated, tag = "2")]
    pub chosen_candidates: ::prost::alloc::vec::Vec<logprobs_result::Candidate>,
}
/// Nested message and enum types in `LogprobsResult`.
pub mod logprobs_result {
    /// Candidate for the logprobs token and score.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Candidate {
        /// The candidate’s token string value.
        #[prost(string, optional, tag = "1")]
        pub token: ::core::option::Option<::prost::alloc::string::String>,
        /// The candidate’s token id value.
        #[prost(int32, optional, tag = "3")]
        pub token_id: ::core::option::Option<i32>,
        /// The candidate's log probability.
        #[prost(float, optional, tag = "2")]
        pub log_probability: ::core::option::Option<f32>,
    }
    /// Candidates with top log probabilities at each decoding step.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TopCandidates {
        /// Sorted by log probability in descending order.
        #[prost(message, repeated, tag = "1")]
        pub candidates: ::prost::alloc::vec::Vec<Candidate>,
    }
}
/// Identifier for the source contributing to this attribution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributionSourceId {
    #[prost(oneof = "attribution_source_id::Source", tags = "1, 2")]
    pub source: ::core::option::Option<attribution_source_id::Source>,
}
/// Nested message and enum types in `AttributionSourceId`.
pub mod attribution_source_id {
    /// Identifier for a part within a `GroundingPassage`.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GroundingPassageId {
        /// Output only. ID of the passage matching the `GenerateAnswerRequest`'s
        /// `GroundingPassage.id`.
        #[prost(string, tag = "1")]
        pub passage_id: ::prost::alloc::string::String,
        /// Output only. Index of the part within the `GenerateAnswerRequest`'s
        /// `GroundingPassage.content`.
        #[prost(int32, tag = "2")]
        pub part_index: i32,
    }
    /// Identifier for a `Chunk` retrieved via Semantic Retriever specified in the
    /// `GenerateAnswerRequest` using `SemanticRetrieverConfig`.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SemanticRetrieverChunk {
        /// Output only. Name of the source matching the request's
        /// `SemanticRetrieverConfig.source`. Example: `corpora/123` or
        /// `corpora/123/documents/abc`
        #[prost(string, tag = "1")]
        pub source: ::prost::alloc::string::String,
        /// Output only. Name of the `Chunk` containing the attributed text.
        /// Example: `corpora/123/documents/abc/chunks/xyz`
        #[prost(string, tag = "2")]
        pub chunk: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// Identifier for an inline passage.
        #[prost(message, tag = "1")]
        GroundingPassage(GroundingPassageId),
        /// Identifier for a `Chunk` fetched via Semantic Retriever.
        #[prost(message, tag = "2")]
        SemanticRetrieverChunk(SemanticRetrieverChunk),
    }
}
/// Attribution for a source that contributed to an answer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundingAttribution {
    /// Output only. Identifier for the source contributing to this attribution.
    #[prost(message, optional, tag = "3")]
    pub source_id: ::core::option::Option<AttributionSourceId>,
    /// Grounding source content that makes up this attribution.
    #[prost(message, optional, tag = "2")]
    pub content: ::core::option::Option<Content>,
}
/// Metadata related to retrieval in the grounding flow.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RetrievalMetadata {
    /// Optional. Score indicating how likely information from google search could
    /// help answer the prompt. The score is in the range \[0, 1\], where 0 is the
    /// least likely and 1 is the most likely. This score is only populated when
    /// google search grounding and dynamic retrieval is enabled. It will be
    /// compared to the threshold to determine whether to trigger google search.
    #[prost(float, tag = "2")]
    pub google_search_dynamic_retrieval_score: f32,
}
/// Metadata returned to client when grounding is enabled.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundingMetadata {
    /// Optional. Google search entry for the following-up web searches.
    #[prost(message, optional, tag = "1")]
    pub search_entry_point: ::core::option::Option<SearchEntryPoint>,
    /// List of supporting references retrieved from specified grounding source.
    #[prost(message, repeated, tag = "2")]
    pub grounding_chunks: ::prost::alloc::vec::Vec<GroundingChunk>,
    /// List of grounding support.
    #[prost(message, repeated, tag = "3")]
    pub grounding_supports: ::prost::alloc::vec::Vec<GroundingSupport>,
    /// Metadata related to retrieval in the grounding flow.
    #[prost(message, optional, tag = "4")]
    pub retrieval_metadata: ::core::option::Option<RetrievalMetadata>,
    /// Web search queries for the following-up web search.
    #[prost(string, repeated, tag = "5")]
    pub web_search_queries: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Google search entry point.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchEntryPoint {
    /// Optional. Web content snippet that can be embedded in a web page or an app
    /// webview.
    #[prost(string, tag = "1")]
    pub rendered_content: ::prost::alloc::string::String,
    /// Optional. Base64 encoded JSON representing array of <search term, search
    /// url> tuple.
    #[prost(bytes = "vec", tag = "2")]
    pub sdk_blob: ::prost::alloc::vec::Vec<u8>,
}
/// Grounding chunk.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundingChunk {
    /// Chunk type.
    #[prost(oneof = "grounding_chunk::ChunkType", tags = "1")]
    pub chunk_type: ::core::option::Option<grounding_chunk::ChunkType>,
}
/// Nested message and enum types in `GroundingChunk`.
pub mod grounding_chunk {
    /// Chunk from the web.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Web {
        /// URI reference of the chunk.
        #[prost(string, optional, tag = "1")]
        pub uri: ::core::option::Option<::prost::alloc::string::String>,
        /// Title of the chunk.
        #[prost(string, optional, tag = "2")]
        pub title: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Chunk type.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ChunkType {
        /// Grounding chunk from the web.
        #[prost(message, tag = "1")]
        Web(Web),
    }
}
/// Segment of the content.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Segment {
    /// Output only. The index of a Part object within its parent Content object.
    #[prost(int32, tag = "1")]
    pub part_index: i32,
    /// Output only. Start index in the given Part, measured in bytes. Offset from
    /// the start of the Part, inclusive, starting at zero.
    #[prost(int32, tag = "2")]
    pub start_index: i32,
    /// Output only. End index in the given Part, measured in bytes. Offset from
    /// the start of the Part, exclusive, starting at zero.
    #[prost(int32, tag = "3")]
    pub end_index: i32,
    /// Output only. The text corresponding to the segment from the response.
    #[prost(string, tag = "4")]
    pub text: ::prost::alloc::string::String,
}
/// Grounding support.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundingSupport {
    /// Segment of the content this support belongs to.
    #[prost(message, optional, tag = "1")]
    pub segment: ::core::option::Option<Segment>,
    /// A list of indices (into 'grounding_chunk') specifying the
    /// citations associated with the claim. For instance \[1,3,4\] means
    /// that grounding_chunk\[1\], grounding_chunk\[3\],
    /// grounding_chunk\[4\] are the retrieved content attributed to the claim.
    #[prost(int32, repeated, tag = "2")]
    pub grounding_chunk_indices: ::prost::alloc::vec::Vec<i32>,
    /// Confidence score of the support references. Ranges from 0 to 1. 1 is the
    /// most confident. This list must have the same size as the
    /// grounding_chunk_indices.
    #[prost(float, repeated, tag = "3")]
    pub confidence_scores: ::prost::alloc::vec::Vec<f32>,
}
/// Request to generate a grounded answer from the `Model`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateAnswerRequest {
    /// Required. The name of the `Model` to use for generating the grounded
    /// response.
    ///
    /// Format: `model=models/{model}`.
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    /// Required. The content of the current conversation with the `Model`. For
    /// single-turn queries, this is a single question to answer. For multi-turn
    /// queries, this is a repeated field that contains conversation history and
    /// the last `Content` in the list containing the question.
    ///
    /// Note: `GenerateAnswer` only supports queries in English.
    #[prost(message, repeated, tag = "2")]
    pub contents: ::prost::alloc::vec::Vec<Content>,
    /// Required. Style in which answers should be returned.
    #[prost(enumeration = "generate_answer_request::AnswerStyle", tag = "5")]
    pub answer_style: i32,
    /// Optional. A list of unique `SafetySetting` instances for blocking unsafe
    /// content.
    ///
    /// This will be enforced on the `GenerateAnswerRequest.contents` and
    /// `GenerateAnswerResponse.candidate`. There should not be more than one
    /// setting for each `SafetyCategory` type. The API will block any contents and
    /// responses that fail to meet the thresholds set by these settings. This list
    /// overrides the default settings for each `SafetyCategory` specified in the
    /// safety_settings. If there is no `SafetySetting` for a given
    /// `SafetyCategory` provided in the list, the API will use the default safety
    /// setting for that category. Harm categories HARM_CATEGORY_HATE_SPEECH,
    /// HARM_CATEGORY_SEXUALLY_EXPLICIT, HARM_CATEGORY_DANGEROUS_CONTENT,
    /// HARM_CATEGORY_HARASSMENT are supported.
    /// Refer to the
    /// [guide](<https://ai.google.dev/gemini-api/docs/safety-settings>)
    /// for detailed information on available safety settings. Also refer to the
    /// [Safety guidance](<https://ai.google.dev/gemini-api/docs/safety-guidance>) to
    /// learn how to incorporate safety considerations in your AI applications.
    #[prost(message, repeated, tag = "3")]
    pub safety_settings: ::prost::alloc::vec::Vec<SafetySetting>,
    /// Optional. Controls the randomness of the output.
    ///
    /// Values can range from \[0.0,1.0\], inclusive. A value closer to 1.0 will
    /// produce responses that are more varied and creative, while a value closer
    /// to 0.0 will typically result in more straightforward responses from the
    /// model. A low temperature (~0.2) is usually recommended for
    /// Attributed-Question-Answering use cases.
    #[prost(float, optional, tag = "4")]
    pub temperature: ::core::option::Option<f32>,
    /// The sources in which to ground the answer.
    #[prost(oneof = "generate_answer_request::GroundingSource", tags = "6, 7")]
    pub grounding_source: ::core::option::Option<
        generate_answer_request::GroundingSource,
    >,
}
/// Nested message and enum types in `GenerateAnswerRequest`.
pub mod generate_answer_request {
    /// Style for grounded answers.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AnswerStyle {
        /// Unspecified answer style.
        Unspecified = 0,
        /// Succint but abstract style.
        Abstractive = 1,
        /// Very brief and extractive style.
        Extractive = 2,
        /// Verbose style including extra details. The response may be formatted as a
        /// sentence, paragraph, multiple paragraphs, or bullet points, etc.
        Verbose = 3,
    }
    impl AnswerStyle {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ANSWER_STYLE_UNSPECIFIED",
                Self::Abstractive => "ABSTRACTIVE",
                Self::Extractive => "EXTRACTIVE",
                Self::Verbose => "VERBOSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ANSWER_STYLE_UNSPECIFIED" => Some(Self::Unspecified),
                "ABSTRACTIVE" => Some(Self::Abstractive),
                "EXTRACTIVE" => Some(Self::Extractive),
                "VERBOSE" => Some(Self::Verbose),
                _ => None,
            }
        }
    }
    /// The sources in which to ground the answer.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum GroundingSource {
        /// Passages provided inline with the request.
        #[prost(message, tag = "6")]
        InlinePassages(super::GroundingPassages),
        /// Content retrieved from resources created via the Semantic Retriever
        /// API.
        #[prost(message, tag = "7")]
        SemanticRetriever(super::SemanticRetrieverConfig),
    }
}
/// Response from the model for a grounded answer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateAnswerResponse {
    /// Candidate answer from the model.
    ///
    /// Note: The model *always* attempts to provide a grounded answer, even when
    /// the answer is unlikely to be answerable from the given passages.
    /// In that case, a low-quality or ungrounded answer may be provided, along
    /// with a low `answerable_probability`.
    #[prost(message, optional, tag = "1")]
    pub answer: ::core::option::Option<Candidate>,
    /// Output only. The model's estimate of the probability that its answer is
    /// correct and grounded in the input passages.
    ///
    /// A low `answerable_probability` indicates that the answer might not be
    /// grounded in the sources.
    ///
    /// When `answerable_probability` is low, you may want to:
    ///
    /// * Display a message to the effect of "We couldn’t answer that question" to
    /// the user.
    /// * Fall back to a general-purpose LLM that answers the question from world
    /// knowledge. The threshold and nature of such fallbacks will depend on
    /// individual use cases. `0.5` is a good starting threshold.
    #[prost(float, optional, tag = "2")]
    pub answerable_probability: ::core::option::Option<f32>,
    /// Output only. Feedback related to the input data used to answer the
    /// question, as opposed to the model-generated response to the question.
    ///
    /// The input data can be one or more of the following:
    ///
    /// - Question specified by the last entry in `GenerateAnswerRequest.content`
    /// - Conversation history specified by the other entries in
    /// `GenerateAnswerRequest.content`
    /// - Grounding sources (`GenerateAnswerRequest.semantic_retriever` or
    /// `GenerateAnswerRequest.inline_passages`)
    #[prost(message, optional, tag = "3")]
    pub input_feedback: ::core::option::Option<generate_answer_response::InputFeedback>,
}
/// Nested message and enum types in `GenerateAnswerResponse`.
pub mod generate_answer_response {
    /// Feedback related to the input data used to answer the question, as opposed
    /// to the model-generated response to the question.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InputFeedback {
        /// Optional. If set, the input was blocked and no candidates are returned.
        /// Rephrase the input.
        #[prost(enumeration = "input_feedback::BlockReason", optional, tag = "1")]
        pub block_reason: ::core::option::Option<i32>,
        /// Ratings for safety of the input.
        /// There is at most one rating per category.
        #[prost(message, repeated, tag = "2")]
        pub safety_ratings: ::prost::alloc::vec::Vec<super::SafetyRating>,
    }
    /// Nested message and enum types in `InputFeedback`.
    pub mod input_feedback {
        /// Specifies what was the reason why input was blocked.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum BlockReason {
            /// Default value. This value is unused.
            Unspecified = 0,
            /// Input was blocked due to safety reasons. Inspect
            /// `safety_ratings` to understand which safety category blocked it.
            Safety = 1,
            /// Input was blocked due to other reasons.
            Other = 2,
        }
        impl BlockReason {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "BLOCK_REASON_UNSPECIFIED",
                    Self::Safety => "SAFETY",
                    Self::Other => "OTHER",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "BLOCK_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                    "SAFETY" => Some(Self::Safety),
                    "OTHER" => Some(Self::Other),
                    _ => None,
                }
            }
        }
    }
}
/// Request containing the `Content` for the model to embed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmbedContentRequest {
    /// Required. The model's resource name. This serves as an ID for the Model to
    /// use.
    ///
    /// This name should match a model name returned by the `ListModels` method.
    ///
    /// Format: `models/{model}`
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    /// Required. The content to embed. Only the `parts.text` fields will be
    /// counted.
    #[prost(message, optional, tag = "2")]
    pub content: ::core::option::Option<Content>,
    /// Optional. Optional task type for which the embeddings will be used. Can
    /// only be set for `models/embedding-001`.
    #[prost(enumeration = "TaskType", optional, tag = "3")]
    pub task_type: ::core::option::Option<i32>,
    /// Optional. An optional title for the text. Only applicable when TaskType is
    /// `RETRIEVAL_DOCUMENT`.
    ///
    /// Note: Specifying a `title` for `RETRIEVAL_DOCUMENT` provides better quality
    /// embeddings for retrieval.
    #[prost(string, optional, tag = "4")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Optional reduced dimension for the output embedding. If set,
    /// excessive values in the output embedding are truncated from the end.
    /// Supported by newer models since 2024 only. You cannot set this value if
    /// using the earlier model (`models/embedding-001`).
    #[prost(int32, optional, tag = "5")]
    pub output_dimensionality: ::core::option::Option<i32>,
}
/// A list of floats representing an embedding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContentEmbedding {
    /// The embedding values.
    #[prost(float, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<f32>,
}
/// The response to an `EmbedContentRequest`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmbedContentResponse {
    /// Output only. The embedding generated from the input content.
    #[prost(message, optional, tag = "1")]
    pub embedding: ::core::option::Option<ContentEmbedding>,
}
/// Batch request to get embeddings from the model for a list of prompts.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchEmbedContentsRequest {
    /// Required. The model's resource name. This serves as an ID for the Model to
    /// use.
    ///
    /// This name should match a model name returned by the `ListModels` method.
    ///
    /// Format: `models/{model}`
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    /// Required. Embed requests for the batch. The model in each of these requests
    /// must match the model specified `BatchEmbedContentsRequest.model`.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<EmbedContentRequest>,
}
/// The response to a `BatchEmbedContentsRequest`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchEmbedContentsResponse {
    /// Output only. The embeddings for each request, in the same order as provided
    /// in the batch request.
    #[prost(message, repeated, tag = "1")]
    pub embeddings: ::prost::alloc::vec::Vec<ContentEmbedding>,
}
/// Counts the number of tokens in the `prompt` sent to a model.
///
/// Models may tokenize text differently, so each model may return a different
/// `token_count`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountTokensRequest {
    /// Required. The model's resource name. This serves as an ID for the Model to
    /// use.
    ///
    /// This name should match a model name returned by the `ListModels` method.
    ///
    /// Format: `models/{model}`
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    /// Optional. The input given to the model as a prompt. This field is ignored
    /// when `generate_content_request` is set.
    #[prost(message, repeated, tag = "2")]
    pub contents: ::prost::alloc::vec::Vec<Content>,
    /// Optional. The overall input given to the `Model`. This includes the prompt
    /// as well as other model steering information like [system
    /// instructions](<https://ai.google.dev/gemini-api/docs/system-instructions>),
    /// and/or function declarations for [function
    /// calling](<https://ai.google.dev/gemini-api/docs/function-calling>).
    /// `Model`s/`Content`s and `generate_content_request`s are mutually
    /// exclusive. You can either send `Model` + `Content`s or a
    /// `generate_content_request`, but never both.
    #[prost(message, optional, tag = "3")]
    pub generate_content_request: ::core::option::Option<GenerateContentRequest>,
}
/// A response from `CountTokens`.
///
/// It returns the model's `token_count` for the `prompt`.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CountTokensResponse {
    /// The number of tokens that the `Model` tokenizes the `prompt` into. Always
    /// non-negative.
    #[prost(int32, tag = "1")]
    pub total_tokens: i32,
    /// Number of tokens in the cached part of the prompt (the cached content).
    #[prost(int32, tag = "5")]
    pub cached_content_token_count: i32,
}
/// Message to be sent in the first and only first
/// `BidiGenerateContentClientMessage`. Contains configuration that will apply
/// for the duration of the streaming RPC.
///
/// Clients should wait for a `BidiGenerateContentSetupComplete` message before
/// sending any additional messages.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiGenerateContentSetup {
    /// Required. The model's resource name. This serves as an ID for the Model to
    /// use.
    ///
    /// Format: `models/{model}`
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    /// Optional. Generation config.
    ///
    /// The following fields are not supported:
    ///
    ///   - `response_logprobs`
    ///   - `response_mime_type`
    ///   - `logprobs`
    ///   - `response_schema`
    ///   - `stop_sequence`
    ///   - `routing_config`
    ///   - `audio_timestamp`
    #[prost(message, optional, tag = "2")]
    pub generation_config: ::core::option::Option<GenerationConfig>,
    /// Optional. The user provided system instructions for the model.
    ///
    /// Note: Only text should be used in parts and content in each part will be
    /// in a separate paragraph.
    #[prost(message, optional, tag = "3")]
    pub system_instruction: ::core::option::Option<Content>,
    /// Optional. A list of `Tools` the model may use to generate the next
    /// response.
    ///
    /// A `Tool` is a piece of code that enables the system to interact with
    /// external systems to perform an action, or set of actions, outside of
    /// knowledge and scope of the model.
    #[prost(message, repeated, tag = "4")]
    pub tools: ::prost::alloc::vec::Vec<Tool>,
}
/// Incremental update of the current conversation delivered from the client.
/// All of the content here is unconditionally appended to the conversation
/// history and used as part of the prompt to the model to generate content.
///
/// A message here will interrupt any current model generation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiGenerateContentClientContent {
    /// Optional. The content appended to the current conversation with the model.
    ///
    /// For single-turn queries, this is a single instance. For multi-turn
    /// queries, this is a repeated field that contains conversation history and
    /// the latest request.
    #[prost(message, repeated, tag = "1")]
    pub turns: ::prost::alloc::vec::Vec<Content>,
    /// Optional. If true, indicates that the server content generation should
    /// start with the currently accumulated prompt. Otherwise, the server awaits
    /// additional messages before starting generation.
    #[prost(bool, tag = "2")]
    pub turn_complete: bool,
}
/// User input that is sent in real time.
///
/// This is different from
/// [BidiGenerateContentClientContent][google.ai.generativelanguage.v1alpha.BidiGenerateContentClientContent]
/// in a few ways:
///
///   - Can be sent continuously without interruption to model generation.
///   - If there is a need to mix data interleaved across the
///     [BidiGenerateContentClientContent][google.ai.generativelanguage.v1alpha.BidiGenerateContentClientContent]
///     and the
///     [BidiGenerateContentRealtimeInput][google.ai.generativelanguage.v1alpha.BidiGenerateContentRealtimeInput],
///     the server attempts to optimize for best response, but there are no
///     guarantees.
///   - End of turn is not explicitly specified, but is rather derived from user
///     activity (for example, end of speech).
///   - Even before the end of turn, the data is processed incrementally
///     to optimize for a fast start of the response from the model.
///   - Is always direct user input that is sent in real time. Can be sent
///     continuously without interruptions. The model automatically detects the
///     beginning and the end of user speech and starts or terminates streaming
///     the response accordingly. Data is processed incrementally as it arrives,
///     minimizing latency.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiGenerateContentRealtimeInput {
    /// Optional. Inlined bytes data for media input.
    #[prost(message, repeated, tag = "1")]
    pub media_chunks: ::prost::alloc::vec::Vec<Blob>,
}
/// Client generated response to a `ToolCall` received from the server.
/// Individual `FunctionResponse` objects are matched to the respective
/// `FunctionCall` objects by the `id` field.
///
/// Note that in the unary and server-streaming GenerateContent APIs function
/// calling happens by exchanging the `Content` parts, while in the bidi
/// GenerateContent APIs function calling happens over these dedicated set of
/// messages.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiGenerateContentToolResponse {
    /// Optional. The response to the function calls.
    #[prost(message, repeated, tag = "1")]
    pub function_responses: ::prost::alloc::vec::Vec<FunctionResponse>,
}
/// Messages sent by the client in the BidiGenerateContent call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiGenerateContentClientMessage {
    /// The type of the message.
    #[prost(
        oneof = "bidi_generate_content_client_message::MessageType",
        tags = "1, 2, 3, 4"
    )]
    pub message_type: ::core::option::Option<
        bidi_generate_content_client_message::MessageType,
    >,
}
/// Nested message and enum types in `BidiGenerateContentClientMessage`.
pub mod bidi_generate_content_client_message {
    /// The type of the message.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum MessageType {
        /// Optional. Session configuration sent in the first and only first client
        /// message.
        #[prost(message, tag = "1")]
        Setup(super::BidiGenerateContentSetup),
        /// Optional. Incremental update of the current conversation delivered from
        /// the client.
        #[prost(message, tag = "2")]
        ClientContent(super::BidiGenerateContentClientContent),
        /// Optional. User input that is sent in real time.
        #[prost(message, tag = "3")]
        RealtimeInput(super::BidiGenerateContentRealtimeInput),
        /// Optional. Response to a `ToolCallMessage` received from the server.
        #[prost(message, tag = "4")]
        ToolResponse(super::BidiGenerateContentToolResponse),
    }
}
/// Sent in response to a `BidiGenerateContentSetup` message from the client.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BidiGenerateContentSetupComplete {}
/// Incremental server update generated by the model in response to client
/// messages.
///
/// Content is generated as quickly as possible, and not in real time. Clients
/// may choose to buffer and play it out in real time.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiGenerateContentServerContent {
    /// Output only. The content that the model has generated as part of the
    /// current conversation with the user.
    #[prost(message, optional, tag = "1")]
    pub model_turn: ::core::option::Option<Content>,
    /// Output only. If true, indicates that the model is done generating.
    /// Generation will only start in response to additional client messages. Can
    /// be set alongside `content`, indicating that the `content` is the last in
    /// the turn.
    #[prost(bool, tag = "2")]
    pub turn_complete: bool,
    /// Output only. If true, indicates that a client message has interrupted
    /// current model generation. If the client is playing out the content in real
    /// time, this is a good signal to stop and empty the current playback queue.
    #[prost(bool, tag = "3")]
    pub interrupted: bool,
    /// Output only. Grounding metadata for the generated content.
    #[prost(message, optional, tag = "4")]
    pub grounding_metadata: ::core::option::Option<GroundingMetadata>,
}
/// Request for the client to execute the `function_calls` and return the
/// responses with the matching `id`s.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiGenerateContentToolCall {
    /// Output only. The function call to be executed.
    #[prost(message, repeated, tag = "2")]
    pub function_calls: ::prost::alloc::vec::Vec<FunctionCall>,
}
/// Notification for the client that a previously issued `ToolCallMessage`
/// with the specified `id`s should have been not executed and should be
/// cancelled. If there were side-effects to those tool calls, clients may
/// attempt to undo the tool calls. This message occurs only in cases where the
/// clients interrupt server turns.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiGenerateContentToolCallCancellation {
    /// Output only. The ids of the tool calls to be cancelled.
    #[prost(string, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response message for the BidiGenerateContent call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BidiGenerateContentServerMessage {
    /// The type of the message.
    #[prost(
        oneof = "bidi_generate_content_server_message::MessageType",
        tags = "2, 3, 4, 5"
    )]
    pub message_type: ::core::option::Option<
        bidi_generate_content_server_message::MessageType,
    >,
}
/// Nested message and enum types in `BidiGenerateContentServerMessage`.
pub mod bidi_generate_content_server_message {
    /// The type of the message.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum MessageType {
        /// Output only. Sent in response to a `BidiGenerateContentSetup` message
        /// from the client when setup is complete.
        #[prost(message, tag = "2")]
        SetupComplete(super::BidiGenerateContentSetupComplete),
        /// Output only. Content generated by the model in response to client
        /// messages.
        #[prost(message, tag = "3")]
        ServerContent(super::BidiGenerateContentServerContent),
        /// Output only. Request for the client to execute the `function_calls` and
        /// return the responses with the matching `id`s.
        #[prost(message, tag = "4")]
        ToolCall(super::BidiGenerateContentToolCall),
        /// Output only. Notification for the client that a previously issued
        /// `ToolCallMessage` with the specified `id`s should be cancelled.
        #[prost(message, tag = "5")]
        ToolCallCancellation(super::BidiGenerateContentToolCallCancellation),
    }
}
/// Type of task for which the embedding will be used.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaskType {
    /// Unset value, which will default to one of the other enum values.
    Unspecified = 0,
    /// Specifies the given text is a query in a search/retrieval setting.
    RetrievalQuery = 1,
    /// Specifies the given text is a document from the corpus being searched.
    RetrievalDocument = 2,
    /// Specifies the given text will be used for STS.
    SemanticSimilarity = 3,
    /// Specifies that the given text will be classified.
    Classification = 4,
    /// Specifies that the embeddings will be used for clustering.
    Clustering = 5,
    /// Specifies that the given text will be used for question answering.
    QuestionAnswering = 6,
    /// Specifies that the given text will be used for fact verification.
    FactVerification = 7,
}
impl TaskType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TASK_TYPE_UNSPECIFIED",
            Self::RetrievalQuery => "RETRIEVAL_QUERY",
            Self::RetrievalDocument => "RETRIEVAL_DOCUMENT",
            Self::SemanticSimilarity => "SEMANTIC_SIMILARITY",
            Self::Classification => "CLASSIFICATION",
            Self::Clustering => "CLUSTERING",
            Self::QuestionAnswering => "QUESTION_ANSWERING",
            Self::FactVerification => "FACT_VERIFICATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TASK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "RETRIEVAL_QUERY" => Some(Self::RetrievalQuery),
            "RETRIEVAL_DOCUMENT" => Some(Self::RetrievalDocument),
            "SEMANTIC_SIMILARITY" => Some(Self::SemanticSimilarity),
            "CLASSIFICATION" => Some(Self::Classification),
            "CLUSTERING" => Some(Self::Clustering),
            "QUESTION_ANSWERING" => Some(Self::QuestionAnswering),
            "FACT_VERIFICATION" => Some(Self::FactVerification),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod generative_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// API for using Large Models that generate multimodal content and have
    /// additional capabilities beyond text generation.
    #[derive(Debug, Clone)]
    pub struct GenerativeServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl GenerativeServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> GenerativeServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GenerativeServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            GenerativeServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Generates a model response given an input `GenerateContentRequest`.
        /// Refer to the [text generation
        /// guide](https://ai.google.dev/gemini-api/docs/text-generation) for detailed
        /// usage information. Input capabilities differ between models, including
        /// tuned models. Refer to the [model
        /// guide](https://ai.google.dev/gemini-api/docs/models/gemini) and [tuning
        /// guide](https://ai.google.dev/gemini-api/docs/model-tuning) for details.
        pub async fn generate_content(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateContentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateContentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.GenerativeService/GenerateContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.GenerativeService",
                        "GenerateContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generates a grounded answer from the model given an input
        /// `GenerateAnswerRequest`.
        pub async fn generate_answer(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateAnswerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateAnswerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.GenerativeService/GenerateAnswer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.GenerativeService",
                        "GenerateAnswer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generates a [streamed
        /// response](https://ai.google.dev/gemini-api/docs/text-generation?lang=python#generate-a-text-stream)
        /// from the model given an input `GenerateContentRequest`.
        pub async fn stream_generate_content(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateContentRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GenerateContentResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.GenerativeService/StreamGenerateContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.GenerativeService",
                        "StreamGenerateContent",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Generates a text embedding vector from the input `Content` using the
        /// specified [Gemini Embedding
        /// model](https://ai.google.dev/gemini-api/docs/models/gemini#text-embedding).
        pub async fn embed_content(
            &mut self,
            request: impl tonic::IntoRequest<super::EmbedContentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EmbedContentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.GenerativeService/EmbedContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.GenerativeService",
                        "EmbedContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generates multiple embedding vectors from the input `Content` which
        /// consists of a batch of strings represented as `EmbedContentRequest`
        /// objects.
        pub async fn batch_embed_contents(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchEmbedContentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchEmbedContentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.GenerativeService/BatchEmbedContents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.GenerativeService",
                        "BatchEmbedContents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Runs a model's tokenizer on input `Content` and returns the token count.
        /// Refer to the [tokens guide](https://ai.google.dev/gemini-api/docs/tokens)
        /// to learn more about tokens.
        pub async fn count_tokens(
            &mut self,
            request: impl tonic::IntoRequest<super::CountTokensRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CountTokensResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.GenerativeService/CountTokens",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.GenerativeService",
                        "CountTokens",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Low-Latency bidirectional streaming API that supports audio and video
        /// streaming inputs can produce multimodal output streams (audio and text).
        pub async fn bidi_generate_content(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::BidiGenerateContentClientMessage,
            >,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::BidiGenerateContentServerMessage>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.GenerativeService/BidiGenerateContent",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.GenerativeService",
                        "BidiGenerateContent",
                    ),
                );
            self.inner.streaming(req, path, codec).await
        }
    }
}
/// Information about a Generative Language Model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Model {
    /// Required. The resource name of the `Model`. Refer to [Model
    /// variants](<https://ai.google.dev/gemini-api/docs/models/gemini#model-variations>)
    /// for all allowed values.
    ///
    /// Format: `models/{model}` with a `{model}` naming convention of:
    ///
    /// * "{base_model_id}-{version}"
    ///
    /// Examples:
    ///
    /// * `models/gemini-1.5-flash-001`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The name of the base model, pass this to the generation request.
    ///
    /// Examples:
    ///
    /// * `gemini-1.5-flash`
    #[prost(string, tag = "2")]
    pub base_model_id: ::prost::alloc::string::String,
    /// Required. The version number of the model.
    ///
    /// This represents the major version (`1.0` or `1.5`)
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// The human-readable name of the model. E.g. "Gemini 1.5 Flash".
    ///
    /// The name can be up to 128 characters long and can consist of any UTF-8
    /// characters.
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    /// A short description of the model.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Maximum number of input tokens allowed for this model.
    #[prost(int32, tag = "6")]
    pub input_token_limit: i32,
    /// Maximum number of output tokens available for this model.
    #[prost(int32, tag = "7")]
    pub output_token_limit: i32,
    /// The model's supported generation methods.
    ///
    /// The corresponding API method names are defined as Pascal case
    /// strings, such as `generateMessage` and `generateContent`.
    #[prost(string, repeated, tag = "8")]
    pub supported_generation_methods: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Controls the randomness of the output.
    ///
    /// Values can range over `\[0.0,max_temperature\]`, inclusive. A higher value
    /// will produce responses that are more varied, while a value closer to `0.0`
    /// will typically result in less surprising responses from the model.
    /// This value specifies default to be used by the backend while making the
    /// call to the model.
    #[prost(float, optional, tag = "9")]
    pub temperature: ::core::option::Option<f32>,
    /// The maximum temperature this model can use.
    #[prost(float, optional, tag = "13")]
    pub max_temperature: ::core::option::Option<f32>,
    /// For [Nucleus
    /// sampling](<https://ai.google.dev/gemini-api/docs/prompting-strategies#top-p>).
    ///
    /// Nucleus sampling considers the smallest set of tokens whose probability
    /// sum is at least `top_p`.
    /// This value specifies default to be used by the backend while making the
    /// call to the model.
    #[prost(float, optional, tag = "10")]
    pub top_p: ::core::option::Option<f32>,
    /// For Top-k sampling.
    ///
    /// Top-k sampling considers the set of `top_k` most probable tokens.
    /// This value specifies default to be used by the backend while making the
    /// call to the model.
    /// If empty, indicates the model doesn't use top-k sampling, and `top_k` isn't
    /// allowed as a generation parameter.
    #[prost(int32, optional, tag = "11")]
    pub top_k: ::core::option::Option<i32>,
}
/// A fine-tuned model created using ModelService.CreateTunedModel.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TunedModel {
    /// Output only. The tuned model name. A unique name will be generated on
    /// create. Example: `tunedModels/az2mb0bpw6i` If display_name is set on
    /// create, the id portion of the name will be set by concatenating the words
    /// of the display_name with hyphens and adding a random portion for
    /// uniqueness.
    ///
    /// Example:
    ///
    ///   * display_name = `Sentence Translator`
    ///   * name = `tunedModels/sentence-translator-u3b7m`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The name to display for this model in user interfaces.
    /// The display name must be up to 40 characters including spaces.
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. A short description of this model.
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    /// Optional. Controls the randomness of the output.
    ///
    /// Values can range over `\[0.0,1.0\]`, inclusive. A value closer to `1.0` will
    /// produce responses that are more varied, while a value closer to `0.0` will
    /// typically result in less surprising responses from the model.
    ///
    /// This value specifies default to be the one used by the base model while
    /// creating the model.
    #[prost(float, optional, tag = "11")]
    pub temperature: ::core::option::Option<f32>,
    /// Optional. For Nucleus sampling.
    ///
    /// Nucleus sampling considers the smallest set of tokens whose probability
    /// sum is at least `top_p`.
    ///
    /// This value specifies default to be the one used by the base model while
    /// creating the model.
    #[prost(float, optional, tag = "12")]
    pub top_p: ::core::option::Option<f32>,
    /// Optional. For Top-k sampling.
    ///
    /// Top-k sampling considers the set of `top_k` most probable tokens.
    /// This value specifies default to be used by the backend while making the
    /// call to the model.
    ///
    /// This value specifies default to be the one used by the base model while
    /// creating the model.
    #[prost(int32, optional, tag = "13")]
    pub top_k: ::core::option::Option<i32>,
    /// Output only. The state of the tuned model.
    #[prost(enumeration = "tuned_model::State", tag = "7")]
    pub state: i32,
    /// Output only. The timestamp when this model was created.
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when this model was updated.
    #[prost(message, optional, tag = "9")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. The tuning task that creates the tuned model.
    #[prost(message, optional, tag = "10")]
    pub tuning_task: ::core::option::Option<TuningTask>,
    /// Optional. List of project numbers that have read access to the tuned model.
    #[prost(int64, repeated, packed = "false", tag = "14")]
    pub reader_project_numbers: ::prost::alloc::vec::Vec<i64>,
    /// The model used as the starting point for tuning.
    #[prost(oneof = "tuned_model::SourceModel", tags = "3, 4")]
    pub source_model: ::core::option::Option<tuned_model::SourceModel>,
}
/// Nested message and enum types in `TunedModel`.
pub mod tuned_model {
    /// The state of the tuned model.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The default value. This value is unused.
        Unspecified = 0,
        /// The model is being created.
        Creating = 1,
        /// The model is ready to be used.
        Active = 2,
        /// The model failed to be created.
        Failed = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    /// The model used as the starting point for tuning.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SourceModel {
        /// Optional. TunedModel to use as the starting point for training the new
        /// model.
        #[prost(message, tag = "3")]
        TunedModelSource(super::TunedModelSource),
        /// Immutable. The name of the `Model` to tune.
        /// Example: `models/gemini-1.5-flash-001`
        #[prost(string, tag = "4")]
        BaseModel(::prost::alloc::string::String),
    }
}
/// Tuned model as a source for training a new model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TunedModelSource {
    /// Immutable. The name of the `TunedModel` to use as the starting point for
    /// training the new model.
    /// Example: `tunedModels/my-tuned-model`
    #[prost(string, tag = "1")]
    pub tuned_model: ::prost::alloc::string::String,
    /// Output only. The name of the base `Model` this `TunedModel` was tuned from.
    /// Example: `models/gemini-1.5-flash-001`
    #[prost(string, tag = "2")]
    pub base_model: ::prost::alloc::string::String,
}
/// Tuning tasks that create tuned models.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TuningTask {
    /// Output only. The timestamp when tuning this model started.
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when tuning this model completed.
    #[prost(message, optional, tag = "2")]
    pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Metrics collected during tuning.
    #[prost(message, repeated, tag = "3")]
    pub snapshots: ::prost::alloc::vec::Vec<TuningSnapshot>,
    /// Required. Input only. Immutable. The model training data.
    #[prost(message, optional, tag = "4")]
    pub training_data: ::core::option::Option<Dataset>,
    /// Immutable. Hyperparameters controlling the tuning process. If not provided,
    /// default values will be used.
    #[prost(message, optional, tag = "5")]
    pub hyperparameters: ::core::option::Option<Hyperparameters>,
}
/// Hyperparameters controlling the tuning process. Read more at
/// <https://ai.google.dev/docs/model_tuning_guidance>
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Hyperparameters {
    /// Immutable. The number of training epochs. An epoch is one pass through the
    /// training data. If not set, a default of 5 will be used.
    #[prost(int32, optional, tag = "14")]
    pub epoch_count: ::core::option::Option<i32>,
    /// Immutable. The batch size hyperparameter for tuning.
    /// If not set, a default of 4 or 16 will be used based on the number of
    /// training examples.
    #[prost(int32, optional, tag = "15")]
    pub batch_size: ::core::option::Option<i32>,
    /// Options for specifying learning rate during tuning.
    #[prost(oneof = "hyperparameters::LearningRateOption", tags = "16, 17")]
    pub learning_rate_option: ::core::option::Option<
        hyperparameters::LearningRateOption,
    >,
}
/// Nested message and enum types in `Hyperparameters`.
pub mod hyperparameters {
    /// Options for specifying learning rate during tuning.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum LearningRateOption {
        /// Optional. Immutable. The learning rate hyperparameter for tuning.
        /// If not set, a default of 0.001 or 0.0002 will be calculated based on the
        /// number of training examples.
        #[prost(float, tag = "16")]
        LearningRate(f32),
        /// Optional. Immutable. The learning rate multiplier is used to calculate a
        /// final learning_rate based on the default (recommended) value. Actual
        /// learning rate := learning_rate_multiplier * default learning rate Default
        /// learning rate is dependent on base model and dataset size. If not set, a
        /// default of 1.0 will be used.
        #[prost(float, tag = "17")]
        LearningRateMultiplier(f32),
    }
}
/// Dataset for training or validation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dataset {
    /// Inline data or a reference to the data.
    #[prost(oneof = "dataset::Dataset", tags = "1")]
    pub dataset: ::core::option::Option<dataset::Dataset>,
}
/// Nested message and enum types in `Dataset`.
pub mod dataset {
    /// Inline data or a reference to the data.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Dataset {
        /// Optional. Inline examples with simple input/output text.
        #[prost(message, tag = "1")]
        Examples(super::TuningExamples),
    }
}
/// A set of tuning examples. Can be training or validation data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TuningExamples {
    /// The examples. Example input can be for text or discuss, but all examples
    /// in a set must be of the same type.
    #[prost(message, repeated, tag = "1")]
    pub examples: ::prost::alloc::vec::Vec<TuningExample>,
    /// Content examples. For multiturn conversations.
    #[prost(message, repeated, tag = "2")]
    pub multiturn_examples: ::prost::alloc::vec::Vec<TuningMultiturnExample>,
}
/// A datatype containing data that is part of a multi-part `TuningContent`
/// message.
///
/// This is a subset of the Part used for model inference, with limited type
/// support.
///
/// A `Part` consists of data which has an associated datatype. A `Part` can
/// only contain one of the accepted types in `Part.data`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TuningPart {
    /// Data for the part. Only text supported.
    #[prost(oneof = "tuning_part::Data", tags = "2")]
    pub data: ::core::option::Option<tuning_part::Data>,
}
/// Nested message and enum types in `TuningPart`.
pub mod tuning_part {
    /// Data for the part. Only text supported.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        /// Inline text.
        #[prost(string, tag = "2")]
        Text(::prost::alloc::string::String),
    }
}
/// The structured datatype containing multi-part content of an example message.
///
/// This is a subset of the Content proto used during model inference with
/// limited type support. A `Content` includes a `role` field designating the
/// producer of the `Content` and a `parts` field containing multi-part data
/// that contains the content of the message turn.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TuningContent {
    /// Ordered `Parts` that constitute a single message. Parts may have different
    /// MIME types.
    #[prost(message, repeated, tag = "1")]
    pub parts: ::prost::alloc::vec::Vec<TuningPart>,
    /// Optional. The producer of the content. Must be either 'user' or 'model'.
    ///
    /// Useful to set for multi-turn conversations, otherwise can be left blank
    /// or unset.
    #[prost(string, tag = "2")]
    pub role: ::prost::alloc::string::String,
}
/// A tuning example with multiturn input.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TuningMultiturnExample {
    /// Optional. Developer set system instructions.
    /// Currently, text only.
    #[prost(message, optional, tag = "8")]
    pub system_instruction: ::core::option::Option<TuningContent>,
    /// Each Content represents a turn in the conversation.
    #[prost(message, repeated, tag = "1")]
    pub contents: ::prost::alloc::vec::Vec<TuningContent>,
}
/// A single example for tuning.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TuningExample {
    /// Required. The expected model output.
    #[prost(string, tag = "3")]
    pub output: ::prost::alloc::string::String,
    /// The input to the model for this example.
    #[prost(oneof = "tuning_example::ModelInput", tags = "1")]
    pub model_input: ::core::option::Option<tuning_example::ModelInput>,
}
/// Nested message and enum types in `TuningExample`.
pub mod tuning_example {
    /// The input to the model for this example.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ModelInput {
        /// Optional. Text model input.
        #[prost(string, tag = "1")]
        TextInput(::prost::alloc::string::String),
    }
}
/// Record for a single tuning step.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TuningSnapshot {
    /// Output only. The tuning step.
    #[prost(int32, tag = "1")]
    pub step: i32,
    /// Output only. The epoch this step was part of.
    #[prost(int32, tag = "2")]
    pub epoch: i32,
    /// Output only. The mean loss of the training examples for this step.
    #[prost(float, tag = "3")]
    pub mean_loss: f32,
    /// Output only. The timestamp when this metric was computed.
    #[prost(message, optional, tag = "4")]
    pub compute_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request for getting information about a specific Model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModelRequest {
    /// Required. The resource name of the model.
    ///
    /// This name should match a model name returned by the `ListModels` method.
    ///
    /// Format: `models/{model}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for listing all Models.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelsRequest {
    /// The maximum number of `Models` to return (per page).
    ///
    /// If unspecified, 50 models will be returned per page.
    /// This method returns at most 1000 models per page, even if you pass a larger
    /// page_size.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListModels` call.
    ///
    /// Provide the `page_token` returned by one request as an argument to the next
    /// request to retrieve the next page.
    ///
    /// When paginating, all other parameters provided to `ListModels` must match
    /// the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response from `ListModel` containing a paginated list of Models.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelsResponse {
    /// The returned Models.
    #[prost(message, repeated, tag = "1")]
    pub models: ::prost::alloc::vec::Vec<Model>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    ///
    /// If this field is omitted, there are no more pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request for getting information about a specific Model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTunedModelRequest {
    /// Required. The resource name of the model.
    ///
    /// Format: `tunedModels/my-model-id`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for listing TunedModels.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTunedModelsRequest {
    /// Optional. The maximum number of `TunedModels` to return (per page).
    /// The service may return fewer tuned models.
    ///
    /// If unspecified, at most 10 tuned models will be returned.
    /// This method returns at most 1000 models per page, even if you pass a larger
    /// page_size.
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListTunedModels` call.
    ///
    /// Provide the `page_token` returned by one request as an argument to the next
    /// request to retrieve the next page.
    ///
    /// When paginating, all other parameters provided to `ListTunedModels`
    /// must match the call that provided the page token.
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. A filter is a full text search over the tuned model's description
    /// and display name. By default, results will not include tuned models shared
    /// with everyone.
    ///
    /// Additional operators:
    ///    - owner:me
    ///    - writers:me
    ///    - readers:me
    ///    - readers:everyone
    ///
    /// Examples:
    ///    "owner:me" returns all tuned models to which caller has owner role
    ///    "readers:me" returns all tuned models to which caller has reader role
    ///    "readers:everyone" returns all tuned models that are shared with everyone
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
}
/// Response from `ListTunedModels` containing a paginated list of Models.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTunedModelsResponse {
    /// The returned Models.
    #[prost(message, repeated, tag = "1")]
    pub tuned_models: ::prost::alloc::vec::Vec<TunedModel>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    ///
    /// If this field is omitted, there are no more pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request to create a TunedModel.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTunedModelRequest {
    /// Optional. The unique id for the tuned model if specified.
    /// This value should be up to 40 characters, the first character must be a
    /// letter, the last could be a letter or a number. The id must match the
    /// regular expression: `[a-z](\[a-z0-9-\]{0,38}\[a-z0-9\])?`.
    #[prost(string, optional, tag = "1")]
    pub tuned_model_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. The tuned model to create.
    #[prost(message, optional, tag = "2")]
    pub tuned_model: ::core::option::Option<TunedModel>,
}
/// Metadata about the state and progress of creating a tuned model returned from
/// the long-running operation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTunedModelMetadata {
    /// Name of the tuned model associated with the tuning operation.
    #[prost(string, tag = "5")]
    pub tuned_model: ::prost::alloc::string::String,
    /// The total number of tuning steps.
    #[prost(int32, tag = "1")]
    pub total_steps: i32,
    /// The number of steps completed.
    #[prost(int32, tag = "2")]
    pub completed_steps: i32,
    /// The completed percentage for the tuning operation.
    #[prost(float, tag = "3")]
    pub completed_percent: f32,
    /// Metrics collected during tuning.
    #[prost(message, repeated, tag = "4")]
    pub snapshots: ::prost::alloc::vec::Vec<TuningSnapshot>,
}
/// Request to update a TunedModel.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTunedModelRequest {
    /// Required. The tuned model to update.
    #[prost(message, optional, tag = "1")]
    pub tuned_model: ::core::option::Option<TunedModel>,
    /// Optional. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request to delete a TunedModel.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTunedModelRequest {
    /// Required. The resource name of the model.
    /// Format: `tunedModels/my-model-id`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod model_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for getting metadata information about Generative Models.
    #[derive(Debug, Clone)]
    pub struct ModelServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ModelServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ModelServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ModelServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ModelServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Gets information about a specific `Model` such as its version number, token
        /// limits,
        /// [parameters](https://ai.google.dev/gemini-api/docs/models/generative-models#model-parameters)
        /// and other metadata. Refer to the [Gemini models
        /// guide](https://ai.google.dev/gemini-api/docs/models/gemini) for detailed
        /// model information.
        pub async fn get_model(
            &mut self,
            request: impl tonic::IntoRequest<super::GetModelRequest>,
        ) -> std::result::Result<tonic::Response<super::Model>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.ModelService/GetModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.ModelService",
                        "GetModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the [`Model`s](https://ai.google.dev/gemini-api/docs/models/gemini)
        /// available through the Gemini API.
        pub async fn list_models(
            &mut self,
            request: impl tonic::IntoRequest<super::ListModelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListModelsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.ModelService/ListModels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.ModelService",
                        "ListModels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets information about a specific TunedModel.
        pub async fn get_tuned_model(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTunedModelRequest>,
        ) -> std::result::Result<tonic::Response<super::TunedModel>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.ModelService/GetTunedModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.ModelService",
                        "GetTunedModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists created tuned models.
        pub async fn list_tuned_models(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTunedModelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTunedModelsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.ModelService/ListTunedModels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.ModelService",
                        "ListTunedModels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a tuned model.
        /// Check intermediate tuning progress (if any) through the
        /// [google.longrunning.Operations] service.
        ///
        /// Access status and results through the Operations service.
        /// Example:
        ///   GET /v1/tunedModels/az2mb0bpw6i/operations/000-111-222
        pub async fn create_tuned_model(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTunedModelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.ModelService/CreateTunedModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.ModelService",
                        "CreateTunedModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a tuned model.
        pub async fn update_tuned_model(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateTunedModelRequest>,
        ) -> std::result::Result<tonic::Response<super::TunedModel>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.ModelService/UpdateTunedModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.ModelService",
                        "UpdateTunedModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a tuned model.
        pub async fn delete_tuned_model(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTunedModelRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.ModelService/DeleteTunedModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.ModelService",
                        "DeleteTunedModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Permission resource grants user, group or the rest of the world access to the
/// PaLM API resource (e.g. a tuned model, corpus).
///
/// A role is a collection of permitted operations that allows users to perform
/// specific actions on PaLM API resources. To make them available to users,
/// groups, or service accounts, you assign roles. When you assign a role, you
/// grant permissions that the role contains.
///
/// There are three concentric roles. Each role is a superset of the previous
/// role's permitted operations:
///
/// - reader can use the resource (e.g. tuned model, corpus) for inference
/// - writer has reader's permissions and additionally can edit and share
/// - owner has writer's permissions and additionally can delete
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Permission {
    /// Output only. Identifier. The permission name. A unique name will be
    /// generated on create. Examples:
    ///      tunedModels/{tuned_model}/permissions/{permission}
    ///      corpora/{corpus}/permissions/{permission}
    /// Output only.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Immutable. The type of the grantee.
    #[prost(enumeration = "permission::GranteeType", optional, tag = "2")]
    pub grantee_type: ::core::option::Option<i32>,
    /// Optional. Immutable. The email address of the user of group which this
    /// permission refers. Field is not set when permission's grantee type is
    /// EVERYONE.
    #[prost(string, optional, tag = "3")]
    pub email_address: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. The role granted by this permission.
    #[prost(enumeration = "permission::Role", optional, tag = "4")]
    pub role: ::core::option::Option<i32>,
}
/// Nested message and enum types in `Permission`.
pub mod permission {
    /// Defines types of the grantee of this permission.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GranteeType {
        /// The default value. This value is unused.
        Unspecified = 0,
        /// Represents a user. When set, you must provide email_address for the user.
        User = 1,
        /// Represents a group. When set, you must provide email_address for the
        /// group.
        Group = 2,
        /// Represents access to everyone. No extra information is required.
        Everyone = 3,
    }
    impl GranteeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "GRANTEE_TYPE_UNSPECIFIED",
                Self::User => "USER",
                Self::Group => "GROUP",
                Self::Everyone => "EVERYONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GRANTEE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "USER" => Some(Self::User),
                "GROUP" => Some(Self::Group),
                "EVERYONE" => Some(Self::Everyone),
                _ => None,
            }
        }
    }
    /// Defines the role granted by this permission.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Role {
        /// The default value. This value is unused.
        Unspecified = 0,
        /// Owner can use, update, share and delete the resource.
        Owner = 1,
        /// Writer can use, update and share the resource.
        Writer = 2,
        /// Reader can use the resource.
        Reader = 3,
    }
    impl Role {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ROLE_UNSPECIFIED",
                Self::Owner => "OWNER",
                Self::Writer => "WRITER",
                Self::Reader => "READER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROLE_UNSPECIFIED" => Some(Self::Unspecified),
                "OWNER" => Some(Self::Owner),
                "WRITER" => Some(Self::Writer),
                "READER" => Some(Self::Reader),
                _ => None,
            }
        }
    }
}
/// Request to create a `Permission`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePermissionRequest {
    /// Required. The parent resource of the `Permission`.
    /// Formats:
    ///     `tunedModels/{tuned_model}`
    ///     `corpora/{corpus}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The permission to create.
    #[prost(message, optional, tag = "2")]
    pub permission: ::core::option::Option<Permission>,
}
/// Request for getting information about a specific `Permission`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPermissionRequest {
    /// Required. The resource name of the permission.
    ///
    /// Formats:
    ///     `tunedModels/{tuned_model}/permissions/{permission}`
    ///     `corpora/{corpus}/permissions/{permission}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for listing permissions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPermissionsRequest {
    /// Required. The parent resource of the permissions.
    /// Formats:
    ///     `tunedModels/{tuned_model}`
    ///     `corpora/{corpus}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `Permission`s to return (per page).
    /// The service may return fewer permissions.
    ///
    /// If unspecified, at most 10 permissions will be returned.
    /// This method returns at most 1000 permissions per page, even if you pass
    /// larger page_size.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListPermissions` call.
    ///
    /// Provide the `page_token` returned by one request as an argument to the
    /// next request to retrieve the next page.
    ///
    /// When paginating, all other parameters provided to `ListPermissions`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response from `ListPermissions` containing a paginated list of
/// permissions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPermissionsResponse {
    /// Returned permissions.
    #[prost(message, repeated, tag = "1")]
    pub permissions: ::prost::alloc::vec::Vec<Permission>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    ///
    /// If this field is omitted, there are no more pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request to update the `Permission`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePermissionRequest {
    /// Required. The permission to update.
    ///
    /// The permission's `name` field is used to identify the permission to update.
    #[prost(message, optional, tag = "1")]
    pub permission: ::core::option::Option<Permission>,
    /// Required. The list of fields to update. Accepted ones:
    ///   - role (`Permission.role` field)
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request to delete the `Permission`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePermissionRequest {
    /// Required. The resource name of the permission.
    /// Formats:
    ///     `tunedModels/{tuned_model}/permissions/{permission}`
    ///     `corpora/{corpus}/permissions/{permission}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request to transfer the ownership of the tuned model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferOwnershipRequest {
    /// Required. The resource name of the tuned model to transfer ownership.
    ///
    /// Format: `tunedModels/my-model-id`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The email address of the user to whom the tuned model is being
    /// transferred to.
    #[prost(string, tag = "2")]
    pub email_address: ::prost::alloc::string::String,
}
/// Response from `TransferOwnership`.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TransferOwnershipResponse {}
/// Generated client implementations.
pub mod permission_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for managing permissions to PaLM API resources.
    #[derive(Debug, Clone)]
    pub struct PermissionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PermissionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PermissionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PermissionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            PermissionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a permission to a specific resource.
        pub async fn create_permission(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePermissionRequest>,
        ) -> std::result::Result<tonic::Response<super::Permission>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.PermissionService/CreatePermission",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.PermissionService",
                        "CreatePermission",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets information about a specific Permission.
        pub async fn get_permission(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPermissionRequest>,
        ) -> std::result::Result<tonic::Response<super::Permission>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.PermissionService/GetPermission",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.PermissionService",
                        "GetPermission",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists permissions for the specific resource.
        pub async fn list_permissions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPermissionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.PermissionService/ListPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.PermissionService",
                        "ListPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the permission.
        pub async fn update_permission(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePermissionRequest>,
        ) -> std::result::Result<tonic::Response<super::Permission>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.PermissionService/UpdatePermission",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.PermissionService",
                        "UpdatePermission",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the permission.
        pub async fn delete_permission(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePermissionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.PermissionService/DeletePermission",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.PermissionService",
                        "DeletePermission",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Transfers ownership of the tuned model.
        /// This is the only way to change ownership of the tuned model.
        /// The current owner will be downgraded to writer role.
        pub async fn transfer_ownership(
            &mut self,
            request: impl tonic::IntoRequest<super::TransferOwnershipRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TransferOwnershipResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.PermissionService/TransferOwnership",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.PermissionService",
                        "TransferOwnership",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Request message for
/// [PredictionService.Predict][google.ai.generativelanguage.v1alpha.PredictionService.Predict].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredictRequest {
    /// Required. The name of the model for prediction.
    /// Format: `name=models/{model}`.
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    /// Required. The instances that are the input to the prediction call.
    #[prost(message, repeated, tag = "2")]
    pub instances: ::prost::alloc::vec::Vec<::prost_types::Value>,
    /// Optional. The parameters that govern the prediction call.
    #[prost(message, optional, tag = "3")]
    pub parameters: ::core::option::Option<::prost_types::Value>,
}
/// Response message for \[PredictionService.Predict\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredictResponse {
    /// The outputs of the prediction call.
    #[prost(message, repeated, tag = "1")]
    pub predictions: ::prost::alloc::vec::Vec<::prost_types::Value>,
}
/// Generated client implementations.
pub mod prediction_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// A service for online predictions and explanations.
    #[derive(Debug, Clone)]
    pub struct PredictionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PredictionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PredictionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PredictionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            PredictionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Performs a prediction request.
        pub async fn predict(
            &mut self,
            request: impl tonic::IntoRequest<super::PredictRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PredictResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.PredictionService/Predict",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.PredictionService",
                        "Predict",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Request to create a `Corpus`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCorpusRequest {
    /// Required. The `Corpus` to create.
    #[prost(message, optional, tag = "1")]
    pub corpus: ::core::option::Option<Corpus>,
}
/// Request for getting information about a specific `Corpus`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCorpusRequest {
    /// Required. The name of the `Corpus`.
    /// Example: `corpora/my-corpus-123`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request to update a `Corpus`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCorpusRequest {
    /// Required. The `Corpus` to update.
    #[prost(message, optional, tag = "1")]
    pub corpus: ::core::option::Option<Corpus>,
    /// Required. The list of fields to update.
    /// Currently, this only supports updating `display_name`.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request to delete a `Corpus`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCorpusRequest {
    /// Required. The resource name of the `Corpus`.
    /// Example: `corpora/my-corpus-123`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If set to true, any `Document`s and objects related to this
    /// `Corpus` will also be deleted.
    ///
    /// If false (the default), a `FAILED_PRECONDITION` error will be returned if
    /// `Corpus` contains any `Document`s.
    #[prost(bool, tag = "2")]
    pub force: bool,
}
/// Request for listing `Corpora`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCorporaRequest {
    /// Optional. The maximum number of `Corpora` to return (per page).
    /// The service may return fewer `Corpora`.
    ///
    /// If unspecified, at most 10 `Corpora` will be returned.
    /// The maximum size limit is 20 `Corpora` per page.
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListCorpora` call.
    ///
    /// Provide the `next_page_token` returned in the response as an argument to
    /// the next request to retrieve the next page.
    ///
    /// When paginating, all other parameters provided to `ListCorpora`
    /// must match the call that provided the page token.
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response from `ListCorpora` containing a paginated list of `Corpora`.
/// The results are sorted by ascending `corpus.create_time`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCorporaResponse {
    /// The returned corpora.
    #[prost(message, repeated, tag = "1")]
    pub corpora: ::prost::alloc::vec::Vec<Corpus>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no more pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request for querying a `Corpus`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryCorpusRequest {
    /// Required. The name of the `Corpus` to query.
    /// Example: `corpora/my-corpus-123`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Query string to perform semantic search.
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    /// Optional. Filter for `Chunk` and `Document` metadata. Each `MetadataFilter`
    /// object should correspond to a unique key. Multiple `MetadataFilter` objects
    /// are joined by logical "AND"s.
    ///
    /// Example query at document level:
    /// (year >= 2020 OR year < 2010) AND (genre = drama OR genre = action)
    ///
    /// `MetadataFilter` object list:
    ///   metadata_filters = [
    ///   {key = "document.custom_metadata.year"
    ///    conditions = [{int_value = 2020, operation = GREATER_EQUAL},
    ///                  {int_value = 2010, operation = LESS}]},
    ///   {key = "document.custom_metadata.year"
    ///    conditions = [{int_value = 2020, operation = GREATER_EQUAL},
    ///                  {int_value = 2010, operation = LESS}]},
    ///   {key = "document.custom_metadata.genre"
    ///    conditions = [{string_value = "drama", operation = EQUAL},
    ///                  {string_value = "action", operation = EQUAL}]}]
    ///
    /// Example query at chunk level for a numeric range of values:
    /// (year > 2015 AND year <= 2020)
    ///
    /// `MetadataFilter` object list:
    ///   metadata_filters = [
    ///   {key = "chunk.custom_metadata.year"
    ///    conditions = \[{int_value = 2015, operation = GREATER}\]},
    ///   {key = "chunk.custom_metadata.year"
    ///    conditions = \[{int_value = 2020, operation = LESS_EQUAL}\]}]
    ///
    /// Note: "AND"s for the same key are only supported for numeric values. String
    /// values only support "OR"s for the same key.
    #[prost(message, repeated, tag = "3")]
    pub metadata_filters: ::prost::alloc::vec::Vec<MetadataFilter>,
    /// Optional. The maximum number of `Chunk`s to return.
    /// The service may return fewer `Chunk`s.
    ///
    /// If unspecified, at most 10 `Chunk`s will be returned.
    /// The maximum specified result count is 100.
    #[prost(int32, tag = "4")]
    pub results_count: i32,
}
/// Response from `QueryCorpus` containing a list of relevant chunks.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryCorpusResponse {
    /// The relevant chunks.
    #[prost(message, repeated, tag = "1")]
    pub relevant_chunks: ::prost::alloc::vec::Vec<RelevantChunk>,
}
/// The information for a chunk relevant to a query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelevantChunk {
    /// `Chunk` relevance to the query.
    #[prost(float, tag = "1")]
    pub chunk_relevance_score: f32,
    /// `Chunk` associated with the query.
    #[prost(message, optional, tag = "2")]
    pub chunk: ::core::option::Option<Chunk>,
}
/// Request to create a `Document`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDocumentRequest {
    /// Required. The name of the `Corpus` where this `Document` will be created.
    /// Example: `corpora/my-corpus-123`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `Document` to create.
    #[prost(message, optional, tag = "2")]
    pub document: ::core::option::Option<Document>,
}
/// Request for getting information about a specific `Document`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDocumentRequest {
    /// Required. The name of the `Document` to retrieve.
    /// Example: `corpora/my-corpus-123/documents/the-doc-abc`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request to update a `Document`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDocumentRequest {
    /// Required. The `Document` to update.
    #[prost(message, optional, tag = "1")]
    pub document: ::core::option::Option<Document>,
    /// Required. The list of fields to update.
    /// Currently, this only supports updating `display_name` and
    /// `custom_metadata`.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request to delete a `Document`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDocumentRequest {
    /// Required. The resource name of the `Document` to delete.
    /// Example: `corpora/my-corpus-123/documents/the-doc-abc`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If set to true, any `Chunk`s and objects related to this
    /// `Document` will also be deleted.
    ///
    /// If false (the default), a `FAILED_PRECONDITION` error will be returned if
    /// `Document` contains any `Chunk`s.
    #[prost(bool, tag = "2")]
    pub force: bool,
}
/// Request for listing `Document`s.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentsRequest {
    /// Required. The name of the `Corpus` containing `Document`s.
    /// Example: `corpora/my-corpus-123`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `Document`s to return (per page).
    /// The service may return fewer `Document`s.
    ///
    /// If unspecified, at most 10 `Document`s will be returned.
    /// The maximum size limit is 20 `Document`s per page.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListDocuments` call.
    ///
    /// Provide the `next_page_token` returned in the response as an argument to
    /// the next request to retrieve the next page.
    ///
    /// When paginating, all other parameters provided to `ListDocuments`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response from `ListDocuments` containing a paginated list of `Document`s.
/// The `Document`s are sorted by ascending `document.create_time`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentsResponse {
    /// The returned `Document`s.
    #[prost(message, repeated, tag = "1")]
    pub documents: ::prost::alloc::vec::Vec<Document>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no more pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request for querying a `Document`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDocumentRequest {
    /// Required. The name of the `Document` to query.
    /// Example: `corpora/my-corpus-123/documents/the-doc-abc`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Query string to perform semantic search.
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    /// Optional. The maximum number of `Chunk`s to return.
    /// The service may return fewer `Chunk`s.
    ///
    /// If unspecified, at most 10 `Chunk`s will be returned.
    /// The maximum specified result count is 100.
    #[prost(int32, tag = "3")]
    pub results_count: i32,
    /// Optional. Filter for `Chunk` metadata. Each `MetadataFilter` object should
    /// correspond to a unique key. Multiple `MetadataFilter` objects are joined by
    /// logical "AND"s.
    ///
    /// Note: `Document`-level filtering is not supported for this request because
    /// a `Document` name is already specified.
    ///
    /// Example query:
    /// (year >= 2020 OR year < 2010) AND (genre = drama OR genre = action)
    ///
    /// `MetadataFilter` object list:
    ///   metadata_filters = [
    ///   {key = "chunk.custom_metadata.year"
    ///    conditions = [{int_value = 2020, operation = GREATER_EQUAL},
    ///                  {int_value = 2010, operation = LESS}},
    ///   {key = "chunk.custom_metadata.genre"
    ///    conditions = [{string_value = "drama", operation = EQUAL},
    ///                  {string_value = "action", operation = EQUAL}}]
    ///
    /// Example query for a numeric range of values:
    /// (year > 2015 AND year <= 2020)
    ///
    /// `MetadataFilter` object list:
    ///   metadata_filters = [
    ///   {key = "chunk.custom_metadata.year"
    ///    conditions = \[{int_value = 2015, operation = GREATER}\]},
    ///   {key = "chunk.custom_metadata.year"
    ///    conditions = \[{int_value = 2020, operation = LESS_EQUAL}\]}]
    ///
    /// Note: "AND"s for the same key are only supported for numeric values. String
    /// values only support "OR"s for the same key.
    #[prost(message, repeated, tag = "4")]
    pub metadata_filters: ::prost::alloc::vec::Vec<MetadataFilter>,
}
/// Response from `QueryDocument` containing a list of relevant chunks.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDocumentResponse {
    /// The returned relevant chunks.
    #[prost(message, repeated, tag = "1")]
    pub relevant_chunks: ::prost::alloc::vec::Vec<RelevantChunk>,
}
/// Request to create a `Chunk`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateChunkRequest {
    /// Required. The name of the `Document` where this `Chunk` will be created.
    /// Example: `corpora/my-corpus-123/documents/the-doc-abc`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `Chunk` to create.
    #[prost(message, optional, tag = "2")]
    pub chunk: ::core::option::Option<Chunk>,
}
/// Request to batch create `Chunk`s.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateChunksRequest {
    /// Optional. The name of the `Document` where this batch of `Chunk`s will be
    /// created. The parent field in every `CreateChunkRequest` must match this
    /// value. Example: `corpora/my-corpus-123/documents/the-doc-abc`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The request messages specifying the `Chunk`s to create.
    /// A maximum of 100 `Chunk`s can be created in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateChunkRequest>,
}
/// Response from `BatchCreateChunks` containing a list of created `Chunk`s.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateChunksResponse {
    /// `Chunk`s created.
    #[prost(message, repeated, tag = "1")]
    pub chunks: ::prost::alloc::vec::Vec<Chunk>,
}
/// Request for getting information about a specific `Chunk`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChunkRequest {
    /// Required. The name of the `Chunk` to retrieve.
    /// Example: `corpora/my-corpus-123/documents/the-doc-abc/chunks/some-chunk`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request to update a `Chunk`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateChunkRequest {
    /// Required. The `Chunk` to update.
    #[prost(message, optional, tag = "1")]
    pub chunk: ::core::option::Option<Chunk>,
    /// Required. The list of fields to update.
    /// Currently, this only supports updating `custom_metadata` and `data`.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request to batch update `Chunk`s.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateChunksRequest {
    /// Optional. The name of the `Document` containing the `Chunk`s to update.
    /// The parent field in every `UpdateChunkRequest` must match this value.
    /// Example: `corpora/my-corpus-123/documents/the-doc-abc`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The request messages specifying the `Chunk`s to update.
    /// A maximum of 100 `Chunk`s can be updated in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<UpdateChunkRequest>,
}
/// Response from `BatchUpdateChunks` containing a list of updated `Chunk`s.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateChunksResponse {
    /// `Chunk`s updated.
    #[prost(message, repeated, tag = "1")]
    pub chunks: ::prost::alloc::vec::Vec<Chunk>,
}
/// Request to delete a `Chunk`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteChunkRequest {
    /// Required. The resource name of the `Chunk` to delete.
    /// Example: `corpora/my-corpus-123/documents/the-doc-abc/chunks/some-chunk`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request to batch delete `Chunk`s.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchDeleteChunksRequest {
    /// Optional. The name of the `Document` containing the `Chunk`s to delete.
    /// The parent field in every `DeleteChunkRequest` must match this value.
    /// Example: `corpora/my-corpus-123/documents/the-doc-abc`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The request messages specifying the `Chunk`s to delete.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<DeleteChunkRequest>,
}
/// Request for listing `Chunk`s.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChunksRequest {
    /// Required. The name of the `Document` containing `Chunk`s.
    /// Example: `corpora/my-corpus-123/documents/the-doc-abc`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `Chunk`s to return (per page).
    /// The service may return fewer `Chunk`s.
    ///
    /// If unspecified, at most 10 `Chunk`s will be returned.
    /// The maximum size limit is 100 `Chunk`s per page.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListChunks` call.
    ///
    /// Provide the `next_page_token` returned in the response as an argument to
    /// the next request to retrieve the next page.
    ///
    /// When paginating, all other parameters provided to `ListChunks`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response from `ListChunks` containing a paginated list of `Chunk`s.
/// The `Chunk`s are sorted by ascending `chunk.create_time`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChunksResponse {
    /// The returned `Chunk`s.
    #[prost(message, repeated, tag = "1")]
    pub chunks: ::prost::alloc::vec::Vec<Chunk>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no more pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod retriever_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// An API for semantic search over a corpus of user uploaded content.
    #[derive(Debug, Clone)]
    pub struct RetrieverServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RetrieverServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RetrieverServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RetrieverServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            RetrieverServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates an empty `Corpus`.
        pub async fn create_corpus(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCorpusRequest>,
        ) -> std::result::Result<tonic::Response<super::Corpus>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/CreateCorpus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "CreateCorpus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets information about a specific `Corpus`.
        pub async fn get_corpus(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCorpusRequest>,
        ) -> std::result::Result<tonic::Response<super::Corpus>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/GetCorpus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "GetCorpus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a `Corpus`.
        pub async fn update_corpus(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCorpusRequest>,
        ) -> std::result::Result<tonic::Response<super::Corpus>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/UpdateCorpus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "UpdateCorpus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a `Corpus`.
        pub async fn delete_corpus(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCorpusRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/DeleteCorpus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "DeleteCorpus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all `Corpora` owned by the user.
        pub async fn list_corpora(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCorporaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCorporaResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/ListCorpora",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "ListCorpora",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Performs semantic search over a `Corpus`.
        pub async fn query_corpus(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryCorpusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryCorpusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/QueryCorpus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "QueryCorpus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an empty `Document`.
        pub async fn create_document(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDocumentRequest>,
        ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/CreateDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "CreateDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets information about a specific `Document`.
        pub async fn get_document(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDocumentRequest>,
        ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/GetDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "GetDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a `Document`.
        pub async fn update_document(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDocumentRequest>,
        ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/UpdateDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "UpdateDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a `Document`.
        pub async fn delete_document(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDocumentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/DeleteDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "DeleteDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all `Document`s in a `Corpus`.
        pub async fn list_documents(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDocumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDocumentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/ListDocuments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "ListDocuments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Performs semantic search over a `Document`.
        pub async fn query_document(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryDocumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryDocumentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/QueryDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "QueryDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a `Chunk`.
        pub async fn create_chunk(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateChunkRequest>,
        ) -> std::result::Result<tonic::Response<super::Chunk>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/CreateChunk",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "CreateChunk",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Batch create `Chunk`s.
        pub async fn batch_create_chunks(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCreateChunksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchCreateChunksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/BatchCreateChunks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "BatchCreateChunks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets information about a specific `Chunk`.
        pub async fn get_chunk(
            &mut self,
            request: impl tonic::IntoRequest<super::GetChunkRequest>,
        ) -> std::result::Result<tonic::Response<super::Chunk>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/GetChunk",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "GetChunk",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a `Chunk`.
        pub async fn update_chunk(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateChunkRequest>,
        ) -> std::result::Result<tonic::Response<super::Chunk>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/UpdateChunk",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "UpdateChunk",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Batch update `Chunk`s.
        pub async fn batch_update_chunks(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchUpdateChunksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchUpdateChunksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/BatchUpdateChunks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "BatchUpdateChunks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a `Chunk`.
        pub async fn delete_chunk(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteChunkRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/DeleteChunk",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "DeleteChunk",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Batch delete `Chunk`s.
        pub async fn batch_delete_chunks(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchDeleteChunksRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/BatchDeleteChunks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "BatchDeleteChunks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all `Chunk`s in a `Document`.
        pub async fn list_chunks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListChunksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListChunksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.RetrieverService/ListChunks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.RetrieverService",
                        "ListChunks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Request to generate a text completion response from the model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateTextRequest {
    /// Required. The name of the `Model` or `TunedModel` to use for generating the
    /// completion.
    /// Examples:
    ///   models/text-bison-001
    ///   tunedModels/sentence-translator-u3b7m
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    /// Required. The free-form input text given to the model as a prompt.
    ///
    /// Given a prompt, the model will generate a TextCompletion response it
    /// predicts as the completion of the input text.
    #[prost(message, optional, tag = "2")]
    pub prompt: ::core::option::Option<TextPrompt>,
    /// Optional. Controls the randomness of the output.
    /// Note: The default value varies by model, see the `Model.temperature`
    /// attribute of the `Model` returned the `getModel` function.
    ///
    /// Values can range from \[0.0,1.0\],
    /// inclusive. A value closer to 1.0 will produce responses that are more
    /// varied and creative, while a value closer to 0.0 will typically result in
    /// more straightforward responses from the model.
    #[prost(float, optional, tag = "3")]
    pub temperature: ::core::option::Option<f32>,
    /// Optional. Number of generated responses to return.
    ///
    /// This value must be between \[1, 8\], inclusive. If unset, this will default
    /// to 1.
    #[prost(int32, optional, tag = "4")]
    pub candidate_count: ::core::option::Option<i32>,
    /// Optional. The maximum number of tokens to include in a candidate.
    ///
    /// If unset, this will default to output_token_limit specified in the `Model`
    /// specification.
    #[prost(int32, optional, tag = "5")]
    pub max_output_tokens: ::core::option::Option<i32>,
    /// Optional. The maximum cumulative probability of tokens to consider when
    /// sampling.
    ///
    /// The model uses combined Top-k and nucleus sampling.
    ///
    /// Tokens are sorted based on their assigned probabilities so that only the
    /// most likely tokens are considered. Top-k sampling directly limits the
    /// maximum number of tokens to consider, while Nucleus sampling limits number
    /// of tokens based on the cumulative probability.
    ///
    /// Note: The default value varies by model, see the `Model.top_p`
    /// attribute of the `Model` returned the `getModel` function.
    #[prost(float, optional, tag = "6")]
    pub top_p: ::core::option::Option<f32>,
    /// Optional. The maximum number of tokens to consider when sampling.
    ///
    /// The model uses combined Top-k and nucleus sampling.
    ///
    /// Top-k sampling considers the set of `top_k` most probable tokens.
    /// Defaults to 40.
    ///
    /// Note: The default value varies by model, see the `Model.top_k`
    /// attribute of the `Model` returned the `getModel` function.
    #[prost(int32, optional, tag = "7")]
    pub top_k: ::core::option::Option<i32>,
    /// Optional. A list of unique `SafetySetting` instances for blocking unsafe
    /// content.
    ///
    /// that will be enforced on the `GenerateTextRequest.prompt` and
    /// `GenerateTextResponse.candidates`. There should not be more than one
    /// setting for each `SafetyCategory` type. The API will block any prompts and
    /// responses that fail to meet the thresholds set by these settings. This list
    /// overrides the default settings for each `SafetyCategory` specified in the
    /// safety_settings. If there is no `SafetySetting` for a given
    /// `SafetyCategory` provided in the list, the API will use the default safety
    /// setting for that category. Harm categories HARM_CATEGORY_DEROGATORY,
    /// HARM_CATEGORY_TOXICITY, HARM_CATEGORY_VIOLENCE, HARM_CATEGORY_SEXUAL,
    /// HARM_CATEGORY_MEDICAL, HARM_CATEGORY_DANGEROUS are supported in text
    /// service.
    #[prost(message, repeated, tag = "8")]
    pub safety_settings: ::prost::alloc::vec::Vec<SafetySetting>,
    /// The set of character sequences (up to 5) that will stop output generation.
    /// If specified, the API will stop at the first appearance of a stop
    /// sequence. The stop sequence will not be included as part of the response.
    #[prost(string, repeated, tag = "9")]
    pub stop_sequences: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The response from the model, including candidate completions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateTextResponse {
    /// Candidate responses from the model.
    #[prost(message, repeated, tag = "1")]
    pub candidates: ::prost::alloc::vec::Vec<TextCompletion>,
    /// A set of content filtering metadata for the prompt and response
    /// text.
    ///
    /// This indicates which `SafetyCategory`(s) blocked a
    /// candidate from this response, the lowest `HarmProbability`
    /// that triggered a block, and the HarmThreshold setting for that category.
    /// This indicates the smallest change to the `SafetySettings` that would be
    /// necessary to unblock at least 1 response.
    ///
    /// The blocking is configured by the `SafetySettings` in the request (or the
    /// default `SafetySettings` of the API).
    #[prost(message, repeated, tag = "3")]
    pub filters: ::prost::alloc::vec::Vec<ContentFilter>,
    /// Returns any safety feedback related to content filtering.
    #[prost(message, repeated, tag = "4")]
    pub safety_feedback: ::prost::alloc::vec::Vec<SafetyFeedback>,
}
/// Text given to the model as a prompt.
///
/// The Model will use this TextPrompt to Generate a text completion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextPrompt {
    /// Required. The prompt text.
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
/// Output text returned from a model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextCompletion {
    /// Output only. The generated text returned from the model.
    #[prost(string, tag = "1")]
    pub output: ::prost::alloc::string::String,
    /// Ratings for the safety of a response.
    ///
    /// There is at most one rating per category.
    #[prost(message, repeated, tag = "2")]
    pub safety_ratings: ::prost::alloc::vec::Vec<SafetyRating>,
    /// Output only. Citation information for model-generated `output` in this
    /// `TextCompletion`.
    ///
    /// This field may be populated with attribution information for any text
    /// included in the `output`.
    #[prost(message, optional, tag = "3")]
    pub citation_metadata: ::core::option::Option<CitationMetadata>,
}
/// Request to get a text embedding from the model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmbedTextRequest {
    /// Required. The model name to use with the format model=models/{model}.
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    /// Optional. The free-form input text that the model will turn into an
    /// embedding.
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
/// The response to a EmbedTextRequest.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EmbedTextResponse {
    /// Output only. The embedding generated from the input text.
    #[prost(message, optional, tag = "1")]
    pub embedding: ::core::option::Option<Embedding>,
}
/// Batch request to get a text embedding from the model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchEmbedTextRequest {
    /// Required. The name of the `Model` to use for generating the embedding.
    /// Examples:
    ///   models/embedding-gecko-001
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    /// Optional. The free-form input texts that the model will turn into an
    /// embedding. The current limit is 100 texts, over which an error will be
    /// thrown.
    #[prost(string, repeated, tag = "2")]
    pub texts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Embed requests for the batch. Only one of `texts` or `requests`
    /// can be set.
    #[prost(message, repeated, tag = "3")]
    pub requests: ::prost::alloc::vec::Vec<EmbedTextRequest>,
}
/// The response to a EmbedTextRequest.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchEmbedTextResponse {
    /// Output only. The embeddings generated from the input text.
    #[prost(message, repeated, tag = "1")]
    pub embeddings: ::prost::alloc::vec::Vec<Embedding>,
}
/// A list of floats representing the embedding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Embedding {
    /// The embedding values.
    #[prost(float, repeated, tag = "1")]
    pub value: ::prost::alloc::vec::Vec<f32>,
}
/// Counts the number of tokens in the `prompt` sent to a model.
///
/// Models may tokenize text differently, so each model may return a different
/// `token_count`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountTextTokensRequest {
    /// Required. The model's resource name. This serves as an ID for the Model to
    /// use.
    ///
    /// This name should match a model name returned by the `ListModels` method.
    ///
    /// Format: `models/{model}`
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    /// Required. The free-form input text given to the model as a prompt.
    #[prost(message, optional, tag = "2")]
    pub prompt: ::core::option::Option<TextPrompt>,
}
/// A response from `CountTextTokens`.
///
/// It returns the model's `token_count` for the `prompt`.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CountTextTokensResponse {
    /// The number of tokens that the `model` tokenizes the `prompt` into.
    ///
    /// Always non-negative.
    #[prost(int32, tag = "1")]
    pub token_count: i32,
}
/// Generated client implementations.
pub mod text_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// API for using Generative Language Models (GLMs) trained to generate text.
    ///
    /// Also known as Large Language Models (LLM)s, these generate text given an
    /// input prompt from the user.
    #[derive(Debug, Clone)]
    pub struct TextServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TextServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TextServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TextServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TextServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Generates a response from the model given an input message.
        pub async fn generate_text(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateTextRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateTextResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.TextService/GenerateText",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.TextService",
                        "GenerateText",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generates an embedding from the model given an input message.
        pub async fn embed_text(
            &mut self,
            request: impl tonic::IntoRequest<super::EmbedTextRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EmbedTextResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.TextService/EmbedText",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.TextService",
                        "EmbedText",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generates multiple embeddings from the model given input text in a
        /// synchronous call.
        pub async fn batch_embed_text(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchEmbedTextRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchEmbedTextResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.TextService/BatchEmbedText",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.TextService",
                        "BatchEmbedText",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Runs a model's tokenizer on a text and returns the token count.
        pub async fn count_text_tokens(
            &mut self,
            request: impl tonic::IntoRequest<super::CountTextTokensRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CountTextTokensResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ai.generativelanguage.v1alpha.TextService/CountTextTokens",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ai.generativelanguage.v1alpha.TextService",
                        "CountTextTokens",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
