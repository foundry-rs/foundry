// This file is @generated by prost-build.
/// A lake is a centralized repository for managing enterprise data across the
/// organization distributed across many cloud projects, and stored in a variety
/// of storage services such as Google Cloud Storage and BigQuery. The resources
/// attached to a lake are referred to as managed resources. Data within these
/// managed resources can be structured or unstructured. A lake provides data
/// admins with tools to organize, secure and manage their data at scale, and
/// provides data scientists and data engineers an integrated experience to
/// easily search, discover, analyze and transform data and associated metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Lake {
    /// Output only. The relative resource name of the lake, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the lake. This ID will
    /// be different if the lake is deleted and re-created with the same name.
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the lake was created.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the lake was last updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. User-defined labels for the lake.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Description of the lake.
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Current state of the lake.
    #[prost(enumeration = "State", tag = "8")]
    pub state: i32,
    /// Output only. Service account associated with this lake. This service
    /// account must be authorized to access or operate on resources managed by the
    /// lake.
    #[prost(string, tag = "9")]
    pub service_account: ::prost::alloc::string::String,
    /// Optional. Settings to manage lake and Dataproc Metastore service instance
    /// association.
    #[prost(message, optional, tag = "102")]
    pub metastore: ::core::option::Option<lake::Metastore>,
    /// Output only. Aggregated status of the underlying assets of the lake.
    #[prost(message, optional, tag = "103")]
    pub asset_status: ::core::option::Option<AssetStatus>,
    /// Output only. Metastore status of the lake.
    #[prost(message, optional, tag = "104")]
    pub metastore_status: ::core::option::Option<lake::MetastoreStatus>,
}
/// Nested message and enum types in `Lake`.
pub mod lake {
    /// Settings to manage association of Dataproc Metastore with a lake.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Metastore {
        /// Optional. A relative reference to the Dataproc Metastore
        /// (<https://cloud.google.com/dataproc-metastore/docs>) service associated
        /// with the lake:
        /// `projects/{project_id}/locations/{location_id}/services/{service_id}`
        #[prost(string, tag = "1")]
        pub service: ::prost::alloc::string::String,
    }
    /// Status of Lake and Dataproc Metastore service instance association.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MetastoreStatus {
        /// Current state of association.
        #[prost(enumeration = "metastore_status::State", tag = "1")]
        pub state: i32,
        /// Additional information about the current status.
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
        /// Last update time of the metastore status of the lake.
        #[prost(message, optional, tag = "3")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
        /// The URI of the endpoint used to access the Metastore service.
        #[prost(string, tag = "4")]
        pub endpoint: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `MetastoreStatus`.
    pub mod metastore_status {
        /// Current state of association.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            /// Unspecified.
            Unspecified = 0,
            /// A Metastore service instance is not associated with the lake.
            None = 1,
            /// A Metastore service instance is attached to the lake.
            Ready = 2,
            /// Attach/detach is in progress.
            Updating = 3,
            /// Attach/detach could not be done due to errors.
            Error = 4,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::None => "NONE",
                    Self::Ready => "READY",
                    Self::Updating => "UPDATING",
                    Self::Error => "ERROR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "NONE" => Some(Self::None),
                    "READY" => Some(Self::Ready),
                    "UPDATING" => Some(Self::Updating),
                    "ERROR" => Some(Self::Error),
                    _ => None,
                }
            }
        }
    }
}
/// Aggregated status of the underlying assets of a lake or zone.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetStatus {
    /// Last update time of the status.
    #[prost(message, optional, tag = "1")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Number of active assets.
    #[prost(int32, tag = "2")]
    pub active_assets: i32,
    /// Number of assets that are in process of updating the security policy on
    /// attached resources.
    #[prost(int32, tag = "3")]
    pub security_policy_applying_assets: i32,
}
/// A zone represents a logical group of related assets within a lake. A zone can
/// be used to map to organizational structure or represent stages of data
/// readiness from raw to curated. It provides managing behavior that is shared
/// or inherited by all contained assets.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Zone {
    /// Output only. The relative resource name of the zone, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the zone. This ID will
    /// be different if the zone is deleted and re-created with the same name.
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the zone was created.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the zone was last updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. User defined labels for the zone.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Description of the zone.
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Current state of the zone.
    #[prost(enumeration = "State", tag = "8")]
    pub state: i32,
    /// Required. Immutable. The type of the zone.
    #[prost(enumeration = "zone::Type", tag = "9")]
    pub r#type: i32,
    /// Optional. Specification of the discovery feature applied to data in this
    /// zone.
    #[prost(message, optional, tag = "103")]
    pub discovery_spec: ::core::option::Option<zone::DiscoverySpec>,
    /// Required. Specification of the resources that are referenced by the assets
    /// within this zone.
    #[prost(message, optional, tag = "104")]
    pub resource_spec: ::core::option::Option<zone::ResourceSpec>,
    /// Output only. Aggregated status of the underlying assets of the zone.
    #[prost(message, optional, tag = "105")]
    pub asset_status: ::core::option::Option<AssetStatus>,
}
/// Nested message and enum types in `Zone`.
pub mod zone {
    /// Settings for resources attached as assets within a zone.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ResourceSpec {
        /// Required. Immutable. The location type of the resources that are allowed
        /// to be attached to the assets within this zone.
        #[prost(enumeration = "resource_spec::LocationType", tag = "1")]
        pub location_type: i32,
    }
    /// Nested message and enum types in `ResourceSpec`.
    pub mod resource_spec {
        /// Location type of the resources attached to a zone.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum LocationType {
            /// Unspecified location type.
            Unspecified = 0,
            /// Resources that are associated with a single region.
            SingleRegion = 1,
            /// Resources that are associated with a multi-region location.
            MultiRegion = 2,
        }
        impl LocationType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "LOCATION_TYPE_UNSPECIFIED",
                    Self::SingleRegion => "SINGLE_REGION",
                    Self::MultiRegion => "MULTI_REGION",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "LOCATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SINGLE_REGION" => Some(Self::SingleRegion),
                    "MULTI_REGION" => Some(Self::MultiRegion),
                    _ => None,
                }
            }
        }
    }
    /// Settings to manage the metadata discovery and publishing in a zone.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DiscoverySpec {
        /// Required. Whether discovery is enabled.
        #[prost(bool, tag = "1")]
        pub enabled: bool,
        /// Optional. The list of patterns to apply for selecting data to include
        /// during discovery if only a subset of the data should considered. For
        /// Cloud Storage bucket assets, these are interpreted as glob patterns used
        /// to match object names. For BigQuery dataset assets, these are interpreted
        /// as patterns to match table names.
        #[prost(string, repeated, tag = "2")]
        pub include_patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. The list of patterns to apply for selecting data to exclude
        /// during discovery.  For Cloud Storage bucket assets, these are interpreted
        /// as glob patterns used to match object names. For BigQuery dataset assets,
        /// these are interpreted as patterns to match table names.
        #[prost(string, repeated, tag = "3")]
        pub exclude_patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. Configuration for CSV data.
        #[prost(message, optional, tag = "4")]
        pub csv_options: ::core::option::Option<discovery_spec::CsvOptions>,
        /// Optional. Configuration for Json data.
        #[prost(message, optional, tag = "5")]
        pub json_options: ::core::option::Option<discovery_spec::JsonOptions>,
        /// Determines when discovery is triggered.
        #[prost(oneof = "discovery_spec::Trigger", tags = "10")]
        pub trigger: ::core::option::Option<discovery_spec::Trigger>,
    }
    /// Nested message and enum types in `DiscoverySpec`.
    pub mod discovery_spec {
        /// Describe CSV and similar semi-structured data formats.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CsvOptions {
            /// Optional. The number of rows to interpret as header rows that should be
            /// skipped when reading data rows.
            #[prost(int32, tag = "1")]
            pub header_rows: i32,
            /// Optional. The delimiter being used to separate values. This defaults to
            /// ','.
            #[prost(string, tag = "2")]
            pub delimiter: ::prost::alloc::string::String,
            /// Optional. The character encoding of the data. The default is UTF-8.
            #[prost(string, tag = "3")]
            pub encoding: ::prost::alloc::string::String,
            /// Optional. Whether to disable the inference of data type for CSV data.
            /// If true, all columns will be registered as strings.
            #[prost(bool, tag = "4")]
            pub disable_type_inference: bool,
        }
        /// Describe JSON data format.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct JsonOptions {
            /// Optional. The character encoding of the data. The default is UTF-8.
            #[prost(string, tag = "1")]
            pub encoding: ::prost::alloc::string::String,
            /// Optional. Whether to disable the inference of data type for Json data.
            /// If true, all columns will be registered as their primitive types
            /// (strings, number or boolean).
            #[prost(bool, tag = "2")]
            pub disable_type_inference: bool,
        }
        /// Determines when discovery is triggered.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Trigger {
            /// Optional. Cron schedule (<https://en.wikipedia.org/wiki/Cron>) for
            /// running discovery periodically. Successive discovery runs must be
            /// scheduled at least 60 minutes apart. The default value is to run
            /// discovery every 60 minutes. To explicitly set a timezone to the cron
            /// tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or
            /// TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string
            /// from IANA time zone database. For example, `CRON_TZ=America/New_York 1
            /// * * * *`, or `TZ=America/New_York 1 * * * *`.
            #[prost(string, tag = "10")]
            Schedule(::prost::alloc::string::String),
        }
    }
    /// Type of zone.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Zone type not specified.
        Unspecified = 0,
        /// A zone that contains data that needs further processing before it is
        /// considered generally ready for consumption and analytics workloads.
        Raw = 1,
        /// A zone that contains data that is considered to be ready for broader
        /// consumption and analytics workloads. Curated structured data stored in
        /// Cloud Storage must conform to certain file formats (parquet, avro and
        /// orc) and organized in a hive-compatible directory layout.
        Curated = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Raw => "RAW",
                Self::Curated => "CURATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "RAW" => Some(Self::Raw),
                "CURATED" => Some(Self::Curated),
                _ => None,
            }
        }
    }
}
/// Action represents an issue requiring administrator action for resolution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Action {
    /// The category of issue associated with the action.
    #[prost(enumeration = "action::Category", tag = "1")]
    pub category: i32,
    /// Detailed description of the issue requiring action.
    #[prost(string, tag = "2")]
    pub issue: ::prost::alloc::string::String,
    /// The time that the issue was detected.
    #[prost(message, optional, tag = "4")]
    pub detect_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The relative resource name of the action, of the form:
    /// `projects/{project}/locations/{location}/lakes/{lake}/actions/{action}`
    /// `projects/{project}/locations/{location}/lakes/{lake}/zones/{zone}/actions/{action}`
    /// `projects/{project}/locations/{location}/lakes/{lake}/zones/{zone}/assets/{asset}/actions/{action}`.
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The relative resource name of the lake, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[prost(string, tag = "6")]
    pub lake: ::prost::alloc::string::String,
    /// Output only. The relative resource name of the zone, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[prost(string, tag = "7")]
    pub zone: ::prost::alloc::string::String,
    /// Output only. The relative resource name of the asset, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}`.
    #[prost(string, tag = "8")]
    pub asset: ::prost::alloc::string::String,
    /// The list of data locations associated with this action. Cloud Storage
    /// locations are represented as URI paths(E.g.
    /// `gs://bucket/table1/year=2020/month=Jan/`). BigQuery locations refer to
    /// resource names(E.g.
    /// `bigquery.googleapis.com/projects/project-id/datasets/dataset-id`).
    #[prost(string, repeated, tag = "9")]
    pub data_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Additional details about the action based on the action category.
    #[prost(oneof = "action::Details", tags = "10, 11, 12, 13, 14, 15, 21, 22")]
    pub details: ::core::option::Option<action::Details>,
}
/// Nested message and enum types in `Action`.
pub mod action {
    /// Action details for resource references in assets that cannot be located.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MissingResource {}
    /// Action details for unauthorized resource issues raised to indicate that the
    /// service account associated with the lake instance is not authorized to
    /// access or manage the resource associated with an asset.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UnauthorizedResource {}
    /// Failed to apply security policy to the managed resource(s) under a
    /// lake, zone or an asset. For a lake or zone resource, one or more underlying
    /// assets has a failure applying security policy to the associated managed
    /// resource.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FailedSecurityPolicyApply {
        /// Resource name of one of the assets with failing security policy
        /// application. Populated for a lake or zone resource only.
        #[prost(string, tag = "1")]
        pub asset: ::prost::alloc::string::String,
    }
    /// Action details for invalid or unsupported data files detected by discovery.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InvalidDataFormat {
        /// The list of data locations sampled and used for format/schema
        /// inference.
        #[prost(string, repeated, tag = "1")]
        pub sampled_data_locations: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        /// The expected data format of the entity.
        #[prost(string, tag = "2")]
        pub expected_format: ::prost::alloc::string::String,
        /// The new unexpected data format within the entity.
        #[prost(string, tag = "3")]
        pub new_format: ::prost::alloc::string::String,
    }
    /// Action details for incompatible schemas detected by discovery.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IncompatibleDataSchema {
        /// The name of the table containing invalid data.
        #[prost(string, tag = "1")]
        pub table: ::prost::alloc::string::String,
        /// The existing and expected schema of the table. The schema is provided as
        /// a JSON formatted structure listing columns and data types.
        #[prost(string, tag = "2")]
        pub existing_schema: ::prost::alloc::string::String,
        /// The new and incompatible schema within the table. The schema is provided
        /// as a JSON formatted structured listing columns and data types.
        #[prost(string, tag = "3")]
        pub new_schema: ::prost::alloc::string::String,
        /// The list of data locations sampled and used for format/schema
        /// inference.
        #[prost(string, repeated, tag = "4")]
        pub sampled_data_locations: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        /// Whether the action relates to a schema that is incompatible or modified.
        #[prost(enumeration = "incompatible_data_schema::SchemaChange", tag = "5")]
        pub schema_change: i32,
    }
    /// Nested message and enum types in `IncompatibleDataSchema`.
    pub mod incompatible_data_schema {
        /// Whether the action relates to a schema that is incompatible or modified.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SchemaChange {
            /// Schema change unspecified.
            Unspecified = 0,
            /// Newly discovered schema is incompatible with existing schema.
            Incompatible = 1,
            /// Newly discovered schema has changed from existing schema for data in a
            /// curated zone.
            Modified = 2,
        }
        impl SchemaChange {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SCHEMA_CHANGE_UNSPECIFIED",
                    Self::Incompatible => "INCOMPATIBLE",
                    Self::Modified => "MODIFIED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SCHEMA_CHANGE_UNSPECIFIED" => Some(Self::Unspecified),
                    "INCOMPATIBLE" => Some(Self::Incompatible),
                    "MODIFIED" => Some(Self::Modified),
                    _ => None,
                }
            }
        }
    }
    /// Action details for invalid or unsupported partitions detected by discovery.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct InvalidDataPartition {
        /// The issue type of InvalidDataPartition.
        #[prost(enumeration = "invalid_data_partition::PartitionStructure", tag = "1")]
        pub expected_structure: i32,
    }
    /// Nested message and enum types in `InvalidDataPartition`.
    pub mod invalid_data_partition {
        /// The expected partition structure.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PartitionStructure {
            /// PartitionStructure unspecified.
            Unspecified = 0,
            /// Consistent hive-style partition definition (both raw and curated zone).
            ConsistentKeys = 1,
            /// Hive style partition definition (curated zone only).
            HiveStyleKeys = 2,
        }
        impl PartitionStructure {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "PARTITION_STRUCTURE_UNSPECIFIED",
                    Self::ConsistentKeys => "CONSISTENT_KEYS",
                    Self::HiveStyleKeys => "HIVE_STYLE_KEYS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PARTITION_STRUCTURE_UNSPECIFIED" => Some(Self::Unspecified),
                    "CONSISTENT_KEYS" => Some(Self::ConsistentKeys),
                    "HIVE_STYLE_KEYS" => Some(Self::HiveStyleKeys),
                    _ => None,
                }
            }
        }
    }
    /// Action details for absence of data detected by discovery.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MissingData {}
    /// Action details for invalid data arrangement.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct InvalidDataOrganization {}
    /// The category of issues.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Category {
        /// Unspecified category.
        Unspecified = 0,
        /// Resource management related issues.
        ResourceManagement = 1,
        /// Security policy related issues.
        SecurityPolicy = 2,
        /// Data and discovery related issues.
        DataDiscovery = 3,
    }
    impl Category {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CATEGORY_UNSPECIFIED",
                Self::ResourceManagement => "RESOURCE_MANAGEMENT",
                Self::SecurityPolicy => "SECURITY_POLICY",
                Self::DataDiscovery => "DATA_DISCOVERY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
                "RESOURCE_MANAGEMENT" => Some(Self::ResourceManagement),
                "SECURITY_POLICY" => Some(Self::SecurityPolicy),
                "DATA_DISCOVERY" => Some(Self::DataDiscovery),
                _ => None,
            }
        }
    }
    /// Additional details about the action based on the action category.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Details {
        /// Details for issues related to invalid or unsupported data formats.
        #[prost(message, tag = "10")]
        InvalidDataFormat(InvalidDataFormat),
        /// Details for issues related to incompatible schemas detected within data.
        #[prost(message, tag = "11")]
        IncompatibleDataSchema(IncompatibleDataSchema),
        /// Details for issues related to invalid or unsupported data partition
        /// structure.
        #[prost(message, tag = "12")]
        InvalidDataPartition(InvalidDataPartition),
        /// Details for issues related to absence of data within managed resources.
        #[prost(message, tag = "13")]
        MissingData(MissingData),
        /// Details for issues related to absence of a managed resource.
        #[prost(message, tag = "14")]
        MissingResource(MissingResource),
        /// Details for issues related to lack of permissions to access data
        /// resources.
        #[prost(message, tag = "15")]
        UnauthorizedResource(UnauthorizedResource),
        /// Details for issues related to applying security policy.
        #[prost(message, tag = "21")]
        FailedSecurityPolicyApply(FailedSecurityPolicyApply),
        /// Details for issues related to invalid data arrangement.
        #[prost(message, tag = "22")]
        InvalidDataOrganization(InvalidDataOrganization),
    }
}
/// An asset represents a cloud resource that is being managed within a lake as a
/// member of a zone.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Asset {
    /// Output only. The relative resource name of the asset, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the asset. This ID
    /// will be different if the asset is deleted and re-created with the same
    /// name.
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the asset was created.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the asset was last updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. User defined labels for the asset.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Description of the asset.
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Current state of the asset.
    #[prost(enumeration = "State", tag = "8")]
    pub state: i32,
    /// Required. Specification of the resource that is referenced by this asset.
    #[prost(message, optional, tag = "100")]
    pub resource_spec: ::core::option::Option<asset::ResourceSpec>,
    /// Output only. Status of the resource referenced by this asset.
    #[prost(message, optional, tag = "101")]
    pub resource_status: ::core::option::Option<asset::ResourceStatus>,
    /// Output only. Status of the security policy applied to resource referenced
    /// by this asset.
    #[prost(message, optional, tag = "103")]
    pub security_status: ::core::option::Option<asset::SecurityStatus>,
    /// Optional. Specification of the discovery feature applied to data referenced
    /// by this asset. When this spec is left unset, the asset will use the spec
    /// set on the parent zone.
    #[prost(message, optional, tag = "106")]
    pub discovery_spec: ::core::option::Option<asset::DiscoverySpec>,
    /// Output only. Status of the discovery feature applied to data referenced by
    /// this asset.
    #[prost(message, optional, tag = "107")]
    pub discovery_status: ::core::option::Option<asset::DiscoveryStatus>,
}
/// Nested message and enum types in `Asset`.
pub mod asset {
    /// Security policy status of the asset. Data security policy, i.e., readers,
    /// writers & owners, should be specified in the lake/zone/asset IAM policy.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SecurityStatus {
        /// The current state of the security policy applied to the attached
        /// resource.
        #[prost(enumeration = "security_status::State", tag = "1")]
        pub state: i32,
        /// Additional information about the current state.
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
        /// Last update time of the status.
        #[prost(message, optional, tag = "3")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Nested message and enum types in `SecurityStatus`.
    pub mod security_status {
        /// The state of the security policy.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            /// State unspecified.
            Unspecified = 0,
            /// Security policy has been successfully applied to the attached resource.
            Ready = 1,
            /// Security policy is in the process of being applied to the attached
            /// resource.
            Applying = 2,
            /// Security policy could not be applied to the attached resource due to
            /// errors.
            Error = 3,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Ready => "READY",
                    Self::Applying => "APPLYING",
                    Self::Error => "ERROR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "READY" => Some(Self::Ready),
                    "APPLYING" => Some(Self::Applying),
                    "ERROR" => Some(Self::Error),
                    _ => None,
                }
            }
        }
    }
    /// Settings to manage the metadata discovery and publishing for an asset.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DiscoverySpec {
        /// Optional. Whether discovery is enabled.
        #[prost(bool, tag = "1")]
        pub enabled: bool,
        /// Optional. The list of patterns to apply for selecting data to include
        /// during discovery if only a subset of the data should considered.  For
        /// Cloud Storage bucket assets, these are interpreted as glob patterns used
        /// to match object names. For BigQuery dataset assets, these are interpreted
        /// as patterns to match table names.
        #[prost(string, repeated, tag = "2")]
        pub include_patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. The list of patterns to apply for selecting data to exclude
        /// during discovery.  For Cloud Storage bucket assets, these are interpreted
        /// as glob patterns used to match object names. For BigQuery dataset assets,
        /// these are interpreted as patterns to match table names.
        #[prost(string, repeated, tag = "3")]
        pub exclude_patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. Configuration for CSV data.
        #[prost(message, optional, tag = "4")]
        pub csv_options: ::core::option::Option<discovery_spec::CsvOptions>,
        /// Optional. Configuration for Json data.
        #[prost(message, optional, tag = "5")]
        pub json_options: ::core::option::Option<discovery_spec::JsonOptions>,
        /// Determines when discovery is triggered.
        #[prost(oneof = "discovery_spec::Trigger", tags = "10")]
        pub trigger: ::core::option::Option<discovery_spec::Trigger>,
    }
    /// Nested message and enum types in `DiscoverySpec`.
    pub mod discovery_spec {
        /// Describe CSV and similar semi-structured data formats.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CsvOptions {
            /// Optional. The number of rows to interpret as header rows that should be
            /// skipped when reading data rows.
            #[prost(int32, tag = "1")]
            pub header_rows: i32,
            /// Optional. The delimiter being used to separate values. This defaults to
            /// ','.
            #[prost(string, tag = "2")]
            pub delimiter: ::prost::alloc::string::String,
            /// Optional. The character encoding of the data. The default is UTF-8.
            #[prost(string, tag = "3")]
            pub encoding: ::prost::alloc::string::String,
            /// Optional. Whether to disable the inference of data type for CSV data.
            /// If true, all columns will be registered as strings.
            #[prost(bool, tag = "4")]
            pub disable_type_inference: bool,
        }
        /// Describe JSON data format.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct JsonOptions {
            /// Optional. The character encoding of the data. The default is UTF-8.
            #[prost(string, tag = "1")]
            pub encoding: ::prost::alloc::string::String,
            /// Optional. Whether to disable the inference of data type for Json data.
            /// If true, all columns will be registered as their primitive types
            /// (strings, number or boolean).
            #[prost(bool, tag = "2")]
            pub disable_type_inference: bool,
        }
        /// Determines when discovery is triggered.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Trigger {
            /// Optional. Cron schedule (<https://en.wikipedia.org/wiki/Cron>) for
            /// running discovery periodically. Successive discovery runs must be
            /// scheduled at least 60 minutes apart. The default value is to run
            /// discovery every 60 minutes. To explicitly set a timezone to the cron
            /// tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or
            /// TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid string
            /// from IANA time zone database. For example, `CRON_TZ=America/New_York 1
            /// * * * *`, or `TZ=America/New_York 1 * * * *`.
            #[prost(string, tag = "10")]
            Schedule(::prost::alloc::string::String),
        }
    }
    /// Identifies the cloud resource that is referenced by this asset.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResourceSpec {
        /// Immutable. Relative name of the cloud resource that contains the data
        /// that is being managed within a lake. For example:
        ///    `projects/{project_number}/buckets/{bucket_id}`
        ///    `projects/{project_number}/datasets/{dataset_id}`
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Required. Immutable. Type of resource.
        #[prost(enumeration = "resource_spec::Type", tag = "2")]
        pub r#type: i32,
        /// Optional. Determines how read permissions are handled for each asset and
        /// their associated tables. Only available to storage buckets assets.
        #[prost(enumeration = "resource_spec::AccessMode", tag = "5")]
        pub read_access_mode: i32,
    }
    /// Nested message and enum types in `ResourceSpec`.
    pub mod resource_spec {
        /// Type of resource.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            /// Type not specified.
            Unspecified = 0,
            /// Cloud Storage bucket.
            StorageBucket = 1,
            /// BigQuery dataset.
            BigqueryDataset = 2,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TYPE_UNSPECIFIED",
                    Self::StorageBucket => "STORAGE_BUCKET",
                    Self::BigqueryDataset => "BIGQUERY_DATASET",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "STORAGE_BUCKET" => Some(Self::StorageBucket),
                    "BIGQUERY_DATASET" => Some(Self::BigqueryDataset),
                    _ => None,
                }
            }
        }
        /// Access Mode determines how data stored within the resource is read. This
        /// is only applicable to storage bucket assets.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum AccessMode {
            /// Access mode unspecified.
            Unspecified = 0,
            /// Default. Data is accessed directly using storage APIs.
            Direct = 1,
            /// Data is accessed through a managed interface using BigQuery APIs.
            Managed = 2,
        }
        impl AccessMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "ACCESS_MODE_UNSPECIFIED",
                    Self::Direct => "DIRECT",
                    Self::Managed => "MANAGED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ACCESS_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                    "DIRECT" => Some(Self::Direct),
                    "MANAGED" => Some(Self::Managed),
                    _ => None,
                }
            }
        }
    }
    /// Status of the resource referenced by an asset.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResourceStatus {
        /// The current state of the managed resource.
        #[prost(enumeration = "resource_status::State", tag = "1")]
        pub state: i32,
        /// Additional information about the current state.
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
        /// Last update time of the status.
        #[prost(message, optional, tag = "3")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
        /// Output only. Service account associated with the BigQuery Connection.
        #[prost(string, tag = "4")]
        pub managed_access_identity: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `ResourceStatus`.
    pub mod resource_status {
        /// The state of a resource.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            /// State unspecified.
            Unspecified = 0,
            /// Resource does not have any errors.
            Ready = 1,
            /// Resource has errors.
            Error = 2,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Ready => "READY",
                    Self::Error => "ERROR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "READY" => Some(Self::Ready),
                    "ERROR" => Some(Self::Error),
                    _ => None,
                }
            }
        }
    }
    /// Status of discovery for an asset.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DiscoveryStatus {
        /// The current status of the discovery feature.
        #[prost(enumeration = "discovery_status::State", tag = "1")]
        pub state: i32,
        /// Additional information about the current state.
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
        /// Last update time of the status.
        #[prost(message, optional, tag = "3")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
        /// The start time of the last discovery run.
        #[prost(message, optional, tag = "4")]
        pub last_run_time: ::core::option::Option<::prost_types::Timestamp>,
        /// Data Stats of the asset reported by discovery.
        #[prost(message, optional, tag = "6")]
        pub stats: ::core::option::Option<discovery_status::Stats>,
        /// The duration of the last discovery run.
        #[prost(message, optional, tag = "7")]
        pub last_run_duration: ::core::option::Option<::prost_types::Duration>,
    }
    /// Nested message and enum types in `DiscoveryStatus`.
    pub mod discovery_status {
        /// The aggregated data statistics for the asset reported by discovery.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Stats {
            /// The count of data items within the referenced resource.
            #[prost(int64, tag = "1")]
            pub data_items: i64,
            /// The number of stored data bytes within the referenced resource.
            #[prost(int64, tag = "2")]
            pub data_size: i64,
            /// The count of table entities within the referenced resource.
            #[prost(int64, tag = "3")]
            pub tables: i64,
            /// The count of fileset entities within the referenced resource.
            #[prost(int64, tag = "4")]
            pub filesets: i64,
        }
        /// Current state of discovery.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            /// State is unspecified.
            Unspecified = 0,
            /// Discovery for the asset is scheduled.
            Scheduled = 1,
            /// Discovery for the asset is running.
            InProgress = 2,
            /// Discovery for the asset is currently paused (e.g. due to a lack
            /// of available resources). It will be automatically resumed.
            Paused = 3,
            /// Discovery for the asset is disabled.
            Disabled = 5,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Scheduled => "SCHEDULED",
                    Self::InProgress => "IN_PROGRESS",
                    Self::Paused => "PAUSED",
                    Self::Disabled => "DISABLED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SCHEDULED" => Some(Self::Scheduled),
                    "IN_PROGRESS" => Some(Self::InProgress),
                    "PAUSED" => Some(Self::Paused),
                    "DISABLED" => Some(Self::Disabled),
                    _ => None,
                }
            }
        }
    }
}
/// State of a resource.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
    /// State is not specified.
    Unspecified = 0,
    /// Resource is active, i.e., ready to use.
    Active = 1,
    /// Resource is under creation.
    Creating = 2,
    /// Resource is under deletion.
    Deleting = 3,
    /// Resource is active but has unresolved actions.
    ActionRequired = 4,
}
impl State {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STATE_UNSPECIFIED",
            Self::Active => "ACTIVE",
            Self::Creating => "CREATING",
            Self::Deleting => "DELETING",
            Self::ActionRequired => "ACTION_REQUIRED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "ACTIVE" => Some(Self::Active),
            "CREATING" => Some(Self::Creating),
            "DELETING" => Some(Self::Deleting),
            "ACTION_REQUIRED" => Some(Self::ActionRequired),
            _ => None,
        }
    }
}
/// Environment represents a user-visible compute infrastructure for analytics
/// within a lake.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Environment {
    /// Output only. The relative resource name of the environment, of the form:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}/environment/{environment_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the environment. This
    /// ID will be different if the environment is deleted and re-created with the
    /// same name.
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. Environment creation time.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the environment was last updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. User defined labels for the environment.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Description of the environment.
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Current state of the environment.
    #[prost(enumeration = "State", tag = "8")]
    pub state: i32,
    /// Required. Infrastructure specification for the Environment.
    #[prost(message, optional, tag = "100")]
    pub infrastructure_spec: ::core::option::Option<environment::InfrastructureSpec>,
    /// Optional. Configuration for sessions created for this environment.
    #[prost(message, optional, tag = "101")]
    pub session_spec: ::core::option::Option<environment::SessionSpec>,
    /// Output only. Status of sessions created for this environment.
    #[prost(message, optional, tag = "102")]
    pub session_status: ::core::option::Option<environment::SessionStatus>,
    /// Output only. URI Endpoints to access sessions associated with the
    /// Environment.
    #[prost(message, optional, tag = "200")]
    pub endpoints: ::core::option::Option<environment::Endpoints>,
}
/// Nested message and enum types in `Environment`.
pub mod environment {
    /// Configuration for the underlying infrastructure used to run workloads.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InfrastructureSpec {
        /// Hardware config
        #[prost(oneof = "infrastructure_spec::Resources", tags = "50")]
        pub resources: ::core::option::Option<infrastructure_spec::Resources>,
        /// Software config
        #[prost(oneof = "infrastructure_spec::Runtime", tags = "100")]
        pub runtime: ::core::option::Option<infrastructure_spec::Runtime>,
    }
    /// Nested message and enum types in `InfrastructureSpec`.
    pub mod infrastructure_spec {
        /// Compute resources associated with the analyze interactive workloads.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ComputeResources {
            /// Optional. Size in GB of the disk. Default is 100 GB.
            #[prost(int32, tag = "1")]
            pub disk_size_gb: i32,
            /// Optional. Total number of nodes in the sessions created for this
            /// environment.
            #[prost(int32, tag = "2")]
            pub node_count: i32,
            /// Optional. Max configurable nodes.
            /// If max_node_count > node_count, then auto-scaling is enabled.
            #[prost(int32, tag = "3")]
            pub max_node_count: i32,
        }
        /// Software Runtime Configuration to run Analyze.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct OsImageRuntime {
            /// Required. Dataplex Image version.
            #[prost(string, tag = "1")]
            pub image_version: ::prost::alloc::string::String,
            /// Optional. List of Java jars to be included in the runtime environment.
            /// Valid input includes Cloud Storage URIs to Jar binaries.
            /// For example, gs://bucket-name/my/path/to/file.jar
            #[prost(string, repeated, tag = "2")]
            pub java_libraries: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// Optional. A list of python packages to be installed.
            /// Valid formats include Cloud Storage URI to a PIP installable library.
            /// For example, gs://bucket-name/my/path/to/lib.tar.gz
            #[prost(string, repeated, tag = "3")]
            pub python_packages: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            /// Optional. Spark properties to provide configuration for use in sessions
            /// created for this environment. The properties to set on daemon config
            /// files. Property keys are specified in `prefix:property` format. The
            /// prefix must be "spark".
            #[prost(map = "string, string", tag = "4")]
            pub properties: ::std::collections::HashMap<
                ::prost::alloc::string::String,
                ::prost::alloc::string::String,
            >,
        }
        /// Hardware config
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Resources {
            /// Optional. Compute resources needed for analyze interactive workloads.
            #[prost(message, tag = "50")]
            Compute(ComputeResources),
        }
        /// Software config
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Runtime {
            /// Required. Software Runtime Configuration for analyze interactive
            /// workloads.
            #[prost(message, tag = "100")]
            OsImage(OsImageRuntime),
        }
    }
    /// Configuration for sessions created for this environment.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SessionSpec {
        /// Optional. The idle time configuration of the session. The session will be
        /// auto-terminated at the end of this period.
        #[prost(message, optional, tag = "1")]
        pub max_idle_duration: ::core::option::Option<::prost_types::Duration>,
        /// Optional. If True, this causes sessions to be pre-created and available
        /// for faster startup to enable interactive exploration use-cases. This
        /// defaults to False to avoid additional billed charges. These can only be
        /// set to True for the environment with name set to "default", and with
        /// default configuration.
        #[prost(bool, tag = "2")]
        pub enable_fast_startup: bool,
    }
    /// Status of sessions created for this environment.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SessionStatus {
        /// Output only. Queries over sessions to mark whether the environment is
        /// currently active or not
        #[prost(bool, tag = "1")]
        pub active: bool,
    }
    /// URI Endpoints to access sessions associated with the Environment.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Endpoints {
        /// Output only. URI to serve notebook APIs
        #[prost(string, tag = "1")]
        pub notebooks: ::prost::alloc::string::String,
        /// Output only. URI to serve SQL APIs
        #[prost(string, tag = "2")]
        pub sql: ::prost::alloc::string::String,
    }
}
/// Content represents a user-visible notebook or a sql script
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Content {
    /// Output only. The relative resource name of the content, of the form:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}/content/{content_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the content. This ID
    /// will be different if the content is deleted and re-created with the same
    /// name.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Required. The path for the Content file, represented as directory
    /// structure. Unique within a lake. Limited to alphanumerics, hyphens,
    /// underscores, dots and slashes.
    #[prost(string, tag = "3")]
    pub path: ::prost::alloc::string::String,
    /// Output only. Content creation time.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the content was last updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. User defined labels for the content.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Description of the content.
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    /// Only returned in `GetContent` requests and not in `ListContent` request.
    #[prost(oneof = "content::Data", tags = "9")]
    pub data: ::core::option::Option<content::Data>,
    /// Types of content
    #[prost(oneof = "content::Content", tags = "100, 101")]
    pub content: ::core::option::Option<content::Content>,
}
/// Nested message and enum types in `Content`.
pub mod content {
    /// Configuration for the Sql Script content.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SqlScript {
        /// Required. Query Engine to be used for the Sql Query.
        #[prost(enumeration = "sql_script::QueryEngine", tag = "1")]
        pub engine: i32,
    }
    /// Nested message and enum types in `SqlScript`.
    pub mod sql_script {
        /// Query Engine Type of the SQL Script.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum QueryEngine {
            /// Value was unspecified.
            Unspecified = 0,
            /// Spark SQL Query.
            Spark = 2,
        }
        impl QueryEngine {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "QUERY_ENGINE_UNSPECIFIED",
                    Self::Spark => "SPARK",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "QUERY_ENGINE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SPARK" => Some(Self::Spark),
                    _ => None,
                }
            }
        }
    }
    /// Configuration for Notebook content.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Notebook {
        /// Required. Kernel Type of the notebook.
        #[prost(enumeration = "notebook::KernelType", tag = "1")]
        pub kernel_type: i32,
    }
    /// Nested message and enum types in `Notebook`.
    pub mod notebook {
        /// Kernel Type of the Jupyter notebook.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum KernelType {
            /// Kernel Type unspecified.
            Unspecified = 0,
            /// Python 3 Kernel.
            Python3 = 1,
        }
        impl KernelType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "KERNEL_TYPE_UNSPECIFIED",
                    Self::Python3 => "PYTHON3",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "KERNEL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "PYTHON3" => Some(Self::Python3),
                    _ => None,
                }
            }
        }
    }
    /// Only returned in `GetContent` requests and not in `ListContent` request.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        /// Required. Content data in string format.
        #[prost(string, tag = "9")]
        DataText(::prost::alloc::string::String),
    }
    /// Types of content
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Content {
        /// Sql Script related configurations.
        #[prost(message, tag = "100")]
        SqlScript(SqlScript),
        /// Notebook related configurations.
        #[prost(message, tag = "101")]
        Notebook(Notebook),
    }
}
/// Represents an active analyze session running for a user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Session {
    /// Output only. The relative resource name of the content, of the form:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}/environment/{environment_id}/sessions/{session_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Email of user running the session.
    #[prost(string, tag = "2")]
    pub user_id: ::prost::alloc::string::String,
    /// Output only. Session start time.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. State of Session
    #[prost(enumeration = "State", tag = "4")]
    pub state: i32,
}
/// A task represents a user-visible job.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Task {
    /// Output only. The relative resource name of the task, of the form:
    /// projects/{project_number}/locations/{location_id}/lakes/{lake_id}/
    /// tasks/{task_id}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the task. This ID will
    /// be different if the task is deleted and re-created with the same name.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the task was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the task was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Description of the task.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Current state of the task.
    #[prost(enumeration = "State", tag = "7")]
    pub state: i32,
    /// Optional. User-defined labels for the task.
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Spec related to how often and when a task should be triggered.
    #[prost(message, optional, tag = "100")]
    pub trigger_spec: ::core::option::Option<task::TriggerSpec>,
    /// Required. Spec related to how a task is executed.
    #[prost(message, optional, tag = "101")]
    pub execution_spec: ::core::option::Option<task::ExecutionSpec>,
    /// Output only. Status of the latest task executions.
    #[prost(message, optional, tag = "201")]
    pub execution_status: ::core::option::Option<task::ExecutionStatus>,
    /// Task template specific user-specified config.
    #[prost(oneof = "task::Config", tags = "300, 302")]
    pub config: ::core::option::Option<task::Config>,
}
/// Nested message and enum types in `Task`.
pub mod task {
    /// Configuration for the underlying infrastructure used to run workloads.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InfrastructureSpec {
        /// Hardware config.
        #[prost(oneof = "infrastructure_spec::Resources", tags = "52")]
        pub resources: ::core::option::Option<infrastructure_spec::Resources>,
        /// Software config.
        #[prost(oneof = "infrastructure_spec::Runtime", tags = "101")]
        pub runtime: ::core::option::Option<infrastructure_spec::Runtime>,
        /// Networking config.
        #[prost(oneof = "infrastructure_spec::Network", tags = "150")]
        pub network: ::core::option::Option<infrastructure_spec::Network>,
    }
    /// Nested message and enum types in `InfrastructureSpec`.
    pub mod infrastructure_spec {
        /// Batch compute resources associated with the task.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct BatchComputeResources {
            /// Optional. Total number of job executors.
            /// Executor Count should be between 2 and 100. \[Default=2\]
            #[prost(int32, tag = "1")]
            pub executors_count: i32,
            /// Optional. Max configurable executors.
            /// If max_executors_count > executors_count, then auto-scaling is enabled.
            /// Max Executor Count should be between 2 and 1000. \[Default=1000\]
            #[prost(int32, tag = "2")]
            pub max_executors_count: i32,
        }
        /// Container Image Runtime Configuration used with Batch execution.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ContainerImageRuntime {
            /// Optional. Container image to use.
            #[prost(string, tag = "1")]
            pub image: ::prost::alloc::string::String,
            /// Optional. A list of Java JARS to add to the classpath.
            /// Valid input includes Cloud Storage URIs to Jar binaries.
            /// For example, gs://bucket-name/my/path/to/file.jar
            #[prost(string, repeated, tag = "2")]
            pub java_jars: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// Optional. A list of python packages to be installed.
            /// Valid formats include Cloud Storage URI to a PIP installable library.
            /// For example, gs://bucket-name/my/path/to/lib.tar.gz
            #[prost(string, repeated, tag = "3")]
            pub python_packages: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            /// Optional. Override to common configuration of open source components
            /// installed on the Dataproc cluster. The properties to set on daemon
            /// config files. Property keys are specified in `prefix:property` format,
            /// for example `core:hadoop.tmp.dir`. For more information, see [Cluster
            /// properties](<https://cloud.google.com/dataproc/docs/concepts/cluster-properties>).
            #[prost(map = "string, string", tag = "4")]
            pub properties: ::std::collections::HashMap<
                ::prost::alloc::string::String,
                ::prost::alloc::string::String,
            >,
        }
        /// Cloud VPC Network used to run the infrastructure.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct VpcNetwork {
            /// Optional. List of network tags to apply to the job.
            #[prost(string, repeated, tag = "3")]
            pub network_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// The Cloud VPC network identifier.
            #[prost(oneof = "vpc_network::NetworkName", tags = "1, 2")]
            pub network_name: ::core::option::Option<vpc_network::NetworkName>,
        }
        /// Nested message and enum types in `VpcNetwork`.
        pub mod vpc_network {
            /// The Cloud VPC network identifier.
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum NetworkName {
                /// Optional. The Cloud VPC network in which the job is run. By default,
                /// the Cloud VPC network named Default within the project is used.
                #[prost(string, tag = "1")]
                Network(::prost::alloc::string::String),
                /// Optional. The Cloud VPC sub-network in which the job is run.
                #[prost(string, tag = "2")]
                SubNetwork(::prost::alloc::string::String),
            }
        }
        /// Hardware config.
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Resources {
            /// Compute resources needed for a Task when using Dataproc Serverless.
            #[prost(message, tag = "52")]
            Batch(BatchComputeResources),
        }
        /// Software config.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Runtime {
            /// Container Image Runtime Configuration.
            #[prost(message, tag = "101")]
            ContainerImage(ContainerImageRuntime),
        }
        /// Networking config.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Network {
            /// Vpc network.
            #[prost(message, tag = "150")]
            VpcNetwork(VpcNetwork),
        }
    }
    /// Task scheduling and trigger settings.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TriggerSpec {
        /// Required. Immutable. Trigger type of the user-specified Task.
        #[prost(enumeration = "trigger_spec::Type", tag = "5")]
        pub r#type: i32,
        /// Optional. The first run of the task will be after this time.
        /// If not specified, the task will run shortly after being submitted if
        /// ON_DEMAND and based on the schedule if RECURRING.
        #[prost(message, optional, tag = "6")]
        pub start_time: ::core::option::Option<::prost_types::Timestamp>,
        /// Optional. Prevent the task from executing.
        /// This does not cancel already running tasks. It is intended to temporarily
        /// disable RECURRING tasks.
        #[prost(bool, tag = "4")]
        pub disabled: bool,
        /// Optional. Number of retry attempts before aborting.
        /// Set to zero to never attempt to retry a failed task.
        #[prost(int32, tag = "7")]
        pub max_retries: i32,
        /// Trigger only applies for RECURRING tasks.
        #[prost(oneof = "trigger_spec::Trigger", tags = "100")]
        pub trigger: ::core::option::Option<trigger_spec::Trigger>,
    }
    /// Nested message and enum types in `TriggerSpec`.
    pub mod trigger_spec {
        /// Determines how often and when the job will run.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Type {
            /// Unspecified trigger type.
            Unspecified = 0,
            /// The task runs one-time shortly after Task Creation.
            OnDemand = 1,
            /// The task is scheduled to run periodically.
            Recurring = 2,
        }
        impl Type {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TYPE_UNSPECIFIED",
                    Self::OnDemand => "ON_DEMAND",
                    Self::Recurring => "RECURRING",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ON_DEMAND" => Some(Self::OnDemand),
                    "RECURRING" => Some(Self::Recurring),
                    _ => None,
                }
            }
        }
        /// Trigger only applies for RECURRING tasks.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Trigger {
            /// Optional. Cron schedule (<https://en.wikipedia.org/wiki/Cron>) for
            /// running tasks periodically. To explicitly set a timezone to the cron
            /// tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or
            /// "TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid
            /// string from IANA time zone database. For example,
            /// `CRON_TZ=America/New_York 1 * * * *`, or `TZ=America/New_York 1 * * *
            /// *`. This field is required for RECURRING tasks.
            #[prost(string, tag = "100")]
            Schedule(::prost::alloc::string::String),
        }
    }
    /// Execution related settings, like retry and service_account.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecutionSpec {
        /// Optional. The arguments to pass to the task.
        /// The args can use placeholders of the format ${placeholder} as
        /// part of key/value string. These will be interpolated before passing the
        /// args to the driver. Currently supported placeholders:
        /// - ${task_id}
        /// - ${job_time}
        /// To pass positional args, set the key as TASK_ARGS. The value should be a
        /// comma-separated string of all the positional arguments. To use a
        /// delimiter other than comma, refer to
        /// <https://cloud.google.com/sdk/gcloud/reference/topic/escaping.> In case of
        /// other keys being present in the args, then TASK_ARGS will be passed as
        /// the last argument.
        #[prost(map = "string, string", tag = "4")]
        pub args: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        /// Required. Service account to use to execute a task.
        /// If not provided, the default Compute service account for the project is
        /// used.
        #[prost(string, tag = "5")]
        pub service_account: ::prost::alloc::string::String,
        /// Optional. The project in which jobs are run. By default, the project
        /// containing the Lake is used. If a project is provided, the
        /// [ExecutionSpec.service_account][google.cloud.dataplex.v1.Task.ExecutionSpec.service_account]
        /// must belong to this project.
        #[prost(string, tag = "7")]
        pub project: ::prost::alloc::string::String,
        /// Optional. The maximum duration after which the job execution is expired.
        #[prost(message, optional, tag = "8")]
        pub max_job_execution_lifetime: ::core::option::Option<::prost_types::Duration>,
        /// Optional. The Cloud KMS key to use for encryption, of the form:
        /// `projects/{project_number}/locations/{location_id}/keyRings/{key-ring-name}/cryptoKeys/{key-name}`.
        #[prost(string, tag = "9")]
        pub kms_key: ::prost::alloc::string::String,
    }
    /// User-specified config for running a Spark task.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SparkTaskConfig {
        /// Optional. Cloud Storage URIs of files to be placed in the working
        /// directory of each executor.
        #[prost(string, repeated, tag = "3")]
        pub file_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. Cloud Storage URIs of archives to be extracted into the working
        /// directory of each executor. Supported file types: .jar, .tar, .tar.gz,
        /// .tgz, and .zip.
        #[prost(string, repeated, tag = "4")]
        pub archive_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. Infrastructure specification for the execution.
        #[prost(message, optional, tag = "6")]
        pub infrastructure_spec: ::core::option::Option<InfrastructureSpec>,
        /// Required. The specification of the main method to call to drive the
        /// job. Specify either the jar file that contains the main class or the
        /// main class name.
        #[prost(oneof = "spark_task_config::Driver", tags = "100, 101, 102, 104, 105")]
        pub driver: ::core::option::Option<spark_task_config::Driver>,
    }
    /// Nested message and enum types in `SparkTaskConfig`.
    pub mod spark_task_config {
        /// Required. The specification of the main method to call to drive the
        /// job. Specify either the jar file that contains the main class or the
        /// main class name.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Driver {
            /// The Cloud Storage URI of the jar file that contains the main class.
            /// The execution args are passed in as a sequence of named process
            /// arguments (`--key=value`).
            #[prost(string, tag = "100")]
            MainJarFileUri(::prost::alloc::string::String),
            /// The name of the driver's main class. The jar file that contains the
            /// class must be in the default CLASSPATH or specified in
            /// `jar_file_uris`.
            /// The execution args are passed in as a sequence of named process
            /// arguments (`--key=value`).
            #[prost(string, tag = "101")]
            MainClass(::prost::alloc::string::String),
            /// The Gcloud Storage URI of the main Python file to use as the driver.
            /// Must be a .py file. The execution args are passed in as a sequence of
            /// named process arguments (`--key=value`).
            #[prost(string, tag = "102")]
            PythonScriptFile(::prost::alloc::string::String),
            /// A reference to a query file. This should be the Cloud Storage URI of
            /// the query file. The execution args are used to declare a set of script
            /// variables (`set key="value";`).
            #[prost(string, tag = "104")]
            SqlScriptFile(::prost::alloc::string::String),
            /// The query text.
            /// The execution args are used to declare a set of script variables
            /// (`set key="value";`).
            #[prost(string, tag = "105")]
            SqlScript(::prost::alloc::string::String),
        }
    }
    /// Config for running scheduled notebooks.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NotebookTaskConfig {
        /// Required. Path to input notebook. This can be the Cloud Storage URI of
        /// the notebook file or the path to a Notebook Content. The execution args
        /// are accessible as environment variables
        /// (`TASK_key=value`).
        #[prost(string, tag = "4")]
        pub notebook: ::prost::alloc::string::String,
        /// Optional. Infrastructure specification for the execution.
        #[prost(message, optional, tag = "3")]
        pub infrastructure_spec: ::core::option::Option<InfrastructureSpec>,
        /// Optional. Cloud Storage URIs of files to be placed in the working
        /// directory of each executor.
        #[prost(string, repeated, tag = "5")]
        pub file_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. Cloud Storage URIs of archives to be extracted into the working
        /// directory of each executor. Supported file types: .jar, .tar, .tar.gz,
        /// .tgz, and .zip.
        #[prost(string, repeated, tag = "6")]
        pub archive_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Status of the task execution (e.g. Jobs).
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecutionStatus {
        /// Output only. Last update time of the status.
        #[prost(message, optional, tag = "3")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
        /// Output only. latest job execution
        #[prost(message, optional, tag = "9")]
        pub latest_job: ::core::option::Option<super::Job>,
    }
    /// Task template specific user-specified config.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Config {
        /// Config related to running custom Spark tasks.
        #[prost(message, tag = "300")]
        Spark(SparkTaskConfig),
        /// Config related to running scheduled Notebooks.
        #[prost(message, tag = "302")]
        Notebook(NotebookTaskConfig),
    }
}
/// A job represents an instance of a task.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Job {
    /// Output only. The relative resource name of the job, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/tasks/{task_id}/jobs/{job_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the job.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the job was started.
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the job ended.
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Execution state for the job.
    #[prost(enumeration = "job::State", tag = "5")]
    pub state: i32,
    /// Output only. The number of times the job has been retried (excluding the
    /// initial attempt).
    #[prost(uint32, tag = "6")]
    pub retry_count: u32,
    /// Output only. The underlying service running a job.
    #[prost(enumeration = "job::Service", tag = "7")]
    pub service: i32,
    /// Output only. The full resource name for the job run under a particular
    /// service.
    #[prost(string, tag = "8")]
    pub service_job: ::prost::alloc::string::String,
    /// Output only. Additional information about the current state.
    #[prost(string, tag = "9")]
    pub message: ::prost::alloc::string::String,
    /// Output only. User-defined labels for the task.
    #[prost(map = "string, string", tag = "10")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Job execution trigger.
    #[prost(enumeration = "job::Trigger", tag = "11")]
    pub trigger: i32,
    /// Output only. Spec related to how a task is executed.
    #[prost(message, optional, tag = "100")]
    pub execution_spec: ::core::option::Option<task::ExecutionSpec>,
}
/// Nested message and enum types in `Job`.
pub mod job {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Service {
        /// Service used to run the job is unspecified.
        Unspecified = 0,
        /// Dataproc service is used to run this job.
        Dataproc = 1,
    }
    impl Service {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SERVICE_UNSPECIFIED",
                Self::Dataproc => "DATAPROC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SERVICE_UNSPECIFIED" => Some(Self::Unspecified),
                "DATAPROC" => Some(Self::Dataproc),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The job state is unknown.
        Unspecified = 0,
        /// The job is running.
        Running = 1,
        /// The job is cancelling.
        Cancelling = 2,
        /// The job cancellation was successful.
        Cancelled = 3,
        /// The job completed successfully.
        Succeeded = 4,
        /// The job is no longer running due to an error.
        Failed = 5,
        /// The job was cancelled outside of Dataplex.
        Aborted = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Running => "RUNNING",
                Self::Cancelling => "CANCELLING",
                Self::Cancelled => "CANCELLED",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::Aborted => "ABORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "RUNNING" => Some(Self::Running),
                "CANCELLING" => Some(Self::Cancelling),
                "CANCELLED" => Some(Self::Cancelled),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "ABORTED" => Some(Self::Aborted),
                _ => None,
            }
        }
    }
    /// Job execution trigger.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Trigger {
        /// The trigger is unspecified.
        Unspecified = 0,
        /// The job was triggered by Dataplex based on trigger spec from task
        /// definition.
        TaskConfig = 1,
        /// The job was triggered by the explicit call of Task API.
        RunRequest = 2,
    }
    impl Trigger {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TRIGGER_UNSPECIFIED",
                Self::TaskConfig => "TASK_CONFIG",
                Self::RunRequest => "RUN_REQUEST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRIGGER_UNSPECIFIED" => Some(Self::Unspecified),
                "TASK_CONFIG" => Some(Self::TaskConfig),
                "RUN_REQUEST" => Some(Self::RunRequest),
                _ => None,
            }
        }
    }
}
/// Create lake request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateLakeRequest {
    /// Required. The resource name of the lake location, of the form:
    /// projects/{project_number}/locations/{location_id}
    /// where `location_id` refers to a GCP region.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Lake identifier.
    /// This ID will be used to generate names such as database and dataset names
    /// when publishing metadata to Hive Metastore and BigQuery.
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    /// * Must be between 1-63 characters.
    /// * Must be unique within the customer project / location.
    #[prost(string, tag = "2")]
    pub lake_id: ::prost::alloc::string::String,
    /// Required. Lake resource
    #[prost(message, optional, tag = "3")]
    pub lake: ::core::option::Option<Lake>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Update lake request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateLakeRequest {
    /// Required. Mask of fields to update.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    #[prost(message, optional, tag = "2")]
    pub lake: ::core::option::Option<Lake>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Delete lake request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteLakeRequest {
    /// Required. The resource name of the lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// List lakes request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLakesRequest {
    /// Required. The resource name of the lake location, of the form:
    /// `projects/{project_number}/locations/{location_id}`
    /// where `location_id` refers to a GCP region.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of Lakes to return. The service may return fewer
    /// than this value. If unspecified, at most 10 lakes will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListLakes` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListLakes` must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Order by fields for the result.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// List lakes response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLakesResponse {
    /// Lakes under the given parent location.
    #[prost(message, repeated, tag = "1")]
    pub lakes: ::prost::alloc::vec::Vec<Lake>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// List lake actions request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLakeActionsRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of actions to return. The service may return fewer
    /// than this value. If unspecified, at most 10 actions will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListLakeActions` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListLakeActions` must match the call that provided
    /// the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// List actions response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListActionsResponse {
    /// Actions under the given parent lake/zone/asset.
    #[prost(message, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Get lake request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLakeRequest {
    /// Required. The resource name of the lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Create zone request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateZoneRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Zone identifier.
    /// This ID will be used to generate names such as database and dataset names
    /// when publishing metadata to Hive Metastore and BigQuery.
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    /// * Must be between 1-63 characters.
    /// * Must be unique across all lakes from all locations in a project.
    /// * Must not be one of the reserved IDs (i.e. "default", "global-temp")
    #[prost(string, tag = "2")]
    pub zone_id: ::prost::alloc::string::String,
    /// Required. Zone resource.
    #[prost(message, optional, tag = "3")]
    pub zone: ::core::option::Option<Zone>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Update zone request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateZoneRequest {
    /// Required. Mask of fields to update.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    #[prost(message, optional, tag = "2")]
    pub zone: ::core::option::Option<Zone>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Delete zone request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteZoneRequest {
    /// Required. The resource name of the zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// List zones request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListZonesRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of zones to return. The service may return fewer
    /// than this value. If unspecified, at most 10 zones will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListZones` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListZones` must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Order by fields for the result.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// List zones response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListZonesResponse {
    /// Zones under the given parent lake.
    #[prost(message, repeated, tag = "1")]
    pub zones: ::prost::alloc::vec::Vec<Zone>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// List zone actions request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListZoneActionsRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of actions to return. The service may return fewer
    /// than this value. If unspecified, at most 10 actions will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListZoneActions` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListZoneActions` must match the call that provided
    /// the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Get zone request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetZoneRequest {
    /// Required. The resource name of the zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Create asset request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAssetRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Asset identifier.
    /// This ID will be used to generate names such as table names when publishing
    /// metadata to Hive Metastore and BigQuery.
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    /// * Must be between 1-63 characters.
    /// * Must be unique within the zone.
    #[prost(string, tag = "2")]
    pub asset_id: ::prost::alloc::string::String,
    /// Required. Asset resource.
    #[prost(message, optional, tag = "3")]
    pub asset: ::core::option::Option<Asset>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Update asset request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAssetRequest {
    /// Required. Mask of fields to update.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<Asset>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Delete asset request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAssetRequest {
    /// Required. The resource name of the asset:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// List assets request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetsRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of asset to return. The service may return fewer
    /// than this value. If unspecified, at most 10 assets will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListAssets` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListAssets` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Order by fields for the result.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// List assets response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetsResponse {
    /// Asset under the given parent zone.
    #[prost(message, repeated, tag = "1")]
    pub assets: ::prost::alloc::vec::Vec<Asset>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// List asset actions request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetActionsRequest {
    /// Required. The resource name of the parent asset:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of actions to return. The service may return fewer
    /// than this value. If unspecified, at most 10 actions will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListAssetActions` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListAssetActions` must match the call that provided
    /// the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Get asset request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAssetRequest {
    /// Required. The resource name of the asset:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Represents the metadata of a long-running operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// Create task request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTaskRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Task identifier.
    #[prost(string, tag = "2")]
    pub task_id: ::prost::alloc::string::String,
    /// Required. Task resource.
    #[prost(message, optional, tag = "3")]
    pub task: ::core::option::Option<Task>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Update task request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTaskRequest {
    /// Required. Mask of fields to update.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    #[prost(message, optional, tag = "2")]
    pub task: ::core::option::Option<Task>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Delete task request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTaskRequest {
    /// Required. The resource name of the task:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/task/{task_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// List tasks request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTasksRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of tasks to return. The service may return fewer
    /// than this value. If unspecified, at most 10 tasks will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListZones` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListZones` must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Order by fields for the result.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// List tasks response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTasksResponse {
    /// Tasks under the given parent lake.
    #[prost(message, repeated, tag = "1")]
    pub tasks: ::prost::alloc::vec::Vec<Task>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Get task request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTaskRequest {
    /// Required. The resource name of the task:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/tasks/{tasks_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Get job request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobRequest {
    /// Required. The resource name of the job:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/tasks/{task_id}/jobs/{job_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunTaskRequest {
    /// Required. The resource name of the task:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/tasks/{task_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User-defined labels for the task. If the map is left empty, the
    /// task will run with existing labels from task definition. If the map
    /// contains an entry with a new key, the same will be added to existing set of
    /// labels. If the map contains an entry with an existing label key in task
    /// definition, the task will run with new label value for that entry. Clearing
    /// an existing label will require label value to be explicitly set to a hyphen
    /// "-". The label value cannot be empty.
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Execution spec arguments. If the map is left empty, the task will
    /// run with existing execution spec args from task definition. If the map
    /// contains an entry with a new key, the same will be added to existing set of
    /// args. If the map contains an entry with an existing arg key in task
    /// definition, the task will run with new arg value for that entry. Clearing
    /// an existing arg will require arg value to be explicitly set to a hyphen
    /// "-". The arg value cannot be empty.
    #[prost(map = "string, string", tag = "4")]
    pub args: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunTaskResponse {
    /// Jobs created by RunTask API.
    #[prost(message, optional, tag = "1")]
    pub job: ::core::option::Option<Job>,
}
/// List jobs request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsRequest {
    /// Required. The resource name of the parent environment:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/tasks/{task_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of jobs to return. The service may return fewer
    /// than this value. If unspecified, at most 10 jobs will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListJobs` call. Provide this
    /// to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListJobs` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// List jobs response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsResponse {
    /// Jobs under a given task.
    #[prost(message, repeated, tag = "1")]
    pub jobs: ::prost::alloc::vec::Vec<Job>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Cancel task jobs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelJobRequest {
    /// Required. The resource name of the job:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/task/{task_id}/job/{job_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Create environment request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEnvironmentRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_id}/locations/{location_id}/lakes/{lake_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Environment identifier.
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the lake.
    #[prost(string, tag = "2")]
    pub environment_id: ::prost::alloc::string::String,
    /// Required. Environment resource.
    #[prost(message, optional, tag = "3")]
    pub environment: ::core::option::Option<Environment>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Update environment request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEnvironmentRequest {
    /// Required. Mask of fields to update.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    #[prost(message, optional, tag = "2")]
    pub environment: ::core::option::Option<Environment>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Delete environment request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEnvironmentRequest {
    /// Required. The resource name of the environment:
    /// `projects/{project_id}/locations/{location_id}/lakes/{lake_id}/environments/{environment_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// List environments request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEnvironmentsRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_id}/locations/{location_id}/lakes/{lake_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of environments to return. The service may return
    /// fewer than this value. If unspecified, at most 10 environments will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListEnvironments` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListEnvironments` must match the call that provided
    /// the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Order by fields for the result.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// List environments response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEnvironmentsResponse {
    /// Environments under the given parent lake.
    #[prost(message, repeated, tag = "1")]
    pub environments: ::prost::alloc::vec::Vec<Environment>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Get environment request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEnvironmentRequest {
    /// Required. The resource name of the environment:
    /// `projects/{project_id}/locations/{location_id}/lakes/{lake_id}/environments/{environment_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// List sessions request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionsRequest {
    /// Required. The resource name of the parent environment:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/environment/{environment_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of sessions to return. The service may return
    /// fewer than this value. If unspecified, at most 10 sessions will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListSessions` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListSessions` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter request. The following `mode` filter is supported to
    /// return only the sessions belonging to the requester when the mode is USER
    /// and return sessions of all the users when the mode is ADMIN. When no filter
    /// is sent default to USER mode. NOTE: When the mode is ADMIN, the requester
    /// should have `dataplex.environments.listAllSessions` permission to list all
    /// sessions, in absence of the permission, the request fails.
    ///
    /// mode = ADMIN | USER
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// List sessions response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionsResponse {
    /// Sessions under a given environment.
    #[prost(message, repeated, tag = "1")]
    pub sessions: ::prost::alloc::vec::Vec<Session>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod dataplex_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Dataplex service provides data lakes as a service. The primary resources
    /// offered by this service are Lakes, Zones and Assets which collectively allow
    /// a data administrator to organize, manage, secure and catalog data across
    /// their organization located across cloud projects in a variety of storage
    /// systems including Cloud Storage and BigQuery.
    #[derive(Debug, Clone)]
    pub struct DataplexServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DataplexServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DataplexServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DataplexServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DataplexServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a lake resource.
        pub async fn create_lake(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateLakeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/CreateLake",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "CreateLake",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a lake resource.
        pub async fn update_lake(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateLakeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/UpdateLake",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "UpdateLake",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a lake resource. All zones within the lake must be deleted before
        /// the lake can be deleted.
        pub async fn delete_lake(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteLakeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/DeleteLake",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "DeleteLake",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists lake resources in a project and location.
        pub async fn list_lakes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListLakesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListLakesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListLakes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListLakes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a lake resource.
        pub async fn get_lake(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLakeRequest>,
        ) -> std::result::Result<tonic::Response<super::Lake>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/GetLake",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "GetLake",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists action resources in a lake.
        pub async fn list_lake_actions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListLakeActionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListActionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListLakeActions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListLakeActions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a zone resource within a lake.
        pub async fn create_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/CreateZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "CreateZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a zone resource.
        pub async fn update_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/UpdateZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "UpdateZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a zone resource. All assets within a zone must be deleted before
        /// the zone can be deleted.
        pub async fn delete_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/DeleteZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "DeleteZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists zone resources in a lake.
        pub async fn list_zones(
            &mut self,
            request: impl tonic::IntoRequest<super::ListZonesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListZonesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListZones",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListZones",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a zone resource.
        pub async fn get_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::GetZoneRequest>,
        ) -> std::result::Result<tonic::Response<super::Zone>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/GetZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "GetZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists action resources in a zone.
        pub async fn list_zone_actions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListZoneActionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListActionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListZoneActions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListZoneActions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an asset resource.
        pub async fn create_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAssetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/CreateAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "CreateAsset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an asset resource.
        pub async fn update_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAssetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/UpdateAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "UpdateAsset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an asset resource. The referenced storage resource is detached
        /// (default) or deleted based on the associated Lifecycle policy.
        pub async fn delete_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAssetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/DeleteAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "DeleteAsset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists asset resources in a zone.
        pub async fn list_assets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAssetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAssetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListAssets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListAssets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves an asset resource.
        pub async fn get_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAssetRequest>,
        ) -> std::result::Result<tonic::Response<super::Asset>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/GetAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "GetAsset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists action resources in an asset.
        pub async fn list_asset_actions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAssetActionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListActionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListAssetActions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListAssetActions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a task resource within a lake.
        pub async fn create_task(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTaskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/CreateTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "CreateTask",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update the task resource.
        pub async fn update_task(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateTaskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/UpdateTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "UpdateTask",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete the task resource.
        pub async fn delete_task(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTaskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/DeleteTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "DeleteTask",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists tasks under the given lake.
        pub async fn list_tasks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTasksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTasksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListTasks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListTasks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get task resource.
        pub async fn get_task(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTaskRequest>,
        ) -> std::result::Result<tonic::Response<super::Task>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/GetTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "GetTask",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Jobs under the given task.
        pub async fn list_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListJobsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListJobsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListJobs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListJobs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Run an on demand execution of a Task.
        pub async fn run_task(
            &mut self,
            request: impl tonic::IntoRequest<super::RunTaskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RunTaskResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/RunTask",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "RunTask",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get job resource.
        pub async fn get_job(
            &mut self,
            request: impl tonic::IntoRequest<super::GetJobRequest>,
        ) -> std::result::Result<tonic::Response<super::Job>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/GetJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.dataplex.v1.DataplexService", "GetJob"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Cancel jobs running for the task resource.
        pub async fn cancel_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelJobRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/CancelJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "CancelJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create an environment resource.
        pub async fn create_environment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEnvironmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/CreateEnvironment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "CreateEnvironment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update the environment resource.
        pub async fn update_environment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEnvironmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/UpdateEnvironment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "UpdateEnvironment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete the environment resource. All the child resources must have been
        /// deleted before environment deletion can be initiated.
        pub async fn delete_environment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEnvironmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/DeleteEnvironment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "DeleteEnvironment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists environments under the given lake.
        pub async fn list_environments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEnvironmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEnvironmentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListEnvironments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListEnvironments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get environment resource.
        pub async fn get_environment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEnvironmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Environment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/GetEnvironment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "GetEnvironment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists session resources in an environment.
        pub async fn list_sessions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSessionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSessionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataplexService/ListSessions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataplexService",
                        "ListSessions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// AspectType is a template for creating Aspects, and represents the
/// JSON-schema for a given Entry, for example, BigQuery Table Schema.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AspectType {
    /// Output only. The relative resource name of the AspectType, of the form:
    /// projects/{project_number}/locations/{location_id}/aspectTypes/{aspect_type_id}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the AspectType.
    /// If you delete and recreate the AspectType with the same name, then this ID
    /// will be different.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the AspectType was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the AspectType was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Description of the AspectType.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. User-defined labels for the AspectType.
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The service computes this checksum. The client may send it on update and
    /// delete requests to ensure it has an up-to-date value before proceeding.
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    /// Immutable. Defines the Authorization for this type.
    #[prost(message, optional, tag = "52")]
    pub authorization: ::core::option::Option<aspect_type::Authorization>,
    /// Required. MetadataTemplate of the aspect.
    #[prost(message, optional, tag = "53")]
    pub metadata_template: ::core::option::Option<aspect_type::MetadataTemplate>,
    /// Output only. Denotes the transfer status of the Aspect Type. It is
    /// unspecified for Aspect Types created from Dataplex API.
    #[prost(enumeration = "TransferStatus", tag = "202")]
    pub transfer_status: i32,
}
/// Nested message and enum types in `AspectType`.
pub mod aspect_type {
    /// Autorization for an AspectType.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Authorization {
        /// Immutable. The IAM permission grantable on the EntryGroup to allow access
        /// to instantiate Aspects of Dataplex owned AspectTypes, only settable for
        /// Dataplex owned Types.
        #[prost(string, tag = "1")]
        pub alternate_use_permission: ::prost::alloc::string::String,
    }
    /// MetadataTemplate definition for an AspectType.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MetadataTemplate {
        /// Optional. Index is used to encode Template messages. The value of index
        /// can range between 1 and 2,147,483,647. Index must be unique within all
        /// fields in a Template. (Nested Templates can reuse indexes). Once a
        /// Template is defined, the index cannot be changed, because it identifies
        /// the field in the actual storage format. Index is a mandatory field, but
        /// it is optional for top level fields, and map/array "values" definitions.
        #[prost(int32, tag = "1")]
        pub index: i32,
        /// Required. The name of the field.
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        /// Required. The datatype of this field. The following values are supported:
        ///
        /// Primitive types:
        ///
        /// * string
        /// * integer
        /// * boolean
        /// * double
        /// * datetime. Must be of the format RFC3339 UTC "Zulu" (Examples:
        /// "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z").
        ///
        /// Complex types:
        ///
        /// * enum
        /// * array
        /// * map
        /// * record
        #[prost(string, tag = "5")]
        pub r#type: ::prost::alloc::string::String,
        /// Optional. Field definition. You must specify it if the type is record. It
        /// defines the nested fields.
        #[prost(message, repeated, tag = "6")]
        pub record_fields: ::prost::alloc::vec::Vec<MetadataTemplate>,
        /// Optional. The list of values for an enum type. You must define it if the
        /// type is enum.
        #[prost(message, repeated, tag = "8")]
        pub enum_values: ::prost::alloc::vec::Vec<metadata_template::EnumValue>,
        /// Optional. If the type is map, set map_items. map_items can refer to a
        /// primitive field or a complex (record only) field. To specify a primitive
        /// field, you only need to set name and type in the nested
        /// MetadataTemplate. The recommended value for the name field is item, as
        /// this isn't used in the actual payload.
        #[prost(message, optional, boxed, tag = "10")]
        pub map_items: ::core::option::Option<
            ::prost::alloc::boxed::Box<MetadataTemplate>,
        >,
        /// Optional. If the type is array, set array_items. array_items can refer
        /// to a primitive field or a complex (record only) field. To specify a
        /// primitive field, you only need to set name and type in the nested
        /// MetadataTemplate. The recommended value for the name field is item, as
        /// this isn't used in the actual payload.
        #[prost(message, optional, boxed, tag = "11")]
        pub array_items: ::core::option::Option<
            ::prost::alloc::boxed::Box<MetadataTemplate>,
        >,
        /// Optional. You can use type id if this definition of the field needs to be
        /// reused later. The type id must be unique across the entire template. You
        /// can only specify it if the field type is record.
        #[prost(string, tag = "12")]
        pub type_id: ::prost::alloc::string::String,
        /// Optional. A reference to another field definition (not an inline
        /// definition). The value must be equal to the value of an id field defined
        /// elsewhere in the MetadataTemplate. Only fields with record type can
        /// refer to other fields.
        #[prost(string, tag = "13")]
        pub type_ref: ::prost::alloc::string::String,
        /// Optional. Specifies the constraints on this field.
        #[prost(message, optional, tag = "50")]
        pub constraints: ::core::option::Option<metadata_template::Constraints>,
        /// Optional. Specifies annotations on this field.
        #[prost(message, optional, tag = "51")]
        pub annotations: ::core::option::Option<metadata_template::Annotations>,
    }
    /// Nested message and enum types in `MetadataTemplate`.
    pub mod metadata_template {
        /// Definition of Enumvalue, to be used for enum fields.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct EnumValue {
            /// Required. Index for the enum value. It can't be modified.
            #[prost(int32, tag = "1")]
            pub index: i32,
            /// Required. Name of the enumvalue. This is the actual value that the
            /// aspect can contain.
            #[prost(string, tag = "2")]
            pub name: ::prost::alloc::string::String,
            /// Optional. You can set this message if you need to deprecate an enum
            /// value.
            #[prost(string, tag = "3")]
            pub deprecated: ::prost::alloc::string::String,
        }
        /// Definition of the constraints of a field.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Constraints {
            /// Optional. Marks this field as optional or required.
            #[prost(bool, tag = "1")]
            pub required: bool,
        }
        /// Definition of the annotations of a field.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Annotations {
            /// Optional. Marks a field as deprecated. You can include a deprecation
            /// message.
            #[prost(string, tag = "1")]
            pub deprecated: ::prost::alloc::string::String,
            /// Optional. Display name for a field.
            #[prost(string, tag = "2")]
            pub display_name: ::prost::alloc::string::String,
            /// Optional. Description for a field.
            #[prost(string, tag = "3")]
            pub description: ::prost::alloc::string::String,
            /// Optional. Display order for a field. You can use this to reorder where
            /// a field is rendered.
            #[prost(int32, tag = "4")]
            pub display_order: i32,
            /// Optional. You can use String Type annotations to specify special
            /// meaning to string fields. The following values are supported:
            ///
            /// * richText: The field must be interpreted as a rich text field.
            /// * url: A fully qualified URL link.
            /// * resource: A service qualified resource reference.
            #[prost(string, tag = "6")]
            pub string_type: ::prost::alloc::string::String,
            /// Optional. Suggested hints for string fields. You can use them to
            /// suggest values to users through console.
            #[prost(string, repeated, tag = "7")]
            pub string_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
    }
}
/// An Entry Group represents a logical grouping of one or more Entries.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntryGroup {
    /// Output only. The relative resource name of the EntryGroup, in the format
    /// projects/{project_id_or_number}/locations/{location_id}/entryGroups/{entry_group_id}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the EntryGroup. If you
    /// delete and recreate the EntryGroup with the same name, this ID will be
    /// different.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the EntryGroup was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the EntryGroup was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Description of the EntryGroup.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. User-defined labels for the EntryGroup.
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// This checksum is computed by the service, and might be sent on update and
    /// delete requests to ensure the client has an up-to-date value before
    /// proceeding.
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. Denotes the transfer status of the Entry Group. It is
    /// unspecified for Entry Group created from Dataplex API.
    #[prost(enumeration = "TransferStatus", tag = "202")]
    pub transfer_status: i32,
}
/// Entry Type is a template for creating Entries.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntryType {
    /// Output only. The relative resource name of the EntryType, of the form:
    /// projects/{project_number}/locations/{location_id}/entryTypes/{entry_type_id}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the EntryType. This ID
    /// will be different if the EntryType is deleted and re-created with the same
    /// name.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the EntryType was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the EntryType was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Description of the EntryType.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. User-defined labels for the EntryType.
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. This checksum is computed by the service, and might be sent on
    /// update and delete requests to ensure the client has an up-to-date value
    /// before proceeding.
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    /// Optional. Indicates the classes this Entry Type belongs to, for example,
    /// TABLE, DATABASE, MODEL.
    #[prost(string, repeated, tag = "9")]
    pub type_aliases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The platform that Entries of this type belongs to.
    #[prost(string, tag = "10")]
    pub platform: ::prost::alloc::string::String,
    /// Optional. The system that Entries of this type belongs to. Examples include
    /// CloudSQL, MariaDB etc
    #[prost(string, tag = "11")]
    pub system: ::prost::alloc::string::String,
    /// AspectInfo for the entry type.
    #[prost(message, repeated, tag = "50")]
    pub required_aspects: ::prost::alloc::vec::Vec<entry_type::AspectInfo>,
    /// Immutable. Authorization defined for this type.
    #[prost(message, optional, tag = "51")]
    pub authorization: ::core::option::Option<entry_type::Authorization>,
}
/// Nested message and enum types in `EntryType`.
pub mod entry_type {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AspectInfo {
        /// Required aspect type for the entry type.
        #[prost(string, tag = "1")]
        pub r#type: ::prost::alloc::string::String,
    }
    /// Authorization for an Entry Type.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Authorization {
        /// Immutable. The IAM permission grantable on the Entry Group to allow
        /// access to instantiate Entries of Dataplex owned Entry Types, only
        /// settable for Dataplex owned Types.
        #[prost(string, tag = "1")]
        pub alternate_use_permission: ::prost::alloc::string::String,
    }
}
/// An aspect is a single piece of metadata describing an entry.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Aspect {
    /// Output only. The resource name of the type used to create this Aspect.
    #[prost(string, tag = "1")]
    pub aspect_type: ::prost::alloc::string::String,
    /// Output only. The path in the entry under which the aspect is attached.
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    /// Output only. The time when the Aspect was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the Aspect was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. The content of the aspect, according to its aspect type schema.
    /// The maximum size of the field is 120KB (encoded as UTF-8).
    #[prost(message, optional, tag = "8")]
    pub data: ::core::option::Option<::prost_types::Struct>,
    /// Optional. Information related to the source system of the aspect.
    #[prost(message, optional, tag = "9")]
    pub aspect_source: ::core::option::Option<AspectSource>,
}
/// Information related to the source system of the aspect.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AspectSource {
    /// The time the aspect was created in the source system.
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time the aspect was last updated in the source system.
    #[prost(message, optional, tag = "11")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The version of the data format used to produce this data. This field is
    /// used to indicated when the underlying data format changes (e.g., schema
    /// modifications, changes to the source URL format definition, etc).
    #[prost(string, tag = "12")]
    pub data_version: ::prost::alloc::string::String,
}
/// An entry is a representation of a data resource that can be described by
/// various metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entry {
    /// Identifier. The relative resource name of the entry, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}/entryGroups/{entry_group_id}/entries/{entry_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Immutable. The relative resource name of the entry type that was
    /// used to create this entry, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}/entryTypes/{entry_type_id}`.
    #[prost(string, tag = "4")]
    pub entry_type: ::prost::alloc::string::String,
    /// Output only. The time when the entry was created in Dataplex.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the entry was last updated in Dataplex.
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The aspects that are attached to the entry. Depending on how the
    /// aspect is attached to the entry, the format of the aspect key can be one of
    /// the following:
    ///
    /// * If the aspect is attached directly to the entry:
    /// `{project_id_or_number}.{location_id}.{aspect_type_id}`
    /// * If the aspect is attached to an entry's path:
    /// `{project_id_or_number}.{location_id}.{aspect_type_id}@{path}`
    #[prost(map = "string, message", tag = "9")]
    pub aspects: ::std::collections::HashMap<::prost::alloc::string::String, Aspect>,
    /// Optional. Immutable. The resource name of the parent entry.
    #[prost(string, tag = "10")]
    pub parent_entry: ::prost::alloc::string::String,
    /// Optional. A name for the entry that can be referenced by an external
    /// system. For more information, see [Fully qualified
    /// names](<https://cloud.google.com/data-catalog/docs/fully-qualified-names>).
    /// The maximum size of the field is 4000 characters.
    #[prost(string, tag = "12")]
    pub fully_qualified_name: ::prost::alloc::string::String,
    /// Optional. Information related to the source system of the data resource
    /// that is represented by the entry.
    #[prost(message, optional, tag = "15")]
    pub entry_source: ::core::option::Option<EntrySource>,
}
/// Information related to the source system of the data resource that is
/// represented by the entry.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntrySource {
    /// The name of the resource in the source system.
    /// Maximum length is 4,000 characters.
    #[prost(string, tag = "1")]
    pub resource: ::prost::alloc::string::String,
    /// The name of the source system.
    /// Maximum length is 64 characters.
    #[prost(string, tag = "2")]
    pub system: ::prost::alloc::string::String,
    /// The platform containing the source system.
    /// Maximum length is 64 characters.
    #[prost(string, tag = "3")]
    pub platform: ::prost::alloc::string::String,
    /// A user-friendly display name.
    /// Maximum length is 500 characters.
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    /// A description of the data resource.
    /// Maximum length is 2,000 characters.
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    /// User-defined labels.
    /// The maximum size of keys and values is 128 characters each.
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Immutable. The entries representing the ancestors of the data resource in
    /// the source system.
    #[prost(message, repeated, tag = "9")]
    pub ancestors: ::prost::alloc::vec::Vec<entry_source::Ancestor>,
    /// The time when the resource was created in the source system.
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time when the resource was last updated in the source system. If the
    /// entry exists in the system and its `EntrySource` has `update_time`
    /// populated, further updates to the `EntrySource` of the entry must provide
    /// incremental updates to its `update_time`.
    #[prost(message, optional, tag = "11")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Location of the resource in the source system. You can search
    /// the entry by this location. By default, this should match the location of
    /// the entry group containing this entry. A different value allows capturing
    /// the source location for data external to Google Cloud.
    #[prost(string, tag = "12")]
    pub location: ::prost::alloc::string::String,
}
/// Nested message and enum types in `EntrySource`.
pub mod entry_source {
    /// Information about individual items in the hierarchy that is associated with
    /// the data resource.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Ancestor {
        /// Optional. The name of the ancestor resource.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Optional. The type of the ancestor resource.
        #[prost(string, tag = "2")]
        pub r#type: ::prost::alloc::string::String,
    }
}
/// Create EntryGroup Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEntryGroupRequest {
    /// Required. The resource name of the entryGroup, of the form:
    /// projects/{project_number}/locations/{location_id}
    /// where `location_id` refers to a GCP region.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. EntryGroup identifier.
    #[prost(string, tag = "2")]
    pub entry_group_id: ::prost::alloc::string::String,
    /// Required. EntryGroup Resource.
    #[prost(message, optional, tag = "3")]
    pub entry_group: ::core::option::Option<EntryGroup>,
    /// Optional. The service validates the request without performing any
    /// mutations. The default is false.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Update EntryGroup Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEntryGroupRequest {
    /// Required. EntryGroup Resource.
    #[prost(message, optional, tag = "1")]
    pub entry_group: ::core::option::Option<EntryGroup>,
    /// Required. Mask of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Optional. The service validates the request, without performing any
    /// mutations. The default is false.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Delete EntryGroup Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEntryGroupRequest {
    /// Required. The resource name of the EntryGroup:
    /// `projects/{project_number}/locations/{location_id}/entryGroups/{entry_group_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If the client provided etag value does not match the current etag
    /// value, the DeleteEntryGroupRequest method returns an ABORTED error
    /// response.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// List entryGroups request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntryGroupsRequest {
    /// Required. The resource name of the entryGroup location, of the form:
    /// `projects/{project_number}/locations/{location_id}`
    /// where `location_id` refers to a Google Cloud region.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of EntryGroups to return. The service may return
    /// fewer than this value. If unspecified, the service returns at most 10
    /// EntryGroups. The maximum value is 1000; values above 1000 will be coerced
    /// to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListEntryGroups` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters you provide to `ListEntryGroups` must match the call that
    /// provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Order by fields for the result.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// List entry groups response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntryGroupsResponse {
    /// Entry groups under the given parent location.
    #[prost(message, repeated, tag = "1")]
    pub entry_groups: ::prost::alloc::vec::Vec<EntryGroup>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that the service couldn't reach.
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Get EntryGroup request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEntryGroupRequest {
    /// Required. The resource name of the EntryGroup:
    /// `projects/{project_number}/locations/{location_id}/entryGroups/{entry_group_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Create EntryType Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEntryTypeRequest {
    /// Required. The resource name of the EntryType, of the form:
    /// projects/{project_number}/locations/{location_id}
    /// where `location_id` refers to a Google Cloud region.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. EntryType identifier.
    #[prost(string, tag = "2")]
    pub entry_type_id: ::prost::alloc::string::String,
    /// Required. EntryType Resource.
    #[prost(message, optional, tag = "3")]
    pub entry_type: ::core::option::Option<EntryType>,
    /// Optional. The service validates the request without performing any
    /// mutations. The default is false.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Update EntryType Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEntryTypeRequest {
    /// Required. EntryType Resource.
    #[prost(message, optional, tag = "1")]
    pub entry_type: ::core::option::Option<EntryType>,
    /// Required. Mask of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Optional. The service validates the request without performing any
    /// mutations. The default is false.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Delele EntryType Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEntryTypeRequest {
    /// Required. The resource name of the EntryType:
    /// `projects/{project_number}/locations/{location_id}/entryTypes/{entry_type_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If the client provided etag value does not match the current etag
    /// value, the DeleteEntryTypeRequest method returns an ABORTED error response.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// List EntryTypes request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntryTypesRequest {
    /// Required. The resource name of the EntryType location, of the form:
    /// `projects/{project_number}/locations/{location_id}`
    /// where `location_id` refers to a Google Cloud region.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of EntryTypes to return. The service may return
    /// fewer than this value. If unspecified, the service returns at most 10
    /// EntryTypes. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListEntryTypes` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters you provided to `ListEntryTypes` must match the call that
    /// provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter request. Filters are case-sensitive.
    /// The service supports the following formats:
    ///
    /// * labels.key1 = "value1"
    /// * labels:key1
    /// * name = "value"
    ///
    /// These restrictions can be conjoined with AND, OR, and NOT conjunctions.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Orders the result by `name` or `create_time` fields.
    /// If not specified, the ordering is undefined.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// List EntryTypes response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntryTypesResponse {
    /// EntryTypes under the given parent location.
    #[prost(message, repeated, tag = "1")]
    pub entry_types: ::prost::alloc::vec::Vec<EntryType>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that the service couldn't reach.
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Get EntryType request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEntryTypeRequest {
    /// Required. The resource name of the EntryType:
    /// `projects/{project_number}/locations/{location_id}/entryTypes/{entry_type_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Create AspectType Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAspectTypeRequest {
    /// Required. The resource name of the AspectType, of the form:
    /// projects/{project_number}/locations/{location_id}
    /// where `location_id` refers to a Google Cloud region.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. AspectType identifier.
    #[prost(string, tag = "2")]
    pub aspect_type_id: ::prost::alloc::string::String,
    /// Required. AspectType Resource.
    #[prost(message, optional, tag = "3")]
    pub aspect_type: ::core::option::Option<AspectType>,
    /// Optional. The service validates the request without performing any
    /// mutations. The default is false.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Update AspectType Request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAspectTypeRequest {
    /// Required. AspectType Resource
    #[prost(message, optional, tag = "1")]
    pub aspect_type: ::core::option::Option<AspectType>,
    /// Required. Mask of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Delele AspectType Request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAspectTypeRequest {
    /// Required. The resource name of the AspectType:
    /// `projects/{project_number}/locations/{location_id}/aspectTypes/{aspect_type_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If the client provided etag value does not match the current etag
    /// value, the DeleteAspectTypeRequest method returns an ABORTED error
    /// response.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// List AspectTypes request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAspectTypesRequest {
    /// Required. The resource name of the AspectType location, of the form:
    /// `projects/{project_number}/locations/{location_id}`
    /// where `location_id` refers to a Google Cloud region.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of AspectTypes to return. The service may return
    /// fewer than this value. If unspecified, the service returns at most 10
    /// AspectTypes. The maximum value is 1000; values above 1000 will be coerced
    /// to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListAspectTypes` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters you provide to `ListAspectTypes` must match the call that
    /// provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter request. Filters are case-sensitive.
    /// The service supports the following formats:
    ///
    /// * labels.key1 = "value1"
    /// * labels:key1
    /// * name = "value"
    ///
    /// These restrictions can be conjoined with AND, OR, and NOT conjunctions.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Orders the result by `name` or `create_time` fields.
    /// If not specified, the ordering is undefined.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// List AspectTypes response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAspectTypesResponse {
    /// AspectTypes under the given parent location.
    #[prost(message, repeated, tag = "1")]
    pub aspect_types: ::prost::alloc::vec::Vec<AspectType>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that the service couldn't reach.
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Get AspectType request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAspectTypeRequest {
    /// Required. The resource name of the AspectType:
    /// `projects/{project_number}/locations/{location_id}/aspectTypes/{aspect_type_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Create Entry request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEntryRequest {
    /// Required. The resource name of the parent Entry Group:
    /// `projects/{project}/locations/{location}/entryGroups/{entry_group}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Entry identifier. It has to be unique within an Entry Group.
    ///
    /// Entries corresponding to Google Cloud resources use an Entry ID format
    /// based on [full resource
    /// names](<https://cloud.google.com/apis/design/resource_names#full_resource_name>).
    /// The format is a full resource name of the resource without the
    /// prefix double slashes in the API service name part of the full resource
    /// name. This allows retrieval of entries using their associated resource
    /// name.
    ///
    /// For example, if the full resource name of a resource is
    /// `//library.googleapis.com/shelves/shelf1/books/book2`,
    /// then the suggested entry_id is
    /// `library.googleapis.com/shelves/shelf1/books/book2`.
    ///
    /// It is also suggested to follow the same convention for entries
    /// corresponding to resources from providers or systems other than Google
    /// Cloud.
    ///
    /// The maximum size of the field is 4000 characters.
    #[prost(string, tag = "2")]
    pub entry_id: ::prost::alloc::string::String,
    /// Required. Entry resource.
    #[prost(message, optional, tag = "3")]
    pub entry: ::core::option::Option<Entry>,
}
/// Update Entry request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEntryRequest {
    /// Required. Entry resource.
    #[prost(message, optional, tag = "1")]
    pub entry: ::core::option::Option<Entry>,
    /// Optional. Mask of fields to update. To update Aspects, the update_mask must
    /// contain the value "aspects".
    ///
    /// If the update_mask is empty, the service will update all modifiable fields
    /// present in the request.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Optional. If set to true and the entry doesn't exist, the service will
    /// create it.
    #[prost(bool, tag = "3")]
    pub allow_missing: bool,
    /// Optional. If set to true and the aspect_keys specify aspect ranges, the
    /// service deletes any existing aspects from that range that weren't provided
    /// in the request.
    #[prost(bool, tag = "4")]
    pub delete_missing_aspects: bool,
    /// Optional. The map keys of the Aspects which the service should modify. It
    /// supports the following syntaxes:
    ///
    /// * `<aspect_type_reference>` - matches an aspect of the given type and empty
    /// path.
    /// * `<aspect_type_reference>@path` - matches an aspect of the given type and
    /// specified path. For example, to attach an aspect to a field that is
    /// specified by the `schema` aspect, the path should have the format
    /// `Schema.<field_name>`.
    /// * `<aspect_type_reference>@*` - matches aspects of the given type for all
    /// paths.
    /// * `*@path` - matches aspects of all types on the given path.
    ///
    /// The service will not remove existing aspects matching the syntax unless
    /// `delete_missing_aspects` is set to true.
    ///
    /// If this field is left empty, the service treats it as specifying
    /// exactly those Aspects present in the request.
    #[prost(string, repeated, tag = "5")]
    pub aspect_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Delete Entry request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEntryRequest {
    /// Required. The resource name of the Entry:
    /// `projects/{project}/locations/{location}/entryGroups/{entry_group}/entries/{entry}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// List Entries request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntriesRequest {
    /// Required. The resource name of the parent Entry Group:
    /// `projects/{project}/locations/{location}/entryGroups/{entry_group}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Number of items to return per page. If there are remaining
    /// results, the service returns a next_page_token. If unspecified, the service
    /// returns at most 10 Entries. The maximum value is 100; values above 100 will
    /// be coerced to 100.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListEntries` call. Provide
    /// this to retrieve the subsequent page.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. A filter on the entries to return. Filters are case-sensitive.
    /// You can filter the request by the following fields:
    ///
    /// * entry_type
    /// * entry_source.display_name
    ///
    /// The comparison operators are =, !=, <, >, <=, >=. The service compares
    /// strings according to lexical order.
    ///
    /// You can use the logical operators AND, OR, NOT in the filter.
    ///
    /// You can use Wildcard "*", but for entry_type you need to provide the
    /// full project id or number.
    ///
    /// Example filter expressions:
    ///
    /// * "entry_source.display_name=AnExampleDisplayName"
    /// * "entry_type=projects/example-project/locations/global/entryTypes/example-entry_type"
    /// * "entry_type=projects/example-project/locations/us/entryTypes/a* OR
    /// entry_type=projects/another-project/locations/*"
    /// * "NOT entry_source.display_name=AnotherExampleDisplayName"
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// List Entries response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntriesResponse {
    /// The list of entries under the given parent location.
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<Entry>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Get Entry request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEntryRequest {
    /// Required. The resource name of the Entry:
    /// `projects/{project}/locations/{location}/entryGroups/{entry_group}/entries/{entry}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. View to control which parts of an entry the service should
    /// return.
    #[prost(enumeration = "EntryView", tag = "2")]
    pub view: i32,
    /// Optional. Limits the aspects returned to the provided aspect types.
    /// It only works for CUSTOM view.
    #[prost(string, repeated, tag = "3")]
    pub aspect_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Limits the aspects returned to those associated with the provided
    /// paths within the Entry. It only works for CUSTOM view.
    #[prost(string, repeated, tag = "4")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Lookup Entry request using permissions in the source system.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupEntryRequest {
    /// Required. The project to which the request should be attributed in the
    /// following form: `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. View to control which parts of an entry the service should
    /// return.
    #[prost(enumeration = "EntryView", tag = "2")]
    pub view: i32,
    /// Optional. Limits the aspects returned to the provided aspect types.
    /// It only works for CUSTOM view.
    #[prost(string, repeated, tag = "3")]
    pub aspect_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Limits the aspects returned to those associated with the provided
    /// paths within the Entry. It only works for CUSTOM view.
    #[prost(string, repeated, tag = "4")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required. The resource name of the Entry:
    /// `projects/{project}/locations/{location}/entryGroups/{entry_group}/entries/{entry}`.
    #[prost(string, tag = "5")]
    pub entry: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchEntriesRequest {
    /// Required. The project to which the request should be attributed in the
    /// following form: `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The query against which entries in scope should be matched.
    /// The query syntax is defined in [Search syntax for Dataplex
    /// Catalog](<https://cloud.google.com/dataplex/docs/search-syntax>).
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    /// Optional. Number of results in the search page. If <=0, then defaults
    /// to 10. Max limit for page_size is 1000. Throws an invalid argument for
    /// page_size > 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `SearchEntries` call. Provide
    /// this to retrieve the subsequent page.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Specifies the ordering of results.
    /// Supported values are:
    /// * `relevance` (default)
    /// * `last_modified_timestamp`
    /// * `last_modified_timestamp asc`
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. The scope under which the search should be operating. It must
    /// either be `organizations/<org_id>` or `projects/<project_ref>`. If it is
    /// unspecified, it defaults to the organization where the project provided in
    /// `name` is located.
    #[prost(string, tag = "7")]
    pub scope: ::prost::alloc::string::String,
}
/// A single result of a SearchEntries request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchEntriesResult {
    /// Linked resource name.
    #[deprecated]
    #[prost(string, tag = "8")]
    pub linked_resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub dataplex_entry: ::core::option::Option<Entry>,
    /// Snippets.
    #[deprecated]
    #[prost(message, optional, tag = "12")]
    pub snippets: ::core::option::Option<search_entries_result::Snippets>,
}
/// Nested message and enum types in `SearchEntriesResult`.
pub mod search_entries_result {
    /// Snippets for the entry, contains HTML-style highlighting for
    /// matched tokens, will be used in UI.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Snippets {
        /// Entry
        #[deprecated]
        #[prost(message, optional, tag = "1")]
        pub dataplex_entry: ::core::option::Option<super::Entry>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchEntriesResponse {
    /// The results matching the search query.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<SearchEntriesResult>,
    /// The estimated total number of matching entries. This number isn't
    /// guaranteed to be accurate.
    #[prost(int32, tag = "2")]
    pub total_size: i32,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that the service couldn't reach. Search results don't include
    /// data from these locations.
    #[prost(string, repeated, tag = "4")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// An object that describes the values that you want to set for an entry and its
/// attached aspects when you import metadata. Used when you run a metadata
/// import job. See
/// [CreateMetadataJob][google.cloud.dataplex.v1.CatalogService.CreateMetadataJob].
///
/// You provide a collection of import items in a metadata import file. For more
/// information about how to create a metadata import file, see [Metadata import
/// file](<https://cloud.google.com/dataplex/docs/import-metadata#metadata-import-file>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportItem {
    /// Information about an entry and its attached aspects.
    #[prost(message, optional, tag = "1")]
    pub entry: ::core::option::Option<Entry>,
    /// The fields to update, in paths that are relative to the `Entry` resource.
    /// Separate each field with a comma.
    ///
    /// In `FULL` entry sync mode, Dataplex includes the paths of all of the fields
    /// for an entry that can be modified, including aspects. This means that
    /// Dataplex replaces the existing entry with the entry in the metadata import
    /// file. All modifiable fields are updated, regardless of the fields that are
    /// listed in the update mask, and regardless of whether a field is present
    /// in the `entry` object.
    ///
    ///
    /// The `update_mask` field is ignored when an entry is created or re-created.
    ///
    /// Dataplex also determines which entries and aspects to modify by comparing
    /// the values and timestamps that you provide in the metadata import file with
    /// the values and timestamps that exist in your project. For more information,
    /// see [Comparison
    /// logic](<https://cloud.google.com/dataplex/docs/import-metadata#data-modification-logic>).
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The aspects to modify. Supports the following syntaxes:
    ///
    /// * `{aspect_type_reference}`: matches aspects that belong to the specified
    /// aspect type and are attached directly to the entry.
    /// * `{aspect_type_reference}@{path}`: matches aspects that belong to the
    /// specified aspect type and path.
    /// * `<aspect_type_reference>@*` : matches aspects of the given type for all
    /// paths.
    /// * `*@path` : matches aspects of all types on the given path.
    /// Replace `{aspect_type_reference}` with a reference to the aspect type, in
    /// the format
    /// `{project_id_or_number}.{location_id}.{aspect_type_id}`.
    ///
    /// If you leave this field empty, it is treated as specifying exactly those
    /// aspects that are present within the specified entry.
    ///
    /// In `FULL` entry sync mode, Dataplex implicitly adds the keys for all of the
    /// required aspects of an entry.
    #[prost(string, repeated, tag = "3")]
    pub aspect_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Create metadata job request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMetadataJobRequest {
    /// Required. The resource name of the parent location, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The metadata job resource.
    #[prost(message, optional, tag = "2")]
    pub metadata_job: ::core::option::Option<MetadataJob>,
    /// Optional. The metadata job ID. If not provided, a unique ID is generated
    /// with the prefix `metadata-job-`.
    #[prost(string, tag = "3")]
    pub metadata_job_id: ::prost::alloc::string::String,
    /// Optional. The service validates the request without performing any
    /// mutations. The default is false.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Get metadata job request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetadataJobRequest {
    /// Required. The resource name of the metadata job, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}/metadataJobs/{metadata_job_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// List metadata jobs request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetadataJobsRequest {
    /// Required. The resource name of the parent location, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of metadata jobs to return. The service might
    /// return fewer jobs than this value. If unspecified, at most 10 jobs are
    /// returned. The maximum value is 1,000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The page token received from a previous `ListMetadataJobs` call.
    /// Provide this token to retrieve the subsequent page of results. When
    /// paginating, all other parameters that are provided to the
    /// `ListMetadataJobs` request must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter request. Filters are case-sensitive.
    /// The service supports the following formats:
    ///
    /// * `labels.key1 = "value1"`
    /// * `labels:key1`
    /// * `name = "value"`
    ///
    /// You can combine filters with `AND`, `OR`, and `NOT` operators.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The field to sort the results by, either `name` or `create_time`.
    /// If not specified, the ordering is undefined.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// List metadata jobs response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetadataJobsResponse {
    /// Metadata jobs under the specified parent location.
    #[prost(message, repeated, tag = "1")]
    pub metadata_jobs: ::prost::alloc::vec::Vec<MetadataJob>,
    /// A token to retrieve the next page of results. If there are no more results
    /// in the list, the value is empty.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that the service couldn't reach.
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Cancel metadata job request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelMetadataJobRequest {
    /// Required. The resource name of the job, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}/metadataJobs/{metadata_job_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A metadata job resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataJob {
    /// Output only. Identifier. The name of the resource that the configuration is
    /// applied to, in the format
    /// `projects/{project_number}/locations/{location_id}/metadataJobs/{metadata_job_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. A system-generated, globally unique ID for the metadata job.
    /// If the metadata job is deleted and then re-created with the same name, this
    /// ID is different.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the metadata job was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the metadata job was updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. User-defined labels.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Metadata job type.
    #[prost(enumeration = "metadata_job::Type", tag = "6")]
    pub r#type: i32,
    /// Output only. Metadata job status.
    #[prost(message, optional, tag = "7")]
    pub status: ::core::option::Option<metadata_job::Status>,
    #[prost(oneof = "metadata_job::Spec", tags = "100")]
    pub spec: ::core::option::Option<metadata_job::Spec>,
    #[prost(oneof = "metadata_job::Result", tags = "200")]
    pub result: ::core::option::Option<metadata_job::Result>,
}
/// Nested message and enum types in `MetadataJob`.
pub mod metadata_job {
    /// Results from a metadata import job.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ImportJobResult {
        /// Output only. The total number of entries that were deleted.
        #[prost(int64, tag = "1")]
        pub deleted_entries: i64,
        /// Output only. The total number of entries that were updated.
        #[prost(int64, tag = "2")]
        pub updated_entries: i64,
        /// Output only. The total number of entries that were created.
        #[prost(int64, tag = "3")]
        pub created_entries: i64,
        /// Output only. The total number of entries that were unchanged.
        #[prost(int64, tag = "4")]
        pub unchanged_entries: i64,
        /// Output only. The total number of entries that were recreated.
        #[prost(int64, tag = "6")]
        pub recreated_entries: i64,
        /// Output only. The time when the status was updated.
        #[prost(message, optional, tag = "5")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Job specification for a metadata import job
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImportJobSpec {
        /// Optional. The URI of a Cloud Storage bucket or folder (beginning with
        /// `gs://` and ending with `/`) that contains the metadata import files for
        /// this job.
        ///
        /// A metadata import file defines the values to set for each of the entries
        /// and aspects in a metadata job. For more information about how to create a
        /// metadata import file and the file requirements, see [Metadata import
        /// file](<https://cloud.google.com/dataplex/docs/import-metadata#metadata-import-file>).
        ///
        /// You can provide multiple metadata import files in the same metadata job.
        /// The bucket or folder must contain at least one metadata import file, in
        /// JSON Lines format (either `.json` or `.jsonl` file extension).
        ///
        /// In `FULL` entry sync mode, don't save the metadata import file in a
        /// folder named `SOURCE_STORAGE_URI/deletions/`.
        ///
        /// **Caution**: If the metadata import file contains no data, all entries
        /// and aspects that belong to the job's scope are deleted.
        #[prost(string, tag = "1")]
        pub source_storage_uri: ::prost::alloc::string::String,
        /// Optional. The time when the process that created the metadata import
        /// files began.
        #[prost(message, optional, tag = "5")]
        pub source_create_time: ::core::option::Option<::prost_types::Timestamp>,
        /// Required. A boundary on the scope of impact that the metadata import job
        /// can have.
        #[prost(message, optional, tag = "2")]
        pub scope: ::core::option::Option<import_job_spec::ImportJobScope>,
        /// Required. The sync mode for entries.
        /// Only `FULL` mode is supported for entries. All entries in the job's scope
        /// are modified. If an entry exists in Dataplex but isn't included in the
        /// metadata import file, the entry is deleted when you run the metadata job.
        #[prost(enumeration = "import_job_spec::SyncMode", tag = "3")]
        pub entry_sync_mode: i32,
        /// Required. The sync mode for aspects.
        /// Only `INCREMENTAL` mode is supported for aspects. An aspect is modified
        /// only if the metadata import file includes a reference to the aspect in
        /// the `update_mask` field and the `aspect_keys` field.
        #[prost(enumeration = "import_job_spec::SyncMode", tag = "4")]
        pub aspect_sync_mode: i32,
        /// Optional. The level of logs to write to Cloud Logging for this job.
        ///
        /// Debug-level logs provide highly-detailed information for
        /// troubleshooting, but their increased verbosity could incur [additional
        /// costs](<https://cloud.google.com/stackdriver/pricing>) that might not be
        /// merited for all jobs.
        ///
        /// If unspecified, defaults to `INFO`.
        #[prost(enumeration = "import_job_spec::LogLevel", tag = "6")]
        pub log_level: i32,
    }
    /// Nested message and enum types in `ImportJobSpec`.
    pub mod import_job_spec {
        /// A boundary on the scope of impact that the metadata import job can have.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ImportJobScope {
            /// Required. The entry group that is in scope for the import job,
            /// specified as a relative resource name in the format
            /// `projects/{project_number_or_id}/locations/{location_id}/entryGroups/{entry_group_id}`.
            /// Only entries that belong to the specified entry group are affected by
            /// the job.
            ///
            /// Must contain exactly one element. The entry group and the job
            /// must be in the same location.
            #[prost(string, repeated, tag = "1")]
            pub entry_groups: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// Required. The entry types that are in scope for the import job,
            /// specified as relative resource names in the format
            /// `projects/{project_number_or_id}/locations/{location_id}/entryTypes/{entry_type_id}`.
            /// The job modifies only the entries that belong to these entry types.
            ///
            /// If the metadata import file attempts to modify an entry whose type
            /// isn't included in this list, the import job is halted before modifying
            /// any entries or aspects.
            ///
            /// The location of an entry type must either match the location of the
            /// job, or the entry type must be global.
            #[prost(string, repeated, tag = "2")]
            pub entry_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// Optional. The aspect types that are in scope for the import job,
            /// specified as relative resource names in the format
            /// `projects/{project_number_or_id}/locations/{location_id}/aspectTypes/{aspect_type_id}`.
            /// The job modifies only the aspects that belong to these aspect types.
            ///
            /// If the metadata import file attempts to modify an aspect whose type
            /// isn't included in this list, the import job is halted before modifying
            /// any entries or aspects.
            ///
            /// The location of an aspect type must either match the location of the
            /// job, or the aspect type must be global.
            #[prost(string, repeated, tag = "3")]
            pub aspect_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        /// Specifies how the entries and aspects in a metadata job are updated.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SyncMode {
            /// Sync mode unspecified.
            Unspecified = 0,
            /// All resources in the job's scope are modified. If a resource exists in
            /// Dataplex but isn't included in the metadata import file, the resource
            /// is deleted when you run the metadata job. Use this mode to perform a
            /// full sync of the set of entries in the job scope.
            Full = 1,
            /// Only the entries and aspects that are explicitly included in the
            /// metadata import file are modified. Use this mode to modify a subset of
            /// resources while leaving unreferenced resources unchanged.
            Incremental = 2,
        }
        impl SyncMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SYNC_MODE_UNSPECIFIED",
                    Self::Full => "FULL",
                    Self::Incremental => "INCREMENTAL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SYNC_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                    "FULL" => Some(Self::Full),
                    "INCREMENTAL" => Some(Self::Incremental),
                    _ => None,
                }
            }
        }
        /// The level of logs to write to Cloud Logging for this job.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum LogLevel {
            /// Log level unspecified.
            Unspecified = 0,
            /// Debug-level logging. Captures detailed logs for each import item. Use
            /// debug-level logging to troubleshoot issues with specific import items.
            /// For example, use debug-level logging to identify resources that are
            /// missing from the job scope, entries or aspects that don't conform to
            /// the associated entry type or aspect type, or other misconfigurations
            /// with the metadata import file.
            ///
            /// Depending on the size of your metadata job and the number of logs that
            /// are generated, debug-level logging might incur
            /// [additional costs](<https://cloud.google.com/stackdriver/pricing>).
            Debug = 1,
            /// Info-level logging. Captures logs at the overall job level. Includes
            /// aggregate logs about import items, but doesn't specify which import
            /// item has an error.
            Info = 2,
        }
        impl LogLevel {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "LOG_LEVEL_UNSPECIFIED",
                    Self::Debug => "DEBUG",
                    Self::Info => "INFO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "LOG_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
                    "DEBUG" => Some(Self::Debug),
                    "INFO" => Some(Self::Info),
                    _ => None,
                }
            }
        }
    }
    /// Metadata job status.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Status {
        /// Output only. State of the metadata job.
        #[prost(enumeration = "status::State", tag = "1")]
        pub state: i32,
        /// Output only. Message relating to the progression of a metadata job.
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
        /// Output only. Progress tracking.
        #[prost(int32, tag = "3")]
        pub completion_percent: i32,
        /// Output only. The time when the status was updated.
        #[prost(message, optional, tag = "4")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Nested message and enum types in `Status`.
    pub mod status {
        /// State of a metadata job.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            /// State unspecified.
            Unspecified = 0,
            /// The job is queued.
            Queued = 1,
            /// The job is running.
            Running = 2,
            /// The job is being canceled.
            Canceling = 3,
            /// The job is canceled.
            Canceled = 4,
            /// The job succeeded.
            Succeeded = 5,
            /// The job failed.
            Failed = 6,
            /// The job completed with some errors.
            SucceededWithErrors = 7,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Queued => "QUEUED",
                    Self::Running => "RUNNING",
                    Self::Canceling => "CANCELING",
                    Self::Canceled => "CANCELED",
                    Self::Succeeded => "SUCCEEDED",
                    Self::Failed => "FAILED",
                    Self::SucceededWithErrors => "SUCCEEDED_WITH_ERRORS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "QUEUED" => Some(Self::Queued),
                    "RUNNING" => Some(Self::Running),
                    "CANCELING" => Some(Self::Canceling),
                    "CANCELED" => Some(Self::Canceled),
                    "SUCCEEDED" => Some(Self::Succeeded),
                    "FAILED" => Some(Self::Failed),
                    "SUCCEEDED_WITH_ERRORS" => Some(Self::SucceededWithErrors),
                    _ => None,
                }
            }
        }
    }
    /// Metadata job type.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Unspecified.
        Unspecified = 0,
        /// Import job.
        Import = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Import => "IMPORT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "IMPORT" => Some(Self::Import),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Spec {
        /// Import job specification.
        #[prost(message, tag = "100")]
        ImportSpec(ImportJobSpec),
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Result {
        /// Output only. Import job result.
        #[prost(message, tag = "200")]
        ImportResult(ImportJobResult),
    }
}
/// View for controlling which parts of an entry are to be returned.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EntryView {
    /// Unspecified EntryView. Defaults to FULL.
    Unspecified = 0,
    /// Returns entry only, without aspects.
    Basic = 1,
    /// Returns all required aspects as well as the keys of all non-required
    /// aspects.
    Full = 2,
    /// Returns aspects matching custom fields in GetEntryRequest. If the number of
    /// aspects exceeds 100, the first 100 will be returned.
    Custom = 3,
    /// Returns all aspects. If the number of aspects exceeds 100, the first
    /// 100 will be returned.
    All = 4,
}
impl EntryView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENTRY_VIEW_UNSPECIFIED",
            Self::Basic => "BASIC",
            Self::Full => "FULL",
            Self::Custom => "CUSTOM",
            Self::All => "ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENTRY_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "BASIC" => Some(Self::Basic),
            "FULL" => Some(Self::Full),
            "CUSTOM" => Some(Self::Custom),
            "ALL" => Some(Self::All),
            _ => None,
        }
    }
}
/// Denotes the transfer status of a resource. It is unspecified for resources
/// created from Dataplex API.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransferStatus {
    /// The default value. It is set for resources that were not subject for
    /// migration from Data Catalog service.
    Unspecified = 0,
    /// Indicates that a resource was migrated from Data Catalog service but it
    /// hasn't been transferred yet. In particular the resource cannot be updated
    /// from Dataplex API.
    Migrated = 1,
    /// Indicates that a resource was transferred from Data Catalog service. The
    /// resource can only be updated from Dataplex API.
    Transferred = 2,
}
impl TransferStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TRANSFER_STATUS_UNSPECIFIED",
            Self::Migrated => "TRANSFER_STATUS_MIGRATED",
            Self::Transferred => "TRANSFER_STATUS_TRANSFERRED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSFER_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "TRANSFER_STATUS_MIGRATED" => Some(Self::Migrated),
            "TRANSFER_STATUS_TRANSFERRED" => Some(Self::Transferred),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod catalog_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The primary resources offered by this service are EntryGroups, EntryTypes,
    /// AspectTypes, and Entries. They collectively let data administrators organize,
    /// manage, secure, and catalog data located across cloud projects in their
    /// organization in a variety of storage systems, including Cloud Storage and
    /// BigQuery.
    #[derive(Debug, Clone)]
    pub struct CatalogServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CatalogServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CatalogServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CatalogServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CatalogServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates an EntryType.
        pub async fn create_entry_type(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEntryTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/CreateEntryType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "CreateEntryType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an EntryType.
        pub async fn update_entry_type(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEntryTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/UpdateEntryType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "UpdateEntryType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an EntryType.
        pub async fn delete_entry_type(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEntryTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/DeleteEntryType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "DeleteEntryType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists EntryType resources in a project and location.
        pub async fn list_entry_types(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEntryTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEntryTypesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/ListEntryTypes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "ListEntryTypes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an EntryType.
        pub async fn get_entry_type(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEntryTypeRequest>,
        ) -> std::result::Result<tonic::Response<super::EntryType>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/GetEntryType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "GetEntryType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an AspectType.
        pub async fn create_aspect_type(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAspectTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/CreateAspectType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "CreateAspectType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an AspectType.
        pub async fn update_aspect_type(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAspectTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/UpdateAspectType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "UpdateAspectType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an AspectType.
        pub async fn delete_aspect_type(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAspectTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/DeleteAspectType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "DeleteAspectType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists AspectType resources in a project and location.
        pub async fn list_aspect_types(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAspectTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAspectTypesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/ListAspectTypes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "ListAspectTypes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an AspectType.
        pub async fn get_aspect_type(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAspectTypeRequest>,
        ) -> std::result::Result<tonic::Response<super::AspectType>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/GetAspectType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "GetAspectType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an EntryGroup.
        pub async fn create_entry_group(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEntryGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/CreateEntryGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "CreateEntryGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an EntryGroup.
        pub async fn update_entry_group(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEntryGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/UpdateEntryGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "UpdateEntryGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an EntryGroup.
        pub async fn delete_entry_group(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEntryGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/DeleteEntryGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "DeleteEntryGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists EntryGroup resources in a project and location.
        pub async fn list_entry_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEntryGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEntryGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/ListEntryGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "ListEntryGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an EntryGroup.
        pub async fn get_entry_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEntryGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::EntryGroup>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/GetEntryGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "GetEntryGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an Entry.
        pub async fn create_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::Entry>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/CreateEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "CreateEntry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an Entry.
        pub async fn update_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::Entry>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/UpdateEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "UpdateEntry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an Entry.
        pub async fn delete_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::Entry>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/DeleteEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "DeleteEntry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Entries within an EntryGroup.
        pub async fn list_entries(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEntriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEntriesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/ListEntries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "ListEntries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an Entry.
        ///
        /// **Caution**: The BigQuery metadata that is stored in Dataplex Catalog is
        /// changing. For more information, see [Changes to BigQuery metadata stored in
        /// Dataplex
        /// Catalog](https://cloud.google.com/dataplex/docs/biqquery-metadata-changes).
        pub async fn get_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::Entry>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/GetEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "GetEntry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Looks up a single Entry by name using the permission on the source system.
        ///
        /// **Caution**: The BigQuery metadata that is stored in Dataplex Catalog is
        /// changing. For more information, see [Changes to BigQuery metadata stored in
        /// Dataplex
        /// Catalog](https://cloud.google.com/dataplex/docs/biqquery-metadata-changes).
        pub async fn lookup_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::Entry>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/LookupEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "LookupEntry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Searches for Entries matching the given query and scope.
        pub async fn search_entries(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchEntriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchEntriesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/SearchEntries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "SearchEntries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a metadata job. For example, use a metadata job to import Dataplex
        /// Catalog entries and aspects from a third-party system into Dataplex.
        pub async fn create_metadata_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateMetadataJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/CreateMetadataJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "CreateMetadataJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a metadata job.
        pub async fn get_metadata_job(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMetadataJobRequest>,
        ) -> std::result::Result<tonic::Response<super::MetadataJob>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/GetMetadataJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "GetMetadataJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists metadata jobs.
        pub async fn list_metadata_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMetadataJobsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMetadataJobsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/ListMetadataJobs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "ListMetadataJobs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Cancels a metadata job.
        ///
        /// If you cancel a metadata import job that is in progress, the changes in the
        /// job might be partially applied. We recommend that you reset the state of
        /// the entry groups in your project by running another metadata job that
        /// reverts the changes from the canceled job.
        pub async fn cancel_metadata_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelMetadataJobRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.CatalogService/CancelMetadataJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.CatalogService",
                        "CancelMetadataJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Create content request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateContentRequest {
    /// Required. The resource name of the parent lake:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Content resource.
    #[prost(message, optional, tag = "2")]
    pub content: ::core::option::Option<Content>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Update content request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateContentRequest {
    /// Required. Mask of fields to update.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    #[prost(message, optional, tag = "2")]
    pub content: ::core::option::Option<Content>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Delete content request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteContentRequest {
    /// Required. The resource name of the content:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}/content/{content_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// List content request. Returns the BASIC Content view.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContentRequest {
    /// Required. The resource name of the parent lake:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of content to return. The service may return fewer
    /// than this value. If unspecified, at most 10 content will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListContent` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListContent` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter request. Filters are case-sensitive.
    /// The following formats are supported:
    ///
    /// labels.key1 = "value1"
    /// labels:key1
    /// type = "NOTEBOOK"
    /// type = "SQL_SCRIPT"
    ///
    /// These restrictions can be coinjoined with AND, OR and NOT conjunctions.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// List content response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContentResponse {
    /// Content under the given parent lake.
    #[prost(message, repeated, tag = "1")]
    pub content: ::prost::alloc::vec::Vec<Content>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Get content request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetContentRequest {
    /// Required. The resource name of the content:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}/content/{content_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Specify content view to make a partial request.
    #[prost(enumeration = "get_content_request::ContentView", tag = "2")]
    pub view: i32,
}
/// Nested message and enum types in `GetContentRequest`.
pub mod get_content_request {
    /// Specifies whether the request should return the full or the partial
    /// representation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContentView {
        /// Content view not specified. Defaults to BASIC.
        /// The API will default to the BASIC view.
        Unspecified = 0,
        /// Will not return the `data_text` field.
        Basic = 1,
        /// Returns the complete proto.
        Full = 2,
    }
    impl ContentView {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CONTENT_VIEW_UNSPECIFIED",
                Self::Basic => "BASIC",
                Self::Full => "FULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONTENT_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
                "BASIC" => Some(Self::Basic),
                "FULL" => Some(Self::Full),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod content_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// ContentService manages Notebook and SQL Scripts for Dataplex.
    #[derive(Debug, Clone)]
    pub struct ContentServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ContentServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ContentServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ContentServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ContentServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a content.
        pub async fn create_content(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateContentRequest>,
        ) -> std::result::Result<tonic::Response<super::Content>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.ContentService/CreateContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.ContentService",
                        "CreateContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a content. Only supports full resource update.
        pub async fn update_content(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateContentRequest>,
        ) -> std::result::Result<tonic::Response<super::Content>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.ContentService/UpdateContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.ContentService",
                        "UpdateContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a content.
        pub async fn delete_content(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteContentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.ContentService/DeleteContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.ContentService",
                        "DeleteContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a content resource.
        pub async fn get_content(
            &mut self,
            request: impl tonic::IntoRequest<super::GetContentRequest>,
        ) -> std::result::Result<tonic::Response<super::Content>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.ContentService/GetContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.ContentService",
                        "GetContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a contentitem resource. A `NOT_FOUND`
        /// error is returned if the resource does not exist. An empty policy is
        /// returned if the resource exists but does not have a policy set on it.
        ///
        /// Caller must have Google IAM `dataplex.content.getIamPolicy` permission
        /// on the resource.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::GetIamPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::iam::v1::Policy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.ContentService/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.ContentService",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified contentitem resource.
        /// Replaces any existing policy.
        ///
        /// Caller must have Google IAM `dataplex.content.setIamPolicy` permission
        /// on the resource.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::SetIamPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::iam::v1::Policy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.ContentService/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.ContentService",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the caller's permissions on a resource.
        /// If the resource does not exist, an empty set of
        /// permissions is returned (a `NOT_FOUND` error is not returned).
        ///
        /// A caller is not required to have Google IAM permission to make this
        /// request.
        ///
        /// Note: This operation is designed to be used for building permission-aware
        /// UIs and command-line tools, not for authorization checking. This operation
        /// may "fail open" without warning.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::TestIamPermissionsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::super::super::super::iam::v1::TestIamPermissionsResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.ContentService/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.ContentService",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List content.
        pub async fn list_content(
            &mut self,
            request: impl tonic::IntoRequest<super::ListContentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListContentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.ContentService/ListContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.ContentService",
                        "ListContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Spec for a data discovery scan.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataDiscoverySpec {
    /// Optional. Configuration for metadata publishing.
    #[prost(message, optional, tag = "1")]
    pub bigquery_publishing_config: ::core::option::Option<
        data_discovery_spec::BigQueryPublishingConfig,
    >,
    /// The configurations of the data discovery scan resource.
    #[prost(oneof = "data_discovery_spec::ResourceConfig", tags = "100")]
    pub resource_config: ::core::option::Option<data_discovery_spec::ResourceConfig>,
}
/// Nested message and enum types in `DataDiscoverySpec`.
pub mod data_discovery_spec {
    /// Describes BigQuery publishing configurations.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BigQueryPublishingConfig {
        /// Optional. Determines whether to  publish discovered tables as BigLake
        /// external tables or non-BigLake external tables.
        #[prost(enumeration = "big_query_publishing_config::TableType", tag = "2")]
        pub table_type: i32,
        /// Optional. The BigQuery connection used to create BigLake tables.
        /// Must be in the form
        /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
        #[prost(string, tag = "3")]
        pub connection: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `BigQueryPublishingConfig`.
    pub mod big_query_publishing_config {
        /// Determines how discovered tables are published.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum TableType {
            /// Table type unspecified.
            Unspecified = 0,
            /// Default. Discovered tables are published as BigQuery external tables
            /// whose data is accessed using the credentials of the user querying the
            /// table.
            External = 1,
            /// Discovered tables are published as BigLake external tables whose data
            /// is accessed using the credentials of the associated BigQuery
            /// connection.
            Biglake = 2,
        }
        impl TableType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TABLE_TYPE_UNSPECIFIED",
                    Self::External => "EXTERNAL",
                    Self::Biglake => "BIGLAKE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TABLE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "EXTERNAL" => Some(Self::External),
                    "BIGLAKE" => Some(Self::Biglake),
                    _ => None,
                }
            }
        }
    }
    /// Configurations related to Cloud Storage as the data source.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StorageConfig {
        /// Optional. Defines the data to include during discovery when only a subset
        /// of the data should be considered. Provide a list of patterns that
        /// identify the data to include. For Cloud Storage bucket assets, these
        /// patterns are interpreted as glob patterns used to match object names. For
        /// BigQuery dataset assets, these patterns are interpreted as patterns to
        /// match table names.
        #[prost(string, repeated, tag = "1")]
        pub include_patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. Defines the data to exclude during discovery. Provide a list of
        /// patterns that identify the data to exclude. For Cloud Storage bucket
        /// assets, these patterns are interpreted as glob patterns used to match
        /// object names. For BigQuery dataset assets, these patterns are interpreted
        /// as patterns to match table names.
        #[prost(string, repeated, tag = "2")]
        pub exclude_patterns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Optional. Configuration for CSV data.
        #[prost(message, optional, tag = "3")]
        pub csv_options: ::core::option::Option<storage_config::CsvOptions>,
        /// Optional. Configuration for JSON data.
        #[prost(message, optional, tag = "4")]
        pub json_options: ::core::option::Option<storage_config::JsonOptions>,
    }
    /// Nested message and enum types in `StorageConfig`.
    pub mod storage_config {
        /// Describes CSV and similar semi-structured data formats.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CsvOptions {
            /// Optional. The number of rows to interpret as header rows that should be
            /// skipped when reading data rows.
            #[prost(int32, tag = "1")]
            pub header_rows: i32,
            /// Optional. The delimiter that is used to separate values. The default is
            /// `,` (comma).
            #[prost(string, tag = "2")]
            pub delimiter: ::prost::alloc::string::String,
            /// Optional. The character encoding of the data. The default is UTF-8.
            #[prost(string, tag = "3")]
            pub encoding: ::prost::alloc::string::String,
            /// Optional. Whether to disable the inference of data types for CSV data.
            /// If true, all columns are registered as strings.
            #[prost(bool, tag = "4")]
            pub type_inference_disabled: bool,
            /// Optional. The character used to quote column values. Accepts `"`
            /// (double quotation mark) or `'` (single quotation mark). If unspecified,
            /// defaults to `"` (double quotation mark).
            #[prost(string, tag = "5")]
            pub quote: ::prost::alloc::string::String,
        }
        /// Describes JSON data format.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct JsonOptions {
            /// Optional. The character encoding of the data. The default is UTF-8.
            #[prost(string, tag = "1")]
            pub encoding: ::prost::alloc::string::String,
            /// Optional. Whether to disable the inference of data types for JSON data.
            /// If true, all columns are registered as their primitive types
            /// (strings, number, or boolean).
            #[prost(bool, tag = "2")]
            pub type_inference_disabled: bool,
        }
    }
    /// The configurations of the data discovery scan resource.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResourceConfig {
        /// Cloud Storage related configurations.
        #[prost(message, tag = "100")]
        StorageConfig(StorageConfig),
    }
}
/// The output of a data discovery scan.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataDiscoveryResult {
    /// Output only. Configuration for metadata publishing.
    #[prost(message, optional, tag = "1")]
    pub bigquery_publishing: ::core::option::Option<
        data_discovery_result::BigQueryPublishing,
    >,
}
/// Nested message and enum types in `DataDiscoveryResult`.
pub mod data_discovery_result {
    /// Describes BigQuery publishing configurations.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BigQueryPublishing {
        /// Output only. The BigQuery dataset to publish to. It takes the form
        /// `projects/{project_id}/datasets/{dataset_id}`.
        /// If not set, the service creates a default publishing dataset.
        #[prost(string, tag = "1")]
        pub dataset: ::prost::alloc::string::String,
    }
}
/// DataScan scheduling and trigger settings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trigger {
    /// DataScan scheduling and trigger settings.
    ///
    /// If not specified, the default is `onDemand`.
    #[prost(oneof = "trigger::Mode", tags = "100, 101")]
    pub mode: ::core::option::Option<trigger::Mode>,
}
/// Nested message and enum types in `Trigger`.
pub mod trigger {
    /// The scan runs once via `RunDataScan` API.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct OnDemand {}
    /// The scan is scheduled to run periodically.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Schedule {
        /// Required. [Cron](<https://en.wikipedia.org/wiki/Cron>) schedule for running
        /// scans periodically.
        ///
        /// To explicitly set a timezone in the cron tab, apply a prefix in the
        /// cron tab: **"CRON_TZ=${IANA_TIME_ZONE}"** or **"TZ=${IANA_TIME_ZONE}"**.
        /// The **${IANA_TIME_ZONE}** may only be a valid string from IANA time zone
        /// database
        /// ([wikipedia](<https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>)).
        /// For example, `CRON_TZ=America/New_York 1 * * * *`, or
        /// `TZ=America/New_York 1 * * * *`.
        ///
        /// This field is required for Schedule scans.
        #[prost(string, tag = "1")]
        pub cron: ::prost::alloc::string::String,
    }
    /// DataScan scheduling and trigger settings.
    ///
    /// If not specified, the default is `onDemand`.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Mode {
        /// The scan runs once via `RunDataScan` API.
        #[prost(message, tag = "100")]
        OnDemand(OnDemand),
        /// The scan is scheduled to run periodically.
        #[prost(message, tag = "101")]
        Schedule(Schedule),
    }
}
/// The data source for DataScan.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataSource {
    /// The source is required and immutable. Once it is set, it cannot be change
    /// to others.
    #[prost(oneof = "data_source::Source", tags = "100, 101")]
    pub source: ::core::option::Option<data_source::Source>,
}
/// Nested message and enum types in `DataSource`.
pub mod data_source {
    /// The source is required and immutable. Once it is set, it cannot be change
    /// to others.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// Immutable. The Dataplex entity that represents the data source (e.g.
        /// BigQuery table) for DataScan, of the form:
        /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}`.
        #[prost(string, tag = "100")]
        Entity(::prost::alloc::string::String),
        /// Immutable. The service-qualified full resource name of the cloud resource
        /// for a DataScan job to scan against. The field could be: BigQuery table of
        /// type "TABLE" for DataProfileScan/DataQualityScan Format:
        /// //bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        #[prost(string, tag = "101")]
        Resource(::prost::alloc::string::String),
    }
}
/// The data scanned during processing (e.g. in incremental DataScan)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScannedData {
    /// The range of scanned data
    #[prost(oneof = "scanned_data::DataRange", tags = "1")]
    pub data_range: ::core::option::Option<scanned_data::DataRange>,
}
/// Nested message and enum types in `ScannedData`.
pub mod scanned_data {
    /// A data range denoted by a pair of start/end values of a field.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IncrementalField {
        /// The field that contains values which monotonically increases over time
        /// (e.g. a timestamp column).
        #[prost(string, tag = "1")]
        pub field: ::prost::alloc::string::String,
        /// Value that marks the start of the range.
        #[prost(string, tag = "2")]
        pub start: ::prost::alloc::string::String,
        /// Value that marks the end of the range.
        #[prost(string, tag = "3")]
        pub end: ::prost::alloc::string::String,
    }
    /// The range of scanned data
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DataRange {
        /// The range denoted by values of an incremental field
        #[prost(message, tag = "1")]
        IncrementalField(IncrementalField),
    }
}
/// DataProfileScan related setting.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataProfileSpec {
    /// Optional. The percentage of the records to be selected from the dataset for
    /// DataScan.
    ///
    /// * Value can range between 0.0 and 100.0 with up to 3 significant decimal
    /// digits.
    /// * Sampling is not applied if `sampling_percent` is not specified, 0 or
    /// 100.
    #[prost(float, tag = "2")]
    pub sampling_percent: f32,
    /// Optional. A filter applied to all rows in a single DataScan job.
    /// The filter needs to be a valid SQL expression for a WHERE clause in
    /// BigQuery standard SQL syntax.
    /// Example: col1 >= 0 AND col2 < 10
    #[prost(string, tag = "3")]
    pub row_filter: ::prost::alloc::string::String,
    /// Optional. Actions to take upon job completion..
    #[prost(message, optional, tag = "4")]
    pub post_scan_actions: ::core::option::Option<data_profile_spec::PostScanActions>,
    /// Optional. The fields to include in data profile.
    ///
    /// If not specified, all fields at the time of profile scan job execution are
    /// included, except for ones listed in `exclude_fields`.
    #[prost(message, optional, tag = "5")]
    pub include_fields: ::core::option::Option<data_profile_spec::SelectedFields>,
    /// Optional. The fields to exclude from data profile.
    ///
    /// If specified, the fields will be excluded from data profile, regardless of
    /// `include_fields` value.
    #[prost(message, optional, tag = "6")]
    pub exclude_fields: ::core::option::Option<data_profile_spec::SelectedFields>,
}
/// Nested message and enum types in `DataProfileSpec`.
pub mod data_profile_spec {
    /// The configuration of post scan actions of DataProfileScan job.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PostScanActions {
        /// Optional. If set, results will be exported to the provided BigQuery
        /// table.
        #[prost(message, optional, tag = "1")]
        pub bigquery_export: ::core::option::Option<post_scan_actions::BigQueryExport>,
    }
    /// Nested message and enum types in `PostScanActions`.
    pub mod post_scan_actions {
        /// The configuration of BigQuery export post scan action.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BigQueryExport {
            /// Optional. The BigQuery table to export DataProfileScan results to.
            /// Format:
            /// //bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
            #[prost(string, tag = "1")]
            pub results_table: ::prost::alloc::string::String,
        }
    }
    /// The specification for fields to include or exclude in data profile scan.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SelectedFields {
        /// Optional. Expected input is a list of fully qualified names of fields as
        /// in the schema.
        ///
        /// Only top-level field names for nested fields are supported.
        /// For instance, if 'x' is of nested field type, listing 'x' is supported
        /// but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of
        /// 'x'.
        #[prost(string, repeated, tag = "1")]
        pub field_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
/// DataProfileResult defines the output of DataProfileScan. Each field of the
/// table will have field type specific profile result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataProfileResult {
    /// The count of rows scanned.
    #[prost(int64, tag = "3")]
    pub row_count: i64,
    /// The profile information per field.
    #[prost(message, optional, tag = "4")]
    pub profile: ::core::option::Option<data_profile_result::Profile>,
    /// The data scanned for this result.
    #[prost(message, optional, tag = "5")]
    pub scanned_data: ::core::option::Option<ScannedData>,
    /// Output only. The result of post scan actions.
    #[prost(message, optional, tag = "6")]
    pub post_scan_actions_result: ::core::option::Option<
        data_profile_result::PostScanActionsResult,
    >,
}
/// Nested message and enum types in `DataProfileResult`.
pub mod data_profile_result {
    /// Contains name, type, mode and field type specific profile information.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Profile {
        /// List of fields with structural and profile information for each field.
        #[prost(message, repeated, tag = "2")]
        pub fields: ::prost::alloc::vec::Vec<profile::Field>,
    }
    /// Nested message and enum types in `Profile`.
    pub mod profile {
        /// A field within a table.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Field {
            /// The name of the field.
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            /// The data type retrieved from the schema of the data source. For
            /// instance, for a BigQuery native table, it is the [BigQuery Table
            /// Schema](<https://cloud.google.com/bigquery/docs/reference/rest/v2/tables#tablefieldschema>).
            /// For a Dataplex Entity, it is the [Entity
            /// Schema](<https://cloud.google.com/dataplex/docs/reference/rpc/google.cloud.dataplex.v1#type_3>).
            #[prost(string, tag = "2")]
            pub r#type: ::prost::alloc::string::String,
            /// The mode of the field. Possible values include:
            ///
            /// * REQUIRED, if it is a required field.
            /// * NULLABLE, if it is an optional field.
            /// * REPEATED, if it is a repeated field.
            #[prost(string, tag = "3")]
            pub mode: ::prost::alloc::string::String,
            /// Profile information for the corresponding field.
            #[prost(message, optional, tag = "4")]
            pub profile: ::core::option::Option<field::ProfileInfo>,
        }
        /// Nested message and enum types in `Field`.
        pub mod field {
            /// The profile information for each field type.
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ProfileInfo {
                /// Ratio of rows with null value against total scanned rows.
                #[prost(double, tag = "2")]
                pub null_ratio: f64,
                /// Ratio of rows with distinct values against total scanned rows.
                /// Not available for complex non-groupable field type, including RECORD,
                /// ARRAY, GEOGRAPHY, and JSON, as well as fields with REPEATABLE mode.
                #[prost(double, tag = "3")]
                pub distinct_ratio: f64,
                /// The list of top N non-null values, frequency and ratio with which
                /// they occur in the scanned data. N is 10 or equal to the number of
                /// distinct values in the field, whichever is smaller. Not available for
                /// complex non-groupable field type, including RECORD, ARRAY, GEOGRAPHY,
                /// and JSON, as well as fields with REPEATABLE mode.
                #[prost(message, repeated, tag = "4")]
                pub top_n_values: ::prost::alloc::vec::Vec<profile_info::TopNValue>,
                /// Structural and profile information for specific field type. Not
                /// available, if mode is REPEATABLE.
                #[prost(oneof = "profile_info::FieldInfo", tags = "101, 102, 103")]
                pub field_info: ::core::option::Option<profile_info::FieldInfo>,
            }
            /// Nested message and enum types in `ProfileInfo`.
            pub mod profile_info {
                /// The profile information for a string type field.
                #[derive(Clone, Copy, PartialEq, ::prost::Message)]
                pub struct StringFieldInfo {
                    /// Minimum length of non-null values in the scanned data.
                    #[prost(int64, tag = "1")]
                    pub min_length: i64,
                    /// Maximum length of non-null values in the scanned data.
                    #[prost(int64, tag = "2")]
                    pub max_length: i64,
                    /// Average length of non-null values in the scanned data.
                    #[prost(double, tag = "3")]
                    pub average_length: f64,
                }
                /// The profile information for an integer type field.
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct IntegerFieldInfo {
                    /// Average of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[prost(double, tag = "1")]
                    pub average: f64,
                    /// Standard deviation of non-null values in the scanned data. NaN, if
                    /// the field has a NaN.
                    #[prost(double, tag = "3")]
                    pub standard_deviation: f64,
                    /// Minimum of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[prost(int64, tag = "4")]
                    pub min: i64,
                    /// A quartile divides the number of data points into four parts, or
                    /// quarters, of more-or-less equal size. Three main quartiles used
                    /// are: The first quartile (Q1) splits off the lowest 25% of data from
                    /// the highest 75%. It is also known as the lower or 25th empirical
                    /// quartile, as 25% of the data is below this point. The second
                    /// quartile (Q2) is the median of a data set. So, 50% of the data lies
                    /// below this point. The third quartile (Q3) splits off the highest
                    /// 25% of data from the lowest 75%. It is known as the upper or 75th
                    /// empirical quartile, as 75% of the data lies below this point.
                    /// Here, the quartiles is provided as an ordered list of approximate
                    /// quartile values for the scanned data, occurring in order Q1,
                    /// median, Q3.
                    #[prost(int64, repeated, tag = "6")]
                    pub quartiles: ::prost::alloc::vec::Vec<i64>,
                    /// Maximum of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[prost(int64, tag = "5")]
                    pub max: i64,
                }
                /// The profile information for a double type field.
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct DoubleFieldInfo {
                    /// Average of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[prost(double, tag = "1")]
                    pub average: f64,
                    /// Standard deviation of non-null values in the scanned data. NaN, if
                    /// the field has a NaN.
                    #[prost(double, tag = "3")]
                    pub standard_deviation: f64,
                    /// Minimum of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[prost(double, tag = "4")]
                    pub min: f64,
                    /// A quartile divides the number of data points into four parts, or
                    /// quarters, of more-or-less equal size. Three main quartiles used
                    /// are: The first quartile (Q1) splits off the lowest 25% of data from
                    /// the highest 75%. It is also known as the lower or 25th empirical
                    /// quartile, as 25% of the data is below this point. The second
                    /// quartile (Q2) is the median of a data set. So, 50% of the data lies
                    /// below this point. The third quartile (Q3) splits off the highest
                    /// 25% of data from the lowest 75%. It is known as the upper or 75th
                    /// empirical quartile, as 75% of the data lies below this point.
                    /// Here, the quartiles is provided as an ordered list of quartile
                    /// values for the scanned data, occurring in order Q1, median, Q3.
                    #[prost(double, repeated, tag = "6")]
                    pub quartiles: ::prost::alloc::vec::Vec<f64>,
                    /// Maximum of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[prost(double, tag = "5")]
                    pub max: f64,
                }
                /// Top N non-null values in the scanned data.
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct TopNValue {
                    /// String value of a top N non-null value.
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                    /// Count of the corresponding value in the scanned data.
                    #[prost(int64, tag = "2")]
                    pub count: i64,
                    /// Ratio of the corresponding value in the field against the total
                    /// number of rows in the scanned data.
                    #[prost(double, tag = "3")]
                    pub ratio: f64,
                }
                /// Structural and profile information for specific field type. Not
                /// available, if mode is REPEATABLE.
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum FieldInfo {
                    /// String type field information.
                    #[prost(message, tag = "101")]
                    StringProfile(StringFieldInfo),
                    /// Integer type field information.
                    #[prost(message, tag = "102")]
                    IntegerProfile(IntegerFieldInfo),
                    /// Double type field information.
                    #[prost(message, tag = "103")]
                    DoubleProfile(DoubleFieldInfo),
                }
            }
        }
    }
    /// The result of post scan actions of DataProfileScan job.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PostScanActionsResult {
        /// Output only. The result of BigQuery export post scan action.
        #[prost(message, optional, tag = "1")]
        pub bigquery_export_result: ::core::option::Option<
            post_scan_actions_result::BigQueryExportResult,
        >,
    }
    /// Nested message and enum types in `PostScanActionsResult`.
    pub mod post_scan_actions_result {
        /// The result of BigQuery export post scan action.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BigQueryExportResult {
            /// Output only. Execution state for the BigQuery exporting.
            #[prost(enumeration = "big_query_export_result::State", tag = "1")]
            pub state: i32,
            /// Output only. Additional information about the BigQuery exporting.
            #[prost(string, tag = "2")]
            pub message: ::prost::alloc::string::String,
        }
        /// Nested message and enum types in `BigQueryExportResult`.
        pub mod big_query_export_result {
            /// Execution state for the exporting.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum State {
                /// The exporting state is unspecified.
                Unspecified = 0,
                /// The exporting completed successfully.
                Succeeded = 1,
                /// The exporting is no longer running due to an error.
                Failed = 2,
                /// The exporting is skipped due to no valid scan result to export
                /// (usually caused by scan failed).
                Skipped = 3,
            }
            impl State {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "STATE_UNSPECIFIED",
                        Self::Succeeded => "SUCCEEDED",
                        Self::Failed => "FAILED",
                        Self::Skipped => "SKIPPED",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                        "SUCCEEDED" => Some(Self::Succeeded),
                        "FAILED" => Some(Self::Failed),
                        "SKIPPED" => Some(Self::Skipped),
                        _ => None,
                    }
                }
            }
        }
    }
}
/// DataQualityScan related setting.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualitySpec {
    /// Required. The list of rules to evaluate against a data source. At least one
    /// rule is required.
    #[prost(message, repeated, tag = "1")]
    pub rules: ::prost::alloc::vec::Vec<DataQualityRule>,
    /// Optional. The percentage of the records to be selected from the dataset for
    /// DataScan.
    ///
    /// * Value can range between 0.0 and 100.0 with up to 3 significant decimal
    /// digits.
    /// * Sampling is not applied if `sampling_percent` is not specified, 0 or
    /// 100.
    #[prost(float, tag = "4")]
    pub sampling_percent: f32,
    /// Optional. A filter applied to all rows in a single DataScan job.
    /// The filter needs to be a valid SQL expression for a WHERE clause in
    /// BigQuery standard SQL syntax.
    /// Example: col1 >= 0 AND col2 < 10
    #[prost(string, tag = "5")]
    pub row_filter: ::prost::alloc::string::String,
    /// Optional. Actions to take upon job completion.
    #[prost(message, optional, tag = "6")]
    pub post_scan_actions: ::core::option::Option<data_quality_spec::PostScanActions>,
}
/// Nested message and enum types in `DataQualitySpec`.
pub mod data_quality_spec {
    /// The configuration of post scan actions of DataQualityScan.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PostScanActions {
        /// Optional. If set, results will be exported to the provided BigQuery
        /// table.
        #[prost(message, optional, tag = "1")]
        pub bigquery_export: ::core::option::Option<post_scan_actions::BigQueryExport>,
        /// Optional. If set, results will be sent to the provided notification
        /// receipts upon triggers.
        #[prost(message, optional, tag = "2")]
        pub notification_report: ::core::option::Option<
            post_scan_actions::NotificationReport,
        >,
    }
    /// Nested message and enum types in `PostScanActions`.
    pub mod post_scan_actions {
        /// The configuration of BigQuery export post scan action.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BigQueryExport {
            /// Optional. The BigQuery table to export DataQualityScan results to.
            /// Format:
            /// //bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
            #[prost(string, tag = "1")]
            pub results_table: ::prost::alloc::string::String,
        }
        /// The individuals or groups who are designated to receive notifications
        /// upon triggers.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Recipients {
            /// Optional. The email recipients who will receive the DataQualityScan
            /// results report.
            #[prost(string, repeated, tag = "1")]
            pub emails: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        /// This trigger is triggered when the DQ score in the job result is less
        /// than a specified input score.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ScoreThresholdTrigger {
            /// Optional. The score range is in \[0,100\].
            #[prost(float, tag = "2")]
            pub score_threshold: f32,
        }
        /// This trigger is triggered when the scan job itself fails, regardless of
        /// the result.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct JobFailureTrigger {}
        /// This trigger is triggered whenever a scan job run ends, regardless
        /// of the result.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct JobEndTrigger {}
        /// The configuration of notification report post scan action.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct NotificationReport {
            /// Required. The recipients who will receive the notification report.
            #[prost(message, optional, tag = "1")]
            pub recipients: ::core::option::Option<Recipients>,
            /// Optional. If set, report will be sent when score threshold is met.
            #[prost(message, optional, tag = "2")]
            pub score_threshold_trigger: ::core::option::Option<ScoreThresholdTrigger>,
            /// Optional. If set, report will be sent when a scan job fails.
            #[prost(message, optional, tag = "4")]
            pub job_failure_trigger: ::core::option::Option<JobFailureTrigger>,
            /// Optional. If set, report will be sent when a scan job ends.
            #[prost(message, optional, tag = "5")]
            pub job_end_trigger: ::core::option::Option<JobEndTrigger>,
        }
    }
}
/// The output of a DataQualityScan.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityResult {
    /// Overall data quality result -- `true` if all rules passed.
    #[prost(bool, tag = "5")]
    pub passed: bool,
    /// Output only. The overall data quality score.
    ///
    /// The score ranges between \[0, 100\] (up to two decimal points).
    #[prost(float, optional, tag = "9")]
    pub score: ::core::option::Option<f32>,
    /// A list of results at the dimension level.
    ///
    /// A dimension will have a corresponding `DataQualityDimensionResult` if and
    /// only if there is at least one rule with the 'dimension' field set to it.
    #[prost(message, repeated, tag = "2")]
    pub dimensions: ::prost::alloc::vec::Vec<DataQualityDimensionResult>,
    /// Output only. A list of results at the column level.
    ///
    /// A column will have a corresponding `DataQualityColumnResult` if and only if
    /// there is at least one rule with the 'column' field set to it.
    #[prost(message, repeated, tag = "10")]
    pub columns: ::prost::alloc::vec::Vec<DataQualityColumnResult>,
    /// A list of all the rules in a job, and their results.
    #[prost(message, repeated, tag = "3")]
    pub rules: ::prost::alloc::vec::Vec<DataQualityRuleResult>,
    /// The count of rows processed.
    #[prost(int64, tag = "4")]
    pub row_count: i64,
    /// The data scanned for this result.
    #[prost(message, optional, tag = "7")]
    pub scanned_data: ::core::option::Option<ScannedData>,
    /// Output only. The result of post scan actions.
    #[prost(message, optional, tag = "8")]
    pub post_scan_actions_result: ::core::option::Option<
        data_quality_result::PostScanActionsResult,
    >,
}
/// Nested message and enum types in `DataQualityResult`.
pub mod data_quality_result {
    /// The result of post scan actions of DataQualityScan job.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PostScanActionsResult {
        /// Output only. The result of BigQuery export post scan action.
        #[prost(message, optional, tag = "1")]
        pub bigquery_export_result: ::core::option::Option<
            post_scan_actions_result::BigQueryExportResult,
        >,
    }
    /// Nested message and enum types in `PostScanActionsResult`.
    pub mod post_scan_actions_result {
        /// The result of BigQuery export post scan action.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BigQueryExportResult {
            /// Output only. Execution state for the BigQuery exporting.
            #[prost(enumeration = "big_query_export_result::State", tag = "1")]
            pub state: i32,
            /// Output only. Additional information about the BigQuery exporting.
            #[prost(string, tag = "2")]
            pub message: ::prost::alloc::string::String,
        }
        /// Nested message and enum types in `BigQueryExportResult`.
        pub mod big_query_export_result {
            /// Execution state for the exporting.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum State {
                /// The exporting state is unspecified.
                Unspecified = 0,
                /// The exporting completed successfully.
                Succeeded = 1,
                /// The exporting is no longer running due to an error.
                Failed = 2,
                /// The exporting is skipped due to no valid scan result to export
                /// (usually caused by scan failed).
                Skipped = 3,
            }
            impl State {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "STATE_UNSPECIFIED",
                        Self::Succeeded => "SUCCEEDED",
                        Self::Failed => "FAILED",
                        Self::Skipped => "SKIPPED",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                        "SUCCEEDED" => Some(Self::Succeeded),
                        "FAILED" => Some(Self::Failed),
                        "SKIPPED" => Some(Self::Skipped),
                        _ => None,
                    }
                }
            }
        }
    }
}
/// DataQualityRuleResult provides a more detailed, per-rule view of the results.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityRuleResult {
    /// The rule specified in the DataQualitySpec, as is.
    #[prost(message, optional, tag = "1")]
    pub rule: ::core::option::Option<DataQualityRule>,
    /// Whether the rule passed or failed.
    #[prost(bool, tag = "7")]
    pub passed: bool,
    /// The number of rows a rule was evaluated against.
    ///
    /// This field is only valid for row-level type rules.
    ///
    /// Evaluated count can be configured to either
    ///
    /// * include all rows (default) - with `null` rows automatically failing rule
    /// evaluation, or
    /// * exclude `null` rows from the `evaluated_count`, by setting
    /// `ignore_nulls = true`.
    #[prost(int64, tag = "9")]
    pub evaluated_count: i64,
    /// The number of rows which passed a rule evaluation.
    ///
    /// This field is only valid for row-level type rules.
    #[prost(int64, tag = "8")]
    pub passed_count: i64,
    /// The number of rows with null values in the specified column.
    #[prost(int64, tag = "5")]
    pub null_count: i64,
    /// The ratio of **passed_count / evaluated_count**.
    ///
    /// This field is only valid for row-level type rules.
    #[prost(double, tag = "6")]
    pub pass_ratio: f64,
    /// The query to find rows that did not pass this rule.
    ///
    /// This field is only valid for row-level type rules.
    #[prost(string, tag = "10")]
    pub failing_rows_query: ::prost::alloc::string::String,
    /// Output only. The number of rows returned by the SQL statement in a SQL
    /// assertion rule.
    ///
    /// This field is only valid for SQL assertion rules.
    #[prost(int64, tag = "11")]
    pub assertion_row_count: i64,
}
/// DataQualityDimensionResult provides a more detailed, per-dimension view of
/// the results.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityDimensionResult {
    /// Output only. The dimension config specified in the DataQualitySpec, as is.
    #[prost(message, optional, tag = "1")]
    pub dimension: ::core::option::Option<DataQualityDimension>,
    /// Whether the dimension passed or failed.
    #[prost(bool, tag = "3")]
    pub passed: bool,
    /// Output only. The dimension-level data quality score for this data scan job
    /// if and only if the 'dimension' field is set.
    ///
    /// The score ranges between \[0, 100\] (up to two decimal
    /// points).
    #[prost(float, optional, tag = "4")]
    pub score: ::core::option::Option<f32>,
}
/// A dimension captures data quality intent about a defined subset of the rules
/// specified.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityDimension {
    /// The dimension name a rule belongs to. Supported dimensions are
    /// ["COMPLETENESS", "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS",
    /// "FRESHNESS", "VOLUME"]
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A rule captures data quality intent about a data source.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityRule {
    /// Optional. The unnested column which this rule is evaluated against.
    #[prost(string, tag = "500")]
    pub column: ::prost::alloc::string::String,
    /// Optional. Rows with `null` values will automatically fail a rule, unless
    /// `ignore_null` is `true`. In that case, such `null` rows are trivially
    /// considered passing.
    ///
    /// This field is only valid for the following type of rules:
    ///
    /// * RangeExpectation
    /// * RegexExpectation
    /// * SetExpectation
    /// * UniquenessExpectation
    #[prost(bool, tag = "501")]
    pub ignore_null: bool,
    /// Required. The dimension a rule belongs to. Results are also aggregated at
    /// the dimension level. Supported dimensions are **["COMPLETENESS",
    /// "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "FRESHNESS",
    /// "VOLUME"]**
    #[prost(string, tag = "502")]
    pub dimension: ::prost::alloc::string::String,
    /// Optional. The minimum ratio of **passing_rows / total_rows** required to
    /// pass this rule, with a range of \[0.0, 1.0\].
    ///
    /// 0 indicates default value (i.e. 1.0).
    ///
    /// This field is only valid for row-level type rules.
    #[prost(double, tag = "503")]
    pub threshold: f64,
    /// Optional. A mutable name for the rule.
    ///
    /// * The name must contain only letters (a-z, A-Z), numbers (0-9), or
    /// hyphens (-).
    /// * The maximum length is 63 characters.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    #[prost(string, tag = "504")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Description of the rule.
    ///
    /// * The maximum length is 1,024 characters.
    #[prost(string, tag = "505")]
    pub description: ::prost::alloc::string::String,
    /// Optional. Whether the Rule is active or suspended.
    /// Default is false.
    #[prost(bool, tag = "506")]
    pub suspended: bool,
    /// The rule-specific configuration.
    #[prost(
        oneof = "data_quality_rule::RuleType",
        tags = "1, 2, 3, 4, 100, 101, 200, 201, 202"
    )]
    pub rule_type: ::core::option::Option<data_quality_rule::RuleType>,
}
/// Nested message and enum types in `DataQualityRule`.
pub mod data_quality_rule {
    /// Evaluates whether each column value lies between a specified range.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RangeExpectation {
        /// Optional. The minimum column value allowed for a row to pass this
        /// validation. At least one of `min_value` and `max_value` need to be
        /// provided.
        #[prost(string, tag = "1")]
        pub min_value: ::prost::alloc::string::String,
        /// Optional. The maximum column value allowed for a row to pass this
        /// validation. At least one of `min_value` and `max_value` need to be
        /// provided.
        #[prost(string, tag = "2")]
        pub max_value: ::prost::alloc::string::String,
        /// Optional. Whether each value needs to be strictly greater than ('>') the
        /// minimum, or if equality is allowed.
        ///
        /// Only relevant if a `min_value` has been defined. Default = false.
        #[prost(bool, tag = "3")]
        pub strict_min_enabled: bool,
        /// Optional. Whether each value needs to be strictly lesser than ('<') the
        /// maximum, or if equality is allowed.
        ///
        /// Only relevant if a `max_value` has been defined. Default = false.
        #[prost(bool, tag = "4")]
        pub strict_max_enabled: bool,
    }
    /// Evaluates whether each column value is null.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct NonNullExpectation {}
    /// Evaluates whether each column value is contained by a specified set.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetExpectation {
        /// Optional. Expected values for the column value.
        #[prost(string, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Evaluates whether each column value matches a specified regex.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RegexExpectation {
        /// Optional. A regular expression the column value is expected to match.
        #[prost(string, tag = "1")]
        pub regex: ::prost::alloc::string::String,
    }
    /// Evaluates whether the column has duplicates.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UniquenessExpectation {}
    /// Evaluates whether the column aggregate statistic lies between a specified
    /// range.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StatisticRangeExpectation {
        /// Optional. The aggregate metric to evaluate.
        #[prost(enumeration = "statistic_range_expectation::ColumnStatistic", tag = "1")]
        pub statistic: i32,
        /// Optional. The minimum column statistic value allowed for a row to pass
        /// this validation.
        ///
        /// At least one of `min_value` and `max_value` need to be provided.
        #[prost(string, tag = "2")]
        pub min_value: ::prost::alloc::string::String,
        /// Optional. The maximum column statistic value allowed for a row to pass
        /// this validation.
        ///
        /// At least one of `min_value` and `max_value` need to be provided.
        #[prost(string, tag = "3")]
        pub max_value: ::prost::alloc::string::String,
        /// Optional. Whether column statistic needs to be strictly greater than
        /// ('>') the minimum, or if equality is allowed.
        ///
        /// Only relevant if a `min_value` has been defined. Default = false.
        #[prost(bool, tag = "4")]
        pub strict_min_enabled: bool,
        /// Optional. Whether column statistic needs to be strictly lesser than ('<')
        /// the maximum, or if equality is allowed.
        ///
        /// Only relevant if a `max_value` has been defined. Default = false.
        #[prost(bool, tag = "5")]
        pub strict_max_enabled: bool,
    }
    /// Nested message and enum types in `StatisticRangeExpectation`.
    pub mod statistic_range_expectation {
        /// The list of aggregate metrics a rule can be evaluated against.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ColumnStatistic {
            /// Unspecified statistic type
            StatisticUndefined = 0,
            /// Evaluate the column mean
            Mean = 1,
            /// Evaluate the column min
            Min = 2,
            /// Evaluate the column max
            Max = 3,
        }
        impl ColumnStatistic {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::StatisticUndefined => "STATISTIC_UNDEFINED",
                    Self::Mean => "MEAN",
                    Self::Min => "MIN",
                    Self::Max => "MAX",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATISTIC_UNDEFINED" => Some(Self::StatisticUndefined),
                    "MEAN" => Some(Self::Mean),
                    "MIN" => Some(Self::Min),
                    "MAX" => Some(Self::Max),
                    _ => None,
                }
            }
        }
    }
    /// Evaluates whether each row passes the specified condition.
    ///
    /// The SQL expression needs to use BigQuery standard SQL syntax and should
    /// produce a boolean value per row as the result.
    ///
    /// Example: col1 >= 0 AND col2 < 10
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RowConditionExpectation {
        /// Optional. The SQL expression.
        #[prost(string, tag = "1")]
        pub sql_expression: ::prost::alloc::string::String,
    }
    /// Evaluates whether the provided expression is true.
    ///
    /// The SQL expression needs to use BigQuery standard SQL syntax and should
    /// produce a scalar boolean result.
    ///
    /// Example: MIN(col1) >= 0
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TableConditionExpectation {
        /// Optional. The SQL expression.
        #[prost(string, tag = "1")]
        pub sql_expression: ::prost::alloc::string::String,
    }
    /// A SQL statement that is evaluated to return rows that match an invalid
    /// state. If any rows are are returned, this rule fails.
    ///
    /// The SQL statement must use BigQuery standard SQL syntax, and must not
    /// contain any semicolons.
    ///
    /// You can use the data reference parameter `${data()}` to reference the
    /// source table with all of its precondition filters applied. Examples of
    /// precondition filters include row filters, incremental data filters, and
    /// sampling. For more information, see [Data reference
    /// parameter](<https://cloud.google.com/dataplex/docs/auto-data-quality-overview#data-reference-parameter>).
    ///
    /// Example: `SELECT * FROM ${data()} WHERE price < 0`
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SqlAssertion {
        /// Optional. The SQL statement.
        #[prost(string, tag = "1")]
        pub sql_statement: ::prost::alloc::string::String,
    }
    /// The rule-specific configuration.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RuleType {
        /// Row-level rule which evaluates whether each column value lies between a
        /// specified range.
        #[prost(message, tag = "1")]
        RangeExpectation(RangeExpectation),
        /// Row-level rule which evaluates whether each column value is null.
        #[prost(message, tag = "2")]
        NonNullExpectation(NonNullExpectation),
        /// Row-level rule which evaluates whether each column value is contained by
        /// a specified set.
        #[prost(message, tag = "3")]
        SetExpectation(SetExpectation),
        /// Row-level rule which evaluates whether each column value matches a
        /// specified regex.
        #[prost(message, tag = "4")]
        RegexExpectation(RegexExpectation),
        /// Row-level rule which evaluates whether each column value is unique.
        #[prost(message, tag = "100")]
        UniquenessExpectation(UniquenessExpectation),
        /// Aggregate rule which evaluates whether the column aggregate
        /// statistic lies between a specified range.
        #[prost(message, tag = "101")]
        StatisticRangeExpectation(StatisticRangeExpectation),
        /// Row-level rule which evaluates whether each row in a table passes the
        /// specified condition.
        #[prost(message, tag = "200")]
        RowConditionExpectation(RowConditionExpectation),
        /// Aggregate rule which evaluates whether the provided expression is true
        /// for a table.
        #[prost(message, tag = "201")]
        TableConditionExpectation(TableConditionExpectation),
        /// Aggregate rule which evaluates the number of rows returned for the
        /// provided statement. If any rows are returned, this rule fails.
        #[prost(message, tag = "202")]
        SqlAssertion(SqlAssertion),
    }
}
/// DataQualityColumnResult provides a more detailed, per-column view of
/// the results.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityColumnResult {
    /// Output only. The column specified in the DataQualityRule.
    #[prost(string, tag = "1")]
    pub column: ::prost::alloc::string::String,
    /// Output only. The column-level data quality score for this data scan job if
    /// and only if the 'column' field is set.
    ///
    /// The score ranges between between \[0, 100\] (up to two decimal
    /// points).
    #[prost(float, optional, tag = "2")]
    pub score: ::core::option::Option<f32>,
}
/// ResourceAccessSpec holds the access control configuration to be enforced
/// on the resources, for example, Cloud Storage bucket, BigQuery dataset,
/// BigQuery table.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceAccessSpec {
    /// Optional. The format of strings follows the pattern followed by IAM in the
    /// bindings. user:{email}, serviceAccount:{email} group:{email}.
    /// The set of principals to be granted reader role on the resource.
    #[prost(string, repeated, tag = "1")]
    pub readers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The set of principals to be granted writer role on the resource.
    #[prost(string, repeated, tag = "2")]
    pub writers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The set of principals to be granted owner role on the resource.
    #[prost(string, repeated, tag = "3")]
    pub owners: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// DataAccessSpec holds the access control configuration to be enforced on data
/// stored within resources (eg: rows, columns in BigQuery Tables). When
/// associated with data, the data is only accessible to
/// principals explicitly granted access through the DataAccessSpec. Principals
/// with access to the containing resource are not implicitly granted access.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAccessSpec {
    /// Optional. The format of strings follows the pattern followed by IAM in the
    /// bindings. user:{email}, serviceAccount:{email} group:{email}.
    /// The set of principals to be granted reader role on data
    /// stored within resources.
    #[prost(string, repeated, tag = "1")]
    pub readers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// DataTaxonomy represents a set of hierarchical DataAttributes resources,
/// grouped with a common theme Eg: 'SensitiveDataTaxonomy' can have attributes
/// to manage PII data. It is defined at project level.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataTaxonomy {
    /// Output only. The relative resource name of the DataTaxonomy, of the form:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{data_taxonomy_id}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the dataTaxonomy. This
    /// ID will be different if the DataTaxonomy is deleted and re-created with the
    /// same name.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the DataTaxonomy was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the DataTaxonomy was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Description of the DataTaxonomy.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. User-defined labels for the DataTaxonomy.
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The number of attributes in the DataTaxonomy.
    #[prost(int32, tag = "9")]
    pub attribute_count: i32,
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[prost(string, tag = "10")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. The number of classes in the DataTaxonomy.
    #[prost(int32, tag = "11")]
    pub class_count: i32,
}
/// Denotes one dataAttribute in a dataTaxonomy, for example, PII.
/// DataAttribute resources can be defined in a hierarchy.
/// A single dataAttribute resource can contain specs of multiple types
///
/// ```
/// PII
///    - ResourceAccessSpec :
///                  - readers :foo@bar.com
///    - DataAccessSpec :
///                  - readers :bar@foo.com
/// ```
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAttribute {
    /// Output only. The relative resource name of the dataAttribute, of the form:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the DataAttribute.
    /// This ID will be different if the DataAttribute is deleted and re-created
    /// with the same name.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the DataAttribute was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the DataAttribute was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Description of the DataAttribute.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. User-defined labels for the DataAttribute.
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. The ID of the parent DataAttribute resource, should belong to the
    /// same data taxonomy. Circular dependency in parent chain is not valid.
    /// Maximum depth of the hierarchy allowed is 4.
    /// \[a -> b -> c -> d -> e, depth = 4\]
    #[prost(string, tag = "8")]
    pub parent_id: ::prost::alloc::string::String,
    /// Output only. The number of child attributes present for this attribute.
    #[prost(int32, tag = "9")]
    pub attribute_count: i32,
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[prost(string, tag = "10")]
    pub etag: ::prost::alloc::string::String,
    /// Optional. Specified when applied to a resource (eg: Cloud Storage bucket,
    /// BigQuery dataset, BigQuery table).
    #[prost(message, optional, tag = "100")]
    pub resource_access_spec: ::core::option::Option<ResourceAccessSpec>,
    /// Optional. Specified when applied to data stored on the resource (eg: rows,
    /// columns in BigQuery Tables).
    #[prost(message, optional, tag = "101")]
    pub data_access_spec: ::core::option::Option<DataAccessSpec>,
}
/// DataAttributeBinding represents binding of attributes to resources. Eg: Bind
/// 'CustomerInfo' entity with 'PII' attribute.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAttributeBinding {
    /// Output only. The relative resource name of the Data Attribute Binding, of
    /// the form:
    /// projects/{project_number}/locations/{location}/dataAttributeBindings/{data_attribute_binding_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the
    /// DataAttributeBinding. This ID will be different if the DataAttributeBinding
    /// is deleted and re-created with the same name.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the DataAttributeBinding was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the DataAttributeBinding was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Description of the DataAttributeBinding.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    #[prost(string, tag = "6")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. User-defined labels for the DataAttributeBinding.
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    /// Etags must be used when calling the DeleteDataAttributeBinding and the
    /// UpdateDataAttributeBinding method.
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    /// Optional. List of attributes to be associated with the resource, provided
    /// in the form:
    /// projects/{project}/locations/{location}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}
    #[prost(string, repeated, tag = "110")]
    pub attributes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The list of paths for items within the associated resource (eg.
    /// columns and partitions within a table) along with attribute bindings.
    #[prost(message, repeated, tag = "120")]
    pub paths: ::prost::alloc::vec::Vec<data_attribute_binding::Path>,
    /// The reference to the resource that is associated to attributes, or
    /// the query to match resources and associate attributes.
    #[prost(oneof = "data_attribute_binding::ResourceReference", tags = "100")]
    pub resource_reference: ::core::option::Option<
        data_attribute_binding::ResourceReference,
    >,
}
/// Nested message and enum types in `DataAttributeBinding`.
pub mod data_attribute_binding {
    /// Represents a subresource of the given resource, and associated bindings
    /// with it. Currently supported subresources are column and partition schema
    /// fields within a table.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Path {
        /// Required. The name identifier of the path.
        /// Nested columns should be of the form: 'address.city'.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Optional. List of attributes to be associated with the path of the
        /// resource, provided in the form:
        /// projects/{project}/locations/{location}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}
        #[prost(string, repeated, tag = "2")]
        pub attributes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// The reference to the resource that is associated to attributes, or
    /// the query to match resources and associate attributes.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResourceReference {
        /// Optional. Immutable. The resource name of the resource that is associated
        /// to attributes. Presently, only entity resource is supported in the form:
        /// projects/{project}/locations/{location}/lakes/{lake}/zones/{zone}/entities/{entity_id}
        /// Must belong in the same project and region as the attribute binding, and
        /// there can only exist one active binding for a resource.
        #[prost(string, tag = "100")]
        Resource(::prost::alloc::string::String),
    }
}
/// Create DataTaxonomy request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataTaxonomyRequest {
    /// Required. The resource name of the data taxonomy location, of the form:
    /// projects/{project_number}/locations/{location_id}
    /// where `location_id` refers to a GCP region.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. DataTaxonomy identifier.
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the Project.
    #[prost(string, tag = "2")]
    pub data_taxonomy_id: ::prost::alloc::string::String,
    /// Required. DataTaxonomy resource.
    #[prost(message, optional, tag = "3")]
    pub data_taxonomy: ::core::option::Option<DataTaxonomy>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Update DataTaxonomy request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataTaxonomyRequest {
    /// Required. Mask of fields to update.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Only fields specified in `update_mask` are updated.
    #[prost(message, optional, tag = "2")]
    pub data_taxonomy: ::core::option::Option<DataTaxonomy>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Get DataTaxonomy request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataTaxonomyRequest {
    /// Required. The resource name of the DataTaxonomy:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{data_taxonomy_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// List DataTaxonomies request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataTaxonomiesRequest {
    /// Required. The resource name of the DataTaxonomy location, of the form:
    /// projects/{project_number}/locations/{location_id}
    /// where `location_id` refers to a GCP region.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of DataTaxonomies to return. The service may
    /// return fewer than this value. If unspecified, at most 10 DataTaxonomies
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous ` ListDataTaxonomies` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to ` ListDataTaxonomies` must match the call that
    /// provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Order by fields for the result.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// List DataTaxonomies response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataTaxonomiesResponse {
    /// DataTaxonomies under the given parent location.
    #[prost(message, repeated, tag = "1")]
    pub data_taxonomies: ::prost::alloc::vec::Vec<DataTaxonomy>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Delete DataTaxonomy request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDataTaxonomyRequest {
    /// Required. The resource name of the DataTaxonomy:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{data_taxonomy_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If the client provided etag value does not match the current etag
    /// value,the DeleteDataTaxonomy method returns an ABORTED error.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// Create DataAttribute request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataAttributeRequest {
    /// Required. The resource name of the parent data taxonomy
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{data_taxonomy_id}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. DataAttribute identifier.
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the DataTaxonomy.
    #[prost(string, tag = "2")]
    pub data_attribute_id: ::prost::alloc::string::String,
    /// Required. DataAttribute resource.
    #[prost(message, optional, tag = "3")]
    pub data_attribute: ::core::option::Option<DataAttribute>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Update DataAttribute request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataAttributeRequest {
    /// Required. Mask of fields to update.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Only fields specified in `update_mask` are updated.
    #[prost(message, optional, tag = "2")]
    pub data_attribute: ::core::option::Option<DataAttribute>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Get DataAttribute request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataAttributeRequest {
    /// Required. The resource name of the dataAttribute:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// List DataAttributes request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataAttributesRequest {
    /// Required. The resource name of the DataTaxonomy:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{data_taxonomy_id}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of DataAttributes to return. The service may
    /// return fewer than this value. If unspecified, at most 10 dataAttributes
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListDataAttributes` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListDataAttributes` must match the call that
    /// provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Order by fields for the result.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// List DataAttributes response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataAttributesResponse {
    /// DataAttributes under the given parent DataTaxonomy.
    #[prost(message, repeated, tag = "1")]
    pub data_attributes: ::prost::alloc::vec::Vec<DataAttribute>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Delete DataAttribute request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDataAttributeRequest {
    /// Required. The resource name of the DataAttribute:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If the client provided etag value does not match the current etag
    /// value, the DeleteDataAttribute method returns an ABORTED error response.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// Create DataAttributeBinding request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataAttributeBindingRequest {
    /// Required. The resource name of the parent data taxonomy
    /// projects/{project_number}/locations/{location_id}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. DataAttributeBinding identifier.
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the Location.
    #[prost(string, tag = "2")]
    pub data_attribute_binding_id: ::prost::alloc::string::String,
    /// Required. DataAttributeBinding resource.
    #[prost(message, optional, tag = "3")]
    pub data_attribute_binding: ::core::option::Option<DataAttributeBinding>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Update DataAttributeBinding request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataAttributeBindingRequest {
    /// Required. Mask of fields to update.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Only fields specified in `update_mask` are updated.
    #[prost(message, optional, tag = "2")]
    pub data_attribute_binding: ::core::option::Option<DataAttributeBinding>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Get DataAttributeBinding request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataAttributeBindingRequest {
    /// Required. The resource name of the DataAttributeBinding:
    /// projects/{project_number}/locations/{location_id}/dataAttributeBindings/{data_attribute_binding_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// List DataAttributeBindings request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataAttributeBindingsRequest {
    /// Required. The resource name of the Location:
    /// projects/{project_number}/locations/{location_id}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of DataAttributeBindings to return. The service
    /// may return fewer than this value. If unspecified, at most 10
    /// DataAttributeBindings will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListDataAttributeBindings`
    /// call. Provide this to retrieve the subsequent page. When paginating, all
    /// other parameters provided to `ListDataAttributeBindings` must match the
    /// call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter request.
    /// Filter using resource: filter=resource:"resource-name"
    /// Filter using attribute: filter=attributes:"attribute-name"
    /// Filter using attribute in paths list:
    /// filter=paths.attributes:"attribute-name"
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Order by fields for the result.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// List DataAttributeBindings response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataAttributeBindingsResponse {
    /// DataAttributeBindings under the given parent Location.
    #[prost(message, repeated, tag = "1")]
    pub data_attribute_bindings: ::prost::alloc::vec::Vec<DataAttributeBinding>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Delete DataAttributeBinding request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDataAttributeBindingRequest {
    /// Required. The resource name of the DataAttributeBinding:
    /// projects/{project_number}/locations/{location_id}/dataAttributeBindings/{data_attribute_binding_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. If the client provided etag value does not match the current etag
    /// value, the DeleteDataAttributeBindingRequest method returns an ABORTED
    /// error response. Etags must be used when calling the
    /// DeleteDataAttributeBinding.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod data_taxonomy_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// DataTaxonomyService enables attribute-based governance. The resources
    /// currently offered include DataTaxonomy and DataAttribute.
    #[derive(Debug, Clone)]
    pub struct DataTaxonomyServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DataTaxonomyServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DataTaxonomyServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DataTaxonomyServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DataTaxonomyServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a DataTaxonomy resource.
        pub async fn create_data_taxonomy(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDataTaxonomyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/CreateDataTaxonomy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "CreateDataTaxonomy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a DataTaxonomy resource.
        pub async fn update_data_taxonomy(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataTaxonomyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/UpdateDataTaxonomy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "UpdateDataTaxonomy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a DataTaxonomy resource. All attributes within the DataTaxonomy
        /// must be deleted before the DataTaxonomy can be deleted.
        pub async fn delete_data_taxonomy(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDataTaxonomyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/DeleteDataTaxonomy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "DeleteDataTaxonomy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists DataTaxonomy resources in a project and location.
        pub async fn list_data_taxonomies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataTaxonomiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataTaxonomiesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/ListDataTaxonomies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "ListDataTaxonomies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a DataTaxonomy resource.
        pub async fn get_data_taxonomy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataTaxonomyRequest>,
        ) -> std::result::Result<tonic::Response<super::DataTaxonomy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/GetDataTaxonomy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "GetDataTaxonomy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a DataAttributeBinding resource.
        pub async fn create_data_attribute_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDataAttributeBindingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/CreateDataAttributeBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "CreateDataAttributeBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a DataAttributeBinding resource.
        pub async fn update_data_attribute_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataAttributeBindingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/UpdateDataAttributeBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "UpdateDataAttributeBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a DataAttributeBinding resource. All attributes within the
        /// DataAttributeBinding must be deleted before the DataAttributeBinding can be
        /// deleted.
        pub async fn delete_data_attribute_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDataAttributeBindingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/DeleteDataAttributeBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "DeleteDataAttributeBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists DataAttributeBinding resources in a project and location.
        pub async fn list_data_attribute_bindings(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataAttributeBindingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataAttributeBindingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/ListDataAttributeBindings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "ListDataAttributeBindings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a DataAttributeBinding resource.
        pub async fn get_data_attribute_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataAttributeBindingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DataAttributeBinding>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/GetDataAttributeBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "GetDataAttributeBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a DataAttribute resource.
        pub async fn create_data_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDataAttributeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/CreateDataAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "CreateDataAttribute",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a DataAttribute resource.
        pub async fn update_data_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataAttributeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/UpdateDataAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "UpdateDataAttribute",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Data Attribute resource.
        pub async fn delete_data_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDataAttributeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/DeleteDataAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "DeleteDataAttribute",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Data Attribute resources in a DataTaxonomy.
        pub async fn list_data_attributes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataAttributesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataAttributesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/ListDataAttributes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "ListDataAttributes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a Data Attribute resource.
        pub async fn get_data_attribute(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataAttributeRequest>,
        ) -> std::result::Result<tonic::Response<super::DataAttribute>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataTaxonomyService/GetDataAttribute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataTaxonomyService",
                        "GetDataAttribute",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Create dataScan request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataScanRequest {
    /// Required. The resource name of the parent location:
    /// `projects/{project}/locations/{location_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. DataScan resource.
    #[prost(message, optional, tag = "2")]
    pub data_scan: ::core::option::Option<DataScan>,
    /// Required. DataScan identifier.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    /// * Must be between 1-63 characters.
    /// * Must be unique within the customer project / location.
    #[prost(string, tag = "3")]
    pub data_scan_id: ::prost::alloc::string::String,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is `false`.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Update dataScan request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataScanRequest {
    /// Required. DataScan resource to be updated.
    ///
    /// Only fields specified in `update_mask` are updated.
    #[prost(message, optional, tag = "1")]
    pub data_scan: ::core::option::Option<DataScan>,
    /// Optional. Mask of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is `false`.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Delete dataScan request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDataScanRequest {
    /// Required. The resource name of the dataScan:
    /// `projects/{project}/locations/{location_id}/dataScans/{data_scan_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If set to true, any child resources of this data scan will also
    /// be deleted. (Otherwise, the request will only work if the data scan has no
    /// child resources.)
    #[prost(bool, tag = "2")]
    pub force: bool,
}
/// Get dataScan request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataScanRequest {
    /// Required. The resource name of the dataScan:
    /// `projects/{project}/locations/{location_id}/dataScans/{data_scan_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Select the DataScan view to return. Defaults to `BASIC`.
    #[prost(enumeration = "get_data_scan_request::DataScanView", tag = "2")]
    pub view: i32,
}
/// Nested message and enum types in `GetDataScanRequest`.
pub mod get_data_scan_request {
    /// DataScan view options.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataScanView {
        /// The API will default to the `BASIC` view.
        Unspecified = 0,
        /// Basic view that does not include *spec* and *result*.
        Basic = 1,
        /// Include everything.
        Full = 10,
    }
    impl DataScanView {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DATA_SCAN_VIEW_UNSPECIFIED",
                Self::Basic => "BASIC",
                Self::Full => "FULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_SCAN_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
                "BASIC" => Some(Self::Basic),
                "FULL" => Some(Self::Full),
                _ => None,
            }
        }
    }
}
/// List dataScans request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataScansRequest {
    /// Required. The resource name of the parent location:
    /// `projects/{project}/locations/{location_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of dataScans to return. The service may return
    /// fewer than this value. If unspecified, at most 500 scans will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListDataScans` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListDataScans` must match the call that provided the
    /// page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Order by fields (`name` or `create_time`) for the result.
    /// If not specified, the ordering is undefined.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// List dataScans response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataScansResponse {
    /// DataScans (`BASIC` view only) under the given parent location.
    #[prost(message, repeated, tag = "1")]
    pub data_scans: ::prost::alloc::vec::Vec<DataScan>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Run DataScan Request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunDataScanRequest {
    /// Required. The resource name of the DataScan:
    /// `projects/{project}/locations/{location_id}/dataScans/{data_scan_id}`.
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    ///
    /// Only **OnDemand** data scans are allowed.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Run DataScan Response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunDataScanResponse {
    /// DataScanJob created by RunDataScan request.
    #[prost(message, optional, tag = "1")]
    pub job: ::core::option::Option<DataScanJob>,
}
/// Get DataScanJob request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataScanJobRequest {
    /// Required. The resource name of the DataScanJob:
    /// `projects/{project}/locations/{location_id}/dataScans/{data_scan_id}/jobs/{data_scan_job_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Select the DataScanJob view to return. Defaults to `BASIC`.
    #[prost(enumeration = "get_data_scan_job_request::DataScanJobView", tag = "2")]
    pub view: i32,
}
/// Nested message and enum types in `GetDataScanJobRequest`.
pub mod get_data_scan_job_request {
    /// DataScanJob view options.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataScanJobView {
        /// The API will default to the `BASIC` view.
        Unspecified = 0,
        /// Basic view that does not include *spec* and *result*.
        Basic = 1,
        /// Include everything.
        Full = 10,
    }
    impl DataScanJobView {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DATA_SCAN_JOB_VIEW_UNSPECIFIED",
                Self::Basic => "BASIC",
                Self::Full => "FULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_SCAN_JOB_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
                "BASIC" => Some(Self::Basic),
                "FULL" => Some(Self::Full),
                _ => None,
            }
        }
    }
}
/// List DataScanJobs request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataScanJobsRequest {
    /// Required. The resource name of the parent environment:
    /// `projects/{project}/locations/{location_id}/dataScans/{data_scan_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of DataScanJobs to return. The service may return
    /// fewer than this value. If unspecified, at most 10 DataScanJobs will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListDataScanJobs` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListDataScanJobs` must match the call that provided
    /// the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the ListDataScanJobs
    /// request.
    ///
    /// If unspecified, all datascan jobs will be returned. Multiple filters can be
    /// applied (with `AND`, `OR` logical operators). Filters are case-sensitive.
    ///
    /// Allowed fields are:
    ///
    /// - `start_time`
    /// - `end_time`
    ///
    /// `start_time` and `end_time` expect RFC-3339 formatted strings (e.g.
    /// 2018-10-08T18:30:00-07:00).
    ///
    /// For instance, 'start_time > 2018-10-08T00:00:00.123456789Z AND end_time <
    /// 2018-10-09T00:00:00.123456789Z' limits results to DataScanJobs between
    /// specified start and end times.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// List DataScanJobs response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataScanJobsResponse {
    /// DataScanJobs (`BASIC` view only) under a given dataScan.
    #[prost(message, repeated, tag = "1")]
    pub data_scan_jobs: ::prost::alloc::vec::Vec<DataScanJob>,
    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request details for generating data quality rule recommendations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateDataQualityRulesRequest {
    /// Required. The name must be one of the following:
    ///
    /// * The name of a data scan with at least one successful, completed data
    /// profiling job
    /// * The name of a successful, completed data profiling job (a data scan job
    /// where the job type is data profiling)
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Response details for data quality rule recommendations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateDataQualityRulesResponse {
    /// The data quality rules that Dataplex generates based on the results
    /// of a data profiling scan.
    #[prost(message, repeated, tag = "1")]
    pub rule: ::prost::alloc::vec::Vec<DataQualityRule>,
}
/// Represents a user-visible job which provides the insights for the related
/// data source.
///
/// For example:
///
/// * Data Quality: generates queries based on the rules and runs against the
///    data to get data quality check results.
/// * Data Profile: analyzes the data in table(s) and generates insights about
///    the structure, content and relationships (such as null percent,
///    cardinality, min/max/mean, etc).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataScan {
    /// Output only. Identifier. The relative resource name of the scan, of the
    /// form: `projects/{project}/locations/{location_id}/dataScans/{datascan_id}`,
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the scan. This ID will
    /// be different if the scan is deleted and re-created with the same name.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Optional. Description of the scan.
    ///
    /// * Must be between 1-1024 characters.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    ///
    /// * Must be between 1-256 characters.
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. User-defined labels for the scan.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Current state of the DataScan.
    #[prost(enumeration = "State", tag = "6")]
    pub state: i32,
    /// Output only. The time when the scan was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the scan was last updated.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. The data source for DataScan.
    #[prost(message, optional, tag = "9")]
    pub data: ::core::option::Option<DataSource>,
    /// Optional. DataScan execution settings.
    ///
    /// If not specified, the fields in it will use their default values.
    #[prost(message, optional, tag = "10")]
    pub execution_spec: ::core::option::Option<data_scan::ExecutionSpec>,
    /// Output only. Status of the data scan execution.
    #[prost(message, optional, tag = "11")]
    pub execution_status: ::core::option::Option<data_scan::ExecutionStatus>,
    /// Output only. The type of DataScan.
    #[prost(enumeration = "DataScanType", tag = "12")]
    pub r#type: i32,
    /// Data scan related setting.
    /// The settings are required and immutable. After you configure the settings
    /// for one type of data scan, you can't change the data scan to a different
    /// type of data scan.
    #[prost(oneof = "data_scan::Spec", tags = "100, 101, 102")]
    pub spec: ::core::option::Option<data_scan::Spec>,
    /// The result of the data scan.
    #[prost(oneof = "data_scan::Result", tags = "200, 201, 202")]
    pub result: ::core::option::Option<data_scan::Result>,
}
/// Nested message and enum types in `DataScan`.
pub mod data_scan {
    /// DataScan execution settings.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecutionSpec {
        /// Optional. Spec related to how often and when a scan should be triggered.
        ///
        /// If not specified, the default is `OnDemand`, which means the scan will
        /// not run until the user calls `RunDataScan` API.
        #[prost(message, optional, tag = "1")]
        pub trigger: ::core::option::Option<super::Trigger>,
        /// Spec related to incremental scan of the data
        ///
        /// When an option is selected for incremental scan, it cannot be unset or
        /// changed. If not specified, a data scan will run for all data in the
        /// table.
        #[prost(oneof = "execution_spec::Incremental", tags = "100")]
        pub incremental: ::core::option::Option<execution_spec::Incremental>,
    }
    /// Nested message and enum types in `ExecutionSpec`.
    pub mod execution_spec {
        /// Spec related to incremental scan of the data
        ///
        /// When an option is selected for incremental scan, it cannot be unset or
        /// changed. If not specified, a data scan will run for all data in the
        /// table.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Incremental {
            /// Immutable. The unnested field (of type *Date* or *Timestamp*) that
            /// contains values which monotonically increase over time.
            ///
            /// If not specified, a data scan will run for all data in the table.
            #[prost(string, tag = "100")]
            Field(::prost::alloc::string::String),
        }
    }
    /// Status of the data scan execution.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ExecutionStatus {
        /// Optional. The time when the latest DataScanJob started.
        #[prost(message, optional, tag = "4")]
        pub latest_job_start_time: ::core::option::Option<::prost_types::Timestamp>,
        /// Optional. The time when the latest DataScanJob ended.
        #[prost(message, optional, tag = "5")]
        pub latest_job_end_time: ::core::option::Option<::prost_types::Timestamp>,
        /// Optional. The time when the DataScanJob execution was created.
        #[prost(message, optional, tag = "6")]
        pub latest_job_create_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Data scan related setting.
    /// The settings are required and immutable. After you configure the settings
    /// for one type of data scan, you can't change the data scan to a different
    /// type of data scan.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Spec {
        /// Settings for a data quality scan.
        #[prost(message, tag = "100")]
        DataQualitySpec(super::DataQualitySpec),
        /// Settings for a data profile scan.
        #[prost(message, tag = "101")]
        DataProfileSpec(super::DataProfileSpec),
        /// Settings for a data discovery scan.
        #[prost(message, tag = "102")]
        DataDiscoverySpec(super::DataDiscoverySpec),
    }
    /// The result of the data scan.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        /// Output only. The result of a data quality scan.
        #[prost(message, tag = "200")]
        DataQualityResult(super::DataQualityResult),
        /// Output only. The result of a data profile scan.
        #[prost(message, tag = "201")]
        DataProfileResult(super::DataProfileResult),
        /// Output only. The result of a data discovery scan.
        #[prost(message, tag = "202")]
        DataDiscoveryResult(super::DataDiscoveryResult),
    }
}
/// A DataScanJob represents an instance of DataScan execution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataScanJob {
    /// Output only. Identifier. The relative resource name of the DataScanJob, of
    /// the form:
    /// `projects/{project}/locations/{location_id}/dataScans/{datascan_id}/jobs/{job_id}`,
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. System generated globally unique ID for the DataScanJob.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. The time when the DataScanJob was created.
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the DataScanJob was started.
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the DataScanJob ended.
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Execution state for the DataScanJob.
    #[prost(enumeration = "data_scan_job::State", tag = "5")]
    pub state: i32,
    /// Output only. Additional information about the current state.
    #[prost(string, tag = "6")]
    pub message: ::prost::alloc::string::String,
    /// Output only. The type of the parent DataScan.
    #[prost(enumeration = "DataScanType", tag = "7")]
    pub r#type: i32,
    /// Data scan related setting.
    #[prost(oneof = "data_scan_job::Spec", tags = "100, 101, 102")]
    pub spec: ::core::option::Option<data_scan_job::Spec>,
    /// The result of the data scan.
    #[prost(oneof = "data_scan_job::Result", tags = "200, 201, 202")]
    pub result: ::core::option::Option<data_scan_job::Result>,
}
/// Nested message and enum types in `DataScanJob`.
pub mod data_scan_job {
    /// Execution state for the DataScanJob.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The DataScanJob state is unspecified.
        Unspecified = 0,
        /// The DataScanJob is running.
        Running = 1,
        /// The DataScanJob is canceling.
        Canceling = 2,
        /// The DataScanJob cancellation was successful.
        Cancelled = 3,
        /// The DataScanJob completed successfully.
        Succeeded = 4,
        /// The DataScanJob is no longer running due to an error.
        Failed = 5,
        /// The DataScanJob has been created but not started to run yet.
        Pending = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Running => "RUNNING",
                Self::Canceling => "CANCELING",
                Self::Cancelled => "CANCELLED",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::Pending => "PENDING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "RUNNING" => Some(Self::Running),
                "CANCELING" => Some(Self::Canceling),
                "CANCELLED" => Some(Self::Cancelled),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "PENDING" => Some(Self::Pending),
                _ => None,
            }
        }
    }
    /// Data scan related setting.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Spec {
        /// Output only. Settings for a data quality scan.
        #[prost(message, tag = "100")]
        DataQualitySpec(super::DataQualitySpec),
        /// Output only. Settings for a data profile scan.
        #[prost(message, tag = "101")]
        DataProfileSpec(super::DataProfileSpec),
        /// Output only. Settings for a data discovery scan.
        #[prost(message, tag = "102")]
        DataDiscoverySpec(super::DataDiscoverySpec),
    }
    /// The result of the data scan.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        /// Output only. The result of a data quality scan.
        #[prost(message, tag = "200")]
        DataQualityResult(super::DataQualityResult),
        /// Output only. The result of a data profile scan.
        #[prost(message, tag = "201")]
        DataProfileResult(super::DataProfileResult),
        /// Output only. The result of a data discovery scan.
        #[prost(message, tag = "202")]
        DataDiscoveryResult(super::DataDiscoveryResult),
    }
}
/// The type of data scan.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataScanType {
    /// The data scan type is unspecified.
    Unspecified = 0,
    /// Data quality scan.
    DataQuality = 1,
    /// Data profile scan.
    DataProfile = 2,
    /// Data discovery scan.
    DataDiscovery = 3,
}
impl DataScanType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DATA_SCAN_TYPE_UNSPECIFIED",
            Self::DataQuality => "DATA_QUALITY",
            Self::DataProfile => "DATA_PROFILE",
            Self::DataDiscovery => "DATA_DISCOVERY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATA_SCAN_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "DATA_QUALITY" => Some(Self::DataQuality),
            "DATA_PROFILE" => Some(Self::DataProfile),
            "DATA_DISCOVERY" => Some(Self::DataDiscovery),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod data_scan_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// DataScanService manages DataScan resources which can be configured to run
    /// various types of data scanning workload and generate enriched metadata (e.g.
    /// Data Profile, Data Quality) for the data source.
    #[derive(Debug, Clone)]
    pub struct DataScanServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DataScanServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DataScanServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DataScanServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DataScanServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a DataScan resource.
        pub async fn create_data_scan(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDataScanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/CreateDataScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "CreateDataScan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a DataScan resource.
        pub async fn update_data_scan(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataScanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/UpdateDataScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "UpdateDataScan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a DataScan resource.
        pub async fn delete_data_scan(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDataScanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/DeleteDataScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "DeleteDataScan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a DataScan resource.
        pub async fn get_data_scan(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataScanRequest>,
        ) -> std::result::Result<tonic::Response<super::DataScan>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/GetDataScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "GetDataScan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists DataScans.
        pub async fn list_data_scans(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataScansRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataScansResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/ListDataScans",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "ListDataScans",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Runs an on-demand execution of a DataScan
        pub async fn run_data_scan(
            &mut self,
            request: impl tonic::IntoRequest<super::RunDataScanRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RunDataScanResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/RunDataScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "RunDataScan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a DataScanJob resource.
        pub async fn get_data_scan_job(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataScanJobRequest>,
        ) -> std::result::Result<tonic::Response<super::DataScanJob>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/GetDataScanJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "GetDataScanJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists DataScanJobs under the given DataScan.
        pub async fn list_data_scan_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataScanJobsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataScanJobsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/ListDataScanJobs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "ListDataScanJobs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generates recommended data quality rules based on the results of a data
        /// profiling scan.
        ///
        /// Use the recommendations to build rules for a data quality scan.
        pub async fn generate_data_quality_rules(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateDataQualityRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateDataQualityRulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.DataScanService/GenerateDataQualityRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.DataScanService",
                        "GenerateDataQualityRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The payload associated with Discovery data processing.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiscoveryEvent {
    /// The log message.
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    /// The id of the associated lake.
    #[prost(string, tag = "2")]
    pub lake_id: ::prost::alloc::string::String,
    /// The id of the associated zone.
    #[prost(string, tag = "3")]
    pub zone_id: ::prost::alloc::string::String,
    /// The id of the associated asset.
    #[prost(string, tag = "4")]
    pub asset_id: ::prost::alloc::string::String,
    /// The data location associated with the event.
    #[prost(string, tag = "5")]
    pub data_location: ::prost::alloc::string::String,
    /// The id of the associated datascan for standalone discovery.
    #[prost(string, tag = "6")]
    pub datascan_id: ::prost::alloc::string::String,
    /// The type of the event being logged.
    #[prost(enumeration = "discovery_event::EventType", tag = "10")]
    pub r#type: i32,
    /// Additional details about the event.
    #[prost(oneof = "discovery_event::Details", tags = "20, 21, 22, 23, 24")]
    pub details: ::core::option::Option<discovery_event::Details>,
}
/// Nested message and enum types in `DiscoveryEvent`.
pub mod discovery_event {
    /// Details about configuration events.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConfigDetails {
        /// A list of discovery configuration parameters in effect.
        /// The keys are the field paths within DiscoverySpec.
        /// Eg. includePatterns, excludePatterns, csvOptions.disableTypeInference,
        /// etc.
        #[prost(map = "string, string", tag = "1")]
        pub parameters: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    /// Details about the entity.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EntityDetails {
        /// The name of the entity resource.
        /// The name is the fully-qualified resource name.
        #[prost(string, tag = "1")]
        pub entity: ::prost::alloc::string::String,
        /// The type of the entity resource.
        #[prost(enumeration = "EntityType", tag = "2")]
        pub r#type: i32,
    }
    /// Details about the published table.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TableDetails {
        /// The fully-qualified resource name of the table resource.
        #[prost(string, tag = "1")]
        pub table: ::prost::alloc::string::String,
        /// The type of the table resource.
        #[prost(enumeration = "TableType", tag = "2")]
        pub r#type: i32,
    }
    /// Details about the partition.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PartitionDetails {
        /// The name to the partition resource.
        /// The name is the fully-qualified resource name.
        #[prost(string, tag = "1")]
        pub partition: ::prost::alloc::string::String,
        /// The name to the containing entity resource.
        /// The name is the fully-qualified resource name.
        #[prost(string, tag = "2")]
        pub entity: ::prost::alloc::string::String,
        /// The type of the containing entity resource.
        #[prost(enumeration = "EntityType", tag = "3")]
        pub r#type: i32,
        /// The locations of the data items (e.g., a Cloud Storage objects) sampled
        /// for metadata inference.
        #[prost(string, repeated, tag = "4")]
        pub sampled_data_locations: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
    /// Details about the action.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ActionDetails {
        /// The type of action.
        /// Eg. IncompatibleDataSchema, InvalidDataFormat
        #[prost(string, tag = "1")]
        pub r#type: ::prost::alloc::string::String,
        /// The human readable issue associated with the action.
        #[prost(string, tag = "2")]
        pub issue: ::prost::alloc::string::String,
    }
    /// The type of the event.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EventType {
        /// An unspecified event type.
        Unspecified = 0,
        /// An event representing discovery configuration in effect.
        Config = 1,
        /// An event representing a metadata entity being created.
        EntityCreated = 2,
        /// An event representing a metadata entity being updated.
        EntityUpdated = 3,
        /// An event representing a metadata entity being deleted.
        EntityDeleted = 4,
        /// An event representing a partition being created.
        PartitionCreated = 5,
        /// An event representing a partition being updated.
        PartitionUpdated = 6,
        /// An event representing a partition being deleted.
        PartitionDeleted = 7,
        /// An event representing a table being published.
        TablePublished = 10,
        /// An event representing a table being updated.
        TableUpdated = 11,
        /// An event representing a table being skipped in publishing.
        TableIgnored = 12,
        /// An event representing a table being deleted.
        TableDeleted = 13,
    }
    impl EventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EVENT_TYPE_UNSPECIFIED",
                Self::Config => "CONFIG",
                Self::EntityCreated => "ENTITY_CREATED",
                Self::EntityUpdated => "ENTITY_UPDATED",
                Self::EntityDeleted => "ENTITY_DELETED",
                Self::PartitionCreated => "PARTITION_CREATED",
                Self::PartitionUpdated => "PARTITION_UPDATED",
                Self::PartitionDeleted => "PARTITION_DELETED",
                Self::TablePublished => "TABLE_PUBLISHED",
                Self::TableUpdated => "TABLE_UPDATED",
                Self::TableIgnored => "TABLE_IGNORED",
                Self::TableDeleted => "TABLE_DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CONFIG" => Some(Self::Config),
                "ENTITY_CREATED" => Some(Self::EntityCreated),
                "ENTITY_UPDATED" => Some(Self::EntityUpdated),
                "ENTITY_DELETED" => Some(Self::EntityDeleted),
                "PARTITION_CREATED" => Some(Self::PartitionCreated),
                "PARTITION_UPDATED" => Some(Self::PartitionUpdated),
                "PARTITION_DELETED" => Some(Self::PartitionDeleted),
                "TABLE_PUBLISHED" => Some(Self::TablePublished),
                "TABLE_UPDATED" => Some(Self::TableUpdated),
                "TABLE_IGNORED" => Some(Self::TableIgnored),
                "TABLE_DELETED" => Some(Self::TableDeleted),
                _ => None,
            }
        }
    }
    /// The type of the entity.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EntityType {
        /// An unspecified event type.
        Unspecified = 0,
        /// Entities representing structured data.
        Table = 1,
        /// Entities representing unstructured data.
        Fileset = 2,
    }
    impl EntityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ENTITY_TYPE_UNSPECIFIED",
                Self::Table => "TABLE",
                Self::Fileset => "FILESET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENTITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TABLE" => Some(Self::Table),
                "FILESET" => Some(Self::Fileset),
                _ => None,
            }
        }
    }
    /// The type of the published table.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TableType {
        /// An unspecified table type.
        Unspecified = 0,
        /// External table type.
        ExternalTable = 1,
        /// BigLake table type.
        BiglakeTable = 2,
        /// Object table type for unstructured data.
        ObjectTable = 3,
    }
    impl TableType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TABLE_TYPE_UNSPECIFIED",
                Self::ExternalTable => "EXTERNAL_TABLE",
                Self::BiglakeTable => "BIGLAKE_TABLE",
                Self::ObjectTable => "OBJECT_TABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TABLE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "EXTERNAL_TABLE" => Some(Self::ExternalTable),
                "BIGLAKE_TABLE" => Some(Self::BiglakeTable),
                "OBJECT_TABLE" => Some(Self::ObjectTable),
                _ => None,
            }
        }
    }
    /// Additional details about the event.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Details {
        /// Details about discovery configuration in effect.
        #[prost(message, tag = "20")]
        Config(ConfigDetails),
        /// Details about the entity associated with the event.
        #[prost(message, tag = "21")]
        Entity(EntityDetails),
        /// Details about the partition associated with the event.
        #[prost(message, tag = "22")]
        Partition(PartitionDetails),
        /// Details about the action associated with the event.
        #[prost(message, tag = "23")]
        Action(ActionDetails),
        /// Details about the BigQuery table publishing associated with the event.
        #[prost(message, tag = "24")]
        Table(TableDetails),
    }
}
/// The payload associated with Job logs that contains events describing jobs
/// that have run within a Lake.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobEvent {
    /// The log message.
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    /// The unique id identifying the job.
    #[prost(string, tag = "2")]
    pub job_id: ::prost::alloc::string::String,
    /// The time when the job started running.
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time when the job ended running.
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The job state on completion.
    #[prost(enumeration = "job_event::State", tag = "5")]
    pub state: i32,
    /// The number of retries.
    #[prost(int32, tag = "6")]
    pub retries: i32,
    /// The type of the job.
    #[prost(enumeration = "job_event::Type", tag = "7")]
    pub r#type: i32,
    /// The service used to execute the job.
    #[prost(enumeration = "job_event::Service", tag = "8")]
    pub service: i32,
    /// The reference to the job within the service.
    #[prost(string, tag = "9")]
    pub service_job: ::prost::alloc::string::String,
    /// Job execution trigger.
    #[prost(enumeration = "job_event::ExecutionTrigger", tag = "11")]
    pub execution_trigger: i32,
}
/// Nested message and enum types in `JobEvent`.
pub mod job_event {
    /// The type of the job.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Unspecified job type.
        Unspecified = 0,
        /// Spark jobs.
        Spark = 1,
        /// Notebook jobs.
        Notebook = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Spark => "SPARK",
                Self::Notebook => "NOTEBOOK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SPARK" => Some(Self::Spark),
                "NOTEBOOK" => Some(Self::Notebook),
                _ => None,
            }
        }
    }
    /// The completion status of the job.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unspecified job state.
        Unspecified = 0,
        /// Job successfully completed.
        Succeeded = 1,
        /// Job was unsuccessful.
        Failed = 2,
        /// Job was cancelled by the user.
        Cancelled = 3,
        /// Job was cancelled or aborted via the service executing the job.
        Aborted = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::Cancelled => "CANCELLED",
                Self::Aborted => "ABORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "CANCELLED" => Some(Self::Cancelled),
                "ABORTED" => Some(Self::Aborted),
                _ => None,
            }
        }
    }
    /// The service used to execute the job.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Service {
        /// Unspecified service.
        Unspecified = 0,
        /// Cloud Dataproc.
        Dataproc = 1,
    }
    impl Service {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SERVICE_UNSPECIFIED",
                Self::Dataproc => "DATAPROC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SERVICE_UNSPECIFIED" => Some(Self::Unspecified),
                "DATAPROC" => Some(Self::Dataproc),
                _ => None,
            }
        }
    }
    /// Job Execution trigger.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExecutionTrigger {
        /// The job execution trigger is unspecified.
        Unspecified = 0,
        /// The job was triggered by Dataplex based on trigger spec from task
        /// definition.
        TaskConfig = 1,
        /// The job was triggered by the explicit call of Task API.
        RunRequest = 2,
    }
    impl ExecutionTrigger {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EXECUTION_TRIGGER_UNSPECIFIED",
                Self::TaskConfig => "TASK_CONFIG",
                Self::RunRequest => "RUN_REQUEST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXECUTION_TRIGGER_UNSPECIFIED" => Some(Self::Unspecified),
                "TASK_CONFIG" => Some(Self::TaskConfig),
                "RUN_REQUEST" => Some(Self::RunRequest),
                _ => None,
            }
        }
    }
}
/// These messages contain information about sessions within an environment.
/// The monitored resource is 'Environment'.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionEvent {
    /// The log message.
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    /// The information about the user that created the session. It will be the
    /// email address of the user.
    #[prost(string, tag = "2")]
    pub user_id: ::prost::alloc::string::String,
    /// Unique identifier for the session.
    #[prost(string, tag = "3")]
    pub session_id: ::prost::alloc::string::String,
    /// The type of the event.
    #[prost(enumeration = "session_event::EventType", tag = "4")]
    pub r#type: i32,
    /// The status of the event.
    #[prost(bool, tag = "6")]
    pub event_succeeded: bool,
    /// If the session is associated with an environment with fast startup enabled,
    /// and was created before being assigned to a user.
    #[prost(bool, tag = "7")]
    pub fast_startup_enabled: bool,
    /// The idle duration of a warm pooled session before it is assigned to user.
    #[prost(message, optional, tag = "8")]
    pub unassigned_duration: ::core::option::Option<::prost_types::Duration>,
    /// Additional information about the Query metadata.
    #[prost(oneof = "session_event::Detail", tags = "5")]
    pub detail: ::core::option::Option<session_event::Detail>,
}
/// Nested message and enum types in `SessionEvent`.
pub mod session_event {
    /// Execution details of the query.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QueryDetail {
        /// The unique Query id identifying the query.
        #[prost(string, tag = "1")]
        pub query_id: ::prost::alloc::string::String,
        /// The query text executed.
        #[prost(string, tag = "2")]
        pub query_text: ::prost::alloc::string::String,
        /// Query Execution engine.
        #[prost(enumeration = "query_detail::Engine", tag = "3")]
        pub engine: i32,
        /// Time taken for execution of the query.
        #[prost(message, optional, tag = "4")]
        pub duration: ::core::option::Option<::prost_types::Duration>,
        /// The size of results the query produced.
        #[prost(int64, tag = "5")]
        pub result_size_bytes: i64,
        /// The data processed by the query.
        #[prost(int64, tag = "6")]
        pub data_processed_bytes: i64,
    }
    /// Nested message and enum types in `QueryDetail`.
    pub mod query_detail {
        /// Query Execution engine.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Engine {
            /// An unspecified Engine type.
            Unspecified = 0,
            /// Spark-sql engine is specified in Query.
            SparkSql = 1,
            /// BigQuery engine is specified in Query.
            Bigquery = 2,
        }
        impl Engine {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "ENGINE_UNSPECIFIED",
                    Self::SparkSql => "SPARK_SQL",
                    Self::Bigquery => "BIGQUERY",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ENGINE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SPARK_SQL" => Some(Self::SparkSql),
                    "BIGQUERY" => Some(Self::Bigquery),
                    _ => None,
                }
            }
        }
    }
    /// The type of the event.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EventType {
        /// An unspecified event type.
        Unspecified = 0,
        /// Event when the session is assigned to a user.
        Start = 1,
        /// Event for stop of a session.
        Stop = 2,
        /// Query events in the session.
        Query = 3,
        /// Event for creation of a cluster. It is not yet assigned to a user.
        /// This comes before START in the sequence
        Create = 4,
    }
    impl EventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EVENT_TYPE_UNSPECIFIED",
                Self::Start => "START",
                Self::Stop => "STOP",
                Self::Query => "QUERY",
                Self::Create => "CREATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "START" => Some(Self::Start),
                "STOP" => Some(Self::Stop),
                "QUERY" => Some(Self::Query),
                "CREATE" => Some(Self::Create),
                _ => None,
            }
        }
    }
    /// Additional information about the Query metadata.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        /// The execution details of the query.
        #[prost(message, tag = "5")]
        Query(QueryDetail),
    }
}
/// Payload associated with Governance related log events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GovernanceEvent {
    /// The log message.
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    /// The type of the event.
    #[prost(enumeration = "governance_event::EventType", tag = "2")]
    pub event_type: i32,
    /// Entity resource information if the log event is associated with a
    /// specific entity.
    #[prost(message, optional, tag = "3")]
    pub entity: ::core::option::Option<governance_event::Entity>,
}
/// Nested message and enum types in `GovernanceEvent`.
pub mod governance_event {
    /// Information about Entity resource that the log event is associated with.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entity {
        /// The Entity resource the log event is associated with.
        /// Format:
        /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}`
        #[prost(string, tag = "1")]
        pub entity: ::prost::alloc::string::String,
        /// Type of entity.
        #[prost(enumeration = "entity::EntityType", tag = "2")]
        pub entity_type: i32,
    }
    /// Nested message and enum types in `Entity`.
    pub mod entity {
        /// Type of entity.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum EntityType {
            /// An unspecified Entity type.
            Unspecified = 0,
            /// Table entity type.
            Table = 1,
            /// Fileset entity type.
            Fileset = 2,
        }
        impl EntityType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "ENTITY_TYPE_UNSPECIFIED",
                    Self::Table => "TABLE",
                    Self::Fileset => "FILESET",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ENTITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "TABLE" => Some(Self::Table),
                    "FILESET" => Some(Self::Fileset),
                    _ => None,
                }
            }
        }
    }
    /// Type of governance log event.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EventType {
        /// An unspecified event type.
        Unspecified = 0,
        /// Resource IAM policy update event.
        ResourceIamPolicyUpdate = 1,
        /// BigQuery table create event.
        BigqueryTableCreate = 2,
        /// BigQuery table update event.
        BigqueryTableUpdate = 3,
        /// BigQuery table delete event.
        BigqueryTableDelete = 4,
        /// BigQuery connection create event.
        BigqueryConnectionCreate = 5,
        /// BigQuery connection update event.
        BigqueryConnectionUpdate = 6,
        /// BigQuery connection delete event.
        BigqueryConnectionDelete = 7,
        /// BigQuery taxonomy created.
        BigqueryTaxonomyCreate = 10,
        /// BigQuery policy tag created.
        BigqueryPolicyTagCreate = 11,
        /// BigQuery policy tag deleted.
        BigqueryPolicyTagDelete = 12,
        /// BigQuery set iam policy for policy tag.
        BigqueryPolicyTagSetIamPolicy = 13,
        /// Access policy update event.
        AccessPolicyUpdate = 14,
        /// Number of resources matched with particular Query.
        GovernanceRuleMatchedResources = 15,
        /// Rule processing exceeds the allowed limit.
        GovernanceRuleSearchLimitExceeds = 16,
        /// Rule processing errors.
        GovernanceRuleErrors = 17,
        /// Governance rule processing Event.
        GovernanceRuleProcessing = 18,
    }
    impl EventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EVENT_TYPE_UNSPECIFIED",
                Self::ResourceIamPolicyUpdate => "RESOURCE_IAM_POLICY_UPDATE",
                Self::BigqueryTableCreate => "BIGQUERY_TABLE_CREATE",
                Self::BigqueryTableUpdate => "BIGQUERY_TABLE_UPDATE",
                Self::BigqueryTableDelete => "BIGQUERY_TABLE_DELETE",
                Self::BigqueryConnectionCreate => "BIGQUERY_CONNECTION_CREATE",
                Self::BigqueryConnectionUpdate => "BIGQUERY_CONNECTION_UPDATE",
                Self::BigqueryConnectionDelete => "BIGQUERY_CONNECTION_DELETE",
                Self::BigqueryTaxonomyCreate => "BIGQUERY_TAXONOMY_CREATE",
                Self::BigqueryPolicyTagCreate => "BIGQUERY_POLICY_TAG_CREATE",
                Self::BigqueryPolicyTagDelete => "BIGQUERY_POLICY_TAG_DELETE",
                Self::BigqueryPolicyTagSetIamPolicy => {
                    "BIGQUERY_POLICY_TAG_SET_IAM_POLICY"
                }
                Self::AccessPolicyUpdate => "ACCESS_POLICY_UPDATE",
                Self::GovernanceRuleMatchedResources => {
                    "GOVERNANCE_RULE_MATCHED_RESOURCES"
                }
                Self::GovernanceRuleSearchLimitExceeds => {
                    "GOVERNANCE_RULE_SEARCH_LIMIT_EXCEEDS"
                }
                Self::GovernanceRuleErrors => "GOVERNANCE_RULE_ERRORS",
                Self::GovernanceRuleProcessing => "GOVERNANCE_RULE_PROCESSING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "RESOURCE_IAM_POLICY_UPDATE" => Some(Self::ResourceIamPolicyUpdate),
                "BIGQUERY_TABLE_CREATE" => Some(Self::BigqueryTableCreate),
                "BIGQUERY_TABLE_UPDATE" => Some(Self::BigqueryTableUpdate),
                "BIGQUERY_TABLE_DELETE" => Some(Self::BigqueryTableDelete),
                "BIGQUERY_CONNECTION_CREATE" => Some(Self::BigqueryConnectionCreate),
                "BIGQUERY_CONNECTION_UPDATE" => Some(Self::BigqueryConnectionUpdate),
                "BIGQUERY_CONNECTION_DELETE" => Some(Self::BigqueryConnectionDelete),
                "BIGQUERY_TAXONOMY_CREATE" => Some(Self::BigqueryTaxonomyCreate),
                "BIGQUERY_POLICY_TAG_CREATE" => Some(Self::BigqueryPolicyTagCreate),
                "BIGQUERY_POLICY_TAG_DELETE" => Some(Self::BigqueryPolicyTagDelete),
                "BIGQUERY_POLICY_TAG_SET_IAM_POLICY" => {
                    Some(Self::BigqueryPolicyTagSetIamPolicy)
                }
                "ACCESS_POLICY_UPDATE" => Some(Self::AccessPolicyUpdate),
                "GOVERNANCE_RULE_MATCHED_RESOURCES" => {
                    Some(Self::GovernanceRuleMatchedResources)
                }
                "GOVERNANCE_RULE_SEARCH_LIMIT_EXCEEDS" => {
                    Some(Self::GovernanceRuleSearchLimitExceeds)
                }
                "GOVERNANCE_RULE_ERRORS" => Some(Self::GovernanceRuleErrors),
                "GOVERNANCE_RULE_PROCESSING" => Some(Self::GovernanceRuleProcessing),
                _ => None,
            }
        }
    }
}
/// These messages contain information about the execution of a datascan.
/// The monitored resource is 'DataScan'
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataScanEvent {
    /// The data source of the data scan
    #[prost(string, tag = "1")]
    pub data_source: ::prost::alloc::string::String,
    /// The identifier of the specific data scan job this log entry is for.
    #[prost(string, tag = "2")]
    pub job_id: ::prost::alloc::string::String,
    /// The time when the data scan job was created.
    #[prost(message, optional, tag = "12")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time when the data scan job started to run.
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time when the data scan job finished.
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The type of the data scan.
    #[prost(enumeration = "data_scan_event::ScanType", tag = "5")]
    pub r#type: i32,
    /// The status of the data scan job.
    #[prost(enumeration = "data_scan_event::State", tag = "6")]
    pub state: i32,
    /// The message describing the data scan job event.
    #[prost(string, tag = "7")]
    pub message: ::prost::alloc::string::String,
    /// A version identifier of the spec which was used to execute this job.
    #[prost(string, tag = "8")]
    pub spec_version: ::prost::alloc::string::String,
    /// The trigger type of the data scan job.
    #[prost(enumeration = "data_scan_event::Trigger", tag = "9")]
    pub trigger: i32,
    /// The scope of the data scan (e.g. full, incremental).
    #[prost(enumeration = "data_scan_event::Scope", tag = "10")]
    pub scope: i32,
    /// The result of post scan actions.
    #[prost(message, optional, tag = "11")]
    pub post_scan_actions_result: ::core::option::Option<
        data_scan_event::PostScanActionsResult,
    >,
    /// The result of the data scan job.
    #[prost(oneof = "data_scan_event::Result", tags = "101, 102")]
    pub result: ::core::option::Option<data_scan_event::Result>,
    /// The applied configs in the data scan job.
    #[prost(oneof = "data_scan_event::AppliedConfigs", tags = "201, 202")]
    pub applied_configs: ::core::option::Option<data_scan_event::AppliedConfigs>,
}
/// Nested message and enum types in `DataScanEvent`.
pub mod data_scan_event {
    /// Data profile result for data scan job.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DataProfileResult {
        /// The count of rows processed in the data scan job.
        #[prost(int64, tag = "1")]
        pub row_count: i64,
    }
    /// Data quality result for data scan job.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DataQualityResult {
        /// The count of rows processed in the data scan job.
        #[prost(int64, tag = "1")]
        pub row_count: i64,
        /// Whether the data quality result was `pass` or not.
        #[prost(bool, tag = "2")]
        pub passed: bool,
        /// The result of each dimension for data quality result.
        /// The key of the map is the name of the dimension.
        /// The value is the bool value depicting whether the dimension result was
        /// `pass` or not.
        #[prost(map = "string, bool", tag = "3")]
        pub dimension_passed: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            bool,
        >,
        /// The table-level data quality score for the data scan job.
        ///
        /// The data quality score ranges between \[0, 100\] (up to two decimal
        /// points).
        #[prost(float, tag = "4")]
        pub score: f32,
        /// The score of each dimension for data quality result.
        /// The key of the map is the name of the dimension.
        /// The value is the data quality score for the dimension.
        ///
        /// The score ranges between \[0, 100\] (up to two decimal
        /// points).
        #[prost(map = "string, float", tag = "5")]
        pub dimension_score: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            f32,
        >,
        /// The score of each column scanned in the data scan job.
        /// The key of the map is the name of the column.
        /// The value is the data quality score for the column.
        ///
        /// The score ranges between \[0, 100\] (up to two decimal
        /// points).
        #[prost(map = "string, float", tag = "6")]
        pub column_score: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            f32,
        >,
    }
    /// Applied configs for data profile type data scan job.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DataProfileAppliedConfigs {
        /// The percentage of the records selected from the dataset for DataScan.
        ///
        /// * Value ranges between 0.0 and 100.0.
        /// * Value 0.0 or 100.0 imply that sampling was not applied.
        #[prost(float, tag = "1")]
        pub sampling_percent: f32,
        /// Boolean indicating whether a row filter was applied in the DataScan job.
        #[prost(bool, tag = "2")]
        pub row_filter_applied: bool,
        /// Boolean indicating whether a column filter was applied in the DataScan
        /// job.
        #[prost(bool, tag = "3")]
        pub column_filter_applied: bool,
    }
    /// Applied configs for data quality type data scan job.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DataQualityAppliedConfigs {
        /// The percentage of the records selected from the dataset for DataScan.
        ///
        /// * Value ranges between 0.0 and 100.0.
        /// * Value 0.0 or 100.0 imply that sampling was not applied.
        #[prost(float, tag = "1")]
        pub sampling_percent: f32,
        /// Boolean indicating whether a row filter was applied in the DataScan job.
        #[prost(bool, tag = "2")]
        pub row_filter_applied: bool,
    }
    /// Post scan actions result for data scan job.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PostScanActionsResult {
        /// The result of BigQuery export post scan action.
        #[prost(message, optional, tag = "1")]
        pub bigquery_export_result: ::core::option::Option<
            post_scan_actions_result::BigQueryExportResult,
        >,
    }
    /// Nested message and enum types in `PostScanActionsResult`.
    pub mod post_scan_actions_result {
        /// The result of BigQuery export post scan action.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct BigQueryExportResult {
            /// Execution state for the BigQuery exporting.
            #[prost(enumeration = "big_query_export_result::State", tag = "1")]
            pub state: i32,
            /// Additional information about the BigQuery exporting.
            #[prost(string, tag = "2")]
            pub message: ::prost::alloc::string::String,
        }
        /// Nested message and enum types in `BigQueryExportResult`.
        pub mod big_query_export_result {
            /// Execution state for the exporting.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum State {
                /// The exporting state is unspecified.
                Unspecified = 0,
                /// The exporting completed successfully.
                Succeeded = 1,
                /// The exporting is no longer running due to an error.
                Failed = 2,
                /// The exporting is skipped due to no valid scan result to export
                /// (usually caused by scan failed).
                Skipped = 3,
            }
            impl State {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "STATE_UNSPECIFIED",
                        Self::Succeeded => "SUCCEEDED",
                        Self::Failed => "FAILED",
                        Self::Skipped => "SKIPPED",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                        "SUCCEEDED" => Some(Self::Succeeded),
                        "FAILED" => Some(Self::Failed),
                        "SKIPPED" => Some(Self::Skipped),
                        _ => None,
                    }
                }
            }
        }
    }
    /// The type of the data scan.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ScanType {
        /// An unspecified data scan type.
        Unspecified = 0,
        /// Data scan for data profile.
        DataProfile = 1,
        /// Data scan for data quality.
        DataQuality = 2,
        /// Data scan for data discovery.
        DataDiscovery = 4,
    }
    impl ScanType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SCAN_TYPE_UNSPECIFIED",
                Self::DataProfile => "DATA_PROFILE",
                Self::DataQuality => "DATA_QUALITY",
                Self::DataDiscovery => "DATA_DISCOVERY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCAN_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "DATA_PROFILE" => Some(Self::DataProfile),
                "DATA_QUALITY" => Some(Self::DataQuality),
                "DATA_DISCOVERY" => Some(Self::DataDiscovery),
                _ => None,
            }
        }
    }
    /// The job state of the data scan.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unspecified job state.
        Unspecified = 0,
        /// Data scan job started.
        Started = 1,
        /// Data scan job successfully completed.
        Succeeded = 2,
        /// Data scan job was unsuccessful.
        Failed = 3,
        /// Data scan job was cancelled.
        Cancelled = 4,
        /// Data scan job was createed.
        Created = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Started => "STARTED",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::Cancelled => "CANCELLED",
                Self::Created => "CREATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "STARTED" => Some(Self::Started),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "CANCELLED" => Some(Self::Cancelled),
                "CREATED" => Some(Self::Created),
                _ => None,
            }
        }
    }
    /// The trigger type for the data scan.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Trigger {
        /// An unspecified trigger type.
        Unspecified = 0,
        /// Data scan triggers on demand.
        OnDemand = 1,
        /// Data scan triggers as per schedule.
        Schedule = 2,
    }
    impl Trigger {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TRIGGER_UNSPECIFIED",
                Self::OnDemand => "ON_DEMAND",
                Self::Schedule => "SCHEDULE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRIGGER_UNSPECIFIED" => Some(Self::Unspecified),
                "ON_DEMAND" => Some(Self::OnDemand),
                "SCHEDULE" => Some(Self::Schedule),
                _ => None,
            }
        }
    }
    /// The scope of job for the data scan.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Scope {
        /// An unspecified scope type.
        Unspecified = 0,
        /// Data scan runs on all of the data.
        Full = 1,
        /// Data scan runs on incremental data.
        Incremental = 2,
    }
    impl Scope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SCOPE_UNSPECIFIED",
                Self::Full => "FULL",
                Self::Incremental => "INCREMENTAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
                "FULL" => Some(Self::Full),
                "INCREMENTAL" => Some(Self::Incremental),
                _ => None,
            }
        }
    }
    /// The result of the data scan job.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        /// Data profile result for data profile type data scan.
        #[prost(message, tag = "101")]
        DataProfile(DataProfileResult),
        /// Data quality result for data quality type data scan.
        #[prost(message, tag = "102")]
        DataQuality(DataQualityResult),
    }
    /// The applied configs in the data scan job.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum AppliedConfigs {
        /// Applied configs for data profile type data scan.
        #[prost(message, tag = "201")]
        DataProfileConfigs(DataProfileAppliedConfigs),
        /// Applied configs for data quality type data scan.
        #[prost(message, tag = "202")]
        DataQualityConfigs(DataQualityAppliedConfigs),
    }
}
/// Information about the result of a data quality rule for data quality scan.
/// The monitored resource is 'DataScan'.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQualityScanRuleResult {
    /// Identifier of the specific data scan job this log entry is for.
    #[prost(string, tag = "1")]
    pub job_id: ::prost::alloc::string::String,
    /// The data source of the data scan (e.g. BigQuery table name).
    #[prost(string, tag = "2")]
    pub data_source: ::prost::alloc::string::String,
    /// The column which this rule is evaluated against.
    #[prost(string, tag = "3")]
    pub column: ::prost::alloc::string::String,
    /// The name of the data quality rule.
    #[prost(string, tag = "4")]
    pub rule_name: ::prost::alloc::string::String,
    /// The type of the data quality rule.
    #[prost(enumeration = "data_quality_scan_rule_result::RuleType", tag = "5")]
    pub rule_type: i32,
    /// The evaluation type of the data quality rule.
    #[prost(enumeration = "data_quality_scan_rule_result::EvaluationType", tag = "6")]
    pub evalution_type: i32,
    /// The dimension of the data quality rule.
    #[prost(string, tag = "7")]
    pub rule_dimension: ::prost::alloc::string::String,
    /// The passing threshold (\[0.0, 100.0\]) of the data quality rule.
    #[prost(double, tag = "8")]
    pub threshold_percent: f64,
    /// The result of the data quality rule.
    #[prost(enumeration = "data_quality_scan_rule_result::Result", tag = "9")]
    pub result: i32,
    /// The number of rows evaluated against the data quality rule.
    /// This field is only valid for rules of PER_ROW evaluation type.
    #[prost(int64, tag = "10")]
    pub evaluated_row_count: i64,
    /// The number of rows which passed a rule evaluation.
    /// This field is only valid for rules of PER_ROW evaluation type.
    #[prost(int64, tag = "11")]
    pub passed_row_count: i64,
    /// The number of rows with null values in the specified column.
    #[prost(int64, tag = "12")]
    pub null_row_count: i64,
    /// The number of rows returned by the SQL statement in a SQL assertion rule.
    /// This field is only valid for SQL assertion rules.
    #[prost(int64, tag = "13")]
    pub assertion_row_count: i64,
}
/// Nested message and enum types in `DataQualityScanRuleResult`.
pub mod data_quality_scan_rule_result {
    /// The type of the data quality rule.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RuleType {
        /// An unspecified rule type.
        Unspecified = 0,
        /// See
        /// [DataQualityRule.NonNullExpectation][google.cloud.dataplex.v1.DataQualityRule.NonNullExpectation].
        NonNullExpectation = 1,
        /// See
        /// [DataQualityRule.RangeExpectation][google.cloud.dataplex.v1.DataQualityRule.RangeExpectation].
        RangeExpectation = 2,
        /// See
        /// [DataQualityRule.RegexExpectation][google.cloud.dataplex.v1.DataQualityRule.RegexExpectation].
        RegexExpectation = 3,
        /// See
        /// [DataQualityRule.RowConditionExpectation][google.cloud.dataplex.v1.DataQualityRule.RowConditionExpectation].
        RowConditionExpectation = 4,
        /// See
        /// [DataQualityRule.SetExpectation][google.cloud.dataplex.v1.DataQualityRule.SetExpectation].
        SetExpectation = 5,
        /// See
        /// [DataQualityRule.StatisticRangeExpectation][google.cloud.dataplex.v1.DataQualityRule.StatisticRangeExpectation].
        StatisticRangeExpectation = 6,
        /// See
        /// [DataQualityRule.TableConditionExpectation][google.cloud.dataplex.v1.DataQualityRule.TableConditionExpectation].
        TableConditionExpectation = 7,
        /// See
        /// [DataQualityRule.UniquenessExpectation][google.cloud.dataplex.v1.DataQualityRule.UniquenessExpectation].
        UniquenessExpectation = 8,
        /// See
        /// [DataQualityRule.SqlAssertion][google.cloud.dataplex.v1.DataQualityRule.SqlAssertion].
        SqlAssertion = 9,
    }
    impl RuleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RULE_TYPE_UNSPECIFIED",
                Self::NonNullExpectation => "NON_NULL_EXPECTATION",
                Self::RangeExpectation => "RANGE_EXPECTATION",
                Self::RegexExpectation => "REGEX_EXPECTATION",
                Self::RowConditionExpectation => "ROW_CONDITION_EXPECTATION",
                Self::SetExpectation => "SET_EXPECTATION",
                Self::StatisticRangeExpectation => "STATISTIC_RANGE_EXPECTATION",
                Self::TableConditionExpectation => "TABLE_CONDITION_EXPECTATION",
                Self::UniquenessExpectation => "UNIQUENESS_EXPECTATION",
                Self::SqlAssertion => "SQL_ASSERTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RULE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NON_NULL_EXPECTATION" => Some(Self::NonNullExpectation),
                "RANGE_EXPECTATION" => Some(Self::RangeExpectation),
                "REGEX_EXPECTATION" => Some(Self::RegexExpectation),
                "ROW_CONDITION_EXPECTATION" => Some(Self::RowConditionExpectation),
                "SET_EXPECTATION" => Some(Self::SetExpectation),
                "STATISTIC_RANGE_EXPECTATION" => Some(Self::StatisticRangeExpectation),
                "TABLE_CONDITION_EXPECTATION" => Some(Self::TableConditionExpectation),
                "UNIQUENESS_EXPECTATION" => Some(Self::UniquenessExpectation),
                "SQL_ASSERTION" => Some(Self::SqlAssertion),
                _ => None,
            }
        }
    }
    /// The evaluation type of the data quality rule.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EvaluationType {
        /// An unspecified evaluation type.
        Unspecified = 0,
        /// The rule evaluation is done at per row level.
        PerRow = 1,
        /// The rule evaluation is done for an aggregate of rows.
        Aggregate = 2,
    }
    impl EvaluationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EVALUATION_TYPE_UNSPECIFIED",
                Self::PerRow => "PER_ROW",
                Self::Aggregate => "AGGREGATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVALUATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PER_ROW" => Some(Self::PerRow),
                "AGGREGATE" => Some(Self::Aggregate),
                _ => None,
            }
        }
    }
    /// Whether the data quality rule passed or failed.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Result {
        /// An unspecified result.
        Unspecified = 0,
        /// The data quality rule passed.
        Passed = 1,
        /// The data quality rule failed.
        Failed = 2,
    }
    impl Result {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESULT_UNSPECIFIED",
                Self::Passed => "PASSED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESULT_UNSPECIFIED" => Some(Self::Unspecified),
                "PASSED" => Some(Self::Passed),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Create a metadata entity request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEntityRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Entity resource.
    #[prost(message, optional, tag = "3")]
    pub entity: ::core::option::Option<Entity>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Update a metadata entity request.
/// The exiting entity will be fully replaced by the entity in the request.
/// The entity ID is mutable. To modify the ID, use the current entity ID in the
/// request URL and specify the new ID in the request body.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEntityRequest {
    /// Required. Update description.
    #[prost(message, optional, tag = "2")]
    pub entity: ::core::option::Option<Entity>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// Delete a metadata entity request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEntityRequest {
    /// Required. The resource name of the entity:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The etag associated with the entity, which can be retrieved with
    /// a [GetEntity][] request.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// List metadata entities request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntitiesRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Specify the entity view to make a partial list request.
    #[prost(enumeration = "list_entities_request::EntityView", tag = "2")]
    pub view: i32,
    /// Optional. Maximum number of entities to return. The service may return
    /// fewer than this value. If unspecified, 100 entities will be returned by
    /// default. The maximum value is 500; larger values will will be truncated to
    /// 500.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListEntities` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListEntities` must match the call that provided the
    /// page token.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. The following filter parameters can be added to the URL to limit
    /// the entities returned by the API:
    ///
    /// - Entity ID: ?filter="id=entityID"
    /// - Asset ID: ?filter="asset=assetID"
    /// - Data path ?filter="data_path=gs://my-bucket"
    /// - Is HIVE compatible: ?filter="hive_compatible=true"
    /// - Is BigQuery compatible: ?filter="bigquery_compatible=true"
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ListEntitiesRequest`.
pub mod list_entities_request {
    /// Entity views.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EntityView {
        /// The default unset value. Return both table and fileset entities
        /// if unspecified.
        Unspecified = 0,
        /// Only list table entities.
        Tables = 1,
        /// Only list fileset entities.
        Filesets = 2,
    }
    impl EntityView {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ENTITY_VIEW_UNSPECIFIED",
                Self::Tables => "TABLES",
                Self::Filesets => "FILESETS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENTITY_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
                "TABLES" => Some(Self::Tables),
                "FILESETS" => Some(Self::Filesets),
                _ => None,
            }
        }
    }
}
/// List metadata entities response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntitiesResponse {
    /// Entities in the specified parent zone.
    #[prost(message, repeated, tag = "1")]
    pub entities: ::prost::alloc::vec::Vec<Entity>,
    /// Token to retrieve the next page of results, or empty if there are no
    /// remaining results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Get metadata entity request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEntityRequest {
    /// Required. The resource name of the entity:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}.`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Used to select the subset of entity information to return.
    /// Defaults to `BASIC`.
    #[prost(enumeration = "get_entity_request::EntityView", tag = "2")]
    pub view: i32,
}
/// Nested message and enum types in `GetEntityRequest`.
pub mod get_entity_request {
    /// Entity views for get entity partial result.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EntityView {
        /// The API will default to the `BASIC` view.
        Unspecified = 0,
        /// Minimal view that does not include the schema.
        Basic = 1,
        /// Include basic information and schema.
        Schema = 2,
        /// Include everything. Currently, this is the same as the SCHEMA view.
        Full = 4,
    }
    impl EntityView {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ENTITY_VIEW_UNSPECIFIED",
                Self::Basic => "BASIC",
                Self::Schema => "SCHEMA",
                Self::Full => "FULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENTITY_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
                "BASIC" => Some(Self::Basic),
                "SCHEMA" => Some(Self::Schema),
                "FULL" => Some(Self::Full),
                _ => None,
            }
        }
    }
}
/// List metadata partitions request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPartitionsRequest {
    /// Required. The resource name of the parent entity:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of partitions to return. The service may return
    /// fewer than this value. If unspecified, 100 partitions will be returned by
    /// default. The maximum page size is 500; larger values will will be truncated
    /// to 500.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Page token received from a previous `ListPartitions` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListPartitions` must match the call that provided
    /// the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter the partitions returned to the caller using a key value
    /// pair expression. Supported operators and syntax:
    ///
    /// - logic operators: AND, OR
    /// - comparison operators: <, >, >=, <= ,=, !=
    /// - LIKE operators:
    ///    - The right hand of a LIKE operator supports "." and
    ///      "*" for wildcard searches, for example "value1 LIKE ".*oo.*"
    /// - parenthetical grouping: ( )
    ///
    /// Sample filter expression: `?filter="key1 < value1 OR key2 > value2"
    ///
    /// **Notes:**
    ///
    /// - Keys to the left of operators are case insensitive.
    /// - Partition results are sorted first by creation time, then by
    ///    lexicographic order.
    /// - Up to 20 key value filter pairs are allowed, but due to performance
    ///    considerations, only the first 10 will be used as a filter.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// Create metadata partition request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePartitionRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Partition resource.
    #[prost(message, optional, tag = "3")]
    pub partition: ::core::option::Option<Partition>,
    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Delete metadata partition request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePartitionRequest {
    /// Required. The resource name of the partition.
    /// format:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}/partitions/{partition_value_path}`.
    /// The {partition_value_path} segment consists of an ordered sequence of
    /// partition values separated by "/". All values must be provided.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The etag associated with the partition.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// List metadata partitions response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPartitionsResponse {
    /// Partitions under the specified parent entity.
    #[prost(message, repeated, tag = "1")]
    pub partitions: ::prost::alloc::vec::Vec<Partition>,
    /// Token to retrieve the next page of results, or empty if there are no
    /// remaining results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Get metadata partition request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPartitionRequest {
    /// Required. The resource name of the partition:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}/partitions/{partition_value_path}`.
    /// The {partition_value_path} segment consists of an ordered sequence of
    /// partition values separated by "/". All values must be provided.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Represents tables and fileset metadata contained within a zone.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entity {
    /// Output only. The resource name of the entity, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Display name must be shorter than or equal to 256 characters.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. User friendly longer description text. Must be shorter than or
    /// equal to 1024 characters.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The time when the entity was created.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the entity was last updated.
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. A user-provided entity ID. It is mutable, and will be used as the
    /// published table name. Specifying a new ID in an update entity
    /// request will override the existing value.
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), and
    /// underscores, and consist of 256 or fewer characters.
    #[prost(string, tag = "7")]
    pub id: ::prost::alloc::string::String,
    /// Optional. The etag associated with the entity, which can be retrieved with
    /// a [GetEntity][] request. Required for update and delete requests.
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    /// Required. Immutable. The type of entity.
    #[prost(enumeration = "entity::Type", tag = "10")]
    pub r#type: i32,
    /// Required. Immutable. The ID of the asset associated with the storage
    /// location containing the entity data. The entity must be with in the same
    /// zone with the asset.
    #[prost(string, tag = "11")]
    pub asset: ::prost::alloc::string::String,
    /// Required. Immutable. The storage path of the entity data.
    /// For Cloud Storage data, this is the fully-qualified path to the entity,
    /// such as `gs://bucket/path/to/data`. For BigQuery data, this is the name of
    /// the table resource, such as
    /// `projects/project_id/datasets/dataset_id/tables/table_id`.
    #[prost(string, tag = "12")]
    pub data_path: ::prost::alloc::string::String,
    /// Optional. The set of items within the data path constituting the data in
    /// the entity, represented as a glob path. Example:
    /// `gs://bucket/path/to/data/**/*.csv`.
    #[prost(string, tag = "13")]
    pub data_path_pattern: ::prost::alloc::string::String,
    /// Output only. The name of the associated Data Catalog entry.
    #[prost(string, tag = "14")]
    pub catalog_entry: ::prost::alloc::string::String,
    /// Required. Immutable. Identifies the storage system of the entity data.
    #[prost(enumeration = "StorageSystem", tag = "15")]
    pub system: i32,
    /// Required. Identifies the storage format of the entity data.
    /// It does not apply to entities with data stored in BigQuery.
    #[prost(message, optional, tag = "16")]
    pub format: ::core::option::Option<StorageFormat>,
    /// Output only. Metadata stores that the entity is compatible with.
    #[prost(message, optional, tag = "19")]
    pub compatibility: ::core::option::Option<entity::CompatibilityStatus>,
    /// Output only. Identifies the access mechanism to the entity. Not user
    /// settable.
    #[prost(message, optional, tag = "21")]
    pub access: ::core::option::Option<StorageAccess>,
    /// Output only. System generated unique ID for the Entity. This ID will be
    /// different if the Entity is deleted and re-created with the same name.
    #[prost(string, tag = "22")]
    pub uid: ::prost::alloc::string::String,
    /// Required. The description of the data structure and layout.
    /// The schema is not included in list responses. It is only included in
    /// `SCHEMA` and `FULL` entity views of a `GetEntity` response.
    #[prost(message, optional, tag = "50")]
    pub schema: ::core::option::Option<Schema>,
}
/// Nested message and enum types in `Entity`.
pub mod entity {
    /// Provides compatibility information for various metadata stores.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CompatibilityStatus {
        /// Output only. Whether this entity is compatible with Hive Metastore.
        #[prost(message, optional, tag = "1")]
        pub hive_metastore: ::core::option::Option<compatibility_status::Compatibility>,
        /// Output only. Whether this entity is compatible with BigQuery.
        #[prost(message, optional, tag = "2")]
        pub bigquery: ::core::option::Option<compatibility_status::Compatibility>,
    }
    /// Nested message and enum types in `CompatibilityStatus`.
    pub mod compatibility_status {
        /// Provides compatibility information for a specific metadata store.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Compatibility {
            /// Output only. Whether the entity is compatible and can be represented in
            /// the metadata store.
            #[prost(bool, tag = "1")]
            pub compatible: bool,
            /// Output only. Provides additional detail if the entity is incompatible
            /// with the metadata store.
            #[prost(string, tag = "2")]
            pub reason: ::prost::alloc::string::String,
        }
    }
    /// The type of entity.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Type unspecified.
        Unspecified = 0,
        /// Structured and semi-structured data.
        Table = 1,
        /// Unstructured data.
        Fileset = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Table => "TABLE",
                Self::Fileset => "FILESET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TABLE" => Some(Self::Table),
                "FILESET" => Some(Self::Fileset),
                _ => None,
            }
        }
    }
}
/// Represents partition metadata contained within entity instances.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Partition {
    /// Output only. Partition values used in the HTTP URL must be
    /// double encoded. For example, `url_encode(url_encode(value))` can be used
    /// to encode "US:CA/CA#Sunnyvale so that the request URL ends
    /// with "/partitions/US%253ACA/CA%2523Sunnyvale".
    /// The name field in the response retains the encoded format.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Immutable. The set of values representing the partition, which
    /// correspond to the partition schema defined in the parent entity.
    #[prost(string, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required. Immutable. The location of the entity data within the partition,
    /// for example, `gs://bucket/path/to/entity/key1=value1/key2=value2`. Or
    /// `projects/<project_id>/datasets/<dataset_id>/tables/<table_id>`
    #[prost(string, tag = "3")]
    pub location: ::prost::alloc::string::String,
    /// Optional. The etag for this partition.
    #[deprecated]
    #[prost(string, tag = "4")]
    pub etag: ::prost::alloc::string::String,
}
/// Schema information describing the structure and layout of the data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    /// Required. Set to `true` if user-managed or `false` if managed by Dataplex.
    /// The default is `false` (managed by Dataplex).
    ///
    /// - Set to `false`to enable Dataplex discovery to update the schema.
    ///    including new data discovery, schema inference, and schema evolution.
    ///    Users retain the ability to input and edit the schema. Dataplex
    ///    treats schema input by the user as though produced
    ///    by a previous Dataplex discovery operation, and it will
    ///    evolve the schema and take action based on that treatment.
    ///
    /// - Set to `true` to fully manage the entity
    ///    schema. This setting guarantees that Dataplex will not
    ///    change schema fields.
    #[prost(bool, tag = "1")]
    pub user_managed: bool,
    /// Optional. The sequence of fields describing data in table entities.
    /// **Note:** BigQuery SchemaFields are immutable.
    #[prost(message, repeated, tag = "2")]
    pub fields: ::prost::alloc::vec::Vec<schema::SchemaField>,
    /// Optional. The sequence of fields describing the partition structure in
    /// entities. If this field is empty, there are no partitions within the data.
    #[prost(message, repeated, tag = "3")]
    pub partition_fields: ::prost::alloc::vec::Vec<schema::PartitionField>,
    /// Optional. The structure of paths containing partition data within the
    /// entity.
    #[prost(enumeration = "schema::PartitionStyle", tag = "4")]
    pub partition_style: i32,
}
/// Nested message and enum types in `Schema`.
pub mod schema {
    /// Represents a column field within a table schema.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SchemaField {
        /// Required. The name of the field. Must contain only letters, numbers and
        /// underscores, with a maximum length of 767 characters,
        /// and must begin with a letter or underscore.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Optional. User friendly field description. Must be less than or equal to
        /// 1024 characters.
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
        /// Required. The type of field.
        #[prost(enumeration = "Type", tag = "3")]
        pub r#type: i32,
        /// Required. Additional field semantics.
        #[prost(enumeration = "Mode", tag = "4")]
        pub mode: i32,
        /// Optional. Any nested field for complex types.
        #[prost(message, repeated, tag = "10")]
        pub fields: ::prost::alloc::vec::Vec<SchemaField>,
    }
    /// Represents a key field within the entity's partition structure. You could
    /// have up to 20 partition fields, but only the first 10 partitions have the
    /// filtering ability due to performance consideration. **Note:**
    /// Partition fields are immutable.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PartitionField {
        /// Required. Partition field name must consist of letters, numbers, and
        /// underscores only, with a maximum of length of 256 characters, and must
        /// begin with a letter or underscore..
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Required. Immutable. The type of field.
        #[prost(enumeration = "Type", tag = "2")]
        pub r#type: i32,
    }
    /// Type information for fields in schemas and partition schemas.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// SchemaType unspecified.
        Unspecified = 0,
        /// Boolean field.
        Boolean = 1,
        /// Single byte numeric field.
        Byte = 2,
        /// 16-bit numeric field.
        Int16 = 3,
        /// 32-bit numeric field.
        Int32 = 4,
        /// 64-bit numeric field.
        Int64 = 5,
        /// Floating point numeric field.
        Float = 6,
        /// Double precision numeric field.
        Double = 7,
        /// Real value numeric field.
        Decimal = 8,
        /// Sequence of characters field.
        String = 9,
        /// Sequence of bytes field.
        Binary = 10,
        /// Date and time field.
        Timestamp = 11,
        /// Date field.
        Date = 12,
        /// Time field.
        Time = 13,
        /// Structured field. Nested fields that define the structure of the map.
        /// If all nested fields are nullable, this field represents a union.
        Record = 14,
        /// Null field that does not have values.
        Null = 100,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Boolean => "BOOLEAN",
                Self::Byte => "BYTE",
                Self::Int16 => "INT16",
                Self::Int32 => "INT32",
                Self::Int64 => "INT64",
                Self::Float => "FLOAT",
                Self::Double => "DOUBLE",
                Self::Decimal => "DECIMAL",
                Self::String => "STRING",
                Self::Binary => "BINARY",
                Self::Timestamp => "TIMESTAMP",
                Self::Date => "DATE",
                Self::Time => "TIME",
                Self::Record => "RECORD",
                Self::Null => "NULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BOOLEAN" => Some(Self::Boolean),
                "BYTE" => Some(Self::Byte),
                "INT16" => Some(Self::Int16),
                "INT32" => Some(Self::Int32),
                "INT64" => Some(Self::Int64),
                "FLOAT" => Some(Self::Float),
                "DOUBLE" => Some(Self::Double),
                "DECIMAL" => Some(Self::Decimal),
                "STRING" => Some(Self::String),
                "BINARY" => Some(Self::Binary),
                "TIMESTAMP" => Some(Self::Timestamp),
                "DATE" => Some(Self::Date),
                "TIME" => Some(Self::Time),
                "RECORD" => Some(Self::Record),
                "NULL" => Some(Self::Null),
                _ => None,
            }
        }
    }
    /// Additional qualifiers to define field semantics.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        /// Mode unspecified.
        Unspecified = 0,
        /// The field has required semantics.
        Required = 1,
        /// The field has optional semantics, and may be null.
        Nullable = 2,
        /// The field has repeated (0 or more) semantics, and is a list of values.
        Repeated = 3,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODE_UNSPECIFIED",
                Self::Required => "REQUIRED",
                Self::Nullable => "NULLABLE",
                Self::Repeated => "REPEATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "REQUIRED" => Some(Self::Required),
                "NULLABLE" => Some(Self::Nullable),
                "REPEATED" => Some(Self::Repeated),
                _ => None,
            }
        }
    }
    /// The structure of paths within the entity, which represent partitions.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PartitionStyle {
        /// PartitionStyle unspecified
        Unspecified = 0,
        /// Partitions are hive-compatible.
        /// Examples: `gs://bucket/path/to/table/dt=2019-10-31/lang=en`,
        /// `gs://bucket/path/to/table/dt=2019-10-31/lang=en/late`.
        HiveCompatible = 1,
    }
    impl PartitionStyle {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PARTITION_STYLE_UNSPECIFIED",
                Self::HiveCompatible => "HIVE_COMPATIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PARTITION_STYLE_UNSPECIFIED" => Some(Self::Unspecified),
                "HIVE_COMPATIBLE" => Some(Self::HiveCompatible),
                _ => None,
            }
        }
    }
}
/// Describes the format of the data within its storage location.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageFormat {
    /// Output only. The data format associated with the stored data, which
    /// represents content type values. The value is inferred from mime type.
    #[prost(enumeration = "storage_format::Format", tag = "1")]
    pub format: i32,
    /// Optional. The compression type associated with the stored data.
    /// If unspecified, the data is uncompressed.
    #[prost(enumeration = "storage_format::CompressionFormat", tag = "2")]
    pub compression_format: i32,
    /// Required. The mime type descriptor for the data. Must match the pattern
    /// {type}/{subtype}. Supported values:
    ///
    /// - application/x-parquet
    /// - application/x-avro
    /// - application/x-orc
    /// - application/x-tfrecord
    /// - application/x-parquet+iceberg
    /// - application/x-avro+iceberg
    /// - application/x-orc+iceberg
    /// - application/json
    /// - application/{subtypes}
    /// - text/csv
    /// - text/<subtypes>
    /// - image/{image subtype}
    /// - video/{video subtype}
    /// - audio/{audio subtype}
    #[prost(string, tag = "3")]
    pub mime_type: ::prost::alloc::string::String,
    /// Additional format-specific options.
    #[prost(oneof = "storage_format::Options", tags = "10, 11, 12")]
    pub options: ::core::option::Option<storage_format::Options>,
}
/// Nested message and enum types in `StorageFormat`.
pub mod storage_format {
    /// Describes CSV and similar semi-structured data formats.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CsvOptions {
        /// Optional. The character encoding of the data. Accepts "US-ASCII",
        /// "UTF-8", and "ISO-8859-1". Defaults to UTF-8 if unspecified.
        #[prost(string, tag = "1")]
        pub encoding: ::prost::alloc::string::String,
        /// Optional. The number of rows to interpret as header rows that should be
        /// skipped when reading data rows. Defaults to 0.
        #[prost(int32, tag = "2")]
        pub header_rows: i32,
        /// Optional. The delimiter used to separate values. Defaults to ','.
        #[prost(string, tag = "3")]
        pub delimiter: ::prost::alloc::string::String,
        /// Optional. The character used to quote column values. Accepts '"'
        /// (double quotation mark) or ''' (single quotation mark). Defaults to
        /// '"' (double quotation mark) if unspecified.
        #[prost(string, tag = "4")]
        pub quote: ::prost::alloc::string::String,
    }
    /// Describes JSON data format.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct JsonOptions {
        /// Optional. The character encoding of the data. Accepts "US-ASCII", "UTF-8"
        /// and "ISO-8859-1". Defaults to UTF-8 if not specified.
        #[prost(string, tag = "1")]
        pub encoding: ::prost::alloc::string::String,
    }
    /// Describes Iceberg data format.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IcebergOptions {
        /// Optional. The location of where the iceberg metadata is present, must be
        /// within the table path
        #[prost(string, tag = "1")]
        pub metadata_location: ::prost::alloc::string::String,
    }
    /// The specific file format of the data.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Format {
        /// Format unspecified.
        Unspecified = 0,
        /// Parquet-formatted structured data.
        Parquet = 1,
        /// Avro-formatted structured data.
        Avro = 2,
        /// Orc-formatted structured data.
        Orc = 3,
        /// Csv-formatted semi-structured data.
        Csv = 100,
        /// Json-formatted semi-structured data.
        Json = 101,
        /// Image data formats (such as jpg and png).
        Image = 200,
        /// Audio data formats (such as mp3, and wav).
        Audio = 201,
        /// Video data formats (such as mp4 and mpg).
        Video = 202,
        /// Textual data formats (such as txt and xml).
        Text = 203,
        /// TensorFlow record format.
        Tfrecord = 204,
        /// Data that doesn't match a specific format.
        Other = 1000,
        /// Data of an unknown format.
        Unknown = 1001,
    }
    impl Format {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FORMAT_UNSPECIFIED",
                Self::Parquet => "PARQUET",
                Self::Avro => "AVRO",
                Self::Orc => "ORC",
                Self::Csv => "CSV",
                Self::Json => "JSON",
                Self::Image => "IMAGE",
                Self::Audio => "AUDIO",
                Self::Video => "VIDEO",
                Self::Text => "TEXT",
                Self::Tfrecord => "TFRECORD",
                Self::Other => "OTHER",
                Self::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "PARQUET" => Some(Self::Parquet),
                "AVRO" => Some(Self::Avro),
                "ORC" => Some(Self::Orc),
                "CSV" => Some(Self::Csv),
                "JSON" => Some(Self::Json),
                "IMAGE" => Some(Self::Image),
                "AUDIO" => Some(Self::Audio),
                "VIDEO" => Some(Self::Video),
                "TEXT" => Some(Self::Text),
                "TFRECORD" => Some(Self::Tfrecord),
                "OTHER" => Some(Self::Other),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
    /// The specific compressed file format of the data.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CompressionFormat {
        /// CompressionFormat unspecified. Implies uncompressed data.
        Unspecified = 0,
        /// GZip compressed set of files.
        Gzip = 2,
        /// BZip2 compressed set of files.
        Bzip2 = 3,
    }
    impl CompressionFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "COMPRESSION_FORMAT_UNSPECIFIED",
                Self::Gzip => "GZIP",
                Self::Bzip2 => "BZIP2",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPRESSION_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "GZIP" => Some(Self::Gzip),
                "BZIP2" => Some(Self::Bzip2),
                _ => None,
            }
        }
    }
    /// Additional format-specific options.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Options {
        /// Optional. Additional information about CSV formatted data.
        #[prost(message, tag = "10")]
        Csv(CsvOptions),
        /// Optional. Additional information about CSV formatted data.
        #[prost(message, tag = "11")]
        Json(JsonOptions),
        /// Optional. Additional information about iceberg tables.
        #[prost(message, tag = "12")]
        Iceberg(IcebergOptions),
    }
}
/// Describes the access mechanism of the data within its storage location.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StorageAccess {
    /// Output only. Describes the read access mechanism of the data. Not user
    /// settable.
    #[prost(enumeration = "storage_access::AccessMode", tag = "21")]
    pub read: i32,
}
/// Nested message and enum types in `StorageAccess`.
pub mod storage_access {
    /// Access Mode determines how data stored within the Entity is read.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccessMode {
        /// Access mode unspecified.
        Unspecified = 0,
        /// Default. Data is accessed directly using storage APIs.
        Direct = 1,
        /// Data is accessed through a managed interface using BigQuery APIs.
        Managed = 2,
    }
    impl AccessMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ACCESS_MODE_UNSPECIFIED",
                Self::Direct => "DIRECT",
                Self::Managed => "MANAGED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACCESS_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "DIRECT" => Some(Self::Direct),
                "MANAGED" => Some(Self::Managed),
                _ => None,
            }
        }
    }
}
/// Identifies the cloud system that manages the data storage.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StorageSystem {
    /// Storage system unspecified.
    Unspecified = 0,
    /// The entity data is contained within a Cloud Storage bucket.
    CloudStorage = 1,
    /// The entity data is contained within a BigQuery dataset.
    Bigquery = 2,
}
impl StorageSystem {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STORAGE_SYSTEM_UNSPECIFIED",
            Self::CloudStorage => "CLOUD_STORAGE",
            Self::Bigquery => "BIGQUERY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STORAGE_SYSTEM_UNSPECIFIED" => Some(Self::Unspecified),
            "CLOUD_STORAGE" => Some(Self::CloudStorage),
            "BIGQUERY" => Some(Self::Bigquery),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod metadata_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Metadata service manages metadata resources such as tables, filesets and
    /// partitions.
    #[derive(Debug, Clone)]
    pub struct MetadataServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MetadataServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MetadataServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MetadataServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MetadataServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a metadata entity.
        pub async fn create_entity(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEntityRequest>,
        ) -> std::result::Result<tonic::Response<super::Entity>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/CreateEntity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "CreateEntity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a metadata entity. Only supports full resource update.
        pub async fn update_entity(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEntityRequest>,
        ) -> std::result::Result<tonic::Response<super::Entity>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/UpdateEntity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "UpdateEntity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a metadata entity.
        pub async fn delete_entity(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEntityRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/DeleteEntity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "DeleteEntity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a metadata entity.
        pub async fn get_entity(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEntityRequest>,
        ) -> std::result::Result<tonic::Response<super::Entity>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/GetEntity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "GetEntity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List metadata entities in a zone.
        pub async fn list_entities(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEntitiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEntitiesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/ListEntities",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "ListEntities",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a metadata partition.
        pub async fn create_partition(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePartitionRequest>,
        ) -> std::result::Result<tonic::Response<super::Partition>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/CreatePartition",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "CreatePartition",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a metadata partition.
        pub async fn delete_partition(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePartitionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/DeletePartition",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "DeletePartition",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a metadata partition of an entity.
        pub async fn get_partition(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPartitionRequest>,
        ) -> std::result::Result<tonic::Response<super::Partition>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/GetPartition",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "GetPartition",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List metadata partitions of an entity.
        pub async fn list_partitions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPartitionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPartitionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.dataplex.v1.MetadataService/ListPartitions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.dataplex.v1.MetadataService",
                        "ListPartitions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
