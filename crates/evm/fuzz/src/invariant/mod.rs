use alloy_dyn_abi::{DynSolValue, JsonAbiExt};
use alloy_json_abi::{Function, JsonAbi};
use alloy_primitives::{Address, Bytes};
use parking_lot::Mutex;
use std::{collections::BTreeMap, sync::Arc};

mod call_override;
pub use call_override::RandomCallGenerator;

mod filters;
pub use filters::{ArtifactFilters, SenderFilters};

pub type TargetedContracts = BTreeMap<Address, (String, JsonAbi, Vec<Function>)>;

/// Contracts identified as targets during a fuzz run.
/// During execution, any newly created contract is added as target and used through the rest of
/// the fuzz run if the collection is updatable (no `targetContract` specified in `setUp`).
#[derive(Clone, Debug)]
pub struct FuzzRunIdentifiedContracts {
    /// Contracts identified as targets during a fuzz run.
    pub targets: Arc<Mutex<TargetedContracts>>,
    /// Whether target contracts are updatable or not.
    pub is_updatable: bool,
}

impl FuzzRunIdentifiedContracts {
    pub fn new(targets: TargetedContracts, is_updatable: bool) -> Self {
        Self { targets: Arc::new(Mutex::new(targets)), is_updatable }
    }
}

/// Details of a transaction generated by invariant strategy for fuzzing a target.
#[derive(Clone, Debug)]
pub struct BasicTxDetails {
    // Transaction sender address.
    pub sender: Address,
    // Transaction call details.
    pub call_details: CallDetails,
}

impl BasicTxDetails {
    pub fn new(sender: Address, call_details: CallDetails) -> Self {
        Self { sender, call_details }
    }
}

/// Call details of a transaction generated to fuzz invariant target.
#[derive(Clone, Debug)]
pub struct CallDetails {
    // Target contract address.
    pub address: Address,
    // The data of the transaction.
    pub calldata: Bytes,
    // Target function, used to decode values from result and to create counterexample.
    pub function: Function,
}

impl CallDetails {
    pub fn new(address: Address, calldata: Bytes, function: Function) -> Self {
        Self { address, calldata, function }
    }

    // Returns args of the call (decoded from calldata).
    pub fn args(&self) -> Vec<DynSolValue> {
        // Skip the function selector when decoding.
        if let Ok(args) = self.function.abi_decode_input(&self.calldata[4..], false) {
            args
        } else {
            vec![]
        }
    }
}

/// Test contract which is testing its invariants.
#[derive(Clone, Debug)]
pub struct InvariantContract<'a> {
    /// Address of the test contract.
    pub address: Address,
    /// Invariant function present in the test contract.
    pub invariant_function: &'a Function,
    /// ABI of the test contract.
    pub abi: &'a JsonAbi,
}
