use foundry_test_utils::snapbox;

// tests complete bind-json workflow
// ensures that we can run forge-bind even if files are depending on yet non-existent bindings and
// that generated bindings are correct
forgetest_init!(test_bind_json, |prj, cmd| {
    prj.add_test(
        "JsonBindings",
        r#"
import {JsonBindings} from "utils/JsonBindings.sol";
import {Test} from "forge-std/Test.sol";

struct TopLevelStruct {
    uint256 param1;
    int8 param2;
}

contract BindJsonTest is Test {
    using JsonBindings for *;

    struct ContractLevelStruct {
        address[][] param1;
        address addrParam;
    }

    function testTopLevel() public {
        string memory json = '{"param1": 1, "param2": -1}';
        TopLevelStruct memory topLevel = json.deserializeTopLevelStruct();
        assertEq(topLevel.param1, 1);
        assertEq(topLevel.param2, -1);

        json = topLevel.serialize();
        TopLevelStruct memory deserialized = json.deserializeTopLevelStruct();
        assertEq(keccak256(abi.encode(deserialized)), keccak256(abi.encode(topLevel)));
    }

    function testContractLevel() public {
        ContractLevelStruct memory contractLevel = ContractLevelStruct({
            param1: new address[][](2),
            addrParam: address(0xBEEF)
        });

        string memory json = contractLevel.serialize();
        assertEq(json, '{"param1":[[],[]],"addrParam":"0x000000000000000000000000000000000000bEEF"}');

        ContractLevelStruct memory deserialized = json.deserializeContractLevelStruct();
        assertEq(keccak256(abi.encode(deserialized)), keccak256(abi.encode(contractLevel)));
    }
}
"#,
    );

    cmd.arg("bind-json").assert_success();

    snapbox::assert_data_eq!(
        snapbox::Data::read_from(&prj.root().join("utils/JsonBindings.sol"), None),
        snapbox::str![[r#"
// Automatically generated by forge bind-json.

pragma solidity >=0.6.2 <0.9.0;
pragma experimental ABIEncoderV2;

import {BindJsonTest, TopLevelStruct} from "test/JsonBindings.sol";

interface Vm {
    function parseJsonTypeArray(string calldata json, string calldata key, string calldata typeDescription) external pure returns (bytes memory);
    function parseJsonType(string calldata json, string calldata typeDescription) external pure returns (bytes memory);
    function parseJsonType(string calldata json, string calldata key, string calldata typeDescription) external pure returns (bytes memory);
    function serializeJsonType(string calldata typeDescription, bytes memory value) external pure returns (string memory json);
    function serializeJsonType(string calldata objectKey, string calldata valueKey, string calldata typeDescription, bytes memory value) external returns (string memory json);
}

library JsonBindings {
    Vm constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));

    string constant schema_TopLevelStruct = "TopLevelStruct(uint256 param1,int8 param2)";
    string constant schema_ContractLevelStruct = "ContractLevelStruct(address[][] param1,address addrParam)";

    function serialize(TopLevelStruct memory value) internal pure returns (string memory) {
        return vm.serializeJsonType(schema_TopLevelStruct, abi.encode(value));
    }

    function serialize(TopLevelStruct memory value, string memory objectKey, string memory valueKey) internal returns (string memory) {
        return vm.serializeJsonType(objectKey, valueKey, schema_TopLevelStruct, abi.encode(value));
    }

    function deserializeTopLevelStruct(string memory json) public pure returns (TopLevelStruct memory) {
        return abi.decode(vm.parseJsonType(json, schema_TopLevelStruct), (TopLevelStruct));
    }

    function deserializeTopLevelStruct(string memory json, string memory path) public pure returns (TopLevelStruct memory) {
        return abi.decode(vm.parseJsonType(json, path, schema_TopLevelStruct), (TopLevelStruct));
    }

    function deserializeTopLevelStructArray(string memory json, string memory path) public pure returns (TopLevelStruct[] memory) {
        return abi.decode(vm.parseJsonTypeArray(json, path, schema_TopLevelStruct), (TopLevelStruct[]));
    }

    function serialize(BindJsonTest.ContractLevelStruct memory value) internal pure returns (string memory) {
        return vm.serializeJsonType(schema_ContractLevelStruct, abi.encode(value));
    }

    function serialize(BindJsonTest.ContractLevelStruct memory value, string memory objectKey, string memory valueKey) internal returns (string memory) {
        return vm.serializeJsonType(objectKey, valueKey, schema_ContractLevelStruct, abi.encode(value));
    }

    function deserializeContractLevelStruct(string memory json) public pure returns (BindJsonTest.ContractLevelStruct memory) {
        return abi.decode(vm.parseJsonType(json, schema_ContractLevelStruct), (BindJsonTest.ContractLevelStruct));
    }

    function deserializeContractLevelStruct(string memory json, string memory path) public pure returns (BindJsonTest.ContractLevelStruct memory) {
        return abi.decode(vm.parseJsonType(json, path, schema_ContractLevelStruct), (BindJsonTest.ContractLevelStruct));
    }

    function deserializeContractLevelStructArray(string memory json, string memory path) public pure returns (BindJsonTest.ContractLevelStruct[] memory) {
        return abi.decode(vm.parseJsonTypeArray(json, path, schema_ContractLevelStruct), (BindJsonTest.ContractLevelStruct[]));
    }
}

"#]],
    );

    cmd.forge_fuse().args(["test"]).assert_success();
});

// tests enhanced `vm.parseJson` and `vm.serializeJson` cheatcodes, which are not constrained to
// alphabetical ordering of struct keys, but rather respect the Solidity struct definition.
forgetest_init!(test_parse_json, |prj, cmd| {
    prj.add_test(
        "JsonCheats",
        r#"
import {Test} from "forge-std/Test.sol";

// Definition order: color, sweetness, sourness
// Alphabetical order: color, sourness, sweetness
struct Apple {
    string color;
    uint8 sweetness;
    uint8 sourness;
}

// Definition order: name, apples
// Alphabetical order: apples, name
struct FruitStall {
    string name;
    Apple[] apples;
}

contract SimpleJsonCheatsTest is Test {
    function testJsonParseAndSerialize() public {
        // Initial JSON has keys in a custom order, different from definition and alphabetical.
        string memory originalJson =
            '{"name":"Fresh Fruit","apples":[{"sweetness":7,"sourness":3,"color":"Red"},{"sweetness":5,"sourness":5,"color":"Green"}]}';

        // Parse the original JSON. The parser should correctly handle the unordered keys.
        bytes memory decoded = vm.parseJson(originalJson);
        FruitStall memory originalType = abi.decode(decoded, (FruitStall));

        // Assert initial parsing is correct
        assertEq(originalType.name, "Fresh Fruit");
        assertEq(originalType.apples[0].color, "Red");
        assertEq(originalType.apples[0].sweetness, 7);
        assertEq(originalType.apples[1].sourness, 5);

        // Serialize the struct back to JSON. `vm.serializeJson` should respect the order for all keys.
        string memory serializedJson = vm.serializeJsonType(
            "FruitStall(Apple[] apples,string name)Apple(string color,uint8 sourness,uint8 sweetness)",
            abi.encode(originalType)
        );

        // The expected JSON should have keys ordered according to the struct definitions.
        string memory expectedJson =
            '{"name":"Fresh Fruit","apples":[{"color":"Red","sweetness":7,"sourness":3},{"color":"Green","sweetness":5,"sourness":5}]}';
        assertEq(serializedJson, expectedJson);

        // Parse the newly serialized JSON to complete the cycle.
        bytes memory redecoded = vm.parseJson(serializedJson);
        FruitStall memory finalType = abi.decode(redecoded, (FruitStall));

        // Assert that the struct from the full cycle is identical to the original parsed struct.
        assertEq(keccak256(abi.encode(finalType)), keccak256(abi.encode(originalType)));
    }
}
"#,
    );

    // Directly run the test. No `bind-json` or type schemas are needed.
    cmd.forge_fuse().args(["test"]).assert_success();
});
